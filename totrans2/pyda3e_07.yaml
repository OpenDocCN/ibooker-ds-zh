- en: '4  NumPy Basics: Arrays and Vectorized Computation'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 NumPy基础知识：数组和向量化计算
- en: 原文：[https://wesmckinney.com/book/numpy-basics](https://wesmckinney.com/book/numpy-basics)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://wesmckinney.com/book/numpy-basics](https://wesmckinney.com/book/numpy-basics)
- en: '*This Open Access web version of *Python for Data Analysis 3rd Edition* is
    now available as a companion to the [print and digital editions](https://amzn.to/3DyLaJc).
    If you encounter any errata, [please report them here](https://oreilly.com/catalog/0636920519829/errata).
    Please note that some aspects of this site as produced by Quarto will differ from
    the formatting of the print and eBook versions from O’Reilly.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*本开放获取的网络版本*Python for Data Analysis第3版*现已作为[印刷版和数字版](https://amzn.to/3DyLaJc)的伴侣提供。如果您遇到任何勘误，请[在此处报告](https://oreilly.com/catalog/0636920519829/errata)。请注意，由Quarto生成的本站的某些方面将与O''Reilly的印刷版和电子书版本的格式不同。'
- en: If you find the online edition of the book useful, please consider [ordering
    a paper copy](https://amzn.to/3DyLaJc) or a [DRM-free eBook](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)
    to support the author. The content from this website may not be copied or reproduced.
    The code examples are MIT licensed and can be found on GitHub or Gitee.*  *NumPy,
    short for Numerical Python, is one of the most important foundational packages
    for numerical computing in Python. Many computational packages providing scientific
    functionality use NumPy's array objects as one of the standard interface *lingua
    francas* for data exchange. Much of the knowledge about NumPy that I cover is
    transferable to pandas as well.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现本书的在线版本有用，请考虑[订购纸质版](https://amzn.to/3DyLaJc)或[无DRM的电子书](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)以支持作者。本网站的内容不得复制或复制。代码示例采用MIT许可证，可在GitHub或Gitee上找到。*
    *NumPy，即Numerical Python，是Python中最重要的数值计算基础包之一。许多提供科学功能的计算包使用NumPy的数组对象作为数据交换的标准接口之一。我涵盖的关于NumPy的许多知识也适用于pandas。
- en: 'Here are some of the things you''ll find in NumPy:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您将在NumPy中找到的一些内容：
- en: ndarray, an efficient multidimensional array providing fast array-oriented arithmetic
    operations and flexible *broadcasting* capabilities
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ndarray，一种高效的多维数组，提供快速的基于数组的算术运算和灵活的广播功能
- en: Mathematical functions for fast operations on entire arrays of data without
    having to write loops
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于在整个数据数组上快速操作的数学函数，而无需编写循环
- en: Tools for reading/writing array data to disk and working with memory-mapped
    files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于读取/写入数组数据到磁盘和处理内存映射文件的工具
- en: Linear algebra, random number generation, and Fourier transform capabilities
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性代数、随机数生成和傅里叶变换功能
- en: A C API for connecting NumPy with libraries written in C, C++, or FORTRAN
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于将NumPy与用C、C++或FORTRAN编写的库连接的C API
- en: Because NumPy provides a comprehensive and well-documented C API, it is straightforward
    to pass data to external libraries written in a low-level language, and for external
    libraries to return data to Python as NumPy arrays. This feature has made Python
    a language of choice for wrapping legacy C, C++, or FORTRAN codebases and giving
    them a dynamic and accessible interface.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于NumPy提供了全面且有文档的C API，因此将数据传递给用低级语言编写的外部库，以及让外部库将数据作为NumPy数组返回给Python是很简单的。这个特性使Python成为封装传统C、C++或FORTRAN代码库并为其提供动态和可访问接口的首选语言。
- en: 'While NumPy by itself does not provide modeling or scientific functionality,
    having an understanding of NumPy arrays and array-oriented computing will help
    you use tools with array computing semantics, like pandas, much more effectively.
    Since NumPy is a large topic, I will cover many advanced NumPy features like broadcasting
    in more depth later (see [Appendix A: Advanced NumPy](/book/advanced-numpy)).
    Many of these advanced features are not needed to follow the rest of this book,
    but they may help you as you go deeper into scientific computing in Python.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然NumPy本身并不提供建模或科学功能，但了解NumPy数组和面向数组的计算将帮助您更有效地使用具有数组计算语义的工具，如pandas。由于NumPy是一个庞大的主题，我将在以后更深入地涵盖许多高级NumPy功能，比如广播（参见[附录A：高级NumPy](/book/advanced-numpy)）。这些高级功能中的许多并不需要遵循本书的其余部分，但在您深入研究Python科学计算时可能会有所帮助。
- en: 'For most data analysis applications, the main areas of functionality I’ll focus
    on are:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数数据分析应用程序，我将关注的主要功能领域是：
- en: Fast array-based operations for data munging and cleaning, subsetting and filtering,
    transformation, and any other kind of computation
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于数据整理和清洗、子集和过滤、转换以及任何其他类型计算的快速基于数组的操作
- en: Common array algorithms like sorting, unique, and set operations
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的数组算法，如排序、唯一值和集合操作
- en: Efficient descriptive statistics and aggregating/summarizing data
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效的描述统计和聚合/汇总数据
- en: Data alignment and relational data manipulations for merging and joining heterogeneous
    datasets
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据对齐和关系数据操作，用于合并和连接异构数据集
- en: Expressing conditional logic as array expressions instead of loops with `if-elif-else`
    branches
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将条件逻辑表达为数组表达式，而不是使用`if-elif-else`分支循环
- en: Group-wise data manipulations (aggregation, transformation, and function application)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分组数据操作（聚合、转换和函数应用）
- en: While NumPy provides a computational foundation for general numerical data processing,
    many readers will want to use pandas as the basis for most kinds of statistics
    or analytics, especially on tabular data. Also, pandas provides some more domain-specific
    functionality like time series manipulation, which is not present in NumPy.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然NumPy为一般数值数据处理提供了计算基础，但许多读者将希望使用pandas作为大多数统计或分析的基础，尤其是在表格数据上。此外，pandas还提供了一些更具领域特定功能，如时间序列操作，这在NumPy中不存在。
- en: '*Note* *Array-oriented computing in Python traces its roots back to 1995, when
    Jim Hugunin created the Numeric library. Over the next 10 years, many scientific
    programming communities began doing array programming in Python, but the library
    ecosystem had become fragmented in the early 2000s. In 2005, Travis Oliphant was
    able to forge the NumPy project from the then Numeric and Numarray projects to
    bring the community together around a single array computing framework.*  *One
    of the reasons NumPy is so important for numerical computations in Python is because
    it is designed for efficiency on large arrays of data. There are a number of reasons
    for this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *Python中的面向数组计算可以追溯到1995年，当时Jim Hugunin创建了Numeric库。在接下来的10年里，许多科学编程社区开始在Python中进行数组编程，但在2000年代初，库生态系统变得分散。2005年，Travis
    Oliphant能够从当时的Numeric和Numarray项目中打造出NumPy项目，将社区团结在一个单一的数组计算框架周围。*  *NumPy在Python中进行数值计算如此重要的原因之一是因为它专为大型数据数组的效率而设计。这有几个原因：*'
- en: NumPy internally stores data in a contiguous block of memory, independent of
    other built-in Python objects. NumPy's library of algorithms written in the C
    language can operate on this memory without any type checking or other overhead.
    NumPy arrays also use much less memory than built-in Python sequences.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy在内部以连续的内存块存储数据，独立于其他内置Python对象。NumPy的用C语言编写的算法库可以在这个内存上操作，而无需进行任何类型检查或其他开销。NumPy数组也比内置Python序列使用更少的内存。
- en: NumPy operations perform complex computations on entire arrays without the need
    for Python `for` loops, which can be slow for large sequences. NumPy is faster
    than regular Python code because its C-based algorithms avoid overhead present
    with regular interpreted Python code.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy操作在整个数组上执行复杂计算，无需Python `for`循环，对于大型序列来说，这可能会很慢。NumPy比常规Python代码更快，因为它的基于C的算法避免了常规解释Python代码的开销。
- en: 'To give you an idea of the performance difference, consider a NumPy array of
    one million integers, and the equivalent Python list:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您了解性能差异，考虑一个包含一百万个整数的NumPy数组，以及等效的Python列表：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now let''s multiply each sequence by 2:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将每个序列乘以2：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: NumPy-based algorithms are generally 10 to 100 times faster (or more) than their
    pure Python counterparts and use significantly less memory.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 基于NumPy的算法通常比纯Python对应算法快10到100倍（或更多），并且使用的内存明显更少。
- en: '4.1 The NumPy ndarray: A Multidimensional Array Object'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 NumPy ndarray：多维数组对象
- en: One of the key features of NumPy is its N-dimensional array object, or ndarray,
    which is a fast, flexible container for large datasets in Python. Arrays enable
    you to perform mathematical operations on whole blocks of data using similar syntax
    to the equivalent operations between scalar elements.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy的一个关键特性是其N维数组对象，或者ndarray，它是Python中大型数据集的快速、灵活的容器。数组使您能够使用类似标量元素之间等效操作的语法在整个数据块上执行数学运算。
- en: 'To give you a flavor of how NumPy enables batch computations with similar syntax
    to scalar values on built-in Python objects, I first import NumPy and create a
    small array:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您了解NumPy如何使用类似标量值的语法在内置Python对象上进行批量计算，我首先导入NumPy并创建一个小数组：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'I then write mathematical operations with `data`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我用`data`编写数学运算：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the first example, all of the elements have been multiplied by 10\. In the
    second, the corresponding values in each "cell" in the array have been added to
    each other.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，所有元素都乘以了10。在第二个示例中，数组中每个“单元格”中的相应值已经相加。
- en: '*Note* *In this chapter and throughout the book, I use the standard NumPy convention
    of always using `import numpy as np`. It would be possible to put `from numpy
    import *` in your code to avoid having to write `np.`, but I advise against making
    a habit of this. The `numpy` namespace is large and contains a number of functions
    whose names conflict with built-in Python functions (like `min` and `max`). Following
    standard conventions like these is almost always a good idea.*  *An ndarray is
    a generic multidimensional container for homogeneous data; that is, all of the
    elements must be the same type. Every array has a `shape`, a tuple indicating
    the size of each dimension, and a `dtype`, an object describing the *data type*
    of the array:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *在本章和整本书中，我使用标准的NumPy约定，始终使用`import numpy as np`。您可以在代码中使用`from numpy
    import *`来避免编写`np.`，但我建议不要养成这种习惯。`numpy`命名空间很大，包含许多函数，它们的名称与内置Python函数（如`min`和`max`）冲突。遵循这些标准约定几乎总是一个好主意。*  *ndarray是一个用于同质数据的通用多维容器；也就是说，所有元素必须是相同类型。每个数组都有一个`shape`，一个指示每个维度大小的元组，以及一个`dtype`，描述数组的*数据类型*的对象：'
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This chapter will introduce you to the basics of using NumPy arrays, and it
    should be sufficient for following along with the rest of the book. While it’s
    not necessary to have a deep understanding of NumPy for many data analytical applications,
    becoming proficient in array-oriented programming and thinking is a key step along
    the way to becoming a scientific Python guru.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍使用NumPy数组的基础知识，这应该足以跟随本书的其余部分。虽然对于许多数据分析应用程序来说，深入了解NumPy并不是必需的，但精通面向数组的编程和思维是成为科学Python大师的关键步骤。
- en: '*Note* *Whenever you see “array,” “NumPy array,” or “ndarray” in the book text,
    in most cases they all refer to the ndarray object.*  *### Creating ndarrays'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *在书中文本中，每当您看到“array”，“NumPy array”或“ndarray”时，在大多数情况下它们都指的是ndarray对象。*  *###
    创建ndarrays'
- en: 'The easiest way to create an array is to use the `array` function. This accepts
    any sequence-like object (including other arrays) and produces a new NumPy array
    containing the passed data. For example, a list is a good candidate for conversion:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组的最简单方法是使用`array`函数。它接受任何类似序列的对象（包括其他数组）并生成包含传递数据的新NumPy数组。例如，列表是一个很好的转换候选：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Nested sequences, like a list of equal-length lists, will be converted into
    a multidimensional array:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套序列，比如等长列表的列表，将被转换为多维数组：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since `data2` was a list of lists, the NumPy array `arr2` has two dimensions,
    with shape inferred from the data. We can confirm this by inspecting the `ndim`
    and `shape` attributes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`data2`是一个列表的列表，NumPy数组`arr2`具有两个维度，形状从数据中推断出。我们可以通过检查`ndim`和`shape`属性来确认这一点：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Unless explicitly specified (discussed in [Data Types for ndarrays](#numpy_dtypes)),
    `numpy.array` tries to infer a good data type for the array that it creates. The
    data type is stored in a special `dtype` metadata object; for example, in the
    previous two examples we have:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除非明确指定（在[ndarrays的数据类型](#numpy_dtypes)中讨论），`numpy.array`会尝试推断创建的数组的良好数据类型。数据类型存储在特殊的`dtype`元数据对象中；例如，在前两个示例中我们有：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In addition to `numpy.array`, there are a number of other functions for creating
    new arrays. As examples, `numpy.zeros` and `numpy.ones` create arrays of 0s or
    1s, respectively, with a given length or shape. `numpy.empty` creates an array
    without initializing its values to any particular value. To create a higher dimensional
    array with these methods, pass a tuple for the shape:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`numpy.array`之外，还有许多其他用于创建新数组的函数。例如，`numpy.zeros`和`numpy.ones`分别创建长度或形状为0或1的数组。`numpy.empty`创建一个数组，而不将其值初始化为任何特定值。要使用这些方法创建更高维度的数组，请传递一个形状的元组：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Caution* *It’s not safe to assume that `numpy.empty` will return an array
    of all zeros. This function returns uninitialized memory and thus may contain
    nonzero "garbage" values. You should use this function only if you intend to populate
    the new array with data.*  *`numpy.arange` is an array-valued version of the built-in
    Python `range` function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *不能假设`numpy.empty`会返回一个全为零的数组。该函数返回未初始化的内存，因此可能包含非零的“垃圾”值。只有在打算用数据填充新数组时才应使用此函数。*
    *`numpy.arange`是内置Python `range`函数的数组版本：'
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: See [Table 4.1](#tbl-table_array_ctor) for a short list of standard array creation
    functions. Since NumPy is focused on numerical computing, the data type, if not
    specified, will in many cases be `float64` (floating point).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[表4.1](#tbl-table_array_ctor)中的一些标准数组创建函数的简要列表。由于NumPy专注于数值计算，如果未指定数据类型，数据类型在许多情况下将是`float64`（浮点数）。
- en: 'Table 4.1: Some important NumPy array creation functions'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1：一些重要的NumPy数组创建函数
- en: '| Function | Description |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `array` | Convert input data (list, tuple, array, or other sequence type)
    to an ndarray either by inferring a data type or explicitly specifying a data
    type; copies the input data by default |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `array` | 将输入数据（列表、元组、数组或其他序列类型）转换为ndarray，可以通过推断数据类型或显式指定数据类型来完成；默认情况下会复制输入数据
    |'
- en: '| `asarray` | Convert input to ndarray, but do not copy if the input is already
    an ndarray |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `asarray` | 将输入转换为ndarray，如果输入已经是ndarray，则不复制 |'
- en: '| `arange` | Like the built-in `range` but returns an ndarray instead of a
    list |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `arange` | 类似于内置的`range`，但返回一个ndarray而不是列表 |'
- en: '| `ones, ones_like` | Produce an array of all 1s with the given shape and data
    type; `ones_like` takes another array and produces a `ones` array of the same
    shape and data type |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `ones, ones_like` | 生成所有值为1的数组，具有给定的形状和数据类型；`ones_like`接受另一个数组，并生成相同形状和数据类型的`ones`数组
    |'
- en: '| `zeros, zeros_like` | Like `ones` and `ones_like` but producing arrays of
    0s instead |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `zeros, zeros_like` | 类似于`ones`和`ones_like`，但生成的是全为0的数组 |'
- en: '| `empty, empty_like` | Create new arrays by allocating new memory, but do
    not populate with any values like `ones` and `zeros` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `empty, empty_like` | 通过分配新内存创建新数组，但不像`ones`和`zeros`那样填充任何值 |'
- en: '| `full, full_like` | Produce an array of the given shape and data type with
    all values set to the indicated "fill value"; `full_like` takes another array
    and produces a filled array of the same shape and data type |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `full, full_like` | 生成具有给定形状和数据类型的数组，所有值都设置为指定的“填充值”；`full_like`接受另一个数组，并生成相同形状和数据类型的填充数组
    |'
- en: '| `eye, identity` | Create a square N × N identity matrix (1s on the diagonal
    and 0s elsewhere) |*  *### Data Types for ndarrays'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '| `eye, identity` | 创建一个N×N的方阵单位矩阵（对角线上为1，其他地方为0） |*  *### ndarrays的数据类型'
- en: 'The *data type* or `dtype` is a special object containing the information (or
    *metadata*, data about data) the ndarray needs to interpret a chunk of memory
    as a particular type of data:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据类型*或`dtype`是一个特殊对象，包含ndarray需要将内存块解释为特定类型数据的信息（或*元数据*，关于数据的数据）：'
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Data types are a source of NumPy''s flexibility for interacting with data coming
    from other systems. In most cases they provide a mapping directly onto an underlying
    disk or memory representation, which makes it possible to read and write binary
    streams of data to disk and to connect to code written in a low-level language
    like C or FORTRAN. The numerical data types are named the same way: a type name,
    like `float` or `int`, followed by a number indicating the number of bits per
    element. A standard double-precision floating-point value (what’s used under the
    hood in Python’s `float` object) takes up 8 bytes or 64 bits. Thus, this type
    is known in NumPy as `float64`. See [Table 4.2](#tbl-table_array_dtypes) for a
    full listing of NumPy’s supported data types.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型是NumPy灵活性的来源，用于与来自其他系统的数据进行交互。在大多数情况下，它们直接映射到底层磁盘或内存表示，这使得可以将数据的二进制流读写到磁盘，并连接到用低级语言（如C或FORTRAN）编写的代码。数值数据类型的命名方式相同：类型名称，如`float`或`int`，后跟表示每个元素的位数的数字。标准的双精度浮点值（Python中`float`对象底层使用的）占用8字节或64位。因此，在NumPy中，此类型称为`float64`。请参见[表4.2](#tbl-table_array_dtypes)以获取NumPy支持的数据类型的完整列表。
- en: '*Note* *Don’t worry about memorizing the NumPy data types, especially if you’re
    a new user. It’s often only necessary to care about the general *kind* of data
    you’re dealing with, whether floating point, complex, integer, Boolean, string,
    or general Python object. When you need more control over how data is stored in
    memory and on disk, especially large datasets, it is good to know that you have
    control over the storage type.*  *Table 4.2: NumPy data types'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *不要担心记住NumPy数据类型，特别是如果您是新用户。通常只需要关心您正在处理的数据的一般*类型*，无论是浮点数、复数、整数、布尔值、字符串还是一般的Python对象。当您需要更多控制数据在内存和磁盘上的存储方式，特别是对于大型数据集时，知道您可以控制存储类型是很好的。*
    *表4.2：NumPy数据类型'
- en: '| Type | Type code | Description |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 类型代码 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `int8, uint8` | `i1, u1` | Signed and unsigned 8-bit (1 byte) integer types
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `int8, uint8` | `i1, u1` | 有符号和无符号8位（1字节）整数类型 |'
- en: '| `int16, uint16` | `i2, u2` | Signed and unsigned 16-bit integer types |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `int16, uint16` | `i2, u2` | 有符号和无符号16位整数类型 |'
- en: '| `int32, uint32` | `i4, u4` | Signed and unsigned 32-bit integer types |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `int32, uint32` | `i4, u4` | 有符号和无符号32位整数类型 |'
- en: '| `int64, uint64` | `i8, u8` | Signed and unsigned 64-bit integer types |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `int64, uint64` | `i8, u8` | 有符号和无符号64位整数类型 |'
- en: '| `float16` | `f2` | Half-precision floating point |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `float16` | `f2` | 半精度浮点数 |'
- en: '| `float32` | `f4 or f` | Standard single-precision floating point; compatible
    with C float |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `float32` | `f4或f` | 标准单精度浮点数；与C浮点兼容 |'
- en: '| `float64` | `f8 or d` | Standard double-precision floating point; compatible
    with C double and Python `float` object |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `float64` | `f8或d` | 标准双精度浮点数；与C双精度和Python `float`对象兼容 |'
- en: '| `float128` | `f16 or g` | Extended-precision floating point |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `float128` | `f16或g` | 扩展精度浮点数 |'
- en: '| `complex64`, `complex128`, `complex256` | `c8, c16, c32` | Complex numbers
    represented by two 32, 64, or 128 floats, respectively |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `complex64`，`complex128`，`complex256` | `c8, c16, c32` | 分别由两个32、64或128个浮点数表示的复数
    |'
- en: '| `bool` | ? | Boolean type storing `True` and `False` values |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | ? | 存储`True`和`False`值的布尔类型 |'
- en: '| `object` | O | Python object type; a value can be any Python object |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `object` | O | Python对象类型；值可以是任何Python对象 |'
- en: '| `string_` | S | Fixed-length ASCII string type (1 byte per character); for
    example, to create a string data type with length 10, use `''S10''` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `string_` | S | 固定长度ASCII字符串类型（每个字符1字节）；例如，要创建长度为10的字符串数据类型，请使用`''S10''`
    |'
- en: '| `unicode_` | U | Fixed-length Unicode type (number of bytes platform specific);
    same specification semantics as `string_` (e.g., `''U10''`) |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `unicode_` | U | 固定长度Unicode类型（字节数平台特定）；与`string_`（例如，`''U10''`）具有相同的规范语义
    |'
- en: '*Note* *There are both *signed* and *unsigned* integer types, and many readers
    will not be familiar with this terminology. A *signed* integer can represent both
    positive and negative integers, while an *unsigned* integer can only represent
    nonzero integers. For example, `int8` (signed 8-bit integer) can represent integers
    from -128 to 127 (inclusive), while `uint8` (unsigned 8-bit integer) can represent
    0 through 255.*  *You can explicitly convert or *cast* an array from one data
    type to another using ndarray’s `astype` method:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *有*有符号*和*无符号*整数类型，许多读者可能不熟悉这个术语。*有符号*整数可以表示正整数和负整数，而*无符号*整数只能表示非零整数。例如，`int8`（有符号8位整数）可以表示从-128到127（包括）的整数，而`uint8`（无符号8位整数）可以表示0到255。*
    *您可以使用ndarray的`astype`方法显式地将数组从一种数据类型转换为另一种数据类型：'
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this example, integers were cast to floating point. If I cast some floating-point
    numbers to be of integer data type, the decimal part will be truncated:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，整数被转换为浮点数。如果我将一些浮点数转换为整数数据类型，小数部分将被截断：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you have an array of strings representing numbers, you can use `astype`
    to convert them to numeric form:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个表示数字的字符串数组，可以使用`astype`将它们转换为数值形式：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Caution* *Be cautious when using the `numpy.string_` type, as string data
    in NumPy is fixed size and may truncate input without warning. pandas has more
    intuitive out-of-the-box behavior on non-numeric data.*  *If casting were to fail
    for some reason (like a string that cannot be converted to `float64`), a `ValueError`
    will be raised. Before, I was a bit lazy and wrote `float` instead of `np.float64`;
    NumPy aliases the Python types to its own equivalent data types.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *在使用`numpy.string_`类型时要小心，因为NumPy中的字符串数据是固定大小的，可能会在没有警告的情况下截断输入。pandas对非数值数据具有更直观的开箱即用行为。*
    *如果由于某种原因（例如无法将字符串转换为`float64`）而转换失败，将引发`ValueError`。以前，我有点懒，写了`float`而不是`np.float64`；NumPy将Python类型别名为其自己的等效数据类型。'
- en: 'You can also use another array’s `dtype` attribute:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用另一个数组的`dtype`属性：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are shorthand type code strings you can also use to refer to a `dtype`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有简写类型代码字符串，您也可以使用它们来引用`dtype`：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Note* *Calling `astype` *always* creates a new array (a copy of the data),
    even if the new data type is the same as the old data type.****  ***### Arithmetic
    with NumPy Arrays'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *调用`astype` *总是*会创建一个新数组（数据的副本），即使新数据类型与旧数据类型相同。****  ***### NumPy数组的算术运算'
- en: 'Arrays are important because they enable you to express batch operations on
    data without writing any `for` loops. NumPy users call this *vectorization*. Any
    arithmetic operations between equal-size arrays apply the operation element-wise:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 数组很重要，因为它们使您能够在不编写任何`for`循环的情况下对数据执行批量操作。NumPy用户称之为*向量化*。任何等大小数组之间的算术运算都会逐元素应用该操作：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Arithmetic operations with scalars propagate the scalar argument to each element
    in the array:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 标量的算术运算会将标量参数传播到数组中的每个元素：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Comparisons between arrays of the same size yield Boolean arrays:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 相同大小的数组之间的比较会产生布尔数组：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Evaluating operations between differently sized arrays is called *broadcasting*
    and will be discussed in more detail in [Appendix A: Advanced NumPy](/book/advanced-numpy).
    Having a deep understanding of broadcasting is not necessary for most of this
    book.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同大小的数组之间进行操作被称为*广播*，将在[附录A：高级NumPy](/book/advanced-numpy)中更详细地讨论。对广播的深入理解对本书的大部分内容并不是必要的。
- en: Basic Indexing and Slicing
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本索引和切片
- en: 'NumPy array indexing is a deep topic, as there are many ways you may want to
    select a subset of your data or individual elements. One-dimensional arrays are
    simple; on the surface they act similarly to Python lists:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, if you assign a scalar value to a slice, as in `arr[5:8] = 12`,
    the value is propagated (or *broadcast* henceforth) to the entire selection.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '*Note* *An important first distinction from Python''s built-in lists is that
    array slices are views on the original array. This means that the data is not
    copied, and any modifications to the view will be reflected in the source array.*  *To
    give an example of this, I first create a slice of `arr`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, when I change values in `arr_slice`, the mutations are reflected in the
    original array `arr`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The "bare" slice `[:]` will assign to all values in an array:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you are new to NumPy, you might be surprised by this, especially if you have
    used other array programming languages that copy data more eagerly. As NumPy has
    been designed to be able to work with very large arrays, you could imagine performance
    and memory problems if NumPy insisted on always copying data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '*Caution* *If you want a copy of a slice of an ndarray instead of a view, you
    will need to explicitly copy the array—for example, `arr[5:8].copy()`. As you
    will see, pandas works this way, too.*  *With higher dimensional arrays, you have
    many more options. In a two-dimensional array, the elements at each index are
    no longer scalars but rather one-dimensional arrays:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Thus, individual elements can be accessed recursively. But that is a bit too
    much work, so you can pass a comma-separated list of indices to select individual
    elements. So these are equivalent:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See [Figure 4.1](#fig-figure_ndarray_indexing) for an illustration of indexing
    on a two-dimensional array. I find it helpful to think of axis 0 as the "rows"
    of the array and axis 1 as the "columns."
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a09620216e4172a26b3283ca34ce702c.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Indexing elements in a NumPy array'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'In multidimensional arrays, if you omit later indices, the returned object
    will be a lower dimensional ndarray consisting of all the data along the higher
    dimensions. So in the 2 × 2 × 3 array `arr3d`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`arr3d[0]` is a 2 × 3 array:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Both scalar values and arrays can be assigned to `arr3d[0]`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Similarly, `arr3d[1, 0]` gives you all of the values whose indices start with
    `(1, 0)`, forming a one-dimensional array:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This expression is the same as though we had indexed in two steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that in all of these cases where subsections of the array have been selected,
    the returned arrays are views.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '*Caution* *This multidimensional indexing syntax for NumPy arrays will not
    work with regular Python objects, such as lists of lists.*  *#### Indexing with
    slices'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Like one-dimensional objects such as Python lists, ndarrays can be sliced with
    the familiar syntax:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Consider the two-dimensional array from before, `arr2d`. Slicing this array
    is a bit different:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, it has sliced along axis 0, the first axis. A slice, therefore,
    selects a range of elements along an axis. It can be helpful to read the expression
    `arr2d[:2]` as "select the first two rows of `arr2d`."
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'You can pass multiple slices just like you can pass multiple indexes:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When slicing like this, you always obtain array views of the same number of
    dimensions. By mixing integer indexes and slices, you get lower dimensional slices.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, I can select the second row but only the first two columns, like
    so:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, while `arr2d` is two-dimensional, `lower_dim_slice` is one-dimensional,
    and its shape is a tuple with one axis size:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Similarly, I can select the third column but only the first two rows, like
    so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'See [Figure 4.2](#fig-figure_ndarray_slicing) for an illustration. Note that
    a colon by itself means to take the entire axis, so you can slice only higher
    dimensional axes by doing:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Of course, assigning to a slice expression assigns to the whole selection:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![](../Images/ae89dd22b1516b02323b63614b75f260.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Two-dimensional array slicing***  ***### Boolean Indexing'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：二维数组切片*** ***### 布尔索引
- en: 'Let’s consider an example where we have some data in an array and an array
    of names with duplicates:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子，其中我们有一些数据在一个数组中，并且有一个包含重复名称的数组：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Suppose each name corresponds to a row in the `data` array and we wanted to
    select all the rows with the corresponding name `"Bob"`. Like arithmetic operations,
    comparisons (such as `==`) with arrays are also vectorized. Thus, comparing `names`
    with the string `"Bob"` yields a Boolean array:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 假设每个名称对应于`data`数组中的一行，并且我们想要选择所有与相应名称`"Bob"`相对应的行。与算术运算一样，与数组进行比较（如`==`）也是矢量化的。因此，将`names`与字符串`"Bob"`进行比较会产生一个布尔数组：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This Boolean array can be passed when indexing the array:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此布尔数组可以在索引数组时传递：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The Boolean array must be of the same length as the array axis it’s indexing.
    You can even mix and match Boolean arrays with slices or integers (or sequences
    of integers; more on this later).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔数组的长度必须与其索引的数组轴的长度相同。甚至可以将布尔数组与切片或整数（或整数序列）混合使用（稍后将详细介绍）。
- en: 'In these examples, I select from the rows where `names == "Bob"` and index
    the columns, too:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，我从`names == "Bob"`的行中选择，并且也索引列：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To select everything but `"Bob"` you can either use `!=` or negate the condition
    using `~`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择除了`"Bob"`之外的所有内容，可以使用`!=`或使用`~`否定条件：
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `~` operator can be useful when you want to invert a Boolean array referenced
    by a variable:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要反转由变量引用的布尔数组时，`~`运算符可能很有用：
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To select two of the three names to combine multiple Boolean conditions, use
    Boolean arithmetic operators like `&` (and) and `|` (or):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用布尔运算符如`&`（和）和`|`（或）选择三个名称中的两个来组合多个布尔条件：
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Selecting data from an array by Boolean indexing and assigning the result to
    a new variable *always* creates a copy of the data, even if the returned array
    is unchanged.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过布尔索引从数组中选择数据并将结果分配给新变量*始终*会创建数据的副本，即使返回的数组未更改。
- en: '*Caution* *The Python keywords `and` and `or` do not work with Boolean arrays.
    Use `&` (and) and `|` (or) instead.*  *Setting values with Boolean arrays works
    by substituting the value or values on the righthand side into the locations where
    the Boolean array''s values are `True`. To set all of the negative values in `data`
    to 0, we need only do:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *Python关键字`and`和`or`不能与布尔数组一起使用。请改用`&`（和）和`|`（或）。* *使用布尔数组设置值的工作方式是将右侧的值或值替换到布尔数组的值为`True`的位置。要将`data`中的所有负值设置为0，我们只需要执行：'
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can also set whole rows or columns using a one-dimensional Boolean array:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用一维布尔数组设置整行或整列：
- en: '[PRE47]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As we will see later, these types of operations on two-dimensional data are
    convenient to do with pandas.*  *### Fancy Indexing
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在后面看到的，对二维数据进行这些类型的操作很方便使用pandas。* *### 花式索引
- en: '*Fancy indexing* is a term adopted by NumPy to describe indexing using integer
    arrays. Suppose we had an 8 × 4 array:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*花式索引*是NumPy采用的术语，用于描述使用整数数组进行索引。假设我们有一个8×4数组：'
- en: '[PRE48]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To select a subset of the rows in a particular order, you can simply pass a
    list or ndarray of integers specifying the desired order:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要按特定顺序选择行的子集，只需传递一个指定所需顺序的整数列表或ndarray：
- en: '[PRE49]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Hopefully this code did what you expected! Using negative indices selects rows
    from the end:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这段代码符合您的期望！使用负索引可从末尾选择行：
- en: '[PRE50]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Passing multiple index arrays does something slightly different; it selects
    a one-dimensional array of elements corresponding to each tuple of indices:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 传递多个索引数组会产生略有不同的结果；它选择与每个索引元组对应的一维数组元素：
- en: '[PRE51]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To learn more about the `reshape` method, have a look at [Appendix A: Advanced
    NumPy](/book/advanced-numpy).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关`reshape`方法的更多信息，请查看[附录A：高级NumPy](/book/advanced-numpy)。
- en: Here the elements `(1, 0), (5, 3), (7, 1)`, and `(2, 2)` were selected. The
    result of fancy indexing with as many integer arrays as there are axes is always
    one-dimensional.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里选择了元素`(1, 0), (5, 3), (7, 1)`和`(2, 2)`。使用与轴数量相同的整数数组进行花式索引的结果始终是一维的。
- en: 'The behavior of fancy indexing in this case is a bit different from what some
    users might have expected (myself included), which is the rectangular region formed
    by selecting a subset of the matrix’s rows and columns. Here is one way to get
    that:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，花式索引的行为与一些用户可能期望的有些不同（包括我自己），即通过选择矩阵的行和列的子集形成的矩形区域。以下是获得该区域的一种方法：
- en: '[PRE52]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Keep in mind that fancy indexing, unlike slicing, always copies the data into
    a new array when assigning the result to a new variable. If you assign values
    with fancy indexing, the indexed values will be modified:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，花式索引与切片不同，当将结果分配给新变量时，总是将数据复制到新数组中。如果使用花式索引分配值，则将修改索引的值：
- en: '[PRE53]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Transposing Arrays and Swapping Axes
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转置数组和交换轴
- en: 'Transposing is a special form of reshaping that similarly returns a view on
    the underlying data without copying anything. Arrays have the `transpose` method
    and the special `T` attribute:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 转置是一种特殊的重塑形式，类似地返回基础数据的视图，而不复制任何内容。数组具有`transpose`方法和特殊的`T`属性：
- en: '[PRE54]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'When doing matrix computations, you may do this very often—for example, when
    computing the inner matrix product using `numpy.dot`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行矩阵计算时，您可能经常这样做-例如，使用`numpy.dot`计算内部矩阵乘积时：
- en: '[PRE55]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `@` infix operator is another way to do matrix multiplication:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`@`中缀运算符是进行矩阵乘法的另一种方式：'
- en: '[PRE56]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Simple transposing with `.T` is a special case of swapping axes. ndarray has
    the method `swapaxes`, which takes a pair of axis numbers and switches the indicated
    axes to rearrange the data:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.T`进行简单的转置是交换轴的特例。ndarray具有`swapaxes`方法，该方法接受一对轴编号，并切换指定的轴以重新排列数据：
- en: '[PRE57]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`swapaxes` similarly returns a view on the data without making a copy.**********  ***##
    4.2 Pseudorandom Number Generation'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`swapaxes`返回数据的视图而不进行复制。********** ***## 4.2 伪随机数生成
- en: 'The `numpy.random` module supplements the built-in Python `random` module with
    functions for efficiently generating whole arrays of sample values from many kinds
    of probability distributions. For example, you can get a 4 × 4 array of samples
    from the standard normal distribution using `numpy.random.standard_normal`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.random` 模块通过函数有效地生成许多种概率分布的样本值的整个数组来补充内置的 Python `random` 模块。例如，您可以使用
    `numpy.random.standard_normal` 从标准正态分布中获取一个 4 × 4 的样本数组：'
- en: '[PRE58]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Python’s built-in `random` module, by contrast, samples only one value at a
    time. As you can see from this benchmark, `numpy.random` is well over an order
    of magnitude faster for generating very large samples:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，Python 的内置 `random` 模块一次只抽取一个值。从这个基准测试中可以看出，对于生成非常大的样本，`numpy.random` 的速度要快一个数量级以上：
- en: '[PRE59]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'These random numbers are not truly random (rather, *pseudorandom*) but instead
    are generated by a configurable random number generator that determines deterministically
    what values are created. Functions like `numpy.random.standard_normal` use the
    `numpy.random` module''s default random number generator, but your code can be
    configured to use an explicit generator:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些随机数并不是真正的随机（而是伪随机），而是由可配置的随机数生成器生成的，该生成器确定确定性地创建哪些值。像 `numpy.random.standard_normal`
    这样的函数使用 `numpy.random` 模块的默认随机数生成器，但是您的代码可以配置为使用显式生成器：
- en: '[PRE60]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `seed` argument is what determines the initial state of the generator,
    and the state changes each time the `rng` object is used to generate data. The
    generator object `rng` is also isolated from other code which might use the `numpy.random`
    module:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`seed` 参数决定生成器的初始状态，每次使用 `rng` 对象生成数据时状态都会改变。生成器对象 `rng` 也与可能使用 `numpy.random`
    模块的其他代码隔离开来：'
- en: '[PRE61]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: See [Table 4.3](#tbl-table_numpy_random) for a partial list of methods available
    on random generator objects like `rng`. I will use the `rng` object I created
    above to generate random data throughout the rest of the chapter.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [表 4.3](#tbl-table_numpy_random) 以获取类似 `rng` 这样的随机生成器对象上可用的部分方法列表。我将使用上面创建的
    `rng` 对象在本章的其余部分生成随机数据。
- en: 'Table 4.3: NumPy random number generator methods'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.3：NumPy 随机数生成器方法
- en: '| Method | Description |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `permutation` | Return a random permutation of a sequence, or return a permuted
    range |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `permutation` | 返回一个序列的随机排列，或返回一个排列的范围 |'
- en: '| `shuffle` | Randomly permute a sequence in place |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `shuffle` | 在原地随机排列一个序列 |'
- en: '| `uniform` | Draw samples from a uniform distribution |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `uniform` | 从均匀分布中抽取样本 |'
- en: '| `integers` | Draw random integers from a given low-to-high range |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `integers` | 从给定的低到高范围中抽取随机整数 |'
- en: '| `standard_normal` | Draw samples from a normal distribution with mean 0 and
    standard deviation 1 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `standard_normal` | 从均值为 0，标准差为 1 的正态分布中抽取样本 |'
- en: '| `binomial` | Draw samples from a binomial distribution |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `binomial` | 从二项分布中抽取样本 |'
- en: '| `normal` | Draw samples from a normal (Gaussian) distribution |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `normal` | 从正态（高斯）分布中抽取样本 |'
- en: '| `beta` | Draw samples from a beta distribution |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `beta` | 从 beta 分布中抽取样本 |'
- en: '| `chisquare` | Draw samples from a chi-square distribution |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `chisquare` | 从卡方分布中抽取样本 |'
- en: '| `gamma` | Draw samples from a gamma distribution |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `gamma` | 从 gamma 分布中抽取样本 |'
- en: '| `uniform` | Draw samples from a uniform [0, 1) distribution |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `uniform` | 从均匀 [0, 1) 分布中抽取样本 |'
- en: '4.3 Universal Functions: Fast Element-Wise Array Functions'
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 通用函数：快速逐元素数组函数
- en: A universal function, or *ufunc*, is a function that performs element-wise operations
    on data in ndarrays. You can think of them as fast vectorized wrappers for simple
    functions that take one or more scalar values and produce one or more scalar results.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通用函数，或者 *ufunc*，是在 ndarrays 中对数据执行逐元素操作的函数。您可以将它们看作是快速矢量化的简单函数的包装器，这些函数接受一个或多个标量值并产生一个或多个标量结果。
- en: 'Many ufuncs are simple element-wise transformations, like `numpy.sqrt` or `numpy.exp`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 ufuncs 都是简单的逐元素转换，比如 `numpy.sqrt` 或 `numpy.exp`：
- en: '[PRE62]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'These are referred to as *unary* ufuncs. Others, such as `numpy.add` or `numpy.maximum`,
    take two arrays (thus, *binary* ufuncs) and return a single array as the result:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被称为一元 ufuncs。其他一些，比如 `numpy.add` 或 `numpy.maximum`，接受两个数组（因此是二元 ufuncs）并返回一个单一数组作为结果：
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this example, `numpy.maximum` computed the element-wise maximum of the elements
    in `x` and `y`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`numpy.maximum` 计算了 `x` 和 `y` 中元素的逐元素最大值。
- en: 'While not common, a ufunc can return multiple arrays. `numpy.modf` is one example:
    a vectorized version of the built-in Python `math.modf`, it returns the fractional
    and integral parts of a floating-point array:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不常见，ufunc 可以返回多个数组。`numpy.modf` 就是一个例子：它是内置 Python `math.modf` 的矢量化版本，返回浮点数组的小数部分和整数部分：
- en: '[PRE64]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Ufuncs accept an optional `out` argument that allows them to assign their results
    into an existing array rather than create a new one:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Ufuncs 接受一个可选的 `out` 参数，允许它们将结果分配到现有数组中，而不是创建一个新数组：
- en: '[PRE65]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: See Tables [Table 4.4](#tbl-table_unary_ufuncs) and [Table 4.5](#tbl-table_binary_ufuncs)
    for a listing of some of NumPy's ufuncs. New ufuncs continue to be added to NumPy,
    so consulting the online NumPy documentation is the best way to get a comprehensive
    listing and stay up to date.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [表 4.4](#tbl-table_unary_ufuncs) 和 [表 4.5](#tbl-table_binary_ufuncs) 以获取
    NumPy 的一些 ufuncs 列表。新的 ufuncs 仍在不断添加到 NumPy 中，因此查阅在线 NumPy 文档是获取全面列表并保持最新的最佳方式。
- en: 'Table 4.4: Some unary universal functions'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.4：一些一元通用函数
- en: '| Function | Description |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `abs, fabs` | Compute the absolute value element-wise for integer, floating-point,
    or complex values |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `abs, fabs` | 计算整数、浮点数或复数值的绝对值元素 |'
- en: '| `sqrt` | Compute the square root of each element (equivalent to `arr ** 0.5`)
    |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `sqrt` | 计算每个元素的平方根（等同于 `arr ** 0.5`） |'
- en: '| `square` | Compute the square of each element (equivalent to `arr ** 2`)
    |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `square` | 计算每个元素的平方（等同于 `arr ** 2`） |'
- en: '| `exp` | Compute the exponent e^x of each element |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `exp` | 计算每个元素的 e^x 指数 |'
- en: '| `log, log10, log2, log1p` | Natural logarithm (base *e*), log base 10, log
    base 2, and log(1 + x), respectively |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `log, log10, log2, log1p` | 自然对数（基数*e*），以10为底的对数，以2为底的对数，以及log(1 + x) |'
- en: '| `sign` | Compute the sign of each element: 1 (positive), 0 (zero), or –1
    (negative) |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `sign` | 计算每个元素的符号：1（正数），0（零），或-1（负数） |'
- en: '| `ceil` | Compute the ceiling of each element (i.e., the smallest integer
    greater than or equal to that number) |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `ceil` | 计算每个元素的上限（即大于或等于该数字的最小整数） |'
- en: '| `floor` | Compute the floor of each element (i.e., the largest integer less
    than or equal to each element) |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `floor` | 计算每个元素的下限（即小于或等于每个元素的最大整数） |'
- en: '| `rint` | Round elements to the nearest integer, preserving the `dtype` |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `rint` | 将元素四舍五入到最近的整数，保留`dtype` |'
- en: '| `modf` | Return fractional and integral parts of array as separate arrays
    |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `modf` | 将数组的分数部分和整数部分作为单独的数组返回 |'
- en: '| `isnan` | Return Boolean array indicating whether each value is `NaN` (Not
    a Number) |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `isnan` | 返回布尔数组，指示每个值是否为`NaN`（不是一个数字） |'
- en: '| `isfinite, isinf` | Return Boolean array indicating whether each element
    is finite (non-`inf`, non-`NaN`) or infinite, respectively |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `isfinite, isinf` | 返回布尔数组，指示每个元素是否有限（非`inf`，非`NaN`）或无限 |'
- en: '| `cos, cosh, sin, sinh, tan, tanh` | Regular and hyperbolic trigonometric
    functions |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `cos, cosh, sin, sinh, tan, tanh` | 常规和双曲三角函数 |'
- en: '| `arccos, arccosh, arcsin, arcsinh, arctan, arctanh` | Inverse trigonometric
    functions |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `arccos, arccosh, arcsin, arcsinh, arctan, arctanh` | 反三角函数 |'
- en: '| `logical_not` | Compute truth value of `not` `x` element-wise (equivalent
    to `~arr`) |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `logical_not` | 逐个元素计算`not` `x`的真值（等同于`~arr`） |'
- en: 'Table 4.5: Some binary universal functions'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.5：一些二元通用函数
- en: '| Function | Description |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `add` | Add corresponding elements in arrays |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `add` | 将数组中对应的元素相加 |'
- en: '| `subtract` | Subtract elements in second array from first array |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `subtract` | 从第一个数组中减去第二个数组中的元素 |'
- en: '| `multiply` | Multiply array elements |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `multiply` | 乘以数组元素 |'
- en: '| `divide, floor_divide` | Divide or floor divide (truncating the remainder)
    |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `divide, floor_divide` | 除法或地板除法（截断余数） |'
- en: '| `power` | Raise elements in first array to powers indicated in second array
    |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `power` | 将第一个数组中的元素提升到第二个数组中指示的幂 |'
- en: '| `maximum, fmax` | Element-wise maximum; `fmax` ignores `NaN` |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `maximum, fmax` | 逐个元素的最大值；`fmax`忽略`NaN` |'
- en: '| `minimum, fmin` | Element-wise minimum; `fmin` ignores `NaN` |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `minimum, fmin` | 逐个元素的最小值；`fmin`忽略`NaN` |'
- en: '| `mod` | Element-wise modulus (remainder of division) |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `mod` | 逐个元素的模数（除法的余数） |'
- en: '| `copysign` | Copy sign of values in second argument to values in first argument
    |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `copysign` | 将第二个参数中的值的符号复制到第一个参数中的值 |'
- en: '| `greater, greater_equal, less, less_equal, equal, not_equal` | Perform element-wise
    comparison, yielding Boolean array (equivalent to infix operators `>, >=, <, <=,
    ==, !=`) |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `greater, greater_equal, less, less_equal, equal, not_equal` | 执行逐个元素的比较，产生布尔数组（等同于中缀运算符`>,
    >=, <, <=, ==, !=`） |'
- en: '| `logical_and` | Compute element-wise truth value of AND (`&`) logical operation
    |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `logical_and` | 计算逻辑与（`&`）的逐个元素真值 |'
- en: '| `logical_or` | Compute element-wise truth value of OR (`&#124;`) logical
    operation |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `logical_or` | 计算逻辑或（`|`）的逐个元素真值 |'
- en: '| `logical_xor` | Compute element-wise truth value of XOR (`^`) logical operation
    |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `logical_xor` | 计算逻辑异或（`^`）的逐个元素真值 |'
- en: 4.4 Array-Oriented Programming with Arrays
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 数组导向编程与数组
- en: 'Using NumPy arrays enables you to express many kinds of data processing tasks
    as concise array expressions that might otherwise require writing loops. This
    practice of replacing explicit loops with array expressions is referred to by
    some people as *vectorization*. In general, vectorized array operations will usually
    be significantly faster than their pure Python equivalents, with the biggest impact
    in any kind of numerical computations. Later, in [Appendix A: Advanced NumPy](/book/advanced-numpy),
    I explain *broadcasting*, a powerful method for vectorizing computations.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NumPy数组使您能够将许多种类的数据处理任务表达为简洁的数组表达式，否则可能需要编写循环。用数组表达式替换显式循环的这种做法被一些人称为*向量化*。一般来说，向量化的数组操作通常比它们纯Python等效的要快得多，在任何类型的数值计算中影响最大。稍后，在[附录A：高级NumPy](/book/advanced-numpy)中，我将解释*广播*，这是一种用于向量化计算的强大方法。
- en: 'As a simple example, suppose we wished to evaluate the function `sqrt(x^2 +
    y^2)` across a regular grid of values. The `numpy.meshgrid` function takes two
    one-dimensional arrays and produces two two-dimensional matrices corresponding
    to all pairs of `(x, y)` in the two arrays:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 举个简单的例子，假设我们希望在一组常规值的网格上评估函数`sqrt(x^2 + y^2)`。`numpy.meshgrid`函数接受两个一维数组，并产生两个对应于两个数组中所有`(x,
    y)`对的二维矩阵：
- en: '[PRE66]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, evaluating the function is a matter of writing the same expression you
    would write with two points:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，评估函数只是写出您将用两个点写出的相同表达式的问题：
- en: '[PRE67]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'As a preview of [Ch 9: Plotting and Visualization](/book/plotting-and-visualization),
    I use matplotlib to create visualizations of this two-dimensional array:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 作为[第9章：绘图和可视化](/book/plotting-and-visualization)的预览，我使用matplotlib来创建这个二维数组的可视化：
- en: '[PRE68]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In [Plot of function evaluated on a grid](#numpy_vectorize_circle), I used the
    matplotlib function `imshow` to create an image plot from a two-dimensional array
    of function values.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在[在网格上评估函数的绘图](#numpy_vectorize_circle)中，我使用了matplotlib函数`imshow`来从函数值的二维数组创建图像图。
- en: '![](../Images/c901850a416d7a0f42bc07ffa0092543.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c901850a416d7a0f42bc07ffa0092543.png)'
- en: 'Figure 4.3: Plot of function evaluated on a grid'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：在网格上评估函数的绘图
- en: 'If you''re working in IPython, you can close all open plot windows by executing
    `plt.close("all")`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在IPython中工作，可以通过执行`plt.close("all")`关闭所有打开的绘图窗口：
- en: '[PRE69]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '*Note* *The term *vectorization* is used to describe some other computer science
    concepts, but in this book I use it to describe operations on whole arrays of
    data at once rather than going value by value using a Python `for` loop.*  *###
    Expressing Conditional Logic as Array Operations'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *术语*矢量化*用于描述其他计算机科学概念，但在本书中，我使用它来描述对整个数据数组进行操作，而不是逐个值使用Python的`for`循环。*  *###
    将条件逻辑表达为数组操作'
- en: 'The `numpy.where` function is a vectorized version of the ternary expression
    `x if condition else y`. Suppose we had a Boolean array and two arrays of values:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.where`函数是三元表达式`x if condition else y`的矢量化版本。假设我们有一个布尔数组和两个值数组：'
- en: '[PRE70]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Suppose we wanted to take a value from `xarr` whenever the corresponding value
    in `cond` is `True`, and otherwise take the value from `yarr`. A list comprehension
    doing this might look like:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要从`cond`中对应的值为`True`时从`xarr`中取一个值，否则从`yarr`中取一个值。一个做到这一点的列表推导可能如下所示：
- en: '[PRE71]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This has multiple problems. First, it will not be very fast for large arrays
    (because all the work is being done in interpreted Python code). Second, it will
    not work with multidimensional arrays. With `numpy.where` you can do this with
    a single function call:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这有多个问题。首先，对于大数组来说速度不会很快（因为所有工作都是在解释的Python代码中完成的）。其次，它不适用于多维数组。使用`numpy.where`可以通过单个函数调用来实现这一点：
- en: '[PRE72]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The second and third arguments to `numpy.where` don’t need to be arrays; one
    or both of them can be scalars. A typical use of `where` in data analysis is to
    produce a new array of values based on another array. Suppose you had a matrix
    of randomly generated data and you wanted to replace all positive values with
    2 and all negative values with –2\. This is possible to do with `numpy.where`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.where`的第二个和第三个参数不需要是数组；它们中的一个或两个可以是标量。在数据分析中，`where`的典型用法是根据另一个数组生成一个新的值数组。假设你有一个随机生成数据的矩阵，并且你想用2替换所有正值和用-2替换所有负值。这可以通过`numpy.where`来实现：'
- en: '[PRE73]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'You can combine scalars and arrays when using `numpy.where`. For example, I
    can replace all positive values in `arr` with the constant 2, like so:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`numpy.where`时，可以将标量和数组组合在一起。例如，我可以用常数2替换`arr`中的所有正值，如下所示：
- en: '[PRE74]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Mathematical and Statistical Methods
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学和统计方法
- en: A set of mathematical functions that compute statistics about an entire array
    or about the data along an axis are accessible as methods of the array class.
    You can use aggregations (sometimes called *reductions*) like `sum`, `mean`, and
    `std` (standard deviation) either by calling the array instance method or using
    the top-level NumPy function. When you use the NumPy function, like `numpy.sum`,
    you have to pass the array you want to aggregate as the first argument.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一组数学函数，用于计算整个数组或沿轴的数据的统计信息，作为数组类的方法可访问。您可以通过调用数组实例方法或使用顶级NumPy函数来使用聚合（有时称为*缩减*）如`sum`、`mean`和`std`（标准差）。当您使用NumPy函数，如`numpy.sum`时，您必须将要聚合的数组作为第一个参数传递。
- en: 'Here I generate some normally distributed random data and compute some aggregate
    statistics:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我生成一些正态分布的随机数据并计算一些聚合统计数据：
- en: '[PRE75]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Functions like `mean` and `sum` take an optional `axis` argument that computes
    the statistic over the given axis, resulting in an array with one less dimension:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 像`mean`和`sum`这样的函数接受一个可选的`axis`参数，该参数在给定轴上计算统计量，结果是一个维数少一的数组：
- en: '[PRE76]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Here, `arr.mean(axis=1)` means "compute mean across the columns," where `arr.sum(axis=0)`
    means "compute sum down the rows."
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`arr.mean(axis=1)`表示“计算沿着列的平均值”，而`arr.sum(axis=0)`表示“计算沿着行的总和”。
- en: 'Other methods like `cumsum` and `cumprod` do not aggregate, instead producing
    an array of the intermediate results:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 像`cumsum`和`cumprod`这样的其他方法不进行聚合，而是产生中间结果的数组：
- en: '[PRE77]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In multidimensional arrays, accumulation functions like `cumsum` return an
    array of the same size but with the partial aggregates computed along the indicated
    axis according to each lower dimensional slice:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在多维数组中，像`cumsum`这样的累积函数返回一个相同大小的数组，但是根据每个较低维度切片沿着指定轴计算部分累积：
- en: '[PRE78]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The expression `arr.cumsum(axis=0)` computes the cumulative sum along the rows,
    while `arr.cumsum(axis=1)` computes the sums along the columns:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`arr.cumsum(axis=0)`计算沿着行的累积和，而`arr.cumsum(axis=1)`计算沿着列的和：
- en: '[PRE79]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: See [Table 4.6](#tbl-table_statistical_methods) for a full listing. We’ll see
    many examples of these methods in action in later chapters.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[表4.6](#tbl-table_statistical_methods)以获取完整列表。我们将在后面的章节中看到这些方法的许多示例。
- en: 'Table 4.6: Basic array statistical methods'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.6：基本数组统计方法
- en: '| Method | Description |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `sum` | Sum of all the elements in the array or along an axis; zero-length
    arrays have sum 0 |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| `sum` | 数组或沿轴的所有元素的总和；长度为零的数组的总和为0 |'
- en: '| `mean` | Arithmetic mean; invalid (returns `NaN`) on zero-length arrays |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `mean` | 算术平均值；对于长度为零的数组无效（返回`NaN`） |'
- en: '| `std, var` | Standard deviation and variance, respectively |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `std, var` | 分别是标准差和方差 |'
- en: '| `min, max` | Minimum and maximum |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `min, max` | 最小值和最大值 |'
- en: '| `argmin, argmax` | Indices of minimum and maximum elements, respectively
    |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `argmin, argmax` | 分别是最小和最大元素的索引 |'
- en: '| `cumsum` | Cumulative sum of elements starting from 0 |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `cumsum` | 从0开始的元素的累积和 |'
- en: '| `cumprod` | Cumulative product of elements starting from 1 |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `cumprod` | 从1开始的元素的累积乘积 |'
- en: Methods for Boolean Arrays
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔数组的方法
- en: 'Boolean values are coerced to 1 (`True`) and 0 (`False`) in the preceding methods.
    Thus, `sum` is often used as a means of counting `True` values in a Boolean array:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，布尔值被强制转换为1（`True`）和0（`False`）。因此，`sum`经常被用作计算布尔数组中`True`值的计数的手段：
- en: '[PRE80]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The parentheses here in the expression `(arr > 0).sum()` are necessary to be
    able to call `sum()` on the temporary result of `arr > 0`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这里表达式`(arr > 0).sum()`中的括号是必要的，以便能够在`arr > 0`的临时结果上调用`sum()`。
- en: 'Two additional methods, `any` and `all`, are useful especially for Boolean
    arrays. `any` tests whether one or more values in an array is `True`, while `all`
    checks if every value is `True`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个方法，`any`和`all`，特别适用于布尔数组。`any`测试数组中是否有一个或多个值为`True`，而`all`检查是否每个值都为`True`：
- en: '[PRE81]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: These methods also work with non-Boolean arrays, where nonzero elements are
    treated as `True`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法也适用于非布尔数组，其中非零元素被视为`True`。
- en: Sorting
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排序
- en: 'Like Python’s built-in list type, NumPy arrays can be sorted in place with
    the `sort` method:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python内置的列表类型类似，NumPy数组可以使用`sort`方法原地排序：
- en: '[PRE82]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'You can sort each one-dimensional section of values in a multidimensional array
    in place along an axis by passing the axis number to `sort`. In this example data:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将轴编号传递给`sort`方法，在多维数组中对每个一维部分的值沿着轴进行原地排序。在这个例子数据中：
- en: '[PRE83]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`arr.sort(axis=0)` sorts the values within each column, while `arr.sort(axis=1)`
    sorts across each row:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`arr.sort(axis=0)`对每列内的值进行排序，而`arr.sort(axis=1)`对每行进行排序：'
- en: '[PRE84]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The top-level method `numpy.sort` returns a sorted copy of an array (like the
    Python built-in function `sorted`) instead of modifying the array in place. For
    example:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层方法`numpy.sort`返回一个数组的排序副本（类似于Python内置函数`sorted`），而不是在原地修改数组。例如：
- en: '[PRE85]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'For more details on using NumPy’s sorting methods, and more advanced techniques
    like indirect sorts, see [Appendix A: Advanced NumPy](/book/advanced-numpy). Several
    other kinds of data manipulations related to sorting (e.g., sorting a table of
    data by one or more columns) can also be found in pandas.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用NumPy的排序方法的更多详细信息，以及更高级的技术，如间接排序，请参见[附录A：高级NumPy](/book/advanced-numpy)。还可以在pandas中找到与排序相关的其他数据操作（例如，按一个或多个列对数据表进行排序）。
- en: Unique and Other Set Logic
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 唯一值和其他集合逻辑
- en: 'NumPy has some basic set operations for one-dimensional ndarrays. A commonly
    used one is `numpy.unique`, which returns the sorted unique values in an array:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy具有一些用于一维ndarrays的基本集合操作。一个常用的操作是`numpy.unique`，它返回数组中排序的唯一值：
- en: '[PRE86]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Contrast `numpy.unique` with the pure Python alternative:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 将`numpy.unique`与纯Python替代方案进行对比：
- en: '[PRE87]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In many cases, the NumPy version is faster and returns a NumPy array rather
    than a Python list.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，NumPy版本更快，并返回一个NumPy数组而不是Python列表。
- en: 'Another function, `numpy.in1d`, tests membership of the values in one array
    in another, returning a Boolean array:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个函数`numpy.in1d`测试一个数组中的值在另一个数组中的成员资格，返回一个布尔数组：
- en: '[PRE88]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: See [Table 4.7](#tbl-table_setops) for a listing of array set operations in
    NumPy.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[表4.7](#tbl-table_setops)以获取NumPy中数组集合操作的列表。
- en: 'Table 4.7: Array set operations'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.7：数组集合操作
- en: '| Method | Description |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `unique(x)` | Compute the sorted, unique elements in `x` |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '`unique(x)` | 计算`x`中排序的唯一元素'
- en: '| `intersect1d(x, y)` | Compute the sorted, common elements in `x` and `y`
    |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '`intersect1d(x, y)` | 计算`x`和`y`中排序的公共元素'
- en: '| `union1d(x, y)` | Compute the sorted union of elements |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '`union1d(x, y)` | 计算元素的排序并集'
- en: '| `in1d(x, y)` | Compute a Boolean array indicating whether each element of
    `x` is contained in `y` |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '`in1d(x, y)` | 计算一个布尔数组，指示`x`的每个元素是否包含在`y`中'
- en: '| `setdiff1d(x, y)` | Set difference, elements in `x` that are not in `y` |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '`setdiff1d(x, y)` | 差集，`x`中不在`y`中的元素'
- en: '| `setxor1d(x, y)` | Set symmetric differences; elements that are in either
    of the arrays, but not both |*  *## 4.5 File Input and Output with Arrays'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`setxor1d(x, y)` | 对称差集；在任一数组中但不在两个数组中的元素 |*  *## 4.5 使用数组进行文件输入和输出'
- en: 'NumPy is able to save and load data to and from disk in some text or binary
    formats. In this section I discuss only NumPy''s built-in binary format, since
    most users will prefer pandas and other tools for loading text or tabular data
    (see [Ch 6: Data Loading, Storage, and File Formats](/book/accessing-data) for
    much more).'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy能够以一些文本或二进制格式将数据保存到磁盘并从磁盘加载数据。在本节中，我只讨论NumPy内置的二进制格式，因为大多数用户更倾向于使用pandas和其他工具来加载文本或表格数据（详见[第6章：数据加载、存储和文件格式](/book/accessing-data)）。
- en: '`numpy.save` and `numpy.load` are the two workhorse functions for efficiently
    saving and loading array data on disk. Arrays are saved by default in an uncompressed
    raw binary format with file extension *.npy*:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.save`和`numpy.load`是在磁盘上高效保存和加载数组数据的两个主要函数。默认情况下，数组以未压缩的原始二进制格式保存，文件扩展名为*.npy*：'
- en: '[PRE89]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'If the file path does not already end in *.npy*, the extension will be appended.
    The array on disk can then be loaded with `numpy.load`:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件路径尚未以*.npy*结尾，则会添加扩展名。然后可以使用`numpy.load`加载磁盘上的数组：
- en: '[PRE90]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'You can save multiple arrays in an uncompressed archive using `numpy.savez`
    and passing the arrays as keyword arguments:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`numpy.savez`并将数组作为关键字参数传递来保存多个数组到未压缩的存档中：
- en: '[PRE91]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'When loading an *.npz* file, you get back a dictionary-like object that loads
    the individual arrays lazily:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载一个*.npz*文件时，您会得到一个类似字典的对象，它会延迟加载各个数组：
- en: '[PRE92]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If your data compresses well, you may wish to use `numpy.savez_compressed`
    instead:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的数据压缩效果很好，您可能希望使用`numpy.savez_compressed`：
- en: '[PRE93]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 4.6 Linear Algebra
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 线性代数
- en: 'Linear algebra operations, like matrix multiplication, decompositions, determinants,
    and other square matrix math, are an important part of many array libraries. Multiplying
    two two-dimensional arrays with `*` is an element-wise product, while matrix multiplications
    require either using the `dot` function or the `@` infix operator. `dot` is both
    an array method and a function in the `numpy` namespace for doing matrix multiplication:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数运算，如矩阵乘法、分解、行列式和其他方阵数学，是许多数组库的重要组成部分。两个二维数组使用`*`进行元素级乘积，而矩阵乘法需要使用`dot`函数或`@`中缀运算符。`dot`既是一个数组方法，也是`numpy`命名空间中用于执行矩阵乘法的函数：
- en: '[PRE94]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '`x.dot(y)` is equivalent to `np.dot(x, y)`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`x.dot(y)`等同于`np.dot(x, y)`：'
- en: '[PRE95]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'A matrix product between a two-dimensional array and a suitably sized one-dimensional
    array results in a one-dimensional array:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 两个二维数组与适当大小的一维数组之间的矩阵乘积会得到一个一维数组：
- en: '[PRE96]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '`numpy.linalg` has a standard set of matrix decompositions and things like
    inverse and determinant:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.linalg`具有一套标准的矩阵分解和逆矩阵、行列式等功能：'
- en: '[PRE97]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The expression `X.T.dot(X)` computes the dot product of `X` with its transpose
    `X.T`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`X.T.dot(X)`计算`X`与其转置`X.T`的点积。
- en: See [Table 4.8](#tbl-table_numpy_linalg) for a list of some of the most commonly
    used linear algebra functions.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[表4.8](#tbl-table_numpy_linalg)以获取一些最常用的线性代数函数的列表。
- en: 'Table 4.8: Commonly used `numpy.linalg` functions'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.8：常用的`numpy.linalg`函数
- en: '| Function | Description |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `diag` | Return the diagonal (or off-diagonal) elements of a square matrix
    as a 1D array, or convert a 1D array into a square matrix with zeros on the off-diagonal
    |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| `diag` | 返回方阵的对角线（或非对角线）元素作为1D数组，或将1D数组转换为具有非对角线零的方阵|'
- en: '| `dot` | Matrix multiplication |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| `dot` | 矩阵乘法|'
- en: '| `trace` | Compute the sum of the diagonal elements |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| `trace` | 计算对角线元素的和|'
- en: '| `det` | Compute the matrix determinant |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| `det` | 计算矩阵行列式|'
- en: '| `eig` | Compute the eigenvalues and eigenvectors of a square matrix |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| `eig` | 计算方阵的特征值和特征向量|'
- en: '| `inv` | Compute the inverse of a square matrix |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| `inv` | 计算方阵的逆|'
- en: '| `pinv` | Compute the Moore-Penrose pseudoinverse of a matrix |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| `pinv` | 计算矩阵的Moore-Penrose伪逆|'
- en: '| `qr` | Compute the QR decomposition |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| `qr` | 计算QR分解|'
- en: '| `svd` | Compute the singular value decomposition (SVD) |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| `svd` | 计算奇异值分解（SVD）|'
- en: '| `solve` | Solve the linear system Ax = b for x, where A is a square matrix
    |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| `solve` | 解线性方程组Ax = b，其中A是方阵|'
- en: '| `lstsq` | Compute the least-squares solution to `Ax = b` |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| `lstsq` | 计算`Ax = b`的最小二乘解|'
- en: '4.7 Example: Random Walks'
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7 示例：随机漫步
- en: The simulation of [*random walks*](https://en.wikipedia.org/wiki/Random_walk)
    provides an illustrative application of utilizing array operations. Let’s first
    consider a simple random walk starting at 0 with steps of 1 and –1 occurring with
    equal probability.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '[*随机漫步*](https://en.wikipedia.org/wiki/Random_walk)的模拟提供了利用数组操作的说明性应用。让我们首先考虑一个简单的从0开始的随机漫步，步长为1和-1，发生概率相等。'
- en: 'Here is a pure Python way to implement a single random walk with 1,000 steps
    using the built-in `random` module:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用内置的`random`模块实现一次包含1,000步的随机漫步的纯Python方法：
- en: '[PRE98]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'See [Figure 4.4](#fig-figure_random_walk1) for an example plot of the first
    100 values on one of these random walks:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[图4.4](#fig-figure_random_walk1)以查看这些随机漫步中前100个值的示例图：
- en: '[PRE99]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '![](../Images/f00985b53f21f5e966a370573cb76885.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f00985b53f21f5e966a370573cb76885.png)'
- en: 'Figure 4.4: A simple random walk'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：一个简单的随机漫步
- en: 'You might make the observation that `walk` is the cumulative sum of the random
    steps and could be evaluated as an array expression. Thus, I use the `numpy.random`
    module to draw 1,000 coin flips at once, set these to 1 and –1, and compute the
    cumulative sum:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会观察到`walk`是随机步数的累积和，可以被评估为一个数组表达式。因此，我使用`numpy.random`模块一次绘制1,000次硬币翻转，将这些设置为1和-1，并计算累积和：
- en: '[PRE100]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'From this we can begin to extract statistics like the minimum and maximum value
    along the walk’s trajectory:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以开始提取统计数据，比如沿着漫步轨迹的最小值和最大值：
- en: '[PRE101]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'A more complicated statistic is the *first crossing time*, the step at which
    the random walk reaches a particular value. Here we might want to know how long
    it took the random walk to get at least 10 steps away from the origin 0 in either
    direction. `np.abs(walk) >= 10` gives us a Boolean array indicating where the
    walk has reached or exceeded 10, but we want the index of the *first* 10 or –10\.
    Turns out, we can compute this using `argmax`, which returns the first index of
    the maximum value in the Boolean array (`True` is the maximum value):'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂的统计量是*第一次穿越时间*，即随机漫步达到特定值的步数。在这里，我们可能想知道随机漫步离原点0至少10步的时间。`np.abs(walk)
    >= 10`给出一个布尔数组，指示漫步已经达到或超过10，但我们想要第一个10或-10的索引。事实证明，我们可以使用`argmax`来计算这个，它返回布尔数组中最大值的第一个索引（`True`是最大值）：
- en: '[PRE102]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Note that using `argmax` here is not always efficient because it always makes
    a full scan of the array. In this special case, once a `True` is observed we know
    it to be the maximum value.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，在这里使用`argmax`并不总是高效的，因为它总是对数组进行完整扫描。在这种特殊情况下，一旦观察到`True`，我们就知道它是最大值。 '
- en: Simulating Many Random Walks at Once
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一次模拟多个随机漫步
- en: 'If your goal was to simulate many random walks, say five thousand of them,
    you can generate all of the random walks with minor modifications to the preceding
    code. If passed a 2-tuple, the `numpy.random` functions will generate a two-dimensional
    array of draws, and we can compute the cumulative sum for each row to compute
    all five thousand random walks in one shot:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的目标是模拟许多随机漫步，比如说五千次，你可以通过对前面的代码进行微小修改来生成所有的随机漫步。如果传递一个2元组，`numpy.random`函数将生成一个二维数组的抽样，我们可以为每一行计算累积和，以一次性计算所有五千次随机漫步：
- en: '[PRE103]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Now, we can compute the maximum and minimum values obtained over all of the
    walks:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以计算所有漫步中获得的最大值和最小值：
- en: '[PRE104]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Out of these walks, let’s compute the minimum crossing time to 30 or –30\.
    This is slightly tricky because not all 5,000 of them reach 30\. We can check
    this using the `any` method:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些漫步中，让我们计算到达30或-30的最小穿越时间。这有点棘手，因为并非所有的5000次都达到30。我们可以使用`any`方法来检查：
- en: '[PRE105]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'We can use this Boolean array to select the rows of `walks` that actually cross
    the absolute 30 level, and call `argmax` across axis 1 to get the crossing times:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个布尔数组来选择实际穿越绝对值30水平的`walks`的行，并在轴1上调用`argmax`来获取穿越时间：
- en: '[PRE106]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Lastly, we compute the average minimum crossing time:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们计算平均最小穿越时间：
- en: '[PRE107]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Feel free to experiment with other distributions for the steps other than equal-sized
    coin flips. You need only use a different random generator method, like `standard_normal`
    to generate normally distributed steps with some mean and standard deviation:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 随意尝试使用与等大小硬币翻转不同的步骤分布。你只需要使用不同的随机生成器方法，比如`standard_normal`来生成具有一定均值和标准差的正态分布步数：
- en: '[PRE108]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '*Note* *Keep in mind that this vectorized approach requires creating an array
    with `nwalks * nsteps` elements, which may use a large amount of memory for large
    simulations. If memory is more constrained, then a different approach will be
    required.*  *## 4.8 Conclusion'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *请记住，这种矢量化方法需要创建一个具有`nwalks * nsteps`元素的数组，这可能会在大型模拟中使用大量内存。如果内存更受限制，则需要采用不同的方法。*  *##
    4.8 结论'
- en: 'While much of the rest of the book will focus on building data wrangling skills
    with pandas, we will continue to work in a similar array-based style. In [Appendix
    A: Advanced NumPy](/book/advanced-numpy), we will dig deeper into NumPy features
    to help you further develop your array computing skills.*******'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书的大部分内容将集中在使用pandas构建数据整理技能上，我们将继续以类似的基于数组的风格工作。在[附录A：高级NumPy](/book/advanced-numpy)中，我们将深入探讨NumPy的特性，帮助您进一步发展数组计算技能。
