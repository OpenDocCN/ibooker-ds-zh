- en: Chapter 12\. Mathematical Logic
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章 数学逻辑
- en: '*Humans bend the rules…*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*人类会打破规则……*'
- en: 'Historically in the AI field, logic based agents come before machine learning
    and neural network based agents. The reason we went over machine learning, neural
    networks, probabilistic reasoning, graph representations, and operations reseach
    before logic is that we want to tie it all into one narrative of reasoning within
    an agent, as opposed to thinking of logic as old and neural networks as modern.
    We want to view the recent advancements as enhancing the way a logical AI agent
    represents and reasons about the world. A good way to think about this is similar
    to enlightenment: An AI agent used to reason using the rigid rules of hand coded
    knowledge base and hand coded rules to make inferences and decisions, then suddenly
    it gets enlightened and becomes endowed with more reasoning tools, networks, and
    neurons that allow it to expand both its knowledge base and inference methods.
    This way, it has more expressive power and can navigate more complex and uncertain
    situations. Moreover, combining all the tools together would allow an agent the
    option to sometimes break the rules of a more rigid logic framework and employ
    a more flexible one depending on the situation, just like humans. Bending, breaking,
    and even changing the rules are distinctive human attributes.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在人工智能领域的历史上，基于逻辑的代理人出现在基于机器学习和神经网络的代理人之前。我们之所以在逻辑之前讨论了机器学习、神经网络、概率推理、图形表示和运算研究，是因为我们希望将所有这些内容融入到一个关于代理人推理的叙事中，而不是将逻辑看作是古老的，神经网络看作是现代的。我们希望将最近的进展视为增强逻辑人工智能代理人表示和推理世界的方式。一个好的思考方式类似于启蒙：一个AI代理人过去使用手工编码的知识库和规则来进行推理和决策，然后突然之间它得到启蒙，变得更具推理工具、网络和神经元，使其能够扩展其知识库和推理方法。这样，它就具有了更多的表达能力，可以应对更复杂和不确定的情况。此外，将所有工具结合在一起将使代理人有时可以打破更严格逻辑框架的规则，根据情况采用更灵活的规则，就像人类一样。打破、弯曲甚至改变规则是人类独有的特征。
- en: The dictionary meaning of the word *logic* sets the tone for this chapter and
    justifies its progression.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 单词*逻辑*的字典含义为本章设定了基调，并证明了其进展。
- en: Logic
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑
- en: A framework that organizes the rules and processes used for sound thinking and
    reasoning. It is a framework that lays down the principles of validity under which
    to conduct reasoning and inference.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 组织用于合理思考和推理的规则和过程的框架。这是一个奠定了进行推理和推断的有效性原则的框架。
- en: The most important words to pay attention to in the above definition are *framework*
    and *principles for inference*. A logic system codifies within an agent the principles
    that govern reliable inference and correct proofs. Designing agents who are able
    to gather knowledge, reason logically, with a flexible logic system that accomodates
    uncertainty about the environment that they exist in, and make inferences and
    decisions based on this logical reasoning lies at the heart of artificial intelligence.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 上述定义中需要注意的最重要的词是*框架*和*推理原则*。逻辑系统在一个代理人内部编码了指导可靠推理和正确证明的原则。设计能够收集知识、逻辑推理的代理人，使用一个灵活的逻辑系统，适应他们存在的环境中的不确定性，并基于这种逻辑推理进行推断和决策，是人工智能的核心。
- en: We discuss the various systems of mathematical logic that we can program into
    an agent. The goal is to give the AI agent the ability to make inferences that
    enable it to act appropriately. These logical frameworks require knowledge bases
    to accompany the inference rules of varying sizes. They also have varying degrees
    of expressive and deductive powers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了我们可以编程到代理人中的各种数学逻辑系统。目标是赋予AI代理人能力，使其能够进行适当的推理。这些逻辑框架需要知识库来配合不同大小的推理规则。它们还具有不同程度的表达和演绎能力。
- en: Various Logic Frameworks
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 各种逻辑框架
- en: 'For each of the different logical frameworks (*propositional, first order,
    temporal, probabilistic, and fuzzy*) that we are about to highlight in this chapter,
    we will answer two questions about how they operate within an agent endowed with
    them:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们将重点介绍的各种逻辑框架（*命题、一阶、时间、概率和模糊*），我们将回答两个关于它们在代理人中如何运作的问题：
- en: What objects exist in the agent’s world? Meaning, how does the agent perceive
    the composition of its world?
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理人的世界中存在哪些对象？也就是说，代理人如何感知其世界的构成？
- en: How does the agent perceive the objects’ states? Meaning, what values can the
    agent assign to each object in its world under the particular logic framework?
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理人如何感知对象的状态？也就是说，在特定的逻辑框架下，代理人可以为其世界中的每个对象分配什么值？
- en: 'It is easy to think about this if we liken our agent to an [ant and how it
    experiences world](http://astronomy.nmsu.edu/geas/lectures/lecture28/slide03.xhtml):
    Because of the ant’s predetermined framework of perception and allowed movements,
    the ant experiences the world, along with its curvature, as two dimensional. If
    the ant gets enhanced and endowed with a more expressive framework of perception
    and allowed movements (for example wings), then it will experience the three dimensional
    world.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将我们的代理人比作一只[蚂蚁及其体验世界的方式](http://astronomy.nmsu.edu/geas/lectures/lecture28/slide03.xhtml)，就很容易理解：由于蚂蚁预先确定的感知框架和允许的移动方式，蚂蚁将世界，以及其曲率，体验为二维。如果蚂蚁得到增强并赋予更具表现力的感知框架和允许的移动方式（例如翅膀），那么它将体验到三维世界。
- en: Propositional Logic
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命题逻辑
- en: What objects exist in the agent’s world?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理人的世界中存在哪些对象？
- en: '*Simple or complex statements, called propositions, hence the name propositional
    logic.*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*简单或复杂的陈述，称为命题，因此称为命题逻辑。*'
- en: How does the agent perceive the objects’ states?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理人如何感知对象的状态？
- en: '*True (1), False (0), or unknown*. Propositional logic is also called Boolean
    logic because the objects in it can only assume two states. Paradoxes in propositional
    logic are statements that cannot classified as true or false, according the logic
    framework’s *truth table*.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*真（1），假（0），或未知*。命题逻辑也被称为布尔逻辑，因为其中的对象只能有两种状态。命题逻辑中的悖论是指无法分类为真或假的陈述，根据逻辑框架的*真值表*。'
- en: 'These are examples of statements and their states:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是陈述及其状态的示例：
- en: It is raining (can take true or false states)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在下雨（可以是真也可以是假）
- en: The Eiffel tower is in Paris (always true)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 埃菲尔铁塔在巴黎（始终为真）
- en: There is suspicious activity in the park (can take true or false states)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公园里有可疑活动（可以是真也可以是假）
- en: This sentence is false (paradox)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这句话是假的（悖论）
- en: I am happy *and* I am sad (always false, unless you ask my husband)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我快乐 *且* 我悲伤（始终为假，除非你问我的丈夫）
- en: I am happy *or* I am sad (always true)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我快乐 *或* 我悲伤（始终为真）
- en: 'If the score is 13 then the student fails (truth depends on failing thresholds,
    so we need a statement in the knowledge base that says: All students with score
    below 16 fail, and set its value at true).'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果分数是13，那么学生就不及格（真假取决于不及格的阈值，因此我们需要在知识库中添加一个陈述，说所有分数低于16的学生都不及格，并将其值设为真）。
- en: 1+2 is equivalent to 2+1 (always true within an agent endowed with arithmetic
    rules).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1+2等于2+1（在具有算术规则的代理中始终为真）。
- en: Paris is romantic (in propositional logic this has to be either true or false
    but in fuzzy logic it can assume a value on a zero to one scale, for example 0.8,
    which corresponds better with the way we perceive our world, on a scale as opposed
    to absolutes. Of course I would assign the value true for this statement if I
    am programming an agent and confined to propositional logic, but someone who hates
    Paris would assign false. Oh well).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 巴黎浪漫（在命题逻辑中，这必须是真或假，但在模糊逻辑中，它可以在零到一的范围内取值，例如0.8，这更符合我们感知世界的方式，以一个范围而不是绝对值。当然，如果我在编程一个代理并且受限于命题逻辑，我会为这个陈述分配真值，但是一个讨厌巴黎的人会分配假值。哦，好吧）。
- en: 'The objects in a propositional logic’s world are simple statements and complex
    statements. We can form complex statements from simple ones using five allowed
    operators: Not (negation); and; or; implies (which is the same as *if then*);
    equivalent to (which is the same as *if and only if*).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 命题逻辑世界中的对象是简单陈述和复杂陈述。我们可以使用五个允许的运算符从简单陈述中形成复杂陈述：非（否定）；和；或；蕴含（与*如果那样*相同）；等同于（与*如果且仅如果*相同）。
- en: 'We also have five rules to determine whether a statement is true or false:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有五条规则来确定一个陈述是真还是假：
- en: The negation of a statement is true if and only if the statement is false.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个陈述的否定为真，那么该陈述为假。
- en: <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi> <mi>t</mi>
    <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>1</mn></msub></mrow></math>
    *and* <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi>
    <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>2</mn></msub></mrow></math>
    is true if and only if both <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi>
    <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>1</mn></msub></mrow></math> and <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi>
    <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>2</mn></msub></mrow></math> are true.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi> <mi>t</mi>
    <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>1</mn></msub></mrow></math>
    *且* <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi>
    <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>2</mn></msub></mrow></math>
    为真，只有当<math alttext="s t a t e m e n t 1"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi>
    <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>1</mn></msub></mrow></math>
    和<math alttext="s t a t e m e n t 2"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi> <mi>t</mi>
    <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>2</mn></msub></mrow></math>
    都为真时才为真。
- en: <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi> <mi>t</mi>
    <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>1</mn></msub></mrow></math>
    *or* <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi>
    <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>2</mn></msub></mrow></math>
    is true if and only if either <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi>
    <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>1</mn></msub></mrow></math> or <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi>
    <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>2</mn></msub></mrow></math> are true (or if both are true).
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果<math alttext="s t a t e m e n t 1"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi>
    <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>1</mn></msub></mrow></math>
    *或* <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi>
    <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>2</mn></msub></mrow></math>
    为真，那么只有当<math alttext="s t a t e m e n t 1"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi>
    <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>1</mn></msub></mrow></math>
    或<math alttext="s t a t e m e n t 2"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi> <mi>t</mi>
    <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>2</mn></msub></mrow></math>
    为真时，该语句为真（或者两者都为真）。
- en: <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi> <mi>t</mi>
    <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>1</mn></msub></mrow></math>
    *implies* <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi>
    <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>2</mn></msub></mrow></math>
    is true except when <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi> <mi>t</mi>
    <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>1</mn></msub></mrow></math> is true and <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi>
    <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>2</mn></msub></mrow></math> is false.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi> <mi>t</mi>
    <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>1</mn></msub></mrow></math>
    *implies* <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi>
    <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>2</mn></msub></mrow></math>
    是真的，除非当 <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi>
    <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>1</mn></msub></mrow></math>
    为真且 <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi>
    <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>2</mn></msub></mrow></math>
    为假时。
- en: <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi> <mi>t</mi>
    <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>1</mn></msub></mrow></math>
    *equivalent to* <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi> <mi>t</mi>
    <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>2</mn></msub></mrow></math> if and only if <math alttext="s t a t e m e n
    t 1"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi>
    <mi>n</mi> <msub><mi>t</mi> <mn>1</mn></msub></mrow></math> and <math alttext="s
    t a t e m e n t 2"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi>
    <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>2</mn></msub></mrow></math>
    are both true or both false.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi> <mi>t</mi>
    <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>1</mn></msub></mrow></math>
    *equivalent to* <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi> <mi>t</mi>
    <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>2</mn></msub></mrow></math> 当且仅当 <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi>
    <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>1</mn></msub></mrow></math> 和 <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi>
    <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>2</mn></msub></mrow></math> 都为真或都为假。
- en: 'We can summarize the above rules in a *truth table* accounting for all the
    possibilities for the states of <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi>
    <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>1</mn></msub></mrow></math> and <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi>
    <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>2</mn></msub></mrow></math> and for their joining using the five allowed operators.
    In the following truth table we use <math alttext="upper S 1"><msub><mi>S</mi>
    <mn>1</mn></msub></math> for <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi>
    <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>1</mn></msub></mrow></math> and <math alttext="upper S 2"><msub><mi>S</mi>
    <mn>2</mn></msub></math> for <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi>
    <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>2</mn></msub></mrow></math> to save space:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个*真值表*总结上述规则，考虑到 <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi>
    <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>1</mn></msub></mrow></math> 和 <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi>
    <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>2</mn></msub></mrow></math> 的状态以及它们的组合使用五个允许的运算符。在下面的真值表中，我们使用 <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> 代表 <math alttext="s t a t e m e
    n t 1"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi>
    <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>1</mn></msub></mrow></math>，使用 <math
    alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> 代表 <math alttext="s
    t a t e m e n t 2"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi>
    <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>2</mn></msub></mrow></math>
    以节省空间：
- en: '| <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> | <math
    alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> | not <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> | <math alttext="upper S 1"><msub><mi>S</mi>
    <mn>1</mn></msub></math> and <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    | <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> or <math
    alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> | <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> implies <math alttext="upper S
    2"><msub><mi>S</mi> <mn>2</mn></msub></math> | <math alttext="upper S 1"><msub><mi>S</mi>
    <mn>1</mn></msub></math> equivalent to <math alttext="upper S 2"><msub><mi>S</mi>
    <mn>2</mn></msub></math> |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> | <math
    alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> | not <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> | <math alttext="upper S 1"><msub><mi>S</mi>
    <mn>1</mn></msub></math> and <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    | <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> or <math
    alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> | <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> implies <math alttext="upper S
    2"><msub><mi>S</mi> <mn>2</mn></msub></math> | <math alttext="upper S 1"><msub><mi>S</mi>
    <mn>1</mn></msub></math> equivalent to <math alttext="upper S 2"><msub><mi>S</mi>
    <mn>2</mn></msub></math> |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| F | F | T | F | F | T | T |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| F | F | T | F | F | T | T |'
- en: '| F | T | T | F | T | T | F |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| F | T | T | F | T | T | F |'
- en: '| T | F | F | F | T | F | F |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| T | F | F | F | T | F | F |'
- en: '| T | T | F | T | T | T | T |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| T | T | F | T | T | T | T |'
- en: 'We can compute the truth of any complex statement using the above table by
    simple recursive evaluation. For example, if we are in a world where <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> is true, <math alttext="upper S
    2"><msub><mi>S</mi> <mn>2</mn></msub></math> is false, and <math alttext="upper
    S 3"><msub><mi>S</mi> <mn>3</mn></msub></math> is true, then the statement:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单的递归评估使用上述表格计算任何复杂语句的真值。例如，如果我们处于一个 <math alttext="upper S 1"><msub><mi>S</mi>
    <mn>1</mn></msub></math> 为真，<math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    为假，且 <math alttext="upper S 3"><msub><mi>S</mi> <mn>3</mn></msub></math> 为真的世界中，那么该语句：
- en: '*not* <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *and*
    ( <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> *or* <math
    alttext="upper S 3"><msub><mi>S</mi> <mn>3</mn></msub></math> ) <math alttext="long
    left right double arrow"><mo>⟺</mo></math> F *and*(F *or* T) = F *and* T = F.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*非* <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *且*
    ( <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> *或* <math
    alttext="upper S 3"><msub><mi>S</mi> <mn>3</mn></msub></math> ) <math alttext="long
    left right double arrow"><mo>⟺</mo></math> F *且*(F *或* T) = F *且* T = F。'
- en: 'To be able to reason and prove theorems using propositional logic, it is helpful
    to establish logical equivalences, meaning statements that have the exact same
    truth tables so they can replace each other in a reasoning process. The following
    are some examples of logical equivalences:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用命题逻辑推理和证明定理，建立逻辑等价是有帮助的，意味着具有完全相同真值表的陈述，因此它们可以在推理过程中相互替换。以下是一些逻辑等价的示例：
- en: 'Commutativity of *and*: <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *and* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> <math
    alttext="long left right double arrow"><mo>⟺</mo></math> <math alttext="upper
    S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> *and* <math alttext="upper S 1"><msub><mi>S</mi>
    <mn>1</mn></msub></math> .'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与的交换律： <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *与*
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> <math alttext="long
    left right double arrow"><mo>⟺</mo></math> <math alttext="upper S 2"><msub><mi>S</mi>
    <mn>2</mn></msub></math> *与* <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    。
- en: 'Commutativity of *or*: <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *or* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> <math
    alttext="long left right double arrow"><mo>⟺</mo></math> <math alttext="upper
    S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> *or* <math alttext="upper S 1"><msub><mi>S</mi>
    <mn>1</mn></msub></math> .'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或的交换律： <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *或*
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> <math alttext="long
    left right double arrow"><mo>⟺</mo></math> <math alttext="upper S 2"><msub><mi>S</mi>
    <mn>2</mn></msub></math> *或* <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    。
- en: 'Double negation elimination: not (not <math alttext="upper S 1"><msub><mi>S</mi>
    <mn>1</mn></msub></math> ) <math alttext="long left right double arrow"><mo>⟺</mo></math>
    <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> .'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双重否定消除：非(非 <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    ) <math alttext="long left right double arrow"><mo>⟺</mo></math> <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> 。
- en: 'Contraposition: <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *implies* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    <math alttext="long left right double arrow"><mo>⟺</mo></math> not( <math alttext="upper
    S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> ) *implies* not( <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逆否命题： <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *蕴含*
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> <math alttext="long
    left right double arrow"><mo>⟺</mo></math> 非( <math alttext="upper S 2"><msub><mi>S</mi>
    <mn>2</mn></msub></math> ) *蕴含* 非( <math alttext="upper S 1"><msub><mi>S</mi>
    <mn>1</mn></msub></math> ) 。
- en: 'Implication elimination: <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *implies* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    <math alttext="long left right double arrow"><mo>⟺</mo></math> not( <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ) *or* <math alttext="upper S 2"><msub><mi>S</mi>
    <mn>2</mn></msub></math> .'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蕴含消除： <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *蕴含*
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> <math alttext="long
    left right double arrow"><mo>⟺</mo></math> 非( <math alttext="upper S 1"><msub><mi>S</mi>
    <mn>1</mn></msub></math> ) *或* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    。
- en: 'De Morgan’s law: not( <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *and* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> ) <math
    alttext="long left right double arrow"><mo>⟺</mo></math> not( <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ) *or* not( <math alttext="upper
    S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> ).'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 德摩根定律：非( <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *且* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> ) <math
    alttext="long left right double arrow"><mo>⟺</mo></math> 非( <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ) *或* 非( <math alttext="upper S
    2"><msub><mi>S</mi> <mn>2</mn></msub></math> )。
- en: 'De Morgan’s law: not( <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *or* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> ) <math
    alttext="long left right double arrow"><mo>⟺</mo></math> not( <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ) *and* not( <math alttext="upper
    S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> ).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 德摩根定律：非( <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *或* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> ) <math
    alttext="long left right double arrow"><mo>⟺</mo></math> 非( <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ) *且* 非( <math alttext="upper S
    2"><msub><mi>S</mi> <mn>2</mn></msub></math> )。
- en: 'Let’s demonstrate that <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *implies* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    <math alttext="long left right double arrow"><mo>⟺</mo></math> not( <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ) *or* <math alttext="upper S 2"><msub><mi>S</mi>
    <mn>2</mn></msub></math> by showing that they have the same truth table, since
    this equivalence is not so intuitive for some people:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过展示它们具有相同的真值表来证明 <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *蕴含* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> <math
    alttext="long left right double arrow"><mo>⟺</mo></math> 非( <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ) *或* <math alttext="upper S 2"><msub><mi>S</mi>
    <mn>2</mn></msub></math>，因为这种等价对于一些人来说并不那么直观：
- en: '| <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> | not
    ( <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ) | <math
    alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> | not( <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ) *or* <math alttext="upper S 2"><msub><mi>S</mi>
    <mn>2</mn></msub></math> | <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *implies* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> | not
    ( <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ) | <math
    alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> | not( <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ) *or* <math alttext="upper S 2"><msub><mi>S</mi>
    <mn>2</mn></msub></math> | <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *implies* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| F | T | F | T | T |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| F | T | F | T | T |'
- en: '| F | T | T | T | T |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| F | T | T | T | T |'
- en: '| T | F | T | T | T |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| T | F | T | T | T |'
- en: '| T | F | F | F | F |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| T | F | F | F | F |'
- en: 'One example that demonstrates how logical equivalences are useful is the *proof
    by contradiction* way of reasoning: To prove that the statement <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> implies the statement <math alttext="upper
    S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> , we can assume that we have <math
    alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> but at the same
    time we do not have <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    , then we arrive at something false or absurd, which proves that we cannot assume
    <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> without concluding
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> as well. We
    can verify the validity of this way of proving that <math alttext="upper S 1"><msub><mi>S</mi>
    <mn>1</mn></msub></math> implies <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    using propositional logic equivalences:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 展示逻辑等价性有用的一个例子是*反证法*推理方式：为了证明陈述 <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    意味着陈述 <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> ，我们可以假设我们有
    <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ，但同时我们没有 <math
    alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> ，然后我们得出一个错误或荒谬的结论，这证明我们不能假设
    <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> 而不得出 <math
    alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> 。我们可以使用命题逻辑等价性验证这种证明方式的有效性，即
    <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> 意味着 <math
    alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> ：
- en: <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *implies*
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> = true <math
    alttext="long left right double arrow"><mo>⟺</mo></math>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *意味着* <math
    alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> = 真 <math alttext="long
    left right double arrow"><mo>⟺</mo></math>
- en: not( <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ) *or*
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> = true (implication
    removal) <math alttext="long left right double arrow"><mo>⟺</mo></math>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 非（ <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ）*或*
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> = 真（蕴含消除）
    <math alttext="long left right double arrow"><mo>⟺</mo></math>
- en: not(not( <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    ) *or* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> )=
    not(true) <math alttext="long left right double arrow"><mo>⟺</mo></math>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 非（非（ <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ）*或*
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> ）= 非（真） <math
    alttext="long left right double arrow"><mo>⟺</mo></math>
- en: <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *and* not(
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> )= false (De
    Morgan and double negation).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *和* 非（ <math
    alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> ）= 假（德摩根定律和双重否定）。
- en: 'We endow propositional logic framework with *rules of inference*, so that we
    are able to reason sequentially from one statement (simple or complex) to the
    next and arrive at a desired goal or at a correct proof of a statement. These
    are some of the rules of inference that accompany propositional logic:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们赋予命题逻辑框架*推理规则*，这样我们就能够从一个陈述（简单或复杂）顺序推理到下一个，并达到所需的目标或正确证明一个陈述。以下是一些伴随命题逻辑的推理规则：
- en: If <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *implies*
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> is true and
    we are given <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    , then we can infer <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    .
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *意味着*
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> 是真的，并且我们已知
    <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ，那么我们可以推断
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> 。
- en: If <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *and*
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> is true then
    we can infer <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    . Similarly, we can also infer <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    .
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果 <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *和*
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> 是真的，那么我们可以推断
    <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> 。同样，我们也可以推断
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> 。 '
- en: If <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *is equivalent
    to* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> then we
    can infer ( <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *implies* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    ) *and* ( <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    *implies* <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    )
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *等价于*
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> ，那么我们可以推断（
    <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *意味着* <math
    alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> ）*和*（ <math alttext="upper
    S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> *意味着* <math alttext="upper S 1"><msub><mi>S</mi>
    <mn>1</mn></msub></math> ）
- en: Conversely, if ( <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *implies* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    ) *and* ( <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    *implies* <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    ) then we can infer that ( <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *is equivalent to* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    ).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，如果（<math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *蕴含*
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> ）*和*（<math
    alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> *蕴含* <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ）那么我们可以推断出（<math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *等价于* <math alttext="upper S 2"><msub><mi>S</mi>
    <mn>2</mn></msub></math> ）。
- en: We finally emphasize that propositional logic does not scale to large size environments
    and cannot efficiently capture universal relationship patterns. However, propositional
    logic provides the foundation of first order logic and higher order logic, since
    those build on top of propositional logic’s machinery.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后强调命题逻辑不适用于大型环境，并且不能有效地捕捉普遍关系模式。然而，命题逻辑为一阶逻辑和高阶逻辑提供了基础，因为这些逻辑建立在命题逻辑的机制之上。
- en: From Few Axioms To A Whole Theory
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从少量公理到整个理论
- en: 'The above inference rules are *sound*: They allow us to prove only true statements,
    in the sense that given a true statement and we can a sound inference rule with
    it, we arrive at a true statement. Therefore, the guarantee that sound inference
    rules provide is that they do not allow false statements to be inferred from true
    ones. We need slightly more than that guarantee.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上述推理规则是*正确*的：它们只允许我们证明真实陈述，即给定一个真实陈述和一个与之相符的推理规则，我们得到一个真实陈述。因此，正确推理规则提供的保证是它们不允许从真实陈述中推导出错误陈述。我们需要比这个保证稍微多一点。
- en: 'A logical framework is *complete* when we are able to infer *all* possible
    true statements using only the system’s knowledge base (axioms) and its inference
    rules. The idea of *completeness* of a system is very important: In all mathematical
    systems, such as number theory, probability theory, set theory, or Euclidean geometry,
    we start with a set of axioms (Peano axioms for number theory and mathematical
    analysis, and probability axioms for probability theory) then we deduce theorems
    from these axioms using the logical rules of inference. One main question in any
    math theory is whether the axioms along with the rules of inference ensure its
    completeness and its consistency.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们能够仅使用系统的知识库（公理）和推理规则推断*所有*可能的真实陈述时，逻辑框架是*完备*的。系统的*完备性*的概念非常重要：在所有数学系统中，如数论、概率论、集合论或欧几里得几何中，我们从一组公理开始（数论和数学分析的皮亚诺公理，概率论的概率公理），然后使用逻辑推理规则从这些公理中推导定理。在任何数学理论中的一个主要问题是公理和推理规则是否确保其完备性和一致性。
- en: '*No first-order theory, however, has the strength to uniquely describe a structure
    with an infinite domain, such as the natural numbers or the real line. Axiom systems
    that do fully describe these two structures (that is, categorical axiom systems)
    can be obtained in stronger logics such as second-order logic.*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*然而，没有一阶理论有足够的力量来唯一描述具有无限域的结构，比如自然数或实数线。可以在更强的逻辑中获得完全描述这两个结构的公理系统（即，范畴公理系统），比如二阶逻辑。*'
- en: Codifying Logic Within An Agent
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在代理中编码逻辑
- en: 'Before moving on to first order logic, let’s recap what we learned in the context
    of an AI agent endowed with propositional logic. The following process is important
    and will be the same for more expressive logics:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进行一阶逻辑之前，让我们回顾一下在具有命题逻辑的AI代理环境中学到的内容。以下过程很重要，对于更具表现力的逻辑来说也是一样的：
- en: We program an initial knowledge base (axioms) in the form of true statements.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在形式为真实陈述的初始知识库（公理）中编写。
- en: We program the inference rules.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们编写推理规则。
- en: The agent perceives certain statements about the current state of its world.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理感知其世界当前状态的某些陈述。
- en: The agent may or may not have a goal statement.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理可能有或没有目标陈述。
- en: The agent uses the inference rules to infer new statements, and to decide what
    to do (move to the next room, open the door, set the alarm clock, *etc*.).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理使用推理规则推断新的陈述，并决定要做什么（移动到下一个房间，打开门，设置闹钟，*等等*）。
- en: Completeness of the agent’s system (knowledge base together with the inference
    rules) is important here, since it allows the agent to infer *any* satisfiable
    goal statement given enough inference steps.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理系统的完备性（知识库和推理规则的结合）在这里很重要，因为它允许代理在足够的推理步骤中推导出*任何*可满足的目标陈述。
- en: How Do Deterministic And Probabilistic Machine Learning Fit In?
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定性和概率机器学习如何适应其中？
- en: The premise of machine learning (including) neural networks is that we do not
    program an initial knowledge base into the agent, and we do not program inference
    rules. What we program instead is a way to represent the input data, the desired
    outputs, and a hypothesis function that maps the input to the output. The agent
    then learns the parameters of the function using by optimizing the objective function
    (loss function). Finally the agent makes inferences on new input data using the
    function it learned. So in this context, the knowledge base and the rules can
    be separated by *during learning* or *during inference*. During learning, the
    knowledge base is the data and the hypothesis function, the goal is minimizing
    the loss, and the rules are the optimization process. After learning, the agent
    uses the learned function for inference.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习（包括）神经网络的前提是我们不将初始知识库编程到代理中，也不编写推理规则。相反，我们编写的是一种表示输入数据、期望输出和将输入映射到输出的假设函数的方法。然后代理通过优化目标函数（损失函数）来学习函数的参数。最后，代理使用学到的函数对新的输入数据进行推理。因此，在这种情况下，知识库和规则可以通过*学习期间*或*推理期间*进行分离。在学习期间，知识库是数据和假设函数，目标是最小化损失，规则是优化过程。学习后，代理使用学到的函数进行推理。
- en: We can think of probabilistic machine learning models in exactly the same way
    if we replace the deterministic hypothesis function by the joint probability distribution
    of the features of the data. Once the agent learns it, it can use it for inference.
    For example, Bayesian networks would play a similar role for uncertain knowledge
    as propositional logic for definite knowledge.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将确定性假设函数替换为数据特征的联合概率分布，我们可以以完全相同的方式思考概率机器学习模型。一旦代理学会了它，就可以用于推理。例如，贝叶斯网络对于不确定知识的作用类似于命题逻辑对于确定知识的作用。
- en: First Order Logic
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一阶逻辑
- en: What objects exist in the agent’s world?
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理的世界中存在哪些对象？
- en: '*Statements, objects, and relations among them.*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: “陈述、对象和它们之间的关系。”
- en: How does the agent perceive the objects’ states?
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理如何感知对象的状态？
- en: '*True (1), False (0), or unknown.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: “真（1）、假（0）或未知。”
- en: 'Propositional logic is great for illustrating how knowledge based agents work,
    and to explain the basic rules of a certain logic’s *language* and rules of inference.
    However, propositional logic is limited it what knowledge it can represent and
    how it can reason about it. For example, in propositional logic, the statement:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 命题逻辑非常适合说明基于知识的代理如何工作，并解释某种逻辑的“语言”和推理规则的基本规则。然而，命题逻辑在能够表示的知识和推理方式方面存在局限。例如，在命题逻辑中，这样的陈述：
- en: '*All users who are older than eighteen can see this ad*.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有年龄超过十八岁的用户都可以看到这则广告。
- en: 'is easy to express as an *implies* statement (which is the same as *if then*),
    since this kind of language exists in the propositional logic framework. This
    is how we can express the above statement as an inference in propositional logic:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 可以表达为一个“蕴含”陈述（与“如果那么”相同），因为这种语言存在于命题逻辑框架中。这就是我们如何在命题逻辑中将上述陈述表达为推理的方式：
- en: (User older than eighteen *implies* see the ad) *and* (User older than eighteen
    = T) then we can infer that (see the ad = T).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: （年满十八岁的用户意味着看广告）*并且*（年满十八岁 = T）然后我们可以推断（看广告 = T）。
- en: 'Let’s now think of a slightly different statement:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一个略有不同的陈述：
- en: '*Some of the users who are older than eighteen click on the ad*.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一些年满十八岁的用户点击广告。
- en: Suddenly the language of propositional logic is not sufficient to express the
    quantity *some* in the above statement! An agent relying only on propositional
    logic will have to store the whole statement, as it is, in its knowledge base,
    then not know how to infer anything useful out of it. Meaning, suppose the agent
    gets the information that a user is indeed older than eighteen, it cannot predict
    whether the user will click on the ad or not.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 突然之间，命题逻辑的语言不足以表达上述陈述中的“一些”数量！仅依赖于命题逻辑的代理将不得不将整个陈述存储在其知识库中，然后不知道如何从中推断出任何有用信息。也就是说，假设代理获得了用户确实年满十八岁的信息，它无法预测用户是否会点击广告。
- en: 'We need a language (or a logical framework) that whose vocabulary includes
    *quantifiers* such as *there exist* and *for all*, so that we can write something
    like:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种语言（或逻辑框架），其中的词汇包括“存在”和“对于所有”，这样我们就可以写出类似以下的内容：
- en: '*For all* users who are older than eighteen, *there exists* a subset who clicks
    on the ad.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有年满十八岁的用户，存在一部分点击广告的用户。
- en: 'These two extra quantifiers are exactly what *first order logic* framework
    provides. This increase in vocabulary allows us to be more economical in what
    to store in the knowledge base, since we are able to break down the knowledge
    into objects and relations between them. For example, instead of storing:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个额外的量词正是“一阶逻辑”框架提供的。这种词汇量的增加使我们能够更经济地存储知识库中的内容，因为我们能够将知识分解为对象和它们之间的关系。例如，与其存储：
- en: '*All the users who are older than eighteen see the ad;*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所有年满十八岁的用户都看广告；
- en: '*Some of the users who are older than eighteen click on the ad;*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 年满十八岁的一些用户点击广告；
- en: '*Some of the users who are older than eighteen buy the product;*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一些年满十八岁的用户购买产品；
- en: '*Some of the users who click on the ad buy the product;*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 点击广告的一些用户购买了产品；
- en: 'as three separate statements in the knowledge base of an agent with only propositional
    logic framework (which we still don’t know how to infer anything useful from),
    we can store two statements in first order logic:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个只有命题逻辑框架的代理的知识库中的三个独立陈述（我们仍然不知道如何从中推断出任何有用信息），我们可以在一阶逻辑中存储两个陈述：
- en: '*For all* users who are older than eighteen, see ad = T;'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有年满十八岁的用户，看广告 = T；
- en: '*For all* users with see ad =T, *there exists* a subset who clicks on the ad;'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有看广告 = T的用户，存在一部分点击广告的用户；
- en: '*For all* users who click on the ad, *there exists* a subset who buys the product.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有点击广告的用户，存在一部分购买产品的用户。
- en: 'Note that in both propositional and first order logics, given only the above
    statements we will not be able to infer whether a specific user who is older than
    eighteen will click on the ad or buy the product, or even the percentage of those
    doing that, but at least in first order logic we have the language to express
    the same knowledge more concisely, and in a way where we would be able to make
    some useful inferences. The most distinctive feature of first order logic from
    propositional logic is that it adds to its base language quantifiers such as *there
    exist* and *for all* on top of *not*, *and*, *or*, *implies*, and *is equivalent
    to* that already exist in propositional logic. This little addition opens the
    door to express objects separately from their descriptions and their relationships
    to each other:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在命题逻辑和一阶逻辑中，仅凭上述陈述，我们将无法推断特定年满十八岁的用户是否会点击广告或购买产品，甚至无法推断这样做的用户的百分比，但至少在一阶逻辑中，我们有语言来更简洁地表达相同的知识，并且以一种能够进行一些有用推断的方式。一阶逻辑与命题逻辑最显著的特征是，在命题逻辑已有的基础语言上增加了诸如“存在”和“对于所有”之类的量词，这些量词已经存在于命题逻辑中的“非”、“和”、“或”、“蕴含”和“等价于”之上。这一小的增加打开了一个表达对象与其描述以及它们之间关系的大门：
- en: The powerful thing about propositional and first order logics is that their
    inference rules are independent form both the domain and its knowledge base or
    set of axioms. Now in order to develop a knowledge base for a specific domain,
    such as a math field, or circuit engineering, we must study the domain carefully,
    choose the vocabulary, then formulate the set of axioms that is required to support
    the desired inferences.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 命题逻辑和一阶逻辑的强大之处在于它们的推理规则独立于领域及其知识库或公理集。现在，为了为特定领域，如数学领域或电路工程，开发一个知识库，我们必须仔细研究该领域，选择词汇，然后制定支持所需推理的公理集。
- en: Relationships between *for all* and *there exists*
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*对于所有*和*存在*之间的关系'
- en: '*For all* and *there exist* are connected to each other through neagtion. The
    following two statements are equivalent:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于所有*和*存在*通过否定相互连接。以下两个陈述是等价的：'
- en: All users who are above eighteen see the ad.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有年满十八岁以上的用户看到广告。
- en: There exist no one above eighteen who doesn’t see the ad.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不存在一个年满十八岁以上的人不看广告。
- en: 'In propositional logic language, the above two statements translate to:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在命题逻辑语言中，上述两个陈述翻译为：
- en: For all users such that user>18 is true, see the ad is true.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有用户，使得用户>18为真，看到广告为真。
- en: There exist no user such that user>18 and see the ad is false
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不存在这样的用户，使得用户>18且看到广告是假的
- en: 'These are the relationships:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是关系：
- en: not(There exist an x such that P is true) <math alttext="long left right double
    arrow"><mo>⟺</mo></math> For all x, P is false.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: not(存在一个x使得P为真) <math alttext="long left right double arrow"><mo>⟺</mo></math>
    对于所有x，P为假。
- en: not(for all x, P is true) <math alttext="long left right double arrow"><mo>⟺</mo></math>
    There exists an x such that P is false.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: not(对于所有x，P为真) <math alttext="long left right double arrow"><mo>⟺</mo></math>
    存在一个x使得P为假。
- en: There exist an x such that P is true <math alttext="long left right double arrow"><mo>⟺</mo></math>
    not for all x P is false.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一个x使得P为真 <math alttext="long left right double arrow"><mo>⟺</mo></math> 不是对所有x，P为假。
- en: For all x, P is true <math alttext="long left right double arrow"><mo>⟺</mo></math>
    There exist no x such that P is false.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有x，P为真 <math alttext="long left right double arrow"><mo>⟺</mo></math> 不存在一个x使得P为假。
- en: 'We cannot leave this section without appreciating the expressive power we gained
    by moving to first order logic. This logic framework is now sufficient for such
    assertions and inferences to make sense:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在不欣赏转向一阶逻辑所获得的表达能力的情况下离开这一部分。这种逻辑框架现在足以支持这样的断言和推理：
- en: Universal approximation theorem for neural networks
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络的普适逼近定理
- en: 'Roughly speaking, the universal approximation theorem asserts that: *For all*
    continuous functions, *there exists* a neural network that can approximate the
    function to as closely as we wish. Note that this does not tell us how to construct
    such a network, it only asserts its existence. Still, this theorem is powerful
    enough to make us *unsurprised* about the success of neural networks in approximating
    all kinds of *input* to *output* functions in all kinds of applications.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 粗略地说，普适逼近定理断言：对于所有连续函数，存在一个神经网络可以将函数近似到我们希望的程度。请注意，这并不告诉我们如何构建这样的网络，它只是断言其存在。尽管如此，这个定理足够强大，使我们对神经网络在各种应用中近似所有种类的输入到输出函数的成功感到不惊讶。
- en: Inferring relationships
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 推断关系
- en: 'Parents and children have inverse relationships to each other: If Sary is the
    child of Hala then Hala is the mother of Sary. Moreover, the relationship is in
    one direction: Sary cannot be the mother of Hala. In first order logic, we can
    assign two functions indicating the relationships: *mother of* and *child of*,
    variables that can be filled in by *Hala* and *Sary* or any other mother and child,
    and a relationship between the *functions* that holds for all their input variables:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 父母和孩子之间具有相反的关系：如果Sary是Hala的孩子，则Hala是Sary的母亲。此外，关系是单向的：Sary不能是Hala的母亲。在一阶逻辑中，我们可以分配两个指示关系的函数：*母亲*和*孩子*，可以由*Hala*和*Sary*或任何其他母亲和孩子填充的变量，以及这些*函数*之间对所有输入变量成立的关系：
- en: '*For all* x,y, if mother(x,y)=T then mother(y,x)=F;'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有的x，y，如果mother(x,y)=T，则mother(y,x)=F；
- en: and *for all* x,y, mother(x,y) <math alttext="long left right double arrow"><mo>⟺</mo></math>
    child(y,x).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有的x，y，mother(x,y) <math alttext="long left right double arrow"><mo>⟺</mo></math>
    child(y,x)。
- en: 'Now if we equip an agent with this knowledge and tell it that Hala is the mother
    of Sary, or mother(Hala, Sary)=T, then it will be able to answer queries like:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们给一个代理提供这些知识，并告诉它Hala是Sary的母亲，或者mother(Hala, Sary)=T，那么它将能够回答类似以下的查询：
- en: Is Hala the mother of Sary? T
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hala是Sary的母亲吗？T
- en: Is Sary the mother of Hala? F
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sary是Hala的母亲吗？F
- en: Is Sary the child of Hala? T
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sary是Hala的孩子吗？T
- en: Is Hala the child of Sary? F
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hala是Sary的孩子吗？F
- en: Is Laura the mother of Joseph? Unknown
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Laura是Joseph的母亲吗？未知
- en: Note that we will have to store each statement separately in a propositional
    logic world which is outrageously inefficient.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在命题逻辑世界中，我们将不得不将每个陈述单独存储，这是极其低效的。
- en: Probabilistic Logic
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概率逻辑
- en: What objects exist in the agent’s world?
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理的世界中存在哪些对象？
- en: '*Statements*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*陈述*'
- en: How does the agent perceive the objects’ states?
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理如何感知对象的状态？
- en: '*A probability value between 0 and 1 that a statement is true.*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个介于0和1之间的概率值，表示一个陈述为真的可能性。*'
- en: Probability is the extension of first order logic that allows us to quantify
    our uncertainty about the truth of a statement. Rather than asserting whether
    a statement is true or false, we assign the degree of our belief in the truth
    of the statement a score between zero and one. Propositional and first order logics
    provide a set of inference rules that allow us to determine the truth of some
    statements given the assumption that some other statements are true. Probability
    theory provides a set of inference rules that allow us to determine how likely
    a statement is true given the likelihood of truth of other statements.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 概率是一阶逻辑的扩展，允许我们量化对陈述真实性的不确定性。我们不是断言一个陈述是真还是假，而是为我们对该陈述真实性的信念程度分配一个介于零和一之间的分数。命题和一阶逻辑提供了一组推理规则，允许我们确定一些陈述的真实性，假设其他一些陈述为真。概率理论提供了一组推理规则，允许我们确定一个陈述在其他陈述的真实性可能性的基础上有多大可能是真的。
- en: 'This extension to dealing with uncertainty results in a more expressive framework
    than first order logic. The axioms of probability allow us to extend traditional
    logic truth tables and inference rules: For example, P(A)+P(not (A))=1: If A is
    true then P(A)=1 and P(not A)=0, which is consistent with first order logic about
    a statement and its negation.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 处理不确定性的这种扩展比一阶逻辑具有更具表现力的框架。概率公理允许我们扩展传统逻辑真值表和推理规则：例如，P(A)+P(not (A))=1：如果A为真，则P(A)=1且P(not
    A)=0，这与关于陈述及其否定的一阶逻辑一致。
- en: Viewing probability theory as a natural extension of first order logic is satisfying
    to a mind that needs to connect things together as opposed to viewing them as
    disparate things. Viewing it this way also naturally leads to Bayesian reasoning
    about data, since we update an agent’s prior distribution as we gather more knowledge
    and make better inferences. This binds all our subjects together in the most *logical*
    way.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将概率理论视为一阶逻辑的自然扩展对于需要将事物连接在一起而不是将它们视为不同事物的思维是令人满意的。这样看待也自然地导致了关于数据的贝叶斯推理，因为我们在收集更多知识并做出更好推断时更新代理人的先验分布。这以最*逻辑*的方式将我们所有的主题联系在一起。
- en: Fuzzy Logic
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊逻辑
- en: What objects exist in the agent’s world? Statements with a degree of truth between
    [0,1]. . How does the agent perceive the objects’ states? A known interval value.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在代理人的世界中存在哪些对象？具有[0,1]之间真实程度的陈述。代理人如何感知对象的状态？已知的区间值。
- en: 'The worlds of propositional and first order logic are black and white, true
    or false. They allow us to start with true statements and infer other true statements.
    This setting is perfect for mathematics where everything can either be right or
    wrong (true or false), or for a video game with very clear boundaries for its
    SIMS. In the real world many statements can be vague whether they are fully true
    (1) or fully false (0), meaning they exit on a *scale of truth* as opposed to
    at the edges: *Paris is romantic*; *She is happy*; *The Dark Knight movie is good*.
    *Fuzzy logic* allows this and assigns values to statements between 0 and 1 as
    opposed to strict 0 or strict 1:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 命题和一阶逻辑的世界是黑白分明的，真或假。它们允许我们从真实陈述开始推断其他真实陈述。这种设置非常适合数学，其中一切都可以是对或错（真或假），或者适合具有非常明确边界的SIMS的视频游戏。在现实世界中，许多陈述可能是模糊的，无论它们是完全真（1）还是完全假（0），这意味着它们存在于*真实度*的尺度上，而不是在边缘上：*巴黎浪漫*；*她很快乐*；*黑暗骑士电影很好*。*模糊逻辑*允许这样做，并为陈述分配0到1之间的值，而不是严格的0或严格的1：
- en: Paris is romantic (0.8); She is happy (0.6); The Dark Knight movie is good (0.9).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 巴黎浪漫（0.8）；她很快乐（0.6）；黑暗骑士电影很好（0.9）。
- en: 'How do we make inference in a vague world where truth comes on a sliding scale?
    It definitely is not as straightforward as inference in true and false worlds.
    For example, how true is the statement: Paris is romantic *and* she is happy given
    the above truth values? We need new rules to assign these values, and we need
    to know the context, or a domain knowledge. Another option is word vectors, which
    we discussed in [Chapter 7](ch07.xhtml#ch07). These vectors carry the meaning
    of words in different dimensions, so we can compute the cosine similarity between
    the vector representing the word Paris and the vector representing the point romantic,
    and assign that as the truth value of the statement Paris is romantic.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个真假程度呈滑动尺度的模糊世界中如何进行推理？这绝对不像在真假世界中进行推理那样直截了当。例如，给定上述真值，陈述巴黎浪漫*且*她很快乐有多真实？我们需要新的规则来分配这些值，并且我们需要了解上下文或领域知识。另一个选择是单词向量，我们在[第7章](ch07.xhtml#ch07)中讨论过。这些向量在不同维度中携带单词的含义，因此我们可以计算代表单词巴黎的向量与代表浪漫点的向量之间的余弦相似度，并将其分配为巴黎浪漫的陈述的真值。
- en: 'Note that the degree of belief in probability theory is not the same as the
    scale of truth in fuzzy logic. In probabilistic logic, the statements themselves
    are unambiguous. What we want to infer is the probability that the unambiguous
    statement is true. Probability theory does not reason about statements that are
    not entirely true or false: We do not calculate the probability that Paris is
    romantic, but we calculate the probability that a person randomly asked whether
    Paris is romantic, would answer true or false.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，概率理论中的信念程度与模糊逻辑中的真实度尺度不同。在概率逻辑中，陈述本身是明确的。我们想要推断的是明确陈述为真的概率。概率理论不推理不完全真实或假的陈述：我们不计算巴黎浪漫的概率，而是计算随机询问巴黎是否浪漫的人会回答真或假的概率。
- en: 'One interesting thing about fuzzy logic is that it kicks two principles present
    in other logics to the curb: The principle that if a statement is true then its
    negation is false, and the principle that two contradictory cannot be true at
    the same time. This actually opens the door to inconsistency and *open universe*.
    In a way fuzzy logic doesn’t attempt to correct vagueness, instead it embraces
    it and leverages it to allow functioning in a world where the boundaries are unclear.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 关于模糊逻辑的一个有趣之处在于，它将其他逻辑中存在的两个原则抛在一边：如果一个陈述是真的，那么它的否定就是假的原则，以及两个矛盾的陈述不能同时为真的原则。这实际上打开了不一致性和*开放宇宙*的大门。在某种程度上，模糊逻辑并不试图纠正模糊性，而是接受它并利用它来允许在边界不清晰的世界中运作。
- en: Temporal Logic
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间逻辑
- en: There are other types of special purpose logics, where certain objects, such
    as *time* in this section, are given special attention, having their own axioms
    and inference rules, because they are central to the knowledge that needs to be
    represented and the reasoning about it. *Temporal logic* puts time dependence
    and the axioms and inference rules about time dependence at the forefront of its
    structure, as opposed to adding statements that include time information to the
    knowledge base. In temporal logic, statements or facts are true at ceratain times,
    which could be time points or time intervals, and these times are ordered.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他类型的特殊用途逻辑，其中某些对象，比如本节中的“时间”，受到特别关注，有自己的公理和推理规则，因为它们对需要表示的知识和对其进行推理至关重要。*时间逻辑*将时间依赖性以及关于时间依赖性的公理和推理规则置于其结构的前沿，而不是将包含时间信息的陈述添加到知识库中。在时间逻辑中，陈述或事实在某些时间点或时间间隔上是真实的，这些时间是有序的。
- en: What objects exist in the agent’s world? Statements, objects, relations, times.
    . How does the agent perceive the objects’ states? True (1), False (0), or unknown.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 代理的世界中存在哪些对象？陈述、对象、关系、时间。代理如何感知对象的状态？真（1）、假（0）或未知。
- en: 'In temporal logic, we can represent statements such as:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间逻辑中，我们可以表示如下陈述：
- en: The alarm goes off when it is 7:00 a.m.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当时间是早上7点时，闹钟会响。
- en: Whenever a request is made to a server, access is eventually granted, but it
    can never be granted to two simultaneous requests.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当向服务器发出请求时，最终会授予访问权限，但永远不会同时授予两个请求。
- en: Comparison With Human Natural Language
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与人类自然语言的比较
- en: 'We spent the whole chapter going through logical systems that are able to express
    knowledge that humans’ natural languages seem to do effortlessly. I just wrote
    a whole book about math using only the English language, as opposed to any other
    technical language. How do we do it? How do humans represent and expand their
    knowledge base and what rules does natural language use for representation and
    reasoning that it is able to be so expressive? Moreover, the particular natural
    language used is not important: Any multi-lingual speaker knows the thought but
    not necessarily which particular language they are using to express that thought.
    There is an internal nonverbal representation for what people know or want to
    express. How does it work, and how can we unlock its secrets and give them to
    our machines?'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在整章中讨论了能够表达人类自然语言似乎轻松做到的知识的逻辑系统。我刚刚用英语写了一本关于数学的整本书，而不是使用任何其他技术语言。我们是如何做到的？人类如何表示和扩展他们的知识库，自然语言使用什么规则来表示和推理，使其如此富有表现力？此外，使用的特定自然语言并不重要：任何多语言的说话者都知道思想，但不一定知道他们用来表达这种思想的特定语言。人们知道或想要表达的东西有一种内在的非语言表示。它是如何工作的，我们如何解锁它的秘密并将其传授给我们的机器？
- en: Similar to human language, if we represent the same knowledge in two different
    formal logics, then we can infer the same facts (assuming the logics have completeness
    inference rules). The only difference would be which logic framework provides
    an easier route for inference.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与人类语言类似，如果我们用两种不同的形式逻辑来表示相同的知识，那么我们可以推断相同的事实（假设逻辑具有完整的推理规则）。唯一的区别在于哪种逻辑框架提供了更容易的推理路径。
- en: That said, human natural language allows for ambiguity on many occasions and
    cannot make absolute mathematical assertions without the formality of mathematics
    and the formal logic it employs. I cannot ask a human who has no access to a gps
    system to predict the exact time it takes to drive from DC to NYC at on a specific
    day.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，人类自然语言在许多情况下允许模糊性，并且不能在没有数学形式和所采用的形式逻辑的情况下做出绝对的数学断言。我不能要求一个没有GPS系统的人预测从DC到NYC的驾驶时间。
- en: Summary And Looking Ahead
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结和展望
- en: An AI agent endowed with various types of logics can express knowledge about
    the world, reason about it, answer queries, and make inferences, that are allowed
    within the boundaries of these logics.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有各种类型逻辑的AI代理可以表达关于世界的知识，对其进行推理，回答查询，并进行推断，这些都在这些逻辑的边界内是允许的。
- en: We discussed various logic frameworks, including propositional logic, first
    order logic, probabilistic logic, fuzzy logic, and temporal logic.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了各种逻辑框架，包括命题逻辑、一阶逻辑、概率逻辑、模糊逻辑和时间逻辑。
- en: 'The next natural questions would be: What content should go into an agent’s
    knowledge base? And how to represent facts about the world? In what framework
    should knowledge be represented and inference made?'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个自然的问题将是：代理的知识库应该包含什么内容？如何表示关于世界的事实？知识应该在什么框架中表示和推理？
- en: Propositional logic?
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命题逻辑？
- en: First order logic?
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一阶逻辑？
- en: Hierarchical task networks for reasoning about plans?
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于推理计划的分层任务网络？
- en: Bayesian networks for reasoning with uncertainty?
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于处理不确定性推理的贝叶斯网络？
- en: Causal diagrams and causal reasoning where an agent is allowed to selectively
    break the rules of logic?
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因果图和因果推理，代理可以有选择地违反逻辑规则？
- en: Markov models for reasoning over time?
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于随时间推理的马尔可夫模型？
- en: Deep neural networks for reasoning about images, sounds, or other data?
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于推理图像、声音或其他数据的深度神经网络？
- en: Another possible next step is to dive deeper into any of the logic frameworks
    that we disucssed, learning their inference rules and existing algorithms for
    inference, along with their strengths, weaknesses, and which kinds of knowledge
    bases they apply to. A recurring theme in these studies are investigating inference
    rules that provide a complete proof system, meaning a system where the axioms
    or the knowledge base along with the rules allow one to prove *all* possible true
    statements. Such rules include the *resolution inference rule* for propositional
    logic and the *generalized resoluton inference rule* for first order logic, which
    work for special types of knowledge bases. These are all important for theory
    (proving mathematical theorems), and technology (verifying and synthesizing) software
    and hardware. Finally, some logics are *strictly more expressive* than others,
    in the sense that some statements that we can represent in the more expressive
    logic cannot be expressed by any finite number statements using the language of
    the less expressive logic. For example, *higher order logic* (which we did not
    discuss in this chapter) is strictly more expressive than first order logic (which
    we did discuss in this chapter, and which is powerful enough to support entire
    math theories).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的下一步是深入研究我们讨论过的任何逻辑框架，学习它们的推理规则和现有的推理算法，以及它们的优势、劣势以及适用于哪种知识库。这些研究中的一个重要主题是调查提供完整证明系统的推理规则，意味着一个系统，其中公理或知识库以及规则允许证明*所有*可能的真陈述。这些规则包括命题逻辑的*分辨推理规则*和一阶逻辑的*广义分辨推理规则*，适用于特定类型的知识库。这些对于理论（证明数学定理）和技术（验证和合成）软件和硬件都很重要。最后，一些逻辑比其他逻辑*更具表现力*，意思是我们可以用更具表现力的逻辑表示的一些陈述，不能用较不具表现力的逻辑语言中的任何有限数量的陈述来表达。例如，*高阶逻辑*（我们在本章中没有讨论）比一阶逻辑（我们在本章中讨论过，足够强大以支持整个数学理论）更具表现力。
