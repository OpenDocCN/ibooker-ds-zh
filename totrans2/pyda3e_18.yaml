- en: Appendix A — Advanced NumPy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A — 高级NumPy
- en: 原文：[https://wesmckinney.com/book/advanced-numpy](https://wesmckinney.com/book/advanced-numpy)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://wesmckinney.com/book/advanced-numpy](https://wesmckinney.com/book/advanced-numpy)
- en: '*This Open Access web version of *Python for Data Analysis 3rd Edition* is
    now available as a companion to the [print and digital editions](https://amzn.to/3DyLaJc).
    If you encounter any errata, [please report them here](https://oreilly.com/catalog/0636920519829/errata).
    Please note that some aspects of this site as produced by Quarto will differ from
    the formatting of the print and eBook versions from O’Reilly.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个开放获取的网络版本*Python for Data Analysis 3rd Edition*现在作为[印刷版和数字版](https://amzn.to/3DyLaJc)的伴侣可用。如果您发现任何勘误，请[在这里报告](https://oreilly.com/catalog/0636920519829/errata)。请注意，由Quarto制作的本站的某些方面与O’Reilly的印刷版和电子书版本的格式不同。'
- en: If you find the online edition of the book useful, please consider [ordering
    a paper copy](https://amzn.to/3DyLaJc) or a [DRM-free eBook](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)
    to support the author. The content from this website may not be copied or reproduced.
    The code examples are MIT licensed and can be found on GitHub or Gitee.*  *In
    this appendix, I will go deeper into the NumPy library for array computing. This
    will include more internal details about the ndarray type and more advanced array
    manipulations and algorithms.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现本书的在线版本有用，请考虑[订购纸质版](https://amzn.to/3DyLaJc)或[无DRM的电子书](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)以支持作者。本网站的内容不得复制或复制。代码示例采用MIT许可证，可以在GitHub或Gitee上找到。*
    *在这个附录中，我将深入探讨NumPy库的数组计算。这将包括有关ndarray类型的更多内部细节以及更高级的数组操作和算法。
- en: 'This appendix contains miscellaneous topics and does not necessarily need to
    be read linearly. Throughout the chapters, I will generate random data for many
    examples that will use the default random number generator in the `numpy.random`
    module:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这个附录包含各种主题，不一定需要按顺序阅读。在各章节中，我将为许多示例生成随机数据，这些示例将使用`numpy.random`模块中的默认随机数生成器：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A.1 ndarray Object Internals
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.1 ndarray对象内部
- en: The NumPy ndarray provides a way to interpret a block of homogeneously typed
    data (either contiguous or strided) as a multidimensional array object. The data
    type, or *dtype*, determines how the data is interpreted as being floating point,
    integer, Boolean, or any of the other types we’ve been looking at.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy ndarray提供了一种将块状同类型数据（连续或分步）解释为多维数组对象的方法。数据类型，或*dtype*，决定了数据被解释为浮点数、整数、布尔值或我们一直在查看的其他类型之一。
- en: 'Part of what makes ndarray flexible is that every array object is a *strided*
    view on a block of data. You might wonder, for example, how the array view `arr[::2,
    ::-1]` does not copy any data. The reason is that the ndarray is more than just
    a chunk of memory and a data type; it also has *striding* information that enables
    the array to move through memory with varying step sizes. More precisely, the
    ndarray internally consists of the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray灵活的部分之一是每个数组对象都是对数据块的*步进*视图。例如，您可能想知道，例如，数组视图`arr[::2, ::-1]`如何不复制任何数据。原因是ndarray不仅仅是一块内存和一个数据类型；它还具有*步进*信息，使数组能够以不同的步长在内存中移动。更准确地说，ndarray内部包含以下内容：
- en: A *pointer to data*—that is, a block of data in RAM or in a memory-mapped file
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*数据指针*—即RAM中的数据块或内存映射文件
- en: The *data type* or dtype describing fixed-size value cells in the array
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述数组中固定大小值单元的*数据类型*或dtype
- en: A tuple indicating the array’s *shape*
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指示数组*形状*的元组
- en: A tuple of *strides*—integers indicating the number of bytes to “step” in order
    to advance one element along a dimension
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*步长*元组—表示在一个维度上前进一个元素所需的字节数
- en: See [Figure A.1](#fig-figure_ndarray) for a simple mock-up of the ndarray innards.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[图A.1](#fig-figure_ndarray)以查看ndarray内部的简单模拟。
- en: '![](../Images/e27af70a8051b0749f47f917cb9bc365.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e27af70a8051b0749f47f917cb9bc365.png)'
- en: 'Figure A.1: The NumPy ndarray object'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.1：NumPy ndarray对象
- en: 'For example, a 10 × 5 array would have the shape `(10, 5)`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个10×5的数组将具有形状`(10, 5)`：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A typical (C order) 3 × 4 × 5 array of `float64` (8-byte) values has the strides
    `(160, 40, 8)` (knowing about the strides can be useful because, in general, the
    larger the strides on a particular axis, the more costly it is to perform computation
    along that axis):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的（C顺序）3×4×5的`float64`（8字节）值数组具有步长`(160, 40, 8)`（了解步长可以是有用的，因为一般来说，特定轴上的步长越大，沿着该轴执行计算的成本就越高）：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While it is rare that a typical NumPy user would be interested in the array
    strides, they are needed to construct "zero-copy" array views. Strides can even
    be negative, which enables an array to move "backward" through memory (this would
    be the case, for example, in a slice like `obj[::-1]` or `obj[:, ::-1]`).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然典型的NumPy用户很少会对数组的步长感兴趣，但它们需要用来构建“零拷贝”数组视图。步长甚至可以是负数，这使得数组可以在内存中“向后”移动（例如，在像`obj[::-1]`或`obj[:,
    ::-1]`这样的切片中）。
- en: NumPy Data Type Hierarchy
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NumPy数据类型层次结构
- en: 'You may occasionally have code that needs to check whether an array contains
    integers, floating-point numbers, strings, or Python objects. Because there are
    multiple types of floating-point numbers (`float16` through `float128`), checking
    that the data type is among a list of types would be very verbose. Fortunately,
    the data types have superclasses, such as `np.integer` and `np.floating`, which
    can be used with the `np.issubdtype` function:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能偶尔需要检查代码是否包含整数、浮点数、字符串或Python对象的数组。由于有多种浮点数类型（`float16`到`float128`），检查数据类型是否在类型列表中会非常冗长。幸运的是，数据类型有超类，如`np.integer`和`np.floating`，可以与`np.issubdtype`函数一起使用：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can see all of the parent classes of a specific data type by calling the
    type’s `mro` method:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用类型的`mro`方法查看特定数据类型的所有父类：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Therefore, we also have:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们还有：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Most NumPy users will never have to know about this, but it is occasionally
    useful. See [Figure A.2](#fig-figure_dtype_hierarchy) for a graph of the data
    type hierarchy and parent–subclass relationships.[¹](#fn1)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 NumPy 用户永远不需要了解这一点，但有时会有用。请参见[图 A.2](#fig-figure_dtype_hierarchy)以查看数据类型层次结构和父-子类关系的图表。[¹](#fn1)
- en: '![](../Images/d60ef95fddd13030d45f90939bef5ca1.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d60ef95fddd13030d45f90939bef5ca1.png)'
- en: 'Figure A.2: The NumPy data type class hierarchy'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.2：NumPy 数据类型类层次结构
- en: A.2 Advanced Array Manipulation
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.2 高级数组操作
- en: There are many ways to work with arrays beyond fancy indexing, slicing, and
    Boolean subsetting. While much of the heavy lifting for data analysis applications
    is handled by higher-level functions in pandas, you may at some point need to
    write a data algorithm that is not found in one of the existing libraries.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了花式索引、切片和布尔子集之外，还有许多处理数组的方法。虽然大部分数据分析应用程序的繁重工作由 pandas 中的高级函数处理，但您可能在某个时候需要编写一个在现有库中找不到的数据算法。
- en: Reshaping Arrays
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新塑形数组
- en: 'In many cases, you can convert an array from one shape to another without copying
    any data. To do this, pass a tuple indicating the new shape to the `reshape` array
    instance method. For example, suppose we had a one-dimensional array of values
    that we wished to rearrange into a matrix (this is illustrated in [Figure A.3](#fig-figure_c_vs_fortran)):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，您可以将一个数组从一种形状转换为另一种形状而不复制任何数据。为此，将表示新形状的元组传递给 `reshape` 数组实例方法。例如，假设我们有一个希望重新排列成矩阵的值的一维数组（这在[图
    A.3](#fig-figure_c_vs_fortran)中有说明）：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](../Images/cf72351c291cc639dc236d8072622fe1.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cf72351c291cc639dc236d8072622fe1.png)'
- en: 'Figure A.3: Reshaping in C (row major) or FORTRAN (column major) order'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.3：按 C（行主要）或 FORTRAN（列主要）顺序重新塑形
- en: 'A multidimensional array can also be reshaped:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组也可以被重新塑形：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'One of the passed shape dimensions can be –1, in which case the value used
    for that dimension will be inferred from the data:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 传递的形状维度中可以有一个为 -1，在这种情况下，该维度的值将从数据中推断出来：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Since an array’s `shape` attribute is a tuple, it can be passed to `reshape`,
    too:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组的 `shape` 属性是一个元组，它也可以传递给 `reshape`：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The opposite operation of `reshape` from one-dimensional to a higher dimension
    is typically known as *flattening* or *raveling*:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从一维到更高维的 `reshape` 的相反操作通常称为 *展平* 或 *raveling*：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`ravel` does not produce a copy of the underlying values if the values in the
    result were contiguous in the original array.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果中的值在原始数组中是连续的，`ravel` 不会生成基础值的副本。
- en: 'The `flatten` method behaves like `ravel` except it always returns a copy of
    the data:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatten` 方法的行为类似于 `ravel`，只是它总是返回数据的副本：'
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The data can be reshaped or raveled in different orders. This is a slightly
    nuanced topic for new NumPy users and is therefore the next subtopic.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以以不同的顺序被重新塑形或展开。这对于新的 NumPy 用户来说是一个略微微妙的主题，因此是下一个子主题。
- en: C Versus FORTRAN Order
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C 与 FORTRAN 顺序
- en: NumPy is able to adapt to many different layouts of your data in memory. By
    default, NumPy arrays are created in *row major* order. Spatially this means that
    if you have a two-dimensional array of data, the items in each row of the array
    are stored in adjacent memory locations. The alternative to row major ordering
    is *column major* order, which means that values within each column of data are
    stored in adjacent memory locations.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 能够适应内存中数据的许多不同布局。默认情况下，NumPy 数组是按 *行主要* 顺序创建的。从空间上讲，这意味着如果您有一个二维数据数组，数组中每行的项都存储在相邻的内存位置上。与行主要顺序相反的是
    *列主要* 顺序，这意味着数据中每列的值都存储在相邻的内存位置上。
- en: For historical reasons, row and column major order are also known as C and FORTRAN
    order, respectively. In the FORTRAN 77 language, matrices are all column major.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 出于历史原因，行和列主要顺序也被称为 C 和 FORTRAN 顺序。在 FORTRAN 77 语言中，矩阵都是列主要的。
- en: 'Functions like `reshape` and `ravel` accept an `order` argument indicating
    the order to use the data in the array. This is usually set to `''C''` or `''F''`
    in most cases (there are also less commonly used options `''A''` and `''K''`;
    see the NumPy documentation, and refer back to [Figure A.3](#fig-figure_c_vs_fortran)
    for an illustration of these options):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `reshape` 和 `ravel` 这样的函数接受一个 `order` 参数，指示数组中使用数据的顺序。在大多数情况下，这通常设置为 `'C'`
    或 `'F'`（还有一些不常用的选项 `'A'` 和 `'K'`；请参阅 NumPy 文档，并参考[图 A.3](#fig-figure_c_vs_fortran)以了解这些选项的说明）：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Reshaping arrays with more than two dimensions can be a bit mind-bending (see
    [Figure A.3](#fig-figure_c_vs_fortran)). The key difference between C and FORTRAN
    order is the way in which the dimensions are walked:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用超过两个维度的数组进行重新塑形可能有点令人费解（参见[图 A.3](#fig-figure_c_vs_fortran)）。C 和 FORTRAN 顺序之间的关键区别在于维度的遍历方式：
- en: C/row major order
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: C/行主要顺序
- en: Traverse higher dimensions *first* (e.g., axis 1 before advancing on axis 0).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历更高维度时，*首先* 遍历（例如，先在轴 1 上再在轴 0 上前进）。
- en: FORTRAN/column major order
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: FORTRAN/列主要顺序
- en: Traverse higher dimensions *last* (e.g., axis 0 before advancing on axis 1).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历更高维度时，*最后* 遍历（例如，先在轴 0 上再在轴 1 上前进）。
- en: Concatenating and Splitting Arrays
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接和分割数组
- en: '`numpy.concatenate` takes a sequence (tuple, list, etc.) of arrays and joins
    them in order along the input axis:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.concatenate` 接受一个数组序列（元组，列表等），并按顺序沿着输入轴连接它们：'
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There are some convenience functions, like `vstack` and `hstack`, for common
    kinds of concatenation. The preceding operations could have been expressed as:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些便利函数，如 `vstack` 和 `hstack`，用于常见类型的连接。前面的操作可以表示为：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`split`, on the other hand, slices an array into multiple arrays along an axis:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`split` 将数组沿着一个轴分割成多个数组：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The value `[1, 3]` passed to `np.split` indicates the indices at which to split
    the array into pieces.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `np.split` 的值 `[1, 3]` 指示在哪些索引处将数组分割成片段。
- en: See [Table A.1](#tbl-table_array_concatenating) for a list of all relevant concatenation
    and splitting functions, some of which are provided only as a convenience of the
    very general-purpose `concatenate`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[表 A.1](#tbl-table_array_concatenating)以获取所有相关连接和分割函数的列表，其中一些仅作为非常通用的 `concatenate`
    的便利。
- en: 'Table A.1: Array concatenation functions'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 表A.1：数组连接函数
- en: '| Function | Description |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `concatenate` | Most general function, concatenate collection of arrays along
    one axis |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `concatenate` | 最通用的函数，沿一个轴连接数组集合 |'
- en: '| `vstack, row_stack` | Stack arrays by rows (along axis 0) |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `vstack, row_stack` | 按行堆叠数组（沿轴0） |'
- en: '| `hstack` | Stack arrays by columns (along axis 1) |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `hstack` | 按列堆叠数组（沿轴1） |'
- en: '| `column_stack` | Like `hstack`, but convert 1D arrays to 2D column vectors
    first |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `column_stack` | 类似于`hstack`，但首先将1D数组转换为2D列向量 |'
- en: '| `dstack` | Stack arrays by “depth” (along axis 2) |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `dstack` | 按“深度”（沿轴2）堆叠数组 |'
- en: '| `split` | Split array at passed locations along a particular axis |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `split` | 沿特定轴在传递位置分割数组 |'
- en: '| `hsplit`/`vsplit` | Convenience functions for splitting on axis 0 and 1,
    respectively |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `hsplit`/`vsplit` | 在轴0和1上分割的便利函数 |'
- en: 'Stacking helpers: r_ and c_'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 堆叠助手：r_ 和 c_
- en: 'There are two special objects in the NumPy namespace, `r_` and `c_`, that make
    stacking arrays more concise:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy命名空间中有两个特殊对象，`r_`和`c_`，使堆叠数组更简洁：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'These additionally can translate slices to arrays:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些还可以将切片转换为数组：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: See the docstring for more on what you can do with `c_` and `r_`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 查看文档字符串以了解您可以使用`c_`和`r_`做什么。
- en: 'Repeating Elements: tile and repeat'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复元素：tile 和 repeat
- en: 'Two useful tools for repeating or replicating arrays to produce larger arrays
    are the `repeat` and `tile` functions. `repeat` replicates each element in an
    array some number of times, producing a larger array:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 用于重复或复制数组以生成更大数组的两个有用工具是`repeat`和`tile`函数。`repeat`将数组中的每个元素重复若干次，生成一个更大的数组：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Note* *The need to replicate or repeat arrays can be less common with NumPy
    than it is with other array programming frameworks like MATLAB. One reason for
    this is that *broadcasting* often fills this need better, which is the subject
    of the next section.*  *By default, if you pass an integer, each element will
    be repeated that number of times. If you pass an array of integers, each element
    can be repeated a different number of times:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *需要复制或重复数组的情况在NumPy中可能不像其他数组编程框架（如MATLAB）中那样常见。其中一个原因是*广播*通常更好地满足这种需求，这是下一节的主题。*
    *默认情况下，如果传递一个整数，每个元素将重复该次数。如果传递一个整数数组，每个元素可以重复不同次数：'
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Multidimensional arrays can have their elements repeated along a particular
    axis:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组可以沿特定轴重复其元素：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that if no axis is passed, the array will be flattened first, which is
    likely not what you want. Similarly, you can pass an array of integers when repeating
    a multidimensional array to repeat a given slice a different number of times:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果没有传递轴，数组将首先被展平，这可能不是您想要的。同样，当重复多维数组以不同次数重复给定切片时，可以传递整数数组：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`tile`, on the other hand, is a shortcut for stacking copies of an array along
    an axis. Visually you can think of it as being akin to “laying down tiles”:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`tile`是一个沿轴堆叠数组副本的快捷方式。在视觉上，您可以将其视为类似于“铺设瓷砖”：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The second argument is the number of tiles; with a scalar, the tiling is made
    row by row, rather than column by column. The second argument to `tile` can be
    a tuple indicating the layout of the “tiling”:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是瓷砖的数量；对于标量，瓦片是按行而不是按列进行的。`tile`的第二个参数可以是一个元组，指示“瓦片”的布局：
- en: '[PRE23]*  *### Fancy Indexing Equivalents: take and put'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE23]*  *### 花式索引等效：take 和 put'
- en: 'As you may recall from [Ch 4: NumPy Basics: Arrays and Vectorized Computation](/book/numpy-basics),
    one way to get and set subsets of arrays is by *fancy* indexing using integer
    arrays:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能从[Ch 4：NumPy基础：数组和矢量化计算](/book/numpy-basics)中记得的那样，通过使用整数数组进行*花式*索引来获取和设置数组的子集是一种方法：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There are alternative ndarray methods that are useful in the special case of
    making a selection only on a single axis:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在仅在单个轴上进行选择的特殊情况下，有一些替代的ndarray方法是有用的：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To use `take` along other axes, you can pass the `axis` keyword:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要在其他轴上使用`take`，可以传递`axis`关键字：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`put` does not accept an `axis` argument but rather indexes into the flattened
    (one-dimensional, C order) version of the array. Thus, when you need to set elements
    using an index array on other axes, it is best to use `[]`-based indexing.*  *##
    A.3 Broadcasting'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`put`不接受`axis`参数，而是索引到数组的展平（一维，C顺序）版本。因此，当您需要使用索引数组在其他轴上设置元素时，最好使用基于`[]`的索引。*  *##
    A.3 广播'
- en: '*Broadcasting* governs how operations work between arrays of different shapes.
    It can be a powerful feature, but it can cause confusion, even for experienced
    users. The simplest example of broadcasting occurs when combining a scalar value
    with an array:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*广播*规定了不同形状数组之间的操作方式。它可以是一个强大的功能，但即使对于有经验的用户也可能会引起混淆。广播的最简单示例是将标量值与数组组合时发生：'
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here we say that the scalar value 4 has been *broadcast* to all of the other
    elements in the multiplication operation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们说标量值4已经*广播*到乘法操作中的所有其他元素。
- en: 'For example, we can demean each column of an array by subtracting the column
    means. In this case, it is necessary only to subtract an array containing the
    mean of each column:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过减去列均值来对数组的每一列进行去均值处理。在这种情况下，只需要减去包含每列均值的数组即可：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: See [Figure A.4](#fig-figure_broadcasting1) for an illustration of this operation.
    Demeaning the rows as a broadcast operation requires a bit more care. Fortunately,
    broadcasting potentially lower dimensional values across any dimension of an array
    (like subtracting the row means from each column of a two-dimensional array) is
    possible as long as you follow the rules.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[图A.4](#fig-figure_broadcasting1)以了解此操作的示例。将行作为广播操作去均值需要更多的注意。幸运的是，跨任何数组维度广播潜在较低维值（例如从二维数组的每列中减去行均值）是可能的，只要遵循规则。
- en: This brings us to the broadcasting rule.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们带到了广播规则。
- en: Two arrays are compatible for broadcasting if for each *trailing dimension*
    (i.e., starting from the end) the axis lengths match or if either of the lengths
    is 1\. Broadcasting is then performed over the missing or length 1 dimensions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 两个数组在广播时兼容，如果对于每个*尾部维度*（即，从末尾开始），轴的长度匹配，或者长度中的任何一个为1。然后在缺失或长度为1的维度上执行广播。
- en: '![](../Images/77180177aee670ca8681b6eabd6ebce8.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/77180177aee670ca8681b6eabd6ebce8.png)'
- en: 'Figure A.4: Broadcasting over axis 0 with a 1D array'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.4：在1D数组的轴0上进行广播
- en: 'Even as an experienced NumPy user, I often find myself having to pause and
    draw a diagram as I think about the broadcasting rule. Consider the last example
    and suppose we wished instead to subtract the mean value from each row. Since
    `arr.mean(0)` has length 3, it is compatible for broadcasting across axis 0 because
    the trailing dimension in `arr` is 3 and therefore matches. According to the rules,
    to subtract over axis 1 (i.e., subtract the row mean from each row), the smaller
    array must have the shape `(4, 1)`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 即使作为一个经验丰富的NumPy用户，我经常发现自己在思考广播规则时不得不停下来画图。考虑最后一个示例，假设我们希望减去每行的平均值。由于`arr.mean(0)`的长度为3，它在轴0上是兼容的进行广播，因为`arr`中的尾部维度为3，因此匹配。根据规则，要在轴1上进行减法（即，从每行减去行均值），较小的数组必须具有形状`(4,
    1)`：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: See [Figure A.5](#fig-figure_broadcasting2) for an illustration of this operation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[图A.5](#fig-figure_broadcasting2)以了解此操作的示例。
- en: '![](../Images/95638725670f843291db058cdae27a0b.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/95638725670f843291db058cdae27a0b.png)'
- en: 'Figure A.5: Broadcasting over axis 1 of a 2D array'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.5：在2D数组的轴1上进行广播
- en: See [Figure A.6](#fig-figure_broadcasting3) for another illustration, this time
    adding a two-dimensional array to a three-dimensional one across axis 0.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[图A.6](#fig-figure_broadcasting3)以获得另一个示例，这次是在轴0上将二维数组添加到三维数组中。
- en: '![](../Images/fb752abddb93c77ae991903b8cf1f98f.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fb752abddb93c77ae991903b8cf1f98f.png)'
- en: 'Figure A.6: Broadcasting over axis 0 of a 3D array'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.6：在3D数组的轴0上进行广播
- en: Broadcasting over Other Axes
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在其他轴上进行广播
- en: 'Broadcasting with higher dimensional arrays can seem even more mind-bending,
    but it is really a matter of following the rules. If you don’t, you’ll get an
    error like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更高维度数组进行广播可能看起来更加令人费解，但实际上只是遵循规则的问题。如果不遵循规则，就会出现如下错误：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It’s quite common to want to perform an arithmetic operation with a lower dimensional
    array across axes other than axis 0\. According to the broadcasting rule, the
    “broadcast dimensions” must be 1 in the smaller array. In the example of row demeaning
    shown here, this means reshaping the row to be shape `(4, 1)` instead of `(4,)`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通常希望使用低维数组在轴0以外的轴上执行算术运算是很常见的。根据广播规则，“广播维度”在较小数组中必须为1。在这里显示的行减均值示例中，这意味着将行重塑为形状`(4,
    1)`而不是`(4,)`：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the three-dimensional case, broadcasting over any of the three dimensions
    is only a matter of reshaping the data to be shape compatible. [Figure A.7](#fig-figure_broadcasting_3d)
    nicely visualizes the shapes required to broadcast over each axis of a three-dimensional
    array.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在三维情况下，沿着任何三个维度进行广播只是将数据重塑为兼容形状的问题。[图A.7](#fig-figure_broadcasting_3d)很好地可视化了广播到三维数组的每个轴所需的形状。
- en: '![](../Images/2cdd2c64c3d5cf9a9a9300814e38d103.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2cdd2c64c3d5cf9a9a9300814e38d103.png)'
- en: 'Figure A.7: Compatible 2D array shapes for broadcasting over a 3D array'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.7：广播到3D数组上的兼容2D数组形状
- en: 'A common problem, therefore, is needing to add a new axis with length 1 specifically
    for broadcasting purposes. Using `reshape` is one option, but inserting an axis
    requires constructing a tuple indicating the new shape. This often can be a tedious
    exercise. Thus, NumPy arrays offer a special syntax for inserting new axes by
    indexing. We use the special `np.newaxis` attribute along with “full” slices to
    insert the new axis:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个常见的问题是需要添加一个新的长度为1的新轴，专门用于广播目的。使用`reshape`是一种选择，但插入轴需要构造一个指示新形状的元组。这通常是一项繁琐的工作。因此，NumPy数组提供了一种特殊的语法，通过索引插入新轴。我们使用特殊的`np.newaxis`属性以及“full”切片来插入新轴：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Thus, if we had a three-dimensional array and wanted to demean axis 2, we would
    need to write:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们有一个三维数组并且希望减去轴2的均值，我们需要编写：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You might be wondering if there’s a way to generalize demeaning over an axis
    without sacrificing performance. There is, but it requires some indexing gymnastics:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道是否有一种方法可以在不牺牲性能的情况下推广沿轴的减均值操作。有，但需要一些索引技巧：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Setting Array Values by Broadcasting
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过广播设置数组值
- en: 'The same broadcasting rule governing arithmetic operations also applies to
    setting values via array indexing. In a simple case, we can do things like:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 控制算术运算的相同广播规则也适用于通过数组索引设置值。在简单情况下，我们可以做如下操作：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'However, if we had a one-dimensional array of values we wanted to set into
    the columns of the array, we can do that as long as the shape is compatible:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们有一个要设置到数组列中的值的一维数组，只要形状兼容，我们就可以这样做：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: A.4 Advanced ufunc Usage
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.4 高级ufunc用法
- en: While many NumPy users will only use the fast element-wise operations provided
    by the universal functions, a number of additional features occasionally can help
    you write more concise code without explicit loops.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多NumPy用户只会使用通用函数提供的快速逐元素操作，但偶尔一些附加功能可以帮助您编写更简洁的代码，而无需显式循环。
- en: ufunc Instance Methods
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ufunc实例方法
- en: Each of NumPy’s binary ufuncs has special methods for performing certain kinds
    of special vectorized operations. These are summarized in [Table A.2](#tbl-table_ufunc_methods),
    but I’ll give a few concrete examples to illustrate how they work.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy的每个二进制ufunc都有特殊的方法来执行某些特定类型的特殊向量化操作。这些方法在[表A.2](#tbl-table_ufunc_methods)中进行了总结，但我将给出一些具体示例来说明它们的工作原理。
- en: '`reduce` takes a single array and aggregates its values, optionally along an
    axis, by performing a sequence of binary operations. For example, an alternative
    way to sum elements in an array is to use `np.add.reduce`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`接受一个数组并通过执行一系列二进制操作（可选地沿轴）来聚合其值。例如，在数组中求和元素的另一种方法是使用`np.add.reduce`：'
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The starting value (for example, 0 for `add`) depends on the ufunc. If an axis
    is passed, the reduction is performed along that axis. This allows you to answer
    certain kinds of questions in a concise way. As a less mundane example, we can
    use `np.logical_and` to check whether the values in each row of an array are sorted:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 起始值（例如，`add`的0）取决于ufunc。如果传递了轴，将沿着该轴执行减少。这使您能够以简洁的方式回答某些类型的问题。作为一个不那么平凡的例子，我们可以使用`np.logical_and`来检查数组的每一行中的值是否已排序：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that `logical_and.reduce` is equivalent to the `all` method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`logical_and.reduce`等同于`all`方法。
- en: 'The `accumulate` ufunc method is related to `reduce`, like `cumsum` is related
    to `sum`. It produces an array of the same size with the intermediate “accumulated”
    values:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`accumulate` ufunc方法与`reduce`相关，就像`cumsum`与`sum`相关一样。它生成一个与中间“累积”值大小相同的数组：'
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`outer` performs a pair-wise cross product between two arrays:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`outer`在两个数组之间执行成对的叉积：'
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output of `outer` will have a dimension that is the concatenation of the
    dimensions of the inputs:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`outer`的输出将具有输入维度的连接：'
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The last method, `reduceat`, performs a “local reduce,” in essence an array
    “group by” operation in which slices of the array are aggregated together. It
    accepts a sequence of “bin edges” that indicate how to split and aggregate the
    values:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法，`reduceat`，执行“本地减少”，本质上是一个数组“分组”操作，其中数组的切片被聚合在一起。它接受指示如何拆分和聚合值的“bin边缘”序列：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The results are the reductions (here, sums) performed over `arr[0:5]`, `arr[5:8]`,
    and `arr[8:]`. As with the other methods, you can pass an `axis` argument:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是在`arr[0:5]`，`arr[5:8]`和`arr[8:]`上执行的减少（这里是求和）。与其他方法一样，您可以传递一个`axis`参数：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: See [Table A.2](#tbl-table_ufunc_methods) for a partial listing of ufunc methods.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[表A.2](#tbl-table_ufunc_methods)以获取ufunc方法的部分列表。
- en: 'Table A.2: ufunc methods'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 表A.2：ufunc方法
- en: '| Method | Description |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `accumulate(x)` | Aggregate values, preserving all partial aggregates. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `accumulate(x)` | 聚合值，保留所有部分聚合。 |'
- en: '| `at(x, indices, b=None)` | Perform operation in place on `x` at the specified
    indices. The argument `b` is the second input to ufuncs that requires two array
    inputs. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `at(x, indices, b=None)` | 在指定的索引处对`x`执行操作。参数`b`是需要两个数组输入的ufunc的第二个输入。 |'
- en: '| `reduce(x)` | Aggregate values by successive applications of the operation.
    |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `reduce(x)` | 通过连续应用操作来聚合值。 |'
- en: '| `reduceat(x, bins)` | “Local” reduce or “group by”; reduce contiguous slices
    of data to produce an aggregated array. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `reduceat(x, bins)` | “本地”减少或“分组”；减少数据的连续切片以生成聚合数组。 |'
- en: '| `outer(x, y)` | Apply operation to all pairs of elements in `x` and `y`;
    the resulting array has shape `x.shape + y.shape`. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `outer(x, y)` | 将操作应用于`x`和`y`中所有元素对；生成的数组形状为`x.shape + y.shape`。 |'
- en: Writing New ufuncs in Python
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用Python编写新的ufuncs
- en: There are a number of ways to create your own NumPy ufuncs. The most general
    is to use the NumPy C API, but that is beyond the scope of this book. In this
    section, we will look at pure Python ufuncs.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多创建自己的NumPy ufuncs的方法。最通用的方法是使用NumPy C API，但这超出了本书的范围。在本节中，我们将看一下纯Python ufuncs。
- en: '`numpy.frompyfunc` accepts a Python function along with a specification for
    the number of inputs and outputs. For example, a simple function that adds element-wise
    would be specified as:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.frompyfunc`接受一个Python函数以及输入和输出数量的规范。例如，一个简单的逐元素相加的函数将被指定为：'
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Functions created using `frompyfunc` always return arrays of Python objects,
    which can be inconvenient. Fortunately, there is an alternative (but slightly
    less feature rich) function, `numpy.vectorize`, that allows you to specify the
    output type:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`frompyfunc`创建的函数始终返回Python对象的数组，这可能不方便。幸运的是，还有一种替代（但功能稍逊一筹）的函数`numpy.vectorize`，允许您指定输出类型：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'These functions provide a way to create ufunc-like functions, but they are
    very slow because they require a Python function call to compute each element,
    which is a lot slower than NumPy’s C-based ufunc loops:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数提供了一种创建类似ufunc函数的方法，但它们非常慢，因为它们需要调用Python函数来计算每个元素，这比NumPy的基于C的ufunc循环慢得多：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Later in this appendix we'll show how to create fast ufuncs in Python using
    the [Numba library](http://numba.pydata.org).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录的后面，我们将展示如何使用[Numba库](http://numba.pydata.org)在Python中创建快速的ufuncs。
- en: A.5 Structured and Record Arrays
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.5 结构化和记录数组
- en: 'You may have noticed up until now that ndarray is a *homogeneous* data container;
    that is, it represents a block of memory in which each element takes up the same
    number of bytes, as determined by the data type. On the surface, this would appear
    to not allow you to represent heterogeneous or tabular data. A *structured* array
    is an ndarray in which each element can be thought of as representing a *struct*
    in C (hence the “structured” name) or a row in a SQL table with multiple named
    fields:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能已经注意到ndarray是一个*同质*数据容器；也就是说，它表示一个内存块，其中每个元素占据相同数量的字节，由数据类型确定。表面上，这似乎不允许您表示异构或表格数据。*结构化*数组是一个ndarray，其中每个元素可以被视为表示C中的*struct*（因此称为“结构化”名称）或SQL表中具有多个命名字段的行：
- en: '[PRE47]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'There are several ways to specify a structured data type (see the online NumPy
    documentation). One typical way is as a list of tuples with `(field_name, field_data_type)`.
    Now, the elements of the array are tuple-like objects whose elements can be accessed
    like a dictionary:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种指定结构化数据类型的方法（请参阅在线NumPy文档）。一种典型的方法是作为具有`(field_name, field_data_type)`的元组列表。现在，数组的元素是类似元组的对象，其元素可以像字典一样访问：
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The field names are stored in the `dtype.names` attribute. When you access
    a field on the structured array, a strided view on the data is returned, thus
    copying nothing:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 字段名称存储在`dtype.names`属性中。当您访问结构化数组上的字段时，会返回数据的跨度视图，因此不会复制任何内容：
- en: '[PRE49]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Nested Data Types and Multidimensional Fields
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套数据类型和多维字段
- en: 'When specifying a structured data type, you can additionally pass a shape (as
    an int or tuple):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定结构化数据类型时，您还可以传递一个形状（作为int或元组）：
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In this case, the `x` field now refers to an array of length 3 for each record:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`x`字段现在指的是每个记录的长度为3的数组：
- en: '[PRE51]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Conveniently, accessing `arr[''x'']` then returns a two-dimensional array instead
    of a one-dimensional array as in prior examples:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，访问`arr['x']`然后返回一个二维数组，而不是像之前的例子中那样返回一个一维数组：
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This enables you to express more complicated, nested structures as a single
    block of memory in an array. You can also nest data types to make more complex
    structures. Here is an example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这使您能够将更复杂的嵌套结构表达为数组中的单个内存块。您还可以嵌套数据类型以创建更复杂的结构。这里是一个例子：
- en: '[PRE53]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: pandas DataFrame does not support this feature in the same way, though it is
    similar to hierarchical indexing.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: pandas DataFrame并不以相同的方式支持这个特性，尽管它类似于分层索引。
- en: Why Use Structured Arrays?
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么使用结构化数组？
- en: Compared with a pandas DataFrame, NumPy structured arrays are a lower level
    tool. They provide a means to interpret a block of memory as a tabular structure
    with nested columns. Since each element in the array is represented in memory
    as a fixed number of bytes, structured arrays provide an efficient way of writing
    data to and from disk (including memory maps), transporting it over the network,
    and other such uses. The memory layout of each value in a structured array is
    based on the binary representation of struct data types in the C programming language.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 与pandas DataFrame相比，NumPy结构化数组是一个更低级别的工具。它们提供了一种将内存块解释为具有嵌套列的表格结构的方法。由于数组中的每个元素在内存中表示为固定数量的字节，结构化数组提供了一种有效的方式来将数据写入磁盘（包括内存映射）、通过网络传输数据以及其他类似用途。结构化数组中每个值的内存布局基于C编程语言中struct数据类型的二进制表示。
- en: As another common use for structured arrays, writing data files as fixed-length
    record byte streams is a common way to serialize data in C and C++ code, which
    is sometimes found in legacy systems in industry. As long as the format of the
    file is known (the size of each record and the order, byte size, and data type
    of each element), the data can be read into memory with `np.fromfile`. Specialized
    uses like this are beyond the scope of this book, but it’s worth knowing that
    such things are possible.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 作为结构化数组的另一个常见用途，将数据文件写为固定长度记录字节流是在工业中的遗留系统中有时会发现的一种序列化数据的常见方式。只要文件的格式已知（每个记录的大小以及每个元素的顺序、字节大小和数据类型），数据就可以通过`np.fromfile`读入内存。像这样的专用用途超出了本书的范围，但值得知道这样的事情是可能的。
- en: A.6 More About Sorting
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.6 更多关于排序的内容
- en: 'Like Python’s built-in list, the ndarray `sort` instance method is an *in-place*
    sort, meaning that the array contents are rearranged without producing a new array:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python内置列表类似，ndarray的`sort`实例方法是一种*原地*排序，这意味着数组内容会被重新排列而不会产生新数组：
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'When sorting arrays in place, remember that if the array is a view on a different
    ndarray, the original array will be modified:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在原地对数组进行排序时，请记住，如果数组是对不同ndarray的视图，则原始数组将被修改：
- en: '[PRE55]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'On the other hand, `numpy.sort` creates a new, sorted copy of an array. Otherwise,
    it accepts the same arguments (such as `kind`) as ndarray''s `sort` method:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`numpy.sort`会创建一个新的、排序后的数组副本。否则，它接受与ndarray的`sort`方法相同的参数（如`kind`）：
- en: '[PRE56]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'All of these sort methods take an axis argument for independently sorting the
    sections of data along the passed axis:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些排序方法都接受一个轴参数，用于独立地对沿传递的轴的数据部分进行排序：
- en: '[PRE57]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You may notice that none of the sort methods have an option to sort in descending
    order. This is a problem in practice because array slicing produces views, thus
    not producing a copy or requiring any computational work. Many Python users are
    familiar with the “trick” that for a list of `values`, `values[::-1]` returns
    a list in reverse order. The same is true for ndarrays:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，所有排序方法都没有选项以降序排序。这在实践中是一个问题，因为数组切片会产生视图，因此不会产生副本或需要任何计算工作。许多Python用户熟悉“技巧”，即对于`values`列表，`values[::-1]`返回一个反向排序的列表。对于ndarrays也是如此：
- en: '[PRE58]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Indirect Sorts: argsort and lexsort'
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 间接排序：argsort和lexsort
- en: 'In data analysis you may need to reorder datasets by one or more keys. For
    example, a table of data about some students might need to be sorted by last name,
    then by first name. This is an example of an *indirect* sort, and if you’ve read
    the pandas-related chapters, you have already seen many higher-level examples.
    Given a key or keys (an array of values or multiple arrays of values), you wish
    to obtain an array of integer *indices* (I refer to them colloquially as *indexers*)
    that tells you how to reorder the data to be in sorted order. Two methods for
    this are `argsort` and `numpy.lexsort`. As an example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据分析中，您可能需要按一个或多个键重新排序数据集。例如，关于一些学生的数据表可能需要按姓氏排序，然后按名字排序。这是一个*间接*排序的例子，如果您已经阅读了与pandas相关的章节，您已经看到了许多更高级的例子。给定一个键或键（一个值数组或多个值数组），您希望获得一个整数*索引*数组（我口头上称之为*索引器*），告诉您如何重新排序数据以使其按排序顺序排列。这种情况下的两种方法是`argsort`和`numpy.lexsort`。例如：
- en: '[PRE59]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As a more complicated example, this code reorders a two-dimensional array by
    its first row:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个更复杂的例子，这段代码通过其第一行重新排序一个二维数组：
- en: '[PRE60]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`lexsort` is similar to `argsort`, but it performs an indirect *lexicographical*
    sort on multiple key arrays. Suppose we wanted to sort some data identified by
    first and last names:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`lexsort`类似于`argsort`，但它对多个关键数组执行间接的*词典排序。假设我们想要按名字和姓氏对一些数据进行排序：'
- en: '[PRE61]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`lexsort` can be a bit confusing the first time you use it, because the order
    in which the keys are used to order the data starts with the *last* array passed.
    Here, `last_name` was used before `first_name`.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次使用`lexsort`可能会有点困惑，因为用于对数据排序的键的顺序是从传递的*最后*数组开始的。在这里，`last_name`在`first_name`之前使用。
- en: Alternative Sort Algorithms
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替代排序算法
- en: 'A *stable* sorting algorithm preserves the relative position of equal elements.
    This can be especially important in indirect sorts where the relative ordering
    is meaningful:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*稳定*排序算法保留相等元素的相对位置。这在相对排序有意义的间接排序中尤为重要：'
- en: '[PRE62]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The only stable sort available is *mergesort*, which has guaranteed `O(n log
    n)` performance, but its performance is on average worse than the default quicksort
    method. See [Table A.3](#tbl-table_array_sort_methods) for a summary of available
    methods and their relative performance (and performance guarantees). This is not
    something that most users will ever have to think about, but it's useful to know
    that it’s there.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一可用的稳定排序是*mergesort*，它保证了`O(n log n)`的性能，但其性能平均而言比默认的quicksort方法差。请参见[表A.3](#tbl-table_array_sort_methods)以获取可用方法及其相对性能（和性能保证）的摘要。这不是大多数用户需要考虑的事情，但知道它存在是有用的。
- en: 'Table A.3: Array sorting methods'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 表A.3：数组排序方法
- en: '| Kind | Speed | Stable | Work space | Worst case |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 速度 | 稳定性 | 工作空间 | 最坏情况 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `''quicksort''` | 1 | No | 0 | `O(n^2)` |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `''quicksort''` | 1 | 否 | 0 | `O(n^2)` |'
- en: '| `''mergesort''` | 2 | Yes | `n / 2` | `O(n log n)` |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `''mergesort''` | 2 | 是 | `n / 2` | `O(n log n)` |'
- en: '| `''heapsort''` | 3 | No | 0 | `O(n log n)` |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `''heapsort''` | 3 | 否 | 0 | `O(n log n)` |'
- en: Partially Sorting Arrays
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部分排序数组
- en: 'One of the goals of sorting can be to determine the largest or smallest elements
    in an array. NumPy has fast methods, `numpy.partition` and `np.argpartition`,
    for partitioning an array around the `k`-th smallest element:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 排序的目标之一可以是确定数组中最大或最小的元素。NumPy有快速方法`numpy.partition`和`np.argpartition`，用于围绕第`k`个最小元素对数组进行分区：
- en: '[PRE63]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'After you call `partition(arr, 3)`, the first three elements in the result
    are the smallest three values in no particular order. `numpy.argpartition`, similar
    to `numpy.argsort`, returns the indices that rearrange the data into the equivalent
    order:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`partition(arr, 3)`后，结果中的前三个元素是任意顺序中最小的三个值。`numpy.argpartition`类似于`numpy.argsort`，返回重新排列数据为等效顺序的索引：
- en: '[PRE64]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'numpy.searchsorted: Finding Elements in a Sorted Array'
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'numpy.searchsorted: 在排序数组中查找元素'
- en: '`searchsorted` is an array method that performs a binary search on a sorted
    array, returning the location in the array where the value would need to be inserted
    to maintain sortedness:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`searchsorted`是一个数组方法，对排序数组执行二分查找，返回值需要插入以保持排序的数组中的位置：'
- en: '[PRE65]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You can also pass an array of values to get an array of indices back:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以传递一个值数组，以获取一个索引数组：
- en: '[PRE66]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'You might have noticed that `searchsorted` returned `0` for the `0` element.
    This is because the default behavior is to return the index at the left side of
    a group of equal values:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到`searchsorted`对于`0`元素返回了`0`。这是因为默认行为是返回相等值组的左侧的索引：
- en: '[PRE67]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'As another application of `searchsorted`, suppose we had an array of values
    between 0 and 10,000, and a separate array of “bucket edges” that we wanted to
    use to bin the data:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`searchsorted`的另一个应用，假设我们有一个值在0到10,000之间的数组，以及一个我们想要用来对数据进行分箱的单独的“桶边缘”数组：
- en: '[PRE68]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'To then get a labeling to which interval each data point belongs (where 1 would
    mean the bucket `[0, 100)`), we can simply use `searchsorted`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了确定每个数据点属于哪个区间（其中1表示桶`[0, 100)`），我们可以简单地使用`searchsorted`：
- en: '[PRE69]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This, combined with pandas’s `groupby`, can be used to bin data:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这与pandas的`groupby`结合使用，可以用于对数据进行分箱：
- en: '[PRE70]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: A.7 Writing Fast NumPy Functions with Numba
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Numba编写快速NumPy函数
- en: '[Numba](http://numba.pydata.org) is an open source project that creates fast
    functions for NumPy-like data using CPUs, GPUs, or other hardware. It uses the
    [LLVM Project](http://llvm.org/) to translate Python code into compiled machine
    code.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[Numba](http://numba.pydata.org) 是一个开源项目，使用CPU、GPU或其他硬件为类似NumPy的数据创建快速函数。它使用[LLVM
    Project](http://llvm.org/)将Python代码转换为编译后的机器代码。'
- en: 'To introduce Numba, let''s consider a pure Python function that computes the
    expression `(x - y).mean()` using a `for` loop:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了介绍Numba，让我们考虑一个纯Python函数，使用`for`循环计算表达式`(x - y).mean()`：
- en: '[PRE71]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This function is slow:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数很慢：
- en: '[PRE72]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The NumPy version is over 100 times faster. We can turn this function into
    a compiled Numba function using the `numba.jit` function:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy版本快了100多倍。我们可以使用`numba.jit`函数将此函数转换为编译后的Numba函数：
- en: '[PRE73]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We also could have written this as a decorator:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将其编写为装饰器：
- en: '[PRE74]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The resulting function is actually faster than the vectorized NumPy version:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 结果函数实际上比矢量化的NumPy版本更快：
- en: '[PRE75]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Numba cannot compile all pure Python code, but it supports a significant subset
    of Python that is most useful for writing numerical algorithms.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Numba无法编译所有纯Python代码，但它支持Python的一个重要子集，对于编写数值算法非常有用。
- en: Numba is a deep library, supporting different kinds of hardware, modes of compilation,
    and user extensions. It is also able to compile a substantial subset of the NumPy
    Python API without explicit `for` loops. Numba is able to recognize constructs
    that can be compiled to machine code, while substituting calls to the CPython
    API for functions that it does not know how to compile. Numba's `jit` function
    option, `nopython=True`, restricts allowed code to Python code that can be compiled
    to LLVM without any Python C API calls. `jit(nopython=True)` has a shorter alias,
    `numba.njit`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Numba是一个深度库，支持不同类型的硬件、编译模式和用户扩展。它还能够编译NumPy Python API的一个重要子集，而无需显式的`for`循环。Numba能够识别可以编译为机器代码的结构，同时替换对CPython
    API的调用，以便编译它不知道如何编译的函数。Numba的`jit`函数选项`nopython=True`将允许的代码限制为可以在没有任何Python C
    API调用的情况下编译为LLVM的Python代码。`jit(nopython=True)`有一个更短的别名，`numba.njit`。
- en: 'In the previous example, we could have written:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以这样写：
- en: '[PRE76]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: I encourage you to learn more by reading the [online documentation for Numba](http://numba.pydata.org/).
    The next section shows an example of creating custom NumPy ufunc objects.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励您通过阅读[Numba的在线文档](http://numba.pydata.org/)来了解更多。下一节将展示创建自定义NumPy ufunc对象的示例。
- en: Creating Custom numpy.ufunc Objects with Numba
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Numba创建自定义numpy.ufunc对象
- en: 'The `numba.vectorize` function creates compiled NumPy ufuncs, which behave
    like built-in ufuncs. Let''s consider a Python implementation of `numpy.add`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`numba.vectorize`函数创建了编译后的NumPy ufuncs，行为类似于内置的ufuncs。让我们考虑一个`numpy.add`的Python实现：'
- en: '[PRE77]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now we have:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有：
- en: '[PRE78]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: A.8 Advanced Array Input and Output
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级数组输入和输出
- en: 'In [Ch 4: NumPy Basics: Arrays and Vectorized Computation](/book/numpy-basics),
    we became acquainted with `np.save` and `np.load` for storing arrays in binary
    format on disk. There are a number of additional options to consider for more
    sophisticated use. In particular, memory maps have the additional benefit of enabling
    you to do certain operations with datasets that do not fit into RAM.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '在[Ch 4: NumPy基础：数组和矢量化计算](/book/numpy-basics)中，我们熟悉了`np.save`和`np.load`用于将数组以二进制格式存储在磁盘上。还有一些其他更复杂用途的选项需要考虑。特别是，内存映射还具有额外的好处，使您能够对不适合RAM的数据集执行某些操作。'
- en: Memory-Mapped Files
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存映射文件
- en: A *memory-mapped* file is a method for interacting with binary data on disk
    as though it is stored in an in-memory array. NumPy implements a `memmap` object
    that is ndarray-like, enabling small segments of a large file to be read and written
    without reading the whole array into memory. Additionally, a `memmap` has the
    same methods as an in-memory array and thus can be substituted into many algorithms
    where an ndarray would be expected.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*内存映射*文件是一种与磁盘上的二进制数据交互的方法，就好像它存储在内存中的数组中一样。NumPy实现了一个类似ndarray的`memmap`对象，使得可以在不将整个数组读入内存的情况下读取和写入大文件的小段。此外，`memmap`具有与内存中数组相同的方法，因此可以替换许多算法中预期的ndarray的地方。'
- en: 'To create a new memory map, use the function `np.memmap` and pass a file path,
    data type, shape, and file mode:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的内存映射，请使用函数`np.memmap`并传递文件路径、数据类型、形状和文件模式：
- en: '[PRE79]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Slicing a `memmap` returns views on the data on disk:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对`memmap`进行切片会返回磁盘上数据的视图：
- en: '[PRE80]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If you assign data to these, it will be buffered in memory, which means that
    the changes will not be immediately reflected in the on-disk file if you were
    to read the file in a different application. Any modifications can be synchronized
    to disk by calling `flush`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将数据分配给这些对象，它将被缓冲在内存中，这意味着如果您在不同的应用程序中读取文件，更改将不会立即反映在磁盘文件中。可以通过调用`flush`将任何修改同步到磁盘：
- en: '[PRE81]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Whenever a memory map falls out of scope and is garbage collected, any changes
    will be flushed to disk also. When *opening an existing memory map*, you still
    have to specify the data type and shape, as the file is only a block of binary
    data without any data type information, shape, or strides:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当内存映射超出范围并被垃圾回收时，任何更改也将刷新到磁盘。*打开现有内存映射*时，仍然必须指定数据类型和形状，因为文件只是一个没有任何数据类型信息、形状或步幅的二进制数据块：
- en: '[PRE82]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Memory maps also work with structured or nested data types, as described in
    [Structured and Record Arrays](#numpy_structured).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射也适用于结构化或嵌套数据类型，如[结构化和记录数组](#numpy_structured)中所述。
- en: 'If you ran this example on your computer, you may want to delete the large
    file that we created above:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在计算机上运行此示例，可能希望删除我们上面创建的大文件：
- en: '[PRE83]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: HDF5 and Other Array Storage Options
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HDF5和其他数组存储选项
- en: PyTables and h5py are two Python projects providing NumPy-friendly interfaces
    for storing array data in the efficient and compressible HDF5 format (HDF stands
    for *hierarchical data format*). You can safely store hundreds of gigabytes or
    even terabytes of data in HDF5 format. To learn more about using HDF5 with Python,
    I recommend reading the [pandas online documentation](http://pandas.pydata.org).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: PyTables和h5py是两个Python项目，提供了与NumPy兼容的接口，用于以高效和可压缩的HDF5格式（HDF代表*分层数据格式*）存储数组数据。您可以安全地将数百吉字节甚至数千吉字节的数据存储在HDF5格式中。要了解如何在Python中使用HDF5，我建议阅读[pandas在线文档](http://pandas.pydata.org)。
- en: A.9 Performance Tips
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能提示
- en: 'Adapting data processing code to use NumPy generally makes things much faster,
    as array operations typically replace otherwise comparatively extremely slow pure
    Python loops. Here are some tips to help get the best performance out of the library:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据处理代码调整为使用NumPy通常会使事情变得更快，因为数组操作通常会取代否则相对极慢的纯Python循环。以下是一些提示，可帮助您从库中获得最佳性能：
- en: Convert Python loops and conditional logic to array operations and Boolean array
    operations.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Python循环和条件逻辑转换为数组操作和布尔数组操作。
- en: Use broadcasting whenever possible.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用广播。
- en: Use arrays views (slicing) to avoid copying data.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数组视图（切片）来避免复制数据。
- en: Utilize ufuncs and ufunc methods.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用ufuncs和ufunc方法。
- en: If you can’t get the performance you require after exhausting the capabilities
    provided by NumPy alone, consider writing code in C, FORTRAN, or Cython. I use
    [Cython](http://cython.org) frequently in my own work as a way to get C-like performance,
    often with much less development time.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仅使用NumPy无法获得所需的性能，请考虑在C、FORTRAN或Cython中编写代码。我经常在自己的工作中使用[Cython](http://cython.org)作为一种获得类似C性能的方法，通常开发时间更短。
- en: The Importance of Contiguous Memory
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连续内存的重要性
- en: While the full extent of this topic is a bit outside the scope of this book,
    in some applications the memory layout of an array can significantly affect the
    speed of computations. This is based partly on performance differences having
    to do with the cache hierarchy of the CPU; operations accessing contiguous blocks
    of memory (e.g., summing the rows of a C order array) will generally be the fastest
    because the memory subsystem will buffer the appropriate blocks of memory into
    the low latency L1 or L2 CPU caches. Also, certain code paths inside NumPy’s C
    codebase have been optimized for the contiguous case in which generic strided
    memory access can be avoided.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个主题的全部范围有点超出了本书的范围，在一些应用中，数组的内存布局可以显著影响计算速度。这部分基于CPU的缓存层次结构的性能差异；访问连续内存块的操作（例如，对C顺序数组的行求和）通常是最快的，因为内存子系统将适当的内存块缓冲到低延迟的L1或L2
    CPU缓存中。此外，NumPy的C代码库中的某些代码路径已经针对连续情况进行了优化，可以避免通用的跨步内存访问。
- en: 'To say that an array’s memory layout is *contiguous* means that the elements
    are stored in memory in the order that they appear in the array with respect to
    FORTRAN (column major) or C (row major) ordering. By default, NumPy arrays are
    created as C contiguous or just simply contiguous. A column major array, such
    as the transpose of a C-contiguous array, is thus said to be FORTRAN contiguous.
    These properties can be explicitly checked via the `flags` attribute on the ndarray:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 说一个数组的内存布局是*连续的*意味着元素按照它们在数组中出现的顺序存储在内存中，关于FORTRAN（列主序）或C（行主序）排序。默认情况下，NumPy数组被创建为C连续或者简单连续。一个列主序数组，比如一个C连续数组的转置，因此被称为FORTRAN连续。这些属性可以通过`flags`属性在ndarray上显式检查：
- en: '[PRE84]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In this example, summing the rows of these arrays should, in theory, be faster
    for `arr_c` than `arr_f` since the rows are contiguous in memory. Here, I check
    using `%timeit` in IPython (these results may differ on your machine):'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，理论上，对这些数组的行求和对于`arr_c`应该比`arr_f`更快，因为行在内存中是连续的。在这里，我使用IPython中的`%timeit`进行检查（这些结果可能在你的机器上有所不同）：
- en: '[PRE85]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'When you''re looking to squeeze more performance out of NumPy, this is often
    a place to invest some effort. If you have an array that does not have the desired
    memory order, you can use `copy` and pass either `''C''` or `''F''`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要从NumPy中挤出更多性能时，这通常是一个值得投入一些努力的地方。如果你有一个数组，它没有所需的内存顺序，你可以使用`copy`并传递`'C'`或`'F'`：
- en: '[PRE86]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'When constructing a view on an array, keep in mind that the result is not guaranteed
    to be contiguous:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建一个数组的视图时，要记住结果不一定是连续的：
- en: '[PRE87]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '* * *'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Some of the data types have trailing underscores in their names. These are there
    to avoid variable name conflicts between the NumPy-specific types and the Python
    built-in ones.[↩︎](#fnref1)**
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些数据类型的名称中有下划线。这是为了避免NumPy特定类型和Python内置类型之间的变量名冲突。
