- en: Appendix A — Advanced NumPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://wesmckinney.com/book/advanced-numpy](https://wesmckinney.com/book/advanced-numpy)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This Open Access web version of *Python for Data Analysis 3rd Edition* is
    now available as a companion to the [print and digital editions](https://amzn.to/3DyLaJc).
    If you encounter any errata, [please report them here](https://oreilly.com/catalog/0636920519829/errata).
    Please note that some aspects of this site as produced by Quarto will differ from
    the formatting of the print and eBook versions from O’Reilly.'
  prefs: []
  type: TYPE_NORMAL
- en: If you find the online edition of the book useful, please consider [ordering
    a paper copy](https://amzn.to/3DyLaJc) or a [DRM-free eBook](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)
    to support the author. The content from this website may not be copied or reproduced.
    The code examples are MIT licensed and can be found on GitHub or Gitee.*  *In
    this appendix, I will go deeper into the NumPy library for array computing. This
    will include more internal details about the ndarray type and more advanced array
    manipulations and algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'This appendix contains miscellaneous topics and does not necessarily need to
    be read linearly. Throughout the chapters, I will generate random data for many
    examples that will use the default random number generator in the `numpy.random`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A.1 ndarray Object Internals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The NumPy ndarray provides a way to interpret a block of homogeneously typed
    data (either contiguous or strided) as a multidimensional array object. The data
    type, or *dtype*, determines how the data is interpreted as being floating point,
    integer, Boolean, or any of the other types we’ve been looking at.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part of what makes ndarray flexible is that every array object is a *strided*
    view on a block of data. You might wonder, for example, how the array view `arr[::2,
    ::-1]` does not copy any data. The reason is that the ndarray is more than just
    a chunk of memory and a data type; it also has *striding* information that enables
    the array to move through memory with varying step sizes. More precisely, the
    ndarray internally consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A *pointer to data*—that is, a block of data in RAM or in a memory-mapped file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *data type* or dtype describing fixed-size value cells in the array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tuple indicating the array’s *shape*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tuple of *strides*—integers indicating the number of bytes to “step” in order
    to advance one element along a dimension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [Figure A.1](#fig-figure_ndarray) for a simple mock-up of the ndarray innards.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e27af70a8051b0749f47f917cb9bc365.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A.1: The NumPy ndarray object'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a 10 × 5 array would have the shape `(10, 5)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A typical (C order) 3 × 4 × 5 array of `float64` (8-byte) values has the strides
    `(160, 40, 8)` (knowing about the strides can be useful because, in general, the
    larger the strides on a particular axis, the more costly it is to perform computation
    along that axis):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While it is rare that a typical NumPy user would be interested in the array
    strides, they are needed to construct "zero-copy" array views. Strides can even
    be negative, which enables an array to move "backward" through memory (this would
    be the case, for example, in a slice like `obj[::-1]` or `obj[:, ::-1]`).
  prefs: []
  type: TYPE_NORMAL
- en: NumPy Data Type Hierarchy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may occasionally have code that needs to check whether an array contains
    integers, floating-point numbers, strings, or Python objects. Because there are
    multiple types of floating-point numbers (`float16` through `float128`), checking
    that the data type is among a list of types would be very verbose. Fortunately,
    the data types have superclasses, such as `np.integer` and `np.floating`, which
    can be used with the `np.issubdtype` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see all of the parent classes of a specific data type by calling the
    type’s `mro` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, we also have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Most NumPy users will never have to know about this, but it is occasionally
    useful. See [Figure A.2](#fig-figure_dtype_hierarchy) for a graph of the data
    type hierarchy and parent–subclass relationships.[¹](#fn1)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d60ef95fddd13030d45f90939bef5ca1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A.2: The NumPy data type class hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: A.2 Advanced Array Manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways to work with arrays beyond fancy indexing, slicing, and
    Boolean subsetting. While much of the heavy lifting for data analysis applications
    is handled by higher-level functions in pandas, you may at some point need to
    write a data algorithm that is not found in one of the existing libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Reshaping Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In many cases, you can convert an array from one shape to another without copying
    any data. To do this, pass a tuple indicating the new shape to the `reshape` array
    instance method. For example, suppose we had a one-dimensional array of values
    that we wished to rearrange into a matrix (this is illustrated in [Figure A.3](#fig-figure_c_vs_fortran)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/cf72351c291cc639dc236d8072622fe1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A.3: Reshaping in C (row major) or FORTRAN (column major) order'
  prefs: []
  type: TYPE_NORMAL
- en: 'A multidimensional array can also be reshaped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the passed shape dimensions can be –1, in which case the value used
    for that dimension will be inferred from the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Since an array’s `shape` attribute is a tuple, it can be passed to `reshape`,
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The opposite operation of `reshape` from one-dimensional to a higher dimension
    is typically known as *flattening* or *raveling*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`ravel` does not produce a copy of the underlying values if the values in the
    result were contiguous in the original array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `flatten` method behaves like `ravel` except it always returns a copy of
    the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The data can be reshaped or raveled in different orders. This is a slightly
    nuanced topic for new NumPy users and is therefore the next subtopic.
  prefs: []
  type: TYPE_NORMAL
- en: C Versus FORTRAN Order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy is able to adapt to many different layouts of your data in memory. By
    default, NumPy arrays are created in *row major* order. Spatially this means that
    if you have a two-dimensional array of data, the items in each row of the array
    are stored in adjacent memory locations. The alternative to row major ordering
    is *column major* order, which means that values within each column of data are
    stored in adjacent memory locations.
  prefs: []
  type: TYPE_NORMAL
- en: For historical reasons, row and column major order are also known as C and FORTRAN
    order, respectively. In the FORTRAN 77 language, matrices are all column major.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions like `reshape` and `ravel` accept an `order` argument indicating
    the order to use the data in the array. This is usually set to `''C''` or `''F''`
    in most cases (there are also less commonly used options `''A''` and `''K''`;
    see the NumPy documentation, and refer back to [Figure A.3](#fig-figure_c_vs_fortran)
    for an illustration of these options):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Reshaping arrays with more than two dimensions can be a bit mind-bending (see
    [Figure A.3](#fig-figure_c_vs_fortran)). The key difference between C and FORTRAN
    order is the way in which the dimensions are walked:'
  prefs: []
  type: TYPE_NORMAL
- en: C/row major order
  prefs: []
  type: TYPE_NORMAL
- en: Traverse higher dimensions *first* (e.g., axis 1 before advancing on axis 0).
  prefs: []
  type: TYPE_NORMAL
- en: FORTRAN/column major order
  prefs: []
  type: TYPE_NORMAL
- en: Traverse higher dimensions *last* (e.g., axis 0 before advancing on axis 1).
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating and Splitting Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`numpy.concatenate` takes a sequence (tuple, list, etc.) of arrays and joins
    them in order along the input axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some convenience functions, like `vstack` and `hstack`, for common
    kinds of concatenation. The preceding operations could have been expressed as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`split`, on the other hand, slices an array into multiple arrays along an axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The value `[1, 3]` passed to `np.split` indicates the indices at which to split
    the array into pieces.
  prefs: []
  type: TYPE_NORMAL
- en: See [Table A.1](#tbl-table_array_concatenating) for a list of all relevant concatenation
    and splitting functions, some of which are provided only as a convenience of the
    very general-purpose `concatenate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table A.1: Array concatenation functions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `concatenate` | Most general function, concatenate collection of arrays along
    one axis |'
  prefs: []
  type: TYPE_TB
- en: '| `vstack, row_stack` | Stack arrays by rows (along axis 0) |'
  prefs: []
  type: TYPE_TB
- en: '| `hstack` | Stack arrays by columns (along axis 1) |'
  prefs: []
  type: TYPE_TB
- en: '| `column_stack` | Like `hstack`, but convert 1D arrays to 2D column vectors
    first |'
  prefs: []
  type: TYPE_TB
- en: '| `dstack` | Stack arrays by “depth” (along axis 2) |'
  prefs: []
  type: TYPE_TB
- en: '| `split` | Split array at passed locations along a particular axis |'
  prefs: []
  type: TYPE_TB
- en: '| `hsplit`/`vsplit` | Convenience functions for splitting on axis 0 and 1,
    respectively |'
  prefs: []
  type: TYPE_TB
- en: 'Stacking helpers: r_ and c_'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two special objects in the NumPy namespace, `r_` and `c_`, that make
    stacking arrays more concise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'These additionally can translate slices to arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: See the docstring for more on what you can do with `c_` and `r_`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeating Elements: tile and repeat'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Two useful tools for repeating or replicating arrays to produce larger arrays
    are the `repeat` and `tile` functions. `repeat` replicates each element in an
    array some number of times, producing a larger array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Note* *The need to replicate or repeat arrays can be less common with NumPy
    than it is with other array programming frameworks like MATLAB. One reason for
    this is that *broadcasting* often fills this need better, which is the subject
    of the next section.*  *By default, if you pass an integer, each element will
    be repeated that number of times. If you pass an array of integers, each element
    can be repeated a different number of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Multidimensional arrays can have their elements repeated along a particular
    axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if no axis is passed, the array will be flattened first, which is
    likely not what you want. Similarly, you can pass an array of integers when repeating
    a multidimensional array to repeat a given slice a different number of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`tile`, on the other hand, is a shortcut for stacking copies of an array along
    an axis. Visually you can think of it as being akin to “laying down tiles”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The second argument is the number of tiles; with a scalar, the tiling is made
    row by row, rather than column by column. The second argument to `tile` can be
    a tuple indicating the layout of the “tiling”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]*  *### Fancy Indexing Equivalents: take and put'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may recall from [Ch 4: NumPy Basics: Arrays and Vectorized Computation](/book/numpy-basics),
    one way to get and set subsets of arrays is by *fancy* indexing using integer
    arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There are alternative ndarray methods that are useful in the special case of
    making a selection only on a single axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To use `take` along other axes, you can pass the `axis` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`put` does not accept an `axis` argument but rather indexes into the flattened
    (one-dimensional, C order) version of the array. Thus, when you need to set elements
    using an index array on other axes, it is best to use `[]`-based indexing.*  *##
    A.3 Broadcasting'
  prefs: []
  type: TYPE_NORMAL
- en: '*Broadcasting* governs how operations work between arrays of different shapes.
    It can be a powerful feature, but it can cause confusion, even for experienced
    users. The simplest example of broadcasting occurs when combining a scalar value
    with an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here we say that the scalar value 4 has been *broadcast* to all of the other
    elements in the multiplication operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can demean each column of an array by subtracting the column
    means. In this case, it is necessary only to subtract an array containing the
    mean of each column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: See [Figure A.4](#fig-figure_broadcasting1) for an illustration of this operation.
    Demeaning the rows as a broadcast operation requires a bit more care. Fortunately,
    broadcasting potentially lower dimensional values across any dimension of an array
    (like subtracting the row means from each column of a two-dimensional array) is
    possible as long as you follow the rules.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the broadcasting rule.
  prefs: []
  type: TYPE_NORMAL
- en: Two arrays are compatible for broadcasting if for each *trailing dimension*
    (i.e., starting from the end) the axis lengths match or if either of the lengths
    is 1\. Broadcasting is then performed over the missing or length 1 dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/77180177aee670ca8681b6eabd6ebce8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A.4: Broadcasting over axis 0 with a 1D array'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even as an experienced NumPy user, I often find myself having to pause and
    draw a diagram as I think about the broadcasting rule. Consider the last example
    and suppose we wished instead to subtract the mean value from each row. Since
    `arr.mean(0)` has length 3, it is compatible for broadcasting across axis 0 because
    the trailing dimension in `arr` is 3 and therefore matches. According to the rules,
    to subtract over axis 1 (i.e., subtract the row mean from each row), the smaller
    array must have the shape `(4, 1)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: See [Figure A.5](#fig-figure_broadcasting2) for an illustration of this operation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/95638725670f843291db058cdae27a0b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A.5: Broadcasting over axis 1 of a 2D array'
  prefs: []
  type: TYPE_NORMAL
- en: See [Figure A.6](#fig-figure_broadcasting3) for another illustration, this time
    adding a two-dimensional array to a three-dimensional one across axis 0.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fb752abddb93c77ae991903b8cf1f98f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A.6: Broadcasting over axis 0 of a 3D array'
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting over Other Axes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Broadcasting with higher dimensional arrays can seem even more mind-bending,
    but it is really a matter of following the rules. If you don’t, you’ll get an
    error like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s quite common to want to perform an arithmetic operation with a lower dimensional
    array across axes other than axis 0\. According to the broadcasting rule, the
    “broadcast dimensions” must be 1 in the smaller array. In the example of row demeaning
    shown here, this means reshaping the row to be shape `(4, 1)` instead of `(4,)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the three-dimensional case, broadcasting over any of the three dimensions
    is only a matter of reshaping the data to be shape compatible. [Figure A.7](#fig-figure_broadcasting_3d)
    nicely visualizes the shapes required to broadcast over each axis of a three-dimensional
    array.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2cdd2c64c3d5cf9a9a9300814e38d103.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure A.7: Compatible 2D array shapes for broadcasting over a 3D array'
  prefs: []
  type: TYPE_NORMAL
- en: 'A common problem, therefore, is needing to add a new axis with length 1 specifically
    for broadcasting purposes. Using `reshape` is one option, but inserting an axis
    requires constructing a tuple indicating the new shape. This often can be a tedious
    exercise. Thus, NumPy arrays offer a special syntax for inserting new axes by
    indexing. We use the special `np.newaxis` attribute along with “full” slices to
    insert the new axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, if we had a three-dimensional array and wanted to demean axis 2, we would
    need to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be wondering if there’s a way to generalize demeaning over an axis
    without sacrificing performance. There is, but it requires some indexing gymnastics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Setting Array Values by Broadcasting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The same broadcasting rule governing arithmetic operations also applies to
    setting values via array indexing. In a simple case, we can do things like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we had a one-dimensional array of values we wanted to set into
    the columns of the array, we can do that as long as the shape is compatible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: A.4 Advanced ufunc Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While many NumPy users will only use the fast element-wise operations provided
    by the universal functions, a number of additional features occasionally can help
    you write more concise code without explicit loops.
  prefs: []
  type: TYPE_NORMAL
- en: ufunc Instance Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each of NumPy’s binary ufuncs has special methods for performing certain kinds
    of special vectorized operations. These are summarized in [Table A.2](#tbl-table_ufunc_methods),
    but I’ll give a few concrete examples to illustrate how they work.
  prefs: []
  type: TYPE_NORMAL
- en: '`reduce` takes a single array and aggregates its values, optionally along an
    axis, by performing a sequence of binary operations. For example, an alternative
    way to sum elements in an array is to use `np.add.reduce`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The starting value (for example, 0 for `add`) depends on the ufunc. If an axis
    is passed, the reduction is performed along that axis. This allows you to answer
    certain kinds of questions in a concise way. As a less mundane example, we can
    use `np.logical_and` to check whether the values in each row of an array are sorted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note that `logical_and.reduce` is equivalent to the `all` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `accumulate` ufunc method is related to `reduce`, like `cumsum` is related
    to `sum`. It produces an array of the same size with the intermediate “accumulated”
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`outer` performs a pair-wise cross product between two arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of `outer` will have a dimension that is the concatenation of the
    dimensions of the inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The last method, `reduceat`, performs a “local reduce,” in essence an array
    “group by” operation in which slices of the array are aggregated together. It
    accepts a sequence of “bin edges” that indicate how to split and aggregate the
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are the reductions (here, sums) performed over `arr[0:5]`, `arr[5:8]`,
    and `arr[8:]`. As with the other methods, you can pass an `axis` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: See [Table A.2](#tbl-table_ufunc_methods) for a partial listing of ufunc methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table A.2: ufunc methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `accumulate(x)` | Aggregate values, preserving all partial aggregates. |'
  prefs: []
  type: TYPE_TB
- en: '| `at(x, indices, b=None)` | Perform operation in place on `x` at the specified
    indices. The argument `b` is the second input to ufuncs that requires two array
    inputs. |'
  prefs: []
  type: TYPE_TB
- en: '| `reduce(x)` | Aggregate values by successive applications of the operation.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `reduceat(x, bins)` | “Local” reduce or “group by”; reduce contiguous slices
    of data to produce an aggregated array. |'
  prefs: []
  type: TYPE_TB
- en: '| `outer(x, y)` | Apply operation to all pairs of elements in `x` and `y`;
    the resulting array has shape `x.shape + y.shape`. |'
  prefs: []
  type: TYPE_TB
- en: Writing New ufuncs in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of ways to create your own NumPy ufuncs. The most general
    is to use the NumPy C API, but that is beyond the scope of this book. In this
    section, we will look at pure Python ufuncs.
  prefs: []
  type: TYPE_NORMAL
- en: '`numpy.frompyfunc` accepts a Python function along with a specification for
    the number of inputs and outputs. For example, a simple function that adds element-wise
    would be specified as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions created using `frompyfunc` always return arrays of Python objects,
    which can be inconvenient. Fortunately, there is an alternative (but slightly
    less feature rich) function, `numpy.vectorize`, that allows you to specify the
    output type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'These functions provide a way to create ufunc-like functions, but they are
    very slow because they require a Python function call to compute each element,
    which is a lot slower than NumPy’s C-based ufunc loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Later in this appendix we'll show how to create fast ufuncs in Python using
    the [Numba library](http://numba.pydata.org).
  prefs: []
  type: TYPE_NORMAL
- en: A.5 Structured and Record Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have noticed up until now that ndarray is a *homogeneous* data container;
    that is, it represents a block of memory in which each element takes up the same
    number of bytes, as determined by the data type. On the surface, this would appear
    to not allow you to represent heterogeneous or tabular data. A *structured* array
    is an ndarray in which each element can be thought of as representing a *struct*
    in C (hence the “structured” name) or a row in a SQL table with multiple named
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several ways to specify a structured data type (see the online NumPy
    documentation). One typical way is as a list of tuples with `(field_name, field_data_type)`.
    Now, the elements of the array are tuple-like objects whose elements can be accessed
    like a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The field names are stored in the `dtype.names` attribute. When you access
    a field on the structured array, a strided view on the data is returned, thus
    copying nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Nested Data Types and Multidimensional Fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When specifying a structured data type, you can additionally pass a shape (as
    an int or tuple):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the `x` field now refers to an array of length 3 for each record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Conveniently, accessing `arr[''x'']` then returns a two-dimensional array instead
    of a one-dimensional array as in prior examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This enables you to express more complicated, nested structures as a single
    block of memory in an array. You can also nest data types to make more complex
    structures. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: pandas DataFrame does not support this feature in the same way, though it is
    similar to hierarchical indexing.
  prefs: []
  type: TYPE_NORMAL
- en: Why Use Structured Arrays?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Compared with a pandas DataFrame, NumPy structured arrays are a lower level
    tool. They provide a means to interpret a block of memory as a tabular structure
    with nested columns. Since each element in the array is represented in memory
    as a fixed number of bytes, structured arrays provide an efficient way of writing
    data to and from disk (including memory maps), transporting it over the network,
    and other such uses. The memory layout of each value in a structured array is
    based on the binary representation of struct data types in the C programming language.
  prefs: []
  type: TYPE_NORMAL
- en: As another common use for structured arrays, writing data files as fixed-length
    record byte streams is a common way to serialize data in C and C++ code, which
    is sometimes found in legacy systems in industry. As long as the format of the
    file is known (the size of each record and the order, byte size, and data type
    of each element), the data can be read into memory with `np.fromfile`. Specialized
    uses like this are beyond the scope of this book, but it’s worth knowing that
    such things are possible.
  prefs: []
  type: TYPE_NORMAL
- en: A.6 More About Sorting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like Python’s built-in list, the ndarray `sort` instance method is an *in-place*
    sort, meaning that the array contents are rearranged without producing a new array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'When sorting arrays in place, remember that if the array is a view on a different
    ndarray, the original array will be modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, `numpy.sort` creates a new, sorted copy of an array. Otherwise,
    it accepts the same arguments (such as `kind`) as ndarray''s `sort` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'All of these sort methods take an axis argument for independently sorting the
    sections of data along the passed axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You may notice that none of the sort methods have an option to sort in descending
    order. This is a problem in practice because array slicing produces views, thus
    not producing a copy or requiring any computational work. Many Python users are
    familiar with the “trick” that for a list of `values`, `values[::-1]` returns
    a list in reverse order. The same is true for ndarrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Indirect Sorts: argsort and lexsort'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In data analysis you may need to reorder datasets by one or more keys. For
    example, a table of data about some students might need to be sorted by last name,
    then by first name. This is an example of an *indirect* sort, and if you’ve read
    the pandas-related chapters, you have already seen many higher-level examples.
    Given a key or keys (an array of values or multiple arrays of values), you wish
    to obtain an array of integer *indices* (I refer to them colloquially as *indexers*)
    that tells you how to reorder the data to be in sorted order. Two methods for
    this are `argsort` and `numpy.lexsort`. As an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'As a more complicated example, this code reorders a two-dimensional array by
    its first row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`lexsort` is similar to `argsort`, but it performs an indirect *lexicographical*
    sort on multiple key arrays. Suppose we wanted to sort some data identified by
    first and last names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '`lexsort` can be a bit confusing the first time you use it, because the order
    in which the keys are used to order the data starts with the *last* array passed.
    Here, `last_name` was used before `first_name`.'
  prefs: []
  type: TYPE_NORMAL
- en: Alternative Sort Algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *stable* sorting algorithm preserves the relative position of equal elements.
    This can be especially important in indirect sorts where the relative ordering
    is meaningful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The only stable sort available is *mergesort*, which has guaranteed `O(n log
    n)` performance, but its performance is on average worse than the default quicksort
    method. See [Table A.3](#tbl-table_array_sort_methods) for a summary of available
    methods and their relative performance (and performance guarantees). This is not
    something that most users will ever have to think about, but it's useful to know
    that it’s there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table A.3: Array sorting methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| Kind | Speed | Stable | Work space | Worst case |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `''quicksort''` | 1 | No | 0 | `O(n^2)` |'
  prefs: []
  type: TYPE_TB
- en: '| `''mergesort''` | 2 | Yes | `n / 2` | `O(n log n)` |'
  prefs: []
  type: TYPE_TB
- en: '| `''heapsort''` | 3 | No | 0 | `O(n log n)` |'
  prefs: []
  type: TYPE_TB
- en: Partially Sorting Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the goals of sorting can be to determine the largest or smallest elements
    in an array. NumPy has fast methods, `numpy.partition` and `np.argpartition`,
    for partitioning an array around the `k`-th smallest element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'After you call `partition(arr, 3)`, the first three elements in the result
    are the smallest three values in no particular order. `numpy.argpartition`, similar
    to `numpy.argsort`, returns the indices that rearrange the data into the equivalent
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'numpy.searchsorted: Finding Elements in a Sorted Array'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`searchsorted` is an array method that performs a binary search on a sorted
    array, returning the location in the array where the value would need to be inserted
    to maintain sortedness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also pass an array of values to get an array of indices back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'You might have noticed that `searchsorted` returned `0` for the `0` element.
    This is because the default behavior is to return the index at the left side of
    a group of equal values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'As another application of `searchsorted`, suppose we had an array of values
    between 0 and 10,000, and a separate array of “bucket edges” that we wanted to
    use to bin the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'To then get a labeling to which interval each data point belongs (where 1 would
    mean the bucket `[0, 100)`), we can simply use `searchsorted`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This, combined with pandas’s `groupby`, can be used to bin data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: A.7 Writing Fast NumPy Functions with Numba
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Numba](http://numba.pydata.org) is an open source project that creates fast
    functions for NumPy-like data using CPUs, GPUs, or other hardware. It uses the
    [LLVM Project](http://llvm.org/) to translate Python code into compiled machine
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To introduce Numba, let''s consider a pure Python function that computes the
    expression `(x - y).mean()` using a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is slow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The NumPy version is over 100 times faster. We can turn this function into
    a compiled Numba function using the `numba.jit` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We also could have written this as a decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting function is actually faster than the vectorized NumPy version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Numba cannot compile all pure Python code, but it supports a significant subset
    of Python that is most useful for writing numerical algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Numba is a deep library, supporting different kinds of hardware, modes of compilation,
    and user extensions. It is also able to compile a substantial subset of the NumPy
    Python API without explicit `for` loops. Numba is able to recognize constructs
    that can be compiled to machine code, while substituting calls to the CPython
    API for functions that it does not know how to compile. Numba's `jit` function
    option, `nopython=True`, restricts allowed code to Python code that can be compiled
    to LLVM without any Python C API calls. `jit(nopython=True)` has a shorter alias,
    `numba.njit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we could have written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: I encourage you to learn more by reading the [online documentation for Numba](http://numba.pydata.org/).
    The next section shows an example of creating custom NumPy ufunc objects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Custom numpy.ufunc Objects with Numba
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `numba.vectorize` function creates compiled NumPy ufuncs, which behave
    like built-in ufuncs. Let''s consider a Python implementation of `numpy.add`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: A.8 Advanced Array Input and Output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Ch 4: NumPy Basics: Arrays and Vectorized Computation](/book/numpy-basics),
    we became acquainted with `np.save` and `np.load` for storing arrays in binary
    format on disk. There are a number of additional options to consider for more
    sophisticated use. In particular, memory maps have the additional benefit of enabling
    you to do certain operations with datasets that do not fit into RAM.'
  prefs: []
  type: TYPE_NORMAL
- en: Memory-Mapped Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *memory-mapped* file is a method for interacting with binary data on disk
    as though it is stored in an in-memory array. NumPy implements a `memmap` object
    that is ndarray-like, enabling small segments of a large file to be read and written
    without reading the whole array into memory. Additionally, a `memmap` has the
    same methods as an in-memory array and thus can be substituted into many algorithms
    where an ndarray would be expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new memory map, use the function `np.memmap` and pass a file path,
    data type, shape, and file mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Slicing a `memmap` returns views on the data on disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'If you assign data to these, it will be buffered in memory, which means that
    the changes will not be immediately reflected in the on-disk file if you were
    to read the file in a different application. Any modifications can be synchronized
    to disk by calling `flush`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever a memory map falls out of scope and is garbage collected, any changes
    will be flushed to disk also. When *opening an existing memory map*, you still
    have to specify the data type and shape, as the file is only a block of binary
    data without any data type information, shape, or strides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Memory maps also work with structured or nested data types, as described in
    [Structured and Record Arrays](#numpy_structured).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ran this example on your computer, you may want to delete the large
    file that we created above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: HDF5 and Other Array Storage Options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PyTables and h5py are two Python projects providing NumPy-friendly interfaces
    for storing array data in the efficient and compressible HDF5 format (HDF stands
    for *hierarchical data format*). You can safely store hundreds of gigabytes or
    even terabytes of data in HDF5 format. To learn more about using HDF5 with Python,
    I recommend reading the [pandas online documentation](http://pandas.pydata.org).
  prefs: []
  type: TYPE_NORMAL
- en: A.9 Performance Tips
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adapting data processing code to use NumPy generally makes things much faster,
    as array operations typically replace otherwise comparatively extremely slow pure
    Python loops. Here are some tips to help get the best performance out of the library:'
  prefs: []
  type: TYPE_NORMAL
- en: Convert Python loops and conditional logic to array operations and Boolean array
    operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use broadcasting whenever possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use arrays views (slicing) to avoid copying data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize ufuncs and ufunc methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you can’t get the performance you require after exhausting the capabilities
    provided by NumPy alone, consider writing code in C, FORTRAN, or Cython. I use
    [Cython](http://cython.org) frequently in my own work as a way to get C-like performance,
    often with much less development time.
  prefs: []
  type: TYPE_NORMAL
- en: The Importance of Contiguous Memory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the full extent of this topic is a bit outside the scope of this book,
    in some applications the memory layout of an array can significantly affect the
    speed of computations. This is based partly on performance differences having
    to do with the cache hierarchy of the CPU; operations accessing contiguous blocks
    of memory (e.g., summing the rows of a C order array) will generally be the fastest
    because the memory subsystem will buffer the appropriate blocks of memory into
    the low latency L1 or L2 CPU caches. Also, certain code paths inside NumPy’s C
    codebase have been optimized for the contiguous case in which generic strided
    memory access can be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'To say that an array’s memory layout is *contiguous* means that the elements
    are stored in memory in the order that they appear in the array with respect to
    FORTRAN (column major) or C (row major) ordering. By default, NumPy arrays are
    created as C contiguous or just simply contiguous. A column major array, such
    as the transpose of a C-contiguous array, is thus said to be FORTRAN contiguous.
    These properties can be explicitly checked via the `flags` attribute on the ndarray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, summing the rows of these arrays should, in theory, be faster
    for `arr_c` than `arr_f` since the rows are contiguous in memory. Here, I check
    using `%timeit` in IPython (these results may differ on your machine):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'When you''re looking to squeeze more performance out of NumPy, this is often
    a place to invest some effort. If you have an array that does not have the desired
    memory order, you can use `copy` and pass either `''C''` or `''F''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'When constructing a view on an array, keep in mind that the result is not guaranteed
    to be contiguous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Some of the data types have trailing underscores in their names. These are there
    to avoid variable name conflicts between the NumPy-specific types and the Python
    built-in ones.[↩︎](#fnref1)**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
