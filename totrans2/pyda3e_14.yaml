- en: 11  Time Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://wesmckinney.com/book/time-series](https://wesmckinney.com/book/time-series)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This Open Access web version of *Python for Data Analysis 3rd Edition* is
    now available as a companion to the [print and digital editions](https://amzn.to/3DyLaJc).
    If you encounter any errata, [please report them here](https://oreilly.com/catalog/0636920519829/errata).
    Please note that some aspects of this site as produced by Quarto will differ from
    the formatting of the print and eBook versions from O’Reilly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you find the online edition of the book useful, please consider [ordering
    a paper copy](https://amzn.to/3DyLaJc) or a [DRM-free eBook](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)
    to support the author. The content from this website may not be copied or reproduced.
    The code examples are MIT licensed and can be found on GitHub or Gitee.*  *Time
    series data is an important form of structured data in many different fields,
    such as finance, economics, ecology, neuroscience, and physics. Anything that
    is recorded repeatedly at many points in time forms a time series. Many time series
    are *fixed frequency*, which is to say that data points occur at regular intervals
    according to some rule, such as every 15 seconds, every 5 minutes, or once per
    month. Time series can also be *irregular* without a fixed unit of time or offset
    between units. How you mark and refer to time series data depends on the application,
    and you may have one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Timestamps
  prefs: []
  type: TYPE_NORMAL
- en: Specific instants in time.
  prefs: []
  type: TYPE_NORMAL
- en: Fixed periods
  prefs: []
  type: TYPE_NORMAL
- en: Such as the whole month of January 2017, or the whole year 2020.
  prefs: []
  type: TYPE_NORMAL
- en: Intervals of time
  prefs: []
  type: TYPE_NORMAL
- en: Indicated by a start and end timestamp. Periods can be thought of as special
    cases of intervals.
  prefs: []
  type: TYPE_NORMAL
- en: Experiment or elapsed time
  prefs: []
  type: TYPE_NORMAL
- en: Each timestamp is a measure of time relative to a particular start time (e.g.,
    the diameter of a cookie baking each second since being placed in the oven), starting
    from 0.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I am mainly concerned with time series in the first three categories,
    though many of the techniques can be applied to experimental time series where
    the index may be an integer or floating-point number indicating elapsed time from
    the start of the experiment. The simplest kind of time series is indexed by timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: '*Tip* *pandas also supports indexes based on timedeltas, which can be a useful
    way of representing experiment or elapsed time. We do not explore timedelta indexes
    in this book, but you can learn more in the [pandas documentation](https://pandas.pydata.org).*  *pandas
    provides many built-in time series tools and algorithms. You can efficiently work
    with large time series, and slice and dice, aggregate, and resample irregular-
    and fixed-frequency time series. Some of these tools are useful for financial
    and economics applications, but you could certainly use them to analyze server
    log data, too.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the rest of the chapters, we start by importing NumPy and pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 11.1 Date and Time Data Types and Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python standard library includes data types for date and time data, as
    well as calendar-related functionality. The `datetime`, `time`, and `calendar`
    modules are the main places to start. The `datetime.datetime` type, or simply
    `datetime`, is widely used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`datetime` stores both the date and time down to the microsecond. `datetime.timedelta`,
    or simply `timedelta`, represents the temporal difference between two `datetime`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add (or subtract) a `timedelta` or multiple thereof to a `datetime`
    object to yield a new shifted object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 11.1](#tbl-table_datetime_module) summarizes the data types in the `datetime`
    module. While this chapter is mainly concerned with the data types in pandas and
    higher-level time series manipulation, you may encounter the `datetime`-based
    types in many other places in Python in the wild.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11.1: Types in the `datetime` module'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `date` | Store calendar date (year, month, day) using the Gregorian calendar
    |'
  prefs: []
  type: TYPE_TB
- en: '| `time` | Store time of day as hours, minutes, seconds, and microseconds |'
  prefs: []
  type: TYPE_TB
- en: '| `datetime` | Store both date and time |'
  prefs: []
  type: TYPE_TB
- en: '| `timedelta` | The difference between two `datetime` values (as days, seconds,
    and microseconds) |'
  prefs: []
  type: TYPE_TB
- en: '| `tzinfo` | Base type for storing time zone information |'
  prefs: []
  type: TYPE_TB
- en: Converting Between String and Datetime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can format `datetime` objects and pandas `Timestamp` objects, which I’ll
    introduce later, as strings using `str` or the `strftime` method, passing a format
    specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: See [Table 11.2](#tbl-table_datetime_formatting) for a complete list of the
    format codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11.2: `datetime` format specification (ISO C89 compatible)'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `%Y` | Four-digit year |'
  prefs: []
  type: TYPE_TB
- en: '| `%y` | Two-digit year |'
  prefs: []
  type: TYPE_TB
- en: '| `%m` | Two-digit month [01, 12] |'
  prefs: []
  type: TYPE_TB
- en: '| `%d` | Two-digit day [01, 31] |'
  prefs: []
  type: TYPE_TB
- en: '| `%H` | Hour (24-hour clock) [00, 23] |'
  prefs: []
  type: TYPE_TB
- en: '| `%I` | Hour (12-hour clock) [01, 12] |'
  prefs: []
  type: TYPE_TB
- en: '| `%M` | Two-digit minute [00, 59] |'
  prefs: []
  type: TYPE_TB
- en: '| `%S` | Second [00, 61] (seconds 60, 61 account for leap seconds) |'
  prefs: []
  type: TYPE_TB
- en: '| `%f` | Microsecond as an integer, zero-padded (from 000000 to 999999) |'
  prefs: []
  type: TYPE_TB
- en: '| `%j` | Day of the year as a zero-padded integer (from 001 to 336) |'
  prefs: []
  type: TYPE_TB
- en: '| `%w` | Weekday as an integer [0 (Sunday), 6] |'
  prefs: []
  type: TYPE_TB
- en: '| `%u` | Weekday as an integer starting from 1, where 1 is Monday. |'
  prefs: []
  type: TYPE_TB
- en: '| `%U` | Week number of the year [00, 53]; Sunday is considered the first day
    of the week, and days before the first Sunday of the year are “week 0” |'
  prefs: []
  type: TYPE_TB
- en: '| `%W` | Week number of the year [00, 53]; Monday is considered the first day
    of the week, and days before the first Monday of the year are “week 0” |'
  prefs: []
  type: TYPE_TB
- en: '| `%z` | UTC time zone offset as `+HHMM` or `-HHMM`; empty if time zone naive
    |'
  prefs: []
  type: TYPE_TB
- en: '| `%Z` | Time zone name as a string, or empty string if no time zone |'
  prefs: []
  type: TYPE_TB
- en: '| `%F` | Shortcut for `%Y-%m-%d` (e.g., `2012-4-18`) |'
  prefs: []
  type: TYPE_TB
- en: '| `%D` | Shortcut for `%m/%d/%y` (e.g., `04/18/12`) |'
  prefs: []
  type: TYPE_TB
- en: 'You can use many of the same format codes to convert strings to dates using
    `datetime.strptime` (but some codes, like `%F`, cannot be used):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`datetime.strptime` is one way to parse a date with a known format.'
  prefs: []
  type: TYPE_NORMAL
- en: 'pandas is generally oriented toward working with arrays of dates, whether used
    as an axis index or a column in a DataFrame. The `pandas.to_datetime` method parses
    many different kinds of date representations. Standard date formats like ISO 8601
    can be parsed quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It also handles values that should be considered missing (`None`, empty string,
    etc.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`NaT` (Not a Time) is pandas’s null value for timestamp data.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Caution* *`dateutil.parser` is a useful but imperfect tool. Notably, it will
    recognize some strings as dates that you might prefer that it didn’t; for example,
    `"42"` will be parsed as the year `2042` with today’s calendar date.*  *`datetime`
    objects also have a number of locale-specific formatting options for systems in
    other countries or languages. For example, the abbreviated month names will be
    different on German or French systems compared with English systems. See [Table 11.3](#tbl-table_datetime_formatting_locale)
    for a listing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11.3: Locale-specific date formatting'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `%a` | Abbreviated weekday name |'
  prefs: []
  type: TYPE_TB
- en: '| `%A` | Full weekday name |'
  prefs: []
  type: TYPE_TB
- en: '| `%b` | Abbreviated month name |'
  prefs: []
  type: TYPE_TB
- en: '| `%B` | Full month name |'
  prefs: []
  type: TYPE_TB
- en: '| `%c` | Full date and time (e.g., ‘Tue 01 May 2012 04:20:57 PM’) |'
  prefs: []
  type: TYPE_TB
- en: '| `%p` | Locale equivalent of AM or PM |'
  prefs: []
  type: TYPE_TB
- en: '| `%x` | Locale-appropriate formatted date (e.g., in the United States, May
    1, 2012 yields ‘05/01/2012’) |'
  prefs: []
  type: TYPE_TB
- en: '| `%X` | Locale-appropriate time (e.g., ‘04:24:12 PM’) |*  *## 11.2 Time Series
    Basics'
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic kind of time series object in pandas is a Series indexed by timestamps,
    which is often represented outside of pandas as Python strings or `datetime` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the hood, these `datetime` objects have been put in a `DatetimeIndex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Like other Series, arithmetic operations between differently indexed time series
    automatically align on the dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Recall that `ts[::2]` selects every second element in `ts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'pandas stores timestamps using NumPy’s `datetime64` data type at the nanosecond
    resolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Scalar values from a `DatetimeIndex` are pandas `Timestamp` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A `pandas.Timestamp` can be substituted most places where you would use a `datetime`
    object. The reverse is not true, however, because `pandas.Timestamp` can store
    nanosecond precision data, while `datetime` stores only up to microseconds. Additionally,
    `pandas.Timestamp` can store frequency information (if any) and understands how
    to do time zone conversions and other kinds of manipulations. More on both of
    these things later in [Time Zone Handling](#tseries_time_zones).
  prefs: []
  type: TYPE_NORMAL
- en: Indexing, Selection, Subsetting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Time series behaves like any other Series when you are indexing and selecting
    data based on the label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As a convenience, you can also pass a string that is interpretable as a date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'For longer time series, a year or only a year and month can be passed to easily
    select slices of data (`pandas.date_range` is discussed in more detail in [Generating
    Date Ranges](#tseries_fixed_date_range)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the string `"2001"` is interpreted as a year and selects that time period.
    This also works if you specify the month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Slicing with `datetime` objects works as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Because most time series data is ordered chronologically, you can slice with
    timestamps not contained in a time series to perform a range query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As before, you can pass a string date, `datetime`, or timestamp. Remember that
    slicing in this manner produces views on the source time series, like slicing
    NumPy arrays. This means that no data is copied, and modifications on the slice
    will be reflected in the original data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an equivalent instance method, `truncate`, that slices a Series between
    two dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'All of this holds true for DataFrame as well, indexing on its rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Time Series with Duplicate Indices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some applications, there may be multiple data observations falling on a
    particular timestamp. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can tell that the index is not unique by checking its `is_unique` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Indexing into this time series will now either produce scalar values or slices,
    depending on whether a timestamp is duplicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you wanted to aggregate the data having nonunique timestamps. One way
    to do this is to use `groupby` and pass `level=0` (the one and only level):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 11.3 Date Ranges, Frequencies, and Shifting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generic time series in pandas are assumed to be irregular; that is, they have
    no fixed frequency. For many applications this is sufficient. However, it’s often
    desirable to work relative to a fixed frequency, such as daily, monthly, or every
    15 minutes, even if that means introducing missing values into a time series.
    Fortunately, pandas has a full suite of standard time series frequencies and tools
    for resampling (discussed in more detail later in [Resampling and Frequency Conversion](#tseries_resampling)),
    inferring frequencies, and generating fixed-frequency date ranges. For example,
    you can convert the sample time series to fixed daily frequency by calling `resample`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The string `"D"` is interpreted as daily frequency.
  prefs: []
  type: TYPE_NORMAL
- en: Conversion between frequencies or *resampling* is a big enough topic to have
    its own section later ([Resampling and Frequency Conversion](#tseries_resampling)).
    Here, I’ll show you how to use the base frequencies and multiples thereof.
  prefs: []
  type: TYPE_NORMAL
- en: Generating Date Ranges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While I used it previously without explanation, `pandas.date_range` is responsible
    for generating a `DatetimeIndex` with an indicated length according to a particular
    frequency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `pandas.date_range` generates daily timestamps. If you pass only
    a start or end date, you must pass a number of periods to generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The start and end dates define strict boundaries for the generated date index.
    For example, if you wanted a date index containing the last business day of each
    month, you would pass the `"BM"` frequency (business end of month; see a more
    complete listing of frequencies in [Table 11.4](#tbl-table_base_frequencies)),
    and only dates falling on or inside the date interval will be included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Table 11.4: Base time series frequencies (not comprehensive)'
  prefs: []
  type: TYPE_NORMAL
- en: '| Alias | Offset type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `D` | `Day` | Calendar daily |'
  prefs: []
  type: TYPE_TB
- en: '| `B` | `BusinessDay` | Business daily |'
  prefs: []
  type: TYPE_TB
- en: '| `H` | `Hour` | Hourly |'
  prefs: []
  type: TYPE_TB
- en: '| `T` or `min` | `Minute` | Once a minute |'
  prefs: []
  type: TYPE_TB
- en: '| `S` | `Second` | Once a second |'
  prefs: []
  type: TYPE_TB
- en: '| `L` or `ms` | `Milli` | Millisecond (1/1,000 of 1 second) |'
  prefs: []
  type: TYPE_TB
- en: '| `U` | `Micro` | Microsecond (1/1,000,000 of 1 second) |'
  prefs: []
  type: TYPE_TB
- en: '| `M` | `MonthEnd` | Last calendar day of month |'
  prefs: []
  type: TYPE_TB
- en: '| `BM` | `BusinessMonthEnd` | Last business day (weekday) of month |'
  prefs: []
  type: TYPE_TB
- en: '| `MS` | `MonthBegin` | First calendar day of month |'
  prefs: []
  type: TYPE_TB
- en: '| `BMS` | `BusinessMonthBegin` | First weekday of month |'
  prefs: []
  type: TYPE_TB
- en: '| `W-MON, W-TUE, ...` | `Week` | Weekly on given day of week (MON, TUE, WED,
    THU, FRI, SAT, or SUN) |'
  prefs: []
  type: TYPE_TB
- en: '| `WOM-1MON, WOM-2MON, ...` | `WeekOfMonth` | Generate weekly dates in the
    first, second, third, or fourth week of the month (e.g., `WOM-3FRI` for the third
    Friday of each month) |'
  prefs: []
  type: TYPE_TB
- en: '| `Q-JAN, Q-FEB, ...` | `QuarterEnd` | Quarterly dates anchored on last calendar
    day of each month, for year ending in indicated month (JAN, FEB, MAR, APR, MAY,
    JUN, JUL, AUG, SEP, OCT, NOV, or DEC) |'
  prefs: []
  type: TYPE_TB
- en: '| `BQ-JAN, BQ-FEB, ...` | `BusinessQuarterEnd` | Quarterly dates anchored on
    last weekday day of each month, for year ending in indicated month |'
  prefs: []
  type: TYPE_TB
- en: '| `QS-JAN, QS-FEB, ...` | `QuarterBegin` | Quarterly dates anchored on first
    calendar day of each month, for year ending in indicated month |'
  prefs: []
  type: TYPE_TB
- en: '| `BQS-JAN, BQS-FEB, ...` | `BusinessQuarterBegin` | Quarterly dates anchored
    on first weekday day of each month, for year ending in indicated month |'
  prefs: []
  type: TYPE_TB
- en: '| `A-JAN, A-FEB, ...` | `YearEnd` | Annual dates anchored on last calendar
    day of given month (JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, or
    DEC) |'
  prefs: []
  type: TYPE_TB
- en: '| `BA-JAN, BA-FEB, ...` | `BusinessYearEnd` | Annual dates anchored on last
    weekday of given month |'
  prefs: []
  type: TYPE_TB
- en: '| `AS-JAN, AS-FEB, ...` | `YearBegin` | Annual dates anchored on first day
    of given month |'
  prefs: []
  type: TYPE_TB
- en: '| `BAS-JAN, BAS-FEB, ...` | `BusinessYearBegin` | Annual dates anchored on
    first weekday of given month |'
  prefs: []
  type: TYPE_TB
- en: '`pandas.date_range` by default preserves the time (if any) of the start or
    end timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes you will have start or end dates with time information but want to
    generate a set of timestamps *normalized* to midnight as a convention. To do this,
    there is a `normalize` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Frequencies and Date Offsets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Frequencies in pandas are composed of a *base frequency* and a multiplier.
    Base frequencies are typically referred to by a string alias, like `"M"` for monthly
    or `"H"` for hourly. For each base frequency, there is an object referred to as
    a *date offset*. For example, hourly frequency can be represented with the `Hour`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can define a multiple of an offset by passing an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In most applications, you would never need to explicitly create one of these
    objects; instead you''d use a string alias like `"H"` or `"4H"`. Putting an integer
    before the base frequency creates a multiple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Many offsets can be combined by addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can pass frequency strings, like `"1h30min"`, that will effectively
    be parsed to the same expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Some frequencies describe points in time that are not evenly spaced. For example,
    `"M"` (calendar month end) and `"BM"` (last business/weekday of month) depend
    on the number of days in a month and, in the latter case, whether the month ends
    on a weekend or not. We refer to these as *anchored* offsets.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [Table 11.4](#tbl-table_base_frequencies) for a listing of frequency
    codes and date offset classes available in pandas.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note* *Users can define their own custom frequency classes to provide date
    logic not available in pandas, though the full details of that are outside the
    scope of this book.*  *#### Week of month dates'
  prefs: []
  type: TYPE_NORMAL
- en: 'One useful frequency class is “week of month,” starting with `WOM`. This enables
    you to get dates like the third Friday of each month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]*  *### Shifting (Leading and Lagging) Data'
  prefs: []
  type: TYPE_NORMAL
- en: '*Shifting* refers to moving data backward and forward through time. Both Series
    and DataFrame have a `shift` method for doing naive shifts forward or backward,
    leaving the index unmodified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When we shift like this, missing data is introduced either at the start or the
    end of the time series.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common use of `shift` is computing consecutive percent changes in a time
    series or multiple time series as DataFrame columns. This is expressed as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Because naive shifts leave the index unmodified, some data is discarded. Thus
    if the frequency is known, it can be passed to `shift` to advance the timestamps
    instead of simply the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Other frequencies can be passed, too, giving you some flexibility in how to
    lead and lag the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `T` here stands for minutes. Note that the `freq` parameter here indicates
    the offset to apply to the timestamps, but it does not change the underlying frequency
    of the data, if any.
  prefs: []
  type: TYPE_NORMAL
- en: Shifting dates with offsets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The pandas date offsets can also be used with `datetime` or `Timestamp` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If you add an anchored offset like `MonthEnd`, the first increment will "roll
    forward" a date to the next date according to the frequency rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Anchored offsets can explicitly “roll” dates forward or backward by simply
    using their `rollforward` and `rollback` methods, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'A creative use of date offsets is to use these methods with `groupby`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, an easier and faster way to do this is with `resample` (we''ll discuss
    this in much more depth in [Resampling and Frequency Conversion](#tseries_resampling)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]*  *## 11.4 Time Zone Handling'
  prefs: []
  type: TYPE_NORMAL
- en: Working with time zones can be one of the most unpleasant parts of time series
    manipulation. As a result, many time series users choose to work with time series
    in *coordinated universal time* or *UTC*, which is the geography-independent international
    standard. Time zones are expressed as offsets from UTC; for example, New York
    is four hours behind UTC during daylight saving time (DST) and five hours behind
    the rest of the year.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, time zone information comes from the third-party `pytz` library (installable
    with pip or conda), which exposes the *Olson database*, a compilation of world
    time zone information. This is especially important for historical data because
    the DST transition dates (and even UTC offsets) have been changed numerous times
    depending on the regional laws. In the United States, the DST transition times
    have been changed many times since 1900!
  prefs: []
  type: TYPE_NORMAL
- en: 'For detailed information about the `pytz` library, you’ll need to look at that
    library’s documentation. As far as this book is concerned, pandas wraps `pytz`’s
    functionality so you can ignore its API outside of the time zone names. Since
    pandas has a hard dependency on `pytz`, it isn''t necessary to install it separately.
    Time zone names can be found interactively and in the docs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To get a time zone object from `pytz`, use `pytz.timezone`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Methods in pandas will accept either time zone names or these objects.
  prefs: []
  type: TYPE_NORMAL
- en: Time Zone Localization and Conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, time series in pandas are *time zone naive*. For example, consider
    the following time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The index’s `tz` field is `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Date ranges can be generated with a time zone set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Conversion from naive to *localized* (reinterpreted as having been observed
    in a particular time zone) is handled by the `tz_localize` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a time series has been localized to a particular time zone, it can be
    converted to another time zone with `tz_convert`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of the preceding time series, which straddles a DST transition
    in the `America/New_York` time zone, we could localize to US Eastern time and
    convert to, say, UTC or Berlin time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`tz_localize` and `tz_convert` are also instance methods on `DatetimeIndex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '*Caution* *Localizing naive timestamps also checks for ambiguous or non-existent
    times around daylight saving time transitions.*  *### Operations with Time Zone-Aware
    Timestamp Objects'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to time series and date ranges, individual `Timestamp` objects similarly
    can be localized from naive to time zone-aware and converted from one time zone
    to another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also pass a time zone when creating the `Timestamp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Time zone-aware `Timestamp` objects internally store a UTC timestamp value
    as nanoseconds since the Unix epoch (January 1, 1970), so changing the time zone
    does not alter the internal UTC value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'When performing time arithmetic using pandas’s `DateOffset` objects, pandas
    respects daylight saving time transitions where possible. Here we construct timestamps
    that occur right before DST transitions (forward and backward). First, 30 minutes
    before transitioning to DST:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, 90 minutes before transitioning out of DST:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Operations Between Different Time Zones
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If two time series with different time zones are combined, the result will
    be UTC. Since the timestamps are stored under the hood in UTC, this is a straightforward
    operation and requires no conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Operations between time zone-naive and time zone-aware data are not supported
    and will raise an exception.*  *## 11.5 Periods and Period Arithmetic
  prefs: []
  type: TYPE_NORMAL
- en: '*Periods* represent time spans, like days, months, quarters, or years. The
    `pandas.Period` class represents this data type, requiring a string or integer
    and a supported frequency from [Table 11.4](#tbl-table_base_frequencies):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the `Period` object represents the full time span from January
    1, 2011, to December 31, 2011, inclusive. Conveniently, adding and subtracting
    integers from periods has the effect of shifting their frequency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If two periods have the same frequency, their difference is the number of units
    between them as a date offset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Regular ranges of periods can be constructed with the `period_range` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PeriodIndex` class stores a sequence of periods and can serve as an axis
    index in any pandas data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have an array of strings, you can also use the `PeriodIndex` class,
    where all of its values are periods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Period Frequency Conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Periods and `PeriodIndex` objects can be converted to another frequency with
    their `asfreq` method. As an example, suppose we had an annual period and wanted
    to convert it into a monthly period either at the start or end of the year. This
    can be done like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You can think of `Period("2011", "A-DEC")` as being a sort of cursor pointing
    to a span of time, subdivided by monthly periods. See [Figure 11.1](#fig-figure_period_asfreq)
    for an illustration of this. For a *fiscal year* ending on a month other than
    December, the corresponding monthly subperiods are different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/d8cb52110dd49d0ab8074f78afe0845d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: Period frequency conversion illustration'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are converting from high to low frequency, pandas determines the subperiod,
    depending on where the superperiod “belongs.” For example, in `A-JUN` frequency,
    the month `Aug-2011` is actually part of the `2012` period:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Whole `PeriodIndex` objects or time series can be similarly converted with
    the same semantics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the annual periods are replaced with monthly periods corresponding to
    the first month falling within each annual period. If we instead wanted the last
    business day of each year, we can use the `"B"` frequency and indicate that we
    want the end of the period:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Quarterly Period Frequencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Quarterly data is standard in accounting, finance, and other fields. Much quarterly
    data is reported relative to a *fiscal year end*, typically the last calendar
    or business day of one of the 12 months of the year. Thus, the period `2012Q4`
    has a different meaning depending on fiscal year end. pandas supports all 12 possible
    quarterly frequencies as `Q-JAN` through `Q-DEC`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of a fiscal year ending in January, `2012Q4` runs from November
    2011 through January 2012, which you can check by converting to daily frequency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: See [Figure 11.2](#fig-figure_quarterly_periods) for an illustration.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/09caf3da85296866437ce8e683dc7f92.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Different quarterly frequency conventions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, it’s possible to do convenient period arithmetic; for example, to get
    the timestamp at 4 P.M. on the second-to-last business day of the quarter, you
    could do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The `to_timestamp` method returns the `Timestamp` at the start of the period
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can generate quarterly ranges using `pandas.period_range`. The arithmetic
    is identical, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Converting Timestamps to Periods (and Back)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Series and DataFrame objects indexed by timestamps can be converted to periods
    with the `to_period` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Since periods refer to nonoverlapping time spans, a timestamp can only belong
    to a single period for a given frequency. While the frequency of the new `PeriodIndex`
    is inferred from the timestamps by default, you can specify any supported frequency
    (most of those listed in [Table 11.4](#tbl-table_base_frequencies) are supported).
    There is also no problem with having duplicate periods in the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert back to timestamps, use the `to_timestamp` method, which returns
    a `DatetimeIndex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Creating a PeriodIndex from Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fixed frequency datasets are sometimes stored with time span information spread
    across multiple columns. For example, in this macroeconomic dataset, the year
    and quarter are in different columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'By passing these arrays to `PeriodIndex` with a frequency, you can combine
    them to form an index for the DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 11.6 Resampling and Frequency Conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Resampling* refers to the process of converting a time series from one frequency
    to another. Aggregating higher frequency data to lower frequency is called *downsampling*,
    while converting lower frequency to higher frequency is called *upsampling*. Not
    all resampling falls into either of these categories; for example, converting
    `W-WED` (weekly on Wednesday) to `W-FRI` is neither upsampling nor downsampling.'
  prefs: []
  type: TYPE_NORMAL
- en: 'pandas objects are equipped with a `resample` method, which is the workhorse
    function for all frequency conversion. `resample` has a similar API to `groupby`;
    you call `resample` to group the data, then call an aggregation function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '`resample` is a flexible method that can be used to process large time series.
    The examples in the following sections illustrate its semantics and use. [Table 11.5](#tbl-table_resample_method)
    summarizes some of its options.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11.5: `resample` method arguments'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `rule` | String, DateOffset, or timedelta indicating desired resampled frequency
    (for example, ’M'', ’5min'', or `Second(15)`) |'
  prefs: []
  type: TYPE_TB
- en: '| `axis` | Axis to resample on; default `axis=0` |'
  prefs: []
  type: TYPE_TB
- en: '| `fill_method` | How to interpolate when upsampling, as in `"ffill"` or `"bfill"`;
    by default does no interpolation |'
  prefs: []
  type: TYPE_TB
- en: '| `closed` | In downsampling, which end of each interval is closed (inclusive),
    `"right"` or `"left"` |'
  prefs: []
  type: TYPE_TB
- en: '| `label` | In downsampling, how to label the aggregated result, with the `"right"`
    or `"left"` bin edge (e.g., the 9:30 to 9:35 five-minute interval could be labeled
    `9:30` or `9:35`) |'
  prefs: []
  type: TYPE_TB
- en: '| `limit` | When forward or backward filling, the maximum number of periods
    to fill |'
  prefs: []
  type: TYPE_TB
- en: '| `kind` | Aggregate to periods (`"period"`) or timestamps (`"timestamp"`);
    defaults to the type of index the time series has |'
  prefs: []
  type: TYPE_TB
- en: '| `convention` | When resampling periods, the convention (`"start"` or `"end"`)
    for converting the low-frequency period to high frequency; defaults to `"start"`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `origin` | The "base" timestamp from which to determine the resampling bin
    edges; can also be one of `"epoch"`, `"start"`, `"start_day"`, `"end"`, or `"end_day"`;
    see the `resample` docstring for full details |'
  prefs: []
  type: TYPE_TB
- en: '| `offset` | An offset timedelta added to the origin; defaults to `None` |'
  prefs: []
  type: TYPE_TB
- en: Downsampling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Downsampling* is aggregating data to a regular, lower frequency. The data
    you’re aggregating doesn’t need to be fixed frequently; the desired frequency
    defines *bin edges* that are used to slice the time series into pieces to aggregate.
    For example, to convert to monthly, `"M"` or `"BM"`, you need to chop up the data
    into one-month intervals. Each interval is said to be *half-open*; a data point
    can belong only to one interval, and the union of the intervals must make up the
    whole time frame. There are a couple things to think about when using `resample`
    to downsample data:'
  prefs: []
  type: TYPE_NORMAL
- en: Which side of each interval is *closed*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to label each aggregated bin, either with the start of the interval or the
    end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To illustrate, let’s look at some one-minute frequency data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you wanted to aggregate this data into five-minute chunks or *bars*
    by taking the sum of each group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The frequency you pass defines bin edges in five-minute increments. For this
    frequency, by default the *left* bin edge is inclusive, so the `00:00` value is
    included in the `00:00` to `00:05` interval, and the `00:05` value is excluded
    from that interval.[¹](#fn1)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting time series is labeled by the timestamps from the left side of
    each bin. By passing `label="right"` you can label them with the right bin edge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: See [Figure 11.3](#fig-figure_resample_conventions) for an illustration of minute
    frequency data being resampled to five-minute frequency.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/21026aa76a40a42294e16b84e2d400ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: Five-minute resampling illustration of closed, label conventions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, you might want to shift the result index by some amount, say subtracting
    one second from the right edge to make it more clear which interval the timestamp
    refers to. To do this, add an offset to the resulting index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Open-high-low-close (OHLC) resampling
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In finance, a popular way to aggregate a time series is to compute four values
    for each bucket: the first (open), last (close), maximum (high), and minimal (low)
    values. By using the `ohlc` aggregate function, you will obtain a DataFrame having
    columns containing these four aggregates, which are efficiently computed in a
    single function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Upsampling and Interpolation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Upsampling is converting from a lower frequency to a higher frequency, where
    no aggregation is needed. Let’s consider a DataFrame with some weekly data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'When you are using an aggregation function with this data, there is only one
    value per group, and missing values result in the gaps. We use the `asfreq` method
    to convert to the higher frequency without any aggregation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you wanted to fill forward each weekly value on the non-Wednesdays.
    The same filling or interpolation methods available in the `fillna` and `reindex`
    methods are available for resampling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'You can similarly choose to only fill a certain number of periods forward to
    limit how far to continue using an observed value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Notably, the new date index need not coincide with the old one at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Resampling with Periods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Resampling data indexed by periods is similar to timestamps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Upsampling is more nuanced, as before resampling you must make a decision about
    which end of the time span in the new frequency to place the values. The `convention`
    argument defaults to `"start"` but can also be `"end"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Since periods refer to time spans, the rules about upsampling and downsampling
    are more rigid:'
  prefs: []
  type: TYPE_NORMAL
- en: In downsampling, the target frequency must be a *subperiod* of the source frequency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In upsampling, the target frequency must be a *superperiod* of the source frequency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If these rules are not satisfied, an exception will be raised. This mainly
    affects the quarterly, annual, and weekly frequencies; for example, the time spans
    defined by `Q-MAR` only line up with `A-MAR`, `A-JUN`, `A-SEP`, and `A-DEC`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Grouped Time Resampling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For time series data, the `resample` method is semantically a group operation
    based on a time intervalization. Here''s a small example table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can index by `"time"` and then resample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose that a DataFrame contains multiple time series, marked by an additional
    group key column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'To do the same resampling for each value of `"key"`, we introduce the `pandas.Grouper`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then set the time index, group by `"key"` and `time_key`, and aggregate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: One constraint with using `pandas.Grouper` is that the time must be the index
    of the Series or DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7 Moving Window Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important class of array transformations used for time series operations
    are statistics and other functions evaluated over a sliding window or with exponentially
    decaying weights. This can be useful for smoothing noisy or gappy data. I call
    these *moving window functions*, even though they include functions without a
    fixed-length window like exponentially weighted moving average. Like other statistical
    functions, these also automatically exclude missing data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before digging in, we can load up some time series data and resample it to
    business day frequency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'I now introduce the `rolling` operator, which behaves similarly to `resample`
    and `groupby`. It can be called on a Series or DataFrame along with a `window`
    (expressed as a number of periods; see [Apple price with 250-day moving average](#apple_daily_ma250)
    for the plot created):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/592f0eb154cb8af5292d2a938f2b873c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: Apple price with 250-day moving average'
  prefs: []
  type: TYPE_NORMAL
- en: The expression `rolling(250)` is similar in behavior to `groupby`, but instead
    of grouping, it creates an object that enables grouping over a 250-day sliding
    window. So here we have the 250-day moving window average of Apple's stock price.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, rolling functions require all of the values in the window to be
    non-NA. This behavior can be changed to account for missing data and, in particular,
    the fact that you will have fewer than `window` periods of data at the beginning
    of the time series (see [Apple 250-day daily return standard deviation](#apple_daily_std250)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/d8892398961900d39bbbcf3f01d8da4c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: Apple 250-day daily return standard deviation'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute an *expanding window mean*, use the `expanding` operator instead
    of `rolling`. The expanding mean starts the time window from the same point as
    the rolling window and increases the size of the window until it encompasses the
    whole series. An expanding window mean on the `std250` time series looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling a moving window function on a DataFrame applies the transformation
    to each column (see [Stock prices 60-day moving average (log y-axis)](#stocks_daily_ma60)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/e8f4e446ffcb7dd48b59497f44f85dd4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.6: Stock prices 60-day moving average (log y-axis)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rolling` function also accepts a string indicating a fixed-size time offset
    rolling() in moving window functions rather than a set number of periods. Using
    this notation can be useful for irregular time series. These are the same strings
    that you can pass to `resample`. For example, we could compute a 20-day rolling
    mean like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Exponentially Weighted Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An alternative to using a fixed window size with equally weighted observations
    is to specify a constant *decay factor* to give more weight to more recent observations.
    There are a couple of ways to specify the decay factor. A popular one is using
    a *span*, which makes the result comparable to a simple moving window function
    with window size equal to the span.
  prefs: []
  type: TYPE_NORMAL
- en: Since an exponentially weighted statistic places more weight on more recent
    observations, it “adapts” faster to changes compared with the equal-weighted version.
  prefs: []
  type: TYPE_NORMAL
- en: 'pandas has the `ewm` operator (which stands for exponentially weighted moving)
    to go along with `rolling` and `expanding`. Here’s an example comparing a 30-day
    moving average of Apple’s stock price with an exponentially weighted (EW) moving
    average with `span=60` (see [Simple moving average versus exponentially weighted](#timeseries_ewma)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/597f66552cc2eb32618fc4fb8471c04d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: Simple moving average versus exponentially weighted'
  prefs: []
  type: TYPE_NORMAL
- en: Binary Moving Window Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some statistical operators, like correlation and covariance, need to operate
    on two time series. As an example, financial analysts are often interested in
    a stock’s correlation to a benchmark index like the S&P 500\. To have a look at
    this, we first compute the percent change for all of our time series of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'After we call `rolling`, the `corr` aggregation function can then compute the
    rolling correlation with `spx_rets` (see [Six-month AAPL return correlation to
    S&P 500](#roll_correl_aapl) for the resulting plot):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/071a15ee104f8b18492d67565b62e3bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.8: Six-month AAPL return correlation to S&P 500'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you wanted to compute the rolling correlation of the S&P 500 index with
    many stocks at once. You could write a loop computing this for each stock like
    we did for Apple above, but if each stock is a column in a single DataFrame, we
    can compute all of the rolling correlations in one shot by calling `rolling` on
    the DataFrame and passing the `spx_rets` Series.
  prefs: []
  type: TYPE_NORMAL
- en: 'See [Six-month return correlations to S&P 500](#roll_correl_all) for the plot
    of the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/898f6a6974d281ac4a87524fcabc2566.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.9: Six-month return correlations to S&P 500'
  prefs: []
  type: TYPE_NORMAL
- en: User-Defined Moving Window Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `apply` method on `rolling` and related methods provides a way to apply
    an array function of your own creation over a moving window. The only requirement
    is that the function produce a single value (a reduction) from each piece of the
    array. For example, while we can compute sample quantiles using `rolling(...).quantile(q)`,
    we might be interested in the percentile rank of a particular value over the sample.
    The `scipy.stats.percentileofscore` function does just this (see [Percentile rank
    of 2% AAPL return over one-year window](#roll_apply_ex) for the resulting plot):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b686da0f6b499292c1b338fdebcddfef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.10: Percentile rank of 2% AAPL return over one-year window'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t have SciPy installed already, you can install it with conda or
    pip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 11.8 Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Time series data calls for different types of analysis and data transformation
    tools than the other types of data we have explored in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will show how to start using modeling libraries
    like statsmodels and scikit-learn.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The choice of the default values for `closed` and `label` might seem a bit odd
    to some users. The default is `closed="left"` for all but a specific set (`"M"`,
    `"A"`, `"Q"`, `"BM"`, `"BQ"`, and `"W"`) for which the default is `closed="right"`.
    The defaults were chosen to make the results more intuitive, but it is worth knowing
    that the default is not always one or the other.[↩︎](#fnref1)*****
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
