- en: 3  Built-In Data Structures, Functions, and Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://wesmckinney.com/book/python-builtin](https://wesmckinney.com/book/python-builtin)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This Open Access web version of *Python for Data Analysis 3rd Edition* is
    now available as a companion to the [print and digital editions](https://amzn.to/3DyLaJc).
    If you encounter any errata, [please report them here](https://oreilly.com/catalog/0636920519829/errata).
    Please note that some aspects of this site as produced by Quarto will differ from
    the formatting of the print and eBook versions from O’Reilly.'
  prefs: []
  type: TYPE_NORMAL
- en: If you find the online edition of the book useful, please consider [ordering
    a paper copy](https://amzn.to/3DyLaJc) or a [DRM-free eBook](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)
    to support the author. The content from this website may not be copied or reproduced.
    The code examples are MIT licensed and can be found on GitHub or Gitee.*  *This
    chapter discusses capabilities built into the Python language that will be used
    ubiquitously throughout the book. While add-on libraries like pandas and NumPy
    add advanced computational functionality for larger datasets, they are designed
    to be used together with Python's built-in data manipulation tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with Python''s workhorse data structures: tuples, lists, dictionaries,
    and sets. Then, we''ll discuss creating your own reusable Python functions. Finally,
    we''ll look at the mechanics of Python file objects and interacting with your
    local hard drive.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Data Structures and Sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python’s data structures are simple but powerful. Mastering their use is a critical
    part of becoming a proficient Python programmer. We start with tuple, list, and
    dictionary, which are some of the most frequently used *sequence* types.
  prefs: []
  type: TYPE_NORMAL
- en: Tuple
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *tuple* is a fixed-length, immutable sequence of Python objects which, once
    assigned, cannot be changed. The easiest way to create one is with a comma-separated
    sequence of values wrapped in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In many contexts, the parentheses can be omitted, so here we could also have
    written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can convert any sequence or iterator to a tuple by invoking `tuple`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Elements can be accessed with square brackets `[]` as with most other sequence
    types. As in C, C++, Java, and many other languages, sequences are 0-indexed in
    Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When you''re defining tuples within more complicated expressions, it’s often
    necessary to enclose the values in parentheses, as in this example of creating
    a tuple of tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'While the objects stored in a tuple may be mutable themselves, once the tuple
    is created it’s not possible to modify which object is stored in each slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If an object inside a tuple is mutable, such as a list, you can modify it in
    place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can concatenate tuples using the `+` operator to produce longer tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiplying a tuple by an integer, as with lists, has the effect of concatenating
    that many copies of the tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that the objects themselves are not copied, only the references to them.
  prefs: []
  type: TYPE_NORMAL
- en: Unpacking tuples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you try to *assign* to a tuple-like expression of variables, Python will
    attempt to *unpack* the value on the righthand side of the equals sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Even sequences with nested tuples can be unpacked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this functionality you can easily swap variable names, a task that in
    many languages might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'But, in Python, the swap can be done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A common use of variable unpacking is iterating over sequences of tuples or
    lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Another common use is returning multiple values from a function. I'll cover
    this in more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some situations where you may want to "pluck" a few elements from
    the beginning of a tuple. There is a special syntax that can do this, `*rest`,
    which is also used in function signatures to capture an arbitrarily long list
    of positional arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This `rest` bit is sometimes something you want to discard; there is nothing
    special about the `rest` name. As a matter of convention, many Python programmers
    will use the underscore (`_`) for unwanted variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tuple methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since the size and contents of a tuple cannot be modified, it is very light
    on instance methods. A particularly useful one (also available on lists) is `count`,
    which counts the number of occurrences of a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In contrast with tuples, lists are variable length and their contents can be
    modified in place. Lists are mutable. You can define them using square brackets
    `[]` or using the `list` type function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Lists and tuples are semantically similar (though tuples cannot be modified)
    and can be used interchangeably in many functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `list` built-in function is frequently used in data processing as a way
    to materialize an iterator or generator expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Adding and removing elements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Elements can be appended to the end of the list with the `append` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `insert` you can insert an element at a specific location in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The insertion index must be between 0 and the length of the list, inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: '*Warning* *`insert` is computationally expensive compared with `append`, because
    references to subsequent elements have to be shifted internally to make room for
    the new element. If you need to insert elements at both the beginning and end
    of a sequence, you may wish to explore `collections.deque`, a double-ended queue,
    which is optimized for this purpose and found in the Python Standard Library.*  *The
    inverse operation to `insert` is `pop`, which removes and returns an element at
    a particular index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Elements can be removed by value with `remove`, which locates the first such
    value and removes it from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If performance is not a concern, by using `append` and `remove`, you can use
    a Python list as a set-like data structure (although Python has actual set objects,
    discussed later).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check if a list contains a value using the `in` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The keyword `not` can be used to negate `in`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Checking whether a list contains a value is a lot slower than doing so with
    dictionaries and sets (to be introduced shortly), as Python makes a linear scan
    across the values of the list, whereas it can check the others (based on hash
    tables) in constant time.*  *#### Concatenating and combining lists
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to tuples, adding two lists together with `+` concatenates them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a list already defined, you can append multiple elements to it
    using the `extend` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that list concatenation by addition is a comparatively expensive operation
    since a new list must be created and the objects copied over. Using `extend` to
    append elements to an existing list, especially if you are building up a large
    list, is usually preferable. Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'is faster than the concatenative alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Sorting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can sort a list in place (without creating a new object) by calling its
    `sort` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`sort` has a few options that will occasionally come in handy. One is the ability
    to pass a secondary *sort key*—that is, a function that produces a value to use
    to sort the objects. For example, we could sort a collection of strings by their
    lengths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Soon, we'll look at the `sorted` function, which can produce a sorted copy of
    a general sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Slicing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can select sections of most sequence types by using slice notation, which
    in its basic form consists of `start:stop` passed to the indexing operator `[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Slices can also be assigned with a sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: While the element at the `start` index is included, the `stop` index is *not
    included*, so that the number of elements in the result is `stop - start`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Either the `start` or `stop` can be omitted, in which case they default to
    the start of the sequence and the end of the sequence, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Negative indices slice the sequence relative to the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Slicing semantics takes a bit of getting used to, especially if you’re coming
    from R or MATLAB. See [Figure 3.1](#fig-figure_seq_slicing) for a helpful illustration
    of slicing with positive and negative integers. In the figure, the indices are
    shown at the "bin edges" to help show where the slice selections start and stop
    using positive or negative indices.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fe1beb3f93e0617bb1f4800840b8dc37.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Illustration of Python slicing conventions'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `step` can also be used after a second colon to, say, take every other element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'A clever use of this is to pass `-1`, which has the useful effect of reversing
    a list or tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]*  *### Dictionary'
  prefs: []
  type: TYPE_NORMAL
- en: 'The dictionary or `dict` may be the most important built-in Python data structure.
    In other programming languages, dictionaries are sometimes called *hash maps*
    or *associative arrays*. A dictionary stores a collection of *key-value* pairs,
    where *key* and *value* are Python objects. Each key is associated with a value
    so that a value can be conveniently retrieved, inserted, modified, or deleted
    given a particular key. One approach for creating a dictionary is to use curly
    braces `{}` and colons to separate keys and values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can access, insert, or set elements using the same syntax as for accessing
    elements of a list or tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check if a dictionary contains a key using the same syntax used for
    checking whether a list or tuple contains a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can delete values using either the `del` keyword or the `pop` method (which
    simultaneously returns the value and deletes the key):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `keys` and `values` method gives you iterators of the dictionary''s keys
    and values, respectively. The order of the keys depends on the order of their
    insertion, and these functions output the keys and values in the same respective
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to iterate over both the keys and values, you can use the `items`
    method to iterate over the keys and values as 2-tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can merge one dictionary into another using the `update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `update` method changes dictionaries in place, so any existing keys in the
    data passed to `update` will have their old values discarded.
  prefs: []
  type: TYPE_NORMAL
- en: Creating dictionaries from sequences
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s common to occasionally end up with two sequences that you want to pair
    up element-wise in a dictionary. As a first cut, you might write code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Since a dictionary is essentially a collection of 2-tuples, the `dict` function
    accepts a list of 2-tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Later we’ll talk about *dictionary comprehensions*, which are another way to
    construct dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Default values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s common to have logic like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, the dictionary methods `get` and `pop` can take a default value to be
    returned, so that the above `if-else` block can be written simply as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`get` by default will return `None` if the key is not present, while `pop`
    will raise an exception. With *setting* values, it may be that the values in a
    dictionary are another kind of collection, like a list. For example, you could
    imagine categorizing a list of words by their first letters as a dictionary of
    lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setdefault` dictionary method can be used to simplify this workflow. The
    preceding `for` loop can be rewritten as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The built-in `collections` module has a useful class, `defaultdict`, which
    makes this even easier. To create one, you pass a type or function for generating
    the default value for each slot in the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Valid dictionary key types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While the values of a dictionary can be any Python object, the keys generally
    have to be immutable objects like scalar types (int, float, string) or tuples
    (all the objects in the tuple need to be immutable, too). The technical term here
    is *hashability*. You can check whether an object is hashable (can be used as
    a key in a dictionary) with the `hash` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The hash values you see when using the `hash` function in general will depend
    on the Python version you are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a list as a key, one option is to convert it to a tuple, which can be
    hashed as long as its elements also can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *set* is an unordered collection of unique elements. A set can be created
    in two ways: via the `set` function or via a *set literal* with curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Sets support mathematical *set operations* like union, intersection, difference,
    and symmetric difference. Consider these two example sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The union of these two sets is the set of distinct elements occurring in either
    set. This can be computed with either the `union` method or the `|` binary operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The intersection contains the elements occurring in both sets. The `&` operator
    or the `intersection` method can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: See [Table 3.1](#tbl-table_set_operations) for a list of commonly used set methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 3.1: Python set operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Alternative syntax | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `a.add(x)` | N/A | Add element `x` to set `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a.clear()` | N/A | Reset set `a` to an empty state, discarding all of its
    elements |'
  prefs: []
  type: TYPE_TB
- en: '| `a.remove(x)` | N/A | Remove element `x` from set `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a.pop()` | N/A | Remove an arbitrary element from set `a`, raising `KeyError`
    if the set is empty |'
  prefs: []
  type: TYPE_TB
- en: '| `a.union(b)` | `a &#124; b` | All of the unique elements in `a` and `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `a.update(b)` | `a &#124;= b` | Set the contents of `a` to be the union of
    the elements in `a` and `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `a.intersection(b)` | `a & b` | All of the elements in *both* `a` and `b`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a.intersection_update(b)` | `a &= b` | Set the contents of `a` to be the
    intersection of the elements in `a` and `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `a.difference(b)` | `a - b` | The elements in `a` that are not in `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `a.difference_update(b)` | `a -= b` | Set `a` to the elements in `a` that
    are not in `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `a.symmetric_difference(b)` | `a ^ b` | All of the elements in either `a`
    or `b` but *not both* |'
  prefs: []
  type: TYPE_TB
- en: '| `a.symmetric_difference_update(b)` | `a ^= b` | Set `a` to contain the elements
    in either `a` or `b` but *not both* |'
  prefs: []
  type: TYPE_TB
- en: '| `a.issubset(b)` | `<=` | `True` if the elements of `a` are all contained
    in `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `a.issuperset(b)` | `>=` | `True` if the elements of `b` are all contained
    in `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a.isdisjoint(b)` | N/A | `True` if `a` and `b` have no elements in common
    |'
  prefs: []
  type: TYPE_TB
- en: '*Note* *If you pass an input that is not a set to methods like `union` and
    `intersection`, Python will convert the input to a set before executing the operation.
    When using the binary operators, both objects must already be sets.*  *All of
    the logical set operations have in-place counterparts, which enable you to replace
    the contents of the set on the left side of the operation with the result. For
    very large sets, this may be more efficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Like dictionary keys, set elements generally must be immutable, and they must
    be *hashable* (which means that calling `hash` on a value does not raise an exception).
    In order to store list-like elements (or other mutable sequences) in a set, you
    can convert them to tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also check if a set is a subset of (is contained in) or a superset
    of (contains all elements of) another set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Sets are equal if and only if their contents are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]*  *### Built-In Sequence Functions'
  prefs: []
  type: TYPE_NORMAL
- en: Python has a handful of useful sequence functions that you should familiarize
    yourself with and use at any opportunity.
  prefs: []
  type: TYPE_NORMAL
- en: enumerate
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s common when iterating over a sequence to want to keep track of the index
    of the current item. A do-it-yourself approach would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is so common, Python has a built-in function, `enumerate`, which
    returns a sequence of `(i, value)` tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: sorted
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `sorted` function returns a new sorted list from the elements of any sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `sorted` function accepts the same arguments as the `sort` method on lists.
  prefs: []
  type: TYPE_NORMAL
- en: zip
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`zip` “pairs” up the elements of a number of lists, tuples, or other sequences
    to create a list of tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '`zip` can take an arbitrary number of sequences, and the number of elements
    it produces is determined by the *shortest* sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'A common use of `zip` is simultaneously iterating over multiple sequences,
    possibly also combined with `enumerate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: reversed
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`reversed` iterates over the elements of a sequence in reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that `reversed` is a generator (to be discussed in some more detail
    later), so it does not create the reversed sequence until materialized (e.g.,
    with `list` or a `for` loop).
  prefs: []
  type: TYPE_NORMAL
- en: List, Set, and Dictionary Comprehensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*List comprehensions* are a convenient and widely used Python language feature.
    They allow you to concisely form a new list by filtering the elements of a collection,
    transforming the elements passing the filter into one concise expression. They
    take the basic form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the following `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The filter condition can be omitted, leaving only the expression. For example,
    given a list of strings, we could filter out strings with length `2` or less and
    convert them to uppercase like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Set and dictionary comprehensions are a natural extension, producing sets and
    dictionaries in an idiomatically similar way instead of lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'A dictionary comprehension looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'A set comprehension looks like the equivalent list comprehension except with
    curly braces instead of square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Like list comprehensions, set and dictionary comprehensions are mostly conveniences,
    but they similarly can make code both easier to write and read. Consider the list
    of strings from before. Suppose we wanted a set containing just the lengths of
    the strings contained in the collection; we could easily compute this using a
    set comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also express this more functionally using the `map` function, introduced
    shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'As a simple dictionary comprehension example, we could create a lookup map
    of these strings for their locations in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Nested list comprehensions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Suppose we have a list of lists containing some English and Spanish names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we wanted to get a single list containing all names with two or more
    `a`’s in them. We could certainly do this with a simple `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'You can actually wrap this whole operation up in a single *nested list comprehension*,
    which will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'At first, nested list comprehensions are a bit hard to wrap your head around.
    The `for` parts of the list comprehension are arranged according to the order
    of nesting, and any filter condition is put at the end as before. Here is another
    example where we “flatten” a list of tuples of integers into a simple list of
    integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep in mind that the order of the `for` expressions would be the same if you
    wrote a nested `for` loop instead of a list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'You can have arbitrarily many levels of nesting, though if you have more than
    two or three levels of nesting, you should probably start to question whether
    this makes sense from a code readability standpoint. It’s important to distinguish
    the syntax just shown from a list comprehension inside a list comprehension, which
    is also perfectly valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: This produces a list of lists, rather than a flattened list of all of the inner
    elements.**  **## 3.2 Functions
  prefs: []
  type: TYPE_NORMAL
- en: '*Functions* are the primary and most important method of code organization
    and reuse in Python. As a rule of thumb, if you anticipate needing to repeat the
    same or very similar code more than once, it may be worth writing a reusable function.
    Functions can also help make your code more readable by giving a name to a group
    of Python statements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions are declared with the `def` keyword. A function contains a block
    of code with an optional use of the `return` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'When a line with `return` is reached, the value or expression after `return`
    is sent to the context where the function was called, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no issue with having multiple `return` statements. If Python reaches
    the end of a function without encountering a `return` statement, `None` is returned
    automatically. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Each function can have *positional* arguments and *keyword* arguments. Keyword
    arguments are most commonly used to specify default values or optional arguments.
    Here we will define a function with an optional `z` argument with the default
    value `1.5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: While keyword arguments are optional, all positional arguments must be specified
    when calling a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can pass values to the `z` argument with or without the keyword provided,
    though using the keyword is encouraged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The main restriction on function arguments is that the keyword arguments *must*
    follow the positional arguments (if any). You can specify keyword arguments in
    any order. This frees you from having to remember the order in which the function
    arguments were specified. You need to remember only what their names are.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces, Scope, and Local Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Functions can access variables created inside the function as well as those
    outside the function in higher (or even *global*) scopes. An alternative and more
    descriptive name describing a variable scope in Python is a *namespace*. Any variables
    that are assigned within a function by default are assigned to the local namespace.
    The local namespace is created when the function is called and is immediately
    populated by the function’s arguments. After the function is finished, the local
    namespace is destroyed (with some exceptions that are outside the purview of this
    chapter). Consider the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'When `func()` is called, the empty list `a` is created, five elements are appended,
    and then `a` is destroyed when the function exits. Suppose instead we had declared
    `a` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Each call to `func` will modify list `a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Assigning variables outside of the function''s scope is possible, but those
    variables must be declared explicitly using either the `global` or `nonlocal`
    keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '`nonlocal` allows a function to modify variables defined in a higher-level
    scope that is not global. Since its use is somewhat esoteric (I never use it in
    this book), I refer you to the Python documentation to learn more about it.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Caution* *I generally discourage use of the `global` keyword. Typically, global
    variables are used to store some kind of state in a system. If you find yourself
    using a lot of them, it may indicate a need for object-oriented programming (using
    classes).*  *### Returning Multiple Values'
  prefs: []
  type: TYPE_NORMAL
- en: 'When I first programmed in Python after having programmed in Java and C++,
    one of my favorite features was the ability to return multiple values from a function
    with simple syntax. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'In data analysis and other scientific applications, you may find yourself doing
    this often. What’s happening here is that the function is actually just returning
    *one* object, a tuple, which is then being unpacked into the result variables.
    In the preceding example, we could have done this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, `return_value` would be a 3-tuple with the three returned variables.
    A potentially attractive alternative to returning multiple values like before
    might be to return a dictionary instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This alternative technique can be useful depending on what you are trying to
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Functions Are Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since Python functions are objects, many constructs can be easily expressed
    that are difficult to do in other languages. Suppose we were doing some data cleaning
    and needed to apply a bunch of transformations to the following list of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Anyone who has ever worked with user-submitted survey data has seen messy results
    like these. Lots of things need to happen to make this list of strings uniform
    and ready for analysis: stripping whitespace, removing punctuation symbols, and
    standardizing proper capitalization. One way to do this is to use built-in string
    methods along with the `re` standard library module for regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative approach that you may find useful is to make a list of the operations
    you want to apply to a particular set of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: A more *functional* pattern like this enables you to easily modify how the strings
    are transformed at a very high level. The `clean_strings` function is also now
    more reusable and generic.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use functions as arguments to other functions like the built-in `map`
    function, which applies a function to a sequence of some kind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '`map` can be used as an alternative to list comprehensions without any filter.'
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous (Lambda) Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python has support for so-called *anonymous* or *lambda* functions, which are
    a way of writing functions consisting of a single statement, the result of which
    is the return value. They are defined with the `lambda` keyword, which has no
    meaning other than “we are declaring an anonymous function”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'I usually refer to these as lambda functions in the rest of the book. They
    are especially convenient in data analysis because, as you’ll see, there are many
    cases where data transformation functions will take functions as arguments. It’s
    often less typing (and clearer) to pass a lambda function as opposed to writing
    a full-out function declaration or even assigning the lambda function to a local
    variable. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: You could also have written `[x * 2 for x in ints]`, but here we were able to
    succinctly pass a custom operator to the `apply_to_list` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'As another example, suppose you wanted to sort a collection of strings by the
    number of distinct letters in each string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we could pass a lambda function to the list’s `sort` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Generators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many objects in Python support iteration, such as over objects in a list or
    lines in a file. This is accomplished by means of the *iterator protocol*, a generic
    way to make objects iterable. For example, iterating over a dictionary yields
    the dictionary keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'When you write `for key in some_dict`, the Python interpreter first attempts
    to create an iterator out of `some_dict`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'An iterator is any object that will yield objects to the Python interpreter
    when used in a context like a `for` loop. Most methods expecting a list or list-like
    object will also accept any iterable object. This includes built-in methods such
    as `min`, `max`, and `sum`, and type constructors like `list` and `tuple`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'A *generator* is a convenient way, similar to writing a normal function, to
    construct a new iterable object. Whereas normal functions execute and return a
    single result at a time, generators can return a sequence of multiple values by
    pausing and resuming execution each time the generator is used. To create a generator,
    use the `yield` keyword instead of `return` in a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'When you actually call the generator, no code is immediately executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'It is not until you request elements from the generator that it begins executing
    its code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '*Note* *Since generators produce output one element at a time versus an entire
    list all at once, it can help your program use less memory.*  *#### Generator
    expressions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to make a generator is by using a *generator expression*. This
    is a generator analogue to list, dictionary, and set comprehensions. To create
    one, enclose what would otherwise be a list comprehension within parentheses instead
    of brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the following more verbose generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Generator expressions can be used instead of list comprehensions as function
    arguments in some cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the number of elements produced by the comprehension expression,
    the generator version can sometimes be meaningfully faster.
  prefs: []
  type: TYPE_NORMAL
- en: itertools module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The standard library `itertools` module has a collection of generators for
    many common data algorithms. For example, `groupby` takes any sequence and a function,
    grouping consecutive elements in the sequence by return value of the function.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: See [Table 3.2](#tbl-table_itertools) for a list of a few other `itertools`
    functions I’ve frequently found helpful. You may like to check out [the official
    Python documentation](https://docs.python.org/3/library/itertools.html) for more
    on this useful built-in utility module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 3.2: Some useful `itertools` functions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `chain(*iterables)` | Generates a sequence by chaining iterators together.
    Once elements from the first iterator are exhausted, elements from the next iterator
    are returned, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `combinations(iterable, k)` | Generates a sequence of all possible `k`-tuples
    of elements in the iterable, ignoring order and without replacement (see also
    the companion function `combinations_with_replacement`). |'
  prefs: []
  type: TYPE_TB
- en: '| `permutations(iterable, k)` | Generates a sequence of all possible `k`-tuples
    of elements in the iterable, respecting order. |'
  prefs: []
  type: TYPE_TB
- en: '| `groupby(iterable[, keyfunc])` | Generates `(key, sub-iterator)` for each
    unique key. |'
  prefs: []
  type: TYPE_TB
- en: '| `product(*iterables, repeat=1)` | Generates the Cartesian product of the
    input iterables as tuples, similar to a nested `for` loop. |*  *### Errors and
    Exception Handling'
  prefs: []
  type: TYPE_NORMAL
- en: 'Handling Python errors or *exceptions* gracefully is an important part of building
    robust programs. In data analysis applications, many functions work only on certain
    kinds of input. As an example, Python’s `float` function is capable of casting
    a string to a floating-point number, but it fails with `ValueError` on improper
    inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we wanted a version of `float` that fails gracefully, returning the
    input argument. We can do this by writing a function that encloses the call to
    `float` in a `try`/`except` block (execute this code in IPython):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The code in the `except` part of the block will only be executed if `float(x)`
    raises an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'You might notice that `float` can raise exceptions other than `ValueError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'You might want to suppress only `ValueError`, since a `TypeError` (the input
    was not a string or numeric value) might indicate a legitimate bug in your program.
    To do that, write the exception type after `except`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'We have then:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'You can catch multiple exception types by writing a tuple of exception types
    instead (the parentheses are required):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, you may not want to suppress an exception, but you want some
    code to be executed regardless of whether or not the code in the `try` block succeeds.
    To do this, use `finally`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the file object `f` will *always* get closed. Similarly, you can have
    code that executes only if the `try:` block succeeds using `else`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Exceptions in IPython
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If an exception is raised while you are `%run`-ing a script or executing any
    statement, IPython will by default print a full call stack trace (traceback) with
    a few lines of context around the position at each point in the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Having additional context by itself is a big advantage over the standard Python
    interpreter (which does not provide any additional context). You can control the
    amount of context shown using the `%xmode` magic command, from `Plain` (same as
    the standard Python interpreter) to `Verbose` (which inlines function argument
    values and more). As you will see later in [Appendix B: More on the IPython System](/book/ipython),
    you can step *into the stack* (using the `%debug` or `%pdb` magics) after an error
    has occurred for interactive postmortem debugging.**  **## 3.3 Files and the Operating
    System'
  prefs: []
  type: TYPE_NORMAL
- en: Most of this book uses high-level tools like `pandas.read_csv` to read data
    files from disk into Python data structures. However, it’s important to understand
    the basics of how to work with files in Python. Fortunately, it’s relatively straightforward,
    which is one reason Python is so popular for text and file munging.
  prefs: []
  type: TYPE_NORMAL
- en: 'To open a file for reading or writing, use the built-in `open` function with
    either a relative or absolute file path and an optional file encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Here, I pass `encoding="utf-8"` as a best practice because the default Unicode
    encoding for reading files varies from platform to platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the file is opened in read-only mode `"r"`. We can then treat the
    file object `f` like a list and iterate over the lines like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The lines come out of the file with the end-of-line (EOL) markers intact, so
    you’ll often see code to get an EOL-free list of lines in a file like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'When you use `open` to create file objects, it is recommended to close the
    file when you are finished with it. Closing the file releases its resources back
    to the operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the ways to make it easier to clean up open files is to use the `with`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: This will automatically close the file `f` when exiting the `with` block. Failing
    to ensure that files are closed will not cause problems in many small programs
    or scripts, but it can be an issue in programs that need to interact with a large
    number of files.
  prefs: []
  type: TYPE_NORMAL
- en: If we had typed `f = open(path, "w")`, a *new file* at *examples/segismundo.txt*
    would have been created (be careful!), overwriting any file in its place. There
    is also the `"x"` file mode, which creates a writable file but fails if the file
    path already exists. See [Table 3.3](#tbl-table_file_modes) for a list of all
    valid file read/write modes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 3.3: Python file modes'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mode | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `r` | Read-only mode |'
  prefs: []
  type: TYPE_TB
- en: '| `w` | Write-only mode; creates a new file (erasing the data for any file
    with the same name) |'
  prefs: []
  type: TYPE_TB
- en: '| `x` | Write-only mode; creates a new file but fails if the file path already
    exists |'
  prefs: []
  type: TYPE_TB
- en: '| `a` | Append to existing file (creates the file if it does not already exist)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `r+` | Read and write |'
  prefs: []
  type: TYPE_TB
- en: '| `b` | Add to mode for binary files (i.e., `"rb"` or `"wb"`) |'
  prefs: []
  type: TYPE_TB
- en: '| `t` | Text mode for files (automatically decoding bytes to Unicode); this
    is the default if not specified |'
  prefs: []
  type: TYPE_TB
- en: 'For readable files, some of the most commonly used methods are `read`, `seek`,
    and `tell`. `read` returns a certain number of characters from the file. What
    constitutes a "character" is determined by the file encoding or simply raw bytes
    if the file is opened in binary mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'The `read` method advances the file object position by the number of bytes
    read. `tell` gives you the current position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though we read 10 characters from the file `f1` opened in text mode, the
    position is 11 because it took that many bytes to decode 10 characters using the
    default encoding. You can check the default encoding in the `sys` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: To get consistent behavior across platforms, it is best to pass an encoding
    (such as `encoding="utf-8"`, which is widely used) when opening files.
  prefs: []
  type: TYPE_NORMAL
- en: '`seek` changes the file position to the indicated byte in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we remember to close the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'To write text to a file, you can use the file’s `write` or `writelines` methods.
    For example, we could create a version of *examples/segismundo.txt* with no blank
    lines like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: See [Table 3.4](#tbl-table_file_methods) for many of the most commonly used
    file methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 3.4: Important Python file methods or attributes'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method/attribute | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `read([size])` | Return data from file as bytes or string depending on the
    file mode, with optional `size` argument indicating the number of bytes or string
    characters to read |'
  prefs: []
  type: TYPE_TB
- en: '| `readable()` | Return `True` if the file supports `read` operations |'
  prefs: []
  type: TYPE_TB
- en: '| `readlines([size])` | Return list of lines in the file, with optional `size`
    argument |'
  prefs: []
  type: TYPE_TB
- en: '| `write(string)` | Write passed string to file |'
  prefs: []
  type: TYPE_TB
- en: '| `writable()` | Return `True` if the file supports `write` operations |'
  prefs: []
  type: TYPE_TB
- en: '| `writelines(strings)` | Write passed sequence of strings to the file |'
  prefs: []
  type: TYPE_TB
- en: '| `close()` | Close the file object |'
  prefs: []
  type: TYPE_TB
- en: '| `flush()` | Flush the internal I/O buffer to disk |'
  prefs: []
  type: TYPE_TB
- en: '| `seek(pos)` | Move to indicated file position (integer) |'
  prefs: []
  type: TYPE_TB
- en: '| `seekable()` | Return `True` if the file object supports seeking and thus
    random access (some file-like objects do not) |'
  prefs: []
  type: TYPE_TB
- en: '| `tell()` | Return current file position as integer |'
  prefs: []
  type: TYPE_TB
- en: '| `closed` | `True` if the file is closed |'
  prefs: []
  type: TYPE_TB
- en: '| `encoding` | The encoding used to interpret bytes in the file as Unicode
    (typically UTF-8) |'
  prefs: []
  type: TYPE_TB
- en: Bytes and Unicode with Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The default behavior for Python files (whether readable or writable) is *text
    mode*, which means that you intend to work with Python strings (i.e., Unicode).
    This contrasts with *binary mode*, which you can obtain by appending `b` to the
    file mode. Revisiting the file (which contains non-ASCII characters with UTF-8
    encoding) from the previous section, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'UTF-8 is a variable-length Unicode encoding, so when I request some number
    of characters from the file, Python reads enough bytes (which could be as few
    as 10 or as many as 40 bytes) from the file to decode that many characters. If
    I open the file in `"rb"` mode instead, `read` requests that exact number of bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on the text encoding, you may be able to decode the bytes to a `str`
    object yourself, but only if each of the encoded Unicode characters is fully formed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Text mode, combined with the `encoding` option of `open`, provides a convenient
    way to convert from one Unicode encoding to another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Beware using `seek` when opening files in any mode other than binary. If the
    file position falls in the middle of the bytes defining a Unicode character, then
    subsequent reads will result in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: If you find yourself regularly doing data analysis on non-ASCII text data, mastering
    Python's Unicode functionality will prove valuable. See [Python's online documentation](https://docs.python.org)
    for much more.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4 Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With some of the basics of the Python environment and language now under your
    belt, it is time to move on and learn about NumPy and array-oriented computing
    in Python.*****
  prefs: []
  type: TYPE_NORMAL
