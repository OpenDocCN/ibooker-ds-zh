- en: 2  Python Language Basics, IPython, and Jupyter Notebooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://wesmckinney.com/book/python-basics](https://wesmckinney.com/book/python-basics)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This Open Access web version of *Python for Data Analysis 3rd Edition* is
    now available as a companion to the [print and digital editions](https://amzn.to/3DyLaJc).
    If you encounter any errata, [please report them here](https://oreilly.com/catalog/0636920519829/errata).
    Please note that some aspects of this site as produced by Quarto will differ from
    the formatting of the print and eBook versions from O’Reilly.'
  prefs: []
  type: TYPE_NORMAL
- en: If you find the online edition of the book useful, please consider [ordering
    a paper copy](https://amzn.to/3DyLaJc) or a [DRM-free eBook](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)
    to support the author. The content from this website may not be copied or reproduced.
    The code examples are MIT licensed and can be found on GitHub or Gitee.*  *When
    I wrote the first edition of this book in 2011 and 2012, there were fewer resources
    available for learning about doing data analysis in Python. This was partially
    a chicken-and-egg problem; many libraries that we now take for granted, like pandas,
    scikit-learn, and statsmodels, were comparatively immature back then. Now in 2022,
    there is now a growing literature on data science, data analysis, and machine
    learning, supplementing the prior works on general-purpose scientific computing
    geared toward computational scientists, physicists, and professionals in other
    research fields. There are also excellent books about learning the Python programming
    language itself and becoming an effective software engineer.
  prefs: []
  type: TYPE_NORMAL
- en: 'As this book is intended as an introductory text in working with data in Python,
    I feel it is valuable to have a self-contained overview of some of the most important
    features of Python’s built-in data structures and libraries from the perspective
    of data manipulation. So, I will only present roughly enough information in this
    chapter and [Ch 3: Built-in Data Structures, Functions, and Files](/book/python-builtin)
    to enable you to follow along with the rest of the book.'
  prefs: []
  type: TYPE_NORMAL
- en: Much of this book focuses on table-based analytics and data preparation tools
    for working with datasets that are small enough to fit on your personal computer.
    To use these tools you must sometimes do some wrangling to arrange messy data
    into a more nicely tabular (or *structured*) form. Fortunately, Python is an ideal
    language for doing this. The greater your facility with the Python language and
    its built-in data types, the easier it will be for you to prepare new datasets
    for analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the tools in this book are best explored from a live IPython or Jupyter
    session. Once you learn how to start up IPython and Jupyter, I recommend that
    you follow along with the examples so you can experiment and try different things.
    As with any keyboard-driven console-like environment, developing familiarity with
    the common commands is also part of the learning curve.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note* *There are introductory Python concepts that this chapter does not cover,
    like classes and object-oriented programming, which you may find useful in your
    foray into data analysis in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To deepen your Python language knowledge, I recommend that you supplement this
    chapter with the [official Python tutorial](http://docs.python.org) and potentially
    one of the many excellent books on general-purpose Python programming. Some recommendations
    to get you started include:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Python Cookbook*, Third Edition, by David Beazley and Brian K. Jones (O''Reilly)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fluent Python* by Luciano Ramalho (O''Reilly)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Effective Python*, Second Edition, by Brett Slatkin (Addison-Wesley)*  *##
    2.1 The Python Interpreter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python is an *interpreted* language. The Python interpreter runs a program
    by executing one statement at a time. The standard interactive Python interpreter
    can be invoked on the command line with the `python` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `>>>` you see is the *prompt* after which you’ll type code expressions.
    To exit the Python interpreter, you can either type `exit()` or press Ctrl-D (works
    on Linux and macOS only).
  prefs: []
  type: TYPE_NORMAL
- en: 'Running Python programs is as simple as calling `python` with a *.py* file
    as its first argument. Suppose we had created *hello_world.py* with these contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run it by executing the following command (the *hello_world.py* file
    must be in your current working terminal directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'While some Python programmers execute all of their Python code in this way,
    those doing data analysis or scientific computing make use of IPython, an enhanced
    Python interpreter, or Jupyter notebooks, web-based code notebooks originally
    created within the IPython project. I give an introduction to using IPython and
    Jupyter in this chapter and have included a deeper look at IPython functionality
    in [Appendix A: Advanced NumPy](/book/advanced-numpy). When you use the `%run`
    command, IPython executes the code in the specified file in the same process,
    enabling you to explore the results interactively when it’s done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The default IPython prompt adopts the numbered `In [2]:` style, compared with
    the standard `>>>` prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 IPython Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, I'll get you up and running with the IPython shell and Jupyter
    notebook, and introduce you to some of the essential concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Running the IPython Shell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can launch the IPython shell on the command line just like launching the
    regular Python interpreter except with the `ipython` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can execute arbitrary Python statements by typing them and pressing Return
    (or Enter). When you type just a variable into IPython, it renders a string representation
    of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines are Python code statements; the second statement creates
    a variable named `data` that refers to a newly created list. The last line prints
    the value of `data` in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many kinds of Python objects are formatted to be more readable, or *pretty-printed*,
    which is distinct from normal printing with `print`. If you printed the above
    `data` variable in the standard Python interpreter, it would be much less readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: IPython also provides facilities to execute arbitrary blocks of code (via a
    somewhat glorified copy-and-paste approach) and whole Python scripts. You can
    also use the Jupyter notebook to work with larger blocks of code, as we will soon
    see.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Jupyter Notebook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the major components of the Jupyter project is the *notebook*, a type
    of interactive document for code, text (including Markdown), data visualizations,
    and other output. The Jupyter notebook interacts with *kernels*, which are implementations
    of the Jupyter interactive computing protocol specific to different programming
    languages. The Python Jupyter kernel uses the IPython system for its underlying
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start up Jupyter, run the command `jupyter` `notebook` in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: On many platforms, Jupyter will automatically open in your default web browser
    (unless you start it with `--no-browser`). Otherwise, you can navigate to the
    HTTP address printed when you started the notebook, here `http://localhost:8888/?token=0a77b52fefe52ab83e3c35dff8de121e4bb443a63f2d3055`.
    See [Figure 2.1](#fig-figure_jupyter_landing) for what this looks like in Google
    Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note* *Many people use Jupyter as a local computing environment, but it can
    also be deployed on servers and accessed remotely. I won''t cover those details
    here, but I encourage you to explore this topic on the internet if it''s relevant
    to your needs.*  *![](../Images/1cd631e8481f11b53a8555983ea31c1e.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.1: Jupyter notebook landing page'
  prefs: []
  type: TYPE_NORMAL
- en: To create a new notebook, click the New button and select the "Python 3" option.
    You should see something like [Figure 2.2](#fig-figure_jupyter_new_nb). If this
    is your first time, try clicking on the empty code "cell" and entering a line
    of Python code. Then press Shift-Enter to execute it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7f99b0a8aa2805183d2316e51eba5f22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Jupyter new notebook view'
  prefs: []
  type: TYPE_NORMAL
- en: When you save the notebook (see "Save and Checkpoint" under the notebook File
    menu), it creates a file with the extension *.ipynb*. This is a self-contained
    file format that contains all of the content (including any evaluated code output)
    currently in the notebook. These can be loaded and edited by other Jupyter users.
  prefs: []
  type: TYPE_NORMAL
- en: To rename an open notebook, click on the notebook title at the top of the page
    and type the new title, pressing Enter when you are finished.
  prefs: []
  type: TYPE_NORMAL
- en: To load an existing notebook, put the file in the same directory where you started
    the notebook process (or in a subfolder within it), then click the name from the
    landing page. You can try it out with the notebooks from my *wesm/pydata-book*
    repository on GitHub. See [Figure 2.3](#fig-figure_jupyter_existing_nb).
  prefs: []
  type: TYPE_NORMAL
- en: When you want to close a notebook, click the File menu and select "Close and
    Halt." If you simply close the browser tab, the Python process associated with
    the notebook will keep running in the background.
  prefs: []
  type: TYPE_NORMAL
- en: While the Jupyter notebook may feel like a distinct experience from the IPython
    shell, nearly all of the commands and tools in this chapter can be used in either
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/85dffdfb28f327f6e100f02d45b76f91.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Jupyter example view for an existing notebook*  *### Tab Completion'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the surface, the IPython shell looks like a cosmetically different version
    of the standard terminal Python interpreter (invoked with `python`). One of the
    major improvements over the standard Python shell is *tab completion*, found in
    many IDEs or other interactive computing analysis environments. While entering
    expressions in the shell, pressing the Tab key will search the namespace for any
    variables (objects, functions, etc.) matching the characters you have typed so
    far and show the results in a convenient drop-down menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, note that IPython displayed both of the two variables I defined,
    as well as the built-in function `any`. Also, you can also complete methods and
    attributes on any object after typing a period:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The same is true for modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Note* *Note that IPython by default hides methods and attributes starting
    with underscores, such as magic methods and internal “private” methods and attributes,
    in order to avoid cluttering the display (and confusing novice users!). These,
    too, can be tab-completed, but you must first type an underscore to see them.
    If you prefer to always see such methods in tab completion, you can change this
    setting in the IPython configuration. See the [IPython documentation](https://ipython.readthedocs.io)
    to find out how to do this.*  *Tab completion works in many contexts outside of
    searching the interactive namespace and completing object or module attributes.
    When typing anything that looks like a file path (even in a Python string), pressing
    the Tab key will complete anything on your computer’s filesystem matching what
    you’ve typed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Combined with the `%run` command (see [Appendix B.2.1: The %run Command](/book/ipython#ipython_basics_magic_run)),
    this functionality can save you many keystrokes.'
  prefs: []
  type: TYPE_NORMAL
- en: Another area where tab completion saves time is in the completion of function
    keyword arguments (including the `=` sign!). See [Figure 2.4](#fig-figure_jupyter_autocomplete_keywords).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9ddeddd0816344270288957f3493eb63.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Autocomplete function keywords in a Jupyter notebook'
  prefs: []
  type: TYPE_NORMAL
- en: We'll have a closer look at functions in a little bit.*  *### Introspection
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a question mark (`?`) before or after a variable will display some general
    information about the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is referred to as *object introspection*. If the object is a function
    or instance method, the docstring, if defined, will also be shown. Suppose we’d
    written the following function (which you can reproduce in IPython or Jupyter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then using `?` shows us the docstring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`?` has a final usage, which is for searching the IPython namespace in a manner
    similar to the standard Unix or Windows command line. A number of characters combined
    with the wildcard (`*`) will show all names matching the wildcard expression.
    For example, we could get a list of all functions in the top-level NumPy namespace
    containing `load`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]**  **## 2.3 Python Language Basics'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I will give you an overview of essential Python programming
    concepts and language mechanics. In the next chapter, I will go into more detail
    about Python data structures, functions, and other built-in tools.
  prefs: []
  type: TYPE_NORMAL
- en: Language Semantics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Python language design is distinguished by its emphasis on readability,
    simplicity, and explicitness. Some people go so far as to liken it to “executable
    pseudocode.”
  prefs: []
  type: TYPE_NORMAL
- en: Indentation, not braces
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Python uses whitespace (tabs or spaces) to structure code instead of using
    braces as in many other languages like R, C++, Java, and Perl. Consider a `for`
    loop from a sorting algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A colon denotes the start of an indented code block after which all of the code
    must be indented by the same amount until the end of the block.
  prefs: []
  type: TYPE_NORMAL
- en: Love it or hate it, significant whitespace is a fact of life for Python programmers.
    While it may seem foreign at first, you will hopefully grow accustomed to it in
    time.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note* *I strongly recommend using *four spaces* as your default indentation
    and replacing tabs with four spaces. Many text editors have a setting that will
    replace tab stops with spaces automatically (do this!). IPython and Jupyter notebooks
    will automatically insert four spaces on new lines following a colon and replace
    tabs by four spaces.*  *As you can see by now, Python statements also do not need
    to be terminated by semicolons. Semicolons can be used, however, to separate multiple
    statements on a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Putting multiple statements on one line is generally discouraged in Python as
    it can make code less readable.*  *#### Everything is an object
  prefs: []
  type: TYPE_NORMAL
- en: An important characteristic of the Python language is the consistency of its
    *object model*. Every number, string, data structure, function, class, module,
    and so on exists in the Python interpreter in its own “box,” which is referred
    to as a *Python object*. Each object has an associated *type* (e.g., *integer*,
    *string*, or *function*) and internal data. In practice this makes the language
    very flexible, as even functions can be treated like any other object.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Any text preceded by the hash mark (pound sign) `#` is ignored by the Python
    interpreter. This is often used to add comments to code. At times you may also
    want to exclude certain blocks of code without deleting them. One solution is
    to *comment out* the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Comments can also occur after a line of executed code. While some programmers
    prefer comments to be placed in the line preceding a particular line of code,
    this can be useful at times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Function and object method calls
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You call functions using parentheses and passing zero or more arguments, optionally
    assigning the returned value to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Almost every object in Python has attached functions, known as *methods*, that
    have access to the object’s internal contents. You can call them using the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions can take both *positional* and *keyword* arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We will look at this in more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: Variables and argument passing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When assigning a variable (or *name*) in Python, you are creating a *reference*
    to the object shown on the righthand side of the equals sign. In practical terms,
    consider a list of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we assign `a` to a new variable `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In some languages, the assignment if `b` will cause the data `[1, 2, 3]` to
    be copied. In Python, `a` and `b` actually now refer to the same object, the original
    list `[1, 2, 3]` (see [Figure 2.5](#fig-figure_references) for a mock-up). You
    can prove this to yourself by appending an element to `a` and then examining `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/844beecf4a6f3e1c98bd50a928a5d379.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Two references for the same object'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the semantics of references in Python, and when, how, and why
    data is copied, is especially critical when you are working with larger datasets
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note* *Assignment is also referred to as *binding*, as we are binding a name
    to an object. Variable names that have been assigned may occasionally be referred
    to as bound variables.*  *When you pass objects as arguments to a function, new
    local variables are created referencing the original objects without any copying.
    If you bind a new object to a variable inside a function, that will not overwrite
    a variable of the same name in the "scope" outside of the function (the "parent
    scope"). It is therefore possible to alter the internals of a mutable argument.
    Suppose we had the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]*  *#### Dynamic references, strong types'
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables in Python have no inherent type associated with them; a variable
    can refer to a different type of object simply by doing an assignment. There is
    no problem with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Variables are names for objects within a particular namespace; the type information
    is stored in the object itself. Some observers might hastily conclude that Python
    is not a “typed language.” This is not true; consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In some languages, the string `''5''` might get implicitly converted (or *cast*)
    to an integer, thus yielding 10\. In other languages the integer `5` might be
    cast to a string, yielding the concatenated string `''55''`. In Python, such implicit
    casts are not allowed. In this regard we say that Python is a *strongly typed*
    language, which means that every object has a specific type (or *class*), and
    implicit conversions will occur only in certain permitted circumstances, such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, even though `b` is an integer, it is implicitly converted to a float for
    the division operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing the type of an object is important, and it’s useful to be able to write
    functions that can handle many different kinds of input. You can check that an
    object is an instance of a particular type using the `isinstance` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`isinstance` can accept a tuple of types if you want to check that an object’s
    type is among those present in the tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Attributes and methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Objects in Python typically have both attributes (other Python objects stored
    “inside” the object) and methods (functions associated with an object that can
    have access to the object’s internal data). Both of them are accessed via the
    syntax <obj.attribute_name>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Attributes and methods can also be accessed by name via the `getattr` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: While we will not extensively use the functions `getattr` and related functions
    `hasattr` and `setattr` in this book, they can be used very effectively to write
    generic, reusable code.
  prefs: []
  type: TYPE_NORMAL
- en: Duck typing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Often you may not care about the type of an object but rather only whether
    it has certain methods or behavior. This is sometimes called *duck typing*, after
    the saying "If it walks like a duck and quacks like a duck, then it''s a duck."
    For example, you can verify that an object is iterable if it implements the *iterator
    protocol*. For many objects, this means it has an `__iter__` “magic method,” though
    an alternative and better way to check is to try using the `iter` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This function would return `True` for strings as well as most Python collection
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Imports
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In Python, a *module* is simply a file with the *.py* extension containing
    Python code. Suppose we had the following module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to access the variables and functions defined in *some_module.py*,
    from another file in the same directory we could do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Or alternately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the `as` keyword, you can give imports different variable names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Binary operators and comparisons
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Most of the binary math operations and comparisons use familiar mathematical
    syntax used in other programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: See [Table 2.1](#tbl-table_binary_ops) for all of the available binary operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2.1: Binary operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `a + b` | Add `a` and `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `a - b` | Subtract `b` from `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a * b` | Multiply `a` by `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `a / b` | Divide `a` by `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `a // b` | Floor-divide `a` by `b`, dropping any fractional remainder |'
  prefs: []
  type: TYPE_TB
- en: '| `a ** b` | Raise `a` to the `b` power |'
  prefs: []
  type: TYPE_TB
- en: '| `a & b` | `True` if both `a` and `b` are `True`; for integers, take the bitwise
    `AND` |'
  prefs: []
  type: TYPE_TB
- en: '| `a &#124; b` | `True` if either `a` or `b` is `True`; for integers, take
    the bitwise `OR` |'
  prefs: []
  type: TYPE_TB
- en: '| `a ^ b` | For Booleans, `True` if `a` or `b` is `True`, but not both; for
    integers, take the bitwise `EXCLUSIVE-OR` |'
  prefs: []
  type: TYPE_TB
- en: '| `a == b` | `True` if `a` equals `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `a != b` | `True` if `a` is not equal to `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `a < b`, a <= b | `True` if `a` is less than (less than or equal to) `b`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a > b, a >= b` | `True` if `a` is greater than (greater than or equal to)
    `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `a is b` | `True` if `a` and `b` reference the same Python object |'
  prefs: []
  type: TYPE_TB
- en: '| `a is not b` | `True` if `a` and `b` reference different Python objects |'
  prefs: []
  type: TYPE_TB
- en: 'To check if two variables refer to the same object, use the `is` keyword. Use
    `is` `not` to check that two objects are not the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `list` function always creates a new Python list (i.e., a copy),
    we can be sure that `c` is distinct from `a`. Comparing with `is` is not the same
    as the `==` operator, because in this case we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'A common use of `is` and `is` `not` is to check if a variable is `None`, since
    there is only one instance of `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Mutable and immutable objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Many objects in Python, such as lists, dictionaries, NumPy arrays, and most
    user-defined types (classes), are *mutable*. This means that the object or values
    that they contain can be modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Others, like strings and tuples, are immutable, which means their internal
    data cannot be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Remember that just because you *can* mutate an object does not mean that you
    always *should*. Such actions are known as *side effects*. For example, when writing
    a function, any side effects should be explicitly communicated to the user in
    the function’s documentation or comments. If possible, I recommend trying to avoid
    side effects and *favor immutability*, even though there may be mutable objects
    involved.**  **### Scalar Types
  prefs: []
  type: TYPE_NORMAL
- en: Python has a small set of built-in types for handling numerical data, strings,
    Boolean (`True` or `False`) values, and dates and time. These "single value" types
    are sometimes called *scalar types*, and we refer to them in this book as *scalars*
    . See [Table 2.2](#tbl-table_python_scalar_types) for a list of the main scalar
    types. Date and time handling will be discussed separately, as these are provided
    by the `datetime` module in the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2.2: Standard Python scalar types'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `None` | The Python “null” value (only one instance of the `None` object
    exists) |'
  prefs: []
  type: TYPE_TB
- en: '| `str` | String type; holds Unicode strings |'
  prefs: []
  type: TYPE_TB
- en: '| `bytes` | Raw binary data |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | Double-precision floating-point number (note there is no separate
    `double` type) |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | A Boolean `True` or `False` value |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | Arbitrary precision integer |'
  prefs: []
  type: TYPE_TB
- en: Numeric types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The primary Python types for numbers are `int` and `float`. An `int` can store
    arbitrarily large numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Floating-point numbers are represented with the Python `float` type. Under
    the hood, each one is a double-precision value. They can also be expressed with
    scientific notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Integer division not resulting in a whole number will always yield a floating-point
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To get C-style integer division (which drops the fractional part if the result
    is not a whole number), use the floor division operator `//`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Many people use Python for its built-in string handling capabilities. You can
    write *string literals* using either single quotes `''` or double quotes `"` (double
    quotes are generally favored):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The Python string type is `str`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For multiline strings with line breaks, you can use triple quotes, either `''''''`
    or `"""`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'It may surprise you that this string `c` actually contains four lines of text;
    the line breaks after `"""` and after `lines` are included in the string. We can
    count the new line characters with the `count` method on `c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Python strings are immutable; you cannot modify a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To interpret this error message, read from the bottom up. We tried to replace
    the character (the "item") at position 10 with the letter `"f"`, but this is not
    allowed for string objects. If we need to modify a string, we have to use a function
    or method that creates a new string, such as the string `replace` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Afer this operation, the variable `a` is unmodified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Many Python objects can be converted to a string using the `str` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings are a sequence of Unicode characters and therefore can be treated like
    other sequences, such as lists and tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The syntax `s[:3]` is called *slicing* and is implemented for many kinds of
    Python sequences. This will be explained in more detail later on, as it is used
    extensively in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The backslash character `\` is an *escape character*, meaning that it is used
    to specify special characters like newline `\n` or Unicode characters. To write
    a string literal with backslashes, you need to escape them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a string with a lot of backslashes and no special characters, you
    might find this a bit annoying. Fortunately you can preface the leading quote
    of the string with `r`, which means that the characters should be interpreted
    as is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `r` stands for *raw*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding two strings together concatenates them and produces a new string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'String templating or formatting is another important topic. The number of ways
    to do so has expanded with the advent of Python 3, and here I will briefly describe
    the mechanics of one of the main interfaces. String objects have a `format` method
    that can be used to substitute formatted arguments into the string, producing
    a new string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In this string:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{0:.2f}` means to format the first argument as a floating-point number with
    two decimal places.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{1:s}` means to format the second argument as a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{2:d}` means to format the third argument as an exact integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To substitute arguments for these format parameters, we pass a sequence of
    arguments to the `format` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Python 3.6 introduced a new feature called *f-strings* (short for *formatted
    string literals*) which can make creating formatted strings even more convenient.
    To create an f-string, write the character `f` immediately preceding a string
    literal. Within the string, enclose Python expressions in curly braces to substitute
    the value of the expression into the formatted string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Format specifiers can be added after each expression using the same syntax
    as with the string templates above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: String formatting is a deep topic; there are multiple methods and numerous options
    and tweaks available to control how values are formatted in the resulting string.
    To learn more, consult the [official Python documentation](https://docs.python.org/3/library/string.html).
  prefs: []
  type: TYPE_NORMAL
- en: Bytes and Unicode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In modern Python (i.e., Python 3.0 and up), Unicode has become the first-class
    string type to enable more consistent handling of ASCII and non-ASCII text. In
    older versions of Python, strings were all bytes without any explicit Unicode
    encoding. You could convert to Unicode assuming you knew the character encoding.
    Here is an example Unicode string with non-ASCII characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We can convert this Unicode string to its UTF-8 bytes representation using
    the `encode` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming you know the Unicode encoding of a `bytes` object, you can go back
    using the `decode` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'While it is now preferable to use UTF-8 for any encoding, for historical reasons
    you may encounter data in any number of different encodings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: It is most common to encounter `bytes` objects in the context of working with
    files, where implicitly decoding all data to Unicode strings may not be desired.
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The two Boolean values in Python are written as `True` and `False`. Comparisons
    and other conditional expressions evaluate to either `True` or `False`. Boolean
    values are combined with the `and` and `or` keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'When converted to numbers, `False` becomes `0` and `True` becomes `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The keyword `not` flips a Boolean value from `True` to `False` or vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Type casting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `str`, `bool`, `int`, and `float` types are also functions that can be
    used to cast values to those types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Note that most nonzero values when cast to `bool` become `True`.
  prefs: []
  type: TYPE_NORMAL
- en: None
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`None` is the Python null value type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '`None` is also a common default value for function arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Dates and times
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The built-in Python `datetime` module provides `datetime`, `date`, and `time`
    types. The `datetime` type combines the information stored in `date` and `time`
    and is the most commonly used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Given a `datetime` instance, you can extract the equivalent `date` and `time`
    objects by calling methods on the `datetime` of the same name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The `strftime` method formats a `datetime` as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings can be converted (parsed) into `datetime` objects with the `strptime`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: See [Table 11.2](/book/time-series#tbl-table_datetime_formatting) for a full
    list of format specifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are aggregating or otherwise grouping time series data, it will occasionally
    be useful to replace time fields of a series of `datetime`s—for example, replacing
    the `minute` and `second` fields with zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `datetime.datetime` is an immutable type, methods like these always produce
    new objects. So in the previous example, `dt` is not modified by `replace`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference of two `datetime` objects produces a `datetime.timedelta` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The output `timedelta(17, 7179)` indicates that the `timedelta` encodes an offset
    of 17 days and 7,179 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a `timedelta` to a `datetime` produces a new shifted `datetime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Control Flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python has several built-in keywords for conditional logic, loops, and other
    standard *control flow* concepts found in other programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: if, elif, and else
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `if` statement is one of the most well-known control flow statement types.
    It checks a condition that, if `True`, evaluates the code in the block that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'An `if` statement can be optionally followed by one or more `elif` blocks and
    a catchall `else` block if all of the conditions are `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'If any of the conditions are `True`, no further `elif` or `else` blocks will
    be reached. With a compound condition using `and` or `or`, conditions are evaluated
    left to right and will short-circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the comparison `c > d` never gets evaluated because the first
    comparison was `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to chain comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: for loops
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`for` loops are for iterating over a collection (like a list or tuple) or an
    iterater. The standard syntax for a `for` loop is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'You can advance a `for` loop to the next iteration, skipping the remainder
    of the block, using the `continue` keyword. Consider this code, which sums up
    integers in a list and skips `None` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'A `for` loop can be exited altogether with the `break` keyword. This code sums
    elements of the list until a 5 is reached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The `break` keyword only terminates the innermost `for` loop; any outer `for`
    loops will continue to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'As we will see in more detail, if the elements in the collection or iterator
    are sequences (tuples or lists, say), they can be conveniently *unpacked* into
    variables in the `for` loop statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: while loops
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A `while` loop specifies a condition and a block of code that is to be executed
    until the condition evaluates to `False` or the loop is explicitly ended with
    `break`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: pass
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`pass` is the “no-op” (or "do nothing") statement in Python. It can be used
    in blocks where no action is to be taken (or as a placeholder for code not yet
    implemented); it is required only because Python uses whitespace to delimit blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: range
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `range` function generates a sequence of evenly spaced integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'A start, end, and step (which may be negative) can be given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `range` produces integers up to but not including the endpoint.
    A common use of `range` is for iterating through sequences by index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'While you can use functions like `list` to store all the integers generated
    by `range` in some other data structure, often the default iterator form will
    be what you want. This snippet sums all numbers from 0 to 99,999 that are multiples
    of 3 or 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: While the range generated can be arbitrarily large, the memory use at any given
    time may be very small.**  **## 2.4 Conclusion
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provided a brief introduction to some basic Python language concepts
    and the IPython and Jupyter programming environments. In the next chapter, I will
    discuss many built-in data types, functions, and input-output utilities that will
    be used continuously throughout the rest of the book.******
  prefs: []
  type: TYPE_NORMAL
