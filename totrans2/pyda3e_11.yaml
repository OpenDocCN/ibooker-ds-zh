- en: '8  Data Wrangling: Join, Combine, and Reshape'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://wesmckinney.com/book/data-wrangling](https://wesmckinney.com/book/data-wrangling)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This Open Access web version of *Python for Data Analysis 3rd Edition* is
    now available as a companion to the [print and digital editions](https://amzn.to/3DyLaJc).
    If you encounter any errata, [please report them here](https://oreilly.com/catalog/0636920519829/errata).
    Please note that some aspects of this site as produced by Quarto will differ from
    the formatting of the print and eBook versions from O’Reilly.'
  prefs: []
  type: TYPE_NORMAL
- en: If you find the online edition of the book useful, please consider [ordering
    a paper copy](https://amzn.to/3DyLaJc) or a [DRM-free eBook](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)
    to support the author. The content from this website may not be copied or reproduced.
    The code examples are MIT licensed and can be found on GitHub or Gitee.*  *In
    many applications, data may be spread across a number of files or databases, or
    be arranged in a form that is not convenient to analyze. This chapter focuses
    on tools to help combine, join, and rearrange data.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, I introduce the concept of *hierarchical indexing* in pandas, which
    is used extensively in some of these operations. I then dig into the particular
    data manipulations. You can see various applied usages of these tools in [Ch 13:
    Data Analysis Examples](#data-analysis-examples).'
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 Hierarchical Indexing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Hierarchical indexing* is an important feature of pandas that enables you
    to have multiple (two or more) index *levels* on an axis. Another way of thinking
    about it is that it provides a way for you to work with higher dimensional data
    in a lower dimensional form. Let’s start with a simple example: create a Series
    with a list of lists (or arrays) as the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'What you’re seeing is a prettified view of a Series with a `MultiIndex` as
    its index. The “gaps” in the index display mean “use the label directly above”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With a hierarchically indexed object, so-called *partial* indexing is possible,
    enabling you to concisely select subsets of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Selection is even possible from an “inner” level. Here I select all of the
    values having the value `2` from the second index level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Hierarchical indexing plays an important role in reshaping data and in group-based
    operations like forming a pivot table. For example, you can rearrange this data
    into a DataFrame using its `unstack` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The inverse operation of `unstack` is `stack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`stack` and `unstack` will be explored in more detail later in [Reshaping and
    Pivoting](#prep_reshape).'
  prefs: []
  type: TYPE_NORMAL
- en: 'With a DataFrame, either axis can have a hierarchical index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The hierarchical levels can have names (as strings or any Python objects).
    If so, these will show up in the console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: These names supersede the `name` attribute, which is used only with single-level
    indexes.
  prefs: []
  type: TYPE_NORMAL
- en: '*Caution* *Be careful to note that the index names `"state"` and `"color"`
    are not part of the row labels (the `frame.index` values).*  *You can see how
    many levels an index has by accessing its `nlevels` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With partial column indexing you can similarly select groups of columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A `MultiIndex` can be created by itself and then reused; the columns in the
    preceding DataFrame with level names could also be created like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Reordering and Sorting Levels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At times you may need to rearrange the order of the levels on an axis or sort
    the data by the values in one specific level. The `swaplevel` method takes two
    level numbers or names and returns a new object with the levels interchanged (but
    the data is otherwise unaltered):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`sort_index` by default sorts the data lexicographically using all the index
    levels, but you can choose to use only a single level or a subset of levels to
    sort by passing the `level` argument. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Note* *Data selection performance is much better on hierarchically indexed
    objects if the index is lexicographically sorted starting with the outermost level—that
    is, the result of calling `sort_index(level=0)` or `sort_index()`.*  *### Summary
    Statistics by Level'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many descriptive and summary statistics on DataFrame and Series have a `level`
    option in which you can specify the level you want to aggregate by on a particular
    axis. Consider the above DataFrame; we can aggregate by level on either the rows
    or columns, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We will discuss `groupby` in much more detail later in [Ch 10: Data Aggregation
    and Group Operations](/book/data-aggregation).'
  prefs: []
  type: TYPE_NORMAL
- en: Indexing with a DataFrame's columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s not unusual to want to use one or more columns from a DataFrame as the
    row index; alternatively, you may wish to move the row index into the DataFrame’s
    columns. Here’s an example DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'DataFrame’s `set_index` function will create a new DataFrame using one or more
    of its columns as the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the columns are removed from the DataFrame, though you can leave
    them in by passing `drop=False` to `set_index`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`reset_index`, on the other hand, does the opposite of `set_index`; the hierarchical
    index levels are moved into the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]**  **## 8.2 Combining and Merging Datasets'
  prefs: []
  type: TYPE_NORMAL
- en: 'Data contained in pandas objects can be combined in a number of ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pandas.merge`'
  prefs: []
  type: TYPE_NORMAL
- en: Connect rows in DataFrames based on one or more keys. This will be familiar
    to users of SQL or other relational databases, as it implements database *join*
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: '`pandas.concat`'
  prefs: []
  type: TYPE_NORMAL
- en: Concatenate or "stack" objects together along an axis.
  prefs: []
  type: TYPE_NORMAL
- en: '`combine_first`'
  prefs: []
  type: TYPE_NORMAL
- en: Splice together overlapping data to fill in missing values in one object with
    values from another.
  prefs: []
  type: TYPE_NORMAL
- en: I will address each of these and give a number of examples. They’ll be utilized
    in examples throughout the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Database-Style DataFrame Joins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Merge* or *join* operations combine datasets by linking rows using one or
    more *keys*. These operations are particularly important in relational databases
    (e.g., SQL-based). The `pandas.merge` function in pandas is the main entry point
    for using these algorithms on your data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here I am using pandas''s `Int64` extension type for nullable integers, discussed
    in [Ch 7.3: Extension Data Types](/book/data-cleaning#pandas-ext-types).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of a *many-to-one* join; the data in `df1` has multiple
    rows labeled `a` and `b`, whereas `df2` has only one row for each value in the
    `key` column. Calling `pandas.merge` with these objects, we obtain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that I didn’t specify which column to join on. If that information is
    not specified, `pandas.merge` uses the overlapping column names as the keys. It’s
    a good practice to specify explicitly, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In general, the order of column output in `pandas.merge` operations is unspecified.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the column names are different in each object, you can specify them separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You may notice that the `"c"` and `"d"` values and associated data are missing
    from the result. By default, `pandas.merge` does an `"inner"` join; the keys in
    the result are the intersection, or the common set found in both tables. Other
    possible options are `"left"`, `"right"`, and `"outer"`. The outer join takes
    the union of the keys, combining the effect of applying both left and right joins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In an outer join, rows from the left or right DataFrame objects that do not
    match on keys in the other DataFrame will appear with NA values in the other DataFrame's
    columns for the nonmatching rows.
  prefs: []
  type: TYPE_NORMAL
- en: See [Table 8.1](#tbl-table_merge_how_behavior) for a summary of the options
    for `how`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8.1: Different join types with the `how` argument'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Behavior |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `how="inner"` | Use only the key combinations observed in both tables |'
  prefs: []
  type: TYPE_TB
- en: '| `how="left"` | Use all key combinations found in the left table |'
  prefs: []
  type: TYPE_TB
- en: '| `how="right"` | Use all key combinations found in the right table |'
  prefs: []
  type: TYPE_TB
- en: '| `how="outer"` | Use all key combinations observed in both tables together
    |'
  prefs: []
  type: TYPE_TB
- en: '*Many-to-many* merges form the Cartesian product of the matching keys. Here’s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Since there were three `"b"` rows in the left DataFrame and two in the right
    one, there are six `"b"` rows in the result. The join method passed to the `how`
    keyword argument affects only the distinct key values appearing in the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To merge with multiple keys, pass a list of column names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To determine which key combinations will appear in the result depending on the
    choice of merge method, think of the multiple keys as forming an array of tuples
    to be used as a single join key.
  prefs: []
  type: TYPE_NORMAL
- en: '*Caution* *When you''re joining columns on columns, the indexes on the passed
    DataFrame objects are discarded. If you need to preserve the index values, you
    can use `reset_index` to append the index to the columns.*  *A last issue to consider
    in merge operations is the treatment of overlapping column names. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'While you can address the overlap manually (see the section [Ch 7.2.4: Renaming
    Axis Indexes](/book/data-cleaning#prep_renaming) for renaming axis labels), `pandas.merge`
    has a `suffixes` option for specifying strings to append to overlapping names
    in the left and right DataFrame objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: See [Table 8.2](#tbl-table_merge_function) for an argument reference on `pandas.merge`.
    The next section covers joining using the DataFrame's row index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8.2: `pandas.merge` function arguments'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `left` | DataFrame to be merged on the left side. |'
  prefs: []
  type: TYPE_TB
- en: '| `right` | DataFrame to be merged on the right side. |'
  prefs: []
  type: TYPE_TB
- en: '| `how` | Type of join to apply: one of `"inner"`, `"outer"`, `"left"`, or
    `"right"`; defaults to `"inner"`. |'
  prefs: []
  type: TYPE_TB
- en: '| `on` | Column names to join on. Must be found in both DataFrame objects.
    If not specified and no other join keys given, will use the intersection of the
    column names in `left` and `right` as the join keys. |'
  prefs: []
  type: TYPE_TB
- en: '| `left_on` | Columns in `left` DataFrame to use as join keys. Can be a single
    column name or a list of column names. |'
  prefs: []
  type: TYPE_TB
- en: '| `right_on` | Analogous to `left_on` for `right` DataFrame. |'
  prefs: []
  type: TYPE_TB
- en: '| `left_index` | Use row index in `left` as its join key (or keys, if a `MultiIndex`).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `right_index` | Analogous to `left_index`. |'
  prefs: []
  type: TYPE_TB
- en: '| `sort` | Sort merged data lexicographically by join keys; `False` by default.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `suffixes` | Tuple of string values to append to column names in case of
    overlap; defaults to `("_x", "_y")` (e.g., if `"data"` in both DataFrame objects,
    would appear as `"data_x"` and `"data_y"` in result). |'
  prefs: []
  type: TYPE_TB
- en: '| `copy` | If `False`, avoid copying data into resulting data structure in
    some exceptional cases; by default always copies. |'
  prefs: []
  type: TYPE_TB
- en: '| `validate` | Verifies if the merge is of the specified type, whether one-to-one,
    one-to-many, or many-to-many. See the docstring for full details on the options.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `indicator` | Adds a special column `_merge` that indicates the source of
    each row; values will be `"left_only"`, `"right_only"`, or `"both"` based on the
    origin of the joined data in each row. |*  *### Merging on Index'
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, the merge key(s) in a DataFrame will be found in its index (row
    labels). In this case, you can pass `left_index=True` or `right_index=True` (or
    both) to indicate that the index should be used as the merge key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Note* *If you look carefully here, you will see that the index values for
    `left1` have been preserved, whereas in other examples above, the indexes of the
    input DataFrame objects are dropped. Because the index of `right1` is unique,
    this "many-to-one" merge (with the default `how="inner"` method) can preserve
    the index values from `left1` that correspond to rows in the output.*  *Since
    the default merge method is to intersect the join keys, you can instead form the
    union of them with an outer join:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With hierarchically indexed data, things are more complicated, as joining on
    index is equivalent to a multiple-key merge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, you have to indicate multiple columns to merge on as a list (note
    the handling of duplicate index values with `how="outer"`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the indexes of both sides of the merge is also possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'DataFrame has a `join` instance method to simplify merging by index. It can
    also be used to combine many DataFrame objects having the same or similar indexes
    but nonoverlapping columns. In the prior example, we could have written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Compared with `pandas.merge`, DataFrame’s `join` method performs a left join
    on the join keys by default. It also supports joining the index of the passed
    DataFrame on one of the columns of the calling DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can think of this method as joining data "into" the object whose `join`
    method was called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, for simple index-on-index merges, you can pass a list of DataFrames
    to `join` as an alternative to using the more general `pandas.concat` function
    described in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]*  *### Concatenating Along an Axis'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another kind of data combination operation is referred to interchangeably as
    *concatenation* or *stacking*. NumPy''s `concatenate` function can do this with
    NumPy arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the context of pandas objects such as Series and DataFrame, having labeled
    axes enable you to further generalize array concatenation. In particular, you
    have a number of additional concerns:'
  prefs: []
  type: TYPE_NORMAL
- en: If the objects are indexed differently on the other axes, should we combine
    the distinct elements in these axes or use only the values in common?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do the concatenated chunks of data need to be identifiable as such in the resulting
    object?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the "concatenation axis" contain data that needs to be preserved? In many
    cases, the default integer labels in a DataFrame are best discarded during concatenation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `concat` function in pandas provides a consistent way to address each of
    these questions. I’ll give a number of examples to illustrate how it works. Suppose
    we have three Series with no index overlap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `pandas.concat` with these objects in a list glues together the values
    and indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `pandas.concat` works along `axis="index"`, producing another Series.
    If you pass `axis="columns"`, the result will instead be a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case there is no overlap on the other axis, which as you can see is
    the union (the `"outer"` join) of the indexes. You can instead intersect them
    by passing `join="inner"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this last example, the `"f"` and `"g"` labels disappeared because of the
    `join="inner"` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'A potential issue is that the concatenated pieces are not identifiable in the
    result. Suppose instead you wanted to create a hierarchical index on the concatenation
    axis. To do this, use the `keys` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of combining Series along `axis="columns"`, the `keys` become the
    DataFrame column headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The same logic extends to DataFrame objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here the `keys` argument is used to create a hierarchical index where the first
    level can be used to identify each of the concatenated DataFrame objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you pass a dictionary of objects instead of a list, the dictionary’s keys
    will be used for the `keys` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'There are additional arguments governing how the hierarchical index is created
    (see [Table 8.3](#tbl-table_concat_function)). For example, we can name the created
    axis levels with the `names` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'A last consideration concerns DataFrames in which the row index does not contain
    any relevant data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, you can pass `ignore_index=True`, which discards the indexes
    from each DataFrame and concatenates the data in the columns only, assigning a
    new default index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 8.3](#tbl-table_concat_function) describes the `pandas.concat` function
    arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8.3: `pandas.concat` function arguments'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `objs` | List or dictionary of pandas objects to be concatenated; this is
    the only required argument |'
  prefs: []
  type: TYPE_TB
- en: '| `axis` | Axis to concatenate along; defaults to concatenating along rows
    (`axis="index"`) |'
  prefs: []
  type: TYPE_TB
- en: '| `join` | Either `"inner"` or `"outer"` (`"outer"` by default); whether to
    intersect (inner) or union (outer) indexes along the other axes |'
  prefs: []
  type: TYPE_TB
- en: '| `keys` | Values to associate with objects being concatenated, forming a hierarchical
    index along the concatenation axis; can be a list or array of arbitrary values,
    an array of tuples, or a list of arrays (if multiple-level arrays passed in `levels`)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `levels` | Specific indexes to use as hierarchical index level or levels
    if keys passed |'
  prefs: []
  type: TYPE_TB
- en: '| `names` | Names for created hierarchical levels if `keys` and/or `levels`
    passed |'
  prefs: []
  type: TYPE_TB
- en: '| `verify_integrity` | Check new axis in concatenated object for duplicates
    and raise an exception if so; by default (`False`) allows duplicates |'
  prefs: []
  type: TYPE_TB
- en: '| `ignore_index` | Do not preserve indexes along concatenation `axis`, instead
    produce a new `range(total_length)` index |'
  prefs: []
  type: TYPE_TB
- en: Combining Data with Overlap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is another data combination situation that can’t be expressed as either
    a merge or concatenation operation. You may have two datasets with indexes that
    overlap in full or in part. As a motivating example, consider NumPy’s `where`
    function, which performs the array-oriented equivalent of an if-else expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, whenever values in `a` are null, values from `b` are selected, otherwise
    the non-null values from `a` are selected. Using `numpy.where` does not check
    whether the index labels are aligned or not (and does not even require the objects
    to be the same length), so if you want to line up values by index, use the Series
    `combine_first` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'With DataFrames, `combine_first` does the same thing column by column, so you
    can think of it as “patching” missing data in the calling object with data from
    the object you pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The output of `combine_first` with DataFrame objects will have the union of
    all the column names.**  **## 8.3 Reshaping and Pivoting
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of basic operations for rearranging tabular data. These are
    referred to as *reshape* or *pivot* operations.
  prefs: []
  type: TYPE_NORMAL
- en: Reshaping with Hierarchical Indexing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Hierarchical indexing provides a consistent way to rearrange data in a DataFrame.
    There are two primary actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`stack`'
  prefs: []
  type: TYPE_NORMAL
- en: This “rotates” or pivots from the columns in the data to the rows.
  prefs: []
  type: TYPE_NORMAL
- en: '`unstack`'
  prefs: []
  type: TYPE_NORMAL
- en: This pivots from the rows into the columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll illustrate these operations through a series of examples. Consider a small
    DataFrame with string arrays as row and column indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `stack` method on this data pivots the columns into the rows, producing
    a Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'From a hierarchically indexed Series, you can rearrange the data back into
    a DataFrame with `unstack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the innermost level is unstacked (same with `stack`). You can unstack
    a different level by passing a level number or name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Unstacking might introduce missing data if all of the values in the level aren’t
    found in each subgroup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Stacking filters out missing data by default, so the operation is more easily
    invertible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'When you unstack in a DataFrame, the level unstacked becomes the lowest level
    in the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `unstack`, when calling `stack` we can indicate the name of the axis
    to stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Pivoting “Long” to “Wide” Format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common way to store multiple time series in databases and CSV files is what
    is sometimes called *long* or *stacked* format. In this format, individual values
    are represented by a single row in a table rather than multiple values per row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s load some example data and do a small amount of time series wrangling
    and other data cleaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'First, I use `pandas.PeriodIndex` (which represents time intervals rather than
    points in time), discussed in more detail in [Ch 11: Time Series](/book/time-series),
    to combine the `year` and `quarter` columns to set the index to consist of `datetime`
    values at the end of each quarter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here I used the `pop` method on the DataFrame, which returns a column while
    deleting it from the DataFrame at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, I select a subset of columns and give the `columns` index the name `"item"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, I reshape with `stack`, turn the new index levels into columns with
    `reset_index`, and finally give the column containing the data values the name
    `"value"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `ldata` looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In this so-called *long* format for multiple time series, each row in the table
    represents a single observation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data is frequently stored this way in relational SQL databases, as a fixed
    schema (column names and data types) allows the number of distinct values in the
    `item` column to change as data is added to the table. In the previous example,
    `date` and `item` would usually be the primary keys (in relational database parlance),
    offering both relational integrity and easier joins. In some cases, the data may
    be more difficult to work with in this format; you might prefer to have a DataFrame
    containing one column per distinct `item` value indexed by timestamps in the `date`
    column. DataFrame’s `pivot` method performs exactly this transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two values passed are the columns to be used, respectively, as the
    row and column index, then finally an optional value column to fill the DataFrame.
    Suppose you had two value columns that you wanted to reshape simultaneously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'By omitting the last argument, you obtain a DataFrame with hierarchical columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `pivot` is equivalent to creating a hierarchical index using `set_index`
    followed by a call to `unstack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Pivoting “Wide” to “Long” Format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An inverse operation to `pivot` for DataFrames is `pandas.melt`. Rather than
    transforming one column into many in a new DataFrame, it merges multiple columns
    into one, producing a DataFrame that is longer than the input. Let''s look at
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The `"key"` column may be a group indicator, and the other columns are data
    values. When using `pandas.melt`, we must indicate which columns (if any) are
    group indicators. Let''s use `"key"` as the only group indicator here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `pivot`, we can reshape back to the original layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the result of `pivot` creates an index from the column used as the row
    labels, we may want to use `reset_index` to move the data back into a column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify a subset of columns to use as `value` columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '`pandas.melt` can be used without any group identifiers, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 8.4 Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have some pandas basics for data import, cleaning, and reorganization
    under your belt, we are ready to move on to data visualization with matplotlib.
    We will return to explore other areas of pandas later in the book when we discuss
    more advanced analytics.*****
  prefs: []
  type: TYPE_NORMAL
