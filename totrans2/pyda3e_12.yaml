- en: 9  Plotting and Visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://wesmckinney.com/book/plotting-and-visualization](https://wesmckinney.com/book/plotting-and-visualization)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This Open Access web version of *Python for Data Analysis 3rd Edition* is
    now available as a companion to the [print and digital editions](https://amzn.to/3DyLaJc).
    If you encounter any errata, [please report them here](https://oreilly.com/catalog/0636920519829/errata).
    Please note that some aspects of this site as produced by Quarto will differ from
    the formatting of the print and eBook versions from O’Reilly.'
  prefs: []
  type: TYPE_NORMAL
- en: If you find the online edition of the book useful, please consider [ordering
    a paper copy](https://amzn.to/3DyLaJc) or a [DRM-free eBook](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)
    to support the author. The content from this website may not be copied or reproduced.
    The code examples are MIT licensed and can be found on GitHub or Gitee.*  *Making
    informative visualizations (sometimes called *plots*) is one of the most important
    tasks in data analysis. It may be a part of the exploratory process—for example,
    to help identify outliers or needed data transformations, or as a way of generating
    ideas for models. For others, building an interactive visualization for the web
    may be the end goal. Python has many add-on libraries for making static or dynamic
    visualizations, but I’ll be mainly focused on [matplotlib](https://matplotlib.org)
    and libraries that build on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: matplotlib is a desktop plotting package designed for creating plots and figures
    suitable for publication. The project was started by John Hunter in 2002 to enable
    a MATLAB-like plotting interface in Python. The matplotlib and IPython communities
    have collaborated to simplify interactive plotting from the IPython shell (and
    now, Jupyter notebook). matplotlib supports various GUI backends on all operating
    systems and can export visualizations to all of the common vector and raster graphics
    formats (PDF, SVG, JPG, PNG, BMP, GIF, etc.). With the exception of a few diagrams,
    nearly all of the graphics in this book were produced using matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, matplotlib has spawned a number of add-on toolkits for data visualization
    that use matplotlib for their underlying plotting. One of these is [seaborn](http://seaborn.pydata.org),
    which we explore later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to follow the code examples in the chapter is to output plots
    in the Jupyter notebook. To set this up, execute the following statement in a
    Jupyter notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Note* *Since this book''s first edition in 2012, many new data visualization
    libraries have been created, some of which (like Bokeh and Altair) take advantage
    of modern web technology to create interactive visualizations that integrate well
    with the Jupyter notebook. Rather than use multiple visualization tools in this
    book, I decided to stick with matplotlib for teaching the fundamentals, in particular
    since pandas has good integration with matplotlib. You can adapt the principles
    from this chapter to learn how to use other visualization libraries as well.*  *##
    9.1 A Brief matplotlib API Primer'
  prefs: []
  type: TYPE_NORMAL
- en: 'With matplotlib, we use the following import convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After running `%matplotlib notebook` in Jupyter (or simply `%matplotlib` in
    IPython), we can try creating a simple plot. If everything is set up right, a
    line plot like [Simple line plot](#mpl_first_plot) should appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/33f467ae0ee1820d490756dfcb2a77fb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Simple line plot'
  prefs: []
  type: TYPE_NORMAL
- en: While libraries like seaborn and pandas's built-in plotting functions will deal
    with many of the mundane details of making plots, should you wish to customize
    them beyond the function options provided, you will need to learn a bit about
    the matplotlib API.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note* *There is not enough room in the book to give comprehensive treatment
    of the breadth and depth of functionality in matplotlib. It should be enough to
    teach you the ropes to get up and running. The matplotlib gallery and documentation
    are the best resource for learning advanced features.*  *### Figures and Subplots'
  prefs: []
  type: TYPE_NORMAL
- en: 'Plots in matplotlib reside within a `Figure` object. You can create a new figure
    with `plt.figure`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In IPython, if you first run `%matplotlib` to set up the matplotlib integration,
    an empty plot window will appear, but in Jupyter nothing will be shown until we
    use a few more commands.
  prefs: []
  type: TYPE_NORMAL
- en: '`plt.figure` has a number of options; notably, `figsize` will guarantee the
    figure has a certain size and aspect ratio if saved to disk.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can’t make a plot with a blank figure. You have to create one or more `subplots`
    using `add_subplot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the figure should be 2 × 2 (so up to four plots in total),
    and we’re selecting the first of four subplots (numbered from 1). If you create
    the next two subplots, you’ll end up with a visualization that looks like [An
    empty matplotlib figure with three subplots](#mpl_empty_subplots):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/3ffe09420f821e4d9cb950f2e5bb6e84.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: An empty matplotlib figure with three subplots'
  prefs: []
  type: TYPE_NORMAL
- en: '*Tip* *One nuance of using Jupyter notebooks is that plots are reset after
    each cell is evaluated, so you must put all of the plotting commands in a single
    notebook cell.*  *Here we run all of these commands in the same cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'These plot axis objects have various methods that create different types of
    plots, and it is preferred to use the axis methods over the top-level plotting
    functions like `plt.plot`. For example, we could make a line plot with the `plot`
    method (see [Data visualization after a single plot](#mpl_subplots_one)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/e930d33b55aed88698b1dbfd5bd03cbf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Data visualization after a single plot'
  prefs: []
  type: TYPE_NORMAL
- en: You may notice output like `<matplotlib.lines.Line2D at ...>` when you run this.
    matplotlib returns objects that reference the plot subcomponent that was just
    added. A lot of the time you can safely ignore this output, or you can put a semicolon
    at the end of the line to suppress the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The additional options instruct matplotlib to plot a black dashed line. The
    objects returned by `fig.add_subplot` here are `AxesSubplot` objects, on which
    you can directly plot on the other empty subplots by calling each one’s instance
    method (see [Data visualization after additional plots](#mpl_subplots_two)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/c61e1e89fed6ca0718719066a3fad5d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Data visualization after additional plots'
  prefs: []
  type: TYPE_NORMAL
- en: The style option `alpha=0.3` sets the transparency of the overlaid plot.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a comprehensive catalog of plot types in the [matplotlib documentation](https://matplotlib.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'To make creating a grid of subplots more convenient, matplotlib includes a
    `plt.subplots` method that creates a new figure and returns a NumPy array containing
    the created subplot objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `axes` array can then be indexed like a two-dimensional array; for example,
    `axes[0, 1]` refers to the subplot in the top row at the center. You can also
    indicate that subplots should have the same x- or y-axis using `sharex` and `sharey`,
    respectively. This can be useful when you're comparing data on the same scale;
    otherwise, matplotlib autoscales plot limits independently. See [Table 9.1](#tbl-table_plt_subplots)
    for more on this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 9.1: `matplotlib.pyplot.subplots` options'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `nrows` | Number of rows of subplots |'
  prefs: []
  type: TYPE_TB
- en: '| `ncols` | Number of columns of subplots |'
  prefs: []
  type: TYPE_TB
- en: '| `sharex` | All subplots should use the same x-axis ticks (adjusting the `xlim`
    will affect all subplots) |'
  prefs: []
  type: TYPE_TB
- en: '| `sharey` | All subplots should use the same y-axis ticks (adjusting the `ylim`
    will affect all subplots) |'
  prefs: []
  type: TYPE_TB
- en: '| `subplot_kw` | Dictionary of keywords passed to `add_subplot` call used to
    create each subplot |'
  prefs: []
  type: TYPE_TB
- en: '| `**fig_kw` | Additional keywords to `subplots` are used when creating the
    figure, such as `plt.subplots(2, 2, figsize=(8, 6))` |'
  prefs: []
  type: TYPE_TB
- en: Adjusting the spacing around subplots
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'By default, matplotlib leaves a certain amount of padding around the outside
    of the subplots and in spacing between subplots. This spacing is all specified
    relative to the height and width of the plot, so that if you resize the plot either
    programmatically or manually using the GUI window, the plot will dynamically adjust
    itself. You can change the spacing using the `subplots_adjust` method on `Figure`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`wspace` and `hspace` control the percent of the figure width and figure height,
    respectively, to use as spacing between subplots. Here is a small example you
    can execute in Jupyter where I shrink the spacing all the way to zero (see [Data
    visualization with no inter-subplot spacing](#mpl_subplots_adjust)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/c29739a3af9d3f69ced8617625eb559c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: Data visualization with no inter-subplot spacing'
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that the axis labels overlap. matplotlib doesn’t check whether
    the labels overlap, so in a case like this you would need to fix the labels yourself
    by specifying explicit tick locations and tick labels (we'll look at how to do
    this in the later section [Ticks, Labels, and Legends](#vis_matplotlib_annotation)).*  *###
    Colors, Markers, and Line Styles
  prefs: []
  type: TYPE_NORMAL
- en: 'matplotlib’s line `plot` function accepts arrays of x and y coordinates and
    optional color styling options. For example, to plot `x` versus `y` with green
    dashes, you would execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A number of color names are provided for commonly used colors, but you can use
    any color on the spectrum by specifying its hex code (e.g., `"#CECECE"`). You
    can see some of the supported line styles by looking at the docstring for `plt.plot`
    (use `plt.plot?` in IPython or Jupyter). A more comprehensive reference is available
    in the online documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Line plots can additionally have *markers* to highlight the actual data points.
    Since matplotlib''s `plot` function creates a continuous line plot, interpolating
    between points, it can occasionally be unclear where the points lie. The marker
    can be supplied as an additional styling option (see [Line plot with markers](#mpl_marker_ex)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/057b871e61b23676a12ca85ac841d012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: Line plot with markers'
  prefs: []
  type: TYPE_NORMAL
- en: 'For line plots, you will notice that subsequent points are linearly interpolated
    by default. This can be altered with the `drawstyle` option (see [Line plot with
    different drawstyle options](#mpl_drawstyle_ex)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/3e63e6a6357b24a6c73084b155cbc27b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: Line plot with different drawstyle options'
  prefs: []
  type: TYPE_NORMAL
- en: Here, since we passed the `label` arguments to `plot`, we are able to create
    a plot legend to identify each line using `ax.legend`. I discuss legends more
    in [Ticks, Labels, and Legends](#vis_matplotlib_annotation).
  prefs: []
  type: TYPE_NORMAL
- en: '*Note* *You must call `ax.legend` to create the legend, whether or not you
    passed the `label` options when plotting the data.*  *### Ticks, Labels, and Legends'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most kinds of plot decorations can be accessed through methods on matplotlib
    axes objects. This includes methods like `xlim`, `xticks`, and `xticklabels`.
    These control the plot range, tick locations, and tick labels, respectively. They
    can be used in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Called with no arguments returns the current parameter value (e.g., `ax.xlim()`
    returns the current x-axis plotting range)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Called with parameters sets the parameter value (e.g., `ax.xlim([0, 10])` sets
    the x-axis range to 0 to 10)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All such methods act on the active or most recently created `AxesSubplot`. Each
    corresponds to two methods on the subplot object itself; in the case of `xlim`,
    these are `ax.get_xlim` and `ax.set_xlim`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the title, axis labels, ticks, and tick labels
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To illustrate customizing the axes, I’ll create a simple figure and plot of
    a random walk (see [Simple plot for illustrating xticks (with default labels)](#vis_ticks_one)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/5a99b09f27faef68b4b1150598d87c05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.8: Simple plot for illustrating xticks (with default labels)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the x-axis ticks, it’s easiest to use `set_xticks` and `set_xticklabels`.
    The former instructs matplotlib where to place the ticks along the data range;
    by default these locations will also be the labels. But we can set any other values
    as the labels using `set_xticklabels`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rotation` option sets the x tick labels at a 30-degree rotation. Lastly,
    `set_xlabel` gives a name to the x-axis, and `set_title` is the subplot title
    (see [Simple plot for illustrating custom xticks](#vis_ticks_two) for the resulting
    figure):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/8592bb9fc63f4f28333b53d403105a57.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.9: Simple plot for illustrating custom xticks'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modifying the y-axis consists of the same process, substituting `y` for `x`
    in this example. The axes class has a `set` method that allows batch setting of
    plot properties. From the prior example, we could also have written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Adding legends
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Legends are another critical element for identifying plot elements. There are
    a couple of ways to add one. The easiest is to pass the `label` argument when
    adding each piece of the plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve done this, you can call `ax.legend()` to automatically create a
    legend. The resulting plot is in [Simple plot with three lines and legend](#vis_legend_ex):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b305e27a26b0ff06c2d3130576a72f42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.10: Simple plot with three lines and legend'
  prefs: []
  type: TYPE_NORMAL
- en: The `legend` method has several other choices for the location `loc` argument.
    See the docstring (with `ax.legend?`) for more information.
  prefs: []
  type: TYPE_NORMAL
- en: The `loc` legend option tells matplotlib where to place the plot. The default
    is `"best"`, which tries to choose a location that is most out of the way. To
    exclude one or more elements from the legend, pass no label or `label="_nolegend_"`.
  prefs: []
  type: TYPE_NORMAL
- en: Annotations and Drawing on a Subplot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to the standard plot types, you may wish to draw your own plot
    annotations, which could consist of text, arrows, or other shapes. You can add
    annotations and text using the `text`, `arrow`, and `annotate` functions. `text`
    draws text at given coordinates `(x, y)` on the plot with optional custom styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Annotations can draw both text and arrows arranged appropriately. As an example,
    let’s plot the closing S&P 500 index price since 2007 (obtained from Yahoo! Finance)
    and annotate it with some of the important dates from the 2008–2009 financial
    crisis. You can run this code example in a single cell in a Jupyter notebook.
    See [Important dates in the 2008–2009 financial crisis](#vis_crisis_dates) for
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b8b372e58ab7916dbb3ef4c71569c5be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.11: Important dates in the 2008–2009 financial crisis'
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of important points to highlight in this plot. The `ax.annotate`
    method can draw labels at the indicated x and y coordinates. We use the `set_xlim`
    and `set_ylim` methods to manually set the start and end boundaries for the plot
    rather than using matplotlib's default. Lastly, `ax.set_title` adds a main title
    to the plot.
  prefs: []
  type: TYPE_NORMAL
- en: See the online matplotlib gallery for many more annotation examples to learn
    from.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing shapes requires some more care. matplotlib has objects that represent
    many common shapes, referred to as *patches*. Some of these, like `Rectangle`
    and `Circle`, are found in `matplotlib.pyplot`, but the full set is located in
    `matplotlib.patches`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a shape to a plot, you create the patch object and add it to a subplot
    `ax` by passing the patch to `ax.add_patch` (see [Data visualization composed
    from three different patches](#vis_patch_ex)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/bbe77ca56f949e70e20ccf23975bca48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.12: Data visualization composed from three different patches'
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the implementation of many familiar plot types, you will see
    that they are assembled from patches.
  prefs: []
  type: TYPE_NORMAL
- en: Saving Plots to File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can save the active figure to file using the figure object’s `savefig`
    instance method. For example, to save an SVG version of a figure, you need only
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The file type is inferred from the file extension. So if you used `.pdf` instead,
    you would get a PDF. One important option that I use frequently for publishing
    graphics is `dpi`, which controls the dots-per-inch resolution. To get the same
    plot as a PNG at 400 DPI, you would do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: See [Table 9.2](#tbl-table_mpl_savefig) for a list of some other options for
    `savefig`. For a comprehensive listing, refer to the docstring in IPython or Jupyter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 9.2: Some `fig.savefig` options'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `fname` | String containing a filepath or a Python file-like object. The
    figure format is inferred from the file extension (e.g., `.pdf` for PDF or `.png`
    for PNG). |'
  prefs: []
  type: TYPE_TB
- en: '| `dpi` | The figure resolution in dots per inch; defaults to 100 in IPython
    or 72 in Jupyter out of the box but can be configured. |'
  prefs: []
  type: TYPE_TB
- en: '| `facecolor, edgecolor` | The color of the figure background outside of the
    subplots; `"w"` (white), by default. |'
  prefs: []
  type: TYPE_TB
- en: '| `format` | The explicit file format to use (`"png"`, `"pdf"`, `"svg"`, `"ps"`,
    `"eps"`, ...). |'
  prefs: []
  type: TYPE_TB
- en: matplotlib Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'matplotlib comes configured with color schemes and defaults that are geared
    primarily toward preparing figures for publication. Fortunately, nearly all of
    the default behavior can be customized via global parameters governing figure
    size, subplot spacing, colors, font sizes, grid styles, and so on. One way to
    modify the configuration programmatically from Python is to use the `rc` method;
    for example, to set the global default figure size to be 10 × 10, you could enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: All of the current configuration settings are found in the `plt.rcParams` dictionary,
    and they can be restored to their default values by calling the `plt.rcdefaults()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first argument to `rc` is the component you wish to customize, such as
    `"figure"`, `"axes"`, `"xtick"`, `"ytick"`, `"grid"`, `"legend"`, or many others.
    After that can follow a sequence of keyword arguments indicating the new parameters.
    A convenient way to write down the options in your program is as a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For more extensive customization and to see a list of all the options, matplotlib
    comes with a configuration file *matplotlibrc* in the *matplotlib/mpl-data* directory.
    If you customize this file and place it in your home directory titled *.matplotlibrc*,
    it will be loaded each time you use matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: As we'll see in the next section, the seaborn package has several built-in plot
    themes or *styles* that use matplotlib's configuration system internally.***  ***##
    9.2 Plotting with pandas and seaborn
  prefs: []
  type: TYPE_NORMAL
- en: 'matplotlib can be a fairly low-level tool. You assemble a plot from its base
    components: the data display (i.e., the type of plot: line, bar, box, scatter,
    contour, etc.), legend, title, tick labels, and other annotations.'
  prefs: []
  type: TYPE_NORMAL
- en: In pandas, we may have multiple columns of data, along with row and column labels.
    pandas itself has built-in methods that simplify creating visualizations from
    DataFrame and Series objects. Another library is [`seaborn`](https://seaborn.pydata.org),
    a high-level statistical graphics library built on matplotlib. seaborn simplifies
    creating many common visualization types.
  prefs: []
  type: TYPE_NORMAL
- en: Line Plots
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Series and DataFrame have a `plot` attribute for making some basic plot types.
    By default, `plot()` makes line plots (see [Simple Series plot](#vis_series_plot_1)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/94759a9f5e61afbdf151f5410cb1d6ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.13: Simple Series plot'
  prefs: []
  type: TYPE_NORMAL
- en: The Series object’s index is passed to matplotlib for plotting on the x-axis,
    though you can disable this by passing `use_index=False`. The x-axis ticks and
    limits can be adjusted with the `xticks` and `xlim` options, and the y-axis respectively
    with `yticks` and `ylim`. See [Table 9.3](#tbl-table_plot_method) for a partial
    listing of `plot` options. I’ll comment on a few more of them throughout this
    section and leave the rest for you to explore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 9.3: `Series.plot` method arguments'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `label` | Label for plot legend |'
  prefs: []
  type: TYPE_TB
- en: '| `ax` | matplotlib subplot object to plot on; if nothing passed, uses active
    matplotlib subplot |'
  prefs: []
  type: TYPE_TB
- en: '| `style` | Style string, like `"ko--"`, to be passed to matplotlib |'
  prefs: []
  type: TYPE_TB
- en: '| `alpha` | The plot fill opacity (from 0 to 1) |'
  prefs: []
  type: TYPE_TB
- en: '| `kind` | Can be `"area"`, `"bar"`, `"barh"`, `"density"`, `"hist"`, `"kde"`,
    `"line"`, or `"pie"`; defaults to `"line"` |'
  prefs: []
  type: TYPE_TB
- en: '| `figsize` | Size of the figure object to create |'
  prefs: []
  type: TYPE_TB
- en: '| `logx` | Pass `True` for logarithmic scaling on the x axis; pass `"sym"`
    for symmetric logarithm that permits negative values |'
  prefs: []
  type: TYPE_TB
- en: '| `logy` | Pass `True` for logarithmic scaling on the y axis; pass `"sym"`
    for symmetric logarithm that permits negative values |'
  prefs: []
  type: TYPE_TB
- en: '| `title` | Title to use for the plot |'
  prefs: []
  type: TYPE_TB
- en: '| `use_index` | Use the object index for tick labels |'
  prefs: []
  type: TYPE_TB
- en: '| `rot` | Rotation of tick labels (0 through 360) |'
  prefs: []
  type: TYPE_TB
- en: '| `xticks` | Values to use for x-axis ticks |'
  prefs: []
  type: TYPE_TB
- en: '| `yticks` | Values to use for y-axis ticks |'
  prefs: []
  type: TYPE_TB
- en: '| `xlim` | x-axis limits (e.g., `[0, 10]`) |'
  prefs: []
  type: TYPE_TB
- en: '| `ylim` | y-axis limits |'
  prefs: []
  type: TYPE_TB
- en: '| `grid` | Display axis grid (off by default) |'
  prefs: []
  type: TYPE_TB
- en: Most of pandas’s plotting methods accept an optional `ax` parameter, which can
    be a matplotlib subplot object. This gives you more flexible placement of subplots
    in a grid layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'DataFrame’s `plot` method plots each of its columns as a different line on
    the same subplot, creating a legend automatically (see [Simple DataFrame plot](#vis_frame_plot_1)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/fdaeef8acbb8ceb4025d1c1bd91d31b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.14: Simple DataFrame plot'
  prefs: []
  type: TYPE_NORMAL
- en: '*Note* *Here I used `plt.style.use(''grayscale'')` to switch to a color scheme
    more suitable for black and white publication, since some readers will not be
    able to see the full color plots.*  *The `plot` attribute contains a "family"
    of methods for different plot types. For example, `df.plot()` is equivalent to
    `df.plot.line()`. We''ll explore some of these methods next.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Note* *Additional keyword arguments to `plot` are passed through to the respective
    matplotlib plotting function, so you can further customize these plots by learning
    more about the matplotlib API.*  *DataFrame has a number of options allowing some
    flexibility for how the columns are handled, for example, whether to plot them
    all on the same subplot or to create separate subplots. See [Table 9.4](#tbl-table_frame_plot_method)
    for more on these.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 9.4: DataFrame-specific plot arguments'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `subplots` | Plot each DataFrame column in a separate subplot |'
  prefs: []
  type: TYPE_TB
- en: '| `layouts` | 2-tuple (rows, columns) providing layout of subplots |'
  prefs: []
  type: TYPE_TB
- en: '| `sharex` | If `subplots=True`, share the same x-axis, linking ticks and limits
    |'
  prefs: []
  type: TYPE_TB
- en: '| `sharey` | If `subplots=True`, share the same y-axis |'
  prefs: []
  type: TYPE_TB
- en: '| `legend` | Add a subplot legend (`True` by default) |'
  prefs: []
  type: TYPE_TB
- en: '| `sort_columns` | Plot columns in alphabetical order; by default uses existing
    column order |'
  prefs: []
  type: TYPE_TB
- en: '*Note* *For time series plotting, see [Ch 11: Time Series](/book/time-series).***  ***###
    Bar Plots'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `plot.bar()` and `plot.barh()` make vertical and horizontal bar plots,
    respectively. In this case, the Series or DataFrame index will be used as the
    x (`bar`) or y (`barh`) ticks (see [Horizonal and vertical bar plot](#vis_bar_plot_ex)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/baca2f4ab210ab7fbb1363acd5366b42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.15: Horizonal and vertical bar plot'
  prefs: []
  type: TYPE_NORMAL
- en: 'With a DataFrame, bar plots group the values in each row in bars, side by side,
    for each value. See [DataFrame bar plot](#vis_frame_barplot):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/7b3fc44566d76e7e8e544437c2dffbcc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.16: DataFrame bar plot'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the name “Genus” on the DataFrame’s columns is used to title the legend.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create stacked bar plots from a DataFrame by passing `stacked=True`, resulting
    in the value in each row being stacked together horizontally (see [DataFrame stacked
    bar plot](#vis_frame_barplot_stacked)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/f28517ea0c78eaca45d3a1d21b743605.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.17: DataFrame stacked bar plot'
  prefs: []
  type: TYPE_NORMAL
- en: '*Note* *A useful recipe for bar plots is to visualize a Series’s value frequency
    using `value_counts`: `s.value_counts().plot.bar()`.*  *Let''s have a look at
    an example dataset about restaurant tipping. Suppose we wanted to make a stacked
    bar plot showing the percentage of data points for each party size for each day.
    I load the data using `read_csv` and make a cross-tabulation by day and party
    size. The `pandas.crosstab` function is a convenient way to compute a simple frequency
    table from two DataFrame columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Since there are not many one- and six-person parties, I remove them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, normalize so that each row sums to 1, and make the plot (see [Fraction
    of parties by size within each day](#vis_tips_barplot)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/fecc24f715268acabec45f889288da9c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.18: Fraction of parties by size within each day'
  prefs: []
  type: TYPE_NORMAL
- en: So you can see that party sizes appear to increase on the weekend in this dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'With data that requires aggregation or summarization before making a plot,
    using the `seaborn` package can make things much simpler (install it with `conda
    install seaborn`). Let''s look now at the tipping percentage by day with seaborn
    (see [Tipping percentage by day with error bars](#vis_tip_pct_seaborn) for the
    resulting plot):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/1c644fda5940269dac22103d8713dae4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.19: Tipping percentage by day with error bars'
  prefs: []
  type: TYPE_NORMAL
- en: Plotting functions in seaborn take a `data` argument, which can be a pandas
    DataFrame. The other arguments refer to column names. Because there are multiple
    observations for each value in the `day`, the bars are the average value of `tip_pct`.
    The black lines drawn on the bars represent the 95% confidence interval (this
    can be configured through optional arguments).
  prefs: []
  type: TYPE_NORMAL
- en: '`seaborn.barplot` has a `hue` option that enables us to split by an additional
    categorical value (see [Tipping percentage by day and time](#vis_tip_pct_sns_grouped)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/7921e3ccd70b031f36c44b85107918d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.20: Tipping percentage by day and time'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that seaborn has automatically changed the aesthetics of plots: the
    default color palette, plot background, and grid line colors. You can switch between
    different plot appearances using `seaborn.set_style`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When producing plots for black-and-white print medium, you may find it useful
    to set a greyscale color palette, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]*  *### Histograms and Density Plots'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *histogram* is a kind of bar plot that gives a discretized display of value
    frequency. The data points are split into discrete, evenly spaced bins, and the
    number of data points in each bin is plotted. Using the tipping data from before,
    we can make a histogram of tip percentages of the total bill using the `plot.hist`
    method on the Series (see [Histogram of tip percentages](#vis_hist_ex)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/ac1010ef5553eff57302677c1ac29851.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.21: Histogram of tip percentages'
  prefs: []
  type: TYPE_NORMAL
- en: 'A related plot type is a *density plot*, which is formed by computing an estimate
    of a continuous probability distribution that might have generated the observed
    data. The usual procedure is to approximate this distribution as a mixture of
    "kernels"—that is, simpler distributions like the normal distribution. Thus, density
    plots are also known as kernel density estimate (KDE) plots. Using `plot.density`
    makes a density plot using the conventional mixture-of-normals estimate (see [Density
    plot of tip percentages](#vis_kde_ex)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/53903a6f57aed96b5029b4bcb265ceb7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.22: Density plot of tip percentages'
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of plot requires SciPy, so if you do not have it installed already,
    you can pause and do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'seaborn makes histograms and density plots even easier through its `histplot`
    method, which can plot both a histogram and a continuous density estimate simultaneously.
    As an example, consider a bimodal distribution consisting of draws from two different
    standard normal distributions (see [Normalized histogram of normal mixture](#vis_series_kde)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/a4c5cd6fc9e8e06951e967c00791ae0c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.23: Normalized histogram of normal mixture'
  prefs: []
  type: TYPE_NORMAL
- en: Scatter or Point Plots
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Point plots or scatter plots can be a useful way of examining the relationship
    between two one-dimensional data series. For example, here we load the `macrodata`
    dataset from the statsmodels project, select a few variables, then compute log
    differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use seaborn''s `regplot` method, which makes a scatter plot and
    fits a linear regression line (see [A seaborn regression/scatter plot](#scatter_plot_ex)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/794c774025d4e8e044c70ae0199ae555.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.24: A seaborn regression/scatter plot'
  prefs: []
  type: TYPE_NORMAL
- en: 'In exploratory data analysis, it’s helpful to be able to look at all the scatter
    plots among a group of variables; this is known as a *pairs* plot or *scatter
    plot matrix*. Making such a plot from scratch is a bit of work, so seaborn has
    a convenient `pairplot` function that supports placing histograms or density estimates
    of each variable along the diagonal (see [Pair plot matrix of statsmodels macro
    data](#scatter_matrix_ex) for the resulting plot):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/dff02874e6216c043e03726ae580d604.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.25: Pair plot matrix of statsmodels macro data'
  prefs: []
  type: TYPE_NORMAL
- en: You may notice the `plot_kws` argument. This enables us to pass down configuration
    options to the individual plotting calls on the off-diagonal elements. Check out
    the `seaborn.pairplot` docstring for more granular configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: Facet Grids and Categorical Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What about datasets where we have additional grouping dimensions? One way to
    visualize data with many categorical variables is to use a *facet grid*, which
    is a two-dimensional layout of plots where the data is split across the plots
    on each axis based on the distinct values of a certain variable. seaborn has a
    useful built-in function `catplot` that simplifies making many kinds of faceted
    plots split by categorical variables (see [Tipping percentage by day/time/smoker](#vis_tip_pct_sns_factorplot)
    for the resulting plot):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/ebc8b1612dde160033c19bae91791567.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.26: Tipping percentage by day/time/smoker'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of grouping by `"time"` by different bar colors within a facet, we
    can also expand the facet grid by adding one row per `time` value (see [Tipping
    percentage by day split by time/smoker](#vis_tip_pct_sns_factorplot2)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/492765c1f52237f69c502e7807e289aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.27: Tipping percentage by day split by time/smoker'
  prefs: []
  type: TYPE_NORMAL
- en: '`catplot` supports other plot types that may be useful depending on what you
    are trying to display. For example, *box plots* (which show the median, quartiles,
    and outliers) can be an effective visualization type (see [Box plot of tipping
    percentage by day](#vis_tip_pct_sns_factor_box)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/1acd381f491d15f26798c13e930adffc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.28: Box plot of tipping percentage by day'
  prefs: []
  type: TYPE_NORMAL
- en: You can create your own facet grid plots using the more general `seaborn.FacetGrid`
    class. See the [seaborn documentation](https://seaborn.pydata.org/) for more.****  ***##
    9.3 Other Python Visualization Tools
  prefs: []
  type: TYPE_NORMAL
- en: As is common with open source, there many options for creating graphics in Python
    (too many to list). Since 2010, much development effort has been focused on creating
    interactive graphics for publication on the web. With tools like [Altair](https://altair-viz.github.io),
    [Bokeh](http://bokeh.pydata.org), and [Plotly](https://plotly.com/python), it's
    now possible to specify dynamic, interactive graphics in Python that are intended
    for use with web browsers.
  prefs: []
  type: TYPE_NORMAL
- en: For creating static graphics for print or web, I recommend using matplotlib
    and libraries that build on matplotlib, like pandas and seaborn, for your needs.
    For other data visualization requirements, it may be useful to learn how to use
    one of the other available tools. I encourage you to explore the ecosystem as
    it continues to evolve and innovate into the future.
  prefs: []
  type: TYPE_NORMAL
- en: An excellent book on data visualization is *Fundamentals of Data Visualization*
    by Claus O. Wilke (O'Reilly), which is available in print or on Claus's website
    at [https://clauswilke.com/dataviz](https://clauswilke.com/dataviz).
  prefs: []
  type: TYPE_NORMAL
- en: 9.4 Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal of this chapter was to get your feet wet with some basic data visualization
    using pandas, matplotlib, and seaborn. If visually communicating the results of
    data analysis is important in your work, I encourage you to seek out resources
    to learn more about effective data visualization. It is an active field of research,
    and you can practice with many excellent learning resources available online and
    in print.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we turn our attention to data aggregation and group operations
    with pandas.********
  prefs: []
  type: TYPE_NORMAL
