- en: 5  Getting Started with pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://wesmckinney.com/book/pandas-basics](https://wesmckinney.com/book/pandas-basics)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This Open Access web version of *Python for Data Analysis 3rd Edition* is
    now available as a companion to the [print and digital editions](https://amzn.to/3DyLaJc).
    If you encounter any errata, [please report them here](https://oreilly.com/catalog/0636920519829/errata).
    Please note that some aspects of this site as produced by Quarto will differ from
    the formatting of the print and eBook versions from O’Reilly.'
  prefs: []
  type: TYPE_NORMAL
- en: If you find the online edition of the book useful, please consider [ordering
    a paper copy](https://amzn.to/3DyLaJc) or a [DRM-free eBook](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)
    to support the author. The content from this website may not be copied or reproduced.
    The code examples are MIT licensed and can be found on GitHub or Gitee.*  *pandas
    will be a major tool of interest throughout much of the rest of the book. It contains
    data structures and data manipulation tools designed to make data cleaning and
    analysis fast and convenient in Python. pandas is often used in tandem with numerical
    computing tools like NumPy and SciPy, analytical libraries like statsmodels and
    scikit-learn, and data visualization libraries like matplotlib. pandas adopts
    significant parts of NumPy's idiomatic style of array-based computing, especially
    array-based functions and a preference for data processing without `for` loops.
  prefs: []
  type: TYPE_NORMAL
- en: While pandas adopts many coding idioms from NumPy, the biggest difference is
    that pandas is designed for working with tabular or heterogeneous data. NumPy,
    by contrast, is best suited for working with homogeneously typed numerical array
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Since becoming an open source project in 2010, pandas has matured into a quite
    large library that's applicable in a broad set of real-world use cases. The developer
    community has grown to over 2,500 distinct contributors, who've been helping build
    the project as they used it to solve their day-to-day data problems. The vibrant
    pandas developer and user communities have been a key part of its success.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note* *Many people don''t know that I haven''t been actively involved in day-to-day
    pandas development since 2013; it has been an entirely community-managed project
    since then. Be sure to pass on your thanks to the core development and all the
    contributors for their hard work!*  *Throughout the rest of the book, I use the
    following import conventions for NumPy and pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, whenever you see `pd.` in code, it’s referring to pandas. You may also
    find it easier to import Series and DataFrame into the local namespace since they
    are so frequently used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 5.1 Introduction to pandas Data Structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started with pandas, you will need to get comfortable with its two workhorse
    data structures: *Series* and *DataFrame*. While they are not a universal solution
    for every problem, they provide a solid foundation for a wide variety of data
    tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: Series
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A Series is a one-dimensional array-like object containing a sequence of values
    (of similar types to NumPy types) of the same type and an associated array of
    data labels, called its *index*. The simplest Series is formed from only an array
    of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The string representation of a Series displayed interactively shows the index
    on the left and the values on the right. Since we did not specify an index for
    the data, a default one consisting of the integers `0` through `N - 1` (where
    `N` is the length of the data) is created. You can get the array representation
    and index object of the Series via its `array` and `index` attributes, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the `.array` attribute is a `PandasArray` which usually wraps
    a NumPy array but can also contain special extension array types which will be
    discussed more in [Ch 7.3: Extension Data Types](/book/data-cleaning#pandas-ext-types).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, you''ll want to create a Series with an index identifying each data
    point with a label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Compared with NumPy arrays, you can use labels in the index when selecting
    single values or a set of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here `["c", "a", "d"]` is interpreted as a list of indices, even though it contains
    strings instead of integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using NumPy functions or NumPy-like operations, such as filtering with a Boolean
    array, scalar multiplication, or applying math functions, will preserve the index-value
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to think about a Series is as a fixed-length, ordered dictionary,
    as it is a mapping of index values to data values. It can be used in many contexts
    where you might use a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Should you have data contained in a Python dictionary, you can create a Series
    from it by passing the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A Series can be converted back to a dictionary with its `to_dict` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When you are only passing a dictionary, the index in the resulting Series will
    respect the order of the keys according to the dictionary''s `keys` method, which
    depends on the key insertion order. You can override this by passing an index
    with the dictionary keys in the order you want them to appear in the resulting
    Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, three values found in `sdata` were placed in the appropriate locations,
    but since no value for `"California"` was found, it appears as `NaN` (Not a Number),
    which is considered in pandas to mark missing or *NA* values. Since `"Utah"` was
    not included in `states`, it is excluded from the resulting object.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will use the terms “missing,” “NA,” or “null” interchangeably to refer to
    missing data. The `isna` and `notna` functions in pandas should be used to detect
    missing data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Series also has these as instance methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'I discuss working with missing data in more detail in [Ch 7: Data Cleaning
    and Preparation](/book/data-cleaning).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful Series feature for many applications is that it automatically aligns
    by index label in arithmetic operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Data alignment features will be addressed in more detail later. If you have
    experience with databases, you can think about this as being similar to a join
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the Series object itself and its index have a `name` attribute, which
    integrates with other areas of pandas functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A Series’s index can be altered in place by assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: DataFrame
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A DataFrame represents a rectangular table of data and contains an ordered,
    named collection of columns, each of which can be a different value type (numeric,
    string, Boolean, etc.). The DataFrame has both a row and column index; it can
    be thought of as a dictionary of Series all sharing the same index.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note* *While a DataFrame is physically two-dimensional, you can use it to
    represent higher dimensional data in a tabular format using hierarchical indexing,
    a subject we will discuss in [Ch 8: Data Wrangling: Join, Combine, and Reshape](/book/data-wrangling)
    and an ingredient in some of the more advanced data-handling features in pandas.*  *There
    are many ways to construct a DataFrame, though one of the most common is from
    a dictionary of equal-length lists or NumPy arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting DataFrame will have its index assigned automatically, as with
    Series, and the columns are placed according to the order of the keys in `data`
    (which depends on their insertion order in the dictionary):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Note* *If you are using the Jupyter notebook, pandas DataFrame objects will
    be displayed as a more browser-friendly HTML table. See [Figure 5.1](#fig-figure_pandas_df_html_table)
    for an example.*  *![](../Images/80bf6ca7e96e78f9839a73591d77f472.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.1: How pandas DataFrame objects look in Jupyter'
  prefs: []
  type: TYPE_NORMAL
- en: 'For large DataFrames, the `head` method selects only the first five rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, `tail` returns the last five rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you specify a sequence of columns, the DataFrame’s columns will be arranged
    in that order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pass a column that isn’t contained in the dictionary, it will appear
    with missing values in the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A column in a DataFrame can be retrieved as a Series either by dictionary-like
    notation or by using the dot attribute notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Note* *Attribute-like access (e.g., `frame2.year`) and tab completion of column
    names in IPython are provided as a convenience.'
  prefs: []
  type: TYPE_NORMAL
- en: '`frame2[column]` works for any column name, but `frame2.column` works only
    when the column name is a valid Python variable name and does not conflict with
    any of the method names in DataFrame. For example, if a column''s name contains
    whitespace or symbols other than underscores, it cannot be accessed with the dot
    attribute method.*  *Note that the returned Series have the same index as the
    DataFrame, and their `name` attribute has been appropriately set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rows can also be retrieved by position or name with the special `iloc` and
    `loc` attributes (more on this later in [Selection on DataFrame with loc and iloc](#pandas-loc-iloc)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Columns can be modified by assignment. For example, the empty `debt` column
    could be assigned a scalar value or an array of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When you are assigning lists or arrays to a column, the value’s length must
    match the length of the DataFrame. If you assign a Series, its labels will be
    realigned exactly to the DataFrame’s index, inserting missing values in any index
    values not present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Assigning a column that doesn’t exist will create a new column.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `del` keyword will delete columns like with a dictionary. As an example,
    I first add a new column of Boolean values where the `state` column equals `"Ohio"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Caution* *New columns cannot be created with the `frame2.eastern` dot attribute
    notation.*  *The `del` method can then be used to remove this column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Caution* *The column returned from indexing a DataFrame is a *view* on the
    underlying data, not a copy. Thus, any in-place modifications to the Series will
    be reflected in the DataFrame. The column can be explicitly copied with the Series’s
    `copy` method.*  *Another common form of data is a nested dictionary of dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If the nested dictionary is passed to the DataFrame, pandas will interpret
    the outer dictionary keys as the columns, and the inner keys as the row indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can transpose the DataFrame (swap rows and columns) with similar syntax
    to a NumPy array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Warning* *Note that transposing discards the column data types if the columns
    do not all have the same data type, so transposing and then transposing back may
    lose the previous type information. The columns become arrays of pure Python objects
    in this case.*  *The keys in the inner dictionaries are combined to form the index
    in the result. This isn’t true if an explicit index is specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Dictionaries of Series are treated in much the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: For a list of many of the things you can pass to the DataFrame constructor,
    see [Table 5.1](#tbl-table_dataframe_constructor).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.1: Possible data inputs to the DataFrame constructor'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2D ndarray | A matrix of data, passing optional row and column labels |'
  prefs: []
  type: TYPE_TB
- en: '| Dictionary of arrays, lists, or tuples | Each sequence becomes a column in
    the DataFrame; all sequences must be the same length |'
  prefs: []
  type: TYPE_TB
- en: '| NumPy structured/record array | Treated as the “dictionary of arrays” case
    |'
  prefs: []
  type: TYPE_TB
- en: '| Dictionary of Series | Each value becomes a column; indexes from each Series
    are unioned together to form the result’s row index if no explicit index is passed
    |'
  prefs: []
  type: TYPE_TB
- en: '| Dictionary of dictionaries | Each inner dictionary becomes a column; keys
    are unioned to form the row index as in the “dictionary of Series” case |'
  prefs: []
  type: TYPE_TB
- en: '| List of dictionaries or Series | Each item becomes a row in the DataFrame;
    unions of dictionary keys or Series indexes become the DataFrame’s column labels
    |'
  prefs: []
  type: TYPE_TB
- en: '| List of lists or tuples | Treated as the “2D ndarray” case |'
  prefs: []
  type: TYPE_TB
- en: '| Another DataFrame | The DataFrame’s indexes are used unless different ones
    are passed |'
  prefs: []
  type: TYPE_TB
- en: '| NumPy MaskedArray | Like the “2D ndarray” case except masked values are missing
    in the DataFrame result |'
  prefs: []
  type: TYPE_TB
- en: 'If a DataFrame’s `index` and `columns` have their `name` attributes set, these
    will also be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike Series, DataFrame does not have a `name` attribute. DataFrame''s `to_numpy`
    method returns the data contained in the DataFrame as a two-dimensional ndarray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If the DataFrame’s columns are different data types, the data type of the returned
    array will be chosen to accommodate all of the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]******  ***### Index Objects'
  prefs: []
  type: TYPE_NORMAL
- en: 'pandas’s Index objects are responsible for holding the axis labels (including
    a DataFrame''s column names) and other metadata (like the axis name or names).
    Any array or other sequence of labels you use when constructing a Series or DataFrame
    is internally converted to an Index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Index objects are immutable and thus can’t be modified by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Immutability makes it safer to share Index objects among data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*Caution* *Some users will not often take advantage of the capabilities provided
    by an Index, but because some operations will yield results containing indexed
    data, it''s important to understand how they work.*  *In addition to being array-like,
    an Index also behaves like a fixed-size set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike Python sets, a pandas Index can contain duplicate labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Selections with duplicate labels will select all occurrences of that label.
  prefs: []
  type: TYPE_NORMAL
- en: Each Index has a number of methods and properties for set logic, which answer
    other common questions about the data it contains. Some useful ones are summarized
    in [Table 5.2](#tbl-table_index_methods).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.2: Some Index methods and properties'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method/Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `append()` | Concatenate with additional Index objects, producing a new Index
    |'
  prefs: []
  type: TYPE_TB
- en: '| `difference()` | Compute set difference as an Index |'
  prefs: []
  type: TYPE_TB
- en: '| `intersection()` | Compute set intersection |'
  prefs: []
  type: TYPE_TB
- en: '| `union()` | Compute set union |'
  prefs: []
  type: TYPE_TB
- en: '| `isin()` | Compute Boolean array indicating whether each value is contained
    in the passed collection |'
  prefs: []
  type: TYPE_TB
- en: '| `delete()` | Compute new Index with element at Index `i` deleted |'
  prefs: []
  type: TYPE_TB
- en: '| `drop()` | Compute new Index by deleting passed values |'
  prefs: []
  type: TYPE_TB
- en: '| `insert()` | Compute new Index by inserting element at Index `i` |'
  prefs: []
  type: TYPE_TB
- en: '| `is_monotonic` | Returns `True` if each element is greater than or equal
    to the previous element |'
  prefs: []
  type: TYPE_TB
- en: '| `is_unique` | Returns `True` if the Index has no duplicate values |'
  prefs: []
  type: TYPE_TB
- en: '| `unique()` | Compute the array of unique values in the Index |****  ***##
    5.2 Essential Functionality'
  prefs: []
  type: TYPE_NORMAL
- en: This section will walk you through the fundamental mechanics of interacting
    with the data contained in a Series or DataFrame. In the chapters to come, we
    will delve more deeply into data analysis and manipulation topics using pandas.
    This book is not intended to serve as exhaustive documentation for the pandas
    library; instead, we'll focus on familiarizing you with heavily used features,
    leaving the less common (i.e., more esoteric) things for you to learn more about
    by reading the online pandas documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Reindexing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An important method on pandas objects is `reindex`, which means to create a
    new object with the values rearranged to align with the new index. Consider an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `reindex` on this Series rearranges the data according to the new index,
    introducing missing values if any index values were not already present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'For ordered data like time series, you may want to do some interpolation or
    filling of values when reindexing. The `method` option allows us to do this, using
    a method such as `ffill`, which forward-fills the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'With DataFrame, `reindex` can alter the (row) index, columns, or both. When
    passed only a sequence, it reindexes the rows in the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The columns can be reindexed with the `columns` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Because `"Ohio"` was not in `states`, the data for that column is dropped from
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to reindex a particular axis is to pass the new axis labels as
    a positional argument and then specify the axis to reindex with the `axis` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: See [Table 5.3](#tbl-table_reindex_function) for more about the arguments to
    `reindex`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.3: `reindex` function arguments'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `labels` | New sequence to use as an index. Can be Index instance or any
    other sequence-like Python data structure. An Index will be used exactly as is
    without any copying. |'
  prefs: []
  type: TYPE_TB
- en: '| `index` | Use the passed sequence as the new index labels. |'
  prefs: []
  type: TYPE_TB
- en: '| `columns` | Use the passed sequence as the new column labels. |'
  prefs: []
  type: TYPE_TB
- en: '| `axis` | The axis to reindex, whether `"index"` (rows) or `"columns"`. The
    default is `"index"`. You can alternately do `reindex(index=new_labels)` or `reindex(columns=new_labels)`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `method` | Interpolation (fill) method; `"ffill"` fills forward, while `"bfill"`
    fills backward. |'
  prefs: []
  type: TYPE_TB
- en: '| `fill_value` | Substitute value to use when introducing missing data by reindexing.
    Use `fill_value="missing"` (the default behavior) when you want absent labels
    to have null values in the result. |'
  prefs: []
  type: TYPE_TB
- en: '| `limit` | When forward filling or backfilling, the maximum size gap (in number
    of elements) to fill. |'
  prefs: []
  type: TYPE_TB
- en: '| `tolerance` | When forward filling or backfilling, the maximum size gap (in
    absolute numeric distance) to fill for inexact matches. |'
  prefs: []
  type: TYPE_TB
- en: '| `level` | Match simple Index on level of MultiIndex; otherwise select subset
    of. |'
  prefs: []
  type: TYPE_TB
- en: '| `copy` | If `True`, always copy underlying data even if the new index is
    equivalent to the old index; if `False`, do not copy the data when the indexes
    are equivalent. |'
  prefs: []
  type: TYPE_TB
- en: 'As we''ll explore later in [Selection on DataFrame with loc and iloc](#pandas-loc-iloc),
    you can also reindex by using the `loc` operator, and many users prefer to always
    do it this way. This works only if all of the new index labels already exist in
    the DataFrame (whereas `reindex` will insert missing data for new labels):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Dropping Entries from an Axis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Dropping one or more entries from an axis is simple if you already have an
    index array or list without those entries, since you can use the `reindex` method
    or `.loc`-based indexing. As that can require a bit of munging and set logic,
    the `drop` method will return a new object with the indicated value or values
    deleted from an axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'With DataFrame, index values can be deleted from either axis. To illustrate
    this, we first create an example DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `drop` with a sequence of labels will drop values from the row labels
    (axis 0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To drop labels from the columns, instead use the `columns` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also drop values from the columns by passing `axis=1` (which is like
    NumPy) or `axis="columns"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Indexing, Selection, and Filtering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Series indexing (`obj[...]`) works analogously to NumPy array indexing, except
    you can use the Series’s index values instead of only integers. Here are some
    examples of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'While you can select data by label this way, the preferred way to select index
    values is with the special `loc` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason to prefer `loc` is because of the different treatment of integers
    when indexing with `[]`. Regular `[]`-based indexing will treat integers as labels
    if the index contains integers, so the behavior differs depending on the data
    type of the index. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'When using `loc`, the expression `obj.loc[[0, 1, 2]]` will fail when the index
    does not contain integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `loc` operator indexes exclusively with labels, there is also an `iloc`
    operator that indexes exclusively with integers to work consistently whether or
    not the index contains integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '*Caution* *You can also slice with labels, but it works differently from normal
    Python slicing in that the endpoint is inclusive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]*  *Assigning values using these methods modifies the corresponding
    section of the Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '*Note* *It can be a common newbie error to try to call `loc` or `iloc` like
    functions rather than "indexing into" them with square brackets. The square bracket
    notation is used to enable slice operations and to allow for indexing on multiple
    axes with DataFrame objects.*  *Indexing into a DataFrame retrieves one or more
    columns either with a single value or sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Indexing like this has a few special cases. The first is slicing or selecting
    data with a Boolean array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The row selection syntax `data[:2]` is provided as a convenience. Passing a
    single element or a list to the `[]` operator selects columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another use case is indexing with a Boolean DataFrame, such as one produced
    by a scalar comparison. Consider a DataFrame with all Boolean values produced
    by comparing with a scalar value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this DataFrame to assign the value 0 to each location with the value
    `True`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Selection on DataFrame with loc and iloc
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like Series, DataFrame has special attributes `loc` and `iloc` for label-based
    and integer-based indexing, respectively. Since DataFrame is two-dimensional,
    you can select a subset of the rows and columns with NumPy-like notation using
    either axis labels (`loc`) or integers (`iloc`).
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first example, let''s select a single row by label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of selecting a single row is a Series with an index that contains
    the DataFrame''s column labels. To select multiple roles, creating a new DataFrame,
    pass a sequence of labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'You can combine both row and column selection in `loc` by separating the selections
    with a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll then perform some similar selections with integers using `iloc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Both indexing functions work with slices in addition to single labels or lists
    of labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Boolean arrays can be used with `loc` but not `iloc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: There are many ways to select and rearrange the data contained in a pandas object.
    For DataFrame, [Table 5.4](#tbl-table_dataframe_loc_iloc) provides a short summary
    of many of them. As you will see later, there are a number of additional options
    for working with hierarchical indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.4: Indexing options with DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `df[column]` | Select single column or sequence of columns from the DataFrame;
    special case conveniences: Boolean array (filter rows), slice (slice rows), or
    Boolean DataFrame (set values based on some criterion) |'
  prefs: []
  type: TYPE_TB
- en: '| `df.loc[rows]` | Select single row or subset of rows from the DataFrame by
    label |'
  prefs: []
  type: TYPE_TB
- en: '| `df.loc[:, cols]` | Select single column or subset of columns by label |'
  prefs: []
  type: TYPE_TB
- en: '| `df.loc[rows, cols]` | Select both row(s) and column(s) by label |'
  prefs: []
  type: TYPE_TB
- en: '| `df.iloc[rows]` | Select single row or subset of rows from the DataFrame
    by integer position |'
  prefs: []
  type: TYPE_TB
- en: '| `df.iloc[:, cols]` | Select single column or subset of columns by integer
    position |'
  prefs: []
  type: TYPE_TB
- en: '| `df.iloc[rows, cols]` | Select both row(s) and column(s) by integer position
    |'
  prefs: []
  type: TYPE_TB
- en: '| `df.at[row, col]` | Select a single scalar value by row and column label
    |'
  prefs: []
  type: TYPE_TB
- en: '| `df.iat[row, col]` | Select a single scalar value by row and column position
    (integers) |'
  prefs: []
  type: TYPE_TB
- en: '| `reindex` method | Select either rows or columns by labels |'
  prefs: []
  type: TYPE_TB
- en: Integer indexing pitfalls
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Working with pandas objects indexed by integers can be a stumbling block for
    new users since they work differently from built-in Python data structures like
    lists and tuples. For example, you might not expect the following code to generate
    an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, pandas could “fall back” on integer indexing, but it is difficult
    to do this in general without introducing subtle bugs into the user code. Here
    we have an index containing `0`, `1`, and `2`, but pandas does not want to guess
    what the user wants (label-based indexing or position-based):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, with a noninteger index, there is no such ambiguity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have an axis index containing integers, data selection will always be
    label oriented. As I said above, if you use `loc` (for labels) or `iloc` (for
    integers) you will get exactly what you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, slicing with integers is always integer oriented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: As a result of these pitfalls, it is best to always prefer indexing with `loc`
    and `iloc` to avoid ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: Pitfalls with chained indexing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the previous section we looked at how you can do flexible selections on a
    DataFrame using `loc` and `iloc`. These indexing attributes can also be used to
    modify DataFrame objects in place, but doing so requires some care.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the example DataFrame above, we can assign to a column or row
    by label or integer position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'A common gotcha for new pandas users is to chain selections when assigning,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on the data contents, this may print a special `SettingWithCopyWarning`,
    which warns you that you are trying to modify a temporary value (the nonempty
    result of `data.loc[data.three == 5]`) instead of the original DataFrame `data`,
    which might be what you were intending. Here, `data` was unmodified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'In these scenarios, the fix is to rewrite the chained assignment to use a single
    `loc` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: A good rule of thumb is to avoid chained indexing when doing assignments. There
    are other cases where pandas will generate `SettingWithCopyWarning` that have
    to do with chained indexing. I refer you to this topic in the online pandas documentation.**  **###
    Arithmetic and Data Alignment
  prefs: []
  type: TYPE_NORMAL
- en: 'pandas can make it much simpler to work with objects that have different indexes.
    For example, when you add objects, if any index pairs are not the same, the respective
    index in the result will be the union of the index pairs. Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding these yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The internal data alignment introduces missing values in the label locations
    that don’t overlap. Missing values will then propagate in further arithmetic computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of DataFrame, alignment is performed on both rows and columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding these returns a DataFrame with index and columns that are the unions
    of the ones in each DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Since the `"c"` and `"e"` columns are not found in both DataFrame objects, they
    appear as missing in the result. The same holds for the rows with labels that
    are not common to both objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you add DataFrame objects with no column or row labels in common, the result
    will contain all nulls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Arithmetic methods with fill values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In arithmetic operations between differently indexed objects, you might want
    to fill with a special value, like 0, when an axis label is found in one object
    but not the other. Here is an example where we set a particular value to NA (null)
    by assigning `np.nan` to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding these results in missing values in the locations that don’t overlap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `add` method on `df1`, I pass `df2` and an argument to `fill_value`,
    which substitutes the passed value for any missing values in the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'See [Table 5.5](#tbl-table_flex_arith) for a listing of Series and DataFrame
    methods for arithmetic. Each has a counterpart, starting with the letter `r`,
    that has arguments reversed. So these two statements are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Relatedly, when reindexing a Series or DataFrame, you can also specify a different
    fill value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Table 5.5: Flexible arithmetic methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `add, radd` | Methods for addition (+) |'
  prefs: []
  type: TYPE_TB
- en: '| `sub, rsub` | Methods for subtraction (-) |'
  prefs: []
  type: TYPE_TB
- en: '| `div, rdiv` | Methods for division (/) |'
  prefs: []
  type: TYPE_TB
- en: '| `floordiv, rfloordiv` | Methods for floor division (//) |'
  prefs: []
  type: TYPE_TB
- en: '| `mul, rmul` | Methods for multiplication (*) |'
  prefs: []
  type: TYPE_TB
- en: '| `pow, rpow` | Methods for exponentiation (**) |'
  prefs: []
  type: TYPE_TB
- en: Operations between DataFrame and Series
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As with NumPy arrays of different dimensions, arithmetic between DataFrame
    and Series is also defined. First, as a motivating example, consider the difference
    between a two-dimensional array and one of its rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'When we subtract `arr[0]` from `arr`, the subtraction is performed once for
    each row. This is referred to as *broadcasting* and is explained in more detail
    as it relates to general NumPy arrays in [Appendix A: Advanced NumPy](/book/advanced-numpy).
    Operations between a DataFrame and a Series are similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, arithmetic between DataFrame and Series matches the index of the
    Series on the columns of the DataFrame, broadcasting down the rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'If an index value is not found in either the DataFrame’s columns or the Series’s
    index, the objects will be reindexed to form the union:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to instead broadcast over the columns, matching on the rows, you
    have to use one of the arithmetic methods and specify to match over the index.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The axis that you pass is the *axis to match on*. In this case we mean to match
    on the DataFrame’s row index (`axis="index"`) and broadcast across the columns.
  prefs: []
  type: TYPE_NORMAL
- en: Function Application and Mapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NumPy ufuncs (element-wise array methods) also work with pandas objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Another frequent operation is applying a function on one-dimensional arrays
    to each column or row. DataFrame’s `apply` method does exactly this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Here the function `f`, which computes the difference between the maximum and
    minimum of a Series, is invoked once on each column in `frame`. The result is
    a Series having the columns of `frame` as its index.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you pass `axis="columns"` to `apply`, the function will be invoked once
    per row instead. A helpful way to think about this is as "apply across the columns":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Many of the most common array statistics (like `sum` and `mean`) are DataFrame
    methods, so using `apply` is not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function passed to `apply` need not return a scalar value; it can also
    return a Series with multiple values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Element-wise Python functions can be used, too. Suppose you wanted to compute
    a formatted string from each floating-point value in `frame`. You can do this
    with `applymap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for the name `applymap` is that Series has a `map` method for applying
    an element-wise function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Sorting and Ranking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sorting a dataset by some criterion is another important built-in operation.
    To sort lexicographically by row or column label, use the `sort_index` method,
    which returns a new, sorted object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'With a DataFrame, you can sort by index on either axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The data is sorted in ascending order by default but can be sorted in descending
    order, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'To sort a Series by its values, use its `sort_values` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Any missing values are sorted to the end of the Series by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Missing values can be sorted to the start instead by using the `na_position`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'When sorting a DataFrame, you can use the data in one or more columns as the
    sort keys. To do so, pass one or more column names to `sort_values`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'To sort by multiple columns, pass a list of names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '*Ranking* assigns ranks from one through the number of valid data points in
    an array, starting from the lowest value. The `rank` methods for Series and DataFrame
    are the place to look; by default, `rank` breaks ties by assigning each group
    the mean rank:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Ranks can also be assigned according to the order in which they’re observed
    in the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Here, instead of using the average rank 6.5 for the entries 0 and 2, they instead
    have been set to 6 and 7 because label 0 precedes label 2 in the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can rank in descending order, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: See [Table 5.6](#tbl-table_pandas_rank) for a list of tie-breaking methods available.
  prefs: []
  type: TYPE_NORMAL
- en: 'DataFrame can compute ranks over the rows or the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Table 5.6: Tie-breaking methods with rank'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `"average"` | Default: assign the average rank to each entry in the equal
    group |'
  prefs: []
  type: TYPE_TB
- en: '| `"min"` | Use the minimum rank for the whole group |'
  prefs: []
  type: TYPE_TB
- en: '| `"max"` | Use the maximum rank for the whole group |'
  prefs: []
  type: TYPE_TB
- en: '| `"first"` | Assign ranks in the order the values appear in the data |'
  prefs: []
  type: TYPE_TB
- en: '| `"dense"` | Like `method="min"`, but ranks always increase by 1 between groups
    rather than the number of equal elements in a group |'
  prefs: []
  type: TYPE_TB
- en: Axis Indexes with Duplicate Labels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Up until now almost all of the examples we have looked at have unique axis
    labels (index values). While many pandas functions (like `reindex`) require that
    the labels be unique, it’s not mandatory. Let’s consider a small Series with duplicate
    indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The `is_unique` property of the index can tell you whether or not its labels
    are unique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Data selection is one of the main things that behaves differently with duplicates.
    Indexing a label with multiple entries returns a Series, while single entries
    return a scalar value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: This can make your code more complicated, as the output type from indexing can
    vary based on whether or not a label is repeated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same logic extends to indexing rows (or columns) in a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]**  **## 5.3 Summarizing and Computing Descriptive Statistics'
  prefs: []
  type: TYPE_NORMAL
- en: 'pandas objects are equipped with a set of common mathematical and statistical
    methods. Most of these fall into the category of *reductions* or *summary statistics*,
    methods that extract a single value (like the sum or mean) from a Series, or a
    Series of values from the rows or columns of a DataFrame. Compared with the similar
    methods found on NumPy arrays, they have built-in handling for missing data. Consider
    a small DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling DataFrame’s `sum` method returns a Series containing column sums:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing `axis="columns"` or `axis=1` sums across the columns instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'When an entire row or column contains all NA values, the sum is 0, whereas
    if any value is not NA, then the result is NA. This can be disabled with the `skipna`
    option, in which case any NA value in a row or column names the corresponding
    result NA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Some aggregations, like `mean`, require at least one non-NA value to yield
    a value result, so here we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: See [Table 5.7](#tbl-table_pandas_reduction) for a list of common options for
    each reduction method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.7: Options for reduction methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `axis` | Axis to reduce over; "index" for DataFrame’s rows and "columns"
    for columns |'
  prefs: []
  type: TYPE_TB
- en: '| `skipna` | Exclude missing values; `True` by default |'
  prefs: []
  type: TYPE_TB
- en: '| `level` | Reduce grouped by level if the axis is hierarchically indexed (MultiIndex)
    |'
  prefs: []
  type: TYPE_TB
- en: 'Some methods, like `idxmin` and `idxmax`, return indirect statistics, like
    the index value where the minimum or maximum values are attained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Other methods are *accumulations*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Some methods are neither reductions nor accumulations. `describe` is one such
    example, producing multiple summary statistics in one shot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'On nonnumeric data, `describe` produces alternative summary statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: See [Table 5.8](#tbl-table_descriptive_stats) for a full list of summary statistics
    and related methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.8: Descriptive and summary statistics'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `count` | Number of non-NA values |'
  prefs: []
  type: TYPE_TB
- en: '| `describe` | Compute set of summary statistics |'
  prefs: []
  type: TYPE_TB
- en: '| `min, max` | Compute minimum and maximum values |'
  prefs: []
  type: TYPE_TB
- en: '| `argmin, argmax` | Compute index locations (integers) at which minimum or
    maximum value is obtained, respectively; not available on DataFrame objects |'
  prefs: []
  type: TYPE_TB
- en: '| `idxmin, idxmax` | Compute index labels at which minimum or maximum value
    is obtained, respectively |'
  prefs: []
  type: TYPE_TB
- en: '| `quantile` | Compute sample quantile ranging from 0 to 1 (default: 0.5) |'
  prefs: []
  type: TYPE_TB
- en: '| `sum` | Sum of values |'
  prefs: []
  type: TYPE_TB
- en: '| `mean` | Mean of values |'
  prefs: []
  type: TYPE_TB
- en: '| `median` | Arithmetic median (50% quantile) of values |'
  prefs: []
  type: TYPE_TB
- en: '| `mad` | Mean absolute deviation from mean value |'
  prefs: []
  type: TYPE_TB
- en: '| `prod` | Product of all values |'
  prefs: []
  type: TYPE_TB
- en: '| `var` | Sample variance of values |'
  prefs: []
  type: TYPE_TB
- en: '| `std` | Sample standard deviation of values |'
  prefs: []
  type: TYPE_TB
- en: '| `skew` | Sample skewness (third moment) of values |'
  prefs: []
  type: TYPE_TB
- en: '| `kurt` | Sample kurtosis (fourth moment) of values |'
  prefs: []
  type: TYPE_TB
- en: '| `cumsum` | Cumulative sum of values |'
  prefs: []
  type: TYPE_TB
- en: '| `cummin, cummax` | Cumulative minimum or maximum of values, respectively
    |'
  prefs: []
  type: TYPE_TB
- en: '| `cumprod` | Cumulative product of values |'
  prefs: []
  type: TYPE_TB
- en: '| `diff` | Compute first arithmetic difference (useful for time series) |'
  prefs: []
  type: TYPE_TB
- en: '| `pct_change` | Compute percent changes |'
  prefs: []
  type: TYPE_TB
- en: Correlation and Covariance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some summary statistics, like correlation and covariance, are computed from
    pairs of arguments. Let’s consider some DataFrames of stock prices and volumes
    originally obtained from Yahoo! Finance and available in binary Python pickle
    files you can find in the accompanying datasets for the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'I now compute percent changes of the prices, a time series operation that will
    be explored further in [Ch 11: Time Series](/book/time-series):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The `corr` method of Series computes the correlation of the overlapping, non-NA,
    aligned-by-index values in two Series. Relatedly, `cov` computes the covariance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'DataFrame’s `corr` and `cov` methods, on the other hand, return a full correlation
    or covariance matrix as a DataFrame, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Using DataFrame’s `corrwith` method, you can compute pair-wise correlations
    between a DataFrame’s columns or rows with another Series or DataFrame. Passing
    a Series returns a Series with the correlation value computed for each column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing a DataFrame computes the correlations of matching column names. Here,
    I compute correlations of percent changes with volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Passing `axis="columns"` does things row-by-row instead. In all cases, the data
    points are aligned by label before the correlation is computed.
  prefs: []
  type: TYPE_NORMAL
- en: Unique Values, Value Counts, and Membership
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another class of related methods extracts information about the values contained
    in a one-dimensional Series. To illustrate these, consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'The first function is `unique`, which gives you an array of the unique values
    in a Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The unique values are not necessarily returned in the order in which they first
    appear, and not in sorted order, but they could be sorted after the fact if needed
    (`uniques.sort()`). Relatedly, `value_counts` computes a Series containing value
    frequencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The Series is sorted by value in descending order as a convenience. `value_counts`
    is also available as a top-level pandas method that can be used with NumPy arrays
    or other Python sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '`isin` performs a vectorized set membership check and can be useful in filtering
    a dataset down to a subset of values in a Series or column in a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Related to `isin` is the `Index.get_indexer` method, which gives you an index
    array from an array of possibly nondistinct values into another array of distinct
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: See [Table 5.9](#tbl-table_binning) for a reference on these methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5.9: Unique, value counts, and set membership methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `isin` | Compute a Boolean array indicating whether each Series or DataFrame
    value is contained in the passed sequence of values |'
  prefs: []
  type: TYPE_TB
- en: '| `get_indexer` | Compute integer indices for each value in an array into another
    array of distinct values; helpful for data alignment and join-type operations
    |'
  prefs: []
  type: TYPE_TB
- en: '| `unique` | Compute an array of unique values in a Series, returned in the
    order observed |'
  prefs: []
  type: TYPE_TB
- en: '| `value_counts` | Return a Series containing unique values as its index and
    frequencies as its values, ordered count in descending order |'
  prefs: []
  type: TYPE_TB
- en: 'In some cases, you may want to compute a histogram on multiple related columns
    in a DataFrame. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'We can compute the value counts for a single column, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'To compute this for all columns, pass `pandas.value_counts` to the DataFrame’s
    `apply` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Here, the row labels in the result are the distinct values occurring in all
    of the columns. The values are the respective counts of these values in each column.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a `DataFrame.value_counts` method, but it computes counts considering
    each row of the DataFrame as a tuple to determine the number of occurrences of
    each distinct row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the result has an index representing the distinct rows as a hierarchical
    index, a topic we will explore in greater detail in [Ch 8: Data Wrangling: Join,
    Combine, and Reshape](/book/data-wrangling).'
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss tools for reading (or *loading*) and writing
    datasets with pandas. After that, we will dig deeper into data cleaning, wrangling,
    analysis, and visualization tools using pandas.*******
  prefs: []
  type: TYPE_NORMAL
