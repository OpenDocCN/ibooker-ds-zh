- en: 10  Data Aggregation and Group Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://wesmckinney.com/book/data-aggregation](https://wesmckinney.com/book/data-aggregation)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This Open Access web version of *Python for Data Analysis 3rd Edition* is
    now available as a companion to the [print and digital editions](https://amzn.to/3DyLaJc).
    If you encounter any errata, [please report them here](https://oreilly.com/catalog/0636920519829/errata).
    Please note that some aspects of this site as produced by Quarto will differ from
    the formatting of the print and eBook versions from O’Reilly.'
  prefs: []
  type: TYPE_NORMAL
- en: If you find the online edition of the book useful, please consider [ordering
    a paper copy](https://amzn.to/3DyLaJc) or a [DRM-free eBook](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)
    to support the author. The content from this website may not be copied or reproduced.
    The code examples are MIT licensed and can be found on GitHub or Gitee.*  *Categorizing
    a dataset and applying a function to each group, whether an aggregation or transformation,
    can be a critical component of a data analysis workflow. After loading, merging,
    and preparing a dataset, you may need to compute group statistics or possibly
    *pivot tables* for reporting or visualization purposes. pandas provides a versatile
    `groupby` interface, enabling you to slice, dice, and summarize datasets in a
    natural way.
  prefs: []
  type: TYPE_NORMAL
- en: 'One reason for the popularity of relational databases and SQL (which stands
    for “structured query language”) is the ease with which data can be joined, filtered,
    transformed, and aggregated. However, query languages like SQL impose certain
    limitations on the kinds of group operations that can be performed. As you will
    see, with the expressiveness of Python and pandas, we can perform quite complex
    group operations by expressing them as custom Python functions that manipulate
    the data associated with each group. In this chapter, you will learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Split a pandas object into pieces using one or more keys (in the form of functions,
    arrays, or DataFrame column names)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate group summary statistics, like count, mean, or standard deviation,
    or a user-defined function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply within-group transformations or other manipulations, like normalization,
    linear regression, rank, or subset selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute pivot tables and cross-tabulations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform quantile analysis and other statistical group analyses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Note* *Time-based aggregation of time series data, a special use case of `groupby`,
    is referred to as *resampling* in this book and will receive separate treatment
    in [Ch 11: Time Series](/book/time-series).*  *As with the rest of the chapters,
    we start by importing NumPy and pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 10.1 How to Think About Group Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hadley Wickham, an author of many popular packages for the R programming language,
    coined the term *split-apply-combine* for describing group operations. In the
    first stage of the process, data contained in a pandas object, whether a Series,
    DataFrame, or otherwise, is *split* into groups based on one or more *keys* that
    you provide. The splitting is performed on a particular axis of an object. For
    example, a DataFrame can be grouped on its rows (`axis="index"`) or its columns
    (`axis="columns"`). Once this is done, a function is *applied* to each group,
    producing a new value. Finally, the results of all those function applications
    are *combined* into a result object. The form of the resulting object will usually
    depend on what’s being done to the data. See [Figure 10.1](#fig-figure_groupby_agg)
    for a mockup of a simple group aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each grouping key can take many forms, and the keys do not have to be all of
    the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: A list or array of values that is the same length as the axis being grouped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A value indicating a column name in a DataFrame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dictionary or Series giving a correspondence between the values on the axis
    being grouped and the group names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function to be invoked on the axis index or the individual labels in the index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/568aea090be607a174816297616d3b0d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Illustration of a group aggregation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the latter three methods are shortcuts for producing an array of
    values to be used to split up the object. Don’t worry if this all seems abstract.
    Throughout this chapter, I will give many examples of all these methods. To get
    started, here is a small tabular dataset as a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you wanted to compute the mean of the `data1` column using the labels
    from `key1`. There are a number of ways to do this. One is to access `data1` and
    call `groupby` with the column (a Series) at `key1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This `grouped` variable is now a special *"GroupBy"* object. It has not actually
    computed anything yet except for some intermediate data about the group key `df["key1"]`.
    The idea is that this object has all of the information needed to then apply some
    operation to each of the groups. For example, to compute group means we can call
    the GroupBy’s `mean` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Later in [Data Aggregation](#groupby_aggregation), I'll explain more about what
    happens when you call `.mean()`. The important thing here is that the data (a
    Series) has been aggregated by splitting the data on the group key, producing
    a new Series that is now indexed by the unique values in the `key1` column. The
    result index has the name `"key1"` because the DataFrame column `df["key1"]` did.
  prefs: []
  type: TYPE_NORMAL
- en: 'If instead we had passed multiple arrays as a list, we''d get something different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we grouped the data using two keys, and the resulting Series now has a
    hierarchical index consisting of the unique pairs of keys observed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the group keys are all Series, though they could be any arrays
    of the right length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Frequently, the grouping information is found in the same DataFrame as the
    data you want to work on. In that case, you can pass column names (whether those
    are strings, numbers, or other Python objects) as the group keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that in the second case, it is necessary to pass `numeric_only=True`
    because the `key1` column is not numeric and thus cannot be aggregated with `mean()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of the objective in using `groupby`, a generally useful GroupBy
    method is `size`, which returns a Series containing group sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that any missing values in a group key are excluded from the result by
    default. This behavior can be disabled by passing `dropna=False` to `groupby`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A group function similar in spirit to `size` is count, which computes the number
    of nonnull values in each group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Iterating over Groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The object returned by `groupby` supports iteration, generating a sequence
    of 2-tuples containing the group name along with the chunk of data. Consider the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of multiple keys, the first element in the tuple will be a tuple
    of key values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you can choose to do whatever you want with the pieces of data.
    A recipe you may find useful is computing a dictionary of the data pieces as a
    one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'By default `groupby` groups on `axis="index"`, but you can group on any of
    the other axes. For example, we could group the columns of our example `df` here
    by whether they start with `"key"` or `"data"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can print out the groups like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Selecting a Column or Subset of Columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Indexing a GroupBy object created from a DataFrame with a column name or array
    of column names has the effect of column subsetting for aggregation. This means
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'are conveniences for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Especially for large datasets, it may be desirable to aggregate only a few
    columns. For example, in the preceding dataset, to compute the means for just
    the `data2` column and get the result as a DataFrame, we could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The object returned by this indexing operation is a grouped DataFrame if a
    list or array is passed, or a grouped Series if only a single column name is passed
    as a scalar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Grouping with Dictionaries and Series
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Grouping information may exist in a form other than an array. Let’s consider
    another example DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose I have a group correspondence for the columns and want to sum
    the columns by group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you could construct an array from this dictionary to pass to `groupby`,
    but instead we can just pass the dictionary (I included the key `"f"` to highlight
    that unused grouping keys are OK):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The same functionality holds for Series, which can be viewed as a fixed-size
    mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Grouping with Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using Python functions is a more generic way of defining a group mapping compared
    with a dictionary or Series. Any function passed as a group key will be called
    once per index value (or once per column value if using `axis="columns"`), with
    the return values being used as the group names. More concretely, consider the
    example DataFrame from the previous section, which has people’s first names as
    index values. Suppose you wanted to group by name length. While you could compute
    an array of string lengths, it''s simpler to just pass the `len` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Mixing functions with arrays, dictionaries, or Series is not a problem, as
    everything gets converted to arrays internally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Grouping by Index Levels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A final convenience for hierarchically indexed datasets is the ability to aggregate
    using one of the levels of an axis index. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To group by level, pass the level number or name using the `level` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 10.2 Data Aggregation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Aggregations* refer to any data transformation that produces scalar values
    from arrays. The preceding examples have used several of them, including `mean`,
    `count`, `min`, and `sum`. You may wonder what is going on when you invoke `mean()`
    on a GroupBy object. Many common aggregations, such as those found in [Table 10.1](#tbl-table_opt_groupby_methods),
    have optimized implementations. However, you are not limited to only this set
    of methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10.1: Optimized `groupby` methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `any, all` | Return `True` if any (one or more values) or all non-NA values
    are "truthy" |'
  prefs: []
  type: TYPE_TB
- en: '| `count` | Number of non-NA values |'
  prefs: []
  type: TYPE_TB
- en: '| `cummin, cummax` | Cumulative minimum and maximum of non-NA values |'
  prefs: []
  type: TYPE_TB
- en: '| `cumsum` | Cumulative sum of non-NA values |'
  prefs: []
  type: TYPE_TB
- en: '| `cumprod` | Cumulative product of non-NA values |'
  prefs: []
  type: TYPE_TB
- en: '| `first, last` | First and last non-NA values |'
  prefs: []
  type: TYPE_TB
- en: '| `mean` | Mean of non-NA values |'
  prefs: []
  type: TYPE_TB
- en: '| `median` | Arithmetic median of non-NA values |'
  prefs: []
  type: TYPE_TB
- en: '| `min, max` | Minimum and maximum of non-NA values |'
  prefs: []
  type: TYPE_TB
- en: '| `nth` | Retrieve value that would appear at position `n` with the data in
    sorted order |'
  prefs: []
  type: TYPE_TB
- en: '| `ohlc` | Compute four "open-high-low-close" statistics for time series-like
    data |'
  prefs: []
  type: TYPE_TB
- en: '| `prod` | Product of non-NA values |'
  prefs: []
  type: TYPE_TB
- en: '| `quantile` | Compute sample quantile |'
  prefs: []
  type: TYPE_TB
- en: '| `rank` | Ordinal ranks of non-NA values, like calling `Series.rank` |'
  prefs: []
  type: TYPE_TB
- en: '| `size` | Compute group sizes, returning result as a Series |'
  prefs: []
  type: TYPE_TB
- en: '| `sum` | Sum of non-NA values |'
  prefs: []
  type: TYPE_TB
- en: '| `std, var` | Sample standard deviation and variance |'
  prefs: []
  type: TYPE_TB
- en: 'You can use aggregations of your own devising and additionally call any method
    that is also defined on the object being grouped. For example, the `nsmallest`
    Series method selects the smallest requested number of values from the data. While
    `nsmallest` is not explicitly implemented for GroupBy, we can still use it with
    a nonoptimized implementation. Internally, GroupBy slices up the Series, calls
    `piece.nsmallest(n)` for each piece, and then assembles those results into the
    result object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To use your own aggregation functions, pass any function that aggregates an
    array to the `aggregate` method or its short alias `agg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You may notice that some methods, like `describe`, also work, even though they
    are not aggregations, strictly speaking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'I will explain in more detail what has happened here in [Apply: General split-apply-combine](#groupby_apply).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Note* *Custom aggregation functions are generally much slower than the optimized
    functions found in [Table 10.1](#tbl-table_opt_groupby_methods). This is because
    there is some extra overhead (function calls, data rearrangement) in constructing
    the intermediate group data chunks.*  *### Column-Wise and Multiple Function Application'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s return to the tipping dataset used in the last chapter. After loading
    it with `pandas.read_csv`, we add a tipping percentage column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now I will add a `tip_pct` column with the tip percentage of the total bill:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As you’ve already seen, aggregating a Series or all of the columns of a DataFrame
    is a matter of using `aggregate` (or `agg`) with the desired function or calling
    a method like `mean` or `std`. However, you may want to aggregate using a different
    function, depending on the column, or multiple functions at once. Fortunately,
    this is possible to do, which I’ll illustrate through a number of examples. First,
    I’ll group the `tips` by `day` and `smoker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that for descriptive statistics like those in [Table 10.1](#tbl-table_opt_groupby_methods),
    you can pass the name of the function as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pass a list of functions or function names instead, you get back a DataFrame
    with column names taken from the functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here we passed a list of aggregation functions to `agg` to evaluate independently
    on the data groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'You don’t need to accept the names that GroupBy gives to the columns; notably,
    `lambda` functions have the name `"<lambda>"`, which makes them hard to identify
    (you can see for yourself by looking at a function’s `__name__` attribute). Thus,
    if you pass a list of `(name, function)` tuples, the first element of each tuple
    will be used as the DataFrame column names (you can think of a list of 2-tuples
    as an ordered mapping):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With a DataFrame you have more options, as you can specify a list of functions
    to apply to all of the columns or different functions per column. To start, suppose
    we wanted to compute the same three statistics for the `tip_pct` and `total_bill`
    columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the resulting DataFrame has hierarchical columns, the same
    as you would get aggregating each column separately and using `concat` to glue
    the results together using the column names as the `keys` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, a list of tuples with custom names can be passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose you wanted to apply potentially different functions to one or
    more of the columns. To do this, pass a dictionary to `agg` that contains a mapping
    of column names to any of the function specifications listed so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: A DataFrame will have hierarchical columns only if multiple functions are applied
    to at least one column.
  prefs: []
  type: TYPE_NORMAL
- en: Returning Aggregated Data Without Row Indexes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In all of the examples up until now, the aggregated data comes back with an
    index, potentially hierarchical, composed from the unique group key combinations.
    Since this isn’t always desirable, you can disable this behavior in most cases
    by passing `as_index=False` to `groupby`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, it’s always possible to obtain the result in this format by calling
    `reset_index` on the result. Using the `as_index=False` argument avoids some unnecessary
    computations.*  *## 10.3 Apply: General split-apply-combine'
  prefs: []
  type: TYPE_NORMAL
- en: The most general-purpose GroupBy method is `apply`, which is the subject of
    this section. `apply` splits the object being manipulated into pieces, invokes
    the passed function on each piece, and then attempts to concatenate the pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the tipping dataset from before, suppose you wanted to select
    the top five `tip_pct` values by group. First, write a function that selects the
    rows with the largest values in a particular column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we group by `smoker`, say, and call `apply` with this function, we
    get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: What has happened here? First, the `tips` DataFrame is split into groups based
    on the value of `smoker`. Then the `top` function is called on each group, and
    the results of each function call are glued together using `pandas.concat`, labeling
    the pieces with the group names. The result therefore has a hierarchical index
    with an inner level that contains index values from the original DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you pass a function to `apply` that takes other arguments or keywords, you
    can pass these after the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Beyond these basic usage mechanics, getting the most out of `apply` may require
    some creativity. What occurs inside the function passed is up to you; it must
    either return a pandas object or a scalar value. The rest of this chapter will
    consist mainly of examples showing you how to solve various problems using `groupby`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you may recall that I earlier called `describe` on a GroupBy object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside GroupBy, when you invoke a method like `describe`, it is actually just
    a shortcut for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Suppressing the Group Keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the preceding examples, you see that the resulting object has a hierarchical
    index formed from the group keys, along with the indexes of each piece of the
    original object. You can disable this by passing `group_keys=False` to `groupby`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Quantile and Bucket Analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you may recall from [Ch 8: Data Wrangling: Join, Combine, and Reshape](/book/data-wrangling),
    pandas has some tools, in particular `pandas.cut` and `pandas.qcut`, for slicing
    data up into buckets with bins of your choosing, or by sample quantiles. Combining
    these functions with `groupby` makes it convenient to perform bucket or quantile
    analysis on a dataset. Consider a simple random dataset and an equal-length bucket
    categorization using `pandas.cut`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Categorical` object returned by `cut` can be passed directly to `groupby`.
    So we could compute a set of group statistics for the quartiles, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep in mind the same result could have been computed more simply with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'These were equal-length buckets; to compute equal-size buckets based on sample
    quantiles, use `pandas.qcut`. We can pass `4` as the number of bucket compute
    sample quartiles, and pass `labels=False` to obtain just the quartile indices
    instead of intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: Filling Missing Values with Group-Specific Values'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When cleaning up missing data, in some cases you will remove data observations
    using `dropna`, but in others you may want to fill in the null (NA) values using
    a fixed value or some value derived from the data. `fillna` is the right tool
    to use; for example, here I fill in the null values with the mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you need the fill value to vary by group. One way to do this is to
    group the data and use `apply` with a function that calls `fillna` on each data
    chunk. Here is some sample data on US states divided into eastern and western
    regions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s set some values in the data to be missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can fill the NA values using the group means, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In another case, you might have predefined fill values in your code that vary
    by group. Since the groups have a `name` attribute set internally, we can use
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: Random Sampling and Permutation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose you wanted to draw a random sample (with or without replacement) from
    a large dataset for Monte Carlo simulation purposes or some other application.
    There are a number of ways to perform the “draws”; here we use the `sample` method
    for Series.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, here’s a way to construct a deck of English-style playing cards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a Series of length 52 whose index contains card names, and values
    are the ones used in blackjack and other games (to keep things simple, I let the
    ace `"A"` be 1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, based on what I said before, drawing a hand of five cards from the deck
    could be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you wanted two random cards from each suit. Because the suit is the
    last character of each card name, we can group based on this and use `apply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we could pass `group_keys=False` to drop the outer suit index,
    leaving in just the selected cards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: Group Weighted Average and Correlation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Under the split-apply-combine paradigm of `groupby`, operations between columns
    in a DataFrame or two Series, such as a group weighted average, are possible.
    As an example, take this dataset containing group keys, values, and some weights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The weighted average by `category` would then be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'As another example, consider a financial dataset originally obtained from Yahoo!
    Finance containing end-of-day prices for a few stocks and the S&P 500 index (the
    `SPX` symbol):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The DataFrame `info()` method here is a convenient way to get an overview of
    the contents of a DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: 'One task of interest might be to compute a DataFrame consisting of the yearly
    correlations of daily returns (computed from percent changes) with `SPX`. As one
    way to do this, we first create a function that computes the pair-wise correlation
    of each column with the `"SPX"` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we compute percent change on `close_px` using `pct_change`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we group these percent changes by year, which can be extracted from
    each row label with a one-line function that returns the `year` attribute of each
    `datetime` label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also compute intercolumn correlations. Here we compute the annual
    correlation between Apple and Microsoft:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: Group-Wise Linear Regression'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the same theme as the previous example, you can use `groupby` to perform
    more complex group-wise statistical analysis, as long as the function returns
    a pandas object or scalar value. For example, I can define the following `regress`
    function (using the `statsmodels` econometrics library), which executes an ordinary
    least squares (OLS) regression on each chunk of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'You can install `statsmodels` with conda if you don''t have it already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to run a yearly linear regression of `AAPL` on `SPX` returns, execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 10.4 Group Transforms and "Unwrapped" GroupBys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Apply: General split-apply-combine](#groupby_apply), we looked at the `apply`
    method in grouped operations for performing transformations. There is another
    built-in method called `transform`, which is similar to `apply` but imposes more
    constraints on the kind of function you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: It can produce a scalar value to be broadcast to the shape of the group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can produce an object of the same shape as the input group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must not mutate its input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s consider a simple example for illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the group means by key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose instead we wanted to produce a Series of the same shape as `df[''value'']`
    but with values replaced by the average grouped by `''key''`. We can pass a function
    that computes the mean of a single group to `transform`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'For built-in aggregation functions, we can pass a string alias as with the
    GroupBy `agg` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Like `apply`, `transform` works with functions that return Series, but the
    result must be the same size as the input. For example, we can multiply each group
    by 2 using a helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'As a more complicated example, we can compute the ranks in descending order
    for each group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider a group transformation function composed from simple aggregations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We can obtain equivalent results in this case using either `transform` or `apply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Built-in aggregate functions like `''mean''` or `''sum''` are often much faster
    than a general `apply` function. These also have a "fast path" when used with
    `transform`. This allows us to perform what is called an *unwrapped* group operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are doing arithmetic between the outputs of multiple GroupBy operations
    instead of writing a function and passing it to `groupby(...).apply`. That is
    what is meant by "unwrapped."
  prefs: []
  type: TYPE_NORMAL
- en: While an unwrapped group operation may involve multiple group aggregations,
    the overall benefit of vectorized operations often outweighs this.
  prefs: []
  type: TYPE_NORMAL
- en: 10.5 Pivot Tables and Cross-Tabulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *pivot table* is a data summarization tool frequently found in spreadsheet
    programs and other data analysis software. It aggregates a table of data by one
    or more keys, arranging the data in a rectangle with some of the group keys along
    the rows and some along the columns. Pivot tables in Python with pandas are made
    possible through the `groupby` facility described in this chapter, combined with
    reshape operations utilizing hierarchical indexing. DataFrame also has a `pivot_table`
    method, and there is also a top-level `pandas.pivot_table` function. In addition
    to providing a convenience interface to `groupby`, `pivot_table` can add partial
    totals, also known as *margins*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the tipping dataset, suppose you wanted to compute a table of
    group means (the default `pivot_table` aggregation type) arranged by `day` and
    `smoker` on the rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This could have been produced with `groupby` directly, using `tips.groupby(["day",
    "smoker"]).mean()`. Now, suppose we want to take the average of only `tip_pct`
    and `size`, and additionally group by `time`. I’ll put `smoker` in the table columns
    and `time` and `day` in the rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We could augment this table to include partial totals by passing `margins=True`.
    This has the effect of adding `All` row and column labels, with corresponding
    values being the group statistics for all the data within a single tier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `All` values are means without taking into account smoker versus non-smoker
    (the `All` columns) or any of the two levels of grouping on the rows (the `All`
    row).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use an aggregation function other than `mean`, pass it to the `aggfunc`
    keyword argument. For example, `"count"` or `len` will give you a cross-tabulation
    (count or frequency) of group sizes (though `"count"` will exclude null values
    from the count within data groups, while `len` will not):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'If some combinations are empty (or otherwise NA), you may wish to pass a `fill_value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: See [Table 10.2](#tbl-table_pivot_table) for a summary of `pivot_table` options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10.2: `pivot_table` options'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `values` | Column name or names to aggregate; by default, aggregates all
    numeric columns |'
  prefs: []
  type: TYPE_TB
- en: '| `index` | Column names or other group keys to group on the rows of the resulting
    pivot table |'
  prefs: []
  type: TYPE_TB
- en: '| `columns` | Column names or other group keys to group on the columns of the
    resulting pivot table |'
  prefs: []
  type: TYPE_TB
- en: '| `aggfunc` | Aggregation function or list of functions (`"mean"` by default);
    can be any function valid in a `groupby` context |'
  prefs: []
  type: TYPE_TB
- en: '| `fill_value` | Replace missing values in the result table |'
  prefs: []
  type: TYPE_TB
- en: '| `dropna` | If `True`, do not include columns whose entries are all `NA` |'
  prefs: []
  type: TYPE_TB
- en: '| `margins` | Add row/column subtotals and grand total (`False` by default)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `margins_name` | Name to use for the margin row/column labels when passing
    `margins=True`; defaults to `"All"` |'
  prefs: []
  type: TYPE_TB
- en: '| `observed` | With Categorical group keys, if `True`, show only the observed
    category values in the keys rather than all categories |'
  prefs: []
  type: TYPE_TB
- en: 'Cross-Tabulations: Crosstab'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *cross-tabulation* (or *crosstab* for short) is a special case of a pivot
    table that computes group frequencies. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'As part of some survey analysis, we might want to summarize this data by nationality
    and handedness. You could use `pivot_table` to do this, but the `pandas.crosstab`
    function can be more convenient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two arguments to `crosstab` can each be an array or Series or a list
    of arrays. As in the tips data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 10.6 Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mastering pandas''s data grouping tools can help with data cleaning and modeling
    or statistical analysis work. In [Ch 13: Data Analysis Examples](#data-analysis-examples)
    we will look at several more example use cases for `groupby` on real data.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we turn our attention to time series data.***
  prefs: []
  type: TYPE_NORMAL
