- en: Appendix B — More on the IPython System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 B — 关于 IPython 系统的更多内容
- en: 原文：[https://wesmckinney.com/book/ipython](https://wesmckinney.com/book/ipython)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://wesmckinney.com/book/ipython](https://wesmckinney.com/book/ipython)
- en: '*This Open Access web version of *Python for Data Analysis 3rd Edition* is
    now available as a companion to the [print and digital editions](https://amzn.to/3DyLaJc).
    If you encounter any errata, [please report them here](https://oreilly.com/catalog/0636920519829/errata).
    Please note that some aspects of this site as produced by Quarto will differ from
    the formatting of the print and eBook versions from O’Reilly.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个开放获取的网络版本 *Python for Data Analysis 3rd Edition* 现在作为 [印刷版和数字版](https://amzn.to/3DyLaJc)
    的伴侣可用。如果您发现任何勘误，请[在此报告](https://oreilly.com/catalog/0636920519829/errata)。请注意，由
    Quarto 生成的本站的某些方面与 O''Reilly 的印刷版和电子书版本的格式不同。'
- en: 'If you find the online edition of the book useful, please consider [ordering
    a paper copy](https://amzn.to/3DyLaJc) or a [DRM-free eBook](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)
    to support the author. The content from this website may not be copied or reproduced.
    The code examples are MIT licensed and can be found on GitHub or Gitee.*  *In
    [Ch 2: Python Language Basics, IPython, and Jupyter Notebooks](/book/python-basics)
    we looked at the basics of using the IPython shell and Jupyter notebook. In this
    appendix, we explore some deeper functionality in the IPython system that can
    either be used from the console or within Jupyter.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现本书的在线版本有用，请考虑[订购纸质版](https://amzn.to/3DyLaJc)或[无 DRM 电子书](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)以支持作者。本网站的内容不得复制或复制。代码示例采用
    MIT 许可，可在 GitHub 或 Gitee 上找到。* *在[第 2 章：Python 语言基础，IPython 和 Jupyter 笔记本](/book/python-basics)中，我们讨论了使用
    IPython shell 和 Jupyter 笔记本的基础知识。在本附录中，我们探索了 IPython 系统中的一些更深层次功能，可以从控制台或 Jupyter
    中使用。
- en: B.1 Terminal Keyboard Shortcuts
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.1 终端键盘快捷键
- en: IPython has many keyboard shortcuts for navigating the prompt (which will be
    familiar to users of the Emacs text editor or the Unix bash shell) and interacting
    with the shell’s command history. [Table B.1](#tbl-table_kbd_shortcuts) summarizes
    some of the most commonly used shortcuts. See [Figure B.1](#fig-figure_ipython_keyboard)
    for an illustration of a few of these, such as cursor movement.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 有许多用于导航提示的键盘快捷键（这些快捷键对于 Emacs 文本编辑器或 Unix bash shell 的用户来说是熟悉的），并与 shell
    的命令历史交互。[表 B.1](#tbl-table_kbd_shortcuts) 总结了一些最常用的快捷键。请参阅[图 B.1](#fig-figure_ipython_keyboard)
    以查看其中一些示例，如光标移动。
- en: 'Table B.1: Standard IPython keyboard shortcuts'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 表 B.1：标准 IPython 键盘快捷键
- en: '| Keyboard shortcut | Description |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 键盘快捷键 | 描述 |'
- en: '| --- | --- |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Ctrl-P or up-arrow | Search backward in command history for commands starting
    with currently entered text |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| Ctrl-P 或向上箭头 | 在命令历史中向后搜索以当前输入文本开头的命令 |'
- en: '| Ctrl-N or down-arrow | Search forward in command history for commands starting
    with currently entered text |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| Ctrl-N 或向下箭头 | 在命令历史中向前搜索以当前输入文本开头的命令 |'
- en: '| Ctrl-R | Readline-style reverse history search (partial matching) |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| Ctrl-R | Readline 风格的反向历史搜索（部分匹配） |'
- en: '| Ctrl-Shift-V | Paste text from clipboard |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| Ctrl-Shift-V | 从剪贴板粘贴文本 |'
- en: '| Ctrl-C | Interrupt currently executing code |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| Ctrl-C | 中断当前正在执行的代码 |'
- en: '| Ctrl-A | Move cursor to beginning of line |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| Ctrl-A | 将光标移动到行首 |'
- en: '| Ctrl-E | Move cursor to end of line |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| Ctrl-E | 将光标移动到行尾 |'
- en: '| Ctrl-K | Delete text from cursor until end of line |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| Ctrl-K | 从光标处删除文本直到行尾 |'
- en: '| Ctrl-U | Discard all text on current line |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| Ctrl-U | 放弃当前行上的所有文本 |'
- en: '| Ctrl-F | Move cursor forward one character |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| Ctrl-F | 将光标向前移动一个字符 |'
- en: '| Ctrl-B | Move cursor back one character |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| Ctrl-B | 将光标向后移动一个字符 |'
- en: '| Ctrl-L | Clear screen |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| Ctrl-L | 清屏 |'
- en: '![](../Images/195715a4c5d3641a804058ec12414e68.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/195715a4c5d3641a804058ec12414e68.png)'
- en: 'Figure B.1: Illustration of some keyboard shortcuts in the IPython shell'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 B.1：IPython shell 中一些键盘快捷键的示例
- en: Note that Jupyter notebooks have a largely separate set of keyboard shortcuts
    for navigation and editing. Since these shortcuts have evolved more rapidly than
    the ones in IPython, I encourage you to explore the integrated help system in
    the Jupyter notebook menus.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Jupyter 笔记本有一个完全独立的键盘快捷键集用于导航和编辑。由于这些快捷键的发展速度比 IPython 中的快捷键更快，我鼓励您探索 Jupyter
    笔记本菜单中的集成帮助系统。
- en: B.2 About Magic Commands
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.2 关于魔术命令
- en: 'Special commands in IPython (which are not built into Python itself) are known
    as *magic* commands. These are designed to facilitate common tasks and enable
    you to easily control the behavior of the IPython system. A magic command is any
    command prefixed by the percent symbol `%`. For example, you can check the execution
    time of any Python statement, such as a matrix multiplication, using the `%timeit`
    magic function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 中的特殊命令（这些命令不是 Python 本身的一部分）被称为*魔术*命令。这些命令旨在简化常见任务，并使您能够轻松控制 IPython
    系统的行为。魔术命令是以百分号 `%` 为前缀的任何命令。例如，您可以使用 `%timeit` 魔术函数检查任何 Python 语句（如矩阵乘法）的执行时间：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Magic commands can be viewed as command-line programs to be run within the
    IPython system. Many of them have additional “command-line” options, which can
    all be viewed (as you might expect) using `?`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '魔术命令可以被视为在 IPython 系统中运行的命令行程序。其中许多具有额外的“命令行”选项，所有这些选项都可以使用 `?` 查看（正如您可能期望的那样）： '
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Magic functions can be used by default without the percent sign, as long as
    no variable is defined with the same name as the magic function in question. This
    feature is called *automagic* and can be enabled or disabled with `%automagic`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 魔术函数可以默认使用，无需百分号，只要没有定义与所讨论的魔术函数同名的变量。这个功能称为*自动魔术*，可以通过 `%automagic` 启用或禁用。
- en: 'Some magic functions behave like Python functions, and their output can be
    assigned to a variable:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一些魔术函数的行为类似于 Python 函数，它们的输出可以分配给一个变量：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since IPython’s documentation is accessible from within the system, I encourage
    you to explore all of the special commands available by using `%quickref` or `%magic`.
    This information is shown in a console pager, so you will need to press `q` to
    exit from the pager. [Table B.2](#tbl-ipython_magic_table) highlights some of
    the most critical commands for being productive in interactive computing and Python
    development in IPython.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IPython的文档可以从系统内部访问，我鼓励您使用`%quickref`或`%magic`来探索所有可用的特殊命令。此信息显示在控制台分页器中，因此您需要按`q`键退出分页器。[表B.2](#tbl-ipython_magic_table)突出显示了在IPython中进行交互式计算和Python开发时最关键的一些命令。
- en: 'Table B.2: Some frequently used IPython magic commands'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 表B.2：一些经常使用的IPython魔术命令
- en: '| Command | Description |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `%quickref` | Display the IPython Quick Reference Card |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `%quickref` | 显示IPython快速参考卡 |'
- en: '| `%magic` | Display detailed documentation for all of the available magic
    commands |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `%magic` | 显示所有可用魔术命令的详细文档 |'
- en: '| `%debug` | Enter the interactive debugger at the bottom of the last exception
    traceback |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `%debug` | 进入最后一个异常回溯底部的交互式调试器 |'
- en: '| `%hist` | Print command input (and optionally output) history |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `%hist` | 打印命令输入（和可选输出）历史记录 |'
- en: '| `%pdb` | Automatically enter debugger after any exception |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `%pdb` | 在任何异常后自动进入调试器 |'
- en: '| `%paste` | Execute preformatted Python code from clipboard |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `%paste` | 从剪贴板执行预格式化的Python代码 |'
- en: '| `%cpaste` | Open a special prompt for manually pasting Python code to be
    executed |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `%cpaste` | 打开一个特殊提示，用于手动粘贴要执行的Python代码 |'
- en: '| `%reset` | Delete all variables/names defined in an interactive namespace
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `%reset` | 删除交互式命名空间中定义的所有变量/名称 |'
- en: '| `%page` <OBJECT> | Pretty-print the object and display it through a pager
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `%page` <OBJECT> | 对对象进行漂亮打印并通过分页器显示 |'
- en: '| `%run` <script.py> | Run a Python script inside IPython |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `%run` <script.py> | 在IPython内部运行Python脚本 |'
- en: '| `%prun` <statement> | Execute <statement> with `cProfile` and report the
    profiler output |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `%prun` <statement> | 使用`cProfile`执行<statement>并报告分析器输出 |'
- en: '| `%time` <statement> | Report the execution time of a single statement |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `%time` <statement> | 报告单个语句的执行时间 |'
- en: '| `%timeit` <statement> | Run a statement multiple times to compute an ensemble
    average execution time; useful for timing code with very short execution time
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `%timeit` <statement> | 多次运行语句以计算集合平均执行时间；用于计时执行时间非常短的代码 |'
- en: '| `%who, %who_ls, %whos` | Display variables defined in interactive namespace,
    with varying levels of information/verbosity |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `%who, %who_ls, %whos` | 显示交互式命名空间中定义的变量，具有不同级别的信息/详细程度 |'
- en: '| `%xdel` <variable> | Delete a variable and attempt to clear any references
    to the object in the IPython internals |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `%xdel` <variable> | 删除变量并尝试清除IPython内部对该对象的任何引用 |'
- en: The %run Command
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '%run命令'
- en: 'You can run any file as a Python program inside the environment of your IPython
    session using the `%run` command. Suppose you had the following simple script
    stored in *script.py*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`%run`命令在IPython会话的环境中运行任何文件作为Python程序。假设您在*script.py*中存储了以下简单脚本：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can execute this by passing the filename to `%run`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将文件名传递给`%run`来执行此操作：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The script is run in an *empty namespace* (with no imports or other variables
    defined), so that the behavior should be identical to running the program on the
    command line using `python script.py`. All of the variables (imports, functions,
    and globals) defined in the file (up until an exception, if any, is raised) will
    then be accessible in the IPython shell:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本在*空命名空间*中运行（没有导入或其他变量定义），因此行为应与在命令行上使用`python script.py`运行程序相同。然后，文件中定义的所有变量（导入、函数和全局变量）（直到引发异常（如果有））将在IPython
    shell中可访问：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If a Python script expects command-line arguments (to be found in `sys.argv`),
    these can be passed after the file path as though run on the command line.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Python脚本需要命令行参数（可以在`sys.argv`中找到），这些参数可以在文件路径之后传递，就像在命令行上运行一样。
- en: '*Note* *If you want to give a script access to variables already defined in
    the interactive IPython namespace, use `%run -i` instead of plain `%run`.*  *In
    the Jupyter notebook, you can also use the related `%load` magic function, which
    imports a script into a code cell:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *如果要让脚本访问已在交互式IPython命名空间中定义的变量，请使用`%run -i`而不是普通的`%run`。* *在Jupyter笔记本中，您还可以使用相关的`%load`魔术函数，它将脚本导入到代码单元格中：'
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Interrupting running code
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 中断运行的代码
- en: Pressing Ctrl-C while any code is running, whether a script through `%run` or
    a long-running command, will raise a `KeyboardInterrupt`. This will cause nearly
    all Python programs to stop immediately except in certain unusual cases.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行任何代码时按下Ctrl-C，无论是通过`%run`运行脚本还是长时间运行的命令，都会引发`KeyboardInterrupt`。这将导致几乎所有Python程序立即停止，除非在某些不寻常的情况下。
- en: '*Warning* *When a piece of Python code has called into some compiled extension
    modules, pressing Ctrl-C will not always cause the program execution to stop immediately.
    In such cases, you will have to either wait until control is returned to the Python
    interpreter, or in more dire circumstances, forcibly terminate the Python process
    in your operating system (such as using Task Manager on Windows or the `kill`
    command on Linux).**  **### Executing Code from the Clipboard'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*警告* *当一段Python代码调用了一些编译的扩展模块时，按下Ctrl-C并不总是会立即停止程序执行。在这种情况下，您要么等待控制返回到Python解释器，要么在更严重的情况下，在您的操作系统中强制终止Python进程（例如在Windows上使用任务管理器或在Linux上使用`kill`命令）。**  **###
    从剪贴板执行代码'
- en: 'If you are using the Jupyter notebook, you can copy and paste code into any
    code cell and execute it. It is also possible to run code from the clipboard in
    the IPython shell. Suppose you had the following code in some other application:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Jupyter笔记本，您可以将代码复制粘贴到任何代码单元格中并执行。还可以在IPython shell中从剪贴板运行代码。假设您在其他应用程序中有以下代码：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The most foolproof methods are the `%paste` and `%cpaste` magic functions (note
    that these do not work in Jupyter since you can copy and paste into a Jupyter
    code cell). `%paste` takes whatever text is in the clipboard and executes it as
    a single block in the shell:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最可靠的方法是`％paste`和`％cpaste`魔术函数（请注意，这些在Jupyter中不起作用，因为您可以将文本复制并粘贴到Jupyter代码单元格中）。`％paste`获取剪贴板中的文本并将其作为单个块在shell中执行：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`%cpaste` is similar, except that it gives you a special prompt for pasting
    code into:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`％cpaste`类似，只是它为您提供了一个特殊的提示符，用于粘贴代码：'
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With the `%cpaste` block, you have the freedom to paste as much code as you
    like before executing it. You might decide to use `%cpaste` to look at the pasted
    code before executing it. If you accidentally paste the wrong code, you can break
    out of the `%cpaste` prompt by pressing Ctrl-C.**  **## B.3 Using the Command
    History
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`％cpaste`块，您可以在执行代码之前粘贴尽可能多的代码。您可能决定使用`％cpaste`在执行代码之前查看粘贴的代码。如果您意外粘贴了错误的代码，可以通过按Ctrl-C键来退出`％cpaste`提示符。**
    **## B.3 使用命令历史
- en: 'IPython maintains a small on-disk database containing the text of each command
    that you execute. This serves various purposes:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: IPython维护一个小型的磁盘数据库，其中包含您执行的每个命令的文本。这有各种用途：
- en: Searching, completing, and executing previously executed commands with minimal
    typing
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最少的键入搜索、完成和执行先前执行的命令
- en: Persisting the command history between sessions
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在会话之间保留命令历史
- en: Logging the input/output history to a file
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将输入/输出历史记录记录到文件中
- en: These features are more useful in the shell than in the notebook, since the
    notebook by design keeps a log of the input and output in each code cell.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能在shell中比在笔记本中更有用，因为笔记本通过设计在每个代码单元格中保留输入和输出的日志。
- en: Searching and Reusing the Command History
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索和重用命令历史记录
- en: 'The IPython shell lets you search and execute previous code or other commands.
    This is useful, as you may often find yourself repeating the same commands, such
    as a `%run` command or some other code snippet. Suppose you had run:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: IPython shell允许您搜索和执行以前的代码或其他命令。这很有用，因为您经常会发现自己重复执行相同的命令，例如`％run`命令或其他代码片段。假设您已运行：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: and then explored the results of the script (assuming it ran successfully),
    only to find that you made an incorrect calculation. After figuring out the problem
    and modifying *data_script.py*, you can start typing a few letters of the `%run`
    command and then press either the Ctrl-P key combination or the up arrow key.
    This will search the command history for the first prior command matching the
    letters you typed. Pressing either Ctrl-P or the up arrow key multiple times will
    continue to search through the history. If you pass over the command you wish
    to execute, fear not. You can move *forward* through the command history by pressing
    either Ctrl-N or the down arrow key. After doing this a few times, you may start
    pressing these keys without thinking!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后探索脚本的结果（假设它成功运行），只发现您进行了错误的计算。找出问题并修改*data_script.py*后，您可以开始键入`％run`命令的几个字母，然后按下Ctrl-P键组合或向上箭头键。这将搜索命令历史记录，找到与您键入的字母匹配的第一个先前命令。多次按下Ctrl-P或向上箭头键将继续搜索历史记录。如果您错过了要执行的命令，不要担心。您可以通过按下Ctrl-N或向下箭头键来*向前*浏览命令历史记录。几次这样做后，您可能会开始在不经思考的情况下按下这些键！
- en: 'Using Ctrl-R gives you the same partial incremental searching capability provided
    by the `readline` used in Unix-style shells, such as the bash shell. On Windows,
    `readline` functionality is emulated by IPython. To use this, press Ctrl-R and
    then type a few characters contained in the input line you want to search for:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ctrl-R会为您提供与Unix风格shell中使用的`readline`相同的部分增量搜索功能，例如bash shell。在Windows上，IPython通过模拟`readline`功能来实现。要使用此功能，请按Ctrl-R，然后键入要搜索的输入行中包含的几个字符：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Pressing Ctrl-R will cycle through the history for each line, matching the characters
    you’ve typed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 按下Ctrl-R将循环遍历每行的历史记录，匹配您键入的字符。
- en: Input and Output Variables
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入和输出变量
- en: 'Forgetting to assign the result of a function call to a variable can be very
    annoying. An IPython session stores references to *both* the input commands and
    output Python objects in special variables. The previous two outputs are stored
    in the `_` (one underscore) and `__` (two underscores) variables, respectively:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 忘记将函数调用的结果分配给变量可能非常恼人。IPython会将*输入命令和输出Python对象*的引用存储在特殊变量中。前两个输出分别存储在`_`（一个下划线）和`__`（两个下划线）变量中：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Input variables are stored in variables named `_iX`, where `X` is the input
    line number.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 输入变量存储在名为`_iX`的变量中，其中`X`是输入行号。
- en: 'For each input variable there is a corresponding output variable `_X`. So after
    input line 27, say, there will be two new variables, `_27` (for the output) and
    `_i27` for the input:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个输入变量，都有一个相应的输出变量`_X`。因此，在输入行27之后，将有两个新变量，`_27`（用于输出）和`_i27`（用于输入）：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since the input variables are strings, they can be executed again with the
    Python `eval` keyword:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于输入变量是字符串，因此可以使用Python的`eval`关键字再次执行它们：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, `_i27` refers to the code input in `In [27]`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`_i27`指的是`In [27]`中输入的代码。
- en: Several magic functions allow you to work with the input and output history.
    `%hist` prints all or part of the input history, with or without line numbers.
    `%reset` clears the interactive namespace and optionally the input and output
    caches. The `%xdel` magic function removes all references to a *particular* object
    from the IPython machinery. See the documentation for these magics for more details.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 几个魔术函数允许您使用输入和输出历史记录。`％hist`打印全部或部分输入历史记录，带或不带行号。`％reset`清除交互式命名空间，可选地清除输入和输出缓存。`％xdel`魔术函数从IPython机制中删除对*特定*对象的所有引用。有关这些魔术的更多详细信息，请参阅文档。
- en: '*Warning* *When working with very large datasets, keep in mind that IPython’s
    input and output history may cause objects referenced there to not be garbage
    collected (freeing up the memory), even if you delete the variables from the interactive
    namespace using the `del` keyword. In such cases, careful usage of `%xdel` and
    `%reset` can help you avoid running into memory problems.*  *## B.4 Interacting
    with the Operating System'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*警告* *在处理非常大的数据集时，请记住IPython的输入和输出历史可能导致其中引用的对象不会被垃圾回收（释放内存），即使您使用`del`关键字从交互式命名空间中删除变量。在这种情况下，谨慎使用`%xdel`和`%reset`可以帮助您避免遇到内存问题。*  *##
    B.4 与操作系统交互'
- en: Another feature of IPython is that it allows you to access the filesystem and
    operating system shell. This means, among other things, that you can perform most
    standard command-line actions as you would in the Windows or Unix (Linux, macOS)
    shell without having to exit IPython. This includes shell commands, changing directories,
    and storing the results of a command in a Python object (list or string). There
    are also command aliasing and directory bookmarking features.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: IPython的另一个特性是它允许您访问文件系统和操作系统shell。这意味着，您可以像在Windows或Unix（Linux，macOS）shell中一样执行大多数标准命令行操作，而无需退出IPython。这包括shell命令、更改目录以及将命令的结果存储在Python对象（列表或字符串）中。还有命令别名和目录标记功能。
- en: See [Table B.3](#tbl-table_system_commands) for a summary of magic functions
    and syntax for calling shell commands. I’ll briefly visit these features in the
    next few sections.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[表B.3](#tbl-table_system_commands)以获取调用shell命令的魔术函数和语法摘要。我将在接下来的几节中简要介绍这些功能。
- en: 'Table B.3: IPython system-related commands'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 表B.3：IPython与系统相关的命令
- en: '| Command | Description |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `!cmd` | Execute `cmd` in the system shell |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `!cmd` | 在系统shell中执行`cmd` |'
- en: '| `output = !cmd args` | Run `cmd` and store the stdout in `output` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `output = !cmd args` | 运行`cmd`并将stdout存储在`output`中 |'
- en: '| `%alias alias_name cmd` | Define an alias for a system (shell) command |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `%alias alias_name cmd` | 为系统（shell）命令定义别名 |'
- en: '| `%bookmark` | Utilize IPython’s directory bookmarking system |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `%bookmark` | 使用IPython的目录标记系统 |'
- en: '| `%cd` <directory> | Change system working directory to passed directory |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `%cd` <directory> | 将系统工作目录更改为传递的目录 |'
- en: '| `%pwd` | Return to the current system working directory |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `%pwd` | 返回当前系统工作目录 |'
- en: '| `%pushd` <directory> | Place current directory on stack and change to target
    directory |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `%pushd` <directory> | 将当前目录放入堆栈并切换到目标目录 |'
- en: '| `%popd` | Change to directory popped off the top of the stack |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `%popd` | 切换到堆栈顶部弹出的目录 |'
- en: '| `%dirs` | Return a list containing the current directory stack |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `%dirs` | 返回包含当前目录堆栈的列表 |'
- en: '| `%dhist` | Print the history of visited directories |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `%dhist` | 打印访问过的目录的历史记录 |'
- en: '| `%env` | Return the system environment variables as a dictionary |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `%env` | 将系统环境变量作为字典返回 |'
- en: '| `%matplotlib` | Configure matplotlib integration options |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `%matplotlib` | 配置matplotlib集成选项 |'
- en: Shell Commands and Aliases
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Shell命令和别名
- en: Starting a line in IPython with an exclamation point `!`, or bang, tells IPython
    to execute everything after the bang in the system shell. This means that you
    can delete files (using `rm` or `del`, depending on your OS), change directories,
    or execute any other process.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPython中以感叹号`!`开头的行告诉IPython在感叹号后执行系统shell中的所有内容。这意味着您可以删除文件（使用`rm`或`del`，取决于您的操作系统）、更改目录或执行任何其他进程。
- en: 'You can store the console output of a shell command in a variable by assigning
    the expression escaped with `!` to a variable. For example, on my Linux-based
    machine connected to the internet via Ethernet, I can get my IP address as a Python
    variable:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将用`!`转义的表达式分配给变量来存储shell命令的控制台输出。例如，在我连接到以太网上网的基于Linux的机器上，我可以将我的IP地址作为Python变量获取：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The returned Python object `ip_info` is actually a custom list type containing
    various versions of the console output.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的Python对象`ip_info`实际上是一个包含各种控制台输出版本的自定义列表类型。
- en: 'IPython can also substitute in Python values defined in the current environment
    when using `!`. To do this, preface the variable name with the dollar sign `$`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`!`时，IPython还可以在当前环境中定义的Python值进行替换。要做到这一点，请在变量名前加上美元符号`$`：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `%alias` magic function can define custom shortcuts for shell commands.
    As an example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`%alias`魔术函数可以为shell命令定义自定义快捷方式。例如：'
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can execute multiple commands just as on the command line by separating
    them with semicolons:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用分号将它们分隔来像在命令行上一样执行多个命令：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You’ll notice that IPython “forgets” any aliases you define interactively as
    soon as the session is closed. To create permanent aliases, you will need to use
    the configuration system.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，IPython在会话关闭后会“忘记”您交互定义的任何别名。要创建永久别名，您需要使用配置系统。
- en: Directory Bookmark System
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目录标记系统
- en: 'IPython has a directory bookmarking system to enable you to save aliases for
    common directories so that you can jump around easily. For example, suppose you
    wanted to create a bookmark that points to the supplementary materials for this
    book:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: IPython具有目录标记系统，使您可以保存常见目录的别名，以便您可以轻松跳转。例如，假设您想要创建一个指向本书补充材料的书签：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once you''ve done this, when you use the `%cd` magic, you can use any bookmarks
    you’ve defined:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，当您使用`%cd`魔术时，您可以使用您定义的任何书签：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If a bookmark name conflicts with a directory name in your current working
    directory, you can use the `-b` flag to override and use the bookmark location.
    Using the `-l` option with `%bookmark` lists all of your bookmarks:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果书签名称与当前工作目录中的目录名称冲突，您可以使用`-b`标志来覆盖并使用书签位置。使用`%bookmark`的`-l`选项列出所有书签：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Bookmarks, unlike aliases, are automatically persisted between IPython sessions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与别名不同，书签在IPython会话之间自动保留。
- en: B.5 Software Development Tools
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.5 软件开发工具
- en: In addition to being a comfortable environment for interactive computing and
    data exploration, IPython can also be a useful companion for general Python software
    development. In data analysis applications, it’s important first to have *correct*
    code. Fortunately, IPython has closely integrated and enhanced the built-in Python
    `pdb` debugger. Secondly, you want your code to be *fast*. For this, IPython has
    convenient integrated code timing and profiling tools. I will give an overview
    of these tools in detail here.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了作为交互式计算和数据探索的舒适环境外，IPython还可以成为一般Python软件开发的有用伴侣。在数据分析应用中，首先重要的是拥有*正确*的代码。幸运的是，IPython已经紧密集成并增强了内置的Python
    `pdb`调试器。其次，您希望您的代码*快速*。为此，IPython具有方便的集成代码计时和性能分析工具。我将在这里详细介绍这些工具。
- en: Interactive Debugger
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交互式调试器
- en: 'IPython’s debugger enhances `pdb` with tab completion, syntax highlighting,
    and context for each line in exception tracebacks. One of the best times to debug
    code is right after an error has occurred. The `%debug` command, when entered
    immediately after an exception, invokes the “postmortem” debugger and drops you
    into the stack frame where the exception was raised:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: IPython的调试器通过制表符补全、语法高亮显示和异常跟踪中每行的上下文增强了`pdb`。调试代码的最佳时机之一是在发生错误后立即进行调试。在异常发生后立即输入`%debug`命令会调用“事后”调试器，并将您放入引发异常的堆栈帧中：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once inside the debugger, you can execute arbitrary Python code and explore
    all of the objects and data (which have been “kept alive” by the interpreter)
    inside each stack frame. By default you start in the lowest level, where the error
    occurred. By typing `u` (up) and `d` (down), you can switch between the levels
    of the stack trace:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 进入调试器后，您可以执行任意Python代码并探索每个堆栈帧中的所有对象和数据（这些对象和数据由解释器“保持活动”）。默认情况下，您从发生错误的最低级别开始。通过输入`u`（向上）和`d`（向下），您可以在堆栈跟踪的级别之间切换：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Executing the `%pdb` command makes IPython automatically invoke the debugger
    after any exception, a mode that many users will find useful.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`%pdb`命令会使IPython在任何异常发生后自动调用调试器，这是许多用户会发现有用的模式。
- en: 'It’s also helpful to use the debugger when developing code, especially when
    you need to set a breakpoint or step through the execution of a function or script
    to examine its behavior at each step. There are several ways to accomplish this.
    The first is by using `%run` with the `-d` flag, which invokes the debugger before
    executing any code in the passed script. You must immediately type `s` (step)
    to enter the script:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发代码时使用调试器也很有帮助，特别是当您需要设置断点或逐步执行函数或脚本以检查每个步骤的行为时。有几种方法可以实现这一点。第一种方法是使用带有`-d`标志的`%run`，在执行传递的脚本中的任何代码之前调用调试器。您必须立即输入`s`（步进）以进入脚本：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After this point, it’s up to you how you want to work your way through the
    file. For example, in the preceding exception, we could set a breakpoint right
    before calling the `works_fine` function, and run the script until we reach the
    breakpoint by typing `c` (continue):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，您可以自行决定如何处理文件。例如，在前面的异常中，我们可以在调用`works_fine`函数之前设置断点，并通过输入`c`（继续）运行脚本直到达到断点：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At this point, you can `step` into `works_fine()` or execute `works_fine()`
    by typing `n` (next) to advance to the next line:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可以通过输入`n`（下一步）进入`works_fine()`或执行`works_fine()`以前进到下一行：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we could step into `throws_an_exception` and advance to the line where
    the error occurs and look at the variables in the scope. Note that debugger commands
    take precedence over variable names; in such cases, preface the variables with
    `!` to examine their contents:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以步入`throws_an_exception`并前进到发生错误的行，并查看作用域中的变量。请注意，调试器命令优先于变量名称；在这种情况下，使用`!`作为前缀来检查它们的内容：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In my experience, developing proficiency with the interactive debugger takes
    time and practice. See [Table B.4](#tbl-pdb_command_table) for a full catalog
    of the debugger commands. If you are accustomed to using an IDE, you might find
    the terminal-driven debugger to be a bit unforgiving at first, but that will improve
    in time. Some of the Python IDEs have excellent GUI debuggers, so most users can
    find something that works for them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，熟练掌握交互式调试器需要时间和实践。请参阅[表B.4](#tbl-pdb_command_table)以获取调试器命令的完整目录。如果您习惯使用IDE，您可能会发现基于终端的调试器一开始有点严格，但随着时间的推移会有所改善。一些Python
    IDE具有出色的GUI调试器，因此大多数用户都可以找到适合自己的工具。
- en: 'Table B.4: Python debugger commands'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 表B.4：Python调试器命令
- en: '| Command | Action |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 动作 |'
- en: '| --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `h(elp)` | Display command list |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `h(elp)` | 显示命令列表 |'
- en: '| `help` <command> | Show documentation for <command> |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `help` <command> | 显示<command>的文档 |'
- en: '| `c(ontinue)` | Resume program execution |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `c(ontinue)` | 恢复程序执行 |'
- en: '| `q(uit)` | Exit debugger without executing any more code |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `q(uit)` | 在不执行任何其他代码的情况下退出调试器 |'
- en: '| `b(reak)` <number> | Set breakpoint at <number> in current file |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `b(reak)` <number> | 在当前文件的<number>行设置断点 |'
- en: '| `b` <path/to/file.py:number> | Set breakpoint at line <number> in specified
    file |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `b` <path/to/file.py:number> | 在指定文件中的第<number>行设置断点 |'
- en: '| `s(tep)` | Step *into* function call |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `s(tep)` | 步入函数调用 |'
- en: '| `n(ext)` | Execute current line and advance to next line at current level
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `n(ext)` | 执行当前行并前进到当前级别的下一行 |'
- en: '| `u(p)`/`d(own)` | Move up/down in function call stack |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `u(p)`/`d(own)` | 在函数调用堆栈中向上/向下移动 |'
- en: '| `a(rgs)` | Show arguments for current function |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `a(rgs)` | 显示当前函数的参数 |'
- en: '| `debug` <statement> | Invoke statement <statement> in new (recursive) debugger
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `debug` <statement> | 在新的（递归）调试器中调用语句<statement> |'
- en: '| `l(ist)` <statement> | Show current position and context at current level
    of stack |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `l(ist)` <statement> | 显示当前位置和堆栈当前级别的上下文 |'
- en: '| `w(here)` | Print full stack trace with context at current position |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `w(here)` | 打印当前位置的完整堆栈跟踪上下文 |'
- en: Other ways to use the debugger
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调试器的其他用法
- en: 'There are a couple of other useful ways to invoke the debugger. The first is
    by using a special `set_trace` function (named after `pdb.set_trace`), which is
    basically a “poor man’s breakpoint.” Here are two small recipes you might want
    to put somewhere for your general use (potentially adding them to your IPython
    profile, as I do):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几种有用的调用调试器的方法。第一种是使用特殊的`set_trace`函数（以`pdb.set_trace`命名），基本上是一个“穷人的断点”。以下是两个您可能希望将其放在某处以供您一般使用的小技巧（可能将它们添加到您的IPython配置文件中，就像我做的那样）：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The first function, `set_trace`, provides a convenient way to put a breakpoint
    somewhere in your code. You can use a `set_trace` in any part of your code that
    you want to temporarily stop to examine it more closely (e.g., right before an
    exception occurs):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`set_trace`提供了一个方便的方法，在代码的某个地方设置断点。您可以在代码的任何部分使用`set_trace`，以便在需要临时停止以更仔细地检查它时使用（例如，在异常发生之前）：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Typing `c` (continue) will cause the code to resume normally with no harm done.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 键入`c`（继续）将使代码正常恢复，不会造成任何伤害。
- en: 'The `debug` function we just looked at enables you to invoke the interactive
    debugger easily on an arbitrary function call. Suppose we had written a function
    like the following, and we wished to step through its logic:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看过的`debug`函数使您可以轻松地在任意函数调用上调用交互式调试器。假设我们编写了一个类似以下内容的函数，并且希望逐步执行其逻辑：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Ordinarily using `f` would look like `f(1, 2, z=3)`. To instead step into `f`,
    pass `f` as the first argument to `debug`, followed by the positional and keyword
    arguments to be passed to `f`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用`f`看起来像`f(1, 2, z=3)`。要代替进入`f`，请将`f`作为`debug`的第一个参数传递，然后是要传递给`f`的位置参数和关键字参数：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These two recipes have saved me a lot of time over the years.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个技巧多年来为我节省了很多时间。
- en: 'Lastly, the debugger can be used in conjunction with `%run`. By running a script
    with `%run -d`, you will be dropped directly into the debugger, ready to set any
    breakpoints and start the script:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调试器可以与`％run`一起使用。通过使用`％run -d`运行脚本，您将直接进入调试器，准备设置任何断点并启动脚本：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Adding `-b` with a line number starts the debugger with a breakpoint set already:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 添加带有行号的`-b`会启动已经设置了断点的调试器：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Timing Code: %time and %timeit'
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计时代码：％time和％timeit
- en: For larger-scale or longer-running data analysis applications, you may wish
    to measure the execution time of various components or of individual statements
    or function calls. You may want a report of which functions are taking up the
    most time in a complex process. Fortunately, IPython enables you to get this information
    conveniently while you are developing and testing your code.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于规模较大或运行时间较长的数据分析应用程序，您可能希望测量各个组件或单个语句或函数调用的执行时间。您可能希望获得一个报告，其中列出了在复杂过程中占用最多时间的函数。幸运的是，IPython使您能够在开发和测试代码时方便地获取这些信息。
- en: 'Timing code by hand using the built-in `time` module and its functions, `time.clock`
    and `time.time`, is often tedious and repetitive, as you must write the same uninteresting
    boilerplate code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 手动使用内置的`time`模块及其函数`time.clock`和`time.time`来计时代码通常是乏味和重复的，因为您必须编写相同的无聊样板代码：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Since this is such a common operation, IPython has two magic functions, `%time`
    and `%timeit`, to automate this process for you.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个常见操作，IPython有两个魔术函数`％time`和`％timeit`，可以为您自动化这个过程。
- en: '`%time` runs a statement once, reporting the total execution time. Suppose
    we had a large list of strings, and we wanted to compare different methods of
    selecting all strings starting with a particular prefix. Here is a list of 600,000
    strings and two identical methods of selecting only the ones that start with `''foo''`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`％time`运行一次语句，报告总执行时间。假设我们有一个大型字符串列表，并且我们想比较不同方法选择所有以特定前缀开头的字符串。这里是一个包含600,000个字符串和两种相同方法的列表，只选择以`''foo''`开头的字符串：'
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It looks like they should be about the same performance-wise, right? We can
    check for sure using `%time`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来它们在性能上应该是一样的，对吧？我们可以使用`％time`来确保：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `Wall time` (short for "wall-clock time") is the main number of interest.
    From these timings, we can infer that there is some performance difference, but
    it''s not a very precise measurement. If you try `%time`-ing those statements
    multiple times yourself, you’ll find that the results are somewhat variable. To
    get a more precise measurement, use the `%timeit` magic function. Given an arbitrary
    statement, it has a heuristic to run a statement multiple times to produce a more
    accurate average runtime (these results may be different on your system):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wall time`（“墙钟时间”的缩写）是主要关注的数字。从这些时间中，我们可以推断出存在一些性能差异，但这不是一个非常精确的测量。如果您尝试自己多次`％time`这些语句，您会发现结果有些变化。要获得更精确的测量结果，请使用`％timeit`魔术函数。给定一个任意语句，它有一个启发式方法多次运行语句以产生更准确的平均运行时间（这些结果在您的系统上可能有所不同）：'
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This seemingly innocuous example illustrates that it is worth understanding
    the performance characteristics of the Python standard library, NumPy, pandas,
    and other libraries used in this book. In larger-scale data analysis applications,
    those milliseconds will start to add up!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看似无害的例子说明了值得了解Python标准库、NumPy、pandas和本书中使用的其他库的性能特征。在规模较大的数据分析应用程序中，这些毫秒将开始累积！
- en: '`%timeit` is especially useful for analyzing statements and functions with
    very short execution times, even at the level of microseconds (millionths of a
    second) or nanoseconds (billionths of a second). These may seem like insignificant
    amounts of time, but of course a 20-microsecond function invoked 1 million times
    takes 15 seconds longer than a 5-microsecond function. In the preceding example,
    we could very directly compare the two string operations to understand their performance
    characteristics:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`％timeit`特别适用于分析具有非常短执行时间的语句和函数，甚至可以到微秒（百万分之一秒）或纳秒（十亿分之一秒）的级别。这些可能看起来是微不足道的时间，但当然，一个耗时20微秒的函数被调用100万次比一个耗时5微秒的函数多花费15秒。在前面的例子中，我们可以直接比较这两个字符串操作以了解它们的性能特征：'
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Basic Profiling: %prun and %run -p'
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本分析：％prun和％run -p
- en: Profiling code is closely related to timing code, except it is concerned with
    determining *where* time is spent. The main Python profiling tool is the `cProfile`
    module, which is not specific to IPython at all. `cProfile` executes a program
    or any arbitrary block of code while keeping track of how much time is spent in
    each function.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 代码剖析与计时代码密切相关，只是它关注于确定时间花费在哪里。主要的Python剖析工具是`cProfile`模块，它与IPython没有特定关联。`cProfile`执行程序或任意代码块，同时跟踪每个函数中花费的时间。
- en: 'A common way to use `cProfile` is on the command line, running an entire program
    and outputting the aggregated time per function. Suppose we had a script that
    does some linear algebra in a loop (computing the maximum absolute eigenvalues
    of a series of 100 × 100 matrices):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上常用的一种使用`cProfile`的方式是运行整个程序并输出每个函数的聚合时间。假设我们有一个脚本，在循环中执行一些线性代数运算（计算一系列100×100矩阵的最大绝对特征值）：
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can run this script through `cProfile` using the following in the command
    line:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过命令行运行以下脚本来使用`cProfile`：
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you try that, you’ll find that the output is sorted by function name. This
    makes it a bit hard to get an idea of where the most time is spent, so it’s useful
    to specify a *sort order* using the `-s` flag:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试这样做，您会发现输出按函数名称排序。这使得很难了解大部分时间花费在哪里，因此使用`-s`标志指定*排序顺序*很有用：
- en: '[PRE41]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Only the first 15 rows of the output are shown. It’s easiest to read by scanning
    down the `cumtime` column to see how much total time was spent *inside* each function.
    Note that if a function calls some other function, *the clock does not stop running*.
    `cProfile` records the start and end time of each function call and uses that
    to produce the timing.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 仅显示输出的前15行。通过扫描`cumtime`列向下阅读，可以最轻松地看出每个函数内部花费了多少总时间。请注意，如果一个函数调用另一个函数，*时钟不会停止*。`cProfile`记录每个函数调用的开始和结束时间，并使用这些时间来生成时间。
- en: 'In addition to the command-line usage, `cProfile` can also be used programmatically
    to profile arbitrary blocks of code without having to run a new process. IPython
    has a convenient interface to this capability using the `%prun` command and the
    `-p` option to `%run`. `%prun` takes the same “command-line options” as `cProfile`
    but will profile an arbitrary Python statement instead of a whole *.py* file:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 除了命令行用法外，`cProfile`还可以以编程方式用于剖析任意代码块，而无需运行新进程。IPython具有方便的接口，可以使用`%prun`命令和`-p`选项来`%run`。`%prun`接受与`cProfile`相同的“命令行选项”，但会剖析一个任意的Python语句，而不是整个*.py*文件：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Similarly, calling `%run -p -s cumulative cprof_example.py` has the same effect
    as the command-line approach, except you never have to leave IPython.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，调用`%run -p -s cumulative cprof_example.py`具有与命令行方法相同的效果，只是您无需离开IPython。
- en: In the Jupyter notebook, you can use the `%%prun` magic (two `%` signs) to profile
    an entire code block. This pops up a separate window with the profile output.
    This can be useful in getting possibly quick answers to questions like, "Why did
    that code block take so long to run?"
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jupyter笔记本中，您可以使用`%%prun`魔术（两个`%`符号）来剖析整个代码块。这会弹出一个单独的窗口，显示剖析输出。这在获取可能快速答案的情况下很有用，比如“为什么那个代码块运行时间如此之长？”
- en: There are other tools available that help make profiles easier to understand
    when you are using IPython or Jupyter. One of these is [SnakeViz](https://github.com/jiffyclub/snakeviz/),
    which produces an interactive visualization of the profile results using D3.js.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用IPython或Jupyter时，还有其他可用的工具可帮助使剖析更易于理解。其中之一是[SnakeViz](https://github.com/jiffyclub/snakeviz/)，它使用D3.js生成剖析结果的交互式可视化。
- en: Profiling a Function Line by Line
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逐行剖析函数
- en: 'In some cases, the information you obtain from `%prun` (or another `cProfile`-based
    profile method) may not tell the whole story about a function’s execution time,
    or it may be so complex that the results, aggregated by function name, are hard
    to interpret. For this case, there is a small library called `line_profiler` (obtainable
    via PyPI or one of the package management tools). It contains an IPython extension
    enabling a new magic function `%lprun` that computes a line-by-line-profiling
    of one or more functions. You can enable this extension by modifying your IPython
    configuration (see the IPython documentation or the section on configuration later
    in this appendix) to include the following line:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您从`%prun`（或其他基于`cProfile`的剖析方法）获得的信息可能无法完全说明函数的执行时间，或者可能非常复杂，以至于按函数名称汇总的结果难以解释。对于这种情况，有一个名为`line_profiler`的小型库（可通过PyPI或其中一个软件包管理工具获取）。它包含一个IPython扩展，可以启用一个新的魔术函数`%lprun`，用于计算一个或多个函数的逐行剖析。您可以通过修改IPython配置（请参阅IPython文档或附录后面的配置部分）来启用此扩展，包括以下行：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can also run the command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以运行以下命令：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`line_profiler` can be used programmatically (see the full documentation),
    but it is perhaps most powerful when used interactively in IPython. Suppose you
    had a module `prof_mod` with the following code doing some NumPy array operations
    (if you want to reproduce this example, put this code into a new file *prof_mod.py*):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`line_profiler`可以以编程方式使用（请参阅完整文档），但在IPython中交互使用时可能效果最好。假设您有一个名为`prof_mod`的模块，其中包含执行一些NumPy数组操作的以下代码（如果要重现此示例，请将此代码放入一个新文件*prof_mod.py*中）：'
- en: '[PRE45]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If we wanted to understand the performance of the `add_and_sum` function, `%prun`
    gives us the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想了解`add_and_sum`函数的性能，`%prun`给出以下结果：
- en: '[PRE46]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is not especially enlightening. With the `line_profiler` IPython extension
    activated, a new command `%lprun` is available. The only difference in usage is
    that we must instruct `%lprun` which function or functions we wish to profile.
    The general syntax is:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不特别启发人。启用`line_profiler` IPython扩展后，将可用一个新命令`%lprun`。使用方式的唯一区别是我们必须指示`%lprun`要剖析哪个函数或函数。一般语法是：
- en: '[PRE47]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In this case, we want to profile `add_and_sum`, so we run:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们想要剖析`add_and_sum`，所以我们运行：
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This can be much easier to interpret. In this case, we profiled the same function
    we used in the statement. Looking at the preceding module code, we could call
    `call_function` and profile that as well as `add_and_sum`, thus getting a full
    picture of the performance of the code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能更容易解释。在这种情况下，我们对我们在语句中使用的相同函数进行了分析。查看前面的模块代码，我们可以调用`call_function`并对其进行分析，以及`add_and_sum`，从而获得代码性能的完整图片：
- en: '[PRE49]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As a general rule of thumb, I tend to prefer `%prun` (`cProfile`) for “macro”
    profiling, and `%lprun` (`line_profiler`) for “micro” profiling. It’s worthwhile
    to have a good understanding of both tools.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个一般准则，我倾向于使用`%prun`（`cProfile`）进行“宏”分析，以及`%lprun`（`line_profiler`）进行“微”分析。了解这两个工具是值得的。
- en: '*Note* *The reason that you must explicitly specify the names of the functions
    you want to profile with `%lprun` is that the overhead of “tracing” the execution
    time of each line is substantial. Tracing functions that are not of interest has
    the potential to significantly alter the profile results.*  *## B.6 Tips for Productive
    Code Development Using IPython'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *您必须明确指定要使用`%lprun`对其进行分析的函数名称的原因是“跟踪”每行的执行时间的开销很大。跟踪不感兴趣的函数可能会显著改变分析结果。*  *##
    B.6 使用IPython进行高效代码开发的提示'
- en: Writing code in a way that makes it convenient to develop, debug, and ultimately
    *use* interactively may be a paradigm shift for many users. There are procedural
    details like code reloading that may require some adjustment, as well as coding
    style concerns.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以一种方便开发、调试和最终*交互使用*的方式编写代码可能对许多用户来说是一种范式转变。有一些程序性细节，比如代码重新加载可能需要一些调整，以及编码风格方面的考虑。
- en: Therefore, implementing most of the strategies described in this section is
    more of an art than a science and will require some experimentation on your part
    to determine a way to write your Python code that is effective for you. Ultimately
    you want to structure your code in a way that makes it convenient to use iteratively
    and be able to explore the results of running a program or function as effortlessly
    as possible. I have found software designed with IPython in mind to be easier
    to work with than code intended only to be run as as standalone command-line application.
    This becomes especially important when something goes wrong and you have to diagnose
    an error in code that you or someone else might have written months or years beforehand.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实现本节中描述的大多数策略更多地是一种艺术而不是科学，需要您进行一些实验来确定一种对您有效的编写Python代码的方式。最终，您希望以一种方便的方式构建代码，以便进行迭代使用，并能够尽可能轻松地探索运行程序或函数的结果。我发现，专为IPython设计的软件比仅用作独立命令行应用程序运行的代码更容易使用。当出现问题并且您必须诊断您或其他人可能在几个月或几年前编写的代码中的错误时，这变得尤为重要。
- en: Reloading Module Dependencies
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新加载模块依赖项
- en: 'In Python, when you type `import some_lib`, the code in `some_lib` is executed,
    and all the variables, functions, and imports defined within are stored in the
    newly created `some_lib` module namespace. The next time you use `import some_lib`,
    you will get a reference to the existing module namespace. The potential difficulty
    in interactive IPython code development comes when you, say, `%run` a script that
    depends on some other module where you may have made changes. Suppose I had the
    following code in *test_script.py*:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，当您键入`import some_lib`时，将执行`some_lib`中的代码，并将在新创建的`some_lib`模块命名空间中存储定义的所有变量、函数和导入。下次使用`import
    some_lib`时，您将获得对现有模块命名空间的引用。在交互式IPython代码开发中可能出现困难的潜在问题是，当您运行依赖于其他模块的脚本时，您可能已经进行了更改。假设我在*test_script.py*中有以下代码：
- en: '[PRE50]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If you were to execute `%run test_script.py` then modify *some_lib.py*, the
    next time you execute `%run test_script.py` you will still get the *old version*
    of *some_lib.py* because of Python’s “load-once” module system. This behavior
    differs from some other data analysis environments, like MATLAB, which automatically
    propagate code changes.[¹](#fn1) To cope with this, you have a couple of options.
    The first way is to use the `reload` function in the `importlib` module in the
    standard library:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您执行`%run test_script.py`然后修改*some_lib.py*，下次执行`%run test_script.py`时，您仍将获得*some_lib.py*的*旧版本*，因为Python的“一次加载”模块系统。这种行为与其他一些数据分析环境（如MATLAB）不同，后者会自动传播代码更改。[¹](#fn1)
    为了应对这种情况，您有几种选择。第一种方法是使用标准库中的`importlib`模块中的`reload`函数：
- en: '[PRE51]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This attempts to give you a fresh copy of *some_lib.py* every time you run *test_script.py*
    (but there are some scenarios where it will not). Obviously, if the dependencies
    go deeper, it might be a bit tricky to be inserting usages of `reload` all over
    the place. For this problem, IPython has a special `dreload` function (*not* a
    magic function) for “deep” (recursive) reloading of modules. If I were to run
    *some_lib.py* then use `dreload(some_lib)`, it will attempt to reload `some_lib`
    as well as all of its dependencies. This will not work in all cases, unfortunately,
    but when it does, it beats having to restart IPython.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这尝试在每次运行*test_script.py*时为您提供*some_lib.py*的新副本（但也有一些情况下不会）。显然，如果依赖关系更深入，可能会在各个地方插入`reload`的用法有点棘手。对于这个问题，IPython有一个特殊的`dreload`函数（*不是*一个魔术函数）用于对模块进行“深”（递归）重新加载。如果我运行*some_lib.py*然后使用`dreload(some_lib)`，它将尝试重新加载`some_lib`以及其所有依赖项。不幸的是，这并不适用于所有情况，但当适用时，它比不得不重新启动IPython要好。
- en: Code Design Tips
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码设计提示
- en: There’s no simple recipe for this, but here are some high-level principles I
    have found effective in my own work.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有简单的配方，但以下是我在自己的工作中发现有效的一些高级原则。
- en: Keep relevant objects and data alive
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 保持相关对象和数据活动
- en: 'It’s not unusual to see a program written for the command line with a structure
    somewhat like the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 看到一个为命令行编写的程序的结构有点像下面这样并不罕见：
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Do you see what might go wrong if we were to run this program in IPython? After
    it’s done, none of the results or objects defined in the `main` function will
    be accessible in the IPython shell. A better way is to have whatever code is in
    `main` execute directly in the module’s global namespace (or in the `if __name__
    == '__main__':` block, if you want the module to also be importable). That way,
    when you `%run` the code, you’ll be able to look at all of the variables defined
    in `main`. This is equivalent to defining top-level variables in cells in the
    Jupyter notebook.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在IPython中运行这个程序，你能看出可能出现什么问题吗？完成后，`main`函数中定义的结果或对象将无法在IPython shell中访问。更好的方法是让`main`中的任何代码直接在模块的全局命名空间中执行（或者在`if
    __name__ == '__main__':`块中执行，如果你希望该模块也可以被导入）。这样，当你`%run`代码时，你将能够查看`main`中定义的所有变量。这相当于在Jupyter笔记本中的单元格中定义顶级变量。
- en: Flat is better than nested
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 扁平比嵌套更好
- en: Deeply nested code makes me think about the many layers of an onion. When testing
    or debugging a function, how many layers of the onion must you peel back in order
    to reach the code of interest? The idea that “flat is better than nested” is a
    part of the Zen of Python, and it applies generally to developing code for interactive
    use as well. Making functions and classes as decoupled and modular as possible
    makes them easier to test (if you are writing unit tests), debug, and use interactively.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 深度嵌套的代码让我想到洋葱的许多层。在测试或调试一个函数时，你必须剥开多少层洋葱才能到达感兴趣的代码？“扁平比嵌套更好”的想法是Python之禅的一部分，它也适用于为交互式使用开发代码。尽可能使函数和类解耦和模块化使它们更容易进行测试（如果你正在编写单元测试）、调试和交互使用。
- en: Overcome a fear of longer files
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 克服对更长文件的恐惧
- en: If you come from a Java (or another such language) background, you may have
    been told to keep files short. In many languages, this is sound advice; long length
    is usually a bad “code smell,” indicating refactoring or reorganization may be
    necessary. However, while developing code using IPython, working with 10 small
    but interconnected files (under, say, 100 lines each) is likely to cause you more
    headaches in general than 2 or 3 longer files. Fewer files means fewer modules
    to reload and less jumping between files while editing, too. I have found maintaining
    larger modules, each with high *internal* cohesion (the code all relates to solving
    the same kinds of problems), to be much more useful and Pythonic. After iterating
    toward a solution, of course it sometimes will make sense to refactor larger files
    into smaller ones.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自Java（或其他类似语言）背景，可能会被告知保持文件短小。在许多语言中，这是一个明智的建议；长长度通常是一个不好的“代码异味”，表明可能需要重构或重新组织。然而，在使用IPython开发代码时，处理10个小但相互关联的文件（每个文件不超过100行）通常会给你带来更多的头痛，而不是2或3个较长的文件。较少的文件意味着较少的模块需要重新加载，编辑时也减少了文件之间的跳转。我发现维护较大的模块，每个模块具有高度的*内部*内聚性（代码都涉及解决相同类型的问题），更加有用和符合Python风格。当朝着一个解决方案迭代时，当然有时将较大的文件重构为较小的文件是有意义的。
- en: Obviously, I don’t support taking this argument to the extreme, which would
    to be to put all of your code in a single monstrous file. Finding a sensible and
    intuitive module and package structure for a large codebase often takes a bit
    of work, but it is especially important to get right in teams. Each module should
    be internally cohesive, and it should be as obvious as possible where to find
    functions and classes responsible for each area of functionality.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我不支持将这个论点推向极端，即将所有代码放在一个庞大的文件中。为大型代码库找到一个明智和直观的模块和包结构通常需要一些工作，但在团队中正确地完成这一点尤为重要。每个模块应该在内部具有内聚性，并且应该尽可能明显地找到负责每个功能区域的函数和类。
- en: B.7 Advanced IPython Features
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.7 高级IPython功能
- en: Making full use of the IPython system may lead you to write your code in a slightly
    different way, or to dig into the configuration.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 充分利用IPython系统可能会导致你以稍微不同的方式编写代码，或者深入了解配置。
- en: Profiles and Configuration
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置文件和配置
- en: 'Most aspects of the appearance (colors, prompt, spacing between lines, etc.)
    and behavior of the IPython and Jupyter environments are configurable through
    an extensive configuration system. Here are some things you can do via configuration:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: IPython和Jupyter环境的外观（颜色、提示、行之间的间距等）和行为的大部分方面都可以通过一个广泛的配置系统进行配置。以下是一些可以通过配置完成的事项：
- en: Change the color scheme
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改颜色方案
- en: Change how the input and output prompts look, or remove the blank line after
    `Out` and before the next `In` prompt
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改输入和输出提示的外观，或者在`Out`之后和下一个`In`提示之前删除空行
- en: Execute an arbitrary list of Python statements (e.g., imports that you use all
    the time or anything else you want to happen each time you launch IPython)
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一系列Python语句（例如，你经常使用的导入或任何其他你希望每次启动IPython时发生的事情）
- en: Enable always-on IPython extensions, like the `%lprun` magic in `line_profiler`
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用始终开启的IPython扩展，比如`line_profiler`中的`%lprun`魔术
- en: Enable Jupyter extensions
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用Jupyter扩展
- en: Define your own magics or system aliases
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义你自己的魔术或系统别名
- en: 'Configurations for the IPython shell are specified in special *ipython_config.py*
    files, which are usually found in the *.ipython/* directory in your user home
    directory. Configuration is performed based on a particular *profile*. When you
    start IPython normally, you load up, by default, the *default profile*, stored
    in the *profile_default* directory. Thus, on my Linux OS, the full path to my
    default IPython configuration file is:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: IPython shell的配置在特殊的*ipython_config.py*文件中指定，这些文件通常位于用户主目录中的*.ipython/*目录中。配置是基于特定的*profile*执行的。当您正常启动IPython时，默认情况下会加载*default
    profile*，存储在*profile_default*目录中。因此，在我的Linux操作系统上，我的默认IPython配置文件的完整路径是：
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To initialize this file on your system, run this in the terminal:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的系统上初始化此文件，请在终端中运行：
- en: '[PRE54]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'I’ll spare you the complete details of what’s in this file. Fortunately, it
    has comments describing what each configuration option is for, so I will leave
    it to the reader to tinker and customize. One additional useful feature is that
    it’s possible to have *multiple profiles*. Suppose you wanted to have an alternative
    IPython configuration tailored for a particular application or project. Creating
    a new profile involves typing the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我将不会详细介绍此文件的内容。幸运的是，它有注释描述每个配置选项的用途，因此我将让读者自行调整和自定义。另一个有用的功能是可以拥有*多个配置文件*。假设您想要为特定应用程序或项目定制一个备用IPython配置。创建新配置涉及键入以下内容：
- en: '[PRE55]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Once you’ve done this, edit the config files in the newly created *profile_secret_project*
    directory and then launch IPython, like so:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，编辑新创建的*profile_secret_project*目录中的配置文件，然后启动IPython，如下所示：
- en: '[PRE56]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As always, the online IPython documentation is an excellent resource for more
    on profiles and configuration.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 与以往一样，在线IPython文档是了解更多有关配置文件和配置的绝佳资源。
- en: 'Configuration for Jupyter works a little differently because you can use its
    notebooks with languages other than Python. To create an analogous Jupyter config
    file, run:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter的配置略有不同，因为您可以将其笔记本与Python以外的语言一起使用。要创建类似的Jupyter配置文件，请运行：
- en: '[PRE57]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This writes a default config file to the *.jupyter/jupyter_notebook_config.py*
    directory in your home directory. After editing this to suit your needs, you may
    rename it to a different file, like:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的主目录中的*.jupyter/jupyter_notebook_config.py*目录中写入一个默认配置文件。编辑后，您可以将其重命名为不同的文件，例如：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'When launching Jupyter, you can then add the `--config` argument:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动Jupyter时，您可以添加`--config`参数：
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: B.8 Conclusion
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.8 结论
- en: As you work through the code examples in this book and grow your skills as a
    Python programmer, I encourage you to keep learning about the IPython and Jupyter
    ecosystems. Since these projects have been designed to assist user productivity,
    you may discover tools that enable you to do your work more easily than using
    the Python language and its computational libraries by themselves.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在本书中逐步学习代码示例并提高自己作为Python程序员的技能时，我鼓励您继续了解IPython和Jupyter生态系统。由于这些项目旨在帮助用户提高生产力，您可能会发现一些工具，使您比仅使用Python语言及其计算库更轻松地完成工作。
- en: You can also find a wealth of interesting Jupyter notebooks on the [nbviewer
    website](https://nbviewer.jupyter.org).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[nbviewer网站](https://nbviewer.jupyter.org)上找到大量有趣的Jupyter笔记本。
- en: '* * *'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Since a module or package may be imported in many different places in a particular
    program, Python caches a module’s code the first time it is imported rather than
    executing the code in the module every time. Otherwise, modularity and good code
    organization could potentially cause inefficiency in an application.[↩︎](#fnref1)*****
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于模块或包可能在特定程序的许多不同位置导入，Python在第一次导入模块时缓存模块的代码，而不是每次执行模块中的代码。否则，模块化和良好的代码组织可能会导致应用程序效率低下。
