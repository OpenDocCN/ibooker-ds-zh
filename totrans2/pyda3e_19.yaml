- en: Appendix B — More on the IPython System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://wesmckinney.com/book/ipython](https://wesmckinney.com/book/ipython)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This Open Access web version of *Python for Data Analysis 3rd Edition* is
    now available as a companion to the [print and digital editions](https://amzn.to/3DyLaJc).
    If you encounter any errata, [please report them here](https://oreilly.com/catalog/0636920519829/errata).
    Please note that some aspects of this site as produced by Quarto will differ from
    the formatting of the print and eBook versions from O’Reilly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you find the online edition of the book useful, please consider [ordering
    a paper copy](https://amzn.to/3DyLaJc) or a [DRM-free eBook](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)
    to support the author. The content from this website may not be copied or reproduced.
    The code examples are MIT licensed and can be found on GitHub or Gitee.*  *In
    [Ch 2: Python Language Basics, IPython, and Jupyter Notebooks](/book/python-basics)
    we looked at the basics of using the IPython shell and Jupyter notebook. In this
    appendix, we explore some deeper functionality in the IPython system that can
    either be used from the console or within Jupyter.'
  prefs: []
  type: TYPE_NORMAL
- en: B.1 Terminal Keyboard Shortcuts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IPython has many keyboard shortcuts for navigating the prompt (which will be
    familiar to users of the Emacs text editor or the Unix bash shell) and interacting
    with the shell’s command history. [Table B.1](#tbl-table_kbd_shortcuts) summarizes
    some of the most commonly used shortcuts. See [Figure B.1](#fig-figure_ipython_keyboard)
    for an illustration of a few of these, such as cursor movement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table B.1: Standard IPython keyboard shortcuts'
  prefs: []
  type: TYPE_NORMAL
- en: '| Keyboard shortcut | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-P or up-arrow | Search backward in command history for commands starting
    with currently entered text |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-N or down-arrow | Search forward in command history for commands starting
    with currently entered text |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-R | Readline-style reverse history search (partial matching) |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-Shift-V | Paste text from clipboard |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-C | Interrupt currently executing code |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-A | Move cursor to beginning of line |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-E | Move cursor to end of line |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-K | Delete text from cursor until end of line |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-U | Discard all text on current line |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-F | Move cursor forward one character |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-B | Move cursor back one character |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-L | Clear screen |'
  prefs: []
  type: TYPE_TB
- en: '![](../Images/195715a4c5d3641a804058ec12414e68.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure B.1: Illustration of some keyboard shortcuts in the IPython shell'
  prefs: []
  type: TYPE_NORMAL
- en: Note that Jupyter notebooks have a largely separate set of keyboard shortcuts
    for navigation and editing. Since these shortcuts have evolved more rapidly than
    the ones in IPython, I encourage you to explore the integrated help system in
    the Jupyter notebook menus.
  prefs: []
  type: TYPE_NORMAL
- en: B.2 About Magic Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Special commands in IPython (which are not built into Python itself) are known
    as *magic* commands. These are designed to facilitate common tasks and enable
    you to easily control the behavior of the IPython system. A magic command is any
    command prefixed by the percent symbol `%`. For example, you can check the execution
    time of any Python statement, such as a matrix multiplication, using the `%timeit`
    magic function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Magic commands can be viewed as command-line programs to be run within the
    IPython system. Many of them have additional “command-line” options, which can
    all be viewed (as you might expect) using `?`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Magic functions can be used by default without the percent sign, as long as
    no variable is defined with the same name as the magic function in question. This
    feature is called *automagic* and can be enabled or disabled with `%automagic`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some magic functions behave like Python functions, and their output can be
    assigned to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Since IPython’s documentation is accessible from within the system, I encourage
    you to explore all of the special commands available by using `%quickref` or `%magic`.
    This information is shown in a console pager, so you will need to press `q` to
    exit from the pager. [Table B.2](#tbl-ipython_magic_table) highlights some of
    the most critical commands for being productive in interactive computing and Python
    development in IPython.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table B.2: Some frequently used IPython magic commands'
  prefs: []
  type: TYPE_NORMAL
- en: '| Command | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `%quickref` | Display the IPython Quick Reference Card |'
  prefs: []
  type: TYPE_TB
- en: '| `%magic` | Display detailed documentation for all of the available magic
    commands |'
  prefs: []
  type: TYPE_TB
- en: '| `%debug` | Enter the interactive debugger at the bottom of the last exception
    traceback |'
  prefs: []
  type: TYPE_TB
- en: '| `%hist` | Print command input (and optionally output) history |'
  prefs: []
  type: TYPE_TB
- en: '| `%pdb` | Automatically enter debugger after any exception |'
  prefs: []
  type: TYPE_TB
- en: '| `%paste` | Execute preformatted Python code from clipboard |'
  prefs: []
  type: TYPE_TB
- en: '| `%cpaste` | Open a special prompt for manually pasting Python code to be
    executed |'
  prefs: []
  type: TYPE_TB
- en: '| `%reset` | Delete all variables/names defined in an interactive namespace
    |'
  prefs: []
  type: TYPE_TB
- en: '| `%page` <OBJECT> | Pretty-print the object and display it through a pager
    |'
  prefs: []
  type: TYPE_TB
- en: '| `%run` <script.py> | Run a Python script inside IPython |'
  prefs: []
  type: TYPE_TB
- en: '| `%prun` <statement> | Execute <statement> with `cProfile` and report the
    profiler output |'
  prefs: []
  type: TYPE_TB
- en: '| `%time` <statement> | Report the execution time of a single statement |'
  prefs: []
  type: TYPE_TB
- en: '| `%timeit` <statement> | Run a statement multiple times to compute an ensemble
    average execution time; useful for timing code with very short execution time
    |'
  prefs: []
  type: TYPE_TB
- en: '| `%who, %who_ls, %whos` | Display variables defined in interactive namespace,
    with varying levels of information/verbosity |'
  prefs: []
  type: TYPE_TB
- en: '| `%xdel` <variable> | Delete a variable and attempt to clear any references
    to the object in the IPython internals |'
  prefs: []
  type: TYPE_TB
- en: The %run Command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can run any file as a Python program inside the environment of your IPython
    session using the `%run` command. Suppose you had the following simple script
    stored in *script.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can execute this by passing the filename to `%run`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The script is run in an *empty namespace* (with no imports or other variables
    defined), so that the behavior should be identical to running the program on the
    command line using `python script.py`. All of the variables (imports, functions,
    and globals) defined in the file (up until an exception, if any, is raised) will
    then be accessible in the IPython shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If a Python script expects command-line arguments (to be found in `sys.argv`),
    these can be passed after the file path as though run on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note* *If you want to give a script access to variables already defined in
    the interactive IPython namespace, use `%run -i` instead of plain `%run`.*  *In
    the Jupyter notebook, you can also use the related `%load` magic function, which
    imports a script into a code cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Interrupting running code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pressing Ctrl-C while any code is running, whether a script through `%run` or
    a long-running command, will raise a `KeyboardInterrupt`. This will cause nearly
    all Python programs to stop immediately except in certain unusual cases.
  prefs: []
  type: TYPE_NORMAL
- en: '*Warning* *When a piece of Python code has called into some compiled extension
    modules, pressing Ctrl-C will not always cause the program execution to stop immediately.
    In such cases, you will have to either wait until control is returned to the Python
    interpreter, or in more dire circumstances, forcibly terminate the Python process
    in your operating system (such as using Task Manager on Windows or the `kill`
    command on Linux).**  **### Executing Code from the Clipboard'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using the Jupyter notebook, you can copy and paste code into any
    code cell and execute it. It is also possible to run code from the clipboard in
    the IPython shell. Suppose you had the following code in some other application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The most foolproof methods are the `%paste` and `%cpaste` magic functions (note
    that these do not work in Jupyter since you can copy and paste into a Jupyter
    code cell). `%paste` takes whatever text is in the clipboard and executes it as
    a single block in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`%cpaste` is similar, except that it gives you a special prompt for pasting
    code into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With the `%cpaste` block, you have the freedom to paste as much code as you
    like before executing it. You might decide to use `%cpaste` to look at the pasted
    code before executing it. If you accidentally paste the wrong code, you can break
    out of the `%cpaste` prompt by pressing Ctrl-C.**  **## B.3 Using the Command
    History
  prefs: []
  type: TYPE_NORMAL
- en: 'IPython maintains a small on-disk database containing the text of each command
    that you execute. This serves various purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Searching, completing, and executing previously executed commands with minimal
    typing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting the command history between sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging the input/output history to a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These features are more useful in the shell than in the notebook, since the
    notebook by design keeps a log of the input and output in each code cell.
  prefs: []
  type: TYPE_NORMAL
- en: Searching and Reusing the Command History
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The IPython shell lets you search and execute previous code or other commands.
    This is useful, as you may often find yourself repeating the same commands, such
    as a `%run` command or some other code snippet. Suppose you had run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: and then explored the results of the script (assuming it ran successfully),
    only to find that you made an incorrect calculation. After figuring out the problem
    and modifying *data_script.py*, you can start typing a few letters of the `%run`
    command and then press either the Ctrl-P key combination or the up arrow key.
    This will search the command history for the first prior command matching the
    letters you typed. Pressing either Ctrl-P or the up arrow key multiple times will
    continue to search through the history. If you pass over the command you wish
    to execute, fear not. You can move *forward* through the command history by pressing
    either Ctrl-N or the down arrow key. After doing this a few times, you may start
    pressing these keys without thinking!
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Ctrl-R gives you the same partial incremental searching capability provided
    by the `readline` used in Unix-style shells, such as the bash shell. On Windows,
    `readline` functionality is emulated by IPython. To use this, press Ctrl-R and
    then type a few characters contained in the input line you want to search for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Pressing Ctrl-R will cycle through the history for each line, matching the characters
    you’ve typed.
  prefs: []
  type: TYPE_NORMAL
- en: Input and Output Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Forgetting to assign the result of a function call to a variable can be very
    annoying. An IPython session stores references to *both* the input commands and
    output Python objects in special variables. The previous two outputs are stored
    in the `_` (one underscore) and `__` (two underscores) variables, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Input variables are stored in variables named `_iX`, where `X` is the input
    line number.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each input variable there is a corresponding output variable `_X`. So after
    input line 27, say, there will be two new variables, `_27` (for the output) and
    `_i27` for the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the input variables are strings, they can be executed again with the
    Python `eval` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, `_i27` refers to the code input in `In [27]`.
  prefs: []
  type: TYPE_NORMAL
- en: Several magic functions allow you to work with the input and output history.
    `%hist` prints all or part of the input history, with or without line numbers.
    `%reset` clears the interactive namespace and optionally the input and output
    caches. The `%xdel` magic function removes all references to a *particular* object
    from the IPython machinery. See the documentation for these magics for more details.
  prefs: []
  type: TYPE_NORMAL
- en: '*Warning* *When working with very large datasets, keep in mind that IPython’s
    input and output history may cause objects referenced there to not be garbage
    collected (freeing up the memory), even if you delete the variables from the interactive
    namespace using the `del` keyword. In such cases, careful usage of `%xdel` and
    `%reset` can help you avoid running into memory problems.*  *## B.4 Interacting
    with the Operating System'
  prefs: []
  type: TYPE_NORMAL
- en: Another feature of IPython is that it allows you to access the filesystem and
    operating system shell. This means, among other things, that you can perform most
    standard command-line actions as you would in the Windows or Unix (Linux, macOS)
    shell without having to exit IPython. This includes shell commands, changing directories,
    and storing the results of a command in a Python object (list or string). There
    are also command aliasing and directory bookmarking features.
  prefs: []
  type: TYPE_NORMAL
- en: See [Table B.3](#tbl-table_system_commands) for a summary of magic functions
    and syntax for calling shell commands. I’ll briefly visit these features in the
    next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table B.3: IPython system-related commands'
  prefs: []
  type: TYPE_NORMAL
- en: '| Command | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `!cmd` | Execute `cmd` in the system shell |'
  prefs: []
  type: TYPE_TB
- en: '| `output = !cmd args` | Run `cmd` and store the stdout in `output` |'
  prefs: []
  type: TYPE_TB
- en: '| `%alias alias_name cmd` | Define an alias for a system (shell) command |'
  prefs: []
  type: TYPE_TB
- en: '| `%bookmark` | Utilize IPython’s directory bookmarking system |'
  prefs: []
  type: TYPE_TB
- en: '| `%cd` <directory> | Change system working directory to passed directory |'
  prefs: []
  type: TYPE_TB
- en: '| `%pwd` | Return to the current system working directory |'
  prefs: []
  type: TYPE_TB
- en: '| `%pushd` <directory> | Place current directory on stack and change to target
    directory |'
  prefs: []
  type: TYPE_TB
- en: '| `%popd` | Change to directory popped off the top of the stack |'
  prefs: []
  type: TYPE_TB
- en: '| `%dirs` | Return a list containing the current directory stack |'
  prefs: []
  type: TYPE_TB
- en: '| `%dhist` | Print the history of visited directories |'
  prefs: []
  type: TYPE_TB
- en: '| `%env` | Return the system environment variables as a dictionary |'
  prefs: []
  type: TYPE_TB
- en: '| `%matplotlib` | Configure matplotlib integration options |'
  prefs: []
  type: TYPE_TB
- en: Shell Commands and Aliases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting a line in IPython with an exclamation point `!`, or bang, tells IPython
    to execute everything after the bang in the system shell. This means that you
    can delete files (using `rm` or `del`, depending on your OS), change directories,
    or execute any other process.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can store the console output of a shell command in a variable by assigning
    the expression escaped with `!` to a variable. For example, on my Linux-based
    machine connected to the internet via Ethernet, I can get my IP address as a Python
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The returned Python object `ip_info` is actually a custom list type containing
    various versions of the console output.
  prefs: []
  type: TYPE_NORMAL
- en: 'IPython can also substitute in Python values defined in the current environment
    when using `!`. To do this, preface the variable name with the dollar sign `$`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `%alias` magic function can define custom shortcuts for shell commands.
    As an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can execute multiple commands just as on the command line by separating
    them with semicolons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice that IPython “forgets” any aliases you define interactively as
    soon as the session is closed. To create permanent aliases, you will need to use
    the configuration system.
  prefs: []
  type: TYPE_NORMAL
- en: Directory Bookmark System
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'IPython has a directory bookmarking system to enable you to save aliases for
    common directories so that you can jump around easily. For example, suppose you
    wanted to create a bookmark that points to the supplementary materials for this
    book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve done this, when you use the `%cd` magic, you can use any bookmarks
    you’ve defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If a bookmark name conflicts with a directory name in your current working
    directory, you can use the `-b` flag to override and use the bookmark location.
    Using the `-l` option with `%bookmark` lists all of your bookmarks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Bookmarks, unlike aliases, are automatically persisted between IPython sessions.
  prefs: []
  type: TYPE_NORMAL
- en: B.5 Software Development Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to being a comfortable environment for interactive computing and
    data exploration, IPython can also be a useful companion for general Python software
    development. In data analysis applications, it’s important first to have *correct*
    code. Fortunately, IPython has closely integrated and enhanced the built-in Python
    `pdb` debugger. Secondly, you want your code to be *fast*. For this, IPython has
    convenient integrated code timing and profiling tools. I will give an overview
    of these tools in detail here.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive Debugger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'IPython’s debugger enhances `pdb` with tab completion, syntax highlighting,
    and context for each line in exception tracebacks. One of the best times to debug
    code is right after an error has occurred. The `%debug` command, when entered
    immediately after an exception, invokes the “postmortem” debugger and drops you
    into the stack frame where the exception was raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once inside the debugger, you can execute arbitrary Python code and explore
    all of the objects and data (which have been “kept alive” by the interpreter)
    inside each stack frame. By default you start in the lowest level, where the error
    occurred. By typing `u` (up) and `d` (down), you can switch between the levels
    of the stack trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Executing the `%pdb` command makes IPython automatically invoke the debugger
    after any exception, a mode that many users will find useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also helpful to use the debugger when developing code, especially when
    you need to set a breakpoint or step through the execution of a function or script
    to examine its behavior at each step. There are several ways to accomplish this.
    The first is by using `%run` with the `-d` flag, which invokes the debugger before
    executing any code in the passed script. You must immediately type `s` (step)
    to enter the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After this point, it’s up to you how you want to work your way through the
    file. For example, in the preceding exception, we could set a breakpoint right
    before calling the `works_fine` function, and run the script until we reach the
    breakpoint by typing `c` (continue):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you can `step` into `works_fine()` or execute `works_fine()`
    by typing `n` (next) to advance to the next line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we could step into `throws_an_exception` and advance to the line where
    the error occurs and look at the variables in the scope. Note that debugger commands
    take precedence over variable names; in such cases, preface the variables with
    `!` to examine their contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In my experience, developing proficiency with the interactive debugger takes
    time and practice. See [Table B.4](#tbl-pdb_command_table) for a full catalog
    of the debugger commands. If you are accustomed to using an IDE, you might find
    the terminal-driven debugger to be a bit unforgiving at first, but that will improve
    in time. Some of the Python IDEs have excellent GUI debuggers, so most users can
    find something that works for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table B.4: Python debugger commands'
  prefs: []
  type: TYPE_NORMAL
- en: '| Command | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `h(elp)` | Display command list |'
  prefs: []
  type: TYPE_TB
- en: '| `help` <command> | Show documentation for <command> |'
  prefs: []
  type: TYPE_TB
- en: '| `c(ontinue)` | Resume program execution |'
  prefs: []
  type: TYPE_TB
- en: '| `q(uit)` | Exit debugger without executing any more code |'
  prefs: []
  type: TYPE_TB
- en: '| `b(reak)` <number> | Set breakpoint at <number> in current file |'
  prefs: []
  type: TYPE_TB
- en: '| `b` <path/to/file.py:number> | Set breakpoint at line <number> in specified
    file |'
  prefs: []
  type: TYPE_TB
- en: '| `s(tep)` | Step *into* function call |'
  prefs: []
  type: TYPE_TB
- en: '| `n(ext)` | Execute current line and advance to next line at current level
    |'
  prefs: []
  type: TYPE_TB
- en: '| `u(p)`/`d(own)` | Move up/down in function call stack |'
  prefs: []
  type: TYPE_TB
- en: '| `a(rgs)` | Show arguments for current function |'
  prefs: []
  type: TYPE_TB
- en: '| `debug` <statement> | Invoke statement <statement> in new (recursive) debugger
    |'
  prefs: []
  type: TYPE_TB
- en: '| `l(ist)` <statement> | Show current position and context at current level
    of stack |'
  prefs: []
  type: TYPE_TB
- en: '| `w(here)` | Print full stack trace with context at current position |'
  prefs: []
  type: TYPE_TB
- en: Other ways to use the debugger
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are a couple of other useful ways to invoke the debugger. The first is
    by using a special `set_trace` function (named after `pdb.set_trace`), which is
    basically a “poor man’s breakpoint.” Here are two small recipes you might want
    to put somewhere for your general use (potentially adding them to your IPython
    profile, as I do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The first function, `set_trace`, provides a convenient way to put a breakpoint
    somewhere in your code. You can use a `set_trace` in any part of your code that
    you want to temporarily stop to examine it more closely (e.g., right before an
    exception occurs):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Typing `c` (continue) will cause the code to resume normally with no harm done.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `debug` function we just looked at enables you to invoke the interactive
    debugger easily on an arbitrary function call. Suppose we had written a function
    like the following, and we wished to step through its logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Ordinarily using `f` would look like `f(1, 2, z=3)`. To instead step into `f`,
    pass `f` as the first argument to `debug`, followed by the positional and keyword
    arguments to be passed to `f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: These two recipes have saved me a lot of time over the years.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, the debugger can be used in conjunction with `%run`. By running a script
    with `%run -d`, you will be dropped directly into the debugger, ready to set any
    breakpoints and start the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding `-b` with a line number starts the debugger with a breakpoint set already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Timing Code: %time and %timeit'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For larger-scale or longer-running data analysis applications, you may wish
    to measure the execution time of various components or of individual statements
    or function calls. You may want a report of which functions are taking up the
    most time in a complex process. Fortunately, IPython enables you to get this information
    conveniently while you are developing and testing your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Timing code by hand using the built-in `time` module and its functions, `time.clock`
    and `time.time`, is often tedious and repetitive, as you must write the same uninteresting
    boilerplate code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Since this is such a common operation, IPython has two magic functions, `%time`
    and `%timeit`, to automate this process for you.
  prefs: []
  type: TYPE_NORMAL
- en: '`%time` runs a statement once, reporting the total execution time. Suppose
    we had a large list of strings, and we wanted to compare different methods of
    selecting all strings starting with a particular prefix. Here is a list of 600,000
    strings and two identical methods of selecting only the ones that start with `''foo''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks like they should be about the same performance-wise, right? We can
    check for sure using `%time`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Wall time` (short for "wall-clock time") is the main number of interest.
    From these timings, we can infer that there is some performance difference, but
    it''s not a very precise measurement. If you try `%time`-ing those statements
    multiple times yourself, you’ll find that the results are somewhat variable. To
    get a more precise measurement, use the `%timeit` magic function. Given an arbitrary
    statement, it has a heuristic to run a statement multiple times to produce a more
    accurate average runtime (these results may be different on your system):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This seemingly innocuous example illustrates that it is worth understanding
    the performance characteristics of the Python standard library, NumPy, pandas,
    and other libraries used in this book. In larger-scale data analysis applications,
    those milliseconds will start to add up!
  prefs: []
  type: TYPE_NORMAL
- en: '`%timeit` is especially useful for analyzing statements and functions with
    very short execution times, even at the level of microseconds (millionths of a
    second) or nanoseconds (billionths of a second). These may seem like insignificant
    amounts of time, but of course a 20-microsecond function invoked 1 million times
    takes 15 seconds longer than a 5-microsecond function. In the preceding example,
    we could very directly compare the two string operations to understand their performance
    characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Basic Profiling: %prun and %run -p'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Profiling code is closely related to timing code, except it is concerned with
    determining *where* time is spent. The main Python profiling tool is the `cProfile`
    module, which is not specific to IPython at all. `cProfile` executes a program
    or any arbitrary block of code while keeping track of how much time is spent in
    each function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common way to use `cProfile` is on the command line, running an entire program
    and outputting the aggregated time per function. Suppose we had a script that
    does some linear algebra in a loop (computing the maximum absolute eigenvalues
    of a series of 100 × 100 matrices):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run this script through `cProfile` using the following in the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try that, you’ll find that the output is sorted by function name. This
    makes it a bit hard to get an idea of where the most time is spent, so it’s useful
    to specify a *sort order* using the `-s` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Only the first 15 rows of the output are shown. It’s easiest to read by scanning
    down the `cumtime` column to see how much total time was spent *inside* each function.
    Note that if a function calls some other function, *the clock does not stop running*.
    `cProfile` records the start and end time of each function call and uses that
    to produce the timing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the command-line usage, `cProfile` can also be used programmatically
    to profile arbitrary blocks of code without having to run a new process. IPython
    has a convenient interface to this capability using the `%prun` command and the
    `-p` option to `%run`. `%prun` takes the same “command-line options” as `cProfile`
    but will profile an arbitrary Python statement instead of a whole *.py* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, calling `%run -p -s cumulative cprof_example.py` has the same effect
    as the command-line approach, except you never have to leave IPython.
  prefs: []
  type: TYPE_NORMAL
- en: In the Jupyter notebook, you can use the `%%prun` magic (two `%` signs) to profile
    an entire code block. This pops up a separate window with the profile output.
    This can be useful in getting possibly quick answers to questions like, "Why did
    that code block take so long to run?"
  prefs: []
  type: TYPE_NORMAL
- en: There are other tools available that help make profiles easier to understand
    when you are using IPython or Jupyter. One of these is [SnakeViz](https://github.com/jiffyclub/snakeviz/),
    which produces an interactive visualization of the profile results using D3.js.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling a Function Line by Line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some cases, the information you obtain from `%prun` (or another `cProfile`-based
    profile method) may not tell the whole story about a function’s execution time,
    or it may be so complex that the results, aggregated by function name, are hard
    to interpret. For this case, there is a small library called `line_profiler` (obtainable
    via PyPI or one of the package management tools). It contains an IPython extension
    enabling a new magic function `%lprun` that computes a line-by-line-profiling
    of one or more functions. You can enable this extension by modifying your IPython
    configuration (see the IPython documentation or the section on configuration later
    in this appendix) to include the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also run the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`line_profiler` can be used programmatically (see the full documentation),
    but it is perhaps most powerful when used interactively in IPython. Suppose you
    had a module `prof_mod` with the following code doing some NumPy array operations
    (if you want to reproduce this example, put this code into a new file *prof_mod.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to understand the performance of the `add_and_sum` function, `%prun`
    gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not especially enlightening. With the `line_profiler` IPython extension
    activated, a new command `%lprun` is available. The only difference in usage is
    that we must instruct `%lprun` which function or functions we wish to profile.
    The general syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we want to profile `add_and_sum`, so we run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be much easier to interpret. In this case, we profiled the same function
    we used in the statement. Looking at the preceding module code, we could call
    `call_function` and profile that as well as `add_and_sum`, thus getting a full
    picture of the performance of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As a general rule of thumb, I tend to prefer `%prun` (`cProfile`) for “macro”
    profiling, and `%lprun` (`line_profiler`) for “micro” profiling. It’s worthwhile
    to have a good understanding of both tools.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note* *The reason that you must explicitly specify the names of the functions
    you want to profile with `%lprun` is that the overhead of “tracing” the execution
    time of each line is substantial. Tracing functions that are not of interest has
    the potential to significantly alter the profile results.*  *## B.6 Tips for Productive
    Code Development Using IPython'
  prefs: []
  type: TYPE_NORMAL
- en: Writing code in a way that makes it convenient to develop, debug, and ultimately
    *use* interactively may be a paradigm shift for many users. There are procedural
    details like code reloading that may require some adjustment, as well as coding
    style concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, implementing most of the strategies described in this section is
    more of an art than a science and will require some experimentation on your part
    to determine a way to write your Python code that is effective for you. Ultimately
    you want to structure your code in a way that makes it convenient to use iteratively
    and be able to explore the results of running a program or function as effortlessly
    as possible. I have found software designed with IPython in mind to be easier
    to work with than code intended only to be run as as standalone command-line application.
    This becomes especially important when something goes wrong and you have to diagnose
    an error in code that you or someone else might have written months or years beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: Reloading Module Dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Python, when you type `import some_lib`, the code in `some_lib` is executed,
    and all the variables, functions, and imports defined within are stored in the
    newly created `some_lib` module namespace. The next time you use `import some_lib`,
    you will get a reference to the existing module namespace. The potential difficulty
    in interactive IPython code development comes when you, say, `%run` a script that
    depends on some other module where you may have made changes. Suppose I had the
    following code in *test_script.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to execute `%run test_script.py` then modify *some_lib.py*, the
    next time you execute `%run test_script.py` you will still get the *old version*
    of *some_lib.py* because of Python’s “load-once” module system. This behavior
    differs from some other data analysis environments, like MATLAB, which automatically
    propagate code changes.[¹](#fn1) To cope with this, you have a couple of options.
    The first way is to use the `reload` function in the `importlib` module in the
    standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This attempts to give you a fresh copy of *some_lib.py* every time you run *test_script.py*
    (but there are some scenarios where it will not). Obviously, if the dependencies
    go deeper, it might be a bit tricky to be inserting usages of `reload` all over
    the place. For this problem, IPython has a special `dreload` function (*not* a
    magic function) for “deep” (recursive) reloading of modules. If I were to run
    *some_lib.py* then use `dreload(some_lib)`, it will attempt to reload `some_lib`
    as well as all of its dependencies. This will not work in all cases, unfortunately,
    but when it does, it beats having to restart IPython.
  prefs: []
  type: TYPE_NORMAL
- en: Code Design Tips
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s no simple recipe for this, but here are some high-level principles I
    have found effective in my own work.
  prefs: []
  type: TYPE_NORMAL
- en: Keep relevant objects and data alive
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s not unusual to see a program written for the command line with a structure
    somewhat like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Do you see what might go wrong if we were to run this program in IPython? After
    it’s done, none of the results or objects defined in the `main` function will
    be accessible in the IPython shell. A better way is to have whatever code is in
    `main` execute directly in the module’s global namespace (or in the `if __name__
    == '__main__':` block, if you want the module to also be importable). That way,
    when you `%run` the code, you’ll be able to look at all of the variables defined
    in `main`. This is equivalent to defining top-level variables in cells in the
    Jupyter notebook.
  prefs: []
  type: TYPE_NORMAL
- en: Flat is better than nested
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Deeply nested code makes me think about the many layers of an onion. When testing
    or debugging a function, how many layers of the onion must you peel back in order
    to reach the code of interest? The idea that “flat is better than nested” is a
    part of the Zen of Python, and it applies generally to developing code for interactive
    use as well. Making functions and classes as decoupled and modular as possible
    makes them easier to test (if you are writing unit tests), debug, and use interactively.
  prefs: []
  type: TYPE_NORMAL
- en: Overcome a fear of longer files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you come from a Java (or another such language) background, you may have
    been told to keep files short. In many languages, this is sound advice; long length
    is usually a bad “code smell,” indicating refactoring or reorganization may be
    necessary. However, while developing code using IPython, working with 10 small
    but interconnected files (under, say, 100 lines each) is likely to cause you more
    headaches in general than 2 or 3 longer files. Fewer files means fewer modules
    to reload and less jumping between files while editing, too. I have found maintaining
    larger modules, each with high *internal* cohesion (the code all relates to solving
    the same kinds of problems), to be much more useful and Pythonic. After iterating
    toward a solution, of course it sometimes will make sense to refactor larger files
    into smaller ones.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, I don’t support taking this argument to the extreme, which would
    to be to put all of your code in a single monstrous file. Finding a sensible and
    intuitive module and package structure for a large codebase often takes a bit
    of work, but it is especially important to get right in teams. Each module should
    be internally cohesive, and it should be as obvious as possible where to find
    functions and classes responsible for each area of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: B.7 Advanced IPython Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Making full use of the IPython system may lead you to write your code in a slightly
    different way, or to dig into the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Profiles and Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most aspects of the appearance (colors, prompt, spacing between lines, etc.)
    and behavior of the IPython and Jupyter environments are configurable through
    an extensive configuration system. Here are some things you can do via configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the color scheme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change how the input and output prompts look, or remove the blank line after
    `Out` and before the next `In` prompt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute an arbitrary list of Python statements (e.g., imports that you use all
    the time or anything else you want to happen each time you launch IPython)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable always-on IPython extensions, like the `%lprun` magic in `line_profiler`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable Jupyter extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define your own magics or system aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configurations for the IPython shell are specified in special *ipython_config.py*
    files, which are usually found in the *.ipython/* directory in your user home
    directory. Configuration is performed based on a particular *profile*. When you
    start IPython normally, you load up, by default, the *default profile*, stored
    in the *profile_default* directory. Thus, on my Linux OS, the full path to my
    default IPython configuration file is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To initialize this file on your system, run this in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ll spare you the complete details of what’s in this file. Fortunately, it
    has comments describing what each configuration option is for, so I will leave
    it to the reader to tinker and customize. One additional useful feature is that
    it’s possible to have *multiple profiles*. Suppose you wanted to have an alternative
    IPython configuration tailored for a particular application or project. Creating
    a new profile involves typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve done this, edit the config files in the newly created *profile_secret_project*
    directory and then launch IPython, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As always, the online IPython documentation is an excellent resource for more
    on profiles and configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuration for Jupyter works a little differently because you can use its
    notebooks with languages other than Python. To create an analogous Jupyter config
    file, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This writes a default config file to the *.jupyter/jupyter_notebook_config.py*
    directory in your home directory. After editing this to suit your needs, you may
    rename it to a different file, like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'When launching Jupyter, you can then add the `--config` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: B.8 Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you work through the code examples in this book and grow your skills as a
    Python programmer, I encourage you to keep learning about the IPython and Jupyter
    ecosystems. Since these projects have been designed to assist user productivity,
    you may discover tools that enable you to do your work more easily than using
    the Python language and its computational libraries by themselves.
  prefs: []
  type: TYPE_NORMAL
- en: You can also find a wealth of interesting Jupyter notebooks on the [nbviewer
    website](https://nbviewer.jupyter.org).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Since a module or package may be imported in many different places in a particular
    program, Python caches a module’s code the first time it is imported rather than
    executing the code in the module every time. Otherwise, modularity and good code
    organization could potentially cause inefficiency in an application.[↩︎](#fnref1)*****
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
