- en: 6 A dashboard fit for a CEO
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 适合CEO的仪表板
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Building an interactive metrics dashboard
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个交互式指标仪表板
- en: Wrangling data using the Pandas library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pandas 库处理数据
- en: Caching the results of functions to improve Streamlit app performance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存函数结果以改进Streamlit应用程序性能
- en: Creating filters, panels and other widgets in a dashboard
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在仪表板中创建过滤器、面板和其他小部件
- en: Developing data visualizations and charts using Plotly
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Plotly 开发数据可视化和图表
- en: Ever wondered how executives at large companies are able to stay on top of the
    business they run? Imagine the complexity and the sheer *number* of products and
    services offered by a company like Amazon, 3M, or Google. How can one person make
    sense of it all? How do they know if their business is meeting expectations and
    what areas need their focus?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾想过大公司的高管是如何保持对所经营业务的掌控？想象一下像亚马逊、3M 或谷歌这样的公司提供的成千上万的产品和服务复杂性。一个人如何理解这一切？他们如何知道他们的业务是否达到预期，以及哪些领域需要他们的关注？
- en: In well-run companies, the answer—or part of it—is metrics. Executives rely
    on a carefully curated set of metrics, or numbers that give them a high-level
    overview of the company’s performance. Metrics help leaders make informed decisions,
    identify potential issues before they become major problems, and pinpoint areas
    where the company can improve or innovate.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理良好的公司中，答案——或者部分答案——是指标。高管们依赖精心挑选的一套指标，即那些能给他们提供公司业绩高级概述的数字。指标帮助领导者做出明智的决策，在问题成为大问题之前识别潜在问题，并确定公司可以改进或创新的领域。
- en: But metrics alone are not enough—they need to be presented in a clear, digestible
    way. That's where dashboards come into play. A good dashboard allows users to
    explore various cuts of data, transforming raw data into a story, highlighting
    what's important and helping leaders stay focused on the bigger picture.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 但仅仅有指标是不够的——它们需要以清晰、易于理解的方式呈现。这就是仪表板发挥作用的地方。一个好的仪表板允许用户探索各种数据切片，将原始数据转化为故事，突出重点，并帮助领导者专注于大局。
- en: In this chapter, we'll develop such a dashboard designed for a CEO to monitor
    key performance indicators (KPIs) for their business. By its end, you'll not only
    know how to build a robust, interactive metrics dashboard using Streamlit, but
    also understand how to present data in a way that empowers decision-makers to
    focus on what truly matters.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发一个为CEO设计的仪表板，用于监控其业务的绩效关键指标（KPIs）。到本章结束时，你不仅将知道如何使用Streamlit构建一个强大、交互式的指标仪表板，还将了解如何以赋予决策者关注真正重要事情的方式呈现数据。
- en: 6.1 A metrics dashboard
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 一个指标仪表板
- en: Change is afoot at Note n' Nib Inc., everyone's favorite fictional online shopping
    site for stationery! The founder-CEO has retired to enjoy his millions in Ibiza,
    and his successor, a data-obsessed bigwig from Silicon Valley, has big plans for
    the company.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Note n' Nib Inc.，这个大家最喜欢的虚构在线办公用品购物网站，正在发生变革！创始人兼首席执行官已经退休，去伊维萨岛享受他的百万财富，而他的继任者，一个来自硅谷的数据狂热大佬，为公司制定了宏伟的计划。
- en: His enthusiasm is punctured a little when, in his first staff meeting, he asks
    the VP of Sales where he can look up the latest sales numbers and the VP fishes
    into his suitcase and retrieves a *paper* report from two months ago.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的第一次员工会议上，他询问销售副总裁在哪里可以查看最新的销售数字，而副总裁从他的手提箱里掏出一个*纸质*报告，那是两个月前的。他的热情受到了一点打击。
- en: '"Don''t we have a dashboard where we keep track of daily sales data?", the
    CEO asks, dreading the answer. His fears are confirmed when the VP mutters something
    about the *old* CEO having possessed a marvelous *intuition* that he frequently
    relied upon to make decisions—and pen-and-paper being the core of the business
    after all.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: “我们不是有一个仪表板来跟踪每日销售数据吗？”CEO 问道，担心着答案。他的担忧在副总裁低声提到前任CEO拥有一种神奇的*直觉*，他经常依赖这种直觉来做决策——毕竟，纸笔是商业的核心。
- en: An hour later, the VP of Sales summons you, a rising star in the department
    (and his go-to for stuff he doesn't want to deal with himself) and tasks you with
    building "one of those fancy metrics pages with line charts" for his boss.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一小时后，销售副总裁召唤你，部门中的新星（也是他处理不想亲自处理的事情的首选），并要求你为他老板构建“那些带有折线图的精美指标页面”。
- en: You know Engineering is busy with a major overhaul of the website, so you don't
    want to drop this on their plate. Luckily, you've been experimenting with this
    cool new Python framework called Streamlit and you're raring to use it at work.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道工程部门正忙于对网站进行大规模改造，所以你不想把这件事推给他们。幸运的是，你一直在尝试这个酷炫的新Python框架Streamlit，你迫不及待想在工作中使用它。
- en: 6.1.1 Stating the concept
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 陈述概念
- en: 'The VP didn''t give you a lot to work with, but you''ve been around long enough
    to have a pretty good idea of what the boss wants. As always, let''s start by
    spelling this out:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 副总裁没有给你太多可以工作的内容，但你已经在公司待了足够长的时间，对老板想要什么有了一个相当好的了解。一如既往，让我们先明确这一点：
- en: Concept
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 概念
- en: A dashboard that lets executives view various cuts of sales data and track key
    metrics to make decisions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个仪表板，让高管能够查看销售数据的各种切割，并跟踪关键指标以做出决策。
- en: 6.1.2 Defining the requirements
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 定义需求
- en: We have our work cut out for us to translate the concept into concrete requirements.
    Specifically, the phrases "sales data", "various cuts", and "key metrics" need
    to be expanded upon.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将概念转化为具体的需求。具体来说，需要扩展“销售数据”、“各种切割”和“关键指标”这些短语。
- en: Exploring the data
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 探索数据
- en: You've managed to get Engineering to export key data fields from their systems
    that you think will be relevant to your project into a Comma-Separated Values
    (CSV) file. You can download this file from the GitHub repo for this book (the
    file is called `sales_data.csv` and is in the `chapter_6` directory).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你设法让工程部门从他们的系统中导出你认为与你的项目相关的关键数据字段到逗号分隔值（CSV）文件中。你可以从本书的GitHub仓库中下载此文件（文件名为`sales_data.csv`，位于`chapter_6`目录中）。
- en: Once you've downloaded it, open it up in a spreadsheet program like Microsoft
    Excel or Numbers on macOS, and inspect the first few lines (shown in Figure 6.1)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，在Microsoft Excel或macOS上的Numbers等电子表格程序中打开它，并检查前几行（如图6.1所示）
- en: '![image](../Images/06__image001.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/06__image001.png)'
- en: Figure 6.1 The first two rows of the CSV data we'll work with
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.1 我们将工作的CSV数据的头两行
- en: The data represents the sales of various products sold by Note n' Nib, broken
    out by various *dimensions* such as segment and category. It also has demographic
    information about the kind of people who bought these products—specifically their
    gender and age group, as well as the state they hailed from. The file has data
    from January 2019 to August 2024, and contains *measures* such as sales (how much
    revenue did Note n' Nib make), gross margin (how much of the sales was profit,
    accounting for the cost), and the number of transactions covered by each row.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 数据代表了Note n' Nib销售的各种产品的销售额，按各种*维度*如细分市场和类别进行细分。它还包含了关于购买这些产品的顾客的人口统计信息——具体来说，包括他们的性别和年龄组，以及他们来自哪个州。该文件包含从2019年1月到2024年8月的数据，并包含*度量*，如销售额（Note
    n' Nib创造了多少收入）、毛利率（销售额中有多少是利润，考虑到成本），以及每行覆盖的交易数量。
- en: 'For instance, here''s how we would interpret the first row: On Jan 1 2019,
    men aged 18-25 from California buying Inkstream fountain pens (classified as "writing
    tools") made 8 transactions on the Note n'' Nib website, bringing in $134.91 in
    sales to the company, of which $83.91 remained after subtracting costs.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是我们对第一行的解释：2019年1月1日，来自加利福尼亚州的18-25岁男性购买Inkstream钢笔（归类为“书写工具”）在Note n' Nib网站上进行了8笔交易，为公司带来了134.91美元的销售额，扣除成本后剩余83.91美元。
- en: The *primary key* (the set of columns that uniquely identify a row) here is
    the combination of `date`, `product_name`, `segment`, `category`, `gender`, `age_group`,
    and `state`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的*主键*（唯一标识一行的列集）是`date`、`product_name`、`segment`、`category`、`gender`、`age_group`和`state`的组合。
- en: 'After speaking to the CEO, you also determine that he cares primarily about
    the following numbers: **total sales**, **gross margin**, **margin percentage**,
    and **average transaction value**. We''ll dive into these and how they''re calculated
    later in the chapter, but these are the "key metrics" from our stated concept.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与首席执行官交谈后，你还确定他主要关心以下数字：**总销售额**、**毛利率**、**利润率**和**平均交易价值**。我们将在本章后面详细讨论这些数字的计算方法，但这些都是我们概念中提到的“关键指标”。
- en: The CEO wants to be able to see how these numbers differ across different **products**,
    **categories**, **age groups**, **genders**, and **states**—the "various cuts"
    from the concept—as well as across time.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首席执行官希望能够看到这些数字在不同**产品**、**类别**、**年龄组**、**性别**和**州**之间的差异——即从概念中得出的“各种切割”，以及随时间的变化。
- en: You also do some thinking about *how* the data should be represented, and finally
    come up with an initial set of requirements.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你也思考了数据应该如何表示，最终提出了一组初步的需求。
- en: Requirements
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 需求
- en: 'The user should be able to:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应该能够：
- en: view in aggregate the total sales, gross margin, margin percentage, and average
    transaction value of products sold on Note n' Nib
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汇总查看Note n' Nib上销售产品的总销售额、毛利率、利润率和平均交易价值
- en: view how these numbers differ across different years, products, categories,
    age groups, genders, and states
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看这些数字在不同年份、产品、类别、年龄组、性别和州之间的差异
- en: filter data by these dimensions to explore cross-sections of the data
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过这些维度筛选数据以探索数据的横截面
- en: visualize the trends and breakdowns of the metrics over time, broken down by
    each dimension
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化指标随时间的变化趋势和分解，按每个维度分解
- en: You want to deliver an initial version of the dashboard quickly without getting
    bogged down in additional feature requests, so you clearly define what's out of
    scope too.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望快速交付仪表板的初始版本，而不被额外的功能请求所困扰，因此您也清楚地定义了范围之外的内容。
- en: What's out of scope
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 范围之外的内容
- en: 'At first launch, the dashboard will *not* support:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在首次发布时，仪表板将*不*支持：
- en: Drilling down into the data to view specific rows
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入数据以查看特定行
- en: Forecasting future values of any metrics
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测任何指标的未来的值
- en: Providing explanations about why a metric has changed over time
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供关于指标随时间变化原因的解释
- en: Some of these can be future expansions to the dashboard, but for now we'll try
    and limit its functionality to *observing* data as opposed to actively *analyzing*
    or *predicting* it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些可以是仪表板的未来扩展，但到目前为止，我们将尝试将其功能限制在*观察*数据，而不是积极*分析*或*预测*数据。
- en: 6.1.3 Visualizing the user experience
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3可视化用户体验
- en: The next step in the app development flow we explored in Chapter 3 is to visualize
    the user experience. From the requirements, it's evident that the four key metrics
    are of vital importance, so we should display them prominently, ideally in such
    a way that the user's eye is immediately drawn towards them. The requirements
    also mention filtering the data based on the dimensions and cuts we discussed.
    It seems reasonable to include a panel where users can do this.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中我们探索的应用程序开发流程的下一步是可视化用户体验。从需求来看，四个关键指标至关重要，因此我们应该突出显示它们，理想情况下以这种方式吸引用户的注意力。需求还提到了基于我们讨论的维度和切割来筛选数据。似乎合理地包括一个用户可以执行此操作的面板。
- en: A picture speaks a thousand words, so we want to provide clear visualizations
    of the data; the trends and breakdowns indicated in the requirements could be
    realized through *time series charts,* which show the progression of a number
    over time, and *pie charts*, which tell you how a whole quantity breaks down into
    its components.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一图胜千言，因此我们希望提供清晰的数据可视化；需求中指出的趋势和分解可以通过*时间序列图表*实现，这些图表显示了数字随时间的变化，以及*饼图*，它告诉您总量如何分解为其组成部分。
- en: Figure 6.2 shows a mock interface designed based on the above.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2展示了基于上述内容设计的模拟界面。
- en: '![image](../Images/06__image002.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/06__image002.png)'
- en: Figure 6.2 A UI mock for the dashboard
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.2仪表板的UI模拟
- en: 'As you can see, this design incorporates everything we discussed: the four
    key metrics are shown in a large unmissable font, and their values correspond
    to a slice of the data that is controlled by the filters at the top and a date
    range selector on the left.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此设计包含了我们讨论的所有内容：四个关键指标以大号字体展示，其值对应于由顶部筛选器和左侧日期范围选择器控制的数据切片。
- en: There's a line chart that shows how any selected metric has changed over time,
    and a pie chart that breaks down the total sales or gross margin by a selected
    dimension, like the product category.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个折线图显示了任何选定的指标随时间的变化，以及一个饼图，它根据选定的维度（如产品类别）分解总销售额或毛利润。
- en: 6.1.4 Brainstorming the implementation
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.4头脑风暴实现方案
- en: Before we get started with actually writing code, let's map out the flow of
    logic and data in our dashboard at a high level. Figure 6.3 shows one way we might
    choose to structure this.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际编写代码之前，让我们从高层次上绘制仪表板中逻辑和数据流的流程。图6.3显示了我们可能选择的一种结构方式。
- en: '![image](../Images/06__image003.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/06__image003.png)'
- en: Figure 6.3 Flow of logic and data in the dashboard
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.3仪表板中的逻辑和数据流
- en: The first step is to read the raw data from our CSV file and to load it into
    memory. There may be some basic data "preparation" or "cleaning" we want to perform
    next, such as renaming columns for convenience.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是从我们的CSV文件中读取原始数据并将其加载到内存中。我们可能想要进行一些基本的数据“准备”或“清理”，例如为了方便而重命名列。
- en: In our mock UI in figure 6.2, the filter bar at the top and the date range selectors
    to the side are meant to be *global*, i.e. they affect all of the widgets in the
    dashboard. So it stands to reason that we should apply the filters and select
    just the range we need before we pass the data around to the other parts of the
    dashboard.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在图6.2中的模拟用户界面中，顶部的过滤器栏和侧边的日期范围选择器旨在是*全局的*，即它们影响仪表板中的所有小部件。因此，在将数据传递到仪表板的其它部分之前，我们应该先应用过滤器并选择所需的范围。
- en: 'There are three sections in the dashboard where we''ll display data in some
    form: the metric bar with the overall metric values, the change-over-time line
    chart, and the pie chart. To obtain the content to show in each of these, we need
    to apply *transformations* to the filtered data, meaning we''ll need to group,
    aggregate and otherwise *transform* it.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在仪表板中，我们将以某种形式显示数据的三个部分：包含总体指标值的指标栏、随时间变化的折线图和饼图。为了获取显示在每个部分中的内容，我们需要对过滤后的数据进行*转换*，这意味着我们需要对其进行分组、聚合以及其他*转换*。
- en: The line and pie charts have additional options (you need to choose a metric
    to display in both charts, and a breakdown dimension—like the product category
    or gender—in the pie chart), which will serve as inputs to the transformations
    we'll apply.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 线形图和饼图有额外的选项（你需要在两个图表中选择一个指标来显示，并在饼图中选择一个细分维度——例如产品类别或性别），这些选项将作为我们将要应用的转换的输入。
- en: This hopefully gave you an overview of the design we'll be implementing in the
    rest of the chapter. Don't worry if some of these parts aren't quite clear to
    you yet; we're about to explore each part in a lot more detail.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '这应该为你提供了一个概述，我们将在本章的其余部分实现的设计。如果你对其中的一些部分还不是非常清楚，不要担心；我们即将更详细地探索每个部分。 '
- en: 6.2 Loading the data
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 加载数据
- en: In any application that presents or visualizes data, the first step involves
    obtaining data from some source. Sometimes this source is simply information entered
    by the user, but often it's an external source such as a database or a file. We'll
    talk about connecting to databases in later chapters, but for now we'll use the
    CSV file we reviewed earlier.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何展示或可视化数据的程序中，第一步涉及从某个来源获取数据。有时这个来源是用户输入的信息，但通常它是一个外部来源，如数据库或文件。我们将在后面的章节中讨论如何连接到数据库，但现在我们将使用我们之前审查过的CSV文件。
- en: In this section, we'll walk through how to load data into your app from an external
    file, keep it in memory, and display it in Streamlit. Along the way, we'll introduce
    Pandas, the quintessential Python library for data manipulation. We'll also discuss
    how to improve your app's performance through caching when the data you need to
    load is very large.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何从外部文件加载数据到您的应用程序中，将其保存在内存中，并在Streamlit中显示它。在这个过程中，我们将介绍Pandas，这是数据操作的典范Python库。我们还将讨论当需要加载数据非常大时，如何通过缓存来提高应用程序的性能。
- en: 6.2.1 The Pandas library
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 Pandas库
- en: I mentioned Pandas in passing in Chapter 1, describing it as a popular library
    for working with tabular data. In truth, Pandas has become such an integral part
    of the data ecosystem that it’s hard to imagine working with data in Python without
    it (or something like it at any rate).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我提到了Pandas，将其描述为处理表格数据的流行库。实际上，Pandas已经成为数据生态系统中不可或缺的一部分，很难想象在没有它（或类似的东西）的情况下用Python处理数据（无论如何）。
- en: Installing Pandas
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装Pandas
- en: 'You can install Pandas the same way you would install any other Python library:
    using `pip`. Type the following to set it up now:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像安装任何其他Python库一样安装Pandas：使用`pip`。现在输入以下命令来设置它：
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once that finishes running, verify that everything's set up right by running
    `pip show pandas`, which should display some information about the library.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行完成，通过运行`pip show pandas`来验证一切设置正确，它应该显示有关库的一些信息。
- en: Exploring our sales data in Pandas
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在Pandas中探索我们的销售数据
- en: Pandas revolves around the concept of the dataframe, which is a two-dimensional,
    tabular data structure similar to a table in a spreadsheet. It consists of rows
    and columns, where each column holds data of a specific type (eg. integer, float,
    string). Dataframes allow for efficient data manipulation and analysis, making
    them a versatile tool for handling structured data.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas围绕数据框的概念，这是一个类似于电子表格中表格的二维、表格式数据结构。它由行和列组成，其中每一列都包含特定类型的数据（例如整数、浮点数、字符串）。数据框允许高效的数据操作和分析，使它们成为处理结构化数据的通用工具。
- en: To see dataframes in action, let's load our sales data CSV into a Pandas dataframe.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看数据框的实际应用，让我们将我们的销售数据CSV文件加载到Pandas数据框中。
- en: 'Navigate to the local directory where you downloaded `sales_data.csv`, open
    a Python shell and type the following commands:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到您下载 `sales_data.csv` 的本地目录，打开 Python 命令行并输入以下命令：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `import pandas as pd` is a regular Python import statement. It's conventional
    to refer to the Pandas module as `pd` (just as we use `st` for Streamlit).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`import pandas as pd` 是一个常规的 Python 导入语句。习惯上，我们将 Pandas 模块称为 `pd`（就像我们使用 `st`
    一样用于 Streamlit）。'
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is where we actually load the CSV file. Pandas makes this incredibly easy
    using the `read_csv` method. `read_csv` actually has a ton of parameters you can
    pass it (such as whether the file contains a header, what column names and types
    to use, and so on), but since all of these have sensible default values, you can
    also just pass it the path to the file and nothing else.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们实际加载 CSV 文件的地方。Pandas 使用 `read_csv` 方法使这一过程变得非常简单。`read_csv` 实际上有很多参数可以传递给它（例如，文件是否包含标题，要使用的列名和类型等），但由于所有这些都有合理的默认值，你也可以只传递文件的路径，而无需其他任何内容。
- en: At the end of this, we have a variable `df` that holds a Pandas dataframe.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个变量 `df`，它包含一个 Pandas 数据框。
- en: 'Let''s verify this using Python''s built-in `type` function, which returns
    the type of the object that a particular variable holds:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Python 内置的 `type` 函数来验证这一点，该函数返回特定变量所持有的对象的类型：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also get more information about the dataframe using its `info()` method:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用数据框的 `info()` 方法获取更多关于数据框的信息：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This tells us a variety of things. The dataframe has more than a million rows,
    numbered from 0 to 1034999\. It has ten columns, with the first seven being of
    the `object` type (strings, essentially) and the last three being `float64s` (or
    floating-point numbers).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们很多信息。数据框有超过一百万行，编号从 0 到 1034999。它有十个列，前七个是 `object` 类型（基本上是字符串）和最后三个是 `float64`（或浮点数）。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: These names may be confusing to you since they're not the regular Python types
    (str, float, etc.) that you're likely used to. This is because Pandas uses its
    own data types (or dtypes), derived from a related Python library called `numpy`,
    for efficient computations.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称可能对你来说很困惑，因为它们不是你可能习惯的常规 Python 类型（如 str、float 等）。这是因为 Pandas 使用其自己的数据类型（或
    dtypes），这些类型是从一个名为 `numpy` 的相关 Python 库派生出来的，用于高效计算。
- en: 'You also have the option of having Pandas use the Apache Arrow format, which
    can be more performant for large datasets. To do so, while reading the CSV, add
    a `dtype_backend` parameter like so:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以选择让 Pandas 使用 Apache Arrow 格式，这对于大型数据集可能更高效。为此，在读取 CSV 时，添加一个 `dtype_backend`
    参数，如下所示：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you do this, you'll notice that the data types shown by .info() are `string[pyarrow]`
    and `double[pyarrow]` rather than `object` and `float64`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做，你会注意到 .info() 显示的数据类型是 `string[pyarrow]` 和 `double[pyarrow]`，而不是 `object`
    和 `float64`。
- en: 'Let''s look at some of the content in the dataframe next. Since we don''t have
    enough space on this page to print all the columns, we first select a subset of
    them:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看数据框中的一些内容。由于我们在这页上没有足够的空间打印所有列，我们首先选择其中的一部分：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can create a new Pandas dataframe by performing some operation on another
    dataframe. That's essentially what happened here. When we pass a list of columns
    to a dataframe using Pandas' user-friendly square-bracket notation (`df[<list
    of column names>]`), we get a new dataframe containing only the columns we passed,
    which we can then assign to another variable (`only_some_cols` in this case).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过对另一个数据框执行某些操作来创建一个新的 Pandas 数据框。这里发生的事情本质上就是这样。当我们使用 Pandas 的用户友好方括号表示法（`df[<列名列表>]`）将列列表传递给数据框时，我们得到一个新的只包含我们传递的列的数据框，然后我们可以将其分配给另一个变量（在这种情况下为
    `only_some_cols`）。
- en: Finally, to see the first few rows, we use the `.head()` method on our smaller
    dataframe, which shows us the values in the first five rows.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了查看前几行，我们在较小的数据框上使用 `.head()` 方法，这显示了前五行中的值。
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We'll learn more Pandas as we go along, so let's stop here for now and get back
    to building our dashboard.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在学习过程中了解更多 Pandas 的知识，所以现在我们先停下来，回到构建我们的仪表板。
- en: 6.2.2 Reading and displaying a dataframe
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 读取和显示数据框
- en: Our dashboard app is going to involve a lot more code than some of the previous
    apps we've written, so it would be a good idea to spread it across multiple modules
    or `.py` files.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的仪表板应用程序将比我们之前编写的一些应用程序涉及更多的代码，所以将其分散到多个模块或 `.py` 文件中是个好主意。
- en: Loading data from the right file path
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从正确的文件路径加载数据
- en: We'll start with a dedicated Python script file to read in the data from our
    CSV. Copy `sales_data.csv` to the folder where you intend to keep your code files,
    and then create `data_loader.py` with the content shown in listing 6.1.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个专门的 Python 脚本文件开始，用于从我们的 CSV 中读取数据。将 `sales_data.csv` 复制到你打算存放代码文件的文件夹中，然后创建
    `data_loader.py` 并包含列表 6.1 中的内容。
- en: Listing 6.1 data_loader.py
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.1 data_loader.py
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `load_data` function simply uses Pandas to read in the CSV as we saw in
    the last section, but there seems to be more going on here. How are we populating
    the `SALES_DATA_PATH` variable? Why couldn't we just set it to `"sales_data.csv"`
    directly, given that `data_loader.py` is in the same directory as `sales_data.csv`?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_data` 函数简单地使用 Pandas 读取 CSV，就像我们在上一节中看到的那样，但这里似乎还有更多的事情发生。我们是如何填充 `SALES_DATA_PATH`
    变量的？既然 `data_loader.py` 与 `sales_data.csv` 在同一目录中，为什么我们不能直接将其设置为 `"sales_data.csv"`
    呢？'
- en: The trouble here is that file paths in Python are considered to be relative
    to the *working directory you're executing a script from*, not the directory that
    the file containing the line currently being executed is located in.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，Python 中的文件路径被认为是相对于**你执行脚本的当前工作目录**的，而不是当前执行行的文件所在的目录。
- en: For instance, if you're currently in `'/Users/alice/'`, your `.py` file and
    CSV are in the folder `'/Users/alice/streamlit_project/'` and you write `pd.read_csv('sales_data.csv')`,
    Python will look for the path `'/Users/alice/sales_data.csv'`, which doesn't exist.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你目前位于 `'/Users/alice/'`，你的 `.py` 文件和 CSV 文件在 `'/Users/alice/streamlit_project/'`
    文件夹中，而你编写 `pd.read_csv('sales_data.csv')`，Python 将寻找 `'/Users/alice/sales_data.csv'`
    的路径，这个路径是不存在的。
- en: You could hardcode the absolute path to the CSV and pass `'/Users/alice/streamlit_project/sales_data.csv'`,
    but that will obviously create issues when your app is deployed on a different
    computer where it won't be in that exact path.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 CSV 的绝对路径硬编码为 `'/Users/alice/streamlit_project/sales_data.csv'` 并传递它，但显然这会在你的应用程序部署到不同的计算机上时产生问题，因为文件不会在那个确切的路径中。
- en: No, what we need is a way to refer to the current `.py` file and construct a
    path relative to that file's path.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我们需要的是一个可以引用当前 `.py` 文件并相对于该文件的路径构造路径的方法。
- en: 'This is what the two lines near the top do:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是顶部附近的两行所做的事情：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`__file__` is a special variable in Python that contains the path of the file
    currently being executed.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`__file__` 是 Python 中一个特殊的变量，它包含当前正在执行的文件的路径。'
- en: '`Path` is a class from the `pathlib` module (which comes built-in with Python)
    that lets you work with file paths in a user-friendly, object-oriented way. `Path(__file__)`
    creates a Path object corresponding to the current Python script, `data_loader.py`,
    and `.resolve()` dynamically generates the absolute path to `data_loader.py` (regardless
    of whether it''s in your local machine or a production deployment). The `.parent`
    then refers to the directory `data_loader.py` is in.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path` 是 `pathlib` 模块（Python 内置）中的一个类，它允许你以用户友好的、面向对象的方式处理文件路径。`Path(__file__)`
    创建了一个与当前 Python 脚本 `data_loader.py` 对应的 Path 对象，`.resolve()` 动态生成 `data_loader.py`
    的绝对路径（无论它是在你的本地机器上还是在生产部署中）。然后 `.parent` 指的是 `data_loader.py` 所在的目录。'
- en: Finally, we use the `'/'` operator which works with `Path` objects (and is *not*
    the mathematical divided-by operator in this context) to generate the final path
    to our CSV, stored in `SALES_DATA_PATH`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `'/'` 操作符与 `Path` 对象一起工作（在这个上下文中**不是**数学上的除法操作符）来生成我们 CSV 文件的最终路径，存储在
    `SALES_DATA_PATH` 中。
- en: It's worth noting that `SALES_DATA_PATH` is not a string, it's still a `Path`
    object. Fortunately, Pandas' `read_csv` knows how to handle those, so we can pass
    it directly to that function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`SALES_DATA_PATH` 不是一个字符串，它仍然是一个 `Path` 对象。幸运的是，Pandas 的 `read_csv` 知道如何处理这些，所以我们可以直接将其传递给该函数。
- en: Using st.write to display the dataframe
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 st.write 显示数据框
- en: Let's now use the `load_data` function we just created in our Streamlit app.
    Create an entrypoint (the file we'll use with `streamlit run`) to the app called
    `dashboard.py`, shown in listing 6.2.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来使用我们在 Streamlit 应用中刚刚创建的 `load_data` 函数。创建一个名为 `dashboard.py` 的应用程序入口点（我们将使用
    `streamlit run` 命令的文件），如列表 6.2 所示。
- en: Listing 6.2 dashboard.py
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.2 dashboard.py
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This part is fairly straightforward. `data` is a Pandas dataframe with data
    from our CSV (since that's what `load_data` returns).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分相当直接。`data` 是一个 Pandas 数据框，包含来自我们 CSV 的数据（因为这就是 `load_data` 返回的内容）。
- en: The last line, `st.write(data.head(5))`, is interesting. We've briefly encountered
    `st.write` before, in Chapter 2\. Streamlit's docs describe `st.write` as "the
    Swiss Army knife of Streamlit commands" and that's fairly accurate.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这一行，`st.write(data.head(5))`很有趣。我们之前在第二章中简要接触过`st.write`。Streamlit的文档将`st.write`描述为“Streamlit命令的瑞士军刀”，这相当准确。
- en: You can basically pass pretty much any kind of object to `st.write` and it'll
    display the passed object in a graceful and sensible way. This means you can pass
    it a string and it'll write the string to the screen, but you can also pass it
    a dictionary and it'll print out the contents of the dictionary in a well-formatted
    way (try it out!). You can even pass it internal Python objects like classes or
    functions and it'll display information about them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你基本上可以将任何类型的对象传递给`st.write`，并且它会以优雅和合理的方式显示传递的对象。这意味着你可以传递一个字符串，它会在屏幕上写入该字符串，但你也可以传递一个字典，并以良好的格式打印出字典的内容（试试看！）你甚至可以传递内部Python对象，如类或函数，并且它会显示有关它们的信息。
- en: '`st.write` works well for our purposes because we can pass it a Pandas dataframe
    and it''ll show the data on the screen. `data.head(5)` returns a dataframe with
    only the first 5 rows of the data, and using `st.write` on it helps us verify
    that the data was loaded correctly, as shown in figure 6.4—which is what you''ll
    get if you execute `streamlit run dashboard.py`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.write`在我们的用途中工作得很好，因为我们可以向它传递一个Pandas数据框，它会在屏幕上显示数据。`data.head(5)`返回一个只包含数据前5行的数据框，使用`st.write`来检查数据是否正确加载，如图6.4所示——这是执行`streamlit
    run dashboard.py`时你会得到的结果。'
- en: '![image](../Images/06__image004.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/06__image004.png)'
- en: Figure 6.4 Streamlit can display Pandas dataframes natively
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.4 Streamlit可以原生显示Pandas数据框
- en: You may notice that it takes a few seconds for the app to load. This is because
    our CSV file is rather large (more than 90 megabytes) and reading it takes a while.
    At first glance, this might not sound like a huge deal, but recall once again
    that Streamlit reruns your *entire* script every time anything needs to change
    on the screen.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到应用程序加载需要几秒钟。这是因为我们的CSV文件相当大（超过90兆字节），读取它需要一段时间。乍一看，这可能不算什么大问题，但请再次记住，Streamlit每次屏幕上需要改变时都会重新运行你的**整个**脚本。
- en: That means that each time the user changes a selection or clicks out of a textbox,
    your app will re-read the CSV, slowing down the whole app. Besides being incredibly
    wasteful, that would degrade your dashboard's user experience, so let's address
    that next.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每次用户更改选择或从文本框中点击出来时，你的应用程序都会重新读取CSV文件，这会减慢整个应用程序的速度。除了非常浪费之外，这还会降低仪表板的用户体验，所以让我们接下来解决这个问题。
- en: 6.2.3 Caching data
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 缓存数据
- en: One of the effects of Streamlit's execution model is that, without intervention,
    expensive operations such as reading a file or performing a complex computation
    are executed over and over again to get the same results every time. This can
    be problematic for data apps like the one we're building now since they frequently
    rely upon such operations.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit执行模型的一个影响是，如果没有干预，像读取文件或执行复杂计算这样的昂贵操作会反复执行以获得相同的结果。这对于我们正在构建的数据应用程序来说可能是个问题，因为它们经常依赖于这样的操作。
- en: 'In prior chapters, we''ve seen one way to deal with the problem: we could save
    the data into `st.session_state`. That way the data would only have to be read
    once per user session, and the app wouldn''t slow down during user interactions.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了一种处理问题的方法：我们可以将数据保存到`st.session_state`中。这样，数据就只需要在每个用户会话中读取一次，应用程序在用户交互期间就不会变慢。
- en: 'This is an *okay* solution, but doesn''t solve a couple of issues:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种**不错的**解决方案，但它没有解决几个问题：
- en: The data would still need to be loaded every time the web page is refreshed.
    If the user opens the dashboard in multiple tabs—and given the number of browser
    tabs the average person has open at any point, they probably will—it would take
    a while to load each time.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据仍然需要在每次网页刷新时加载。如果用户在多个标签页中打开仪表板——考虑到平均每个人在任何时候打开的浏览器标签页数量，他们很可能这么做——每次加载都会花费一些时间。
- en: The dashboard would have to read the data from scratch for *each* user even
    though it's the exact same data.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使数据完全相同，仪表板也必须为**每个**用户重新读取数据。
- en: Streamlit offers a better way to deal with this situation, in the form of `st.cache_data`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit提供了一种更好的方法来处理这种情况，即`st.cache_data`。
- en: st.cache_data
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: st.cache_data
- en: '`st.cache_data` is Streamlit''s way of *caching* or storing the results of
    a slow function call so that the next time the function is called with the same
    parameters, it can simply look up the stored result of the *last* call rather
    than actually executing the function again.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.cache_data` 是 Streamlit 缓存或存储慢速函数调用结果的方式，以便下次以相同的参数调用该函数时，它可以直接查找上次调用的存储结果，而不是再次执行该函数。'
- en: For our use case, we can simply cache the result of the `load_data` function
    we wrote earlier. Streamlit would then store the Pandas dataframe it returns,
    and subsequent app reruns or even page refreshes wouldn't cause the function to
    be executed again.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的用例，我们可以简单地缓存我们之前编写的 `load_data` 函数的结果。Streamlit 将存储它返回的 Pandas 数据框，并且随后的应用程序重新运行或甚至页面刷新都不会再次执行该函数。
- en: '`st.cache_data` uses a different Python construct from the Streamlit elements
    we''ve seen so far: it''s a *decorator,* which you can think of as something that
    takes a function or a class and adds some new feature to it without you having
    to rewrite the function or class.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.cache_data` 使用了与迄今为止我们所见的 Streamlit 元素不同的 Python 构造：它是一个 *装饰器*，你可以将其视为一种可以接受一个函数或类并为其添加一些新功能，而无需重新编写函数或类的东西。'
- en: 'To apply `st.cache_data` on the `load_data` function (in `data_loader.py`),
    simply write `@st.cache_data` above it, like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `load_data` 函数（在 `data_loader.py` 中）上应用 `st.cache_data`，只需在其上方写 `@st.cache_data`，如下所示：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, `st.cache_data` is *decorating* the `load_data` function, transforming
    it with the caching feature so that when it's called again, it'll return the previous
    cached result rather than executing its logic.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`st.cache_data` 正在 *装饰* `load_data` 函数，通过缓存功能将其转换，以便再次调用时，它将返回之前的缓存结果，而不是再次执行其逻辑。
- en: 'Since we''re now referring to a Streamlit element within `data_loader.py`,
    we also need to include the Streamlit import at the top:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在在 `data_loader.py` 中引用了 Streamlit 元素，因此我们还需要在顶部包含 Streamlit 的导入：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you run the app now, you'll briefly see a spinning icon with the text "Running
    `load_data()."` (see figure 6.5) before your dataframe is displayed, but if you
    reload the page your data should now load instantly.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你将短暂地看到一个带有文本 "正在运行 `load_data().`" 的旋转图标（见图 6.5），然后你的数据框才会显示出来，但如果你重新加载页面，你的数据现在应该可以立即加载。
- en: '![image](../Images/06__image005.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/06__image005.png)'
- en: Figure 6.5 By default, st.cache_data shows a spinner with a function name when
    actually running the function
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.5 默认情况下，st.cache_data 在实际运行函数时显示一个带有函数名的旋转图标
- en: 'Looks like the caching is working! Here''s a question though: what happens
    when the data changes? The CEO wants a dashboard with *up-to-date* sales data,
    so we can assume that the source data will change periodically—at least daily
    if not more frequently than that. For our example, let''s assume that Engineering
    will overwrite the existing CSV with a version with newer data every day.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来缓存正在工作！不过这里有一个问题：当数据发生变化时会发生什么？CEO 想要一个包含 *最新* 销售数据的仪表板，因此我们可以假设源数据会定期变化——至少每天，甚至更频繁。在我们的例子中，让我们假设工程部门每天都会用包含新数据的版本覆盖现有的
    CSV 文件。
- en: If the data is cached the way we've set it up, Streamlit won't pull in the updated
    CSV when it changes. It will just see that the return value of `load_data` is
    cached from the first run (perhaps several days ago) and use that.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据以我们设置的方式缓存，Streamlit 不会在 CSV 更改时拉取更新的 CSV。它只会看到 `load_data` 的返回值是从第一次运行（可能是几天前）缓存的，并使用那个结果。
- en: We need a way to set an *expiry date* for the cache, essentially telling it
    that if the cached data is older than a certain threshold, the function needs
    to actually be executed and the results re-cached.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来设置缓存的 *过期日期*，本质上告诉它，如果缓存的数据超过某个阈值，则函数需要实际执行并重新缓存结果。
- en: We achieve this using the `ttl` argument of `st.cache_data`. `ttl` stands for
    "time-to-live" and sets the amount of time that the cached data is valid for before
    Streamlit will re-execute the function during a rerun.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `st.cache_data` 的 `ttl` 参数来实现这一点。`ttl` 代表 "存活时间"，它设置了缓存数据在 Streamlit 重新执行函数之前有效的时长。
- en: 'If we assume that our CSV data will change every day, we could set a `ttl`
    of 1 day like so:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设我们的 CSV 数据每天都会变化，我们可以将 `ttl` 设置为 1 天，如下所示：
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This way, the loaded data will be pulled once every day when a user runs the
    app. That run will take a while, but all subsequent runs in the following 24 hours
    will use the newly cached data and therefore be quick.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当用户每天运行应用程序时，加载的数据将每天被拉取一次。这次运行可能需要一段时间，但接下来的 24 小时内所有后续的运行都将使用新缓存的数据库，因此运行速度快。
- en: Figure 6.6 illustrates how this works.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6说明了这是如何工作的。
- en: '![image](../Images/06__image006.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/06__image006.png)'
- en: Figure 6.6 How st.cache_data works
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.6 st.cache_data的工作原理
- en: 'Another thing we probably want to change is the message displayed with the
    spinning icon. The name `load_data` is internal to our code and we don''t want
    it exposed to users. We can change this message using the `show_spinner` argument
    of `st.cache_data` so our code becomes:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还想改变与旋转图标一起显示的消息。名称`load_data`是我们代码内部的，我们不希望它暴露给用户。我们可以使用`st.cache_data`的`show_spinner`参数来更改此消息，使我们的代码变为：
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the app again and you'll notice the loading indicator has changed to figure
    6.7.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序，你会注意到加载指示器已更改为图6.7。
- en: '![image](../Images/06__image007.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/06__image007.png)'
- en: Figure 6.7 Setting the show_spinner parameter in st.cache_data displays a user-friendly
    message when the data is loading
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.7 在st.cache_data中设置show_spinner参数，当数据正在加载时显示一个用户友好的消息
- en: It's valuable to realize that when a user runs the app and the data is cached,
    the cached values are available to *all* users of the app, not just the current
    one. There are times when this can lead to unexpected results (we'll probably
    encounter some of these in later chapters), but in this case, since we want to
    show all users the same data, it's desirable behavior.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有价值的是意识到，当用户运行应用程序并且数据被缓存时，缓存值对所有应用程序的用户都可用，而不仅仅是当前用户。有时这可能会导致意外结果（我们可能在后面的章节中遇到一些），但在这个案例中，因为我们想向所有用户显示相同的数据，所以这是一种理想的行为。
- en: With the data loaded and available within our app, let's move on to constructing
    the dashboard itself.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据加载并可在我们的应用中使用后，让我们继续构建仪表板本身。
- en: 6.3 Prepping and filtering the data
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 准备和过滤数据
- en: A key requirement our dashboard needs to meet is the ability to inspect various
    *slices* of the data, as opposed to its entirety. This is quite logical; our source
    data runs across 5+ years. A user today would probably be more interested in the
    most recent year of data than older years. Similarly, a user may only be interested
    in sales related to the "Paper products" category.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仪表板需要满足的一个关键要求是能够检查数据的各种*切片*，而不是其整体。这是非常合理的；我们的源数据跨越了5年以上。今天的用户可能对最近一年的数据更感兴趣，而不是旧年的数据。同样，用户可能只对与“纸制品”类别相关的销售感兴趣。
- en: '*Filtering* a table of data is the act of considering only the rows of data
    that we care about, and excluding everything else. Our envisioned dashboard has
    two areas that enable this: a *filter panel* where users can choose the values
    of each field they want to consider, and a *date range selector*.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*过滤*数据表是只考虑我们关心的数据行，并排除其他所有内容的行为。我们设想中的仪表板有两个区域可以实现这一点：一个*过滤器面板*，用户可以选择他们想要考虑的每个字段的值，以及一个*日期范围选择器*。'
- en: In this section we'll build both of these components visually, and perform the
    Pandas data wrangling that enables their functionality.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将可视化构建这两个组件，并执行使它们功能化的Pandas数据处理。
- en: 6.3.1 Creating a filter panel
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 创建过滤器面板
- en: Let's revisit our UI mock, focusing on the filter panel at the top, reproduced
    in figure 6.8.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视我们的UI原型，重点关注顶部显示的过滤器面板，如图6.8所示。
- en: '![image](../Images/06__image008.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/06__image008.png)'
- en: Figure 6.8 The filter panel from our UI mock
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.8 我们UI原型中的过滤器面板
- en: The panel is essentially a collection of dropdown menus, one for each field
    that we want to filter by.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 该面板基本上是每个我们想要筛选的字段的下拉菜单的集合。
- en: Each menu presumably contains the unique values corresponding to each field
    as options, and the user can choose multiple options (eg. in figure 6.8, the "State"
    filter has CA, TX and FL all selected). Also, the user can choose not to select
    *any* option (eg. "Gender" in figure 6.8), which we should probably treat as there
    not being any filter on that field.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 每个菜单可能包含对应于每个字段的唯一值作为选项，用户可以选择多个选项（例如，在图6.8中，“州”过滤器选择了CA、TX和FL）。此外，用户可以选择不选择*任何*选项（例如，图6.8中的“性别”），我们可能将此视为该字段没有筛选。
- en: The selections shown in figure 6.8 should cut the data down to rows corresponding
    to the 18-25 and 26-35 age groups for customers in CA, TX or FL. Since there's
    no filter on, say, "Product name", the data should include all products sold by
    Note n' Nib.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8中显示的选择应将数据缩减到对应于CA、TX或FL的18-25岁和26-35岁年龄段的客户行。由于没有对“产品名称”进行筛选，数据应包括Note
    n' Nib销售的所有产品。
- en: Obtaining the list of unique values for a field
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取字段唯一值的列表
- en: 'Clearly, we need a way to populate the options in the dropdowns when we create
    them. A plausible way to do this might be to hardcode the list of possible values
    for each field, but this presents some glaring issues: we would need to change
    our code every time there''s a new product or category, or if the way we''re grouping
    ages changes, or for plenty of other reasons.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要一种方法在创建下拉菜单时填充选项。一个可能的方法可能是为每个字段硬编码可能的值列表，但这会带来一些明显的问题：每次有新产品或类别，或者我们分组年龄的方式改变，或者有其他许多原因时，我们都需要更改我们的代码。
- en: A better approach is to get the list of options dynamically, from the data *itself*.
    Start a new Python file called `data_wrangling.py` and add a function to do this,
    as shown in listing 6.3.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是动态地从数据 *本身* 获取选项列表。开始一个新的 Python 文件，命名为 `data_wrangling.py`，并添加一个函数来完成此操作，如列表
    6.3 所示。
- en: Listing 6.3 data_wrangling.py
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.3 data_wrangling.py
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `get_unique_values` function accepts a Pandas dataframe `df` and a column
    name `column`. It returns a list of unique values for that column in the dataframe.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_unique_values` 函数接受一个 Pandas 数据框 `df` 和一个列名 `column`。它返回数据框中该列的唯一值列表。'
- en: When you pass a column name to a Pandas dataframe within square brackets (an
    operation named *column selection*), you get a Pandas *series*, which is a one-dimensional
    array-like object (you could think of it as a single-column dataframe).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Pandas 数据框中传递一个列名（称为 *列选择* 操作）并用方括号括起来时，你会得到一个 Pandas *序列*，这是一个类似于一维数组的对象（你可以将其视为单列数据框）。
- en: For instance, `df['age_group']` would return a series with the same number of
    elements as there are rows in `df`, with each element being the `age_group` corresponding
    to a row.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`df['age_group']` 会返回一个与 `df` 中行数相同数量的元素序列，每个元素对应于一行中的 `age_group`。
- en: Calling `.unique()` on it dedupes the elements and gives you a new series with
    just the five or six distinct age groups in the data. We finally convert it into
    a regular Python list with the `list` function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在它上面调用 `.unique()` 会去重元素，并给你一个新的序列，其中只包含数据中的五个或六个不同的年龄组。我们最终使用 `list` 函数将其转换为常规
    Python 列表。
- en: Adding the dropdowns with st.multiselect
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 st.multiselect 添加下拉菜单
- en: As we've seen, the user should be able to select any combination of options
    in each filter. Streamlit provides this functionality through `st.multiselect`,
    which is quite similar to `st.selectbox`, which we've come across before. As in
    the case of `st.selectbox`, the first two parameters (the only required ones)
    that you pass to `st.multiselect` are the label and the list of options.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，用户应该能够选择每个过滤器中任何选项的组合。Streamlit 通过 `st.multiselect` 提供此功能，这与我们之前遇到的 `st.selectbox`
    非常相似。与 `st.selectbox` 的情况一样，传递给 `st.multiselect` 的前两个参数（唯一必需的参数）是标签和选项列表。
- en: For example, you could write `st.multiselect('Color', ['blue', 'green', 'red'])`
    to display a dropdown labeled "Color" from which you can select one or more colors.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以编写 `st.multiselect('Color', ['blue', 'green', 'red'])` 来显示一个标记为 "Color"
    的下拉菜单，你可以从中选择一个或多个颜色。
- en: Keeping with our approach of spreading our code into several modules, we'll
    create a new one for the filter panel and call it `filter_panel.py`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们将代码分散到几个模块的方法，我们将创建一个新的模块用于过滤器面板，并将其命名为 `filter_panel.py`。
- en: Listing 6.4 shows a starting draft of `filter_panel.py`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 显示了 `filter_panel.py` 的起始草稿。
- en: Listing 6.4 dashboard.py
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.4 dashboard.py
- en: '[PRE16]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`filter_dims` holds the list of fields from the dataframe that we want to filter
    on.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter_dims` 包含我们想要过滤的数据框中的字段列表。'
- en: The `filter_panel` function is what actually displays the dropdowns. It takes
    a dataframe as input and renders the dropdowns using the unique values for each
    field.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter_panel` 函数实际上是显示下拉菜单的部分。它接受一个数据框作为输入，并使用每个字段的唯一值来渲染下拉菜单。'
- en: Some of this code should look familiar by this point. We want to display the
    dropdowns side by side, so we use `st.columns(len(filter_dims))` to create as
    many display columns as there are fields we want to filter on.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一些代码应该看起来很熟悉。我们希望并排显示下拉菜单，因此我们使用 `st.columns(len(filter_dims))` 来创建我们想要过滤的字段数那么多显示列。
- en: 'For each field, we obtain the unique values using our `get_unique_values` function
    from `data_wrangling.py`, and use them to populate the dropdown:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个字段，我们使用来自 `data_wrangling.py` 的 `get_unique_values` 函数获取唯一值，并使用它们来填充下拉菜单：
- en: '[PRE17]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Listing 6.4 also shows the use of a new Streamlit widget called `st.expander`,
    which is a collapsible box that users can expand or contract as needed. This makes
    sense because the user probably doesn't want to see the filters all the time.
    It's a good idea to have the option of hiding them so they can focus on the actual
    displayed data.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 还展示了使用一个新的 Streamlit 小部件 `st.expander`，它是一个可折叠的框，用户可以根据需要展开或收缩。这很有意义，因为用户可能不想总是看到筛选器。隐藏它们的选项是个好主意，这样他们就可以专注于实际显示的数据。
- en: 'Let''s include the `filter_panel` in our main dashboard by editing `dashboard.py`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `dashboard.py` 中编辑主仪表板，包括 `filter_panel`：
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This should yield the output in figure 6.9.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生图 6.9 中的输出。
- en: '![image](../Images/06__image009.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/06__image009.png)'
- en: Figure 6.9 By default, our Streamlit app's layout is centered, which can be
    problematic if there's a lot to display horizontally
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.9 默认情况下，我们的 Streamlit 应用布局是居中的，如果水平显示的内容很多，这可能会成问题
- en: One issue we can see immediately is that with six fields to filter on, each
    individual filter seems to be squished against its neighbors.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即看到的一个问题是，有六个筛选字段时，每个单独的筛选器似乎都挤压在其邻居旁边。
- en: Additionally, the filter field names are currently the raw column names from
    the CSV, including underscores. A more polished design would present these as
    user-friendly labels, such as "Age group," instead of technical identifiers like
    "age_group."
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当前筛选字段的名称是来自 CSV 的原始列名，包括下划线。一个更精致的设计会展示为用户友好的标签，例如“年龄组”，而不是像“age_group”这样的技术标识符。
- en: Fixing the width issue
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决宽度问题
- en: Notice in figure 6.9 that there's a lot of unused whitespace to the sides of
    the filter panel. By default, Streamlit apps have a "centered" layout where the
    body of the app is rendered horizontally at the center of the window, and the
    sides are blank.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意图 6.9 中筛选面板两侧有很多未使用的空白空间。默认情况下，Streamlit 应用有一个“居中”布局，其中应用的主体在窗口中心水平渲染，两侧是空白。
- en: This is usually fine, but with a UI as dense as what we're building, screen
    real estate comes at a premium. Thankfully, Streamlit allows us to change this
    and use more of the screen. We can do this using the `st.set_page_config` method
    in `dashboard.py`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常没问题，但鉴于我们正在构建的 UI 如此密集，屏幕空间变得非常宝贵。幸运的是，Streamlit 允许我们改变这一点，并使用更多的屏幕空间。我们可以通过在
    `dashboard.py` 中使用 `st.set_page_config` 方法来实现这一点。
- en: '[PRE19]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Importantly, this only works if it's the very first Streamlit command executed
    in an app, so make sure it's at the top of `dashboard.py`, right after the imports.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，这只有在它是应用程序中执行的第一个 Streamlit 命令时才有效，所以请确保它在 `dashboard.py` 的顶部，紧随导入之后。
- en: Displaying user-friendly labels for fields
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显示字段的用户友好标签
- en: To swap out the raw field names for labels, we could retain a mapping between
    the raw names and their associated labels in a dictionary, and look up the label
    every time we needed to display the name of a field. That sounds quite tedious
    though, so instead let's just rename the fields in the data frame to be user-friendly
    ones.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将原始字段名称替换为标签，我们可以在字典中保留原始名称及其相关标签之间的映射，并在需要显示字段名称时查找标签。但这听起来相当繁琐，所以让我们直接将数据框中的字段重命名为用户友好的名称。
- en: 'There will probably be a bunch of similar "cleaning-up" modifications we''ll
    need to make to the data. We''ll bundle these up into a `prep_data` function in
    `data_wrangling.py`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能需要对数据进行一系列类似的“清理”修改。我们将把这些修改打包成一个名为 `prep_data` 的函数，放在 `data_wrangling.py`
    文件中：
- en: '[PRE20]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '#A Don''t forget to import the functions we need from other modules'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 不要忘记从其他模块导入我们需要的函数'
- en: '#B Move the st.cache_data decorator so it applies to prep_data instead of load_data'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 将 st.cache_data 装饰器移动到 prep_data 而不是 load_data 上'
- en: Here we define a function called `clean_column_names` that replaces the underscores
    in each column name of a dataframe with spaces and capitalizes it. `df.columns`
    returns the dataframe column names, and `.str.replace()` and `.str.capitalize()`
    are the respective string operations. We use `.str` to apply the replace and capitalize
    operations to each element in `df.columns` in one go, which is something which
    you'll see quite frequently in Pandas.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们定义了一个名为 `clean_column_names` 的函数，该函数将数据框中每个列名中的下划线替换为空格，并将其大写。`df.columns`
    返回数据框的列名，`.str.replace()` 和 `.str.capitalize()` 是相应的字符串操作。我们使用 `.str` 将替换和大小写操作一次性应用于
    `df.columns` 中的每个元素，这在 Pandas 中会经常看到。
- en: For now, the `prep_data` function calls `load_data` internally and then simply
    returns the result of applying `clean_column_names` to the returned dataframe,
    but we'll add more logic to it later.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`prep_data`函数内部调用`load_data`，然后简单地返回对返回的数据帧应用`clean_column_names`的结果，但我们将稍后添加更多逻辑。
- en: We've also moved `st.cache_data` decorator to the `prep_data` function (remove
    it from `load_data` in `data_loader.py`) because `prep_data` is supposed to contain
    basic operations we always want done on the data. After this, Streamlit will cache
    the result only after prepping the data, not immediately after loading it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`st.cache_data`装饰器移动到`prep_data`函数中（从`data_loader.py`中的`load_data`中移除），因为`prep_data`应该包含我们对数据进行的基本操作。在此之后，Streamlit将仅在准备数据后缓存结果，而不是在加载数据后立即缓存。
- en: To close the loop, in `dashboard.py`, replace the line `data = load_data()`
    with `data = prep_data()`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了闭合循环，在`dashboard.py`中，将`data = load_data()`行替换为`data = prep_data()`。
- en: 'Finally, in `filter_panel.py`, modify `filter_dims` to use the newly polished
    field names:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`filter_panel.py`中，修改`filter_dims`以使用新抛光的字段名称：
- en: '[PRE21]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Save and re-run to see the result shown in figure 6.10
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并重新运行以查看图6.10中所示的结果
- en: '![image](../Images/06__image010.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/06__image010.png)'
- en: Figure 6.10 Filter panel with user-friendly field names and a wide layout
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.10 带有用户友好字段名称和宽布局的过滤器面板
- en: The dashboard now uses up the full width of the screen, and we're using labels
    for the filters.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板现在使用屏幕的全宽，我们正在使用标签作为过滤器。
- en: Note
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Due to the amount of code in this chapter and the limited amount of space available
    on the printed page, while providing code snippets here, we'll focus primarily
    on how the code in a particular file has *changed* rather than reproducing the
    entire file as we did in previous chapters. However, at any point, if you're stuck
    and would like to compare your code to what it should be at that point, you can
    see complete in-progress snapshots of the code in the GitHub repo for this book
    (github.com/aneevdavis/streamlit-in-action), under the chapter_6 folder. For instance,
    the code files you should be comparing to at the moment are in the in_progress_4
    directory.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章代码量较大，且打印页面上可用的空间有限，因此在这里提供代码片段时，我们将主要关注特定文件中代码的*变化*，而不是像前几章那样重新生成整个文件。然而，在任何时候，如果您遇到困难并希望将您的代码与该点应具有的代码进行比较，您可以在本书的GitHub仓库（github.com/aneevdavis/streamlit-in-action）中查看代码的完整进度快照，在chapter_6文件夹下。例如，您应该比较的代码文件目前在in_progress_4目录中。
- en: Applying the filters to the data
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 应用过滤器到数据
- en: So far, we've created the UI elements corresponding to the filters, but we haven't
    actually applied them to the data.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了与过滤器对应的UI元素，但实际上还没有将它们应用到数据上。
- en: To do this, let's first think of how we should represent the output we get from
    the filter panel. To be able to apply the filters, we need to look up the values
    the user has selected in the filter for each dimension. This is a good use case
    for a dictionary that has each field name as a key and the list of selected options
    as the value for the key.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，让我们首先考虑我们应该如何表示从过滤器面板获得的输出。为了能够应用过滤器，我们需要查找用户在每个维度上选择的过滤器值。这是一个使用字典的好用例，其中每个字段名称作为键，所选选项列表作为键的值。
- en: Our current `filter_panel` function (from `filter_panel.py`) simply displays
    the filter bar, but we want to modify it so that it actually returns such a dictionary
    that we can use for further processing.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的`filter_panel`函数（来自`filter_panel.py`）只是简单地显示过滤器栏，但我们希望修改它，使其实际上返回一个我们可以用于进一步处理的字典。
- en: '[PRE22]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Though we weren't making use of this earlier, `st.multiselec`t actually returns
    the list of options a user has selected in the UI. As the highlighted lines show,
    we're now storing this returned value in the `filters` dictionary using `dim`
    (the field name) as the key, and returning filters at the end.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们之前没有利用这一点，但`st.multiselec`实际上返回了用户在UI中选择的选项列表。正如突出显示的行所示，我们现在使用`dim`（字段名称）作为键，将此返回值存储在`filters`字典中，并在最后返回过滤器。
- en: Next, we need to use the dictionary to produce the slice of the data the user
    wants. Since this involves data manipulation operations, let's put this functionality
    in `data_wrangling.py`, in a function called `apply_filters`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用字典来生成用户想要的数据切片。由于这涉及到数据操作操作，让我们将此功能放在`data_wrangling.py`中，在名为`apply_filters`的函数中。
- en: '[PRE23]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`apply_filters` takes `df`—a Pandas dataframe—and the filters dictionary returned
    by `filter_panel`. It goes through each of the key-value pairs in filters and
    iteratively modifies the dataframe by filtering it using the statement:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply_filters` 接受 `df`（一个 Pandas 数据框）和 `filter_panel` 返回的过滤器字典。它遍历过滤器中的每个键值对，并通过使用语句迭代修改数据框：'
- en: '[PRE24]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is worth breaking down a little. The square brackets are quite versatile
    in Pandas. When you pass a column name in the brackets following a dataframe variable
    (like `df['Age group']`), it returns that column as a Pandas series—as we've seen
    previously.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这值得稍微分解一下。在 Pandas 中，方括号非常灵活。当你将列名传递给数据框变量后面的方括号（如 `df['Age group']`）时，它返回一个
    Pandas 系列如我们所见。
- en: If, instead, you pass a Pandas boolean series (a series where each item is a
    boolean) instead, it will match the numbered elements of the series against the
    ordered rows of the dataframe, returning only the rows where the corresponding
    boolean value is `True`. This is called *boolean indexing*.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相反，你传递一个 Pandas 布尔系列（每个项目都是布尔值的系列），它将匹配系列编号元素与数据框的有序行，只返回对应布尔值为 `True` 的行。这被称为
    *布尔索引*。
- en: 'You can see both of these usages in the line above:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在上面的行中看到这两种用法：
- en: '`df[col]` does column selection, selecting the col (the column to filter) in
    df.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`df[col]` 进行列选择，在 df 中选择要过滤的列 col。'
- en: The `.isin(values)` applies an element-wise operation on the column, checking
    whether each value in it is present in values, the list of dropdown options selected
    by the user. This returns another series with a `True`/`False` value for every
    corresponding item in `df[col]`. This is an example of a *vectorized* calculation,
    which is responsible for much of Pandas' performance.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`.isin(values)` 对列执行逐元素操作，检查列中的每个值是否存在于用户选择的下拉选项列表 `values` 中。这返回另一个包含 `True`/`False`
    值的系列，对应于 `df[col]` 中的每个项目。这是一个 *向量化* 计算的例子，这是 Pandas 性能的主要原因。'
- en: Finally, we perform boolean indexing, using the boolean series obtained in the
    previous step to produce a new filtered dataframe and assign *that* to df.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用前一步获得的布尔系列进行布尔索引，生成一个新的过滤后的数据框并将其分配给 df。
- en: Effectively, each time it executes, the line `df = df[df[col].isin(values)]`
    filters the dataframe to include only rows where the column we're currently looking
    at contains one of the values the user selected.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，每次执行时，行 `df = df[df[col].isin(values)]` 都会过滤数据框，只包含当前查看的列包含用户选择的值的行。
- en: The `if values` part ensures that we don't do the filtering if the user hasn't
    selected any values for a field, thus correctly implementing our requirement.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`if values` 部分确保了如果用户没有为某个字段选择任何值，我们不会进行过滤，从而正确地实现了我们的要求。'
- en: 'To see this in action, make the required modifications to `dashboard.py`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个动作，请对 `dashboard.py` 进行必要的修改：
- en: '[PRE25]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '#A We now put the dictionary returned by filter_panel(data) in a variable'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 我们现在将 filter_panel(data) 返回的字典放入一个变量中'
- en: We're now capturing the dictionary of filters, using `apply_filters` to create
    a new dataframe called `main_df`, and displaying that instead of data. This should
    give us the result in figure 6.11.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在捕获过滤器字典，使用 `apply_filters` 创建一个新的数据框 `main_df`，并显示该数据框而不是数据。这应该会给我们带来图
    6.11 的结果。
- en: '![image](../Images/06__image011.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/06__image011.png)'
- en: Figure 6.11 The selections in the filter panel correctly filter the displayed
    rows (see chapter_6/in_progress_5 in the GitHub repo for a snapshot of the full
    code)
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.11 过滤面板中的选择正确地过滤了显示的行（有关完整代码的快照，请参阅 GitHub 上的 chapter_6/in_progress_5）。
- en: As you can see, the displayed dataframe only shows rows corresponding to the
    user's selections in the filter panel (18-25, M, Staples, CA).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，显示的数据框只显示与过滤面板中用户选择对应的行（18-25, M, Staples, CA）。
- en: 'There''s still one more kind of filter to apply: the date range! Let''s deal
    with that next.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种类型的过滤器需要应用：日期范围！让我们接下来处理这个问题。
- en: 6.3.2 Creating a date range selector
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 创建日期范围选择器
- en: As usual, Streamlit offers an easy way to enable users to select a date range.
    In its typical intuitive naming fashion, the widget we want is called `st.date_input`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，Streamlit 提供了一种简单的方法来允许用户选择日期范围。按照其典型的直观命名方式，我们想要的部件被称为 `st.date_input`。
- en: '`st.date_input` accepts a label, a default value, minimum and maximum values
    and more. You can have the user select a single date or a range of dates.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.date_input` 接受一个标签、默认值、最小值和最大值等。用户可以选择单个日期或日期范围。'
- en: 'For instance, to allow the user to select a single date with today''s date
    as the default:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了允许用户选择一个默认为今天的单日日期：
- en: '[PRE26]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To enable a date range selection between a default start and end date:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在默认的开始和结束日期之间启用日期范围选择：
- en: '[PRE27]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We'll put our date range selector in a new file called `date_range_panel.py`,
    shown in listing 6.5.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将日期范围选择器放在一个名为 `date_range_panel.py` 的新文件中，如列表 6.5 所示。
- en: Listing 6.5 date_range_panel.py
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.5 date_range_panel.py
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `date_range_panel` function displays two date selector widgets—one each
    for the start and end of the range—and returns the dates selected by the user.
    We're opting to use two separate single-date inputs here instead of a single range
    input to prevent temporary errors when the end of the range hasn't been selected
    yet.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`date_range_panel` 函数显示两个日期选择器小部件——一个用于范围的开始，一个用于结束——并返回用户选择的日期。我们选择在这里使用两个单独的单日输入而不是单个范围输入，以防止在尚未选择范围的结束日期时出现临时错误。'
- en: For the default date range values, we show a start date of one month ago and
    an end date of today, using the variables `THIRTY_DAYS_AGO` and `LATEST_DATE`.
    Since we're dealing with a static dataset, we hardcode `LATEST_DATE` to a particular
    date that's available in the CSV. If we were working with real-time or regularly
    updated data, we would have replaced this with `LATEST_DATE = date.today()`. `THIRTY_DAYS_AGO`
    is obtained by subtracting 30 days from `LATEST_DATE` using the `timedelta` class
    from the `datetime` module.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于默认日期范围值，我们显示了一个月前的开始日期和今天的结束日期，使用变量 `THIRTY_DAYS_AGO` 和 `LATEST_DATE`。由于我们处理的是一个静态数据集，我们将
    `LATEST_DATE` 硬编码为 CSV 中可用的特定日期。如果我们处理的是实时或定期更新的数据，我们将用 `LATEST_DATE = date.today()`
    替换它。`THIRTY_DAYS_AGO` 是通过从 `LATEST_DATE` 中减去 30 天，使用 `datetime` 模块中的 `timedelta`
    类获得的。
- en: The values `LATEST_DATE` and `THIRTY_DAYS_AGO` are of the type `date`, from
    the built-in `datetime` module. `st.date_input` understands this type and even
    returns it. The variables `start` and `end` returned by `date_range_panel` are
    thus both also of type `date`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`LATEST_DATE` 和 `THIRTY_DAYS_AGO` 的值是来自内置 `datetime` 模块的 `date` 类型。`st.date_input`
    理解这种类型，甚至返回它。因此，`date_range_panel` 返回的 `start` 和 `end` 变量也都是 `date` 类型。'
- en: 'In fact, let''s make use of those values presently by editing `data_wrangling.py`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，让我们现在利用这些值通过编辑 `data_wrangling.py` 来使用它们：
- en: '[PRE29]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We''ve made a few changes here:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做了一些更改：
- en: In addition to cleaning up the column names, `prep_data` adds a new column called
    'Day', the result of applying `pd.to_datetime()` to the existing 'Date' column.
    Recall that the 'Date' column is currently an opaque "object" type. `pd.to_datetime()`
    converts it to `datetime[ns]` which can be optimized by Pandas.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 除了清理列名之外，`prep_data` 还添加了一个名为 'Day' 的新列，它是将 `pd.to_datetime()` 应用到现有的 'Date'
    列的结果。回想一下，'Date' 列目前是一个不透明的 "object" 类型。`pd.to_datetime()` 将其转换为 `datetime[ns]`
    类型，这可以通过 Pandas 进行优化。
- en: We've wrapped a call to `apply_filters` within the `get_filtered_data_within_date_range`
    function, which first accepts the start and end dates of the date range and uses
    them to call `get_data_within_date_range`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `get_filtered_data_within_date_range` 函数中包装了对 `apply_filters` 的调用，该函数首先接受日期范围的开始和结束日期，并使用它们来调用
    `get_data_within_date_range`。
- en: '`get_data_within_date_range` is the function that actually applies the date
    range filter on our dataframe. The first line in this function does a date format
    conversion:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_data_within_date_range` 是实际在我们的 dataframe 上应用日期范围过滤器的函数。该函数的第一行执行日期格式转换：'
- en: '[PRE30]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is because Pandas uses a `datetime[ns]` type to represent dates. This is
    different from Python's `date` type that `start` and `end` are in, and is more
    efficient for use in dataframe operations.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Pandas 使用 `datetime[ns]` 类型来表示日期。这与 `start` 和 `end` 所在的 Python 的 `date`
    类型不同，并且在 dataframe 操作中更有效。
- en: '[PRE31]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is boolean indexing again, similar to what we encountered in the `apply_filters`
    function, but we're using a combination of two conditions (`df['Day'] >= dt_start
    and df['Day'] <= dt_end`) to filter the dataframe, joining them with `&`, which
    is Pandas' element-wise logical `AND` operator.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是布尔索引，类似于我们在 `apply_filters` 函数中遇到的，但我们使用两个条件（`df['Day'] >= dt_start and df['Day']
    <= dt_end`）的组合来过滤 dataframe，并用 `&` 连接它们，这是 Pandas 的元素级逻辑 `AND` 运算符。
- en: 'We also need to update dashboard.py again:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要再次更新 dashboard.py：
- en: '[PRE32]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We place the date range panel in a sidebar (which you should be quite comfortable
    with by now).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将日期范围面板放置在侧边栏中（你现在应该非常熟悉了）。
- en: And since `apply_data` is now contained within `get_filtered_data_within_date_range`,
    we assign the result of this wrapping function to `main_df`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `apply_data` 现在包含在 `get_filtered_data_within_date_range` 中，我们将这个包装函数的结果赋值给
    `main_df`。
- en: Figure 6.12 shows our new date range panel.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12显示了我们的新日期范围面板。
- en: '![image](../Images/06__image012.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/06__image012.png)'
- en: Figure 6.12 Date range inputs displayed in a sidebar (see chapter_6/in_progress_6
    in the GitHub repo for a full code snapshot)
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.12 显示在侧边栏中的日期范围输入（在GitHub仓库的chapter_6/in_progress_6中查看完整的代码快照）
- en: Our dashboard is slowly starting to take form! It's not very useful to the CEO
    at the moment, however, since it doesn't show any summary information or metrics.
    That's up next!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的仪表板正在慢慢成形！然而，目前对CEO来说并不太有用，因为它没有显示任何总结信息或指标。接下来就是这些内容！
- en: 6.4 Calculating and displaying metrics
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 计算和显示指标
- en: Imagine you're running a business. How do you know if it's thriving or struggling,
    whether it's about to go through the roof or come crashing down?
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在经营一家企业。你怎么知道它是否繁荣或挣扎，它是否即将飞涨或崩溃？
- en: One obvious answer is that you'd look at how much the company is earning and
    the amount of profit it's making. You'll likely also want to know the rate at
    which your revenue is growing. If you're a fan of Shark Tank's Mr. Wonderful,
    you probably also keep track of more esoteric numbers such as how much it costs
    you to acquire a customer.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的答案是你应该查看公司赚了多少钱以及它赚取的利润总额。你可能还想知道你的收入增长的速度。如果你是《鲨鱼坦克》中Mr. Wonderful的粉丝，你可能还会关注一些更专业的数字，比如获取一个客户需要花费你多少钱。
- en: All of these numbers are called *metrics*. Metrics are useful because they help
    you boil down all the complexity of a vast business (or any project, really) into
    a few figures. If a positive metric (like profit) is going up or a negative metric
    (like cost) is going down, that means things are going well. If the opposite is
    happening, something likely needs to change.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些数字都被称为*指标*。指标是有用的，因为它们可以帮助你将一个庞大业务（或任何项目，实际上）的所有复杂性简化为几个数字。如果一个积极的指标（如利润）正在上升，或者一个消极的指标（如成本）正在下降，这意味着事情进展顺利。如果情况相反，可能需要做出一些改变。
- en: In this section, we'll calculate and display the metrics that Note n' Nib's
    CEO cares about. To do this, we'll first understand what the metrics mean and
    how to calculate them. We'll then set up a scalable way to define new metrics
    for our dashboard to use, and display them prominently in the dashboard.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将计算并显示Note n' Nib的CEO关心的指标。为此，我们首先了解这些指标的含义以及如何计算它们。然后，我们将设置一种可扩展的方式来定义仪表板使用的新指标，并在仪表板中突出显示它们。
- en: 6.4.1 Calculating the metrics
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.1 计算指标
- en: 'Referring back to our requirements, there are four metrics we care about: *total
    sales*, *gross margin*, *margin percentage*, and *average transaction value*.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的需求，我们有四个我们关心的指标：*总销售额*、*毛利率*、*利润率*和*平均交易价值*。
- en: 'Let''s try and understand these in reference to our data. Recall that our source
    CSV has one row for every combination of date, product (and its associated segment
    and category), gender, age group and state. For each row, it gives us three numeric
    fields: *sales*, *gross margin*, and *transactions*.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过我们的数据来理解这些。回想一下，我们的源CSV文件为每个日期、产品（及其相关的细分和类别）、性别、年龄组和州组合创建一行。对于每一行，它给我们三个数值字段：*销售额*、*毛利率*和*交易*。
- en: 'A transaction refers to a single purchase of some number of items, and the
    figure "transactions" refers to the number of them represented by a row. Sales
    is pretty easy to understand: it''s the amount in dollars Note n'' Nib collected
    from those transactions. Gross margin is the profit, or sales minus the cost that
    the company paid to acquire what the items it sold.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 交易是指购买一定数量商品的单一购买，而“交易”这个数字指的是一行中代表它们的数量。销售额很容易理解：它是Note n' Nib从这些交易中收集到的美元金额。毛利率是指利润，即销售额减去公司为获取所售商品而支付的成本。
- en: 'Given this, let''s figure out how to calculate our metrics for any given slice
    of our CSV:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，让我们弄清楚如何计算我们CSV文件中任何给定部分的指标：
- en: '**Total sales** is simply the sum of the sales column'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总销售额**仅仅是销售额列的总和。'
- en: Similarly, **gross margin** is the sum of the gross margin column
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，**毛利率**是毛利率列的总和。
- en: '**Margin percentage** is the gross margin expressed as a percentage of total
    sales, so it''s calculated as total sales / gross margin * 100'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利润率**是将毛利率表示为总销售额的百分比，因此它被计算为总销售额除以毛利率乘以100。'
- en: '**Average transaction value** is the what Note n'' Nib earned per transaction,
    so we can calculate it as total sales / sum of the transactions column'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平均交易价值**是指Note n'' Nib每次交易赚取的金额，因此我们可以将其计算为总销售额除以交易列的总和。'
- en: 'Let''s consider a quick example to crystallize this. Imagine you have the following
    rows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个快速示例来阐明这一点。假设您有以下行：
- en: '[PRE33]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Total sales* is $500 + $300 + $200 = $1000'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*总销售额* 是 $500 + $300 + $200 = $1000'
- en: '*Gross margin* is $200 + $120 + $80 = $400'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*毛利润* 是 $200 + $120 + $80 = $400'
- en: '*Margin percentage* is $400 / $1000 = 0.4 = 40%'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*利润率百分比* 是 $400 / $1000 = 0.4 = 40%'
- en: '*Average transaction value* is $1000 / (10 + 5 + 8) = $1000 / 23 = $43.48'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*平均交易价值* 是 $1000 / (10 + 5 + 8) = $1000 / 23 = $43.48'
- en: 6.4.2 Setting up the metrics configuration
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.2 设置指标配置
- en: A recurring theme you'll come across in software development is that it's a
    good idea to keep your design reasonably *general*. By this, I mean that if you
    have a choice between coding something in a very specific way (hardcoding a list
    of values, for instance) and coding it in a flexible way (populating the list
    from a configuration file), it's often better practice to do the latter.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，您会遇到的一个反复出现的主题是，保持设计合理地 *通用* 是一个好主意。通过这种方式，我的意思是，如果您在以非常具体的方式（例如硬编码值列表）和以灵活的方式（从配置文件中填充列表）编写代码之间有选择，那么通常更好的做法是后者。
- en: A more general design makes your code more adaptable to future changes, and
    easier to maintain. We saw this when we developed a unit converter app in Chapter
    3, where rather than putting the conversion factors directly in our code, we opted
    to use a configuration file.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 更通用的设计使您的代码更容易适应未来的变化，并且更容易维护。我们在第 3 章开发单位转换应用程序时看到了这一点，在那里我们选择使用配置文件而不是直接在我们的代码中放置转换系数。
- en: This is exactly what we'll do to set up the metrics in our dashboard—define
    a configuration file that defines how to calculate them.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们将要在我们的仪表板上设置指标的方式——定义一个配置文件，该文件定义了如何计算它们。
- en: As we did in Chapter 3, we'll start by creating a dataclass—`Metric`—to hold
    the object we want to configure. Let's put this in a new file called `metric.py`
    (see listing 6.6).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 3 章中所做的那样，我们将首先创建一个数据类——`Metric`——来保存我们想要配置的对象。让我们将其放入一个名为 `metric.py`
    的新文件中（参见列表 6.6）。
- en: Listing 6.6 metric.py
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.6 metric.py
- en: '[PRE34]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `Metric` class contains a title, which is the label we'll display on the
    interface, and a type, which indicates how it should be formatted (eg. "dollars"
    as the type would instruct our app to prefix a '$' sign before the number).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`Metric` 类包含一个标题，这是我们将在界面上显示的标签，以及一个类型，它指示应该如何格式化（例如，类型为 "dollars" 将指示我们的应用程序在数字前加上一个
    ''$'' 符号）。'
- en: It also has a member called `func` which is apparently a *callable.* Callables
    are essentially just functions, and `func` is meant to be a function that accepts
    a Pandas dataframe object and calculates the value of the metric.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 它还有一个名为 `func` 的成员，显然是一个 *可调用对象*。可调用对象本质上只是函数，而 `func` 的意图是作为一个函数，它接受一个 Pandas
    数据框对象并计算指标值。
- en: To truly understand this, let's see how objects of the `Metric` class are defined
    in our configuration file, `metric_config.py`, shown in listing 6.7.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正理解这一点，让我们看看 `Metric` 类的对象是如何在我们的配置文件 `metric_config.py` 中定义的，如列表 6.7 所示。
- en: Listing 6.7 metric_config.py
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.7 metric_config.py
- en: '[PRE35]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Turn your attention to the variable `metrics`, a dictionary with the names of
    each of our metrics as keys, and their corresponding `Metric` objects as values.
    Again, this is reminiscent of `unit_config.py` from Chapter 3, where we did essentially
    the same thing.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的注意力转向变量 `metrics`，它是一个字典，以我们每个指标的名称作为键，以及相应的 `Metric` 对象作为值。再次强调，这与第 3 章中的
    `unit_config.py` 类似，在那里我们做了几乎同样的事情。
- en: 'Let''s inspect the first item in the dictionary:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查字典中的第一个条目：
- en: '[PRE36]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is the "total sales" metric, which has a sensible display label as its
    `title`, and "dollars" as its `type`. `func` here is a lambda (which, you might
    remember from Chapter 2, is an anonymous one-line function). It accepts a single
    argument—`df`, a Pandas dataframe-~-and calculates total sales using the expression:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 "总销售额" 指标，它有一个合理的显示标签作为其 `title`，以及 "dollars" 作为其 `type`。这里的 `func` 是一个 lambda
    表达式（您可能还记得，在第 2 章中，它是一个匿名的一行函数）。它接受一个参数——`df`，一个 Pandas 数据框，并使用表达式计算总销售额：
- en: '[PRE37]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`df["Sales"]`, as we''ve discussed before, selects just the "Sales" column
    from `df`, and `.sum()` adds up all the values in it to obtain the final value
    of the metric.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`df["Sales"]`，正如我们之前讨论的，从 `df` 中选择 "Sales" 列，而 `.sum()` 将其中的所有值加起来以获得指标的最终值。'
- en: The other metrics defined in the dictionary are fairly similar, and their calculations
    should make sense after the discussion in the previous section. The "Margin %"
    and "ATV" metrics *don't* use a lambda for their funcs.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 字典中定义的其他指标相当相似，它们的计算应该在上一节的讨论之后有意义。"Margin %" 和 "ATV" 指标不使用 lambda 表达式作为它们的
    `func`。
- en: 'Rather, in each of these cases, `func` points to a regular function (`margin_percent`
    and `average_transaction_value`) defined above. Since these metrics are both ratios,
    we need to handle the possibility that the denominator is zero, preventing a division-by-zero
    error:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在这些情况中，`func` 指向上面定义的常规函数（`margin_percent` 和 `average_transaction_value`）。由于这些指标都是比率，我们需要处理分母为零的可能性，以防止除以零错误：
- en: '[PRE38]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The bottom of our configuration file has the following line:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置文件的底部有如下一行：
- en: '[PRE39]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The variable is meant to hold the metrics we'll actually display in our metric
    bar. This may seem kind of pointless since we're just listing out all of the keys
    in the `metrics` dictionary. However, this might come in handy if we ever decided
    to include more metrics and don't want to display all of them, or want to display
    them in a specific order. We'll see in a bit how `display_metrics` is actually
    used.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 变量旨在存储我们将在指标栏中实际显示的指标。这看起来可能有点无意义，因为我们只是在 `metrics` 字典中列出所有键。然而，如果我们决定包含更多指标而不想显示所有指标，或者想按特定顺序显示它们，这可能会很有用。我们稍后会看到
    `display_metrics` 的实际用法。
- en: 6.4.3 Formatting the metrics
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.3 格式化指标
- en: One of the pieces of information we capture in the `Metric` class is the "type"
    of the metric, used primarily for formatting.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Metric` 类中捕获的信息之一是指标的“类型”，主要用于格式化。
- en: In our configuration file, three of our metrics are of the "dollars" type, while
    Margin % is of the "percent" type.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配置文件中，我们的三个指标是“美元”类型，而“利润百分比”是“百分比”类型。
- en: Let's now define the formatting logic in its own module, `formatting.py` (see
    listing 6.8). For this, we'll be using a third-party library called `humanize`
    (install it the usual way, i.e. by running `pip install humanize`), which provides
    some nice formatting features.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将定义格式化逻辑，并在其自己的模块 `formatting.py` 中实现（参见列表 6.8）。为此，我们将使用一个名为 `humanize`
    的第三方库（按照常规方式安装，即运行 `pip install humanize`），它提供了一些不错的格式化功能。
- en: Listing 6.8 formatting.py
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.8 formatting.py
- en: '[PRE40]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `format_metric` function takes a numeric value and a metric type, and returns
    a formatted display string.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`format_metric` 函数接受一个数值和一个指标类型，并返回一个格式化的显示字符串。'
- en: The `humanize` library we just installed comes into play while formatting a
    dollar-type metric. Since Note n' Nib is such a popular retailer, its sales figures
    are in the millions. If the raw revenue number we're tasked with displaying is
    $25,125,367, we'd rather not show the precise value to the CEO. An abbreviated
    version like "$25.1m" will do the trick while reducing cognitive load for the
    user.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚安装的 `humanize` 库在格式化美元类型指标时发挥作用。由于 Note n' Nib 是如此受欢迎的零售商，其销售额以百万计。如果我们被要求显示的原始收入数字是
    $25,125,367，我们宁愿不向首席执行官展示精确值。像 "$25.1m" 这样的缩写版本将起到作用，同时减少用户的认知负担。
- en: This is exactly what the `humanize.metric` method does. Given a raw number,
    it will return a rounded number with a sensible lower precision and a suffix ("k"
    for thousands, "m" for millions, etc). We add the "$" sign manually to get the
    f-string `f'${humanize.metric(value)}'`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是 `humanize.metric` 方法所做的事情。给定一个原始数字，它将返回一个经过四舍五入的数字，具有合理的低精度和后缀（“k”代表千，“m”代表百万等）。我们手动添加“$”符号以获得
    f-string `f'${humanize.metric(value)}'`。
- en: For percent-metrics, we multiply the actual value by 100 to convert it from
    a fraction to a percentage, and round it to a single decimal point before adding
    the "%" sign.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 对于百分比指标，我们将实际值乘以100，将其从分数转换为百分比，并在添加“%”符号之前将其四舍五入到一个小数点。
- en: For anything else, we don't do any formatting and just print the value as-is.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他任何内容，我们不做任何格式化，只是按原样打印值。
- en: 6.4.4 Displaying the metrics
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.4 显示指标
- en: With all the building blocks in place, we can now go ahead and create the metric
    bar in Streamlit. To do this, create yet another Python module, called `metric_bar.py`,
    with the code from listing 6.9
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有构建块就绪后，我们现在可以继续在 Streamlit 中创建指标栏。为此，创建另一个名为 `metric_bar.py` 的 Python 模块，其中包含列表
    6.9 中的代码。
- en: Listing 6.9 metric_bar.py
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.9 metric_bar.py
- en: '[PRE41]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `metric_bar` function iterates through the list of metrics we flagged for
    display (`display_metrics` from `metric_config.p`y), adding an `st.metric` element
    within a display column for each of them.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`metric_bar` 函数遍历我们标记用于显示的指标列表（来自 `metric_config.p`y 的 `display_metrics`），为每个指标在显示列中添加一个
    `st.metric` 元素。'
- en: That's the gist of it, but there are a few interesting bits here.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的核心内容，但这里有几个有趣的部分。
- en: 'The first is the use of `st.container`, a new Streamlit element. Here we''re
    just using it to put the metric bar within a box with a border:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点是使用`st.container`，这是一个新的Streamlit元素。在这里，我们只是用它将指标条形图放入一个带有边框的框中：
- en: '[PRE42]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There is more to `st.container`, however. One use case for it is when we want
    to display elements "out of order", or in a different order than they are written
    in the code. We'll come across this later in the book.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`st.container`还有更多用途。其中一个用例是我们想要显示“顺序外”的元素，或者以不同于代码中编写的顺序显示。我们将在本书的后面遇到这种情况。
- en: 'We use the `get_metric` function to extract the value of a metric, given a
    dataframe and a Metric object. Since each Metric object already has a `func` member
    that defines how to do this, the body of `get_metric` is as simple as calling
    it:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`get_metric`函数来提取一个指标值，给定一个数据框和一个指标对象。由于每个指标对象已经有一个`func`成员来定义如何进行这一操作，因此`get_metric`的主体非常简单，只需调用它即可：
- en: '[PRE43]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The last interesting bit is this part:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 最后有趣的部分是这里：
- en: '[PRE44]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You may find this rather strange. We've already defined a column for the metric
    (`metric_cols[idx]`), but it seems like we're splitting that column into three
    *sub*-columns, and then putting the `st.metric` widget in only the second one!
    What's the point of this?
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得这相当奇怪。我们已经为指标定义了一个列（`metric_cols[idx]`），但看起来我们似乎将那个列分成了三个*子*列，然后将`st.metric`小部件只放在第二个中！这有什么意义呢？
- en: Well, this is actually a layout hack. Unfortunately, as of time of writing,
    Streamlit doesn't offer a great way of horizontally centering items within a column
    without HTML. So instead, here we're creating three columns within the main column,
    with the first and third being equal-width blank ones and the second holding the
    actual content. The overall effect is that the content of the second sub-column
    appears centered within the main column.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这实际上是一个布局技巧。不幸的是，截至写作时，Streamlit没有提供一种在不使用HTML的情况下在列内水平居中项的出色方法。因此，在这里，我们在主列内创建了三个列，其中第一和第三个是等宽的空白列，第二个则包含实际内容。整体效果是，第二个子列的内容在主列中看起来是居中的。
- en: 'With that, all we need is a quick update to `dashboard.py` and we should be
    good to move on:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需要快速更新`dashboard.py`，然后我们就可以继续前进：
- en: '[PRE45]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We've removed the sample dataframe rows from the display and replaced it with
    the metric bar. Re-run the dashboard to find the output in figure 6.13.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从显示中移除了样本数据框的行，并用指标条形图替换了它们。重新运行仪表板以找到图6.13中的输出。
- en: '![image](../Images/06__image013.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/06__image013.png)'
- en: Figure 6.13 Metrics bar showing key metrics in aggregate (see chapter_6/in_progress_7
    in the GitHub repo for the full code)
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.13 指标条形图显示了关键指标的汇总（完整的代码请参阅GitHub仓库中的chapter_6/in_progress_7）
- en: Let's tackle some of the visualization components of the dashboard next.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们解决仪表板的一些可视化组件。
- en: 6.5 Constructing visualizations
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 构建可视化
- en: Humans are intuitively visual beings. When you're trying to convey a message
    through data, it's usually more memorable and *clicks* much faster when you use
    a graph rather than a table of numbers. This is especially important for busy
    executives who may have to deal with a breadth of matters and need to develop
    an understanding of the business so they can make decisions quickly.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 人类天生具有直观的视觉能力。当你试图通过数据传达信息时，使用图表而不是数字表格通常更容易记住，并且点击速度更快。这对于忙碌的执行者尤为重要，他们可能需要处理众多事务，并需要快速了解业务以便做出决策。
- en: In this section, we'll add visualizations to our dashboard in the form of a
    line chart to show how the metrics we're tracking have changed over time, and
    a pie chart to show the breakdown of those metrics across a chosen dimension.
    In each case, we'll use Pandas to wrangle the data into a form we can visualize
    easily, whip up the actual images using a library called Plotly, and display them
    using Streamlit.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将以折线图的形式将可视化添加到仪表板中，以显示我们跟踪的指标随时间的变化，以及以饼图的形式显示这些指标在所选维度上的分解。在每种情况下，我们将使用Pandas将数据整理成易于可视化的形式，使用名为Plotly的库生成实际图像，并使用Streamlit显示它们。
- en: 6.5.1 Creating a time series chart
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1 创建时间序列图
- en: A time series is simply a sequence of data points recorded at regular time intervals,
    showing how a particular metric or variable changes over time. This is crucial
    for spotting trends, seasonality, and outliers, which can inform decision-making.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列简单来说就是一系列在固定时间间隔记录的数据点，展示了特定指标或变量随时间的变化情况。这对于发现趋势、季节性和异常值至关重要，这些信息可以指导决策。
- en: You can think of a simple time series as a series of data with two variables—one
    representing a date or time, and another representing the measure we're tracking.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将简单的时间序列视为具有两个变量的数据序列——一个代表日期或时间，另一个代表我们正在跟踪的度量。
- en: 'For instance, this is a time series:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个时间序列：
- en: '[PRE46]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Obtaining a time series from our dataframe
  id: totrans-367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从我们的数据框中获取时间序列
- en: Recall that the data we're dealing with have many different fields—date, product
    name, gender, sales, and so on. We're going to have to transform it into the specific
    shape of a time series before we can pass it to the visualization we'll build.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们正在处理的数据有许多不同的字段——日期、产品名称、性别、销售额等等。在我们将数据传递给我们将要构建的可视化之前，我们必须将其转换成时间序列的特定形状。
- en: We have a "Day" field in our data, but one particular row in our dataframe represents
    the value for a particular combination of gender, age group, product name, etc.
    What we need is something that, given any particular slice of our full dataframe
    (which is what our filters give us), *aggregates* the data up to the "Day" level.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据中有一个 "Day" 字段，但数据框中特定的一行代表特定组合的性别、年龄组、产品名称等的值。我们需要的是，给定我们完整数据框的任何特定部分（这就是我们的过滤器给出的），能够将数据聚合到
    "Day" 级别。
- en: 'For example, a user may have applied the filters "State = CA" giving us the
    following slice of data (simplified for clarity, excluding the other fields):'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个用户可能应用了 "State = CA" 的过滤器，给我们以下数据片段（为了清晰起见简化，排除了其他字段）：
- en: '[PRE47]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Our time series should contain only "Day" and "Total sales", so we need to
    add up the sales for each date across state, gender and product:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的时间序列应仅包含 "Day" 和 "Total sales"，因此我们需要将每个日期在州、性别和产品上的销售额加起来：
- en: '[PRE48]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To do this in Pandas, assuming our dataframe is called `df`, we could write
    the following:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pandas 中做这个，假设我们的数据框名为 `df`，我们可以编写以下代码：
- en: '[PRE49]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s break this down. `df.groupby(''Day'')` would give us a grouped dataframe,
    which you can imagine as being represented internally like this:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下。`df.groupby('Day')` 会给我们一个分组后的数据框，你可以想象它内部表示如下：
- en: '[PRE50]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, consider the line `grouped.apply(lambda df: df[''Sales''].sum(), include_groups=False)`'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，考虑以下行 `grouped.apply(lambda df: df[''Sales''].sum(), include_groups=False)`'
- en: The apply method is an extremely powerful Pandas construct that lets you apply
    a function to each row or column of a dataframe or to the values of a series.
    When used on a grouped dataframe like the one above, it allows you to perform
    operations on each group separately.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply` 方法是 Pandas 中一个非常强大的结构，它允许你将函数应用于数据框的每一行或每一列，或者应用于序列的值。当用于如上所述的分组数据框时，它允许你分别对每个组执行操作。'
- en: 'In this case, the lambda function `lambda df: df[''Sales''].sum()` takes each
    group (which corresponds to a specific day) and calculates the total sales for
    that day by summing the `Sales` values. In the example above, the day 2024-08-01
    would have a total `Sales` value of 2800, adding up the sales for the RoyalQuill
    and GripLink rows.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，lambda 函数 `lambda df: df[''Sales''].sum()` 对每个组（对应于特定的某一天）进行操作，通过求和
    `Sales` 值来计算该天的总销售额。在上面的例子中，2024-08-01 这一天的总 `Sales` 值为 2800，这是 RoyalQuill 和 GripLink
    行销售额的总和。'
- en: The `include_groups = False` bit indicates that we don't want the function to
    also operate on group labels (the `Day` values). It's kind of redundant here as
    our lambda function specifically refers to the `"Sales"` column, but if you don't
    include this, Pandas will whine about it.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`include_groups = False` 这一部分表示我们不希望函数同时对组标签（`Day` 的值）进行操作。在这里有点多余，因为我们的 lambda
    函数专门引用了 `"Sales"` 列，但如果你不包括这个，Pandas 会对此抱怨。'
- en: Finally, the `reset_index()` method converts the results back to a standard
    DataFrame format. An *index* is a Pandas concept referring to a unique identifier
    column for each row, enabling efficient data retrieval and alignment; after summing,
    the `Day` column becomes the index. By calling reset_index(), we restore `Day`
    as a regular column and create a new index that ranges from 0 to n-1, where n
    is the number of unique days.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`reset_index()` 方法将结果转换回标准的 DataFrame 格式。*索引*是 Pandas 的一个概念，指的是每行的唯一标识符列，它使得数据检索和校准变得高效；在求和后，`Day`
    列成为索引。通过调用 `reset_index()`，我们将 `Day` 恢复为常规列，并创建一个新的索引，范围从 0 到 n-1，其中 n 是唯一天数。
- en: We need a slightly more generalized version of the above code for our dashboard,
    as our line chart may need to show any of our four key metrics, not just sales
    (see figure 6.14 from our UI mock).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的仪表板，我们需要一个稍微更通用的上述代码版本，因为我们的折线图可能需要显示我们四个关键指标中的任何一个，而不仅仅是销售额（参见我们 UI 模拟的图
    6.14）。
- en: '![image](../Images/06__image014.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/06__image014.png)'
- en: Figure 6.14 The time series chart from our UI mock
  id: totrans-385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.14 我们 UI 模拟的时间序列图表
- en: So rather than passing in `df["Sales"].sum()` as the function to apply, we'll
    obtain this function from the `func` attribute of the `Metric` class we defined
    in `metric.py` and instantiated in `metric_config.py`.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不会将 `df["Sales"].sum()` 作为要应用的功能传递，而是从我们在 `metric.py` 中定义并在 `metric_config.py`
    中实例化的 `Metric` 类的 `func` 属性中获取这个功能。
- en: '[PRE51]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Our function accepts a dataframe `df` and `metric`, one of the `Metric` objects
    from `metric_config.py`. As you can see, we pass `metric.func` to `grouped.apply`
    to make it general.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能接受一个数据框 `df` 和 `metric`，它是来自 `metric_config.py` 的 `Metric` 对象之一。正如你所看到的，我们通过将
    `metric.func` 传递给 `grouped.apply` 来使其通用。
- en: The line `data.columns = ['Day', 'Value']` resets the column names of the resultant
    dataframe to new ones.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.columns = [''Day'', ''Value'']` 这行代码将结果数据框的列名重置为新的名称。'
- en: Now that we have our time series, let's build our line chart.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的时间序列，让我们构建我们的折线图。
- en: Using Plotly to build a line chart with our time series
  id: totrans-391
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Plotly 构建我们的时间序列折线图
- en: As we touched upon briefly in Chapter 1, Streamlit supports many different data
    visualization libraries. Plotly is one such library that tends to be fairly easy
    to use and offers a range of engaging interactive visualizations.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第一章中简要提到的，Streamlit 支持许多不同的数据可视化库。Plotly 是其中之一，它通常很容易使用，并提供了一系列引人入胜的交互式可视化。
- en: To use it, you first need to install it with `pip install plotly.`
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，你首先需要使用 `pip install plotly` 安装它。
- en: The flavor of Plotly we'll use is called Plotly Graph Objects (GO for short).
    GO allows you to construct plots with a high degree of control and customization,
    making it ideal for interactive charts where you can define every detail.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的 Plotly 版本被称为 Plotly 图形对象（简称 GO）。GO 允许你以高程度控制和定制构建图表，使其非常适合交互式图表，你可以定义每个细节。
- en: Create a new Python module named `time_series_chart.py` with the code in listing
    6.10.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `time_series_chart.py` 的新 Python 模块，并在列表 6.10 中编写代码。
- en: Listing 6.10 time_series_chart.py
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.10 time_series_chart.py
- en: '[PRE52]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The import statement at the top makes Plotly Graph Objects available; the abbreviation
    `go` is conventionally used to refer to it.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的导入语句使 Plotly 图形对象可用；缩写 `go` 是传统上用来指代它的。
- en: The `get_time_series_chart` metric takes our dataframe as well as an object
    of type `Metric` and returns the line chart (a Plotly `Figure` object) that we
    can pass later to a Streamlit widget for display.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_time_series_chart` 指标接受我们的数据框以及一个类型为 `Metric` 的对象，并返回我们可以稍后传递给 Streamlit
    小部件进行显示的折线图（一个 Plotly `Figure` 对象）。'
- en: We first obtain our time series data by calling the `get_metric_time_series`
    function we defined earlier.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过调用我们之前定义的 `get_metric_time_series` 函数来获取我们的时间序列数据。
- en: Plotly charts are constructed incrementally. We start with an empty chart and
    add the components we need bit-by-bit. Here, the line `fig = go.Figure()` initializes
    the chart and assigns it to `fig`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: Plotly 图表是逐步构建的。我们从一个空图表开始，逐步添加所需的组件。在这里，`fig = go.Figure()` 初始化图表并将其分配给 `fig`。
- en: 'The next part adds the actual line to the chart:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将实际的线条添加到图表中：
- en: '[PRE53]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We're creating a `go.Scatter` object here, which represents a scatterplot. A
    scatterplot simply plots points on a graph with two axes (the x-axis and the y-axis).
    Each point has a pair of coordinates. In this case, the x-coordinates are supplied
    by `data['Day']`, or the dates we want to show in the chart, and the y-coordinates
    are in `data['Value']`, which will be the values of one of our key metrics (depending
    on which one the variable `metric` contains).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个 `go.Scatter` 对象，它代表一个散点图。散点图简单地在二维坐标轴（x轴和y轴）上绘制点。每个点都有一个坐标对。在这种情况下，x坐标由
    `data['Day']` 提供，即我们想在图表中显示的日期，而y坐标在 `data['Value']` 中，这将是我们关键指标之一（取决于变量 `metric`
    包含的是哪一个）。
- en: We also pass `mode='lines+markers'`, which makes it so that in addition to plotting
    the points (using "markers"), Plotly also puts lines between them. The effect
    is that every (`Day`, `Value`) pair in our dataframe has a marker, and all the
    markers are connected by lines, forming the line chart we need.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还传递 `mode='lines+markers'`，这使得 Plotly 不仅绘制点（使用“标记”），还在它们之间画线。结果是，我们数据框中的每个
    (`Day`, `Value`) 对都有一个标记，所有标记都由线连接，形成了我们需要的折线图。
- en: We then add the plot we just created to our `Figure` object by passing it to
    `fig.add_trace()`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将我们刚刚创建的图表添加到我们的 `Figure` 对象中，通过将其传递给 `fig.add_trace()`。
- en: '[PRE54]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The last part, shown above, simply adds some text to our graph, such as a title
    (which we get from our `Metric` object's `title` attribute, defined in `metric_config.py`),
    and the titles of the x- and y-axes.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的最后部分，只是在我们图表中添加了一些文本，例如标题（我们从`Metric`对象的`title`属性中获取，该属性在`metric_config.py`中定义），以及x轴和y轴的标题。
- en: 'We now know how to create the chart we require. We still need to actually display
    it though, so go ahead and update `time_series_chart.py`, adding a `time_series_chart`
    function at the bottom and the corresponding imports at the top:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何创建所需的图表。但我们还需要实际显示它，所以继续更新`time_series_chart.py`，在底部添加一个`time_series_chart`函数，并在顶部添加相应的导入：
- en: '[PRE55]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Once again, we use `st.container(border=True)` to make a box to put our line
    chart in.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`st.container(border=True)`来制作一个盒子，将我们的折线图放入其中。
- en: 'The next bit, `chart_tabs = st.tabs(display_metrics)`, introduces a new Streamlit
    UI widget: `st.tabs`.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分，`chart_tabs = st.tabs(display_metrics)`，引入了一个新的Streamlit UI小部件：`st.tabs`。
- en: As the name suggests, `st.tabs` creates a tabbed area in your app that lets
    users switch between pieces of content by clicking tabs at the top. The argument
    to `st.tabs` is the list of tab titles to use.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`st.tabs`在应用中创建了一个标签页区域，允许用户通过点击顶部的标签在内容之间切换。`st.tabs`的参数是要使用的标签标题列表。
- en: For instance, `st.tabs(["Home", "About us", "Careers"])` would create three
    tabs with the titles "Home", "About us", and "Careers".
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`st.tabs(["Home", "About us", "Careers"])`将创建三个带有标题“Home”、“About us”和“Careers”的标签页。
- en: We're trying to create one tab for each metric with its respective line chart,
    so we can pass the variable `display_metrics` from `metric_config.py`—which, you
    may recall, is a list of the metrics we care about that we can use as tab titles.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图为每个指标创建一个标签页，并带有相应的折线图，因此我们可以传递来自`metric_config.py`的变量`display_metrics`——你可能还记得，这是一个我们关心的指标列表，我们可以将其用作标签页标题。
- en: 'We define the content within a tab in the same way that we would do it for
    `st.column`: using the with context manager. Since `chart_tabs` now contains the
    list of tabs (returned by `st.tabs`), we can iterate through each list index/metric
    name pair (`idx, met`) in `display_metrics` and use `chart_tabs[idx]` to refer
    to the corresponding tab, calling `get_time_series_chart` to create the Plotly
    line chart for that metric.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义标签页内的内容的方式与定义`st.column`的方式相同：使用with上下文管理器。由于`chart_tabs`现在包含标签列表（由`st.tabs`返回），我们可以遍历`display_metrics`中的每个列表索引/指标名称对（`idx,
    met`），并使用`chart_tabs[idx]`来引用相应的标签页，调用`get_time_series_chart`来为该指标创建Plotly折线图。
- en: 'Finally, we pass the created chart to the `st.plotly_chart` element to render
    it on the screen:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建的图表传递给`st.plotly_chart`元素以在屏幕上渲染：
- en: '[PRE56]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `use_container_width=True` ensures that the line chart expands to fill the
    width of the box that contains it. This prevents weird layout issues where the
    chart ends up being larger than the container or leaves a lot of whitespace around
    it.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`use_container_width=True`确保折线图扩展以填充包含它的盒子的宽度。这防止了图表比容器大或在其周围留下大量空白等奇怪布局问题。'
- en: 'Let''s now include the line chart in our main app by updating `dashboard.py`:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将折线图包含到我们的主应用中，通过更新`dashboard.py`：
- en: '[PRE57]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If you save and re-run the app now, you'll see your first Streamlit visualization
    (see figure 6.15)
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在保存并重新运行应用，你会看到你的第一个Streamlit可视化（见图6.15）
- en: '![image](../Images/06__image015.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/06__image015.png)'
- en: Figure 6.15 Time series chart created using Plotly (chapter_6/in_progress_8
    in the GitHub repo has the full code)
  id: totrans-424
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.15 使用Plotly创建的时间序列图表（GitHub仓库中的chapter_6/in_progress_8部分有完整的代码）
- en: Pretty, ce n'est pas? You can see the tabs and switch between them to see how
    each metric has changed over the given data range. Visualizations created using
    `st.plotly_chart` throw in a lot of useful functionality for free, such as the
    ability to zoom in to specific points in the chart, tooltips when you hover over
    specific data points, a full-screen mode, and a download button to save the image.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 真的很漂亮，不是吗？你可以看到标签页，并通过切换它们来查看每个指标在给定数据范围内的变化情况。使用`st.plotly_chart`创建的视觉图表免费提供许多有用的功能，例如能够放大图表中的特定点，当鼠标悬停在特定数据点上时显示工具提示，全屏模式，以及下载按钮以保存图像。
- en: Note
  id: totrans-426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'We could have used radio buttons as our metric selection widget as our UI mock
    indicates, but I didn''t want to pass up the chance to introduce st.tabs. Also,
    there is one important difference in how selection via st.radio and that via st.tabs
    works: switching between tabs does not trigger an app rerun while changing between
    radio button options does. This makes using tabs faster and more efficient with
    the tradeoff that charts for all the metrics need to be created at once, during
    the initial load.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用单选按钮作为我们的指标选择小部件，正如我们的UI原型所示，但我不想错过介绍st.tabs的机会。此外，通过st.radio和通过st.tabs进行选择的方式有一个重要区别：在选项之间切换不会触发应用程序重新运行，而切换单选按钮选项则会。这使得使用标签页更快、更高效，但代价是需要一次性在初始加载时创建所有指标的图表。
- en: 6.5.2 Creating a pie chart
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.2 创建饼图
- en: The time series chart we just created lets us identify trends over time, but
    we also need to be able to break a particular data point down and see what contributes
    to it. For instance, if we know that the total sales for the "Fountain pens" segment
    are $500k, it would be helpful to know that 70% of that was driven by the RoyalQuill
    brand, while Inkstream only accounted for 30%, or that 45% of stapler sales are
    from the 56+ age group.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的时间序列图表让我们能够识别时间趋势，但我们还需要能够分解特定的数据点并查看其贡献因素。例如，如果我们知道“钢笔”细分市场的总销售额为50万美元，那么了解其中70%是由RoyalQuill品牌推动的，而Inkstream只占30%，或者45%的订书机销售额来自56岁以上的年龄组，将是有帮助的。
- en: Pie charts, which illustrate the percentage breakdown of a whole into its component
    parts, are a good way to instantly form a picture of the data.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 饼图，它展示了整体按其组成部分的百分比分解，是快速形成数据图像的好方法。
- en: Figure 6.16 shows the pie chart from our UI mock again.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16再次显示了我们的UI原型的饼图。
- en: '![image](../Images/06__image016.png)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/06__image016.png)'
- en: Figure 6.16 The pie chart from our UI mock
  id: totrans-433
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.16 我们UI原型的饼图
- en: 'There are two selections you can make here: a metric for the pie chart to display,
    and a breakdown dimension. The metric can only be "Total sales" or "Gross margin",
    not "Margin %" or ATV. This is because the latter two metrics are ratios, and
    the corresponding dimension-wise ratios won''t add up to 100%—so a pie chart does
    not apply.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以做出两个选择：为饼图显示的指标和细分维度。指标只能是“总销售额”或“毛利润”，不能是“利润率%”或ATV。这是因为后两个指标是比率，相应的按维度比率的总和不会达到100%——因此饼图不适用。
- en: For instance, let's say the average transaction value (sales divided by transaction
    count) for fountain pens is $50\. We can't break this down by gender and say that
    60% ($30) of that comes from males and 40% ($20) comes from females. To get the
    ATV for males, we have to calculate the ratio by dividing total sales for males
    by the corresponding transaction count.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设钢笔的平均交易价值（销售额除以交易次数）为50美元。我们无法按性别细分，并说其中60%（30美元）来自男性，40%（20美元）来自女性。要获取男性的ATV，我们必须通过将男性的总销售额除以相应的交易次数来计算比率。
- en: 'Let''s record this smaller list of pie-chart-applicable metrics in a new variable
    at the bottom of metric_config.py:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们在metric_config.py的底部记录这个适用于饼图的较小指标列表的新变量： '
- en: '[PRE58]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Getting data into the right shape
  id: totrans-438
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将数据整理成正确的形状
- en: Just as we wrangled our data into a date/value time series to feed it to the
    time series chart, we need to prepare our data for the pie chart too. The pie
    chart needs to know the value of our metric corresponding to each dimension value;
    it will do the conversion to percentages on its own.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将数据整理成日期/值时间序列以供时间序列图表使用一样，我们还需要为饼图准备我们的数据。饼图需要知道与每个维度值对应的指标值；它将自行进行转换为百分比。
- en: 'For example, consider the earlier sample data we processed into a time series
    earlier:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑我们之前处理成时间序列的早期样本数据：
- en: '[PRE59]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If we want to show a breakdown of the total sales by product, you would group
    by product and add up the sales:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想按产品展示总销售额的细分，您将按产品分组并汇总销售额：
- en: '[PRE60]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This is remarkably similar to what we did earlier; the only difference is that
    instead of grouping by the date field, we're grouping by a particular dimension
    ("Product") instead.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前所做的工作非常相似；唯一的区别是，我们不是按日期字段分组，而是按特定维度（“产品”）分组。
- en: 'The function we''ll include at the bottom of `data_wrangling.py` is thus also
    very similar to `get_metric_time_series`:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将包含在`data_wrangling.py`底部的函数也与`get_metric_time_series`非常相似：
- en: '[PRE61]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The sole distinction between the newly added `get_metric_grouped_by_dimension`
    and `get_metric_time_series` is that in the former, we're accepting dimension
    as an input and grouping by that instead of `Day`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 新增的 `get_metric_grouped_by_dimension` 和 `get_metric_time_series` 之间的唯一区别在于，在前者中，我们接受维度作为输入，并按该维度进行分组，而不是按
    `Day`。
- en: A Plotly pie chart
  id: totrans-448
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个 Plotly 饼图
- en: 'The ever-versatile Plotly Graph Objects can also be used to create the pie
    chart we want. In fact, the code you''ll put in `pie_chart.py` (a new file shown
    in listing 6.11), is closely related to that in `time_series_chart.py`:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 可变通用的 Plotly 图形对象也可以用来创建我们想要的饼图。实际上，你将在 `pie_chart.py`（如列表 6.11 所示的新文件）中放入的代码与
    `time_series_chart.py` 中的代码密切相关：
- en: Listing 6.11 pie_chart.py
  id: totrans-450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.11 pie_chart.py
- en: '[PRE62]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The differences should be fairly obvious: we use `get_metric_grouped_by_dimension`
    in the place of `get_metric_time_series`, and `go.Pie` instead of `go.Scatter`.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 差异应该是相当明显的：我们用 `get_metric_grouped_by_dimension` 替换了 `get_metric_time_series`，用
    `go.Pie` 替换了 `go.Scatter`。
- en: '`go.Pie` accepts `labels`, which will be displayed in a color legend, `values`,
    and `hole`, which indicates how large the "donut hole" in the pie chart should
    be.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`go.Pie` 接受 `labels`，这些标签将在颜色图例中显示，`values`，以及 `hole`，它表示饼图中的“甜甜圈洞”应该有多大。'
- en: We're not using `fig.update_layout()` here to set any text in the chart, since
    the title will simply be the tab header (which we'll get to in a second), and
    there are no x- or y-axes.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不使用 `fig.update_layout()` 来设置图表中的任何文本，因为标题将简单地是标签页标题（我们将在下一部分讨论），并且没有 x
    或 y 轴。
- en: 'As we did previously, we also need to write another function in `pie_chart.py`
    to render the image:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所做的那样，我们还需要在 `pie_chart.py` 中编写另一个函数来渲染图像：
- en: '[PRE63]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `pie_chart` function, too, is similar to its counterpart—`time_series_chart`—from
    `time_series.chart.py`.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`pie_chart` 函数与来自 `time_series.chart.py` 的对应函数——`time_series_chart`——类似。'
- en: The key difference is the added `split_dimension` variable (the dimension to
    break down the metric for) that we need to collect from users using `st.selectbox`.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 关键区别是添加了 `split_dimension` 变量（用于分解指标的维度），我们需要使用 `st.selectbox` 从用户那里收集。
- en: Everything else stays more or less analogous; we create a tab for each metric
    in `pie_chart_display_metrics` (that we defined in `metric_config.py`), iterate
    through those metrics, create the Plotly object with `get_pie_chart`, and display
    it using `st.plotly_chart`.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 其他内容保持大致相似；我们在 `pie_chart_display_metrics`（我们在 `metric_config.py` 中定义的）中为每个指标创建一个标签，遍历这些指标，使用
    `get_pie_chart` 创建 Plotly 对象，并使用 `st.plotly_chart` 显示它。
- en: 'In `dashboard.py`, we want to display the line and pie charts side-by-side,
    so we use `st.columns`:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `dashboard.py` 中，我们希望显示线形图和饼图并排，因此我们使用 `st.columns`：
- en: '[PRE64]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: With this, our dashboard's UI is complete! Re-run to see figure 6.17.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的仪表板的 UI 就完成了！重新运行以查看图 6.17。
- en: '![image](../Images/06__image017.png)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/06__image017.png)'
- en: Figure 6.17 Our completed app, with the newly-added pie chart at the bottom
    right (chapter_6/in_progress_9 in the GitHub repo has the full code)
  id: totrans-464
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.17 我们完成的程序，底部右边的饼图是新添加的（GitHub 仓库中的 chapter_6/in_progress_9 有完整的代码）
- en: We've covered a lot of ground in this chapter, and we're ready to launch our
    dashboard. We're not quite done with Note n' Nib though. In the next chapter,
    we'll see several ways in which our app can be improved-~-including usability
    tweaks and shifting from a static CSV file to a data warehouse.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们覆盖了很多内容，我们准备启动我们的仪表板。尽管如此，我们还没有完成 Note n' Nib。在下一章中，我们将看到几种改进我们应用程序的方法——包括可用性调整，以及从静态
    CSV 文件切换到数据仓库。
- en: 6.6 Summary
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 摘要
- en: A metrics dashboard is an essential decision-making tool for executives.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指标仪表板是高管们的重要决策工具。
- en: Pandas is a popular Python library for manipulating tabular data in dataframes.
    Streamlit can display Pandas dataframes natively.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas 是一个流行的 Python 库，用于在数据框中操作表格数据。Streamlit 可以原生地显示 Pandas 数据框。
- en: Use Pandas' `read_csv` function to load data from a comma-separated values (CSV)
    file
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pandas 的 `read_csv` 函数从逗号分隔值（CSV）文件加载数据。
- en: The `st.cache_data` decorator can be used to cache the results of functions
    to improve performance. Its `ttl` parameter sets the time period for which a cached
    result is valid.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`st.cache_data` 装饰器可用于缓存函数的结果以改进性能。其 `ttl` 参数设置缓存结果有效的时长。'
- en: The dataframe square bracket notation is quite versatile in Pandas; you can
    use them to select columns, filter rows, and more.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Pandas 中，数据框的方括号表示法非常灵活；你可以使用它们来选择列、过滤行等等。
- en: '`st.container` can be used to hold other Streamlit widgets, displaying them
    out of order or with a border around them.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`st.container` 可以用来包含其他 Streamlit 小部件，以无序或带有边框的方式显示它们。'
- en: '`st.multiselect` creates a dropdown menu where you can select multiple options.'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`st.multiselect` 创建一个下拉菜单，你可以从中选择多个选项。'
- en: '`st.set_page_config` can set app configurations in Streamlit, including switching
    from a centered layout to a maximized one.'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`st.set_page_config` 可以在 Streamlit 中设置应用程序配置，包括从居中布局切换到最大化布局。'
- en: '`st.date_input` can be used to display date selectors in your app.'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`st.date_input` 可以用来在你的应用程序中显示日期选择器。'
- en: The `humanize` library is useful for formatting numbers in a user-friendly way.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`humanize` 库对于以用户友好的方式格式化数字非常有用。'
- en: A time series is a sequence of data points, each with a date and a value.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列是一系列数据点，每个数据点都有一个日期和一个值。
- en: The `groupby` method on Pandas dataframes can aggregate data across dimensions.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas 数据框上的 `groupby` 方法可以在多个维度上聚合数据。
- en: Plotly Graph Objects (abbreviated to `go`) is a Python library used to create
    visualizations that can be displayed directly by Streamlit.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Plotly 图形对象（简称 `go`）是一个 Python 库，用于创建可以直接由 Streamlit 显示的可视化。
- en: '`go.Scatter` can be used to create scatterplots and line charts, while `go.Pie`
    can make pie charts.'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go.Scatter` 可以用来创建散点图和折线图，而 `go.Pie` 可以用来制作饼图。'
- en: A data warehouse is a specialized system designed to store and retrieve large
    amounts of data.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据仓库是一个专门设计的系统，用于存储和检索大量数据。
- en: Google BigQuery—part of GCP—is an example of a data warehouse. To enable an
    app to connect to it, you need to create a service account with a key, and record
    the credentials in `st.secrets`.
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google BigQuery（GCP 的一部分）是一个数据仓库的例子。为了使应用程序能够连接到它，你需要创建一个带有密钥的服务帐户，并将凭据记录在 `st.secrets`
    中。
