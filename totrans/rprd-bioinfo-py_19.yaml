- en: 'Chapter 17\. DNA Synthesizer: Creating Synthetic Data with Markov Chains'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Markov chain is a model for representing a sequence of possibilities found
    in a given dataset. It is a machine learning (ML) algorithm because it discovers
    or learns patterns from input data. In this exercise, I’ll show how to use Markov
    chains trained on a set of DNA sequences to generate novel DNA sequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you will:'
  prefs: []
  type: TYPE_NORMAL
- en: Read some number of input sequence files to find all the unique k-mers for a
    given *k*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a Markov chain using these k-mers to produce some number of novel sequences
    of lengths bounded by a minimum and maximum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about generators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a random seed to replicate random selections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Markov Chains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Claude Shannon’s [“A Mathematical Theory of Communication”](https://oreil.ly/8Gka4)
    (1948), the author describes a *Markoff process* that is surprisingly similar
    to graphs and the finite state diagrams I’ve been using to illustrate regular
    expressions. Shannon describes this process as “a finite number of possible *states*
    of a system” and “a set of transition probabilities” that one state will lead
    to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'For one example of a Markov process, Shannon describes a system for generating
    strings of text by randomly selecting from the 26 letters of the English alphabet
    and a space. In a “zero-order approximation,” each character has an equal probability
    of being chosen. This process generates strings where letter combinations like
    *bz* and *qr* might appear as frequently as *st* and *qu*. An examination of actual
    English words, however, would show that the latter two are orders of magnitude
    more common than the first two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To more accurately model the possible transition from one letter to another,
    Shannon introduces a “first-order approximation…obtained by choosing successive
    letters independently but each letter having the same probability that it has
    in the natural language.” For this model, I need to train the selection process
    on representative texts of English. Shannon notes that the letter *e* has a probability
    of 0.12, reflecting the frequency of its use in English words, whereas *w*, being
    much less frequently used, has a probability of 0.02, as shown in [Figure 17-1](#fig_17.1).
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1701](assets/mpfb_1701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-1\. A finite state diagram that includes the probability of moving
    from any character in English to the letters “e” or “w”
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Shannon goes on to describe a “second-order approximation” where subsequent
    letters are “chosen in accordance with the frequencies with which the various
    letters follow the first one.” This relates to k-mers that I used several times
    in [Part I](part01.html#part_one). In linguistics, these are called *N-grams*.
    For instance, what possible 3-mers could be created given the 2-mer *th*? The
    letters *e* or *r* would be rather likely, whereas *z* would be impossible as
    no English word contains the sequence *thz*.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can perform a rough estimation of how often I can find these patterns. I
    find approximately 236K English words using **`wc -l`** to count the lines of
    my system dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the frequency of the substrings, I need to account for the fact that
    some words may have the pattern twice. For instance, here are a few words that
    have more than one occurrence of the pattern *the*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'I can use `grep -io` to search in a case-insensitive fashion (`-i`) for the
    strings *thr* and *the*, while the `-o` flag tells `grep` to return *only* the
    matching strings, which will reveal all the matches in each word. I find that
    *thr* occurs 1,270 times, while *the* occurs 3,593 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Dividing these numbers by the total number of words leads to a frequency of
    0.005 for *thr* and 0.015 for *the*, as shown in [Figure 17-2](#fig_17.2).
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1702](assets/mpfb_1702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-2\. A finite state diagram showing the probability of moving from
    “th” to either an “r” or an “e”
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I can apply these ideas to generate novel DNA sequences by reading some sample
    sequences and noting the ordering of the bases at the level of some k-mer like
    10 base pairs (bp). It’s important to note that different training texts will
    affect the model. For instance, English words and spellings have changed over
    time, so training on older English texts like *Beowulf* and *Canterbury Tales*
    will yield different results than articles from modern newspapers. This is the
    *learning* part of machine learning. Many ML algorithms are designed to find patterns
    from some sets of data to apply to another set. In the case of this program, the
    generated sequences will bear some resemblance in composition to the input sequences.
    Running the program with the human genome as training data will produce different
    results than using a viral metagenome from an oceanic hydrothermal flume.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should work in the *17_synth* directory containing the inputs and tests
    for this program. Start by copying the solution to the program `synth.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This program has a large number of parameters. Run the help to see them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The only required parameter is one or more input files.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The output filename will default to *out.fa*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The input format should be either *fasta* or *fastq* and defaults to the first.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The default number of sequences generated will be 100.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The default maximum sequence length is 75 bp.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The default minimum sequence length is 50 bp.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The default k-mer length is 10 bp.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-8)'
  prefs: []
  type: TYPE_NORMAL
- en: The default random seed is the `None` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, I create an `Args` class to represent these parameters. I use the
    following `typing` imports. Note the `Dict` is used later in the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The input `files` will be a list of open filehandles.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `outfile` will be an open filehandle.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `file_format` of the input files is a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The number of sequences to generate (`num`) is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `min_len` is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The `max_len` is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The `k` for k-mer length is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-8)'
  prefs: []
  type: TYPE_NORMAL
- en: The random seed can either be the value `None` or an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how I define the program’s parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `type` restricts the values to readable text files, and the `nargs` requires
    one or more values.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `type` restricts the value to a writable text file, and the default filename
    will be *out.fa*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `choices` restrict the values to either `fasta` or `fastq`, and the default
    will be `fasta`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `type` restricts this to a valid integer value, and the default is `100`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `type` restricts this to a valid integer value, and the default is `75`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The `type` restricts this to a valid integer value, and the default is `50`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The `type` restricts this to a valid integer value, and the default is `10`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-8)'
  prefs: []
  type: TYPE_NORMAL
- en: The `type` restricts this to a valid integer value, and the default is `None`.
  prefs: []
  type: TYPE_NORMAL
- en: It might seem a little odd that the `seed` has `type=int` but has a default
    of `None` because `None` is not an integer. What I’m saying is that if the user
    provides any value for the seed, it must be a valid integer; otherwise, the value
    will be `None`. This is also reflected in the `Args.seed` definition as an `Optional[int]`,
    which means the value can either be `int` or `None`. Note that this is equivalent
    to `typing.Union[int, None]`, the union of the `int` type and `None` value.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Random Seeds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is an element of randomness to this program as you generate the sequences.
    I can start with Shannon’s zero-order implementation where I select each base
    independently at random. I can use the `random.choice()` function to select one
    base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If I wanted to generate a 10-bp sequence, I could use a list comprehension
    with the `range()` function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'I could further select a random sequence length between some minimum and maximum
    length using the `random.randint()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you execute the preceding code on your computer, it’s highly unlikely you
    will see the same output as shown. Fortunately, these selections are only pseudorandom
    as they are produced deterministically by a random number generator (RNG). Truly
    random, unreproducible choices would make testing this program impossible.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can use a *seed* or initial value to force the pseudorandom selections to
    be predictable. If you read **`help(random.seed)`**, you’ll see that the “supported
    seed types are `None`, `int`, `float`, `str`, `bytes`, and `bytearray`.” For instance,
    I can seed using an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'I can also use a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you execute the preceding code, you should get the exact output shown. By
    default, the random seed is `None`, which you’ll notice is the default for the
    program. This is the same as not setting the seed at all, so when the program
    runs with the default it will act in a pseudorandom manner. When testing, I can
    provide a value that will produce a known result to verify that the program works
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that I have forced the user to provide an integer value. Although I find
    using integers to be convenient, you can seed using strings, numbers, or bytes
    when writing your own programs. Just remember that the integer `4` and the string
    `''4''` are two different values and will produce different results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Seed using the integer value `4`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Seed using the string value `'4'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The random seed affects every call to `random` functions from that point forward.
    This creates a *global* change to your program, and so should be viewed with extreme
    caution. Typically, I will set the random seed in my program immediately after
    validating the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If the seed is the default value of `None`, this will not affect the `random`
    functions. If the user has provided a seed value, then all subsequent `random`
    calls will be affected.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the Training Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step in my program is to read the training files. Due to how I defined
    this argument with `argparse`, the process of validating the input files has been
    handled, and I know I will have a `List[TextIO]` which is a list of open filehandles.
    I will use `Bio.SeqIO.parse()`, as in previous chapters, to read the sequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the training files, I want to produce a dictionary that describes the
    weighted possible bases that can follow each k-mer. I think it’s helpful to use
    a type alias to define a couple of new types to describe this. First, I want a
    dictionary that maps a base like *T* to a floating-point value between 0 and 1
    to describe the probability of choosing this base. I’ll call it a `WeightedChoice`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, in the sequence *ACGTACGC*, the 3-mer *ACG* is followed by either
    *T* or *C* with equal likelihood. I represent this like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, I want a type that maps the k-mer *ACG* to the choices. I’ll call this
    a `Chain` as it represents the Markov chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Each k-mer from the sequences in the input file will have a dictionary of weighted
    options for use in selecting the next base. Here is how I use it to define a function
    to read the training files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The function accepts a list of filehandles, the file format of the files, and
    the size of the k-mers to read. It returns the type `Chain`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `pass` to do nothing and return `None` for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since k-mers figure prominently in this solution, you may want to use the `find_kmers()`
    function from [Part I](part01.html#part_one). As a reminder, for a function with
    this signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'I would use the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'I think it’s helpful to see exactly what goes into this function and what I
    expect it to return. In the *tests/unit_test.py* file, you’ll find all the unit
    tests for this program. Here is the test for this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The function takes no arguments and returns `None`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Define a mock filehandle containing a single sequence in FASTA format.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Read the data in FASTA format and return the Markov chains for 4-mers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Define a mock filehandle containing a single sequence in FASTQ format.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Read the data in FASTQ format and return the Markov chains for 5-mers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help you better understand k-mers, I’ve included a program called `kmer_tiler.py`
    that will show you the overlapping k-mers in a given sequence. The first test
    in the preceding function checks that the 3-mer *ACG* is followed by either *T*
    or *C* with equal probability to create the 4-mers *ACGT* and *ACGC*. Looking
    at the output from `kmer_tiler.py`, I can see these two possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '*ACG* followed by *T*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '*ACG* followed by *C*.'
  prefs: []
  type: TYPE_NORMAL
- en: Using this information, I can create Shannon’s second-order approximation. For
    instance, if I randomly select the 3-mer *ACG* to start generating a new sequence,
    I can add either *T* or *C* with equal probability. Given this training data,
    I could never append either *A* or *G*, as these patterns never occur.
  prefs: []
  type: TYPE_NORMAL
- en: This is a tricky function to write, so let me give you some pointers. First,
    you need to find all the k-mers in all the sequences in all the files. For each
    k-mer, you need to find all the possible endings for a sequence of length `k -
    1`. That is, if `k` is `4`, you first find all the 4-mers and then note how the
    leading 3-mer can be completed with the last base.
  prefs: []
  type: TYPE_NORMAL
- en: 'I used `collections.Counter()` and ended up with an interim data structure
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the input files are all DNA sequences, each k-mer can have at most four
    possible choices. The key to the Markov chain is in giving these values weights,
    so next, I need to divide each option by the total number of options. In the case
    of *ACG*, there are two possible values each occurring once, so they each get
    a weight of 1/2 or 0.5. The data structure I return from this function looks like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: I recommend you first focus on writing a function that passes this test.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the Sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, I recommend you concentrate on using the `Chain` to generate new sequences.
    Here is a stub for your function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The function accepts the `Chain`, the size of the k-mers, and the minimum and
    maximum sequence length. It might or might not return a new sequence as a string,
    for reasons I’ll explain shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: For now, return the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: When stubbing a function, I interchange `pass` with returning some dummy value.
    Here I use the empty string since the function returns a `str`. The point is only
    to create a function that Python parses and which I can use for testing. At this
    point, I *expect* the function to fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the test I wrote for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The function accepts no arguments and returns `None`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the data structure returned by the `read_training()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Save the current global state of the `random` module.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Set the seed to a known value of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Verify that the proper sequence is generated.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Set the seed to a different known value of `2`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Verify that the proper sequence is generated.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Restore the `random` module to any previous state.
  prefs: []
  type: TYPE_NORMAL
- en: As noted before, calling `random.seed()` globally modifies the state of the
    `random` module. I use `random.getstate()` to save the current state before modifying
    and then restore that state when the testing is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a tricky function to write, so I’ll give you some direction. You will
    first randomly select the length of the sequence to generate, and the `random.randint()`
    function will do just that. Note that the upper and lower bounds are inclusive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you should initialize the sequence using one of the keys from the Markov
    `Chain` structure. Note the need to coerce the `list(chain.keys())` to avoid the
    error “`dict_keys` object is not subscriptable”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'I decided to set up a loop with the condition that the length of the sequence
    is less than the chosen sequence length. While inside the loop, I will keep appending
    bases. To select each new base, I need to get the last `k - 1` bases of the ever-growing
    sequence, which I can do using a list slice and negative indexing. Here’s one
    pass through the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If this previous value occurs in the given chain, then I can select the next
    base using the `random.choices()` function. If you read **`help(random.choices)`**,
    you will see that this function accepts a `population` from which to select, `weights`
    to consider when making the selection, and a `k` for the number of choices to
    return. The keys of the chain for a given k-mer are the population:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The values of the chain are the weights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the need to coerce the keys and values using `list()`, and that `random.choices()`
    always returns a `list` even when you ask for just one, so you’ll need to select
    the first value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'I can append this to the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The loop repeats until either the sequence is the correct length or I select
    a previous value that does not exist in the chain. The next time through the loop,
    the `prev` 3-mer will be *CGT*, as these are the last three bases in `seq`. It
    happens that *CGT* is a key in the chain, but you may sometimes find that there
    is no way to continue the sequence because the next k-mer doesn’t exist in the
    chain. In this case, you can exit your loop and return `None` from the function.
    This is why the `gen_seq()` function signature returns an `Optional[str]`; I don’t
    want my function to return sequences that are too short. I recommend that you
    not move on until this function passes the unit test.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring the Program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you can read the training files and generate a new sequence using the
    Markov chain algorithm, you are ready to print the new sequences to the output
    file. Here is a general outline of how my program works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the program will only generate FASTA output, and each sequence should
    be numbered from 1 as the ID. That is, your output file should look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The test suite is pretty large as there are so many options to check. I recommend
    you run **`make test`** or read the *Makefile* to see the longer command to ensure
    that you are properly running all the unit and integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I have just one solution for this program as it’s complicated enough. I’ll
    start with my function to read the training files, which requires you to import
    `defaultdict()` and `Counter()` from the `collections` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a dictionary to hold the Markov chains.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through each filehandle.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through each sequence in the filehandle.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through each k-mer in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the prefix of the k-mer as the key into the Markov chain, and add to the
    count of the final base.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Define a function that will turn the counts into weighted values.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Find the total number of bases.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Divide the frequencies of each base by the total.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Use a dictionary comprehension to convert the raw counts into weights.
  prefs: []
  type: TYPE_NORMAL
- en: 'This uses the `find_kmers()` function from [Part I](part01.html#part_one),
    which is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The number of k-mers is the length of the sequence minus `k` plus 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use a list comprehension to select all the k-mers from the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how I wrote the `gen_seq()` function to generate a single sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the sequence to a random choice from the keys of the chain.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Select a length for the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Execute a loop while the length of the sequence is less than the desired length.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Select the last `k - 1` bases.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Attempt to get a list of choices for this k-mer.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Randomly choose the next base using the weighted choices.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-7)'
  prefs: []
  type: TYPE_NORMAL
- en: If we cannot find this k-mer in the chain, exit the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Return the new sequence if it is long enough; otherwise return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To integrate all these, here is my `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Set the random seed.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Read the training files in the given format using the given size `k`. This may
    fail if the sequences are shorter than `k`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a generator to produce the sequences.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `filter()` with a predicate of `None` to remove falsey elements from the
    `seqs` generator. Use `enumerate()` to iterate through the index positions and
    sequences starting at 1 instead of 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the sequence in FASTA format using the index position as the ID.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Break out of the loop if enough sequences have been generated.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the final status.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Let the user know why no sequences could be generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’d like to take a moment to explain the generator in the preceding code. I
    use the `range()` function to generate the desired number of sequences. I could
    have used a list comprehension like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'A list comprehension will force the creation of all the sequences before moving
    to the next line. If I were creating millions of sequences, the program would
    block here and likely use a large amount of memory to store all the sequences.
    If I replace the square brackets `[]` of the list comprehension with parentheses
    `()`, then it becomes a lazy generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: I can still treat this like a list by iterating over the values, but these values
    are only produced as needed. That means the line of code to create the generator
    executes almost immediately and moves on to the `for` loop. Additionally, the
    program only uses the memory needed to produce the next sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'One small problem with using `range()` and the number of sequences is that
    I know the `gen_seq()` function may sometimes return `None` to indicate that random
    choices lead down a chain that didn’t produce a long enough sequence. I need the
    generator to run with no upper limit, and I’ll write code to stop requesting sequences
    when enough have been generated. I can use `itertools.count()` to create an infinite
    sequence, and I use `filter()` with a predicate of `None` to remove falsey elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'I can run the final program to create an output file using the defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'And then I can use `seqmagique.py` from [Chapter 15](ch15.html#ch15) to verify
    that it generated the correct number of sequences in the expected ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Flippin’ sweet.
  prefs: []
  type: TYPE_NORMAL
- en: Going Further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add a sequence `--type` option to produce either DNA or RNA.
  prefs: []
  type: TYPE_NORMAL
- en: Expand the program to handle paired-end sequences where the forward and reverse
    reads are in two separate files.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand Markov chains, you might be interested to see how they
    are used elsewhere in bioinformatics. For instance, the [HMMER](http://hmmer.org)
    tool uses hidden Markov models to find homologs in sequence databases and to create
    sequence alignments.
  prefs: []
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Key points from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Random seeds are used to replicate pseudorandom selections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Markov chains can be used to encode the probabilities that a node in a graph
    can move to another node or state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list comprehension can be made into a lazy generator by replacing the square
    brackets with parentheses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
