- en: 'Chapter 12\. Inferring mRNA from Protein: Products and Reductions of Lists'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described in [the Rosalind mRNA challenge](https://oreil.ly/ZYelo), the goal
    of this program is to find the number of mRNA strings that could produce a given
    protein sequence. You’ll see that this number can become exceedingly large, so
    the final answer will be the remainder after dividing by a given value. I hope
    to show that I can turn the tables on regular expressions by trying to generate
    all the strings that could be matched by a particular pattern. I’ll also show
    how to create the products of numbers and lists as well as how to *reduce* any
    list of values to a single value, and along the way I’ll talk about some memory
    issues that can cause problems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: How to use the `functools.reduce()` function to create a mathematical `product()`
    function for multiplying numbers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Python’s modulo (`%`) operator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About buffer overflow problems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What monoids are
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to reverse a dictionary by flipping the keys and values
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Started
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should work in the *12_mrna* directory of the repository. Begin by copying
    the first solution to the program `mrna.py`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As usual, inspect the usage first:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO1-1)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The required positional argument is a protein sequence or a file containing
    a protein sequence.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO1-2)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The `--modulo` option defaults to 1,000,000.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the program with the Rosalind example of *MA* and verify that it prints
    `12`, the number of possible mRNA sequences modulo 1,000,000 that could encode
    this protein sequence:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The program will also read an input file for the sequence. The first input
    file has a sequence that is 998 residues long, and the result should be `448832`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the program with other inputs and also execute the tests with **`make test`**.
    When you are satisfied you understand how the program should work, start over:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Define the parameters as described in the usage. The protein may be a string
    or a filename, but I chose to model the parameter as a string. If the user provides
    a file, I will read the contents and pass this to the program as I first demonstrated
    in [Chapter 3](ch03.html#ch03):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-1)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The required `protein` argument should be a string which may be a filename.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-2)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The `modulo` option is an integer that will default to `1000000`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-5)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: If the `protein` argument names an existing file, read the protein sequence
    from the file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Change your `main()` to print the protein sequence:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Verify that your program prints the protein both from the command line and
    a file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO3-1)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The `-c` option to `wc` indicates I only want a count of the number of *characters*
    in the input.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Your program should pass the first two tests and fail the third.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Product of Lists
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the input is *MA*, the program should print the response `12`, which is
    the number of possible mRNA strings that could have produced this protein sequence,
    as shown in [Figure 12-1](#fig_12.1). Using the same RNA encoding table from [Chapter 7](ch07.html#ch07),
    I see that the amino acid methionine (*M*) is encoded by the mRNA codon sequence
    *AUG*,^([1](ch12.html#idm45963629782024)) alanine (*A*) has four possible codons
    (*GCA*, *GCC*, *GCG*, *GCU*), and the stop codon has three (*UAA*, *UAG*, *UGA*).
    The product of these three groups is 1 × 4 × 3 = 12.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1201](assets/mpfb_1201.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: Figure 12-1\. The Cartesian product of all the codons that encode the protein
    sequence MA results in 12 mRNA sequences
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In [Chapter 9](ch09.html#ch09), I introduced the `itertools.product()` function
    that will generate the Cartesian product from lists of values. I can produce all
    possible combinations of the 12 codons in the REPL like so:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you try printing `combos` to see the contents, you’ll see it’s not a list
    of values but a *product object*. That is, this is another lazy object that will
    wait to produce the values until you need them:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I can use the `list()` function to coerce the values:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'I want to show you a sneaky little bug waiting for you. Try printing the combos
    again:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This product object, like a generator, will yield the values only once and
    then will be exhausted. All subsequent calls will produce an empty list. To save
    the results, I need to save the coerced list to a variable:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The length of this product is `12`, meaning there are 12 ways to combine those
    amino acids to produce the sequence *MA*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Avoiding Overflow with Modular Multiplication
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the length of the input protein sequence grows, the number of possible combinations
    will grow extremely large. For example, the second test uses a protein with a
    file of 998 residues, resulting in approximately 8.98 × 10^(29) putative mRNA
    sequences. The Rosalind challenge notes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of memory considerations, most data formats that are built into languages
    have upper bounds on how large an integer can be: in some versions of Python,
    an `int` variable may be required to be no larger than 2^(31)−1, or 2,147,483,647\.
    As a result, to deal with very large numbers in Rosalind, we need to devise a
    system that allows us to manipulate large numbers without actually having to store
    large numbers.'
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Very large numbers pose the risk of exceeding the memory limitations for the
    size of an integer, especially on older 32-bit systems. To avoid this, the final
    answer should be the number of combinations *modulo* 1,000,000. The modulo operation
    returns the remainder when one number is divided by another. For example, 5 modulo
    2 = 1 because 5 divided by 2 is 2 with a remainder of 1. Python has the `%` operator
    to compute the modulo:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The answer for the 998-residue protein is 448,832, which is the remainder after
    dividing 8.98 × 10^(29) by 1,000,000:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In [Chapter 5](ch05.html#ch05), I introduce the NumPy module for mathematical
    operations. As you might expect, there is a `numpy.prod()` function that will
    compute the product of a list of numbers. Unfortunately, it can quietly fail and
    return `0` when I try to compute something as large as the factorial of 1,000:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The problem here is that NumPy is implemented in C, which is faster than Python,
    and the C code tries to store a larger number than will fit into the memory available
    for an integer. The unfortunate result is `0`. It’s common to call this type of
    error a *buffer overflow*, where here the buffer is an integer variable but it
    could be a string, floating-point number, list, or any other container. Generally
    speaking, Python programmers don’t have to worry about memory allocations the
    way programmers do in other languages, but here I must be aware of the limitations
    of the underlying library. Because the maximum size of an `int` can differ depending
    on the machine, `numpy.prod()` is an unreliable solution and should be avoided.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Python 3.8, there exists a `math.prod()` function that can calculate
    incredibly large products such as the factorial of 1,000. This is because all
    the computation happens inside Python, and integers in Python are virtually *unbounded*,
    meaning they are limited only by the available memory on your machine. Try running
    this on your computer:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Notice, however, the result is `0` when I apply the modulo operation:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once again, I’ve bumped up against an overflow that quietly fails, this one
    due to Python’s use of a `float` in the division operation, which is a bounded
    type. For the provided tests, you should not encounter a problem if you use `math.prod()`
    and modulo the results. In the solutions, I will show a way to compute the product
    of an arbitrarily large set of numbers using the modulo operation to avoid integer
    overflow. This should be enough for you to solve the problem. Keep working until
    your program passes all the tests.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I present three solutions that mostly differ in the structure of a dictionary
    used to represent the RNA translation information and in how to compute the mathematical
    product of a list of numbers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 1: Using a Dictionary for the RNA Codon Table'
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For my first solution, I used the RNA codon table from [Chapter 7](ch07.html#ch07)
    to find the number of codons for each residue:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'I want to iterate over each amino acid in the protein sequence *MA* plus the
    stop codon to find all the encoding codons. Note that sequences from Rosalind
    do not terminate with the stop codon, so I must append `*`. I can use a list comprehension
    with a guard to express this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'I don’t need the actual list of codons that encode a given residue, only the
    number which I can find using the `len()` function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The answer lies in multiplying these values. In the previous section, I suggested
    you could use the `math.prod()` function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Although this will work perfectly well, I’d like to take this opportunity to
    talk about *reducing* a sequence of values to a single value. In [Chapter 5](ch05.html#ch05),
    I introduced the `sum()` function that will add the numbers 1, 4, and 3 to create
    the result 8:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It does this in pairs, first adding 1 + 4 to get 5, then adding 5 + 3 to get
    8. If I change the `+` operator to `*`, then I get a product and the result is
    12, as shown in [Figure 12-2](#fig_12.2).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1202](assets/mpfb_1202.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: Figure 12-2\. Reducing a list of numbers using addition and multiplication
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This is the idea behind reducing a list of values, and it’s precisely what
    the `functools.reduce()` function helps us to do. This is another higher-order
    function, like `filter()` and `map()` and others I’ve used throughout the book,
    but with an important difference: the `lambda` function will receive *two* arguments
    instead of only one. The documentation shows how to write `sum()`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is how I could use this to write my own version of `sum()`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To create a product, I can change the addition to multiplication:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'I can use `functools.reduce()` to write my own `product()` function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO4-1)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Return the product of a list of integers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO4-2)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Use the `functools.reduce()` function to progressively multiply the values.
    Use `1` for the initial result to ensure that an empty list returns `1`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Why would I do this? Intellectual curiosity, for one, but I also want to show
    how I could use this to write a function that works without relying on Python’s
    unbounded integers, which this version does. To avoid overflowing in any step
    of the reduction, I need to incorporate the modulo operation into the function
    itself rather than applying it to the end result. Given that I’m not a math wizard,
    I didn’t know how to write such a function. I searched the internet and found
    some code which I modified into this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-1)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: The `mulmod()` function accepts two integers `a` and `b` to multiply with an
    integer modulo value `mod`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-2)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: This is a closure around the `mod` value to possibly return a value modulo `mod`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-3)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: If the result is `0`, return the original value; otherwise, return the computed
    value.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-4)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the result.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-5)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Possibly reduce the size of `a`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-6)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Loop while `b` is greater than `0`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-7)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Check if `b` is an odd number.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-8)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Add `a` to the result and possibly modulo the result.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-9)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Double `a` and possibly modulo the value.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](assets/10.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-10)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Halve `b` using floor division, eventually resulting in `0` and terminating
    the loop.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the test I wrote:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'I chose those large numbers because they are the `sys.maxsize` on my machine:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that this is the same answer that I can get from `math.prod()`, but my
    version does not rely on Python’s dynamic integer sizing and is not tied (as much)
    to the available memory on my machine:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To integrate this, I wrote a `modprod()` function and added a test as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note that it can handle the earlier example of the factorial of 1,000. The
    answer to this is still too large to print, but the point is that the answer is
    not `0`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The final answer is the products of these numbers modulo the given argument.
    Here is how I put it all together:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-1)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: A dictionary encoding RNA codons to amino acids.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-2)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through the residues of the protein plus the stop codon, then find the
    number of codons matching the given amino acid.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-3)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Print the product of the possibilities modulo the given value.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 2: Turn the Beat Around'
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this next solution, I decided to reverse the keys and values of the RNA
    codons dictionary so that the unique amino acids form the keys and the values
    are the lists of codons. It’s handy to know how to flip a dictionary like this,
    but it only works if the values are unique. For instance, I can create a lookup
    table to go from DNA bases like *A* or *T* to their names:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To turn that around so I could go from the name to the base, I can use `dict.items()`
    to get the key/value pairs:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'I then `map()` those through `reversed()` to flip them, and finally pass the
    result to the `dict()` function to create a dictionary:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If I try that on the RNA codons table from the first solution, however, I’ll
    get this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can see that I’m missing most of the codons. Only *M* and *W* have just
    one codon. What happened to the rest? When creating the dictionary, Python overwrote
    any existing values for a key with the newest value. In the original table, for
    instance, *UUG* was the last value indicated for *L*, so that was the value that
    was left standing. Just remember this trick for reversing dictionary key/values
    and ensure that the values are unique. For what it’s worth, if I needed to do
    this, I would use the `collections.defaultdict()` function:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is the data structure I used in the following solution. I also show how
    to use the `math.prod()` function rather than rolling my own:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-1)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Represent the dictionary using the residues as the keys and the codons for the
    values.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-2)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Find the number of codons encoding each amino acid in the protein sequence plus
    the stop codon.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-3)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Use `math.prod()` to calculate the product, then apply the modulo operator.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: This version is much shorter and assumes that the machine will have enough memory
    to compute the product. (Python will handle the memory requirements to represent
    astronomically large numbers.) For all the datasets given to me by Rosalind, this
    was true, but you may one day encounter the need to use something like the `mulmod()`
    function in your travels.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 3: Encoding the Minimal Information'
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous solution encoded more information than was necessary to find the
    solution. Since I only need the *number* of codons that encode a given amino acid,
    not the actual list, I could instead create this lookup table:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'A list comprehension will return the numbers needed for the product. I will
    use `1` for the default argument to `dict.get()` here in case I find a residue
    not present in my dictionary:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Leading to this code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-1)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Encode the number of codons for each amino acid.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 编码每种氨基酸的密码子数量。
- en: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-2)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-2)'
- en: Find the number of codons for each amino acid plus the stop.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 查找每种氨基酸及终止子的密码子数量。
- en: '[![3](assets/3.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-3)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-3)'
- en: Print the product of the combinations modulo the given value.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 输出给定值取模后的组合乘积。
- en: Going Further
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步探讨
- en: 'In a sense, I’ve reversed the idea of a regular expression match by creating
    all the possible strings for a match. That is, the 12 patterns that could produce
    the protein *MA* are as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，我颠倒了正则表达式匹配的思路，通过创建所有可能的匹配字符串。也就是说，能产生蛋白质 *MA* 的 12 种模式如下：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Essentially, I could try to use this information to create a single unified
    regular expression. That might not be easy or even possible, but it’s an idea
    that might help me find a genomic source for a protein. For example, the first
    two sequences differ by their last base. The alternation between *A* and *G* can
    be expressed with the character class `[AG]`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，我可以尝试使用这些信息创建一个统一的正则表达式。这可能并不容易，甚至可能不可能，但这个想法可能帮助我找到蛋白质的基因组来源。例如，前两个序列的区别在于它们的最后一个碱基。在
    *A* 和 *G* 之间的交替可以用字符类 `[AG]` 表示：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Could you write a tool that would combine many regular expression patterns into
    a single one?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你能写一个工具，将许多正则表达式模式组合成一个单一模式吗？
- en: Review
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习
- en: 'Key points from this chapter:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的关键点：
- en: The `itertools.product()` function will create the Cartesian product of a list
    of iterables.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`itertools.product()` 函数将创建列表可迭代对象的笛卡尔积。'
- en: '`functools.reduce()` is a higher-order function that provides a way to combine
    progressive pairs of elements from an iterable.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`functools.reduce()` 是一个高阶函数，它提供了一种从可迭代对象中逐渐组合成对元素的方式。'
- en: Python’s `%` (modulo) operator will return the remainder after division.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的 `%`（取模）运算符将返回除法后的余数。
- en: Homogeneous lists of numbers and strings can be reduced under monoidal operations
    like addition, multiplication, and concatenation to a single value.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字和字符串的同类列表可以通过加法、乘法和连接等幺半群操作减少为单一值。
- en: A dictionary with unique values can be reversed by flipping the keys and values.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有唯一值的字典可以通过交换键和值来反转。
- en: The size of integer values in Python is limited only by the available memory.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 中整数值的大小仅受可用内存限制。
- en: ^([1](ch12.html#idm45963629782024-marker)) While there are other possible start
    codons, this is the only one considered by the Rosalind problem.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch12.html#idm45963629782024-marker)) 虽然存在其他可能的起始密码子，但罗莎琳问题只考虑了这一个。
