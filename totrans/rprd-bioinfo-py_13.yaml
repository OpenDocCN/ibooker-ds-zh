- en: 'Chapter 12\. Inferring mRNA from Protein: Products and Reductions of Lists'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described in [the Rosalind mRNA challenge](https://oreil.ly/ZYelo), the goal
    of this program is to find the number of mRNA strings that could produce a given
    protein sequence. You’ll see that this number can become exceedingly large, so
    the final answer will be the remainder after dividing by a given value. I hope
    to show that I can turn the tables on regular expressions by trying to generate
    all the strings that could be matched by a particular pattern. I’ll also show
    how to create the products of numbers and lists as well as how to *reduce* any
    list of values to a single value, and along the way I’ll talk about some memory
    issues that can cause problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use the `functools.reduce()` function to create a mathematical `product()`
    function for multiplying numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Python’s modulo (`%`) operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About buffer overflow problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What monoids are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to reverse a dictionary by flipping the keys and values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should work in the *12_mrna* directory of the repository. Begin by copying
    the first solution to the program `mrna.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, inspect the usage first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The required positional argument is a protein sequence or a file containing
    a protein sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `--modulo` option defaults to 1,000,000.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the program with the Rosalind example of *MA* and verify that it prints
    `12`, the number of possible mRNA sequences modulo 1,000,000 that could encode
    this protein sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The program will also read an input file for the sequence. The first input
    file has a sequence that is 998 residues long, and the result should be `448832`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with other inputs and also execute the tests with **`make test`**.
    When you are satisfied you understand how the program should work, start over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the parameters as described in the usage. The protein may be a string
    or a filename, but I chose to model the parameter as a string. If the user provides
    a file, I will read the contents and pass this to the program as I first demonstrated
    in [Chapter 3](ch03.html#ch03):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The required `protein` argument should be a string which may be a filename.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `modulo` option is an integer that will default to `1000000`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: If the `protein` argument names an existing file, read the protein sequence
    from the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change your `main()` to print the protein sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that your program prints the protein both from the command line and
    a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `-c` option to `wc` indicates I only want a count of the number of *characters*
    in the input.
  prefs: []
  type: TYPE_NORMAL
- en: Your program should pass the first two tests and fail the third.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Product of Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the input is *MA*, the program should print the response `12`, which is
    the number of possible mRNA strings that could have produced this protein sequence,
    as shown in [Figure 12-1](#fig_12.1). Using the same RNA encoding table from [Chapter 7](ch07.html#ch07),
    I see that the amino acid methionine (*M*) is encoded by the mRNA codon sequence
    *AUG*,^([1](ch12.html#idm45963629782024)) alanine (*A*) has four possible codons
    (*GCA*, *GCC*, *GCG*, *GCU*), and the stop codon has three (*UAA*, *UAG*, *UGA*).
    The product of these three groups is 1 × 4 × 3 = 12.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1201](assets/mpfb_1201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-1\. The Cartesian product of all the codons that encode the protein
    sequence MA results in 12 mRNA sequences
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In [Chapter 9](ch09.html#ch09), I introduced the `itertools.product()` function
    that will generate the Cartesian product from lists of values. I can produce all
    possible combinations of the 12 codons in the REPL like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try printing `combos` to see the contents, you’ll see it’s not a list
    of values but a *product object*. That is, this is another lazy object that will
    wait to produce the values until you need them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'I can use the `list()` function to coerce the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'I want to show you a sneaky little bug waiting for you. Try printing the combos
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This product object, like a generator, will yield the values only once and
    then will be exhausted. All subsequent calls will produce an empty list. To save
    the results, I need to save the coerced list to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The length of this product is `12`, meaning there are 12 ways to combine those
    amino acids to produce the sequence *MA*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding Overflow with Modular Multiplication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the length of the input protein sequence grows, the number of possible combinations
    will grow extremely large. For example, the second test uses a protein with a
    file of 998 residues, resulting in approximately 8.98 × 10^(29) putative mRNA
    sequences. The Rosalind challenge notes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of memory considerations, most data formats that are built into languages
    have upper bounds on how large an integer can be: in some versions of Python,
    an `int` variable may be required to be no larger than 2^(31)−1, or 2,147,483,647\.
    As a result, to deal with very large numbers in Rosalind, we need to devise a
    system that allows us to manipulate large numbers without actually having to store
    large numbers.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Very large numbers pose the risk of exceeding the memory limitations for the
    size of an integer, especially on older 32-bit systems. To avoid this, the final
    answer should be the number of combinations *modulo* 1,000,000. The modulo operation
    returns the remainder when one number is divided by another. For example, 5 modulo
    2 = 1 because 5 divided by 2 is 2 with a remainder of 1. Python has the `%` operator
    to compute the modulo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The answer for the 998-residue protein is 448,832, which is the remainder after
    dividing 8.98 × 10^(29) by 1,000,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Chapter 5](ch05.html#ch05), I introduce the NumPy module for mathematical
    operations. As you might expect, there is a `numpy.prod()` function that will
    compute the product of a list of numbers. Unfortunately, it can quietly fail and
    return `0` when I try to compute something as large as the factorial of 1,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The problem here is that NumPy is implemented in C, which is faster than Python,
    and the C code tries to store a larger number than will fit into the memory available
    for an integer. The unfortunate result is `0`. It’s common to call this type of
    error a *buffer overflow*, where here the buffer is an integer variable but it
    could be a string, floating-point number, list, or any other container. Generally
    speaking, Python programmers don’t have to worry about memory allocations the
    way programmers do in other languages, but here I must be aware of the limitations
    of the underlying library. Because the maximum size of an `int` can differ depending
    on the machine, `numpy.prod()` is an unreliable solution and should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Python 3.8, there exists a `math.prod()` function that can calculate
    incredibly large products such as the factorial of 1,000. This is because all
    the computation happens inside Python, and integers in Python are virtually *unbounded*,
    meaning they are limited only by the available memory on your machine. Try running
    this on your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice, however, the result is `0` when I apply the modulo operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Once again, I’ve bumped up against an overflow that quietly fails, this one
    due to Python’s use of a `float` in the division operation, which is a bounded
    type. For the provided tests, you should not encounter a problem if you use `math.prod()`
    and modulo the results. In the solutions, I will show a way to compute the product
    of an arbitrarily large set of numbers using the modulo operation to avoid integer
    overflow. This should be enough for you to solve the problem. Keep working until
    your program passes all the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I present three solutions that mostly differ in the structure of a dictionary
    used to represent the RNA translation information and in how to compute the mathematical
    product of a list of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 1: Using a Dictionary for the RNA Codon Table'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For my first solution, I used the RNA codon table from [Chapter 7](ch07.html#ch07)
    to find the number of codons for each residue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'I want to iterate over each amino acid in the protein sequence *MA* plus the
    stop codon to find all the encoding codons. Note that sequences from Rosalind
    do not terminate with the stop codon, so I must append `*`. I can use a list comprehension
    with a guard to express this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'I don’t need the actual list of codons that encode a given residue, only the
    number which I can find using the `len()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The answer lies in multiplying these values. In the previous section, I suggested
    you could use the `math.prod()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this will work perfectly well, I’d like to take this opportunity to
    talk about *reducing* a sequence of values to a single value. In [Chapter 5](ch05.html#ch05),
    I introduced the `sum()` function that will add the numbers 1, 4, and 3 to create
    the result 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It does this in pairs, first adding 1 + 4 to get 5, then adding 5 + 3 to get
    8. If I change the `+` operator to `*`, then I get a product and the result is
    12, as shown in [Figure 12-2](#fig_12.2).
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1202](assets/mpfb_1202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-2\. Reducing a list of numbers using addition and multiplication
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This is the idea behind reducing a list of values, and it’s precisely what
    the `functools.reduce()` function helps us to do. This is another higher-order
    function, like `filter()` and `map()` and others I’ve used throughout the book,
    but with an important difference: the `lambda` function will receive *two* arguments
    instead of only one. The documentation shows how to write `sum()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how I could use this to write my own version of `sum()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a product, I can change the addition to multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'I can use `functools.reduce()` to write my own `product()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Return the product of a list of integers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `functools.reduce()` function to progressively multiply the values.
    Use `1` for the initial result to ensure that an empty list returns `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why would I do this? Intellectual curiosity, for one, but I also want to show
    how I could use this to write a function that works without relying on Python’s
    unbounded integers, which this version does. To avoid overflowing in any step
    of the reduction, I need to incorporate the modulo operation into the function
    itself rather than applying it to the end result. Given that I’m not a math wizard,
    I didn’t know how to write such a function. I searched the internet and found
    some code which I modified into this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `mulmod()` function accepts two integers `a` and `b` to multiply with an
    integer modulo value `mod`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This is a closure around the `mod` value to possibly return a value modulo `mod`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: If the result is `0`, return the original value; otherwise, return the computed
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Possibly reduce the size of `a`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Loop while `b` is greater than `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Check if `b` is an odd number.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Add `a` to the result and possibly modulo the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Double `a` and possibly modulo the value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](assets/10.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-10)'
  prefs: []
  type: TYPE_NORMAL
- en: Halve `b` using floor division, eventually resulting in `0` and terminating
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the test I wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'I chose those large numbers because they are the `sys.maxsize` on my machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this is the same answer that I can get from `math.prod()`, but my
    version does not rely on Python’s dynamic integer sizing and is not tied (as much)
    to the available memory on my machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To integrate this, I wrote a `modprod()` function and added a test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that it can handle the earlier example of the factorial of 1,000. The
    answer to this is still too large to print, but the point is that the answer is
    not `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The final answer is the products of these numbers modulo the given argument.
    Here is how I put it all together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: A dictionary encoding RNA codons to amino acids.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through the residues of the protein plus the stop codon, then find the
    number of codons matching the given amino acid.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the product of the possibilities modulo the given value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 2: Turn the Beat Around'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this next solution, I decided to reverse the keys and values of the RNA
    codons dictionary so that the unique amino acids form the keys and the values
    are the lists of codons. It’s handy to know how to flip a dictionary like this,
    but it only works if the values are unique. For instance, I can create a lookup
    table to go from DNA bases like *A* or *T* to their names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To turn that around so I could go from the name to the base, I can use `dict.items()`
    to get the key/value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'I then `map()` those through `reversed()` to flip them, and finally pass the
    result to the `dict()` function to create a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If I try that on the RNA codons table from the first solution, however, I’ll
    get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that I’m missing most of the codons. Only *M* and *W* have just
    one codon. What happened to the rest? When creating the dictionary, Python overwrote
    any existing values for a key with the newest value. In the original table, for
    instance, *UUG* was the last value indicated for *L*, so that was the value that
    was left standing. Just remember this trick for reversing dictionary key/values
    and ensure that the values are unique. For what it’s worth, if I needed to do
    this, I would use the `collections.defaultdict()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the data structure I used in the following solution. I also show how
    to use the `math.prod()` function rather than rolling my own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Represent the dictionary using the residues as the keys and the codons for the
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Find the number of codons encoding each amino acid in the protein sequence plus
    the stop codon.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `math.prod()` to calculate the product, then apply the modulo operator.
  prefs: []
  type: TYPE_NORMAL
- en: This version is much shorter and assumes that the machine will have enough memory
    to compute the product. (Python will handle the memory requirements to represent
    astronomically large numbers.) For all the datasets given to me by Rosalind, this
    was true, but you may one day encounter the need to use something like the `mulmod()`
    function in your travels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 3: Encoding the Minimal Information'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous solution encoded more information than was necessary to find the
    solution. Since I only need the *number* of codons that encode a given amino acid,
    not the actual list, I could instead create this lookup table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'A list comprehension will return the numbers needed for the product. I will
    use `1` for the default argument to `dict.get()` here in case I find a residue
    not present in my dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Leading to this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Encode the number of codons for each amino acid.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Find the number of codons for each amino acid plus the stop.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the product of the combinations modulo the given value.
  prefs: []
  type: TYPE_NORMAL
- en: Going Further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a sense, I’ve reversed the idea of a regular expression match by creating
    all the possible strings for a match. That is, the 12 patterns that could produce
    the protein *MA* are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Essentially, I could try to use this information to create a single unified
    regular expression. That might not be easy or even possible, but it’s an idea
    that might help me find a genomic source for a protein. For example, the first
    two sequences differ by their last base. The alternation between *A* and *G* can
    be expressed with the character class `[AG]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Could you write a tool that would combine many regular expression patterns into
    a single one?
  prefs: []
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Key points from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The `itertools.product()` function will create the Cartesian product of a list
    of iterables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`functools.reduce()` is a higher-order function that provides a way to combine
    progressive pairs of elements from an iterable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python’s `%` (modulo) operator will return the remainder after division.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Homogeneous lists of numbers and strings can be reduced under monoidal operations
    like addition, multiplication, and concatenation to a single value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dictionary with unique values can be reversed by flipping the keys and values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The size of integer values in Python is limited only by the available memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch12.html#idm45963629782024-marker)) While there are other possible start
    codons, this is the only one considered by the Rosalind problem.
  prefs: []
  type: TYPE_NORMAL
