- en: 'Chapter 12\. Inferring mRNA from Protein: Products and Reductions of Lists'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章。从蛋白质推断 mRNA：列表的乘积和减少
- en: As described in [the Rosalind mRNA challenge](https://oreil.ly/ZYelo), the goal
    of this program is to find the number of mRNA strings that could produce a given
    protein sequence. You’ll see that this number can become exceedingly large, so
    the final answer will be the remainder after dividing by a given value. I hope
    to show that I can turn the tables on regular expressions by trying to generate
    all the strings that could be matched by a particular pattern. I’ll also show
    how to create the products of numbers and lists as well as how to *reduce* any
    list of values to a single value, and along the way I’ll talk about some memory
    issues that can cause problems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如[罗莎琳的 mRNA 挑战](https://oreil.ly/ZYelo)中所述，该程序的目标是找出可以产生给定蛋白质序列的 mRNA 字符串数量。你会发现这个数字可能非常大，因此最终答案将是除以给定值后的余数。我希望展示我能通过尝试生成可以匹配特定模式的所有字符串来扭转正则表达式的局面。我还将展示如何创建数字和列表的乘积，以及如何将任何值列表*减少*到单个值，并在此过程中谈论可能导致问题的一些内存问题。
- en: 'You will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学到：
- en: How to use the `functools.reduce()` function to create a mathematical `product()`
    function for multiplying numbers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `functools.reduce()` 函数创建一个数学 `product()` 函数来相乘数字
- en: How to use Python’s modulo (`%`) operator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Python 的取模（`%`）运算符
- en: About buffer overflow problems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于缓冲区溢出问题
- en: What monoids are
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是单子群
- en: How to reverse a dictionary by flipping the keys and values
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过交换键和值来反转字典
- en: Getting Started
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门指南
- en: 'You should work in the *12_mrna* directory of the repository. Begin by copying
    the first solution to the program `mrna.py`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在存储库的 *12_mrna* 目录中工作。首先将第一个解决方案复制到程序 `mrna.py` 中：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As usual, inspect the usage first:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，首先检查用法：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO1-1)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO1-1)'
- en: The required positional argument is a protein sequence or a file containing
    a protein sequence.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的位置参数是一个蛋白质序列或包含蛋白质序列的文件。
- en: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO1-2)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO1-2)'
- en: The `--modulo` option defaults to 1,000,000.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`--modulo` 选项默认为 1,000,000。'
- en: 'Run the program with the Rosalind example of *MA* and verify that it prints
    `12`, the number of possible mRNA sequences modulo 1,000,000 that could encode
    this protein sequence:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 用罗莎琳示例 *MA* 运行程序，并验证它是否打印 `12`，可能编码该蛋白质序列的 1,000,000 取模后的 mRNA 序列数量：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The program will also read an input file for the sequence. The first input
    file has a sequence that is 998 residues long, and the result should be `448832`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序还将读取序列的输入文件。第一个输入文件的序列长度为 998，结果应为 `448832`：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the program with other inputs and also execute the tests with **`make test`**.
    When you are satisfied you understand how the program should work, start over:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 用其他输入运行程序，还要执行**`make test`**测试。当你确信理解程序应该如何工作时，重新开始：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Define the parameters as described in the usage. The protein may be a string
    or a filename, but I chose to model the parameter as a string. If the user provides
    a file, I will read the contents and pass this to the program as I first demonstrated
    in [Chapter 3](ch03.html#ch03):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 按照用法描述定义参数。蛋白质可能是一个字符串或一个文件名，但我选择将参数建模为一个字符串。如果用户提供了一个文件，我将读取内容并将其传递给程序，就像我在[第三章](ch03.html#ch03)中首次展示的那样：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-1)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-1)'
- en: The required `protein` argument should be a string which may be a filename.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的 `protein` 参数应为一个字符串，可能是一个文件名。
- en: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-2)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-2)'
- en: The `modulo` option is an integer that will default to `1000000`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`modulo` 选项是一个整数，默认为 `1000000`。'
- en: '[![3](assets/3.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-5)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-5)'
- en: If the `protein` argument names an existing file, read the protein sequence
    from the file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `protein` 参数命名一个现有文件，则从文件中读取蛋白质序列。
- en: 'Change your `main()` to print the protein sequence:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的 `main()` 更改为打印蛋白质序列：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Verify that your program prints the protein both from the command line and
    a file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 验证您的程序从命令行和文件中打印出蛋白质：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO3-1)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO3-1)'
- en: The `-c` option to `wc` indicates I only want a count of the number of *characters*
    in the input.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`-c` 选项到 `wc` 表示我只想要输入中的字符数的计数。'
- en: Your program should pass the first two tests and fail the third.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您的程序应通过前两个测试并失败第三个。
- en: Creating the Product of Lists
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建列表的乘积
- en: When the input is *MA*, the program should print the response `12`, which is
    the number of possible mRNA strings that could have produced this protein sequence,
    as shown in [Figure 12-1](#fig_12.1). Using the same RNA encoding table from [Chapter 7](ch07.html#ch07),
    I see that the amino acid methionine (*M*) is encoded by the mRNA codon sequence
    *AUG*,^([1](ch12.html#idm45963629782024)) alanine (*A*) has four possible codons
    (*GCA*, *GCC*, *GCG*, *GCU*), and the stop codon has three (*UAA*, *UAG*, *UGA*).
    The product of these three groups is 1 × 4 × 3 = 12.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入为 *MA* 时，程序应打印出响应 `12`，这是能够产生该蛋白质序列的可能 mRNA 字符串数量，如 [图 12-1](#fig_12.1) 所示。使用来自
    [第 7 章](ch07.html#ch07) 的同一 RNA 编码表，我发现氨基甲酸 (*M*) 由 mRNA 密码序列 *AUG* 编码，^([1](ch12.html#idm45963629782024))
    丙氨酸 (*A*) 有四种可能的密码子 (*GCA*, *GCC*, *GCG*, *GCU*)，而终止密码子有三种 (*UAA*, *UAG*, *UGA*)。这三组的乘积为
    1 × 4 × 3 = 12。
- en: '![mpfb 1201](assets/mpfb_1201.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 1201](assets/mpfb_1201.png)'
- en: Figure 12-1\. The Cartesian product of all the codons that encode the protein
    sequence MA results in 12 mRNA sequences
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-1\. 编码蛋白质序列 MA 的所有密码子的笛卡尔乘积结果为 12 个 mRNA 序列
- en: 'In [Chapter 9](ch09.html#ch09), I introduced the `itertools.product()` function
    that will generate the Cartesian product from lists of values. I can produce all
    possible combinations of the 12 codons in the REPL like so:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 9 章](ch09.html#ch09) 中，我介绍了 `itertools.product()` 函数，它将从值列表生成笛卡尔乘积。我可以像这样在
    REPL 中生成这 12 个密码子的所有可能组合：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you try printing `combos` to see the contents, you’ll see it’s not a list
    of values but a *product object*. That is, this is another lazy object that will
    wait to produce the values until you need them:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试打印 `combos` 查看内容，您会看到它不是一个值列表，而是一个 *product object*。也就是说，这是另一个延迟生成值的对象：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I can use the `list()` function to coerce the values:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用 `list()` 函数强制转换值：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'I want to show you a sneaky little bug waiting for you. Try printing the combos
    again:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我想向您展示一个等待您的小错误。再试打印组合：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This product object, like a generator, will yield the values only once and
    then will be exhausted. All subsequent calls will produce an empty list. To save
    the results, I need to save the coerced list to a variable:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此乘积对象像生成器一样，仅会产生值一次，然后将被用尽。所有后续调用将生成空列表。为了保存结果，我需要将强制转换后的列表保存到一个变量中：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The length of this product is `12`, meaning there are 12 ways to combine those
    amino acids to produce the sequence *MA*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该产品的长度为 `12`，表示有 12 种方式将这些氨基酸组合成序列 *MA*：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Avoiding Overflow with Modular Multiplication
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模块化乘法避免溢出
- en: 'As the length of the input protein sequence grows, the number of possible combinations
    will grow extremely large. For example, the second test uses a protein with a
    file of 998 residues, resulting in approximately 8.98 × 10^(29) putative mRNA
    sequences. The Rosalind challenge notes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 随着输入蛋白质序列长度的增加，可能组合的数量会变得极其庞大。例如，第二个测试使用具有 998 个残基的蛋白质文件，导致大约 8.98 × 10^(29)
    个假设的 mRNA 序列。Rosalind 挑战说明：
- en: 'Because of memory considerations, most data formats that are built into languages
    have upper bounds on how large an integer can be: in some versions of Python,
    an `int` variable may be required to be no larger than 2^(31)−1, or 2,147,483,647\.
    As a result, to deal with very large numbers in Rosalind, we need to devise a
    system that allows us to manipulate large numbers without actually having to store
    large numbers.'
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于内存限制，大多数内置语言数据格式对整数的大小有上限：在某些 Python 版本中，`int` 变量可能要求不大于 2^(31)−1，即 2,147,483,647\.
    因此，为了处理 Rosalind 中的大数，我们需要设计一种系统，允许我们在不实际存储大数的情况下操作它们。
- en: 'Very large numbers pose the risk of exceeding the memory limitations for the
    size of an integer, especially on older 32-bit systems. To avoid this, the final
    answer should be the number of combinations *modulo* 1,000,000. The modulo operation
    returns the remainder when one number is divided by another. For example, 5 modulo
    2 = 1 because 5 divided by 2 is 2 with a remainder of 1. Python has the `%` operator
    to compute the modulo:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 非常大的数字可能会超过整数大小的内存限制，特别是在旧的32位系统上。为了避免这种情况，最终答案应该是组合数对1,000,000取模的结果。模运算返回一个数除以另一个数的余数。例如，5模2
    = 1，因为5除以2是2，余数为1。Python有`%`运算符来计算模运算：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The answer for the 998-residue protein is 448,832, which is the remainder after
    dividing 8.98 × 10^(29) by 1,000,000:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于998个残基的蛋白质来说，答案是448,832，这是在将8.98 × 10^(29)除以1,000,000后的余数：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In [Chapter 5](ch05.html#ch05), I introduce the NumPy module for mathematical
    operations. As you might expect, there is a `numpy.prod()` function that will
    compute the product of a list of numbers. Unfortunately, it can quietly fail and
    return `0` when I try to compute something as large as the factorial of 1,000:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html#ch05)中，我介绍了用于数学运算的NumPy模块。正如你所预料的那样，有一个`numpy.prod()`函数可以计算一组数字的乘积。不幸的是，当我尝试计算像1000的阶乘这样的大数时，它可能会悄无声息地失败并返回`0`：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The problem here is that NumPy is implemented in C, which is faster than Python,
    and the C code tries to store a larger number than will fit into the memory available
    for an integer. The unfortunate result is `0`. It’s common to call this type of
    error a *buffer overflow*, where here the buffer is an integer variable but it
    could be a string, floating-point number, list, or any other container. Generally
    speaking, Python programmers don’t have to worry about memory allocations the
    way programmers do in other languages, but here I must be aware of the limitations
    of the underlying library. Because the maximum size of an `int` can differ depending
    on the machine, `numpy.prod()` is an unreliable solution and should be avoided.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是NumPy是用C实现的，比Python更快，C代码尝试存储比整数可用内存更大的数字。不幸的结果是`0`。这种类型的错误通常被称为*缓冲区溢出*，在这里缓冲区是一个整数变量，但也可以是字符串、浮点数、列表或任何其他容器。一般来说，Python程序员不必像其他语言的程序员那样担心内存分配，但我必须意识到底层库的限制。因为`int`的最大大小可能因机器而异，`numpy.prod()`是一个不可靠的解决方案，应该避免使用。
- en: 'Since Python 3.8, there exists a `math.prod()` function that can calculate
    incredibly large products such as the factorial of 1,000. This is because all
    the computation happens inside Python, and integers in Python are virtually *unbounded*,
    meaning they are limited only by the available memory on your machine. Try running
    this on your computer:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 自Python 3.8以来，存在一个`math.prod()`函数，可以计算像1000的阶乘这样的极大乘积。这是因为所有计算都发生在Python内部，而Python中的整数几乎是*无限大*的，这意味着它们仅受到计算机可用内存的限制。请在您的计算机上运行这个试试：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Notice, however, the result is `0` when I apply the modulo operation:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，当我应用模运算时，结果是`0`：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once again, I’ve bumped up against an overflow that quietly fails, this one
    due to Python’s use of a `float` in the division operation, which is a bounded
    type. For the provided tests, you should not encounter a problem if you use `math.prod()`
    and modulo the results. In the solutions, I will show a way to compute the product
    of an arbitrarily large set of numbers using the modulo operation to avoid integer
    overflow. This should be enough for you to solve the problem. Keep working until
    your program passes all the tests.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我遇到了由于Python在除法操作中使用了有界类型`float`而导致的溢出问题，这是一个不太可能遇到的问题，如果您使用`math.prod()`和对结果进行模运算。在解决方案中，我将展示一种计算任意大数字集合乘积的方法，使用模运算以避免整数溢出。这应该足以帮助您解决问题。继续努力，直到您的程序通过所有测试。
- en: Solutions
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: I present three solutions that mostly differ in the structure of a dictionary
    used to represent the RNA translation information and in how to compute the mathematical
    product of a list of numbers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我提出了三种解决方案，它们主要在用于表示RNA翻译信息的字典结构以及如何计算数字列表的数学乘积方面有所不同。
- en: 'Solution 1: Using a Dictionary for the RNA Codon Table'
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案1：使用RNA密码子表的字典
- en: 'For my first solution, I used the RNA codon table from [Chapter 7](ch07.html#ch07)
    to find the number of codons for each residue:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我的第一个解决方案，我使用了来自[第7章](ch07.html#ch07)的RNA密码子表来查找每个残基的密码子数量：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'I want to iterate over each amino acid in the protein sequence *MA* plus the
    stop codon to find all the encoding codons. Note that sequences from Rosalind
    do not terminate with the stop codon, so I must append `*`. I can use a list comprehension
    with a guard to express this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要遍历蛋白质序列*MA*加上终止密码子，以找到所有编码密码子。请注意，来自罗萨琳德的序列不以终止密码子结束，所以我必须添加`*`。我可以使用列表推导式和守卫来表达这一点：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'I don’t need the actual list of codons that encode a given residue, only the
    number which I can find using the `len()` function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我不需要编码给定残基的密码子实际列表，只需要我可以使用`len()`函数找到的数字：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The answer lies in multiplying these values. In the previous section, I suggested
    you could use the `math.prod()` function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在于将这些值相乘。在前一节中，我建议您可以使用`math.prod()`函数：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Although this will work perfectly well, I’d like to take this opportunity to
    talk about *reducing* a sequence of values to a single value. In [Chapter 5](ch05.html#ch05),
    I introduced the `sum()` function that will add the numbers 1, 4, and 3 to create
    the result 8:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个方法可以完美地工作，但我想借此机会谈谈*将*一系列值减少为单个值。在[第5章](ch05.html#ch05)中，我介绍了`sum()`函数，它将数字1、4和3相加得到结果8：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It does this in pairs, first adding 1 + 4 to get 5, then adding 5 + 3 to get
    8. If I change the `+` operator to `*`, then I get a product and the result is
    12, as shown in [Figure 12-2](#fig_12.2).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它这样做是成对的，首先将1 + 4相加得到5，然后将5 + 3相加得到8。如果我将`+`运算符改为`*`，那么我得到一个乘积，结果是12，如[图12-2](#fig_12.2)所示。
- en: '![mpfb 1202](assets/mpfb_1202.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 1202](assets/mpfb_1202.png)'
- en: Figure 12-2\. Reducing a list of numbers using addition and multiplication
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-2\. 使用加法和乘法减少数字列表
- en: 'This is the idea behind reducing a list of values, and it’s precisely what
    the `functools.reduce()` function helps us to do. This is another higher-order
    function, like `filter()` and `map()` and others I’ve used throughout the book,
    but with an important difference: the `lambda` function will receive *two* arguments
    instead of only one. The documentation shows how to write `sum()`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是减少值列表背后的思想，也正是`functools.reduce()`函数帮助我们做到的。这是另一个高阶函数，类似于`filter()`和`map()`以及本书中我使用过的其他函数，但有一个重要的区别：`lambda`函数将接收*两个*参数而不是一个。文档显示如何编写`sum()`：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is how I could use this to write my own version of `sum()`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我如何使用这个来编写自己版本的`sum()`：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To create a product, I can change the addition to multiplication:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个乘积，我可以将加法改为乘法：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'I can use `functools.reduce()` to write my own `product()` function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用`functools.reduce()`来编写自己的`product()`函数：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO4-1)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO4-1)'
- en: Return the product of a list of integers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 返回整数列表的乘积。
- en: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO4-2)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO4-2)'
- en: Use the `functools.reduce()` function to progressively multiply the values.
    Use `1` for the initial result to ensure that an empty list returns `1`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`functools.reduce()`函数逐步将值相乘。使用`1`作为初始结果确保空列表返回`1`。
- en: 'Why would I do this? Intellectual curiosity, for one, but I also want to show
    how I could use this to write a function that works without relying on Python’s
    unbounded integers, which this version does. To avoid overflowing in any step
    of the reduction, I need to incorporate the modulo operation into the function
    itself rather than applying it to the end result. Given that I’m not a math wizard,
    I didn’t know how to write such a function. I searched the internet and found
    some code which I modified into this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要这样做？一部分是出于好奇心，但我还想展示如何编写一个可以在不依赖Python无界整数的情况下工作的函数。为了避免在减少的任何步骤中溢出，我需要将模操作合并到函数本身而不是应用到最终结果上。考虑到我不是数学专家，我不知道如何编写这样一个函数。我在互联网上搜索并找到了一些代码，我修改成了这个：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-1)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-1)'
- en: The `mulmod()` function accepts two integers `a` and `b` to multiply with an
    integer modulo value `mod`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`mulmod()`函数接受两个整数`a`和`b`以及一个整数模值`mod`来进行乘法。'
- en: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-2)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-2)'
- en: This is a closure around the `mod` value to possibly return a value modulo `mod`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个封闭的函数，用于可能返回模 `mod` 的值。
- en: '[![3](assets/3.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-3)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-3)'
- en: If the result is `0`, return the original value; otherwise, return the computed
    value.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果为 `0`，则返回原始值；否则，返回计算得到的值。
- en: '[![4](assets/4.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-4)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-4)'
- en: Initialize the result.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化结果。
- en: '[![5](assets/5.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-5)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-5)'
- en: Possibly reduce the size of `a`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 可能减少 `a` 的大小。
- en: '[![6](assets/6.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-6)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-6)'
- en: Loop while `b` is greater than `0`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `b` 大于 `0` 的同时循环。
- en: '[![7](assets/7.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-7)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-7)'
- en: Check if `b` is an odd number.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `b` 是否为奇数。
- en: '[![8](assets/8.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-8)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-8)'
- en: Add `a` to the result and possibly modulo the result.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `a` 加到结果中，并可能对结果取模。
- en: '[![9](assets/9.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-9)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-9)'
- en: Double `a` and possibly modulo the value.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `a` 加倍，并可能对值取模。
- en: '[![10](assets/10.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-10)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-10)'
- en: Halve `b` using floor division, eventually resulting in `0` and terminating
    the loop.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用地板除法将 `b` 减半，最终结果为 `0` 并终止循环。
- en: 'Following is the test I wrote:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我写的测试：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'I chose those large numbers because they are the `sys.maxsize` on my machine:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择这些大数，因为它们是我机器上的 `sys.maxsize`：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that this is the same answer that I can get from `math.prod()`, but my
    version does not rely on Python’s dynamic integer sizing and is not tied (as much)
    to the available memory on my machine:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这与我可以从 `math.prod()` 得到的答案相同，但我的版本不依赖于Python的动态整数大小，并且不像（更多地）绑定于我的机器上的可用内存：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To integrate this, I wrote a `modprod()` function and added a test as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了集成这一点，我编写了一个 `modprod()` 函数，并添加了一个如下的测试：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note that it can handle the earlier example of the factorial of 1,000. The
    answer to this is still too large to print, but the point is that the answer is
    not `0`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它可以处理前述的1000阶乘的示例。这个答案仍然太大而无法打印，但重点是答案不是 `0`：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The final answer is the products of these numbers modulo the given argument.
    Here is how I put it all together:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最终答案是这些数字的乘积模给定的参数。以下是我如何将所有这些内容整合到一起的：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-1)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-1)'
- en: A dictionary encoding RNA codons to amino acids.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一个将RNA密码子编码为氨基酸的字典。
- en: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-2)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-2)'
- en: Iterate through the residues of the protein plus the stop codon, then find the
    number of codons matching the given amino acid.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代蛋白质残基加上停止密码子，然后找到与给定氨基酸匹配的密码子数量。
- en: '[![3](assets/3.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-3)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-3)'
- en: Print the product of the possibilities modulo the given value.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 打印可能性的乘积模给定的值。
- en: 'Solution 2: Turn the Beat Around'
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 2：扭转节拍
- en: 'For this next solution, I decided to reverse the keys and values of the RNA
    codons dictionary so that the unique amino acids form the keys and the values
    are the lists of codons. It’s handy to know how to flip a dictionary like this,
    but it only works if the values are unique. For instance, I can create a lookup
    table to go from DNA bases like *A* or *T* to their names:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个解决方案，我决定颠倒RNA密码子字典的键和值，使得唯一的氨基酸形成键，而值则是密码子的列表。知道如何像这样翻转字典非常方便，但只有当值是唯一的时候才能起作用。例如，我可以创建一个查找表，将DNA碱基如*A*或*T*映射到它们的名称：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To turn that around so I could go from the name to the base, I can use `dict.items()`
    to get the key/value pairs:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要反过来，从名称转到碱基，我可以使用`dict.items()`获取键/值对：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'I then `map()` those through `reversed()` to flip them, and finally pass the
    result to the `dict()` function to create a dictionary:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我将它们通过`reversed()`映射，最后将结果传递给`dict()`函数以创建字典：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If I try that on the RNA codons table from the first solution, however, I’ll
    get this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我尝试在第一个解决方案中使用的RNA密码子表上尝试，我会得到这个：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can see that I’m missing most of the codons. Only *M* and *W* have just
    one codon. What happened to the rest? When creating the dictionary, Python overwrote
    any existing values for a key with the newest value. In the original table, for
    instance, *UUG* was the last value indicated for *L*, so that was the value that
    was left standing. Just remember this trick for reversing dictionary key/values
    and ensure that the values are unique. For what it’s worth, if I needed to do
    this, I would use the `collections.defaultdict()` function:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我缺少大部分密码子。只有*M*和*W*有一个密码子。其余的都去哪了？当创建字典时，Python会用最新的值覆盖键的任何现有值。例如，在原始表中，*UUG*是最后指定给*L*的值，因此这是保留的值。只需记住这个反转字典键/值的技巧，并确保值是唯一的。值得一提的是，如果我需要这样做，我会使用`collections.defaultdict()`函数：
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is the data structure I used in the following solution. I also show how
    to use the `math.prod()` function rather than rolling my own:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在以下解决方案中使用的数据结构。我还展示了如何使用`math.prod()`函数而不是自己编写代码：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-1)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-1)'
- en: Represent the dictionary using the residues as the keys and the codons for the
    values.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 用残基作为键，密码子作为值来表示字典。
- en: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-2)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-2)'
- en: Find the number of codons encoding each amino acid in the protein sequence plus
    the stop codon.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 找到编码蛋白质序列中每种氨基酸的密码子数量以及终止密码子。
- en: '[![3](assets/3.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-3)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-3)'
- en: Use `math.prod()` to calculate the product, then apply the modulo operator.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`math.prod()`计算乘积，然后应用模运算符。
- en: This version is much shorter and assumes that the machine will have enough memory
    to compute the product. (Python will handle the memory requirements to represent
    astronomically large numbers.) For all the datasets given to me by Rosalind, this
    was true, but you may one day encounter the need to use something like the `mulmod()`
    function in your travels.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本要短得多，并假设机器有足够的内存来计算乘积。（Python将处理表示天文数字所需的内存要求。）对我罗莎琳德提供的所有数据集而言，这是真的，但您可能有一天会遇到需要在旅途中使用类似`mulmod()`函数的情况。
- en: 'Solution 3: Encoding the Minimal Information'
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '解决方案 3: 编码最少信息'
- en: 'The previous solution encoded more information than was necessary to find the
    solution. Since I only need the *number* of codons that encode a given amino acid,
    not the actual list, I could instead create this lookup table:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个解决方案编码了比找到解决方案所需更多的信息。由于我只需要编码给定氨基酸的密码子数量，而不是实际列表，我可以创建这个查找表：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'A list comprehension will return the numbers needed for the product. I will
    use `1` for the default argument to `dict.get()` here in case I find a residue
    not present in my dictionary:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式将返回所需的乘积数字。我会在这里使用`1`作为`dict.get()`的默认参数，以防我找到字典中不存在的残基：
- en: '[PRE42]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Leading to this code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 导致这段代码：
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-1)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-1)'
- en: Encode the number of codons for each amino acid.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 编码每种氨基酸的密码子数量。
- en: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-2)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-2)'
- en: Find the number of codons for each amino acid plus the stop.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 查找每种氨基酸及终止子的密码子数量。
- en: '[![3](assets/3.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-3)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-3)'
- en: Print the product of the combinations modulo the given value.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 输出给定值取模后的组合乘积。
- en: Going Further
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步探讨
- en: 'In a sense, I’ve reversed the idea of a regular expression match by creating
    all the possible strings for a match. That is, the 12 patterns that could produce
    the protein *MA* are as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，我颠倒了正则表达式匹配的思路，通过创建所有可能的匹配字符串。也就是说，能产生蛋白质 *MA* 的 12 种模式如下：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Essentially, I could try to use this information to create a single unified
    regular expression. That might not be easy or even possible, but it’s an idea
    that might help me find a genomic source for a protein. For example, the first
    two sequences differ by their last base. The alternation between *A* and *G* can
    be expressed with the character class `[AG]`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，我可以尝试使用这些信息创建一个统一的正则表达式。这可能并不容易，甚至可能不可能，但这个想法可能帮助我找到蛋白质的基因组来源。例如，前两个序列的区别在于它们的最后一个碱基。在
    *A* 和 *G* 之间的交替可以用字符类 `[AG]` 表示：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Could you write a tool that would combine many regular expression patterns into
    a single one?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你能写一个工具，将许多正则表达式模式组合成一个单一模式吗？
- en: Review
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习
- en: 'Key points from this chapter:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的关键点：
- en: The `itertools.product()` function will create the Cartesian product of a list
    of iterables.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`itertools.product()` 函数将创建列表可迭代对象的笛卡尔积。'
- en: '`functools.reduce()` is a higher-order function that provides a way to combine
    progressive pairs of elements from an iterable.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`functools.reduce()` 是一个高阶函数，它提供了一种从可迭代对象中逐渐组合成对元素的方式。'
- en: Python’s `%` (modulo) operator will return the remainder after division.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的 `%`（取模）运算符将返回除法后的余数。
- en: Homogeneous lists of numbers and strings can be reduced under monoidal operations
    like addition, multiplication, and concatenation to a single value.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字和字符串的同类列表可以通过加法、乘法和连接等幺半群操作减少为单一值。
- en: A dictionary with unique values can be reversed by flipping the keys and values.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有唯一值的字典可以通过交换键和值来反转。
- en: The size of integer values in Python is limited only by the available memory.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 中整数值的大小仅受可用内存限制。
- en: ^([1](ch12.html#idm45963629782024-marker)) While there are other possible start
    codons, this is the only one considered by the Rosalind problem.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch12.html#idm45963629782024-marker)) 虽然存在其他可能的起始密码子，但罗莎琳问题只考虑了这一个。
