<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>chapter-8</title>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
 </head>
 <body>
  <div class="readable-text " id="p1"> 
   <h1 class=" readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">8</span></span> Building a CRUD app with Streamlit</h1>
  </div>
  <div class="introduction-summary"> 
   <h3>This chapter covers</h3>
   <ul> 
    <li class="readable-text" id="p2">Setting up a relational database for persistent storage</li>
    <li class="readable-text" id="p3">Performing CRUD operations using SQL</li>
    <li class="readable-text" id="p4">Developing a multi-page Streamlit app</li>
    <li class="readable-text" id="p5">Creating shared database connections in a Streamlit app</li>
    <li class="readable-text" id="p6">Authenticating users</li>
   </ul>
  </div>
  <div class="readable-text " id="p7"> 
   <p>In 1957, a science fiction author named Theodore Sturgeon famously said, "ninety percent of <em>everything</em> is crud". While this was originally a cynical defense of the genre of science fiction—the point being that it was no different from anything else in that regard—the adage has since taken on a different meaning, becoming the worst-kept secret in software engineering: Ninety percent of everything is CRUD.</p>
  </div>
  <div class="readable-text  intended-text" id="p8"> 
   <p>By CRUD, I'm referring to Create, Read, Update, and Delete, the four mundane operations that appear repeatedly in almost any notable piece of software.</p>
  </div>
  <div class="readable-text  intended-text" id="p9"> 
   <p>Think about it. Social media platforms like Facebook revolve around creating posts, reading feeds, updating profiles, and deleting content. E-commerce sites manage products, orders, customer accounts, and reviews through similar operations. Even something as simple as Notepad on Windows centers around creating, reading, updating, and deleting text files.</p>
  </div>
  <div class="readable-text  intended-text" id="p10"> 
   <p>Mastering CRUD operations is essential for building a strong foundation in software design, as their implementation often involves tackling non-trivial challenges. In this chapter, we'll create a CRUD application with Streamlit, implementing these operations from scratch while covering related topics such as user authentication.</p>
  </div>
  <div class="readable-text" id="p11"> 
   <h2 class=" readable-text-h2">8.1 Haiku Haven: A CRUD app in Streamlit</h2>
  </div>
  <div class="readable-text " id="p12"> 
   <p>For our excursion into CRUD, we're going with the Japanese art of <em>haiku</em>—specifically, we will create a website that lets users write and share their own haikus.</p>
  </div>
  <div class="readable-text  intended-text" id="p13"> 
   <p>For those not intimately familiar with Japanese literature, a haiku is a short three-line poem conforming to certain rules: the first and the third lines must have five syllables, while the second must have seven. For instance, here's one I wrote about Streamlit:</p>
  </div>
  <div class="readable-text" id="p14"> 
   <blockquote>
    <div>
     <em>So many web apps!</em>
    </div>
   </blockquote>
  </div>
  <div class="readable-text" id="p15"> 
   <blockquote>
    <div>
     <em>With Python can I make one?</em>
    </div>
   </blockquote>
  </div>
  <div class="readable-text" id="p16"> 
   <blockquote>
    <div>
     <em>Then I tried Streamlit.</em>
    </div>
   </blockquote>
  </div>
  <div class="readable-text " id="p17"> 
   <p>I know<em>, </em>right? I sometimes wonder if I missed my calling too. Regardless, you'll notice that the poem adheres to the 5-7-5 syllable rule I mentioned above, and is therefore a valid haiku.</p>
  </div>
  <div class="readable-text  intended-text" id="p18"> 
   <p>Haiku Haven will be a place where budding poets can author, refine, and manage haikus. It will enable users to <em>create</em> haikus from scratch, <em>read </em>what they've created, <em>update</em> a haiku once they've created it, and <em>delete</em> it if they decide it doesn't pass muster.</p>
  </div>
  <div class="readable-text" id="p19"> 
   <h3 class=" readable-text-h3">8.1.1 Stating the concept and requirements</h3>
  </div>
  <div class="readable-text " id="p20"> 
   <p>As usual, we'll start by stating the concept of our app succinctly:</p>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p21"> 
    <h5 class=" callout-container-h5 readable-text-h5">Concept</h5>
   </div>
   <div class="readable-text" id="p22"> 
    <p>Haiku Haven, a website that allows users to create, edit, and manage haikus</p>
   </div>
  </div>
  <div class="readable-text " id="p23"> 
   <p>This concept and our earlier discussion about CRUD should give you a basic idea of what we want, but let's spell out the concrete requirements so we're on the same page about the Haiku Haven vision.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p24"> 
   <h4 class=" readable-text-h4">Requirements</h4>
  </div>
  <div class="readable-text " id="p25"> 
   <p>A user of Haiku Haven should be able to:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p26">create and log in to an account with a username and password</li>
   <li class="readable-text" id="p27">create haikus under their username</li>
   <li class="readable-text" id="p28">view the haikus they've created</li>
   <li class="readable-text" id="p29">update haikus</li>
   <li class="readable-text" id="p30">delete their haikus</li>
  </ul>
  <div class="readable-text " id="p31"> 
   <p>Hopefully you'll realize how frequently you encounter this kind of app. If you replace the word "haiku" in the requirements with "image", you get a barebones version of Instagram. Substitute "task" to get a productivity tool like Asana or "post" to get Twitter or WordPress.</p>
  </div>
  <div class="readable-text  intended-text" id="p32"> 
   <p>The point is that these requirements aren't just about haikus—they represent a universal pattern in software design. Almost every app revolves around managing some kind of data, founded on CRUD operations.</p>
  </div>
  <div class="readable-text  intended-text" id="p33"> 
   <p>By building Haiku Haven, you're not just creating a playful app for poetry lovers; you're learning how to construct the essential workflows of modern software. You'll tackle user authentication, data storage, and retrieval—skills that apply to nearly any app or system you might create in the future.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p34"> 
   <h4 class=" readable-text-h4">What's out of scope</h4>
  </div>
  <div class="readable-text " id="p35"> 
   <p>We could fit a lot of functionality into Haiku Haven (think of everything you can do on Twitter), but we only have one chapter, so we'll focus on the absolute core stuff. That means we <em>won't</em> concern ourselves with:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p36">Making haikus visible to and searchable by other users—haikus are private to the author</li>
   <li class="readable-text" id="p37">"Social" features such as liking, commenting, and sharing</li>
   <li class="readable-text" id="p38">Auxiliary functionality like pagination</li>
   <li class="readable-text" id="p39">Advanced security features (though we'll get the basics right)</li>
  </ul>
  <div class="readable-text" id="p40"> 
   <h3 class=" readable-text-h3">8.1.2 Visualizing the user experience</h3>
  </div>
  <div class="readable-text " id="p41"> 
   <p>Haiku Haven will be our first multi-page app. We'll need to craft multiple experiences or flows—the account creation flow, login and logout, and the actual CRUD part (creating, reading, updating, and deleting haikus).</p>
  </div>
  <div class="readable-text  intended-text" id="p42"> 
   <p>Figure 8.1 attempts to sketch out what the different portions of our app might look like.</p>
  </div>
  <div class="browsable-container figure-container" id="p43">  
   <img src="../Images/ch08__image001.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 8.1 Rough sketches of the pages we want in Haiku Haven</h5>
  </div>
  <div class="readable-text " id="p44"> 
   <p>Because of how common these flows are in various common apps, I won't take too much space here to explain them in detail, but here are a few highlights:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p45">The login page uses a password for authentication, which you can set in the signup page</li>
   <li class="readable-text" id="p46">A "My haikus" page represents the logged-in experience within the app, letting users create, view, edit, or delete their haikus.</li>
   <li class="readable-text" id="p47">There's also a haiku editor page where the authoring of haikus takes place.</li>
  </ul>
  <div class="readable-text" id="p48"> 
   <h3 class=" readable-text-h3">8.1.3 Brainstorming the implementation</h3>
  </div>
  <div class="readable-text " id="p49"> 
   <p>Given that Haiku Haven represents CRUD web apps—and thus, by Sturgeon's law, 90% of <em>all</em> web apps—it stands to reason that its implementation should involve some very common patterns.</p>
  </div>
  <div class="readable-text  intended-text" id="p50"> 
   <p>Indeed, the design we'll use consists of three components that are seen in most live online applications: a frontend, a backend, and a <em>database</em>. Figure 8.2 lays out this approach.</p>
  </div>
  <div class="browsable-container figure-container" id="p51">  
   <img src="../Images/ch08__image002.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 8.2 Design for our app showing a frontend, backend, and database</h5>
  </div>
  <div class="readable-text " id="p52"> 
   <p>The frontend, as we've seen in prior apps, consists of the widgets that the user interacts with. Each major action, such as creating an account, or updating a haiku, calls a corresponding function in the backend.</p>
  </div>
  <div class="readable-text  intended-text" id="p53"> 
   <p>We'll divide the functions available in the backend into two groups: one that includes actions related to users, like creating an account or authenticating a user, and another that includes haiku-related actions—creating, reading, updating, or deleting haikus.</p>
  </div>
  <div class="readable-text  intended-text" id="p54"> 
   <p>The interesting section here—one that's new to us—is the database, which is used to permanently store information related to users and haikus in <em>tables</em>. As we'll soon see, the database also makes it easy to retrieve the information we've stored.</p>
  </div>
  <div class="readable-text  intended-text" id="p55"> 
   <p>While our app is intentionally simple, it captures the core elements of most web applications: a frontend for user interaction, a backend for handling requests, and a database for storing and retrieving data. These three pillars work together seamlessly, forming the foundation of countless applications, whether simple or complex.</p>
  </div>
  <div class="readable-text" id="p56"> 
   <h2 class=" readable-text-h2">8.2 Setting up persistent storage</h2>
  </div>
  <div class="readable-text " id="p57"> 
   <p>One of the most important deficiencies in the apps we've created thus far is the lack of persistent storage. Essentially, in all of our apps so far, if the user closes their browser window, they lose their data and progress. This won't do at all for Haiku Haven; we need users to be able to save and access their haikus after they log out and log back in again at some point in the future—we need to store data <em>outside</em> of the app itself.</p>
  </div>
  <div class="readable-text  intended-text" id="p58"> 
   <p>There are several different approaches to solving the problem of data storage, but we'll use a fairly common technique: a relational database.</p>
  </div>
  <div class="readable-text" id="p59"> 
   <h3 class=" readable-text-h3">8.2.1 Relational database concepts</h3>
  </div>
  <div class="readable-text " id="p60"> 
   <p>A <em>relational database</em> is a type of data storage system that organizes data into structured <em>tables</em>, where each table consists of <em>rows</em> (also called <em>records</em>) and <em>columns</em> (also called <em>fields</em>). A row represents some kind of entry or entity, and a column is an attribute of the entity. A <em>schema</em> defines the structure of these tables, including the <em>data types</em> of each column and the <em>relationships</em> between different tables.</p>
  </div>
  <div class="readable-text  intended-text" id="p61"> 
   <p>Relational databases rely on a language called <em>Structured Query Language </em>(SQL) to create, manage and <em>query </em>tables.</p>
  </div>
  <div class="readable-text  intended-text" id="p62"> 
   <p>If some of this rings a bell, it's likely because we've been dealing with this kind of thing for a while now. In Chapters 6 and 7, we worked with Pandas dataframes that also handle tabular data—except that dataframes are stored in memory while a program is running, while a database is used for <em>persistent</em> storage, i.e. storage that exists even when a program finishes running.</p>
  </div>
  <div class="readable-text  intended-text" id="p63"> 
   <p>We also encountered SQL briefly in Chapter 7, where we used it to fetch the rows of the sales data that we stored in Google BigQuery. Indeed BigQuery is often considered to be a relational database itself, though of a different kind than the one we'll use in this chapter.</p>
  </div>
  <div class="readable-text" id="p64"> 
   <h3 class=" readable-text-h3">8.2.2 Haiku Haven's data model</h3>
  </div>
  <div class="readable-text " id="p65"> 
   <p>To understand all of this better, let's try and figure out how we can <em>model </em>Haiku Haven's data in a relational database.</p>
  </div>
  <div class="readable-text  intended-text" id="p66"> 
   <p>Broadly speaking, modeling data for an app consists of the following steps:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p67">Identifying the <em>entities</em> involved in the app</li>
   <li class="readable-text" id="p68">Defining the <em>relationship</em> between those entities</li>
   <li class="readable-text" id="p69">Listing the <em>attributes</em> of each entity</li>
   <li class="readable-text" id="p70">Converting the entities, attributes and relationships into a relational database schema</li>
  </ul>
  <div class="readable-text sub-sub-section-heading" id="p71"> 
   <h4 class=" readable-text-h4">Identifying the entities</h4>
  </div>
  <div class="readable-text " id="p72"> 
   <p>Generally speaking, a good way to identify the entities involved in an app is to list all the <em>nouns</em> that represent core concepts in the app. For instance, if you take Twitter, the following might all be considered as entities: users, tweets, retweets, direct messages, mentions, followers, hashtags, etc.</p>
  </div>
  <div class="readable-text  intended-text" id="p73"> 
   <p>Haiku Haven is way simpler, of course. We can fairly easily identify the two key entities our app will need to handle: <strong>haikus</strong> and <strong>users</strong>.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p74"> 
   <h4 class=" readable-text-h4">Defining the relationship between the entities</h4>
  </div>
  <div class="readable-text " id="p75"> 
   <p>The relationship between any two entities should be defined in terms of the <em>nature </em>and<em> cardinality</em> of the possible interaction between them. In English, that means you should lay out <em>how</em> one entity is related to the other, and <em>how many </em>of each entity can be on each side of this relationship.</p>
  </div>
  <div class="readable-text  intended-text" id="p76"> 
   <p>For instance, haikus and users are related because a user <strong>can write</strong> a haiku (the "nature" we spoke of above). Also, one user can write many haikus, while a particular haiku can only be written by one user. So the relationship between a user and a haiku is <strong>one-to-many </strong>or 1:n (the "cardinality").</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p77"> 
   <h4 class=" readable-text-h4">Listing the attributes of each entity</h4>
  </div>
  <div class="readable-text " id="p78"> 
   <p>The attributes of an entity are the fields that describe it. In our case:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p79">A user has a <strong>username</strong> and a <strong>password</strong>. In real life, we'd probably also want to capture the name of the user or the time a user's account is created, but let's keep things simple.</li>
   <li class="readable-text" id="p80">A haiku has its <strong>text</strong>, and an <strong>author</strong> (who happens to be a user). We should also give each haiku a <strong>numeric ID</strong> for easy reference. The <strong>creation time</strong> for a haiku may be important to display in the app, so let's consider that too.</li>
  </ul>
  <div class="readable-text " id="p81"> 
   <p>All of this can be represented in an entity-relationship diagram (or ER diagram) as shown in figure 8.3.</p>
  </div>
  <div class="browsable-container figure-container" id="p82">  
   <img src="../Images/ch08__image003.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 8.3 Entity-Relationship (ER) diagram showing the User and Haiku entities</h5>
  </div>
  <div class="readable-text " id="p83"> 
   <p>Of course, ER diagrams for apps in the real world tend to be much, <em>much </em>more complex than this, but I hope this serves to illustrate the concept.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p84"> 
   <h4 class=" readable-text-h4">Converting everything into a database schema</h4>
  </div>
  <div class="readable-text " id="p85"> 
   <p>The exercise of coming up with an ER diagram is helpful in visualizing the data model, but the end outcome we actually want is a schema that we can use in our relational database.</p>
  </div>
  <div class="readable-text  intended-text" id="p86"> 
   <p>There's no hard-and-fast rule to convert entities, attributes, and relationships into tables in a database, but <em>generally</em> speaking: entities become tables, attributes become columns, one-to-many relationships become <em>foreign keys </em>(more on this in a moment), and many-to-many relationships become their own tables.</p>
  </div>
  <div class="browsable-container figure-container" id="p87">  
   <img src="../Images/ch08__image004.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 8.4 Database schema with a foreign key relationship between the users and haikus tables</h5>
  </div>
  <div class="readable-text " id="p88"> 
   <p>In our case, as figure 8.4 shows, we'll have two tables, <kbd>users</kbd> and <kbd>haikus</kbd>, with the attributes we discussed earlier as columns. Each row in users represents a single user, and each row in <kbd>haikus</kbd> is a single haiku. Additionally, each table has a <em>primary key</em>, which is a field that can be used to uniquely identify any row in the table. For <kbd>users</kbd>, the primary key is the <kbd>username</kbd> field (which makes sense since every user has a username and no two users can have the same username). For <kbd>haikus</kbd>, it's <kbd>haiku_id</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p89"> 
   <p>The relationship between <kbd>users</kbd> and <kbd>haikus</kbd> is reflected in the <kbd>author</kbd> column in the <kbd>haikus</kbd> table, which contains a username that must appear in the <kbd>users</kbd> table. Such a column (<kbd>author</kbd>) is called a <em>foreign key</em> as it points to the primary key (<kbd>username</kbd>) of another ("foreign") table.</p>
  </div>
  <div class="readable-text" id="p90"> 
   <h3 class=" readable-text-h3">8.2.3 PostgreSQL: A real relational database</h3>
  </div>
  <div class="readable-text " id="p91"> 
   <p>Enough theorizing! Let's now get our hands dirty with a real relational database. The one we'll use in this chapter is PostgreSQL (pronounced "post-gress-cue-ell"), one of the oldest, most robust, and most popular databases in the industry.</p>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p92"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p93"> 
    <p>Google BigQuery, which we encountered in Chapter 7, can also be considered a relational database (though it's better described as a cloud-based data warehouse). While BigQuery is optimized for analytical use cases (like querying a large amount of data to generate reports or uncover trends), PostgreSQL is better suited for transactional use cases, such as handling frequent small updates to individual records, and maintaining data consistency across concurrent operations.</p>
   </div>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p94"> 
   <h4 class=" readable-text-h4">Installing PostgreSQL</h4>
  </div>
  <div class="readable-text " id="p95"> 
   <p>Towards the end of this chapter, when we deploy Haiku Haven to production, we'll use a free cloud service to set up PostgreSQL. However, for local development, we first need a local installation.</p>
  </div>
  <div class="readable-text  intended-text" id="p96"> 
   <p>To install PostgreSQL, download the installer for your operating system from <kbd>https://www.postgresql.org/download/</kbd> and run it, following the on-screen instructions. For most options, you can accept the defaults. During the installation, you'll be prompted to set a password for the database superuser. Make sure to note this password—you'll need it in the next section.</p>
  </div>
  <div class="readable-text  intended-text" id="p97"> 
   <p>Once installation is complete, you should have access to the PostgreSQL shell, called <kbd>psql</kbd>, which is located in the<kbd> bin/</kbd> directory of your installation folder. If you kept the default options, this would typically be:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p98"><kbd>/Library/PostgreSQL/17/bin/psql</kbd> on macOS</li>
   <li class="readable-text" id="p99"><kbd>C:\Program Files\PostgreSQL\17\bin\psql</kbd> on Windows</li>
  </ul>
  <div class="readable-text " id="p100"> 
   <p>To simplify access, you should configure your system so you can run the <kbd>psql</kbd> command directly from your terminal. This requires adding the <kbd>bin/</kbd> directory to your system's environment variables. You may already have done something similar for the <kbd>streamlit</kbd> command, which you can find detailed steps for in Appendix A (section A.4).</p>
  </div>
  <div class="readable-text  intended-text" id="p101"> 
   <p>If adding the path to your environment variables isn't feasible for any reason, you can still use <kbd>psql</kbd> by typing its full path instead of just the command. For example:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p102">macOS: <kbd>/Library/PostgreSQL/17/bin/psql</kbd></li>
   <li class="readable-text" id="p103">Windows:<kbd> "C:\Program Files\PostgreSQL\17\bin\psql"</kbd> (include quotes)</li>
  </ul>
  <div class="readable-text " id="p104"> 
   <p>Throughout the rest of this chapter, substitute the full path whenever you see <kbd>psql</kbd>, if necessary.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p105"> 
   <h4 class=" readable-text-h4">Creating a database for Haiku Haven</h4>
  </div>
  <div class="readable-text " id="p106"> 
   <p>Once you've set up the <kbd>psql</kbd> command, log in to your local PostgreSQL instance by running the following command:</p>
  </div>
  <div class="browsable-container listing-container" id="p107"> 
   <div class="code-area-container"> 
    <pre class="code-area">psql -U postgres -d postgres</pre>
   </div>
  </div>
  <div class="readable-text " id="p108"> 
   <p>When prompted for a password, enter the one you configured during installation. This command logs you into PostgreSQL as the default user (<kbd>-U</kbd>) <kbd>postgres</kbd>—which is an administrative user that's allowed to do whatever they want. The <kbd>-d</kbd> specifies that you want to connect to the default database, which is–~-rather confusingly if you ask me—also called <kbd>postgres</kbd>. You should see now see the <kbd>psql</kbd> prompt that looks like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p109"> 
   <div class="code-area-container"> 
    <pre class="code-area">postgres=#</pre>
   </div>
  </div>
  <div class="readable-text " id="p110"> 
   <p>When your app talks to PostgreSQL, you don't want it to be running with broad administrative privileges—that would be a security nightmare. Instead, let's create a more narrowly-scoped user. Enter this into the <kbd>psql</kbd> prompt, replacing the quoted string with a password of your choice:</p>
  </div>
  <div class="browsable-container listing-container" id="p111"> 
   <div class="code-area-container"> 
    <pre class="code-area">CREATE USER haiku_lord WITH PASSWORD '&lt;Pick a password you like&gt;';</pre>
   </div>
  </div>
  <div class="readable-text " id="p112"> 
   <p>Obviously, you can use whatever username you like, but I'm going to assume we're going with <kbd>haiku_lord</kbd>. If that works (don't forget the ending semicolon!), you should get an output line that just says <kbd>CREATE ROLE</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p113"> 
   <p>Before you can create tables in PostgreSQL, you need to first make a <strong>database</strong> (which you can think of here as a container for tables). The <kbd>haiku_lord</kbd> user you just created can't do that yet, so enter this command to let it:</p>
  </div>
  <div class="browsable-container listing-container" id="p114"> 
   <div class="code-area-container"> 
    <pre class="code-area">ALTER USER haiku_lord CREATEDB;</pre>
   </div>
  </div>
  <div class="readable-text " id="p115"> 
   <p>Now that we have an appropriately-privileged Haiku Haven-specific user, we're done with the default <kbd>postgres</kbd> user, so exit out of the <kbd>psql</kbd> shell by typing <kbd>exit</kbd>, and then re-run it like so:</p>
  </div>
  <div class="browsable-container listing-container" id="p116"> 
   <div class="code-area-container"> 
    <pre class="code-area">psql -U haiku_lord -d postgres</pre>
   </div>
  </div>
  <div class="readable-text " id="p117"> 
   <p>Assuming you entered the password you selected for <kbd>haiku_db</kbd> when prompted, you're again connected to the <kbd>postgres</kbd> database, but now you're acting under the capacity of <kbd>haiku_lord</kbd> (if you like, you can verify this by typing <kbd>SELECT current_user;</kbd>).</p>
  </div>
  <div class="readable-text  intended-text" id="p118"> 
   <p>To create a database called <kbd>haikudb</kbd> to hold the tables for Haiku Haven, enter:</p>
  </div>
  <div class="browsable-container listing-container" id="p119"> 
   <div class="code-area-container"> 
    <pre class="code-area">CREATE DATABASE haikudb;</pre>
   </div>
  </div>
  <div class="readable-text " id="p120"> 
   <p>You can list all the databases available in your local PostgreSQL instance by typing <kbd>\l</kbd>. You should now be able to see <kbd>haikudb</kbd> in there, along with <kbd>postgres</kbd> and a couple of others.</p>
  </div>
  <div class="readable-text  intended-text" id="p121"> 
   <p>To start using our database, we need to "connect" to it. To do this, type:</p>
  </div>
  <div class="browsable-container listing-container" id="p122"> 
   <div class="code-area-container"> 
    <pre class="code-area">\c haikudb;</pre>
   </div>
  </div>
  <div class="readable-text " id="p123"> 
   <p>A confirmation message—<kbd>You are now connected to database "haikudb" as user "haiku_lord"</kbd>—should let you know that this worked.</p>
  </div>
  <div class="readable-text  intended-text" id="p124"> 
   <p>Keep this terminal window with the <kbd>psql</kbd> shell open. We're going to keep coming back to it throughout this chapter. If you do end up closing it, you can get back to this state by typing:</p>
  </div>
  <div class="browsable-container listing-container" id="p125"> 
   <div class="code-area-container"> 
    <pre class="code-area">psql -U haiku_lord -d haikudb</pre>
   </div>
  </div>
  <div class="readable-text" id="p126"> 
   <h3 class=" readable-text-h3">8.2.4 A crash course in SQL</h3>
  </div>
  <div class="readable-text " id="p127"> 
   <p>The SQL in PostgreSQL stands for Structured Query Language. Variously pronounced as "sequel" and "ess-cue-ell", SQL is the language of databases, used to create and update tables, and most importantly, to <em>query </em>them to get exactly the data we need. It's also one of the most popular and useful languages to know if you're a developer or work in the field of data in any capacity.</p>
  </div>
  <div class="readable-text  intended-text" id="p128"> 
   <p>If you don't know SQL, today's your lucky day because we're going to breeze through the basics in this section.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p129"> 
   <h4 class=" readable-text-h4">Creating tables</h4>
  </div>
  <div class="readable-text " id="p130"> 
   <p>Previously in this chapter, we came up with Haiku Haven's database schema that contains two tables: <kbd>users</kbd> and <kbd>haikus</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p131"> 
   <p>We're now going to actually create these tables in PostgreSQL. Go back to the <kbd>psql</kbd> shell where you're connected to the <kbd>haikudb</kbd> database (or re-run <kbd>psql</kbd> as indicated earlier), and enter the following SQL command:</p>
  </div>
  <div class="browsable-container listing-container" id="p132"> 
   <div class="code-area-container"> 
    <pre class="code-area">CREATE TABLE users (
  username VARCHAR(100) PRIMARY KEY,
  password_hash VARCHAR(128)
);</pre>
   </div>
  </div>
  <div class="readable-text " id="p133"> 
   <p>The <kbd>CREATE</kbd> <kbd>TABLE</kbd> command creates a table with a specific schema. In the above, the name of the table is <kbd>users</kbd>, and it has two columns: <kbd>username</kbd> and <kbd>password_hash</kbd>—which, if you recall, are the two fields we settled on earlier as being important attributes of a user.</p>
  </div>
  <div class="readable-text  intended-text" id="p134"> 
   <p>Why does it say <kbd>password_hash</kbd> instead of just <kbd>password</kbd>? Bear with me, please—I'll explain this a little later in the chapter. For now, let's just think of it as the user's password.</p>
  </div>
  <div class="readable-text  intended-text" id="p135"> 
   <p>Turn your attention to the lines where we've defined the columns:</p>
  </div>
  <div class="browsable-container listing-container" id="p136"> 
   <div class="code-area-container"> 
    <pre class="code-area">username VARCHAR(100) PRIMARY KEY,
password_hash VARCHAR(128)</pre>
   </div>
  </div>
  <div class="readable-text " id="p137"> 
   <p>These sequences, separated by commas, are <em>column specifications</em> that let you configure each column—including specifying the data type.</p>
  </div>
  <div class="readable-text  intended-text" id="p138"> 
   <p><kbd>VARCHAR</kbd> is one such data type in PostgreSQL; it's a string type that can have a varying number of characters. <kbd>VARCHAR(100)</kbd> means that the column can have any number of characters up to 100. If you try to store more than 100 characters, PostgreSQL will throw an error.</p>
  </div>
  <div class="readable-text  intended-text" id="p139"> 
   <p>You'll also notice <kbd>PRIMARY</kbd> <kbd>KEY</kbd> against the <kbd>username</kbd> column. This denotes that the <kbd>username</kbd> column will be used to uniquely identify a row in the users table. Among other things, this means that every row in <kbd>users</kbd> must have a <kbd>username</kbd>, and that only one user can have a particular <kbd>username</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p140"> 
   <p>To check that this worked, you can use the <kbd>psql</kbd> command <kbd>\dt</kbd>, which lists all the tables in the current database. Doing so now should give you:</p>
  </div>
  <div class="browsable-container listing-container" id="p141"> 
   <div class="code-area-container"> 
    <pre class="code-area">          List of relations
 Schema | Name  | Type  |   Owner
--------+-------+-------+------------
 public | users | table | haiku_lord
(1 row)</pre>
   </div>
  </div>
  <div class="readable-text " id="p142"> 
   <p>Next, let's create our second table, <kbd>haikus</kbd>, with another <kbd>CREATE</kbd> <kbd>TABLE</kbd> command:</p>
  </div>
  <div class="browsable-container listing-container" id="p143"> 
   <div class="code-area-container"> 
    <pre class="code-area">CREATE TABLE haikus (
  haiku_id SERIAL PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
  author VARCHAR(100),
  text TEXT,
  FOREIGN KEY (author) REFERENCES users(username)
);</pre>
   </div>
  </div>
  <div class="readable-text " id="p144"> 
   <p>There are a few new things here:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p145"><kbd>haiku_id</kbd>, the primary key, has a data type of <kbd>SERIAL</kbd>. This means that PostgreSQL will automatically provide the value for this column as an auto-incrementing integer. The first row inserted will have <kbd>1</kbd> as its <kbd>haiku_id</kbd>, the second will have <kbd>2</kbd>, and so on.</li>
   <li class="readable-text" id="p146"><kbd>created_at</kbd> has the data type <kbd>TIMESTAMPTZ</kbd>, which is a timestamp with time zone information. The <kbd>DEFAULT</kbd> keyword specifies the value to put in this column if one is not explicitly provided while inserting a row in the table. In this case, we want the current timestamp (<kbd>CURRENT_TIMESTAMP</kbd>) to be provided as this default value.</li>
   <li class="readable-text" id="p147"><kbd>text</kbd> has a data type of <kbd>TEXT</kbd>, which is like <kbd>VARCHAR</kbd> but with no maximum character length. This makes sense for the actual content of the haiku.</li>
   <li class="readable-text" id="p148">The last line, <kbd>FOREIGN KEY (author) REFERENCES users(username)</kbd>, says that the author column must have a value that exists in the username column of some row in the users table. This is called a <em>foreign key constraint</em>.</li>
  </ul>
  <div class="readable-text sub-sub-section-heading" id="p149"> 
   <h4 class=" readable-text-h4">Inserting rows into tables</h4>
  </div>
  <div class="readable-text " id="p150"> 
   <p>Next, let's populate these tables with rows using SQL's<kbd> INSERT INTO</kbd> statement.</p>
  </div>
  <div class="readable-text  intended-text" id="p151"> 
   <p>We'll first create a new user by adding a row to the <kbd>users</kbd> table:</p>
  </div>
  <div class="browsable-container listing-container" id="p152"> 
   <div class="code-area-container"> 
    <pre class="code-area">INSERT INTO users (username, password_hash) VALUES ('alice', 'Pass_word&amp;34');</pre>
   </div>
  </div>
  <div class="readable-text " id="p153"> 
   <p>The <kbd>INSERT INTO</kbd> command inserts a row into the table by specifying the column values. The <kbd>(username, password_hash)</kbd> after the table name <kbd>users</kbd> says that the column values we're about to specify correspond to the columns <kbd>username</kbd> and <kbd>password_hash</kbd>, in that order.</p>
  </div>
  <div class="readable-text  intended-text" id="p154"> 
   <p>The part after <kbd>VALUES</kbd> gives the actual values to enter. The effect here is that <kbd>users</kbd> now has one row—with a <kbd>username</kbd> of <kbd>alice</kbd> and <kbd>password_hash</kbd> set to <kbd>Pass_word&amp;34</kbd>.</p>
  </div>
  <div class="browsable-container listing-container" id="p155"> 
   <div class="code-area-container"> 
    <pre class="code-area">INSERT INTO haikus (author, text) VALUES
('alice', E'Two foxes leap high\nOne lands safely on the earth\nWhere is the other?');</pre>
   </div>
  </div>
  <div class="readable-text " id="p156"> 
   <p>Note here that though <kbd>haikus</kbd> has four columns, we're only specifying the values for two of them—<kbd>author</kbd> and <kbd>text</kbd>. PostgreSQL automatically provides the <kbd>haiku_id</kbd> as well as a default value for <kbd>created_at</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p157"> 
   <p>Also notice the <kbd>E</kbd> before the starting quote of the haiku. This marks the value as an <em>escape string</em>, correctly translating the <kbd>\n</kbd> escape sequence into a newline character.</p>
  </div>
  <div class="readable-text  intended-text" id="p158"> 
   <p>Before we query these tables, let's add another unsettling haiku under <kbd>alice</kbd> for good measure:</p>
  </div>
  <div class="browsable-container listing-container" id="p159"> 
   <div class="code-area-container"> 
    <pre class="code-area">INSERT INTO haikus (author, text) VALUES
('alice', E'Five frogs are jumping\nFour come down as expected\nBut one goes missing.');</pre>
   </div>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p160"> 
   <h4 class=" readable-text-h4">Querying tables</h4>
  </div>
  <div class="readable-text " id="p161"> 
   <p>The real strength of SQL lies in the versatile ways in which we can <em>query </em>tables (read data from them) once they have been populated with rows.</p>
  </div>
  <div class="readable-text  intended-text" id="p162"> 
   <p>To retrieve data, we use the <kbd>SELECT</kbd> statement. This command allows us to specify the columns we want to see and filter rows based on certain criteria. Let's start with a simple query to fetch all the rows and columns from the <kbd>users</kbd> table:</p>
  </div>
  <div class="browsable-container listing-container" id="p163"> 
   <div class="code-area-container"> 
    <pre class="code-area">SELECT * FROM users;</pre>
   </div>
  </div>
  <div class="readable-text " id="p164"> 
   <p>The * indicates that we want to retrieve all columns from the table. As a result of this, we'll see a list of all users along with their associated <kbd>user_id</kbd> and <kbd>password_hash</kbd>. We only currently have one user, so we get:</p>
  </div>
  <div class="browsable-container listing-container" id="p165"> 
   <div class="code-area-container"> 
    <pre class="code-area"> username | password_hash
----------+---------------
 alice    | Pass_word&amp;34
(1 row)</pre>
   </div>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p166"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p167"> 
    <p>If you're horrified to see passwords so easily queried, don't worry! As we'll soon see, we're not actually going to be storing passwords like this.</p>
   </div>
  </div>
  <div class="readable-text " id="p168"> 
   <p>We could also choose to only retrieve certain columns from the table. For example, if we only want the <kbd>haiku_id</kbd>, <kbd>created_at</kbd>, and <kbd>author</kbd> fields from the <kbd>haikus</kbd> table, we could write:</p>
  </div>
  <div class="browsable-container listing-container" id="p169"> 
   <div class="code-area-container"> 
    <pre class="code-area">SELECT haiku_id, created_at, author FROM haikus;</pre>
   </div>
  </div>
  <div class="readable-text " id="p170"> 
   <p>This would give us:</p>
  </div>
  <div class="browsable-container listing-container" id="p171"> 
   <div class="code-area-container"> 
    <pre class="code-area"> haiku_id |          created_at           | author
----------+-------------------------------+--------
        1 | 2024-12-10 16:12:11.71654-08  | alice
        2 | 2024-12-10 16:12:16.364669-08 | alice
(2 rows)</pre>
   </div>
  </div>
  <div class="readable-text " id="p172"> 
   <p>We can also filter the rows we want to see based on a condition (or set of conditions) using a <kbd>WHERE</kbd> clause. For example, if we want to see the <kbd>haiku_id</kbd> and <kbd>text</kbd> for only haikus that are written by <kbd>alice</kbd> and contain <kbd>"fox"</kbd>, we could use the following:</p>
  </div>
  <div class="browsable-container listing-container" id="p173"> 
   <div class="code-area-container"> 
    <pre class="code-area">SELECT haiku_id, text FROM haikus WHERE author = 'alice' AND text LIKE '%fox%';</pre>
   </div>
  </div>
  <div class="readable-text " id="p174"> 
   <p>to get:</p>
  </div>
  <div class="browsable-container listing-container" id="p175"> 
   <div class="code-area-container"> 
    <pre class="code-area"> haiku_id |             text
----------+-------------------------------
        1 | Two foxes leap high          +
          | One lands safely on the earth+
          | Where is the other?
(1 row)</pre>
   </div>
  </div>
  <div class="readable-text " id="p176"> 
   <p>We've filtered the <kbd>haikus</kbd> table using two conditions separated by the keyword <kbd>AND</kbd> here: <kbd>author = 'alice'</kbd>, and <kbd>text LIKE '%fox%'</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p177"> 
   <p>The <kbd>LIKE</kbd> keyword is used to perform text-matching. The <kbd>%</kbd> symbol means "zero or more characters," making <kbd>%fox%</kbd> a pattern that matches any text containing the word 'fox' anywhere within it.</p>
  </div>
  <div class="readable-text  intended-text" id="p178"> 
   <p>The <kbd>SELECT</kbd> statement can do a <em>lot </em>more than this, such as calculating summary statistics, aggregating rows, fetching data from multiple tables by joining them and more, but these are out of the scope of this chapter.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p179"> 
   <h4 class=" readable-text-h4">Updating tables</h4>
  </div>
  <div class="readable-text " id="p180"> 
   <p>You can update rows in a table after you've inserted them, using the <kbd>UPDATE</kbd> statement. For example, let's say you want to add the string "[By Alice] " to the start of the haiku with <kbd>haiku_id</kbd> 1:</p>
  </div>
  <div class="browsable-container listing-container" id="p181"> 
   <div class="code-area-container"> 
    <pre class="code-area">UPDATE haikus SET text = '[By Alice] ' || text WHERE haiku_id = 1;</pre>
   </div>
  </div>
  <div class="readable-text " id="p182"> 
   <p>Here we're setting the column <kbd>text</kbd> in the <kbd>haikus</kbd> table for rows where the <kbd>haiku_id</kbd> is <kbd>1</kbd>. The The <kbd>||</kbd> operator is used in SQL to concatenate strings, so <kbd>SET text = '[By Alice] ' || text</kbd> adds "[By Alice] " to the beginning. If we now <kbd>SELECT</kbd> the text for that haiku with:</p>
  </div>
  <div class="browsable-container listing-container" id="p183"> 
   <div class="code-area-container"> 
    <pre class="code-area">SELECT text FROM haikus WHERE haiku_id = 1;</pre>
   </div>
  </div>
  <div class="readable-text " id="p184"> 
   <p>we'll get:</p>
  </div>
  <div class="browsable-container listing-container" id="p185"> 
   <div class="code-area-container"> 
    <pre class="code-area">              text
--------------------------------
 [By Alice] Two foxes leap high+
 One lands safely on the earth +
 Where is the other?
(1 row)</pre>
   </div>
  </div>
  <div class="readable-text " id="p186"> 
   <p>Though we've only updated one row here, <kbd>UPDATE</kbd> will update all the rows that match the <kbd>WHERE</kbd> clause. If we omit the <kbd>WHERE</kbd> clause, the <kbd>UPDATE</kbd> will apply to every single row in the table.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p187"> 
   <h4 class=" readable-text-h4">Deleting rows (and tables)</h4>
  </div>
  <div class="readable-text " id="p188"> 
   <p>To delete rows from a table, we use the <kbd>DELETE FROM</kbd> command. Just as in the case of <kbd>UPDATE</kbd>, it uses a <kbd>WHERE</kbd> condition to determine the rows to delete.</p>
  </div>
  <div class="readable-text  intended-text" id="p189"> 
   <p>So we could delete the haiku with ID 2 by running:</p>
  </div>
  <div class="browsable-container listing-container" id="p190"> 
   <div class="code-area-container"> 
    <pre class="code-area">DELETE FROM haikus WHERE haiku_id = 2;</pre>
   </div>
  </div>
  <div class="readable-text " id="p191"> 
   <p>Be careful with this command! If you omit the <kbd>WHERE</kbd> clause, <kbd>DELETE FROM</kbd> will delete <em>every single</em> row!</p>
  </div>
  <div class="readable-text  intended-text" id="p192"> 
   <p>Finally, we can delete a table itself (as opposed to just the rows in the table), by using the <kbd>DROP TABLE</kbd> command.</p>
  </div>
  <div class="readable-text  intended-text" id="p193"> 
   <p>For instance, if we wanted to remove the <kbd>haikus</kbd> table (which we don't, for now), we could have entered:</p>
  </div>
  <div class="browsable-container listing-container" id="p194"> 
   <div class="code-area-container"> 
    <pre class="code-area">DROP TABLE haikus;</pre>
   </div>
  </div>
  <div class="readable-text " id="p195"> 
   <p>Of course, there's much more to SQL than what we've learned—indeed, entire careers can be forged by knowing it well enough—but this is all we'll need for this chapter.</p>
  </div>
  <div class="readable-text" id="p196"> 
   <h3 class=" readable-text-h3">8.2.5 Connecting PostgreSQL to our app</h3>
  </div>
  <div class="readable-text " id="p197"> 
   <p>We've now set up the database for Haiku Haven. We've also learned to insert rows and query our database <em>manually</em>. What's left is to enable our app to query and make changes to the database <em>programmatically</em>, through Python.</p>
  </div>
  <div class="readable-text  intended-text" id="p198"> 
   <p>For this, we'll employ a third-party Python module named <kbd>psycopg2</kbd>, which provides us with a way to talk to PostgreSQL in our app.</p>
  </div>
  <div class="readable-text  intended-text" id="p199"> 
   <p>Go ahead and install it now by running <kbd>pip install psycopg2</kbd> in a new terminal window.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p200"> 
   <h4 class=" readable-text-h4">How database connections work</h4>
  </div>
  <div class="readable-text " id="p201"> 
   <p>Before using <kbd>psycopg2</kbd>, let’s understand how PostgreSQL queries work in Python.</p>
  </div>
  <div class="readable-text  intended-text" id="p202"> 
   <p>We learned in prior chapters that a Streamlit app is served by a Streamlit server process that listens to a particular port (usually 8501 or something near that) on a machine. Similarly, a PostgreSQL database runs on a PostgreSQL server that listens to a different port—5432 by default, unless you set a different port number when you installed it.</p>
  </div>
  <div class="readable-text  intended-text" id="p203"> 
   <p>To execute SQL commands, the app must establish a <em>connection</em> to the PostgreSQL server. A single connection can handle only one command at a time.</p>
  </div>
  <div class="readable-text  intended-text" id="p204"> 
   <p>But what if multiple users try to create or update a haiku at once? We could queue up the SQL commands on a single connection, but that could cause delays. Using multiple <em>connections</em> is better, but setting up each one can be resource-intensive—especially in production—as it involves network initialization and authentication.</p>
  </div>
  <div class="readable-text  intended-text" id="p205"> 
   <p><kbd>psycopg2</kbd>'s answer to this is a <em>connection pool </em>that manages multiple <em>re-usable</em> database connections efficiently, illustrated by figure 8.5.</p>
  </div>
  <div class="browsable-container figure-container" id="p206">  
   <img src="../Images/ch08__image005.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 8.5 Database connection pool with 1 minimum and 5 maximum connections</h5>
  </div>
  <div class="readable-text " id="p207"> 
   <p>A connection pool maintains a set of connections that can be quickly reused by different parts of the application or different users accessing the application. When a part of the application needs to run a database query, it can:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p208">Request a connection from the pool</li>
   <li class="readable-text" id="p209">Use the connection to execute the query</li>
   <li class="readable-text" id="p210">Return the connection to the pool for reuse</li>
  </ul>
  <div class="readable-text sub-sub-section-heading" id="p211"> 
   <h4 class=" readable-text-h4">Using psycopg2 to connect to our database</h4>
  </div>
  <div class="readable-text " id="p212"> 
   <p>With all that in mind, let's try setting up a live database connection and running a query! Open a Python shell by typing <kbd>python</kbd> (or <kbd>python3</kbd>) into your terminal.</p>
  </div>
  <div class="readable-text  intended-text" id="p213"> 
   <p>Once you're in, import what we need from the module:</p>
  </div>
  <div class="browsable-container listing-container" id="p214"> 
   <div class="code-area-container"> 
    <pre class="code-area">&gt;&gt;&gt; from psycopg2.pool import ThreadedConnectionPool</pre>
   </div>
  </div>
  <div class="readable-text " id="p215"> 
   <p><kbd>ThreadedConnectionPool</kbd> is the connection pool class we'll use. To instantiate it, we'll need the address where our PostgreSQL server is running, the port number it's running on, the username and password of the PostgreSQL user we created, and the name of our database.</p>
  </div>
  <div class="readable-text  intended-text" id="p216"> 
   <p>We can combine all of these into a <em>connection string</em> that takes the form:</p>
  </div>
  <div class="browsable-container listing-container" id="p217"> 
   <div class="code-area-container"> 
    <pre class="code-area">postgresql://&lt;PostgreSQL username&gt;:&lt;Password&gt;@&lt;Address of server&gt;:&lt;Port number&gt;/&lt;Database name&gt;</pre>
   </div>
  </div>
  <div class="readable-text " id="p218"> 
   <p>In our case, we'll type:</p>
  </div>
  <div class="browsable-container listing-container" id="p219"> 
   <div class="code-area-container"> 
    <pre class="code-area">&gt;&gt;&gt; connection_string = 'postgresql://haiku_lord:&lt;password&gt;@localhost:5432/haikudb'</pre>
   </div>
  </div>
  <div class="readable-text " id="p220"> 
   <p>Obviously, you'll need to replace <kbd>&lt;password&gt;</kbd> with the actual password you created for <kbd>haiku_lord</kbd>. Since we're running PostgreSQL locally right now, the server address is simply <kbd>localhost</kbd>, but this will change when we switch to a managed PostgreSQL service during deployment later in the chapter.</p>
  </div>
  <div class="readable-text  intended-text" id="p221"> 
   <p>We can now create our connection pool:</p>
  </div>
  <div class="browsable-container listing-container" id="p222"> 
   <div class="code-area-container"> 
    <pre class="code-area">&gt;&gt;&gt; connection_pool = ThreadedConnectionPool(1, 5, connection_string)</pre>
   </div>
  </div>
  <div class="readable-text " id="p223"> 
   <p>1 and 5 here are the minimum and maximum connections in the pool. This means 1 connection is always kept available even before we receive any requests, and a maximum of 5 simultaneous connections can be maintained.</p>
  </div>
  <div class="readable-text  intended-text" id="p224"> 
   <p>Let's grab a connection from the pool using the <kbd>getconn</kbd> method:</p>
  </div>
  <div class="browsable-container listing-container" id="p225"> 
   <div class="code-area-container"> 
    <pre class="code-area">&gt;&gt;&gt; connection = connection_pool.getconn()</pre>
   </div>
  </div>
  <div class="readable-text " id="p226"> 
   <p>To execute a query, we need a <em>cursor</em>, which is a pointer that allows us to execute SQL commands and fetch results from the database in flexible ways. We create one by calling the <kbd>cursor()</kbd> method on our <kbd>connection</kbd> object:</p>
  </div>
  <div class="browsable-container listing-container" id="p227"> 
   <div class="code-area-container"> 
    <pre class="code-area">&gt;&gt;&gt; cursor = connection.cursor()
Let's now write the query itself. We'll try to fetch the haiku_id and author fields for a given author:
&gt;&gt;&gt; query = 'SELECT haiku_id, author FROM haikus WHERE author = %s'</pre>
   </div>
  </div>
  <div class="readable-text " id="p228"> 
   <p>Note the <kbd>%s</kbd> here. This makes the username of the author a parameter of the query. By plugging in different usernames, we could get the haikus of different authors. For now, we want <kbd>alice</kbd>'s haikus, so we'll create a params tuple to pass along with the query.</p>
  </div>
  <div class="browsable-container listing-container" id="p229"> 
   <div class="code-area-container"> 
    <pre class="code-area">&gt;&gt;&gt; params = ('alice',)</pre>
   </div>
  </div>
  <div class="readable-text " id="p230"> 
   <p><kbd>('alice',)</kbd> is the literal notation for a single-element tuple containing the string <kbd>'alice'</kbd>.</p>
  </div>
  <div class="browsable-container listing-container" id="p231"> 
   <div class="code-area-container"> 
    <pre class="code-area">&gt;&gt;&gt; cursor.execute(query, params)</pre>
   </div>
  </div>
  <div class="readable-text " id="p232"> 
   <p>Once the execution is done, let's fetch all the results.</p>
  </div>
  <div class="browsable-container listing-container" id="p233"> 
   <div class="code-area-container"> 
    <pre class="code-area">&gt;&gt;&gt; cursor.fetchall()
[(2, 'alice'), (1, 'alice')]</pre>
   </div>
  </div>
  <div class="readable-text " id="p234"> 
   <p>The results are in the form of a list of tuples, where each tuple represents a single row in the database. Since our <kbd>SELECT</kbd> clause said <kbd>haiku_id, author</kbd>, the first element of each result tuple is the <kbd>haiku_id</kbd>, while the second is the <kbd>author</kbd> field.</p>
  </div>
  <div class="readable-text  intended-text" id="p235"> 
   <p>Since we're done with the query, let's return the connection to the pool so other parts of the app can use it:</p>
  </div>
  <div class="browsable-container listing-container" id="p236"> 
   <div class="code-area-container"> 
    <pre class="code-area">&gt;&gt;&gt; connection_pool.putconn(connection)</pre>
   </div>
  </div>
  <div class="readable-text " id="p237"> 
   <p>That concludes our illustration of <kbd>psycopg2</kbd>. As a final step, let's clean up the connection pool:</p>
  </div>
  <div class="browsable-container listing-container" id="p238"> 
   <div class="code-area-container"> 
    <pre class="code-area">&gt;&gt;&gt; connection_pool.closeall()</pre>
   </div>
  </div>
  <div class="readable-text " id="p239"> 
   <p>This closes all connections and no more can be requested from the pool.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p240"> 
   <h4 class=" readable-text-h4">Creating a Database class</h4>
  </div>
  <div class="readable-text " id="p241"> 
   <p>Now that we know how to run SQL queries in Python, we're ready to begin writing the code for our app.</p>
  </div>
  <div class="readable-text  intended-text" id="p242"> 
   <p>In this chapter, we're going to organize our code in two folders: <kbd>backend</kbd> and <kbd>frontend</kbd>, and a main entrypoint script (the one we'll use with <kbd>streamlit run</kbd>) that lies outside of either.</p>
  </div>
  <div class="readable-text  intended-text" id="p243"> 
   <p>The database connection stuff we just covered is pretty technical and we'd rather not have to deal with it in the remainder of our app's code. It would be nice if we had a database object that we could just ask to execute the queries we need, without having to worry about the gory details of connection pools and cursors. Whenever we want to run a particular query, we should be able to write <kbd>database.execute_query(query, params)</kbd>, passing in the query we want to execute and the parameters we want to give it.</p>
  </div>
  <div class="readable-text  intended-text" id="p244"> 
   <p>To set this up, let's create a <kbd>Database</kbd> <em>class</em>.</p>
  </div>
  <div class="readable-text  intended-text" id="p245"> 
   <p>Create a new Python file called <kbd>database.py</kbd> within the backend folder and copy the code in listing 8.1.</p>
  </div>
  <div class="browsable-container listing-container" id="p246"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 8.1 backend/database.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">from psycopg2.pool import ThreadedConnectionPool
 
MIN_CONNECTIONS = 1
MAX_CONNECTIONS = 10
 
class Database:
  def __init__(self, connection_string):
    self.connection_pool = ThreadedConnectionPool(
      MIN_CONNECTIONS, MAX_CONNECTIONS, connection_string
    )
 
  def connect(self):
    return self.connection_pool.getconn()
 
  def close(self, connection):
    self.connection_pool.putconn(connection)
 
  def close_all(self):
    print("Closing all connections...")
    self.connection_pool.closeall()
 
  def execute_query(self, query, params=()):
    connection = self.connect()
    try:
      cursor = connection.cursor()
      cursor.execute(query, params)
      results = cursor.fetchall()
      connection.commit()
      return results
    except Exception:
      connection.rollback()
      raise
    finally:
      self.close(connection)</pre>
   </div>
  </div>
  <div class="readable-text " id="p247"> 
   <p>By this point, you should be used to the simple dataclasses we've used in prior chapters. Dataclasses simplify the syntax used to create classes in Python, but for more complex use cases, we need to peel back that layer and write a traditional class definition.</p>
  </div>
  <div class="readable-text  intended-text" id="p248"> 
   <p>A class is essentially a blueprint that can be turned into a concrete Python object, which can have attributes—these are the object's properties or data associated with the object—and methods—or functions that define the object's behavior and can interact with its attributes.</p>
  </div>
  <div class="readable-text  intended-text" id="p249"> 
   <p>Let's study the class definition for our <kbd>Database</kbd> class, shown in listing 8.1. We'll start with the <kbd>__init__</kbd> method:</p>
  </div>
  <div class="browsable-container listing-container" id="p250"> 
   <div class="code-area-container"> 
    <pre class="code-area">def __init__(self, connection_string):
  self.connection_pool = ThreadedConnectionPool(
    MIN_CONNECTIONS, MAX_CONNECTIONS, connection_string
  )</pre>
   </div>
  </div>
  <div class="readable-text " id="p251"> 
   <p><kbd>__init__</kbd> (pronounced "dunder init") is a special method in Python. When an object is first created from a class, the <kbd>__init__</kbd> method is executed automatically. The two arguments our <kbd>__init__</kbd> takes are <kbd>self</kbd> and <kbd>connection_string</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p252"> 
   <p>You'll see <kbd>self</kbd> extremely often in Python class definitions. The first argument to a method within a class is a special one that's not explicitly passed while calling it (as we'll see in a bit). It always refers to the object on which the method is being called. By convention, this argument is named <kbd>self</kbd>—though you can technically call it whatever you like.</p>
  </div>
  <div class="readable-text  intended-text" id="p253"> 
   <p><kbd>connection_string</kbd> is meant to hold a string of the type we formed earlier, containing the database configuration.</p>
  </div>
  <div class="readable-text  intended-text" id="p254"> 
   <p>The line <kbd>self.connection_pool = ThreadedConnectionPool(MIN_CONNECTIONS, MAX_CONNECTIONS, connection_string)</kbd> creates a <kbd>psycopg2</kbd> <kbd>ThreadedConnectionPool</kbd> as we demonstrated in the earlier section, and assigns it to <kbd>self.connection_pool</kbd>, making it an attribute of the object created from the class.</p>
  </div>
  <div class="readable-text  intended-text" id="p255"> 
   <p><kbd>MIN_CONNECTIONS</kbd> and <kbd>MAX_CONNECTIONS</kbd> are defined at the top of the file where they can be easily configured or changed later.</p>
  </div>
  <div class="readable-text  intended-text" id="p256"> 
   <p>We're effectively initializing a connection pool as soon as the database object is created.</p>
  </div>
  <div class="readable-text  intended-text" id="p257"> 
   <p>We also define methods other than <kbd>__init__</kbd>, such as <kbd>connect</kbd>, which obtains a connection from the pool, <kbd>close</kbd>, which returns a given connection to the pool, and <kbd>close_all</kbd>, which closes the connection pool itself (and prints a message to the terminal window). The code for these should be familiar as we discussed it when we were trying out <kbd>psycopg2</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p258"> 
   <p>However, we generally won't call these methods directly. Recall that what we really want is a simple <kbd>execute_query</kbd> method that'll take care of all the underlying database connection logic. Let's presently turn our attention to that method:</p>
  </div>
  <div class="browsable-container listing-container" id="p259"> 
   <div class="code-area-container"> 
    <pre class="code-area">def execute_query(self, query, params=()):
  connection = self.connect()
  try:
    cursor = connection.cursor()
    cursor.execute(query, params)
    results = cursor.fetchall()
    connection.commit()
    return results
  except Exception:
    connection.rollback()
    raise
  finally:
    self.close(connection)</pre>
   </div>
  </div>
  <div class="readable-text " id="p260"> 
   <p><kbd>execute_query</kbd> naturally accepts a SQL query we want to execute and any params (set to an empty tuple, <kbd>()</kbd>, by default) we want to give the query.</p>
  </div>
  <div class="readable-text  intended-text" id="p261"> 
   <p>The body of the method starts by obtaining a connection from the pool. We then see a <kbd>try</kbd>-<kbd>finally</kbd> block.</p>
  </div>
  <div class="readable-text  intended-text" id="p262"> 
   <p>In Python, <kbd>try</kbd>-<kbd>except</kbd>-<kbd>finally</kbd> is a construct <kbd>that's</kbd> used for error handling. The idea is to write your regular code in the <kbd>try</kbd> block. If an exception occurs while running the <kbd>try</kbd> code, Python stops execution and jumps to an <kbd>except</kbd> block that "catches" the exception, allowing you to log a sensible error message, for example, or use some other kind of handling logic.</p>
  </div>
  <div class="readable-text  intended-text" id="p263"> 
   <p>Regardless of whether there's an exception or not, the code in the <kbd>finally</kbd> block is always executed.</p>
  </div>
  <div class="readable-text  intended-text" id="p264"> 
   <p>The code in the <kbd>try</kbd> block simply gets a cursor, executes the query and returns the results, just as we saw when we were exploring <kbd>psycopg2</kbd>. The only new thing you might notice is the line <kbd>connection.commit()</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p265"> 
   <p>This line exists because we're not just going to be using <kbd>execute_query</kbd> to run <kbd>SELECT</kbd> queries. We're also going to run <kbd>INSERT INTO</kbd>, <kbd>UPDATE</kbd>, and <kbd>DELETE FROM</kbd> commands—all of which <em>modify</em> tables, not just <em>read</em> from them.</p>
  </div>
  <div class="readable-text  intended-text" id="p266"> 
   <p>In PostgreSQL, when you modify data, the changes aren't permanently saved until you <em>commit </em>them.</p>
  </div>
  <div class="readable-text  intended-text" id="p267"> 
   <p>What if some kind of error occurs (for instance, the given query might have incorrect SQL syntax) while Python's trying to execute this code? We enter the <kbd>except</kbd> block marked by <kbd>except Exception</kbd>, which contains the line <kbd>connection.rollback()</kbd>. This undoes any temporary changes made so that the database is left in a pristine state.</p>
  </div>
  <div class="readable-text  intended-text" id="p268"> 
   <p>We also print the error we encountered and then re-raise the exception, letting the regular exception flow take over—such as printing the exception message to the screen. What we've achieved with the <kbd>try</kbd>-<kbd>except</kbd> construct is to inject ourselves into the flow when an exception occurs and make sure any partial changes are rolled back.</p>
  </div>
  <div class="readable-text  intended-text" id="p269"> 
   <p>What about the <kbd>finally</kbd> block? Well, that calls the <kbd>close</kbd> method further up in the file, returning the connection to the pool. Regardless of what happens in the <kbd>try</kbd> block, the connection is always freed up. If we didn't have this code, the connection would remain allocated even after the function exits, and eventually the pool would run out of new connections. Putting this code in the <kbd>finally</kbd> block ensures the connection is returned even if an error occurs.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p270"> 
   <h4 class=" readable-text-h4">Using the Database class in our app</h4>
  </div>
  <div class="readable-text " id="p271"> 
   <p>With a <kbd>Database</kbd> class set up, all that's left to do to enable persistent storage and retrieval in our app is to actually use the class in our Streamlit app.</p>
  </div>
  <div class="readable-text  intended-text" id="p272"> 
   <p>Creating an instance of the Database class requires providing it with a connection string. Connection strings are sensitive because they contain PostgreSQL credentials, so we don't want to be putting the string in our code.</p>
  </div>
  <div class="readable-text  intended-text" id="p273"> 
   <p>You probably know where this is heading—we need to use <kbd>st.secrets</kbd> as we've done in the past! Without further ado, go ahead and create a <kbd>.streamlit</kbd> folder in your app's root folder (the parent folder where you created the <kbd>backend</kbd> directory), and create a<kbd> secrets.toml</kbd> within it, with contents similar to what's shown in listing 8.2.</p>
  </div>
  <div class="browsable-container listing-container" id="p274"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 8.2 .streamlit/secrets.toml</h5>
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">[config]
connection_string = "postgresql://haiku_lord:<b>password</b>@localhost:5432/haikudb"</pre>
   </div>
  </div>
  <div class="readable-text " id="p275"> 
   <p>Don't forget to replace <kbd>password</kbd> with your actual password. Also, as we learned before, you shouldn't check this file into Git.</p>
  </div>
  <div class="readable-text  intended-text" id="p276"> 
   <p>Next, create our app's entrypoint file—say, <kbd>main.py</kbd>—in the app's root directory, with the code in listing 8.3.</p>
  </div>
  <div class="browsable-container listing-container" id="p277"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 8.3 main.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
from backend.database import Database
 
st.title('Haiku Haven')
 
connection_string = st.secrets['config']['connection_string']
database = Database(connection_string)
query_results = database.execute_query('SELECT * FROM haikus')
st.write(query_results)</pre>
   </div>
  </div>
  <div class="readable-text " id="p278"> 
   <p>This is where it all comes together! Firstly, we import the <kbd>Database</kbd> class we just created using:</p>
  </div>
  <div class="browsable-container listing-container" id="p279"> 
   <div class="code-area-container"> 
    <pre class="code-area">from backend.database import Database</pre>
   </div>
  </div>
  <div class="readable-text " id="p280"> 
   <p>This line means "import the Database class from <kbd>backend/database.py</kbd>". Notice how, in module import paths, the path separator becomes a dot.</p>
  </div>
  <div class="readable-text  intended-text" id="p281"> 
   <p>For this line to work, Python needs to recognize the parent folder of <kbd>backend</kbd> as a starting point from which it can look for modules. We can do this by adding the path to the parent folder of <kbd>backend</kbd> to <kbd>sys.path</kbd>, which is the list of paths that determines this in Python.</p>
  </div>
  <div class="readable-text  intended-text" id="p282"> 
   <p>Fortunately, when you run the <kbd>streamlit run &lt;script.py&gt;</kbd> command, the parent folder of <kbd>&lt;script.py&gt;</kbd> is automatically added to <kbd>sys.path</kbd>. In this case, since the parent folder of <kbd>main.py</kbd> is also the parent folder of the <kbd>backend</kbd> directory, we don't need to do anything extra.</p>
  </div>
  <div class="readable-text  intended-text" id="p283"> 
   <p>Next, after displaying a title, we extract the connection string from <kbd>st.secrets</kbd> as we've done in prior chapters:</p>
  </div>
  <div class="browsable-container listing-container" id="p284"> 
   <div class="code-area-container"> 
    <pre class="code-area">connection_string = st.secrets['config']['connection_string']</pre>
   </div>
  </div>
  <div class="readable-text " id="p285"> 
   <p>We use this to create an instance of the <kbd>Database</kbd> class:</p>
  </div>
  <div class="browsable-container listing-container" id="p286"> 
   <div class="code-area-container"> 
    <pre class="code-area">database = Database(connection_string)</pre>
   </div>
  </div>
  <div class="readable-text " id="p287"> 
   <p>You'll probably recognize this syntax from when we've used dataclasses before, but this is the first time in this book that we've instantiated a traditional class we wrote, so a deeper explanation is warranted.</p>
  </div>
  <div class="readable-text  intended-text" id="p288"> 
   <p>What's going on here is that by passing <kbd>connection_string</kbd> to the class <kbd>Database</kbd> as though it were a function, we're actually passing it to <kbd>Database</kbd>'s <kbd>__init__</kbd> method, which has the signature line <kbd>def __init__(self, connection_string)</kbd>. As I mentioned earlier, <kbd>self</kbd> is automatically set to the object that's being created, so we don't need to pass it explicitly.</p>
  </div>
  <div class="readable-text  intended-text" id="p289"> 
   <p>Instead, we pass only <kbd>connection_string</kbd>, thus letting <kbd>__init__</kbd> set up the connection pool for us, and getting the resulting <kbd>Database</kbd> instance in the <kbd>database</kbd> variable (note that <kbd>__init__</kbd> will return the instance even though we didn't write an explicit <kbd>return</kbd> statement).</p>
  </div>
  <div class="readable-text  intended-text" id="p290"> 
   <p>Once we have the instance <kbd>database</kbd>, we use it to execute a simple <kbd>SELECT</kbd> query:</p>
  </div>
  <div class="browsable-container listing-container" id="p291"> 
   <div class="code-area-container"> 
    <pre class="code-area">query_results = database.execute_query('SELECT * FROM haikus')</pre>
   </div>
  </div>
  <div class="readable-text " id="p292"> 
   <p>Again, even though <kbd>execute_query</kbd> takes <kbd>self</kbd> as its first argument, we don't need to pass it explicitly. Instead <kbd>database</kbd> itself is passed to <kbd>self</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p293"> 
   <p>This query has no parameters, so we let the <kbd>params</kbd> argument have the default value (an empty tuple) by not specifying it.</p>
  </div>
  <div class="readable-text  intended-text" id="p294"> 
   <p>Finally, we use <kbd>st.write</kbd> to display the results of the query:</p>
  </div>
  <div class="browsable-container listing-container" id="p295"> 
   <div class="code-area-container"> 
    <pre class="code-area">st.write(query_results)</pre>
   </div>
  </div>
  <div class="readable-text " id="p296"> 
   <p>Take a look at the page now by typing <kbd>streamlit run main.py</kbd> (make sure you're in <kbd>main.py</kbd>'s containing folder first so that Streamlit can find the <kbd>.streamlit</kbd> folder). You should see something similar to figure 8.6.</p>
  </div>
  <div class="browsable-container figure-container" id="p297">  
   <img src="../Images/ch08__image006.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 8.6 The contents of the haiku table as read by executing a SELECT query using the Database class and displayed using st.write (see chapter_8/in_progress_01 in the GitHub repo for the full code)</h5>
  </div>
  <div class="readable-text " id="p298"> 
   <p>One interesting thing here is how <kbd>st.write</kbd> formats the list of tuples within <kbd>query_results</kbd> in an easy-to-read form.</p>
  </div>
  <div class="readable-text  intended-text" id="p299"> 
   <p>In any case, our app is now connected to a database! Next up, let's use this to allow users to create accounts!</p>
  </div>
  <div class="readable-text" id="p300"> 
   <h2 class=" readable-text-h2">8.3 Creating user accounts</h2>
  </div>
  <div class="readable-text " id="p301"> 
   <p>Since our users can create their own haikus, there needs to be a way for them to create Haiku Haven accounts to hold their haikus. In this section, we'll wire up our app to enable this, taking care to store passwords securely.</p>
  </div>
  <div class="readable-text  intended-text" id="p302"> 
   <p>Before we get to that though, let's take a minute to talk about code organization.</p>
  </div>
  <div class="readable-text" id="p303"> 
   <h3 class=" readable-text-h3">8.3.1 Splitting our app into services</h3>
  </div>
  <div class="readable-text " id="p304"> 
   <p>In Chapter 3, we discussed the principle of <em>separation of concerns</em>—the idea that each component of our app should focus on a specific thing and be independent of the other components, interacting with them only in ways that are specified by a contract or API.</p>
  </div>
  <div class="readable-text  intended-text" id="p305"> 
   <p>We'll do something similar here, separating the frontend and backend as we did in that chapter. Since we're using classes and <em>object-oriented programming </em>this time, we could define a backend class<em>—</em>let's call this <kbd>Hub</kbd>—that can be the single point of contact for frontend code to call backend code. Any function that the frontend can call should be a method in the <kbd>Hub</kbd> class. This is analogous to <kbd>backend.py</kbd> in Chapter 3 where every backend function called from the frontend code was defined in <kbd>backend.py</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p306"> 
   <p>We might expect the <kbd>Hub</kbd> class to have methods that fulfill actions a frontend user might want to take, such as <kbd>create_user</kbd>, <kbd>create_haiku</kbd>, <kbd>update_haiku</kbd>, etc. Over time, though, as our app grows more and more complex, the <kbd>Hub</kbd> class would have an increasing number of methods, slowly making it unwieldy and difficult to manage.</p>
  </div>
  <div class="readable-text  intended-text" id="p307"> 
   <p>Rather than take this <em>monolithic </em>approach, it might be a better idea to divide up the actions offered by Hub into individual<em> service classes</em>, each pertaining to a specific kind of action, and using the <kbd>Hub</kbd> class as merely a coordinator. For instance, we could have a <kbd>UserService</kbd> class that offers methods pertaining to users, such as <kbd>create_user</kbd>, and a <kbd>HaikuService</kbd> class that offers those related to haikus, such as <kbd>create_haiku</kbd> and <kbd>update_haiku</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p308"> 
   <p>This would make our app more modular and easier to extend and maintain. We can add more user-related functionality to <kbd>UserService</kbd> independently of the haiku-related actions in <kbd>HaikuService</kbd>, and if we wanted to add limericks to our app later, we could introduce a <kbd>LimerickService</kbd> without touching either.</p>
  </div>
  <div class="readable-text  intended-text" id="p309"> 
   <p>With our overall code organization strategy in mind, let's turn our attention towards building one of the components—the user service.</p>
  </div>
  <div class="readable-text" id="p310"> 
   <h3 class=" readable-text-h3">8.3.2 Creating the user service</h3>
  </div>
  <div class="readable-text " id="p311"> 
   <p>Just as in prior chapters, we'll use a dataclass to represent the fundamental objects we're concerned with. In Chapters 3, 4, and 6, we had <kbd>Unit</kbd>, <kbd>Task</kbd>, and <kbd>Metric</kbd> classes. Here, we'll start with a <kbd>User</kbd> class.</p>
  </div>
  <div class="readable-text  intended-text" id="p312"> 
   <p>Create a new Python file called <kbd>user.py</kbd> in the <kbd>backend</kbd> folder, with the text shown in listing 8.4.</p>
  </div>
  <div class="browsable-container listing-container" id="p313"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 8.4 backend/user.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">from dataclasses import dataclass
 
@dataclass
class User:
  username: str
  password_hash: str</pre>
   </div>
  </div>
  <div class="readable-text " id="p314"> 
   <p>You'll see that this directly mirrors the <kbd>users</kbd> table in our database, with fields for <kbd>username</kbd> and <kbd>password_hash</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p315"> 
   <p>Let's now talk about the latter field, and why we called it <kbd>password_hash</kbd> instead of <kbd>password</kbd>.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p316"> 
   <h4 class=" readable-text-h4">Storing passwords securely</h4>
  </div>
  <div class="readable-text " id="p317"> 
   <p>Passwords are naturally some of the most sensitive pieces of information software developers need to deal with, and much of the field of cybersecurity focuses on keeping them secret.</p>
  </div>
  <div class="readable-text  intended-text" id="p318"> 
   <p>We know that we shouldn't store passwords in our code, resorting to the construct of <kbd>st.secrets</kbd> to avoid this. But what about storing them in a database?</p>
  </div>
  <div class="readable-text  intended-text" id="p319"> 
   <p>Obviously, our app needs to be able to compare a user-entered password with the one actually associated with the user, so passwords need to be stored in some form. However, storing them directly as plain text in a database introduces a security vulnerability.</p>
  </div>
  <div class="readable-text  intended-text" id="p320"> 
   <p>That's because anyone who gains access to our database—through some kind of security breach—will be able to see passwords in their raw form. How do we avoid this though?</p>
  </div>
  <div class="readable-text  intended-text" id="p321"> 
   <p>The answer is: with <em>one-way cryptographic hash functions</em>, or in other words, a bit of fancy math. It turns out that there are certain mathematical operations that are easy to perform normally but extremely difficult to perform in reverse. As a trivial example, consider multiplying two prime numbers a and b to get c. Multiplying a and b to get c is easy, but if you're only given c, identifying a and b is difficult, especially when c is very, very large (think hundreds of digits long).</p>
  </div>
  <div class="readable-text  intended-text" id="p322"> 
   <p>Similarly, you can think of a cryptographic hash function as an operation performed on a password that's very difficult to reverse.</p>
  </div>
  <div class="readable-text  intended-text" id="p323"> 
   <p>Let's say someone's password is <kbd>SomePassword123</kbd>. If you apply a hash function <kbd>H</kbd> to it, you might get a password hash that looks like a random sequence of characters:</p>
  </div>
  <div class="readable-text  intended-text" id="p324"> 
   <p>Rather than store the string <kbd>SomePassword123</kbd> directly in the database, we store <kbd>g53jkdlgfee09ded8d33rr45t5y5y43f2eff</kbd>. Then when someone enters a password in our app, we apply the hash function to <em>that </em>password and compare the result to <kbd>g53jkdlgfee09ded8d33rr45t5y5y43f2eff</kbd>. If the two are the same, the user is authenticated.</p>
  </div>
  <div class="readable-text  intended-text" id="p325"> 
   <p>How does this help with security? Well, if a hacker now manages to get into our database, they don't have the actual password, only the password hash. As stated, it's very difficult to obtain the password from the password hash.</p>
  </div>
  <div class="readable-text  intended-text" id="p326"> 
   <p>The password hash itself is useless to the hacker as there's no point entering it in the app—if you did, the app would just apply the hash function on it and come up with a completely different hash that's compared against the real one.</p>
  </div>
  <div class="readable-text  intended-text" id="p327"> 
   <p>How do we implement this in our app? Fortunately, we don't have to do it from scratch. There are third-party libraries that do it for us. We'll use <kbd>bcrypt</kbd>, which you should install now with <kbd>pip install bcrypt</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p328"> 
   <p>Let's add two more methods to our <kbd>User</kbd> class so it now looks like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p329"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">from dataclasses import dataclass
<b>import bcrypt</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
@dataclass
class User:
  username: str
  password_hash: str
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
  <b>@staticmethod</b>
<b>  def hash_password(password):</b>
<b>    return bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode()</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
  <b>def authenticate(self, password):</b>
<b>    return bcrypt.checkpw(password.encode(), self.password_hash.encode())</b></pre>
   </div>
  </div>
  <div class="readable-text " id="p330"> 
   <p>We've decorated the <kbd>hash_password</kbd> method with <kbd>@staticmethod</kbd>. This makes it belong to the class itself rather than to any specific instance of the class. We generally use <kbd>@staticmethod</kbd> for utility functions that are logically related to a class but don't actually need to access anything from a particular instance.</p>
  </div>
  <div class="readable-text  intended-text" id="p331"> 
   <p><kbd>hash_password</kbd> is a good fit for this since it doesn't need to access any of the instance's attributes or methods (note the absence of a <kbd>self</kbd> parameter). Rather, it simply accepts a password entered by a user, converts it into a hash using <kbd>bcrypt</kbd>, and returns it.</p>
  </div>
  <div class="readable-text  intended-text" id="p332"> 
   <p>I won't go into the details of how this works, but at a high level, we're taking an extra measure of security here by adding a random "salt" to the password (<kbd>bcrypt.gensalt()</kbd>) before hashing it. This salt helps protect the password against hackers simply looking up the password associated with a password hash from a huge pre-computed table of such hashes (called a <em>rainbow table</em>).</p>
  </div>
  <div class="readable-text  intended-text" id="p333"> 
   <p>We also have an <kbd>authenticate</kbd> method that we'll use when a user enters a password. <kbd>bcrypt.checkpw</kbd> compares the entered password (<kbd>password.encode()</kbd>) and the password hash stored in the <kbd>User</kbd> object (<kbd>self.password_hash.encode()</kbd>), returning <kbd>True</kbd> if they match.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p334"> 
   <h4 class=" readable-text-h4">The UserService class</h4>
  </div>
  <div class="readable-text " id="p335"> 
   <p>We're now ready to create the <kbd>UserService</kbd> class, the one we determined would have methods for user-related operations. Create a <kbd>user_service.py</kbd> file under <kbd>backend/</kbd> with the content in listing 8.5.</p>
  </div>
  <div class="browsable-container listing-container" id="p336"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 8.5 backend/user_service.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">from backend.user import User
 
class UserService:
  def __init__(self, database):
    self.database = database
 
  def get_user(self, username):
    query = "SELECT username, password_hash FROM users WHERE username = %s"
    params = (username,)
    results = self.database.execute_query(query, params)
    return User(*results[0]) if results else None
 
  def create_user(self, username, password):
    existing_user = self.get_user(username)
    if not existing_user:
      query = '''
        INSERT INTO users (username, password_hash)
          VALUES (%s, %s)
          RETURNING username, password_hash
      '''
      password_hash = User.hash_password(password)
      params = (username, password_hash)
      results = self.database.execute_query(query, params)
      return User(*results[0]) if results else None
    return None</pre>
   </div>
  </div>
  <div class="readable-text " id="p337"> 
   <p><kbd>UserService</kbd> has a <kbd>__init__</kbd> method that accepts an instance of the <kbd>Database</kbd> class we created earlier and assigns it to a <kbd>database</kbd> attribute (<kbd>self.database</kbd>) of the object.</p>
  </div>
  <div class="readable-text  intended-text" id="p338"> 
   <p>When a user enters a username and password to create a user, we first need to check if a user of that username already exists, so we have a <kbd>get_user</kbd> method that returns the user if one exists or <kbd>None</kbd> if it doesn't.</p>
  </div>
  <div class="readable-text  intended-text" id="p339"> 
   <p>The <kbd>get_user</kbd> method executes a parameterized SQL query (<kbd>SELECT username, password_hash FROM users WHERE username = %s</kbd>) on the database, passing the given username as the only parameter (<kbd>(username, )</kbd>).</p>
  </div>
  <div class="readable-text  intended-text" id="p340"> 
   <p>As we've seen before, this returns a list of tuples. Due to the <kbd>SELECT username, password</kbd>, these will be of the form <kbd>(&lt;username&gt;, &lt;password_hash&gt;)</kbd>. Consider the last line in <kbd>get_users</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p341"> 
   <div class="code-area-container"> 
    <pre class="code-area">return User(*results[0]) if results else None </pre>
   </div>
  </div>
  <div class="readable-text " id="p342"> 
   <p>If there's no user with the given username, results will be an empty list, so it'll evaluate to <kbd>False</kbd>, causing <kbd>get_user</kbd> to return <kbd>None</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p343"> 
   <p>If there <em>is </em>such a user, <kbd>results[0]</kbd> will be a tuple of the form <kbd>(&lt;username&gt;, &lt;password_hash&gt;)</kbd>. In Python, the <kbd>*</kbd> operator when applied to a tuple (or a list), <em>destructures</em> it for use in things like function calls.</p>
  </div>
  <div class="readable-text  intended-text" id="p344"> 
   <p>So <kbd>User(*results[0])</kbd> is equivalent to <kbd>User(&lt;username&gt;, &lt;password_hash&gt;)</kbd> which creates a new instance of the <kbd>User</kbd> dataclass (which you'll recall has two corresponding members: <kbd>username</kbd> and <kbd>password_hash</kbd>).</p>
  </div>
  <div class="readable-text  intended-text" id="p345"> 
   <p>The <kbd>create_user</kbd> method first uses <kbd>self.get_user(username)</kbd> to see if a user already exists with the given username. If it does, it simply returns <kbd>None</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p346"> 
   <p>If it doesn't, it issues the following query to the database:</p>
  </div>
  <div class="browsable-container listing-container" id="p347"> 
   <div class="code-area-container"> 
    <pre class="code-area">INSERT INTO users (username, password_hash)
  VALUES (%s, %s)
  RETURNING username, password_hash</pre>
   </div>
  </div>
  <div class="readable-text " id="p348"> 
   <p>This is an <kbd>INSERT</kbd> query, which we've seen previously. The only new thing here is the line <kbd>RETURNING username, password_hash</kbd>. An <kbd>INSERT</kbd> query doesn't generally need to return any results, as it's a modify operation, not a read operation.</p>
  </div>
  <div class="readable-text  intended-text" id="p349"> 
   <p>Adding the <kbd>RETURNING</kbd> clause makes it return the specified fields in the same way that a <kbd>SELECT</kbd> query would. In this case, the <kbd>username</kbd> and <kbd>password_hash</kbd> of the newly created row are returned.</p>
  </div>
  <div class="readable-text  intended-text" id="p350"> 
   <p>Once again, <kbd>create_user</kbd> uses the same approach as <kbd>get_user</kbd> (<kbd>User(*results[0])</kbd>) to create and return a <kbd>User</kbd> object if everything is successful.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p351"> 
   <h4 class=" readable-text-h4">The Hub class</h4>
  </div>
  <div class="readable-text " id="p352"> 
   <p>When we spoke of code organization earlier, we mentioned the <kbd>Hub</kbd> class, which would be the single point that our frontend code would access. Let's write that class now. Create <kbd>backend/hub.py</kbd> with the code from listing 8.6.</p>
  </div>
  <div class="browsable-container listing-container" id="p353"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 8.6 backend/hub.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">from backend.database import Database
from backend.user_service import UserService
 
class Hub:
  def __init__(self, config):
    database = Database(config['connection_string'])
    self.user_service = UserService(database)</pre>
   </div>
  </div>
  <div class="readable-text " id="p354"> 
   <p>The <kbd>Hub</kbd> class's <kbd>__init__</kbd> is quite simple: it accepts a <kbd>config</kbd> object (a dictionary of configuration options, such as the one obtained by parsing the <kbd>secrets.toml</kbd> file we created earlier), creates a <kbd>Database</kbd> object, and passes it to <kbd>UserService</kbd> to create an instance of that class.</p>
  </div>
  <div class="readable-text  intended-text" id="p355"> 
   <p><kbd>Hub</kbd> has no other methods. This makes sense because, as we've emphasized, <kbd>Hub</kbd> is simply a coordinator class that our frontend can use to access the various service class objects (of which <kbd>user_service</kbd>, an instance of <kbd>UserService</kbd>, is the only one we've created so far).</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p356"> 
   <h4 class=" readable-text-h4">The signup page</h4>
  </div>
  <div class="readable-text " id="p357"> 
   <p>Working our way from the bottom up, we've created a <kbd>User</kbd> class, a <kbd>UserService</kbd> class that accesses the <kbd>User</kbd> class, and a <kbd>Hub</kbd> class that accesses the <kbd>UserService</kbd> class—which currently only has a <kbd>create_user</kbd> method.</p>
  </div>
  <div class="readable-text  intended-text" id="p358"> 
   <p>The part of our Streamlit app that accesses <kbd>create_user</kbd> will be the signup page, which we'll define—for now—in <kbd>main.py</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p359"> 
   <p>Our previous <kbd>main.py</kbd> initialized the <kbd>Database</kbd> object directly and executed a sample query. Since the database is now initialized in the <kbd>Hub</kbd> class, we'll rewrite <kbd>main.py</kbd> entirely, as shown in listing 8.7.</p>
  </div>
  <div class="browsable-container listing-container" id="p360"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 8.7 main.py revised</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
from backend.hub import Hub
 
hub = Hub(st.secrets['config'])
 
with st.container(border=True):
  st.title("Sign up")
  username = st.text_input("Username")
  password = st.text_input("Password", type="password")
  confirm_password = st.text_input("Confirm password", type="password")
 
  if st.button("Create account", type="primary"):
    if password != confirm_password:
      st.error("Passwords do not match")
    else:
      user = hub.user_service.create_user(username, password)
      if user:
        st.success("Account created successfully")
      else:
        st.error("Username already exists")</pre>
   </div>
  </div>
  <div class="readable-text " id="p361"> 
   <p>By this point in the book, you should be able to read the code in listing 8.7 fairly easily.</p>
  </div>
  <div class="readable-text  intended-text" id="p362"> 
   <p>It starts by creating an instance of <kbd>Hub</kbd> using the <kbd>'config'</kbd> entry of <kbd>st.secrets</kbd> (note here that <kbd>Hub</kbd> accepts the entire <kbd>config</kbd> object rather than just the connection string in case there are other configurations that need to be considered).</p>
  </div>
  <div class="readable-text  intended-text" id="p363"> 
   <p>Next, it displays the usual username-password-confirm password set of inputs I'm sure you've seen in various websites before. On clicking the "Create account" button, if the passwords in the two inputs don't match, an error is displayed.</p>
  </div>
  <div class="readable-text  intended-text" id="p364"> 
   <p>If they do match, we call the <kbd>create_user</kbd> method defined in the <kbd>UserService</kbd> class to create the user in the database:</p>
  </div>
  <div class="browsable-container listing-container" id="p365"> 
   <div class="code-area-container"> 
    <pre class="code-area">user = hub.user_service.create_user(username, password)</pre>
   </div>
  </div>
  <div class="readable-text " id="p366"> 
   <p>We then show a success or error message based on the return value.</p>
  </div>
  <div class="readable-text  intended-text" id="p367"> 
   <p>At this point, you should be able to see figure 8.7 if you rerun the app.</p>
  </div>
  <div class="browsable-container figure-container" id="p368">  
   <img src="../Images/ch08__image007.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 8.7 Haiku Haven's signup page (see chapter_8/in_progress_02 in the GitHub repo for the full code)</h5>
  </div>
  <div class="readable-text " id="p369"> 
   <p>Try creating an account with the username <kbd>bob</kbd>. To verify that it worked and that a user has indeed been created, you can issue the query <kbd>SELECT * from users where username = 'bob'</kbd> in your <kbd>psql</kbd> prompt (which you've hopefully kept open). This should give you something like:</p>
  </div>
  <div class="browsable-container listing-container" id="p370"> 
   <div class="code-area-container"> 
    <pre class="code-area"> username |                        password_hash
----------+--------------------------------------------------------------
 bob      | $2b$12$hVzjZJN7QMTM94H7ZL.ZJe3PFfgyAPgDOH1F2b38IovcuvKrNAu3G
(1 row)</pre>
   </div>
  </div>
  <div class="readable-text " id="p371"> 
   <p>As you can see, due to the hashing, <kbd>bob</kbd>'s password is no longer directly visible. But can <kbd>bob</kbd> log in? Not until we've completed the next part!</p>
  </div>
  <div class="readable-text" id="p372"> 
   <h2 class=" readable-text-h2">8.4 Setting up a multi-page login flow</h2>
  </div>
  <div class="readable-text " id="p373"> 
   <p>We saw earlier—when we sketched out the user experience—that Haiku Haven is meant to be a multi-page app with different pages for signup, login, and the haiku-related functionality, something we haven't encountered before.</p>
  </div>
  <div class="readable-text" id="p374"> 
   <h3 class=" readable-text-h3">8.4.1 Multi-page apps in Streamlit</h3>
  </div>
  <div class="readable-text " id="p375"> 
   <p>Streamlit has built-in support for multi-page apps. In this scheme, you define your individual pages separately, and let your entrypoint file (the one you run with <kbd>streamlit run</kbd>) act as a "router" that identifies the page to load and runs it.</p>
  </div>
  <div class="readable-text  intended-text" id="p376"> 
   <p>The entrypoint file is quite crucial here; it's loaded as usual in every re-run, and it's the one that picks the "current page" to load.</p>
  </div>
  <div class="readable-text  intended-text" id="p377"> 
   <p>Let's see an example. So far in our app, we've created a signup page for users to create their accounts, but not a login page. Once we do create the login page, there needs to be a way to tie the two together, making them part of the same app.</p>
  </div>
  <div class="readable-text  intended-text" id="p378"> 
   <p>We'll do that by revising the <kbd>main.py</kbd> file one more time, using the multi-page approach discussed above. The signup flow we included in <kbd>main.py</kbd> will have to move to a different file (<kbd>frontend/signup.py</kbd>). The new <kbd>main.py</kbd> is shown in listing 8.8.</p>
  </div>
  <div class="browsable-container listing-container" id="p379"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 8.8 main.py revised (yet again)</h5>
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">import streamlit as st
from backend.hub import Hub
 
<b>pages = {</b>
<b>  "login": st.Page("frontend/login.py", title="Log in",</b>
<b>                   icon=":material/login:"),</b>
<b>  "signup": st.Page("frontend/signup.py", title="Sign up", </b>
<b>                    icon=":material/person_add:"),</b>
<b>}</b>
<b></b>
<b>if 'hub' not in st.session_state:</b>
<b>  config = st.secrets['config']</b>
<b>  st.session_state.hub = Hub(config)</b>
<b></b>
<b>page = st.navigation([pages['login'], pages['signup']])</b>
<b>page.run()</b></pre>
   </div>
  </div>
  <div class="readable-text " id="p380"> 
   <p>The first new thing you'll notice here is the <kbd>pages</kbd> dictionary. The keys in <kbd>pages</kbd> are <kbd>"login"</kbd> and <kbd>"signup"</kbd>, which are the names of the pages we want in our app. The values are <kbd>st.Page</kbd> objects. Let's inspect the first one:</p>
  </div>
  <div class="browsable-container listing-container" id="p381"> 
   <div class="code-area-container"> 
    <pre class="code-area">st.Page("frontend/login.py", title="Log in", icon=":material/login:")</pre>
   </div>
  </div>
  <div class="readable-text " id="p382"> 
   <p><kbd>st.Page</kbd> is Streamlit's way of defining a single page in a multi-page app. The first argument you pass it is the path to the Python script for that page—in this case, <kbd>frontend/login.py</kbd>, which doesn't exist yet. We've also passed it a sensible title.</p>
  </div>
  <div class="readable-text  intended-text" id="p383"> 
   <p>The last argument is an icon for the page. It has a curious value: <kbd>:material/login:</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p384"> 
   <p>This demonstrates a neat way to display icons in Streamlit. The syntax <kbd>:material/&lt;icon_name&gt;:</kbd> is accepted by most widgets that accept displayable text, and is converted to an image when rendered to the screen.</p>
  </div>
  <div class="readable-text  intended-text" id="p385"> 
   <p>You can see the supported icons in Google's Material Symbols library at <kbd>https://fonts.google.com/icons?icon.set=Material+Symbols</kbd>. In this case, we've chosen the "Login" icon. Whenever you need to show an icon, you can go to that URL, click the icon you want, identify its icon name from the sidebar that opens to the right, and substitute it within the text <kbd>:material/&lt;icon_name&gt;:</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p386"> 
   <p>Now turn your focus to the following lines further below:</p>
  </div>
  <div class="browsable-container listing-container" id="p387"> 
   <div class="code-area-container"> 
    <pre class="code-area">page = st.navigation([pages['login'], pages['signup']])
page.run()</pre>
   </div>
  </div>
  <div class="readable-text " id="p388"> 
   <p>Here, we're feeding the two <kbd>st.Page</kbd> objects in the <kbd>pages</kbd> dictionary (<kbd>pages['login']</kbd> and <kbd>pages['signup']</kbd>) to <kbd>st.navigation</kbd>, a new Streamlit widget.</p>
  </div>
  <div class="readable-text  intended-text" id="p389"> 
   <p><kbd>st.navigation</kbd> is used to configure the available pages in a multi-page Streamlit app, displaying a navigation bar that users can use to select the page they want to go to.</p>
  </div>
  <div class="readable-text  intended-text" id="p390"> 
   <p>It accepts a list of <kbd>Page</kbd> objects that form the navigation options, and returns a single <kbd>Page</kbd> object from the list. This returned item is the page selected by the user, or the first item in the list if nothing has been selected yet.</p>
  </div>
  <div class="readable-text  intended-text" id="p391"> 
   <p>Once a page has been returned, it can be loaded using its <kbd>.run()</kbd> method.</p>
  </div>
  <div class="readable-text  intended-text" id="p392"> 
   <p>You'll also see that we're saving the <kbd>Hub</kbd> instance (<kbd>hub</kbd>) to <kbd>st.session_state</kbd>, but not doing anything else with it. This is because the session state is shared between the pages in a multi-page app. So if you save something to <kbd>st.session_state</kbd> in any page, it will be accessible in the other pages too. In this case, we're going to be using the saved <kbd>hub</kbd> object in the other pages.</p>
  </div>
  <div class="readable-text  intended-text" id="p393"> 
   <p>What about the signup flow we had earlier? Well, now that our app is multi-page, we'll move it to its own page, <kbd>signup.py</kbd>, within a new folder called <kbd>frontend</kbd>. As you'll see from listing 8.9, the content has mostly just been copied directly from our earlier <kbd>main.py</kbd> with no changes.</p>
  </div>
  <div class="browsable-container listing-container" id="p394"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 8.9 frontend/signup.py</h5>
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">import streamlit as st
 
<b>hub = st.session_state.hub</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
with st.container(border=True):
  st.title("Sign up")
  username = st.text_input("Username")
  password = st.text_input("Password", type="password")
  confirm_password = st.text_input("Confirm password", type="password")
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
  if st.button("Create account", type="primary"):
    if password != confirm_password:
      st.error("Passwords do not match")
    else:
      user = hub.user_service.create_user(username, password)
      if user:
        st.success("Account created successfully")
      else:
        st.error("Username already exists")</pre>
   </div>
  </div>
  <div class="readable-text " id="p395"> 
   <p>The only change we've made (as compared to listing 8.7) is that we obtain the value of the <kbd>hub</kbd> variable from <kbd>st.session_state</kbd> where we saved it in the new <kbd>main.py</kbd>.</p>
  </div>
  <div class="readable-text" id="p396"> 
   <h3 class=" readable-text-h3">8.4.2 Implementing login</h3>
  </div>
  <div class="readable-text " id="p397"> 
   <p>With our multi-page app infrastructure in place, it's time to build out the login feature. Before we set up the login page, let's make sure our backend has the functionality we need.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p398"> 
   <h4 class=" readable-text-h4">Authenticating a user in UserService</h4>
  </div>
  <div class="readable-text " id="p399"> 
   <p>As we've discussed, all user-related functionality needs to live in <kbd>UserService</kbd>. Currently, that class has <kbd>create_user</kbd> and <kbd>get_user</kbd> methods. We'll implement a new <kbd>get_authenticated_user</kbd> method:</p>
  </div>
  <div class="browsable-container listing-container" id="p400"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">from backend.user import User
 
class UserService:
  ...
 
  def get_user(self, username):
    ...
  
  ...
<b>  def get_authenticated_user(self, username, password):</b>
<b>    user = self.get_user(username)</b>
<b>    if user and user.authenticate(password):</b>
<b>        return user</b>
<b>    return None</b></pre>
   </div>
  </div>
  <div class="readable-text " id="p401"> 
   <p><kbd>get_authenticated_user</kbd> accepts a username and password as arguments. It first calls the <kbd>get_user</kbd> method we defined earlier to see if a user exists with that username. If there is, it calls the <kbd>authenticate</kbd> method on the returned <kbd>User</kbd> object. Recall that the <kbd>authenticate</kbd> method in the <kbd>User</kbd> class compares the hash of the given password with that of the actual password.</p>
  </div>
  <div class="readable-text  intended-text" id="p402"> 
   <p>If the authentication succeeds, the <kbd>User</kbd> object is returned. If it doesn't, the method returns <kbd>None</kbd>, which the calling code can interpret in two ways: either no such user exists or the password is incorrect. To keep things simple, we won't distinguish between these in the return value.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p403"> 
   <h4 class=" readable-text-h4">Creating the login page</h4>
  </div>
  <div class="readable-text " id="p404"> 
   <p>That's all we need in <kbd>UserService</kbd>. We can now go ahead and create a login page to complement the signup page we made earlier.</p>
  </div>
  <div class="readable-text  intended-text" id="p405"> 
   <p>Create a new file in <kbd>frontend/</kbd> called <kbd>login.py</kbd>, with the content shown in listing 8.10.</p>
  </div>
  <div class="browsable-container listing-container" id="p406"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 8.10 frontend/login.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
 
hub = st.session_state.hub
 
with st.container(border=True):
  st.title("Log in")
  username = st.text_input("Username", key="login_username")
  password = st.text_input("Password", type="password")
 
  if st.button("Log in", type="primary"):
    user = hub.user_service.get_authenticated_user(username, password)
    if user:
      st.session_state.logged_in = True
      st.session_state.user = user
      st.success("Logged in successfully")
    else:
      st.error("Invalid username or password")</pre>
   </div>
  </div>
  <div class="readable-text " id="p407"> 
   <p>This page is fairly similar to <kbd>signup.py</kbd>, and should be straightforward to follow with your current understanding of Streamlit.</p>
  </div>
  <div class="readable-text  intended-text" id="p408"> 
   <p>The part to focus on here is what happens when the "Log in" button is clicked. We first call the authentication method we defined in <kbd>UserService</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p409"> 
   <div class="code-area-container"> 
    <pre class="code-area">user = hub.user_service.get_authenticated_user(username, password)</pre>
   </div>
  </div>
  <div class="readable-text " id="p410"> 
   <p>As we saw, if the method returns a <kbd>User</kbd> object, authentication has succeeded; if it returns <kbd>None</kbd>, authentication has failed.</p>
  </div>
  <div class="readable-text  intended-text" id="p411"> 
   <p>We write this condition as if <kbd>user:</kbd>. For the actual logging in, we'll use a very simple approach—storing a boolean variable called <kbd>logged_in</kbd> under <kbd>st.session_state</kbd>, along with the <kbd>User</kbd> object for the logged-in user (named simply as <kbd>user</kbd>).</p>
  </div>
  <div class="readable-text  intended-text" id="p412"> 
   <p>We also display a success or error message depending on whether the login succeeds.</p>
  </div>
  <div class="readable-text  intended-text" id="p413"> 
   <p>At this point, you should re-run your app using <kbd>streamlit run main.py</kbd>. Try logging in with the account you created previously. You should see something similar to figure 8.8.</p>
  </div>
  <div class="browsable-container figure-container" id="p414">  
   <img src="../Images/ch08__image008.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 8.8 Haiku Haven's login page (see chapter_8/in_progress_03 in the GitHub repo for the full code)</h5>
  </div>
  <div class="readable-text " id="p415"> 
   <p>Note the navigation panel created by <kbd>st.navigation</kbd>, which takes up the sidebar and contains links to navigate to either page (along with the icons we added!).</p>
  </div>
  <div class="readable-text" id="p416"> 
   <h3 class=" readable-text-h3">8.4.3 Navigating between pages</h3>
  </div>
  <div class="readable-text " id="p417"> 
   <p>While we currently have the bare minimum that we need in a signup/login flow, there's definitely room for improvement. For instance, if the user is on the login page but doesn't have an account, there should be a helpful link right there to sign up, or vice versa.</p>
  </div>
  <div class="readable-text  intended-text" id="p418"> 
   <p>Also, when the user logs in, we should take them to some kind of logged-in page and give them the ability to log out.</p>
  </div>
  <div class="readable-text  intended-text" id="p419"> 
   <p>Figure 8.9 lays out the ideal signup/login/logout flow we want to design.</p>
  </div>
  <div class="browsable-container figure-container" id="p420">  
   <img src="../Images/ch08__image009.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 8.9 Diagram showing the connections between pages through redirection and page links</h5>
  </div>
  <div class="readable-text " id="p421"> 
   <p>Besides being able to go back and forth between the signup and login pages, and redirect to a home page when logged in, we also want the navigation panel to display different options based on if we're logged in or not.</p>
  </div>
  <div class="readable-text  intended-text" id="p422"> 
   <p>If the user is logged in, they should see the home page and have the ability to log out—which shows them the login page again. If they're not, they should instead see the options to sign up or log in.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p423"> 
   <h4 class=" readable-text-h4">Moving the pages dictionary to its own file</h4>
  </div>
  <div class="readable-text " id="p424"> 
   <p>Since we're now going to be navigating between individual pages, it would be cleaner to put the <kbd>pages</kbd> dictionary (the one in <kbd>main.py</kbd> that defines the available pages) in its own separate file, so let's move that part of the code to <kbd>frontend/pages.py</kbd>, shown in listing 8.11.</p>
  </div>
  <div class="browsable-container listing-container" id="p425"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 8.11 frontend/pages.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
 
pages = {
  "login": st.Page("frontend/login.py", title="Log in",
                   icon=":material/login:"),
  "signup": st.Page("frontend/signup.py", title="Sign up",
                    icon=":material/person_add:"),
  "home": st.Page("frontend/home.py", title="Home",
                  icon=":material/home:"),
  "logout": st.Page("frontend/logout.py", title="Log out",
                    icon=":material/logout:")
}</pre>
   </div>
  </div>
  <div class="readable-text " id="p426"> 
   <p>You'll notice that we've added two new pages: <kbd>home</kbd>, which is supposed to represent the logged-in home page, and <kbd>logout</kbd>, which will log the user out.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p427"> 
   <h4 class=" readable-text-h4">Links between pages</h4>
  </div>
  <div class="readable-text " id="p428"> 
   <p>Streamlit allows you to create links between pages in a multi-page app through a widget that is, appropriately enough, named <kbd>st.page_link</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p429"> 
   <p>Let's use this to link between the <kbd>login</kbd> and <kbd>signup</kbd> pages.</p>
  </div>
  <div class="readable-text  intended-text" id="p430"> 
   <p><kbd>login.py</kbd> should look like this, with the page link added to the very bottom:</p>
  </div>
  <div class="browsable-container listing-container" id="p431"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">import streamlit as st
<b>from frontend.pages import pages</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
...
with st.container(border=True):
    ...
    else:
      st.error("Invalid username or password")
      
<b>st.page_link(pages["signup"], label="Don't have an account? Sign up!")</b></pre>
   </div>
  </div>
  <div class="readable-text " id="p432"> 
   <p><kbd>st.page_link</kbd> is quite easy to understand; the first argument is the <kbd>st.Page</kbd> object (from <kbd>pages</kbd>, imported from <kbd>pages.py</kbd>) we want to link to, and the second is the label text.</p>
  </div>
  <div class="readable-text  intended-text" id="p433"> 
   <p>You can also pass a regular URL as the first argument, in case you want to link to an external page. <kbd>signup.py</kbd> has very similar changes:</p>
  </div>
  <div class="browsable-container listing-container" id="p434"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">import streamlit as st
<b>from frontend.pages import pages</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
...
with st.container(border=True):
    ...
    else:
      st.error("Invalid username or password")
      
<b>st.page_link(pages["signup"], label="Don't have an account? Sign up!")</b></pre>
   </div>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p435"> 
   <h4 class=" readable-text-h4">Dynamically changing st.navigation</h4>
  </div>
  <div class="readable-text " id="p436"> 
   <p>The next feature we'll implement is showing the user the right pages for their context in the navigation bar, i.e. <kbd>signup</kbd> and <kbd>login</kbd> when they're logged out, or <kbd>home</kbd> and <kbd>logout</kbd> when they're logged in.</p>
  </div>
  <div class="readable-text  intended-text" id="p437"> 
   <p>Edit <kbd>main.py</kbd> so it now looks like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p438"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">import streamlit as st
 
from backend.hub import Hub
<b>from frontend.pages import pages</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
if 'hub' not in st.session_state:
  config = st.secrets['config']
  st.session_state.hub = Hub(config)
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
<b>if 'logged_in' in st.session_state and st.session_state.logged_in:</b>
<b>  </b>page = st.navigation([pages['home'], pages['logout']])
<b>else:</b>
<b>  page = st.navigation([pages['login'], pages['signup']])</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;; mso-ansi-language:FR"></span>
page.run()</pre>
   </div>
  </div>
  <div class="readable-text " id="p439"> 
   <p>Obviously, the <kbd>pages</kbd> dictionary is now defined in <kbd>pages.py </kbd>and imported into <kbd>main.py</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p440"> 
   <p>As shown above, to dynamically change what's in the navigation panel, we use the <kbd>logged_in</kbd> session state variable that we save when the user logs in, and vary the <kbd>st.navigation</kbd> object that's assigned to <kbd>page</kbd> accordingly.</p>
  </div>
  <div class="readable-text  intended-text" id="p441"> 
   <p>If the user is logged in, the navigation bar will now show the <kbd>home</kbd> and <kbd>logout</kbd> options. Since <kbd>pages['home']</kbd> is the first item in the list passed to <kbd>st.navigation</kbd>, that's the page that will be loaded by default when the user logs in.</p>
  </div>
  <div class="readable-text  intended-text" id="p442"> 
   <p>Let's now actually set up a placeholder page in <kbd>frontend/home.py</kbd> (listing 8.12), so that there's something for a logged-in user to see.</p>
  </div>
  <div class="browsable-container listing-container" id="p443"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 8.12 frontend/home.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
 
user = st.session_state.user
st.title(f"Welcome, {user.username}!")</pre>
   </div>
  </div>
  <div class="readable-text " id="p444"> 
   <p>Nothing earth-shattering here for now; we just display a greeting that includes the logged-in user's username. Recall that we save the logged-in <kbd>User</kbd> object in <kbd>st.session_state.user</kbd> in <kbd>login.py</kbd>.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p445"> 
   <h4 class=" readable-text-h4">Automatic redirection for login and logout</h4>
  </div>
  <div class="readable-text " id="p446"> 
   <p>Our proposed ideal login flow requires the user to be redirected automatically on login and logout. How does this work exactly?</p>
  </div>
  <div class="readable-text  intended-text" id="p447"> 
   <p>Remember that when a user clicks the "Log in" button, the <kbd>logged_in</kbd> session state variable is set to <kbd>True</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p448"> 
   <p>This means that in the next re-run, <kbd>main.py</kbd> will pick up the changed value of <kbd>logged_in</kbd>, display the new navigation panel and load <kbd>home.py</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p449"> 
   <p>To make this truly seamless, we have to trigger the re-run though. So add an <kbd>st.rerun()</kbd> to <kbd>login.py</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p450"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">user = hub.user_service.get_authenticated_user(username, password)
    if user:
      st.session_state.logged_in = True
      st.session_state.user = user
      <b>st.rerun()</b></pre>
   </div>
  </div>
  <div class="readable-text " id="p451"> 
   <p>And logging out? Well, that's going to reverse everything that happens at login. Create a <kbd>logout.py</kbd> with content shown in listing 8.13.</p>
  </div>
  <div class="browsable-container listing-container" id="p452"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 8.13 frontend/logout.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
 
st.session_state.user = None
st.session_state.logged_in = False
st.rerun()</pre>
   </div>
  </div>
  <div class="readable-text " id="p453"> 
   <p>That completes our signup/login/logout flow! Re-run the app and try it all out! When you log in, you should now see a different navigation panel and the loaded home page (see figure 8.10).</p>
  </div>
  <div class="browsable-container figure-container" id="p454">  
   <img src="../Images/ch08__image010.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 8.10 The logged-in page with different options in the navigation bar (see chapter_8/in_progress_04 in the GitHub repo for the full code)</h5>
  </div>
  <div class="readable-text " id="p455"> 
   <p>Clicking "Log out" in the navigation bar will load the login and signup pages again, which have page links to each other at the bottom.</p>
  </div>
  <div class="readable-text" id="p456"> 
   <h2 class=" readable-text-h2">8.5 Creating, reading, updating, and deleting haikus</h2>
  </div>
  <div class="readable-text " id="p457"> 
   <p>Now that user authentication is taken care of, it's finally time to work on the crux of our app: the ability to create, read, update and delete haikus. We'll start with haiku creation, encapsulating this behavior in a <kbd>HaikuService</kbd> class, and then making the appropriate changes to the frontend.</p>
  </div>
  <div class="readable-text" id="p458"> 
   <h3 class=" readable-text-h3">8.5.1 Defining a HaikuService class</h3>
  </div>
  <div class="readable-text " id="p459"> 
   <p>The code structure we'll follow in the haiku service is pretty analogous to what we already have in <kbd>UserService</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p460"> 
   <p>Let's begin with a <kbd>Haiku</kbd> dataclass to represent a haiku. Create this as <kbd>haiku.py</kbd> in the <kbd>backend/</kbd> folder (listing 8.14).</p>
  </div>
  <div class="browsable-container listing-container" id="p461"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 8.14 backend/haiku.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">from dataclasses import dataclass
 
@dataclass
class Haiku:
  haiku_id: int
  created_at: str
  author: str
  text: str</pre>
   </div>
  </div>
  <div class="readable-text " id="p462"> 
   <p>As in the <kbd>User</kbd> class, the fields mirror those in our corresponding database table (<kbd>haikus</kbd>).</p>
  </div>
  <div class="readable-text  intended-text" id="p463"> 
   <p><kbd>HaikuService</kbd> itself is shown in listing 8.15.</p>
  </div>
  <div class="browsable-container listing-container" id="p464"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 8.15 backend/haiku_service.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">from backend.haiku import Haiku
 
class HaikuService:
  def __init__(self, database):
    self.database = database
 
  def create_haiku(self, author, haiku_text):
    query = '''
      INSERT INTO haikus (author, text)
      VALUES (%s, %s)
      RETURNING haiku_id, created_at, author, text
    '''
    params = (author, haiku_text)
    results = self.database.execute_query(query, params)
    return Haiku(*results[0]) if results else None</pre>
   </div>
  </div>
  <div class="readable-text " id="p465"> 
   <p>Again, the code is fairly analogous to that of <kbd>UserService</kbd>, so a detailed explanation isn't warranted.</p>
  </div>
  <div class="readable-text  intended-text" id="p466"> 
   <p>As we've seen, we only need to supply the <kbd>author</kbd> and <kbd>text</kbd> fields in our SQL query; the database automatically provides <kbd>haiku_id</kbd> and <kbd>created_at</kbd>, and all of the fields are returned as per the <kbd>RETURNING</kbd> clause.</p>
  </div>
  <div class="readable-text  intended-text" id="p467"> 
   <p>To wrap up the backend changes, let's add an instance of <kbd>HaikuService</kbd> to <kbd>hub.py</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p468"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">...
<b>from backend.haiku_service import HaikuService</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
class Hub:
  def __init__(self, config):
    database = Database(config['connection_string'])
    self.user_service = UserService(database)
    <b>self.haiku_service = HaikuService(database)</b></pre>
   </div>
  </div>
  <div class="readable-text " id="p469"> 
   <p>This will enable the haiku creation function to be accessed from the frontend, as we'll see presently.</p>
  </div>
  <div class="readable-text" id="p470"> 
   <h3 class=" readable-text-h3">8.5.2 Enabling users to create haikus</h3>
  </div>
  <div class="readable-text " id="p471"> 
   <p>Our earlier <kbd>home.py</kbd> was, of course, just a placeholder. Our actual logged-in home page should ideally have a way to create haikus and display them.</p>
  </div>
  <div class="readable-text  intended-text" id="p472"> 
   <p>For creating haikus, let's create a modal dialog similar to the one we created in Chapter 7.</p>
  </div>
  <div class="readable-text  intended-text" id="p473"> 
   <p>Create a new file, <kbd>frontend/haiku_editor.py</kbd> as shown in listing 8.16.</p>
  </div>
  <div class="browsable-container listing-container" id="p474"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 8.16 frontend/haiku_editor.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
 
@st.dialog("Haiku editor", width="large")
def haiku_editor(hub, user):
  haiku_text = st.text_area('Enter a haiku')
  if st.button('Save haiku', type='primary'):
    haiku = hub.haiku_service.create_haiku(user.username, haiku_text)
    if haiku:
      st.success('Haiku saved successfully!')
    else:
      st.error('Failed to save haiku')</pre>
   </div>
  </div>
  <div class="readable-text " id="p475"> 
   <p>The <kbd>haiku_editor</kbd> function is decorated with <kbd>st.dialog</kbd>—which, as we saw in this previous chapter, executes its body in a modal screen.</p>
  </div>
  <div class="readable-text  intended-text" id="p476"> 
   <p>The body of <kbd>haiku_editor</kbd> is uncomplicated. We first accept the haiku text entered by the user in an <kbd>st.text_area</kbd> widget:</p>
  </div>
  <div class="browsable-container listing-container" id="p477"> 
   <div class="code-area-container"> 
    <pre class="code-area">haiku_text = st.text_area('Enter a haiku')</pre>
   </div>
  </div>
  <div class="readable-text " id="p478"> 
   <p><kbd>st.text_area</kbd> is precisely what you'd expect it to be—an area for entering several lines of text.</p>
  </div>
  <div class="readable-text  intended-text" id="p479"> 
   <p>On clicking "Save haiku", we call the <kbd>create_haiku</kbd> method under <kbd>HaikuService</kbd> to save it to the database, and show the appropriate success/failure message.</p>
  </div>
  <div class="readable-text  intended-text" id="p480"> 
   <p>Close the loop by including—in <kbd>home.py</kbd>—an "Add Haiku" button that triggers the <kbd>haiku_editor</kbd> dialog we just defined:</p>
  </div>
  <div class="browsable-container listing-container" id="p481"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">import streamlit as st
<b>from frontend.haiku_editor import haiku_editor</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
<b>hub = st.session_state.hub</b>
user = st.session_state.user
st.title(f"Welcome, {user.username}!")
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
<b>if st.button(':material/add_circle: Haiku', type='primary'):</b>
<b>    haiku_editor(hub, user)</b></pre>
   </div>
  </div>
  <div class="readable-text " id="p482"> 
   <p>As you can see, we're using a Material icon again, this time in the place of the word "Add" within the button label.</p>
  </div>
  <div class="readable-text  intended-text" id="p483"> 
   <p>Let's see everything working so far! Re-run your Streamlit app, login, and add a haiku (see figure 8.11).</p>
  </div>
  <div class="browsable-container figure-container" id="p484">  
   <img src="../Images/ch08__image011.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 8.11 Creating a haiku (see chapter_8/in_progress_05 in the GitHub repo for the full code)</h5>
  </div>
  <div class="readable-text " id="p485"> 
   <p>To convince yourself that a haiku has indeed been created, you can query your <kbd>haikus</kbd> table.</p>
  </div>
  <div class="readable-text" id="p486"> 
   <h3 class=" readable-text-h3">8.5.3 The other CRUD operations: Read, Update, Delete</h3>
  </div>
  <div class="readable-text " id="p487"> 
   <p>To make our CRUD app feature complete, there are three more operations we need to implement:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p488"><em>Reading </em>the current users' haikus from the database and list them in the app</li>
   <li class="readable-text" id="p489"><em>Updating</em> a given haiku</li>
   <li class="readable-text" id="p490"><em>Deleting</em> a haiku altogether</li>
  </ul>
  <div class="readable-text sub-sub-section-heading" id="p491"> 
   <h4 class=" readable-text-h4">Defining the operations in HaikuService</h4>
  </div>
  <div class="readable-text " id="p492"> 
   <p>As before, let's define these operations in the backend first, by editing the <kbd>HaikuService</kbd> class in <kbd>haiku_service.py</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p493"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">from backend.haiku import Haiku
 
class HaikuService:
  ...
  def create_haiku(self, author, haiku_text):
    ...
 
  <b>def get_haikus_by_author(self, author):</b>
<b>    query = 'SELECT * FROM haikus WHERE author = %s'</b>
<b>    params = (author,)</b>
<b>    results = self.database.execute_query(query, params)</b>
<b>    return [Haiku(*row) for row in results]</b>
<b></b>
<b>  def update_haiku(self, haiku_id, haiku_text):</b>
<b>    query = 'UPDATE haikus SET text = %s WHERE haiku_id = %s RETURNING *'</b>
<b>    params = (haiku_text, haiku_id)</b>
<b>    results = self.database.execute_query(query, params)</b>
<b>    return Haiku(*results[0]) if results else None</b>
<b></b>
<b>  def delete_haiku(self, haiku_id):</b>
<b>    query = 'DELETE FROM haikus WHERE haiku_id = %s RETURNING *'</b>
<b>    params = (haiku_id,)</b>
<b>    results = self.database.execute_query(query, params)</b>
<b>    return Haiku(*results[0]) if results else None</b><span style="mso-fareast-font-family:&quot;Roboto Mono&quot;;mso-bidi-font-family: &quot;Times New Roman&quot;;layout-grid-mode:both"></span></pre>
   </div>
  </div>
  <div class="readable-text " id="p494"> 
   <p>We define one method for each operation: <kbd>get_haikus_by_author</kbd> for reading haikus, <kbd>update_haiku</kbd> for updating, and <kbd>delete_haiku</kbd> for deleting a haiku.</p>
  </div>
  <div class="readable-text  intended-text" id="p495"> 
   <p>In each case, we use the same pattern we've seen before—we run a SQL command, convert the results into Haiku objects, and return them.</p>
  </div>
  <div class="readable-text  intended-text" id="p496"> 
   <p>In the case of <kbd>get_haikus_by_author</kbd>, we return the results as a <em>list</em> of Haiku objects given that there may be more than one by a certain author.</p>
  </div>
  <div class="readable-text  intended-text" id="p497"> 
   <p>In both <kbd>update_haiku</kbd> and <kbd>delete_haiku</kbd>, we accept <kbd>haiku_id</kbd>—the unique identifier of a haiku—as an argument, using <kbd>UPDATE..SET</kbd> and <kbd>DELETE FROM</kbd> SQL commands respectively to achieve the desired result.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p498"> 
   <h4 class=" readable-text-h4">Creating the UI</h4>
  </div>
  <div class="readable-text " id="p499"> 
   <p>Our backend methods return instances of the <kbd>Haiku</kbd> class, but how do we display these in the frontend?</p>
  </div>
  <div class="readable-text  intended-text" id="p500"> 
   <p>We should probably create a <kbd>display_haiku</kbd> function that accepts a <kbd>Haiku</kbd> object and displays it on the screen. The next natural question is: what do we display? What is the user likely to be interested in seeing?</p>
  </div>
  <div class="readable-text  intended-text" id="p501"> 
   <p>The <kbd>Haiku</kbd> class has four attributes: <kbd>haiku_id</kbd>, <kbd>created_at</kbd>, <kbd>author</kbd>, and <kbd>text</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p502"> 
   <p>Of these, <kbd>haiku_id</kbd> is an internal identifier that would be of no meaning to the end user, so we can exclude that. <kbd>created_at</kbd> might be useful to jog the user's memory of when a haiku was originally created. It would be redundant to show the <kbd>author</kbd> field since we're only going to be displaying haikus by the current logged-in user. And <kbd>text</kbd> is the content of the haiku, so we obviously want to display that.</p>
  </div>
  <div class="readable-text  intended-text" id="p503"> 
   <p>That gives us: <kbd>created_at</kbd> and <kbd>text</kbd>. Anything else? Well, we also want to give the user the option to edit or delete a particular haiku, so let's pop in a couple of buttons as well.</p>
  </div>
  <div class="browsable-container listing-container" id="p504"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 8.17 frontend/haiku_display.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
 
hub = st.session_state.hub
user = st.session_state.user
 
def get_haiku_created_display(haiku):
  day = haiku.created_at.strftime('%Y-%m-%d')
  time = haiku.created_at.strftime('%H:%M')
  return f':gray[:material/calendar_month: {day}  \n :material/schedule: {time}]'
 
def get_haiku_text_display(haiku):
  display_text = haiku.text.replace('\n', '  \n')
  return f':green[{display_text}]'
 
def edit_button(haiku):
  if st.button(':material/edit:', key=f"edit_{haiku.haiku_id}"):
    pass
 
def delete_button(haiku):
  if st.button(':material/delete:', key=f"delete_{haiku.haiku_id}"):
    pass
 
def display_haiku(haiku):
  with st.container(border=True):
    cols = st.columns([2, 5, 1, 1])
    created_col, text_col, edit_col, delete_col = cols
 
    created_col.markdown(get_haiku_created_display(haiku))
    text_col.markdown(get_haiku_text_display(haiku))
    with edit_col:
      edit_button(haiku)
    with delete_col:
      delete_button(haiku)</pre>
   </div>
  </div>
  <div class="readable-text " id="p505"> 
   <p>The key function to focus on here is the last one: <kbd>display_haiku</kbd>. Given <kbd>haiku</kbd>, an instance of the <kbd>Haiku</kbd> class, it makes four columns for the four things we want to display: <kbd>created_at</kbd>, <kbd>text</kbd>, the edit button, and the delete button.</p>
  </div>
  <div class="readable-text  intended-text" id="p506"> 
   <p>The actual rendering of each of these takes place in its own function.</p>
  </div>
  <div class="readable-text  intended-text" id="p507"> 
   <p><kbd>get_haiku_created_display</kbd> takes haiku's <kbd>created_at</kbd> property—a timestamp— and breaks it down into a day and a time using a method called <kbd>strftime</kbd>, which is used to format a timestamp in any given format based on a <em>format string</em>. In this case, <kbd>%Y-%m-%d</kbd> formats it as just a date, whereas <kbd>%H:%M</kbd> extracts the time in hours and minutes.</p>
  </div>
  <div class="browsable-container listing-container" id="p508"> 
   <div class="code-area-container"> 
    <pre class="code-area">f':gray[:material/calendar_month: {day}  \n :material/schedule: {time}]'</pre>
   </div>
  </div>
  <div class="readable-text " id="p509"> 
   <p>There are a few things going on here. The <kbd>:&lt;color&gt;[&lt;text&gt;]</kbd> syntax is used in Streamlit to display text in various colors. For instance, the string <kbd>:red[Hello]</kbd> would be interpreted by widgets like <kbd>st.write</kbd> or <kbd>st.markdown</kbd> as the word <kbd>Hello</kbd> in red text.</p>
  </div>
  <div class="readable-text  intended-text" id="p510"> 
   <p>We also see the icon syntax we saw earlier. Here we're using a calendar icon for the date and a clock icon (<kbd>schedule</kbd>) for the time, creating a user-friendly display for the date and time.</p>
  </div>
  <div class="readable-text  intended-text" id="p511"> 
   <p><kbd>get_haiku_text_display</kbd> is meant to display the content of the haiku. Why do we have the following replace method? Why not just display the content directly?</p>
  </div>
  <div class="browsable-container listing-container" id="p512"> 
   <div class="code-area-container"> 
    <pre class="code-area">haiku.text.replace('\n', '  \n')</pre>
   </div>
  </div>
  <div class="readable-text " id="p513"> 
   <p>This is something of a workaround. Streamlit handles line breaks in text rather strangely. To get text widgets like <kbd>st.markdown</kbd> to display the newline character <kbd>\n</kbd> properly, we have to precede it with two spaces, i.e. <kbd>' \n'</kbd> instead of just <kbd>'\n'</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p514"> 
   <p>The <kbd>edit_button</kbd> and <kbd>delete_button</kbd> functions simply display <kbd>st.button</kbd> widgets. You'll notice that we use icons as their labels, and give them widget keys—which is required for Streamlit to distinguish between them when we have many haikus displayed on a page. We've given them placeholder bodies with <kbd>pass</kbd> for now; we'll come back to them later.</p>
  </div>
  <div class="readable-text  intended-text" id="p515"> 
   <p>Since we're using icons so much throughout the app, our code would actually be a lot more readable if we gave them better names (e.g. <kbd>CLOCK</kbd> instead of <kbd>:material/schedule:</kbd>) and put them in a more central location.</p>
  </div>
  <div class="readable-text  intended-text" id="p516"> 
   <p>Let's put all the icons in their own file, <kbd>frontend/icons.py</kbd> (listing 8.18) and <em>import</em> them instead.</p>
  </div>
  <div class="browsable-container listing-container" id="p517"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 8.18 frontend/icons.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">LOGIN = ":material/login:"
SIGNUP = ":material/person_add:"
HOME = ":material/home:"
LOGOUT = ":material/logout:"
ADD = ":material/add_circle:"
CALENDAR = ":material/calendar_month:"
CLOCK = ":material/schedule:"
EDIT = ":material/edit:"
DELETE = ":material/delete:"</pre>
   </div>
  </div>
  <div class="readable-text " id="p518"> 
   <p>We can now change <kbd>haiku_display.py</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p519"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">import streamlit as st
<b>from frontend.icons import CALENDAR, CLOCK, EDIT, DELETE</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
...
def get_haiku_created_display(haiku):
  ...
  <b>return f':gray[{CALENDAR} {day}  \n {CLOCK} {time}]'</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
...
def edit_button(haiku):
  <b>if st.button(f'{EDIT}', key=f"edit_{haiku.haiku_id}"):</b>
    pass
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
def delete_button(haiku):
  <b>if st.button(f'{DELETE}', key=f"delete_{haiku.haiku_id}"):</b>
    pass
...</pre>
   </div>
  </div>
  <div class="readable-text " id="p520"> 
   <p>There—that's much more readable! Let's now call <kbd>display_haiku</kbd> to show the user their list of created haikus! We'll edit <kbd>home.py</kbd> to do this:</p>
  </div>
  <div class="browsable-container listing-container" id="p521"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">import streamlit as st
from frontend.haiku_editor import haiku_editor
<b>from frontend.haiku_display import display_haiku</b>
<b>from frontend.icons import ADD</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
...
<b>if st.button(f'{ADD} Haiku', type='primary'):</b>
  haiku_editor(hub, user)
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
<b>haikus = hub.haiku_service.get_haikus_by_author(user.username)</b>
<b>if len(haikus) == 0:</b>
<b>  st.info("You haven't written any haikus yet.")</b>
<b>else:</b>
<b>  for haiku in haikus:</b>
<b>    display_haiku(haiku)</b></pre>
   </div>
  </div>
  <div class="readable-text " id="p522"> 
   <p>The changes here are quite simple. After the add button we created earlier—which we've now changed to use an icon imported from <kbd>icons.py</kbd>—we display a header that says <kbd>&lt;username&gt;'s haikus</kbd> along with a divider (just a horizontal line underneath, controlled by <kbd>divider="gray"</kbd>).</p>
  </div>
  <div class="readable-text  intended-text" id="p523"> 
   <p>We then call the <kbd>get_haikus_by_author</kbd> method we defined in <kbd>HaikuService</kbd>, and loop through the results, calling <kbd>display_haiku</kbd> on each. If there are no haikus, we display an <kbd>st.info</kbd> message that says so.</p>
  </div>
  <div class="readable-text  intended-text" id="p524"> 
   <p>Re-run your app now to see the changes in figure 8.12 (after adding one more haiku)!</p>
  </div>
  <div class="browsable-container figure-container" id="p525">  
   <img src="../Images/ch08__image012.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 8.12 Listing created haikus (see chapter_8/in_progress_07 in the GitHub repo for the full code)</h5>
  </div>
  <div class="readable-text " id="p526"> 
   <p>Note that there's one more place we've been using icons: <kbd>pages.py</kbd>, where we've defined the pages for the multi-page app. Go ahead and update that file too:</p>
  </div>
  <div class="browsable-container listing-container" id="p527"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">import streamlit as st
<b>from frontend.icons import LOGIN, LOGOUT, SIGNUP, HOME</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
pages = {
  "login": st.Page("frontend/login.py", title="Log in", icon=<b>LOGIN</b>),
  "signup": st.Page("frontend/signup.py", title="Sign up", icon=<b>SIGNUP</b>),
  "home": st.Page("frontend/home.py", title="Home", icon=<b>HOME</b>),
  "logout": st.Page("frontend/logout.py", title="Log out", icon=<b>LOGOUT</b>)
}</pre>
   </div>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p528"> 
   <h4 class=" readable-text-h4">Adding the update and delete functionality</h4>
  </div>
  <div class="readable-text " id="p529"> 
   <p>Let's get back to the edit and delete buttons, which currently have placeholders under them. The edit button should let a user edit one of their existing haikus. We can repurpose the haiku editor dialog we've already created to work with the "Add Haiku" button for this:</p>
  </div>
  <div class="browsable-container listing-container" id="p530"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">import streamlit as st
 
@st.dialog("Haiku editor", width="large")
def haiku_editor(hub, user, <b>haiku=None</b>):
  <b>default_text = haiku.text if haiku else ''</b>
  haiku_text = st.text_area('Enter a haiku', <b>value=default_text</b>)
  if st.button('Save haiku', type='primary'):
    <b>if haiku:</b>
<b>      new_haiku = hub.haiku_service.update_haiku(haiku.haiku_id, haiku_text)</b>
<b>    else:</b>
<b>      new_haiku = hub.haiku_service.create_haiku(user.username, haiku_text)</b>
    if new_haiku:
      st.success('Haiku saved successfully!')
      <b>st.rerun()</b>
    else:
      st.error('Failed to save haiku')</pre>
   </div>
  </div>
  <div class="readable-text " id="p531"> 
   <p>The <kbd>haiku_editor</kbd> function now accepts a <kbd>haiku</kbd> argument which is <kbd>None</kbd> by default. If we're calling the editor to edit an existing haiku, we can pass the corresponding <kbd>Haiku</kbd> instance to <kbd>haiku</kbd>. Otherwise we're calling the dialog to add a haiku, so we pass <kbd>None</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p532"> 
   <p>In the rest of the function, we'll use the condition <kbd>if haiku</kbd> to check if we're performing the edit action or the add action.</p>
  </div>
  <div class="readable-text  intended-text" id="p533"> 
   <p>In the next two lines, we pre-populate the existing haiku's text in the text area as a default value using the <kbd>value</kbd> parameter of <kbd>st.text_area</kbd> if we're in the edit action.</p>
  </div>
  <div class="browsable-container listing-container" id="p534"> 
   <div class="code-area-container"> 
    <pre class="code-area">default_text = haiku.text if haiku else ''
haiku_text = st.text_area('Enter a haiku', value=default_text)</pre>
   </div>
  </div>
  <div class="readable-text " id="p535"> 
   <p>Then, once the save button is clicked, we pick either the <kbd>update_haiku</kbd> or the <kbd>create_haiku</kbd> method from <kbd>HaikuService</kbd> to execute. In the former case, we pass the existing haiku's <kbd>haiku_id</kbd> to identify the haiku we want to edit.</p>
  </div>
  <div class="readable-text  intended-text" id="p536"> 
   <p>If the operation is successful—which we determine by checking the return value, <kbd>new_haiku</kbd>—we issue an <kbd>st.rerun()</kbd>. This re-runs the entire app, closing the dialog in the process, because the button that triggered it in the first place is now in the "unclicked" state.</p>
  </div>
  <div class="readable-text  intended-text" id="p537"> 
   <p>We can now replace the placeholder under the edit button in <kbd>haiku_display.py</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p538"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">def edit_button(haiku):
  if st.button(f'{EDIT}', key=f"edit_{haiku.haiku_id}"):
    <b>haiku_editor(app, user, haiku)</b></pre>
   </div>
  </div>
  <div class="readable-text " id="p539"> 
   <p>In the same page, let's also make the delete button trigger a deletion:</p>
  </div>
  <div class="browsable-container listing-container" id="p540"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">def delete_button(haiku):
  if st.button(f'{DELETE}', key=f"delete_{haiku.haiku_id}"):
    <b>deleted_haiku = app.haiku_service.delete_haiku(haiku.haiku_id)</b>
<b>    if deleted_haiku:</b>
<b>      st.rerun()</b>
<b>    else:</b>
<b>      st.error("Failed to delete haiku.")</b></pre>
   </div>
  </div>
  <div class="readable-text " id="p541"> 
   <p>Here we call the <kbd>delete_haiku</kbd> method in <kbd>HaikuService</kbd>. If the deletion is successful, we perform an <kbd>st.rerun()</kbd> so that the list of haikus can update and no longer show the deleted haiku. If the deletion fails for any reason, we show an error.</p>
  </div>
  <div class="readable-text  intended-text" id="p542"> 
   <p>Re-run the app now and try editing or deleting a haiku (figure 8.13)!</p>
  </div>
  <div class="browsable-container figure-container" id="p543">  
   <img src="../Images/ch08__image013.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 8.13 Deleting a haiku (see chapter_8/in_progress_08 in the GitHub repo for the full code)</h5>
  </div>
  <div class="readable-text " id="p544"> 
   <p>Haiku Haven has now been fully built—or at least we have a version that's fit to deploy to production. Before we do that though, there are a couple of final issues we need to address.</p>
  </div>
  <div class="readable-text" id="p545"> 
   <h2 class=" readable-text-h2">8.6 Multi-user considerations</h2>
  </div>
  <div class="readable-text " id="p546"> 
   <p>While Haiku Haven can be used by many users simultaneously, we need to be able to share resources efficiently between these users. The main resource that we're responsible for managing here is the database.</p>
  </div>
  <div class="readable-text" id="p547"> 
   <h3 class=" readable-text-h3">8.6.1 Using st.cache_resource to share the database connection pool</h3>
  </div>
  <div class="readable-text " id="p548"> 
   <p>Let's consider how a Streamlit app works when there are multiple users accessing it simultaneously. While there's a single Streamlit server that serves the app, each time a user accesses it, a new instance of the app is created, with all of the objects required to run the app created anew for that user.</p>
  </div>
  <div class="readable-text  intended-text" id="p549"> 
   <p>Most of the time, this is what we want; it makes sure different user sessions don't interfere with each other. However, there are some things we <em>don't </em>want to create anew each time someone loads the app in a new browser tab.</p>
  </div>
  <div class="readable-text  intended-text" id="p550"> 
   <p>A key example is the database connection pool we create in the <kbd>Database</kbd> class. In fact, the whole point of having a database connection pool is that when multiple user sessions need to access the database, they can do so by requesting connections from a <em>shared</em> pool, returning them when they're done.</p>
  </div>
  <div class="readable-text  intended-text" id="p551"> 
   <p>This means that there should only be <em>one </em>instance of the <kbd>Database</kbd> class ever created, to be shared across all users. However, we haven't set it up that way. Right now, <em>whenever </em>a new user loads the app—or a user loads the app in a new browser tab—a new session begins, and a new instance of the <kbd>Hub</kbd> class is created, which means a new <kbd>Database</kbd> instance is also created.</p>
  </div>
  <div class="readable-text  intended-text" id="p552"> 
   <p>Fortunately, Streamlit offers a solution for this: <kbd>st.cache_resource</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p553"> 
   <p>Like <kbd>st.cache_data</kbd>—which we used in Chapter 6 to make loading the data in our metric dashboard faster—<kbd>st.cache_resource</kbd> is a way to make sure that only one instance of something exists across all users of an app.</p>
  </div>
  <div class="readable-text  intended-text" id="p554"> 
   <p>While <kbd>st.cache_data</kbd> is used for caching things like Pandas dataframes or the results of API calls, <kbd>st.cache_resource</kbd> is used for resources like database connections. In this case, we'll use it to store the single instance we want to create of the <kbd>Database</kbd> class.</p>
  </div>
  <div class="readable-text  intended-text" id="p555"> 
   <p>This requires refactoring our app a little. Recall that currently (in <kbd>hub.py</kbd>) our <kbd>Hub</kbd> class accepts a <kbd>config</kbd> object and creates the <kbd>Database</kbd> instance itself:</p>
  </div>
  <div class="browsable-container listing-container" id="p556"> 
   <div class="code-area-container"> 
    <pre class="code-area">...
class Hub:
  def __init__(self, config):
    database = Database(config['connection_string'])
    self.user_service = UserService(database)
    self.haiku_service = HaikuService(database)</pre>
   </div>
  </div>
  <div class="readable-text " id="p557"> 
   <p>But in our new scheme, the <kbd>Hub</kbd> class will continue to have a new instance created for every session, which means a new <kbd>Database</kbd> instance will <em>also</em> keep getting created. Instead, we'll have <kbd>Hub</kbd>'s <kbd>__init__</kbd> accept an <em>already-created </em><kbd>Database</kbd> instance that it can simply pass to <kbd>UserService</kbd> and <kbd>HaikuService</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p558"> 
   <p>That way, we can always pass the <em>same </em>instance of the <kbd>Database</kbd> class, avoiding creating it every time. <kbd>hub.py</kbd> will now look like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p559"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">...
class Hub:
  def __init__(self, <b>database</b>):
    self.user_service = UserService(database)
    self.haiku_service = HaikuService(database)</pre>
   </div>
  </div>
  <div class="readable-text " id="p560"> 
   <p>Where do we create the <kbd>Database</kbd> instance then? In <kbd>main.py</kbd>, which is where we'll use <kbd>st.cache_resource</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p561"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">...
<b>from backend.database import Database</b>
from frontend.pages import pages
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
<b>@st.cache_resource</b>
<b>def get_database():</b>
<b>  connection_string = st.secrets['config']['connection_string']</b>
<b>  database = Database(connection_string)</b>
<b>  return database</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
if 'hub' not in st.session_state:
  st.session_state.hub = Hub(<b>get_database()</b>)
...</pre>
   </div>
  </div>
  <div class="readable-text " id="p562"> 
   <p>As is the case with <kbd>st.cache_data</kbd>, <kbd>st.cache_resource</kbd> is a decorator that's applied to a function. Here we define a new function to decorate called <kbd>get_database</kbd> which will return the cached <kbd>Database</kbd> object.</p>
  </div>
  <div class="readable-text  intended-text" id="p563"> 
   <p><kbd>get_database</kbd> will now run only once for a particular Streamlit server that's started up, i.e. a single <kbd>streamlit run</kbd> command—when <kbd>main.py</kbd> is loaded for the first time. For all subsequent runs, <kbd>get_database</kbd> will return the cached <kbd>Database</kbd> instance, thereby making sure only one such instance is ever created. This cached instance will persist until the server process is terminated.</p>
  </div>
  <div class="readable-text" id="p564"> 
   <h3 class=" readable-text-h3">8.6.2 Using atexit to clean up database connections</h3>
  </div>
  <div class="readable-text " id="p565"> 
   <p>We've made sure that a <kbd>Database</kbd> instance is only created once per running instance of a Streamlit app server. That's one part of managing our database resource efficiently. The other is safely cleaning up any connections we create.</p>
  </div>
  <div class="readable-text  intended-text" id="p566"> 
   <p>Our <kbd>Database</kbd> class has a <kbd>close_all</kbd> method:</p>
  </div>
  <div class="browsable-container listing-container" id="p567"> 
   <div class="code-area-container"> 
    <pre class="code-area">def close_all(self):
  print("Closing all connections...")
  self.connection_pool.closeall()</pre>
   </div>
  </div>
  <div class="readable-text " id="p568"> 
   <p>If you inspect our code so far, however, we're not actually calling this method anywhere.</p>
  </div>
  <div class="readable-text  intended-text" id="p569"> 
   <p>To clean up our connections correctly, we want this method to be called only once, when the Streamlit server is terminated. How do we accomplish this?</p>
  </div>
  <div class="readable-text  intended-text" id="p570"> 
   <p>The solution is the <kbd>atexit</kbd> module, which comes built-in with Python. <kbd>atexit</kbd> lets you register functions to be executed automatically when the Python interpreter is about to exit.</p>
  </div>
  <div class="readable-text  intended-text" id="p571"> 
   <p>Here's how we would modify <kbd>main.py</kbd> to register a function that cleans up our database connections using <kbd>atexit</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p572"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">import streamlit as st
<b>import atexit</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
...
@st.cache_resource
def get_database():
  connection_string = st.secrets['config']['connection_string']
  database = Database(connection_string)
  <b>atexit.register(lambda db: db.close_all(), database)</b>
  return database
...</pre>
   </div>
  </div>
  <div class="readable-text " id="p573"> 
   <p><kbd>atexit.register</kbd> accepts a function to register, along with the values of any parameters we want to pass to the function. In the above code, the function we're registering is a one-line lambda function: <kbd>lambda db: db.close_all()</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p574"> 
   <p>It accepts one parameter—<kbd>db</kbd>, which is the database instance. All the function does is to invoke <kbd>db</kbd>'s <kbd>close_all</kbd> method. The second parameter we pass to <kbd>atexit.register</kbd> is <kbd>database</kbd>, which is the <kbd>Database</kbd> instance created in the line above.</p>
  </div>
  <div class="readable-text  intended-text" id="p575"> 
   <p>Calling <kbd>atexit.register</kbd> "schedules" a function to be executed when Python itself exits, which, in the case of <kbd>streamlit run</kbd>, happens when the Streamlit server shuts down.</p>
  </div>
  <div class="readable-text  intended-text" id="p576"> 
   <p>Why do we put the call to <kbd>atexit.register</kbd> within <kbd>get_database</kbd>? Why not put it somewhere else, perhaps at the end of the file? Well, like the creation of a <kbd>Database</kbd> object, we only want to perform the registration of the function with <kbd>atexit</kbd> <em>once </em>across all users—because there's only one Streamlit server. That means we have to call <kbd>atexit.register</kbd> within a function decorated with <kbd>st.cache_resource</kbd>, or this registration would happen multiple times.</p>
  </div>
  <div class="readable-text  intended-text" id="p577"> 
   <p>To see this change in action, try restarting the app server with <kbd>streamlit run</kbd>, and then press <kbd>Ctrl+C</kbd> to exit it. You should see the message <kbd>Closing all connections...</kbd> which indicates that <kbd>close_all</kbd> has been called.</p>
  </div>
  <div class="readable-text" id="p578"> 
   <h2 class=" readable-text-h2">8.7 Deploying Haiku Haven</h2>
  </div>
  <div class="readable-text " id="p579"> 
   <p>Since we have Haiku Haven working locally, it's time to productionize our app on Community Cloud. The process to do so is the same as what we've been following since Chapter 5, but there's an additional wrinkle here: our app requires a running PostgreSQL server to host our database.</p>
  </div>
  <div class="readable-text" id="p580"> 
   <h3 class=" readable-text-h3">8.7.1 Setting up a managed PostgreSQL server in production</h3>
  </div>
  <div class="readable-text " id="p581"> 
   <p>While we were developing locally, it was a simple matter to install PostgreSQL on the same machine, but Streamlit Community Cloud doesn't provide an option to do that. Instead, we need to set up an external PostgreSQL server somewhere.</p>
  </div>
  <div class="readable-text  intended-text" id="p582"> 
   <p>We'll use a cloud-based managed PostgreSQL service called Neon, which makes this process super-easy, and has a significant free quota. Create an account with Neon now at <kbd>https://neon.tech/</kbd>. The signup process is quite painless; you can choose to sign up with your GitHub or Google account if you like.</p>
  </div>
  <div class="readable-text  intended-text" id="p583"> 
   <p>You'll be asked for a project name and a database name. The project name can be whatever you like (<kbd>Haiku Haven</kbd>, maybe?), while the database name should be whatever you named your database in your local Postgres—<kbd>haikudb</kbd> if you've been following along faithfully.</p>
  </div>
  <div class="readable-text  intended-text" id="p584"> 
   <p>You might also be asked to choose a cloud provider and location—these can be whatever you like, though I chose AWS as the provider.</p>
  </div>
  <div class="readable-text  intended-text" id="p585"> 
   <p>Once your account is set up, navigate to the Quick Start page to see a connection string that looks something like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p586"> 
   <div class="code-area-container"> 
    <pre class="code-area">postgresql://haikudb_owner:Dxg2HFXreSZ3@ep-flower-dust-a63e8evn.us-west-2.aws.neon.tech/haikudb?sslmode=require</pre>
   </div>
  </div>
  <div class="readable-text " id="p587"> 
   <p>This is the connection string we'll use in production. Neon has taken the liberty of setting up a username (<kbd>haikudb_owner</kbd>) and password for you. Store this string somewhere safe.</p>
  </div>
  <div class="readable-text  intended-text" id="p588"> 
   <p>Next, you'll need to set up the <kbd>users</kbd> and <kbd>haikus</kbd> tables once again in Neon. To do this, go to the SQL Editor tab. This is where you can enter SQL commands as though you were in the <kbd>psql</kbd> prompt. To create the tables, refer back to section 8.2.4 and grab the <kbd>CREATE TABLE</kbd> commands we executed locally. You can execute these commands in Neon's SQL Editor without any changes.</p>
  </div>
  <div class="readable-text" id="p589"> 
   <h3 class=" readable-text-h3">8.7.2 Deploying to Community Cloud</h3>
  </div>
  <div class="readable-text " id="p590"> 
   <p>The rest of the deployment process should be straightforward, and is pretty much identical to what we did in Chapter 5.</p>
  </div>
  <div class="readable-text  intended-text" id="p591"> 
   <p>Make sure to create a <kbd>requirements.txt</kbd> so that Community Cloud knows to install the third-party modules needed—primarily <kbd>psycopg2</kbd> and <kbd>bcrypt</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p592"> 
   <p>For reference, listing 8.19 shows the requirements.txt that I used.</p>
  </div>
  <div class="browsable-container listing-container" id="p593"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 8.19 requirements.txt</h5>
   <div class="code-area-container"> 
    <pre class="code-area">streamlit==1.40.2
psycopg2-binary==2.9.10
bcrypt==4.2.0</pre>
   </div>
  </div>
  <div class="readable-text " id="p594"> 
   <p>Notice that I used <kbd>psycopg2-binary</kbd> instead of <kbd>psycopg2</kbd>; that's because Community Cloud threw an error when I tried to use the latter but not with the former.</p>
  </div>
  <div class="readable-text  intended-text" id="p595"> 
   <p>Once you've completed deployment, you'll need to copy the contents of <kbd>secrets.toml</kbd> and paste it in Community Cloud's Secrets setting (refer to Chapter 5 for a refresher), replacing the connection string with the one you copied from Neon.</p>
  </div>
  <div class="readable-text  intended-text" id="p596"> 
   <p>That's all, folks! Haiku Haven is now live! Tell all your friends they can unleash their seventeen-syllable creativity on your brand new web app!</p>
  </div>
  <div class="readable-text  intended-text" id="p597"> 
   <p>As for us, let's turn the page on CRUD and try our hand at building AI apps next.</p>
  </div>
  <div class="readable-text" id="p598"> 
   <h2 class=" readable-text-h2">8.8 Summary</h2>
  </div>
  <ul> 
   <li class="readable-text" id="p599">CRUD stands for Create-Read-Update-Delete, the four fundamental operations that most apps perform.</li>
   <li class="readable-text" id="p600">Relational databases like PostgreSQL organize data in tables with rows and columns according to a schema.</li>
   <li class="readable-text" id="p601">Designing the data model for an application involves identifying the entities, defining their relationships, listing their attributes, and converting these into a schema, often assisted by an Entity-Relationship (ER) diagram.</li>
   <li class="readable-text" id="p602">SQL (Structured Query Language) supports commands for creating tables (<kbd>CREATE TABLE</kbd>), inserting rows (<kbd>INSERT INTO</kbd>), reading data (<kbd>SELECT..FROM</kbd>), updating rows (<kbd>UPDATE..SET</kbd>), deleting rows (<kbd>DELETE FROM</kbd>) and dropping tables (<kbd>DROP TABLE</kbd>).</li>
   <li class="readable-text" id="p603"><kbd>psycopg2</kbd> is a Python module used to connect to PostgreSQL using a shared connection pool.</li>
   <li class="readable-text" id="p604">Never store passwords in plain text; instead hash them using a library like <kbd>bcrypt</kbd> and store the hashed version. To authenticate, hash the given password and compare with the stored hash.</li>
   <li class="readable-text" id="p605"><kbd>st.Page</kbd> objects correspond to individual pages in multi-page apps in Streamlit.</li>
   <li class="readable-text" id="p606"><kbd>st.navigation</kbd> is used to create a navigation bar and specify the pages in an app.</li>
   <li class="readable-text" id="p607"><kbd>st.page_link</kbd> creates links between pages in a multi-page app.</li>
   <li class="readable-text" id="p608"><kbd>st.cache_resource</kbd> is used to cache resources like database connections and share them between users.</li>
   <li class="readable-text" id="p609">Use <kbd>atexit.register</kbd> from the built-in <kbd>atexit</kbd> module to register a function to execute when a Streamlit server shuts down.</li>
   <li class="readable-text" id="p610">When deploying to production, you need to set up your database server separately, potentially using a managed service like Neon for PostgreSQL.</li>
  </ul>
</body>
</html>