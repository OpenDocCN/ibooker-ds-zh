<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 22. Vectorized String Operations" data-type="chapter" epub:type="chapter"><div class="chapter" id="section-0310-working-with-strings">
<h1><span class="label">Chapter 22. </span>Vectorized String Operations</h1>
<p><a data-primary="vectorized string operations" data-secondary="basics" data-type="indexterm" id="idm45858771091328"/>One <a data-primary="Pandas" data-secondary="vectorized string operations" data-type="indexterm" id="ix_ch22-asciidoc0"/><a data-primary="vectorized string operations" data-type="indexterm" id="ix_ch22-asciidoc1"/>strength of Python is its relative ease in handling and manipulating
string data. Pandas builds on this and provides a comprehensive set of
<em>vectorized string operations</em> that are an important part of the type of
munging required when working with (read: cleaning up) real-world data.
In this chapter, we’ll walk through some of the Pandas
string operations, and then take a look at using them to partially clean
up a very messy dataset of recipes collected from the internet.</p>
<section data-pdf-bookmark="Introducing Pandas String Operations" data-type="sect1"><div class="sect1" id="ch_0310-working-with-strings_introducing-pandas-string-operations">
<h1>Introducing Pandas String Operations</h1>
<p>We saw in previous chapters how tools like NumPy and Pandas generalize
arithmetic operations so that we can easily and quickly perform the same
operation on many array elements. For example:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>
        <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">11</code><code class="p">,</code> <code class="mi">13</code><code class="p">])</code>
        <code class="n">x</code> <code class="o">*</code> <code class="mi">2</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code> <code class="mi">4</code><code class="p">,</code>  <code class="mi">6</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">14</code><code class="p">,</code> <code class="mi">22</code><code class="p">,</code> <code class="mi">26</code><code class="p">])</code></pre>
<p>This <em>vectorization</em> of operations simplifies the syntax of operating on
arrays of data: we no longer have to worry about the size or shape of
the array, but just about what operation we want done. For arrays of
strings, NumPy does not provide such simple access, and thus
you’re stuck using a more verbose loop syntax:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="n">data</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'peter'</code><code class="p">,</code> <code class="s1">'Paul'</code><code class="p">,</code> <code class="s1">'MARY'</code><code class="p">,</code> <code class="s1">'gUIDO'</code><code class="p">]</code>
        <code class="p">[</code><code class="n">s</code><code class="o">.</code><code class="n">capitalize</code><code class="p">()</code> <code class="k">for</code> <code class="n">s</code> <code class="ow">in</code> <code class="n">data</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="p">[</code><code class="s1">'Peter'</code><code class="p">,</code> <code class="s1">'Paul'</code><code class="p">,</code> <code class="s1">'Mary'</code><code class="p">,</code> <code class="s1">'Guido'</code><code class="p">]</code></pre>
<p class="pagebreak-before less_space">This is perhaps sufficient to work with some data, but it will break if
there are any missing values, so this approach requires putting in extra
checks:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="n">data</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'peter'</code><code class="p">,</code> <code class="s1">'Paul'</code><code class="p">,</code> <code class="kc">None</code><code class="p">,</code> <code class="s1">'MARY'</code><code class="p">,</code> <code class="s1">'gUIDO'</code><code class="p">]</code>
        <code class="p">[</code><code class="n">s</code> <code class="k">if</code> <code class="n">s</code> <code class="ow">is</code> <code class="kc">None</code> <code class="k">else</code> <code class="n">s</code><code class="o">.</code><code class="n">capitalize</code><code class="p">()</code> <code class="k">for</code> <code class="n">s</code> <code class="ow">in</code> <code class="n">data</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="p">[</code><code class="s1">'Peter'</code><code class="p">,</code> <code class="s1">'Paul'</code><code class="p">,</code> <code class="kc">None</code><code class="p">,</code> <code class="s1">'Mary'</code><code class="p">,</code> <code class="s1">'Guido'</code><code class="p">]</code></pre>
<p>This  manual approach is not only verbose and inconvenient, it
can be error-prone.</p>
<p>Pandas includes features to address both this need for vectorized string
operations as well as the need for correctly handling missing data via the
<code>str</code> attribute of Pandas 
<span class="keep-together"><code>Series</code></span> and <code>Index</code> objects containing
strings. So, for example, if we create a Pandas 
<span class="keep-together"><code>Series</code></span> with this data
we can directly call the <code>str.capitalize</code> method, which has missing
value handling built in:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>
        <code class="n">names</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">(</code><code class="n">data</code><code class="p">)</code>
        <code class="n">names</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">capitalize</code><code class="p">()</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="mi">0</code>    <code class="n">Peter</code>
        <code class="mi">1</code>     <code class="n">Paul</code>
        <code class="mi">2</code>     <code class="kc">None</code>
        <code class="mi">3</code>     <code class="n">Mary</code>
        <code class="mi">4</code>    <code class="n">Guido</code>
        <code class="n">dtype</code><code class="p">:</code> <code class="nb">object</code></pre>
</div></section>
<section data-pdf-bookmark="Tables of Pandas String Methods" data-type="sect1"><div class="sect1" id="ch_0310-working-with-strings_tables-of-pandas-string-methods">
<h1>Tables of Pandas String Methods</h1>
<p><a data-primary="vectorized string operations" data-secondary="tables of" data-type="indexterm" id="ix_ch22-asciidoc2"/>If you have a good understanding of string manipulation in Python, most
of the Pandas string syntax is intuitive enough that it’s
probably sufficient to just list the available methods.
We’ll start with that here, before diving deeper into a few
of the subtleties. The examples in this section use the following
<code>Series</code> object:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">monte</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">([</code><code class="s1">'Graham Chapman'</code><code class="p">,</code> <code class="s1">'John Cleese'</code><code class="p">,</code> <code class="s1">'Terry Gilliam'</code><code class="p">,</code>
                           <code class="s1">'Eric Idle'</code><code class="p">,</code> <code class="s1">'Terry Jones'</code><code class="p">,</code> <code class="s1">'Michael Palin'</code><code class="p">])</code></pre>
<section data-pdf-bookmark="Methods Similar to Python String Methods" data-type="sect2"><div class="sect2" id="ch_0310-working-with-strings_methods-similar-to-python-string-methods">
<h2>Methods Similar to Python String Methods</h2>
<p><a data-primary="vectorized string operations" data-secondary="methods similar to Python string methods" data-type="indexterm" id="idm45858770747648"/>Nearly all of Python’s built-in string methods are mirrored
by a Pandas vectorized string method. The following Pandas <code>str</code>
methods mirror Python string 
<span class="keep-together">methods</span>:</p>
<table>
<tbody>
<tr>
<td><p><code>len</code></p></td>
<td><p><code>lower</code></p></td>
<td><p><code>translate</code></p></td>
<td><p><code>islower</code></p></td>
<td><p><code>ljust</code></p></td>
</tr>
<tr>
<td><p><code>upper</code></p></td>
<td><p><code>startswith</code></p></td>
<td><p><code>isupper</code></p></td>
<td><p><code>rjust</code></p></td>
<td><p><code>find</code></p></td>
</tr>
<tr>
<td><p><code>endswith</code></p></td>
<td><p><code>isnumeric</code></p></td>
<td><p><code>center</code></p></td>
<td><p><code>rfind</code></p></td>
<td><p><code>isalnum</code></p></td>
</tr>
<tr>
<td><p><code>isdecimal</code></p></td>
<td><p><code>zfill</code></p></td>
<td><p><code>index</code></p></td>
<td><p><code>isalpha</code></p></td>
<td><p><code>split</code></p></td>
</tr>
<tr>
<td><p><code>strip</code></p></td>
<td><p><code>rindex</code></p></td>
<td><p><code>isdigit</code></p></td>
<td><p><code>rsplit</code></p></td>
<td><p><code>rstrip</code></p></td>
</tr>
<tr>
<td><p><code>capitalize</code></p></td>
<td><p><code>isspace</code></p></td>
<td><p><code>partition</code></p></td>
<td><p><code>lstrip</code></p></td>
<td><p><code>swapcase</code></p></td>
</tr>
</tbody>
</table>
<p>Notice that these have various return values. Some, like <code>lower</code>, return
a series of strings:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">monte</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">lower</code><code class="p">()</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="mi">0</code>    <code class="n">graham</code> <code class="n">chapman</code>
        <code class="mi">1</code>       <code class="n">john</code> <code class="n">cleese</code>
        <code class="mi">2</code>     <code class="n">terry</code> <code class="n">gilliam</code>
        <code class="mi">3</code>         <code class="n">eric</code> <code class="n">idle</code>
        <code class="mi">4</code>       <code class="n">terry</code> <code class="n">jones</code>
        <code class="mi">5</code>     <code class="n">michael</code> <code class="n">palin</code>
        <code class="n">dtype</code><code class="p">:</code> <code class="nb">object</code></pre>
<p>But some others return numbers:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">monte</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">len</code><code class="p">()</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="mi">0</code>    <code class="mi">14</code>
        <code class="mi">1</code>    <code class="mi">11</code>
        <code class="mi">2</code>    <code class="mi">13</code>
        <code class="mi">3</code>     <code class="mi">9</code>
        <code class="mi">4</code>    <code class="mi">11</code>
        <code class="mi">5</code>    <code class="mi">13</code>
        <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>Or Boolean values:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">monte</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">startswith</code><code class="p">(</code><code class="s1">'T'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="mi">0</code>    <code class="kc">False</code>
        <code class="mi">1</code>    <code class="kc">False</code>
        <code class="mi">2</code>     <code class="kc">True</code>
        <code class="mi">3</code>    <code class="kc">False</code>
        <code class="mi">4</code>     <code class="kc">True</code>
        <code class="mi">5</code>    <code class="kc">False</code>
        <code class="n">dtype</code><code class="p">:</code> <code class="nb">bool</code></pre>
<p>Still others return lists or other compound values for each element:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">monte</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">split</code><code class="p">()</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="mi">0</code>    <code class="p">[</code><code class="n">Graham</code><code class="p">,</code> <code class="n">Chapman</code><code class="p">]</code>
        <code class="mi">1</code>       <code class="p">[</code><code class="n">John</code><code class="p">,</code> <code class="n">Cleese</code><code class="p">]</code>
        <code class="mi">2</code>     <code class="p">[</code><code class="n">Terry</code><code class="p">,</code> <code class="n">Gilliam</code><code class="p">]</code>
        <code class="mi">3</code>         <code class="p">[</code><code class="n">Eric</code><code class="p">,</code> <code class="n">Idle</code><code class="p">]</code>
        <code class="mi">4</code>       <code class="p">[</code><code class="n">Terry</code><code class="p">,</code> <code class="n">Jones</code><code class="p">]</code>
        <code class="mi">5</code>     <code class="p">[</code><code class="n">Michael</code><code class="p">,</code> <code class="n">Palin</code><code class="p">]</code>
        <code class="n">dtype</code><code class="p">:</code> <code class="nb">object</code></pre>
<p>We’ll see further manipulations of this kind of
series-of-lists object as we continue our discussion.</p>
</div></section>
<section data-pdf-bookmark="Methods Using Regular Expressions" data-type="sect2"><div class="sect2" id="ch_0310-working-with-strings_methods-using-regular-expressions">
<h2>Methods Using Regular Expressions</h2>
<p><a data-primary="regular expressions" data-type="indexterm" id="idm45858770425952"/><a data-primary="vectorized string operations" data-secondary="methods using regular expressions" data-type="indexterm" id="idm45858770425344"/>In addition, there are several methods that accept regular expressions
(regexps) to examine the content of each string element, and follow some
of the API conventions of Python’s built-in <code>re</code> module (see <a data-type="xref" href="#table-22-1">Table 22-1</a>).</p>
<table id="table-22-1">
<caption><span class="label">Table 22-1. </span>Mapping between Pandas methods and functions in Python’s <code>re</code> module</caption>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>match</code></p></td>
<td><p>Calls <code>re.match</code> on each element, returning a Boolean.</p></td>
</tr>
<tr>
<td><p><code>extract</code></p></td>
<td><p>Calls <code>re.match</code> on each element, returning matched groups
as strings.</p></td>
</tr>
<tr>
<td><p><code>findall</code></p></td>
<td><p>Calls <code>re.findall</code> on each element</p></td>
</tr>
<tr>
<td><p><code>replace</code></p></td>
<td><p>Replaces occurrences of pattern with some other string</p></td>
</tr>
<tr>
<td><p><code>contains</code></p></td>
<td><p>Calls <code>re.search</code> on each element, returning a boolean</p></td>
</tr>
<tr>
<td><p><code>count</code></p></td>
<td><p>Counts occurrences of pattern</p></td>
</tr>
<tr>
<td><p><code>split</code></p></td>
<td><p>Equivalent to <code>str.split</code>, but accepts regexps</p></td>
</tr>
<tr>
<td><p><code>rsplit</code></p></td>
<td><p>Equivalent to <code>str.rsplit</code>, but accepts regexps</p></td>
</tr>
</tbody>
</table>
<p>With these, we can do a wide range of operations. For example, we can
extract the first name from each element by asking for a contiguous
group of characters at the beginning of each element:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">monte</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">extract</code><code class="p">(</code><code class="s1">'([A-Za-z]+)'</code><code class="p">,</code> <code class="n">expand</code><code class="o">=</code><code class="kc">False</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="mi">0</code>     <code class="n">Graham</code>
         <code class="mi">1</code>       <code class="n">John</code>
         <code class="mi">2</code>      <code class="n">Terry</code>
         <code class="mi">3</code>       <code class="n">Eric</code>
         <code class="mi">4</code>      <code class="n">Terry</code>
         <code class="mi">5</code>    <code class="n">Michael</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="nb">object</code></pre>
<p>Or we can do something more complicated, like finding all names that
start and end with a consonant, making use of the start-of-string (<code>^</code>)
and end-of-string (<code>$</code>) regular expression characters:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">monte</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">findall</code><code class="p">(</code><code class="sa">r</code><code class="s1">'^[^AEIOU].*[^aeiou]$'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="mi">0</code>    <code class="p">[</code><code class="n">Graham</code> <code class="n">Chapman</code><code class="p">]</code>
         <code class="mi">1</code>                  <code class="p">[]</code>
         <code class="mi">2</code>     <code class="p">[</code><code class="n">Terry</code> <code class="n">Gilliam</code><code class="p">]</code>
         <code class="mi">3</code>                  <code class="p">[]</code>
         <code class="mi">4</code>       <code class="p">[</code><code class="n">Terry</code> <code class="n">Jones</code><code class="p">]</code>
         <code class="mi">5</code>     <code class="p">[</code><code class="n">Michael</code> <code class="n">Palin</code><code class="p">]</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="nb">object</code></pre>
<p>The ability to concisely apply regular expressions across <code>Series</code> or
<code>DataFrame</code> entries opens up many possibilities for analysis and
cleaning of data.</p>
</div></section>
<section data-pdf-bookmark="Miscellaneous Methods" data-type="sect2"><div class="sect2" id="ch_0310-working-with-strings_miscellaneous-methods">
<h2>Miscellaneous Methods</h2>
<p>Finally, <a data-type="xref" href="#table-22-2">Table 22-2</a> lists miscellaneous methods that enable other
convenient 
<span class="keep-together">operations</span>.</p>
<table id="table-22-2">
<caption><span class="label">Table 22-2. </span>Other Pandas string methods</caption>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>get</code></p></td>
<td><p>Indexes each element</p></td>
</tr>
<tr>
<td><p><code>slice</code></p></td>
<td><p>Slices each element</p></td>
</tr>
<tr>
<td><p><code>slice_replace</code></p></td>
<td><p>Replaces slice in each element with the passed value</p></td>
</tr>
<tr>
<td><p><code>cat</code></p></td>
<td><p>Concatenates strings</p></td>
</tr>
<tr>
<td><p><code>repeat</code></p></td>
<td><p>Repeats values</p></td>
</tr>
<tr>
<td><p><code>normalize</code></p></td>
<td><p>Returns Unicode form of strings</p></td>
</tr>
<tr>
<td><p><code>pad</code></p></td>
<td><p>Adds whitespace to left, right, or both sides of strings</p></td>
</tr>
<tr>
<td><p><code>wrap</code></p></td>
<td><p>Splits long strings into lines with length less than a given
width</p></td>
</tr>
<tr>
<td><p><code>join</code></p></td>
<td><p>Joins strings in each element of the <code>Series</code> with the passed
separator</p></td>
</tr>
<tr>
<td><p><code>get_dummies</code></p></td>
<td><p>Extracts dummy variables as a <code>DataFrame</code></p></td>
</tr>
</tbody>
</table>
<section data-pdf-bookmark="Vectorized item access and slicing" data-type="sect3"><div class="sect3" id="ch_0310-working-with-strings_vectorized-item-access-and-slicing">
<h3>Vectorized item access and slicing</h3>
<p><a data-primary="get() operation" data-type="indexterm" id="idm45858770232448"/><a data-primary="indicator variables" data-type="indexterm" id="idm45858770231520"/><a data-primary="slice() operation" data-type="indexterm" id="idm45858770230816"/><a data-primary="slicing" data-secondary="vectorized item access and" data-type="indexterm" id="idm45858770230144"/><a data-primary="vectorized string operations" data-secondary="indicator variables" data-type="indexterm" id="idm45858770229232"/><a data-primary="vectorized string operations" data-secondary="vectorized item access and slicing" data-type="indexterm" id="idm45858770228352"/>The <code>get</code> and <code>slice</code> operations, in particular, enable vectorized
element access from each array. For example, we can get a slice of the
first three characters of each array using <code>str.slice(0, 3)</code>. This behavior is also available through Python’s normal
indexing syntax; for example, <code>df.str.slice(0, 3)</code> is equivalent to
<code>df.str[0:3]</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="n">monte</code><code class="o">.</code><code class="n">str</code><code class="p">[</code><code class="mi">0</code><code class="p">:</code><code class="mi">3</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="mi">0</code>    <code class="n">Gra</code>
         <code class="mi">1</code>    <code class="n">Joh</code>
         <code class="mi">2</code>    <code class="n">Ter</code>
         <code class="mi">3</code>    <code class="n">Eri</code>
         <code class="mi">4</code>    <code class="n">Ter</code>
         <code class="mi">5</code>    <code class="n">Mic</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="nb">object</code></pre>
<p>Indexing via <code>df.str.get(i)</code> and <code>df.str[i]</code> are likewise similar.</p>
<p>These indexing methods also let you access elements of arrays returned
by <code>split</code>. For example, to extract the last name of each entry,
combine <code>split</code> with <code>str</code> indexing:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="n">monte</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">split</code><code class="p">()</code><code class="o">.</code><code class="n">str</code><code class="p">[</code><code class="o">-</code><code class="mi">1</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="mi">0</code>    <code class="n">Chapman</code>
         <code class="mi">1</code>     <code class="n">Cleese</code>
         <code class="mi">2</code>    <code class="n">Gilliam</code>
         <code class="mi">3</code>       <code class="n">Idle</code>
         <code class="mi">4</code>      <code class="n">Jones</code>
         <code class="mi">5</code>      <code class="n">Palin</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="nb">object</code></pre>
</div></section>
<section data-pdf-bookmark="Indicator variables" data-type="sect3"><div class="sect3" id="ch_0310-working-with-strings_indicator-variables">
<h3>Indicator variables</h3>
<p><a data-primary="get_dummies() method" data-type="indexterm" id="idm45858770099888"/>Another method that requires a bit of extra explanation is the
<code>get_dummies</code> method. This is useful when your data has a column
containing some sort of coded indicator. For example, we might have a
dataset that contains information in the form of codes, such as A =
“born in America,” B = “born in the United Kingdom,” C = “likes
cheese,” D = “likes spam”:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="n">full_monte</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">({</code><code class="s1">'name'</code><code class="p">:</code> <code class="n">monte</code><code class="p">,</code>
                                    <code class="s1">'info'</code><code class="p">:</code> <code class="p">[</code><code class="s1">'B|C|D'</code><code class="p">,</code> <code class="s1">'B|D'</code><code class="p">,</code> <code class="s1">'A|C'</code><code class="p">,</code>
                                             <code class="s1">'B|D'</code><code class="p">,</code> <code class="s1">'B|C'</code><code class="p">,</code> <code class="s1">'B|C|D'</code><code class="p">]})</code>
         <code class="n">full_monte</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">14</code><code class="p">]:</code>              <code class="n">name</code>   <code class="n">info</code>
         <code class="mi">0</code>  <code class="n">Graham</code> <code class="n">Chapman</code>  <code class="n">B</code><code class="o">|</code><code class="n">C</code><code class="o">|</code><code class="n">D</code>
         <code class="mi">1</code>     <code class="n">John</code> <code class="n">Cleese</code>    <code class="n">B</code><code class="o">|</code><code class="n">D</code>
         <code class="mi">2</code>   <code class="n">Terry</code> <code class="n">Gilliam</code>    <code class="n">A</code><code class="o">|</code><code class="n">C</code>
         <code class="mi">3</code>       <code class="n">Eric</code> <code class="n">Idle</code>    <code class="n">B</code><code class="o">|</code><code class="n">D</code>
         <code class="mi">4</code>     <code class="n">Terry</code> <code class="n">Jones</code>    <code class="n">B</code><code class="o">|</code><code class="n">C</code>
         <code class="mi">5</code>   <code class="n">Michael</code> <code class="n">Palin</code>  <code class="n">B</code><code class="o">|</code><code class="n">C</code><code class="o">|</code><code class="n">D</code></pre>
<p>The <code>get_dummies</code> routine lets us split out these indicator variables
into a <code>DataFrame</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="n">full_monte</code><code class="p">[</code><code class="s1">'info'</code><code class="p">]</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">get_dummies</code><code class="p">(</code><code class="s1">'|'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">15</code><code class="p">]:</code>    <code class="n">A</code>  <code class="n">B</code>  <code class="n">C</code>  <code class="n">D</code>
         <code class="mi">0</code>  <code class="mi">0</code>  <code class="mi">1</code>  <code class="mi">1</code>  <code class="mi">1</code>
         <code class="mi">1</code>  <code class="mi">0</code>  <code class="mi">1</code>  <code class="mi">0</code>  <code class="mi">1</code>
         <code class="mi">2</code>  <code class="mi">1</code>  <code class="mi">0</code>  <code class="mi">1</code>  <code class="mi">0</code>
         <code class="mi">3</code>  <code class="mi">0</code>  <code class="mi">1</code>  <code class="mi">0</code>  <code class="mi">1</code>
         <code class="mi">4</code>  <code class="mi">0</code>  <code class="mi">1</code>  <code class="mi">1</code>  <code class="mi">0</code>
         <code class="mi">5</code>  <code class="mi">0</code>  <code class="mi">1</code>  <code class="mi">1</code>  <code class="mi">1</code></pre>
<p>With these operations as building blocks, you can construct an endless
range of string processing procedures when cleaning your data.</p>
<p>We won’t dive further into these methods here, but I
encourage you to read through
<a href="https://oreil.ly/oYgWA">“Working
with Text Data”</a> in the Pandas online documentation, or to refer to the
resources listed in <a data-type="xref" href="ch24.xhtml#section-0313-further-resources">“Further Resources”</a>.<a data-startref="ix_ch22-asciidoc2" data-type="indexterm" id="idm45858769879072"/></p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Example: Recipe Database" data-type="sect1"><div class="sect1" id="ch_0310-working-with-strings_example-recipe-database">
<h1>Example: Recipe Database</h1>
<p><a data-primary="vectorized string operations" data-secondary="recipe database example" data-type="indexterm" id="ix_ch22-asciidoc3"/>These vectorized string operations become most useful in the process of
cleaning up messy, real-world data. Here I’ll walk through
an example of that, using an open recipe database compiled from various
sources on the web. Our goal will be to parse the recipe data into
ingredient lists, so we can quickly find a recipe based on some
ingredients we have on hand. The scripts used to compile this can be
found on <a href="https://oreil.ly/3S0Rg">
<span class="keep-together">GitHub</span></a>, and the link to the
most recent version of the database is found there as well.</p>
<p>This database is about 30 MB, and can be downloaded and unzipped with
these 
<span class="keep-together">commands</span>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="c1"># repo = "https://raw.githubusercontent.com/jakevdp/open-recipe-data/master"</code>
         <code class="c1"># !cd data &amp;&amp; curl -O {repo}/recipeitems.json.gz</code>
         <code class="c1"># !gunzip data/recipeitems.json.gz</code></pre>
<p>The database is in JSON format, so we will use <code>pd.read_json</code> to read it
(<code>lines=True</code> is required for this dataset because each line of the file
is a JSON entry):</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="n">recipes</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">read_json</code><code class="p">(</code><code class="s1">'data/recipeitems.json'</code><code class="p">,</code> <code class="n">lines</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code>
         <code class="n">recipes</code><code class="o">.</code><code class="n">shape</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="p">(</code><code class="mi">173278</code><code class="p">,</code> <code class="mi">17</code><code class="p">)</code></pre>
<p>We see there are nearly 175,000 recipes, and 17 columns.
Let’s take a look at one row to see what we have:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">18</code><code class="p">]:</code> <code class="n">recipes</code><code class="o">.</code><code class="n">iloc</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">18</code><code class="p">]:</code> <code class="n">_id</code>                                <code class="p">{</code><code class="s1">'$oid'</code><code class="p">:</code> <code class="s1">'5160756b96cc62079cc2db15'</code><code class="p">}</code>
         <code class="n">name</code>                                    <code class="n">Drop</code> <code class="n">Biscuits</code> <code class="ow">and</code> <code class="n">Sausage</code> <code class="n">Gravy</code>
         <code class="n">ingredients</code>           <code class="n">Biscuits</code>\<code class="n">n3</code> <code class="n">cups</code> <code class="n">All</code><code class="o">-</code><code class="n">purpose</code> <code class="n">Flour</code>\<code class="n">n2</code> <code class="n">Tablespo</code><code class="o">...</code>
         <code class="n">url</code>                   <code class="n">http</code><code class="p">:</code><code class="o">//</code><code class="n">thepioneerwoman</code><code class="o">.</code><code class="n">com</code><code class="o">/</code><code class="n">cooking</code><code class="o">/</code><code class="mi">2013</code><code class="o">/</code><code class="mi">03</code><code class="o">/</code><code class="n">dro</code><code class="o">...</code>
         <code class="n">image</code>                 <code class="n">http</code><code class="p">:</code><code class="o">//</code><code class="n">static</code><code class="o">.</code><code class="n">thepioneerwoman</code><code class="o">.</code><code class="n">com</code><code class="o">/</code><code class="n">cooking</code><code class="o">/</code><code class="n">file</code><code class="o">...</code>
         <code class="n">ts</code>                                             <code class="p">{</code><code class="s1">'$date'</code><code class="p">:</code> <code class="mi">1365276011104</code><code class="p">}</code>
         <code class="n">cookTime</code>                                                          <code class="n">PT30M</code>
         <code class="n">source</code>                                                  <code class="n">thepioneerwoman</code>
         <code class="n">recipeYield</code>                                                          <code class="mi">12</code>
         <code class="n">datePublished</code>                                                <code class="mi">2013</code><code class="o">-</code><code class="mi">03</code><code class="o">-</code><code class="mi">11</code>
         <code class="n">prepTime</code>                                                          <code class="n">PT10M</code>
         <code class="n">description</code>           <code class="n">Late</code> <code class="n">Saturday</code> <code class="n">afternoon</code><code class="p">,</code> <code class="n">after</code> <code class="n">Marlboro</code> <code class="n">Man</code> <code class="n">ha</code><code class="o">...</code>
         <code class="n">totalTime</code>                                                           <code class="n">NaN</code>
         <code class="n">creator</code>                                                             <code class="n">NaN</code>
         <code class="n">recipeCategory</code>                                                      <code class="n">NaN</code>
         <code class="n">dateModified</code>                                                        <code class="n">NaN</code>
         <code class="n">recipeInstructions</code>                                                  <code class="n">NaN</code>
         <code class="n">Name</code><code class="p">:</code> <code class="mi">0</code><code class="p">,</code> <code class="n">dtype</code><code class="p">:</code> <code class="nb">object</code></pre>
<p>There is a lot of information there, but much of it is in a very messy
form, as is typical of data scraped from the web. In particular, the
ingredient list is in string format; we’re going to have to
carefully extract the information we’re interested in.
Let’s start by taking a closer look at the ingredients:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">19</code><code class="p">]:</code> <code class="n">recipes</code><code class="o">.</code><code class="n">ingredients</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">len</code><code class="p">()</code><code class="o">.</code><code class="n">describe</code><code class="p">()</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">19</code><code class="p">]:</code> <code class="n">count</code>    <code class="mf">173278.000000</code>
         <code class="n">mean</code>        <code class="mf">244.617926</code>
         <code class="n">std</code>         <code class="mf">146.705285</code>
         <code class="nb">min</code>           <code class="mf">0.000000</code>
         <code class="mi">25</code><code class="o">%</code>         <code class="mf">147.000000</code>
         <code class="mi">50</code><code class="o">%</code>         <code class="mf">221.000000</code>
         <code class="mi">75</code><code class="o">%</code>         <code class="mf">314.000000</code>
         <code class="nb">max</code>        <code class="mf">9067.000000</code>
         <code class="n">Name</code><code class="p">:</code> <code class="n">ingredients</code><code class="p">,</code> <code class="n">dtype</code><code class="p">:</code> <code class="n">float64</code></pre>
<p>The ingredient lists average 250 characters long, with a minimum of 0
and a maximum of nearly 10,000 characters!</p>
<p>Just out of curiosity, let’s see which recipe has the
longest ingredient list:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">20</code><code class="p">]:</code> <code class="n">recipes</code><code class="o">.</code><code class="n">name</code><code class="p">[</code><code class="n">np</code><code class="o">.</code><code class="n">argmax</code><code class="p">(</code><code class="n">recipes</code><code class="o">.</code><code class="n">ingredients</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">len</code><code class="p">())]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">20</code><code class="p">]:</code> <code class="s1">'Carrot Pineapple Spice &amp;amp; Brownie Layer Cake with Whipped Cream &amp;amp;</code>
          <code class="o">&gt;</code> <code class="n">Cream</code> <code class="n">Cheese</code> <code class="n">Frosting</code> <code class="ow">and</code> <code class="n">Marzipan</code> <code class="n">Carrots</code><code class="s1">'</code></pre>
<p>We can do other aggregate explorations; for example, we can see how many
of the recipes are for breakfast foods (using regular expression syntax
to match both lowercase and capital letters):</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">21</code><code class="p">]:</code> <code class="n">recipes</code><code class="o">.</code><code class="n">description</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">contains</code><code class="p">(</code><code class="s1">'[Bb]reakfast'</code><code class="p">)</code><code class="o">.</code><code class="n">sum</code><code class="p">()</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">21</code><code class="p">]:</code> <code class="mi">3524</code></pre>
<p>Or how many of the recipes list cinnamon as an ingredient:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">22</code><code class="p">]:</code> <code class="n">recipes</code><code class="o">.</code><code class="n">ingredients</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">contains</code><code class="p">(</code><code class="s1">'[Cc]innamon'</code><code class="p">)</code><code class="o">.</code><code class="n">sum</code><code class="p">()</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">22</code><code class="p">]:</code> <code class="mi">10526</code></pre>
<p>We could even look to see whether any recipes misspell the ingredient as
“cinamon”:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">23</code><code class="p">]:</code> <code class="n">recipes</code><code class="o">.</code><code class="n">ingredients</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">contains</code><code class="p">(</code><code class="s1">'[Cc]inamon'</code><code class="p">)</code><code class="o">.</code><code class="n">sum</code><code class="p">()</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">23</code><code class="p">]:</code> <code class="mi">11</code></pre>
<p>This is the type of data exploration that is possible with Pandas string
tools. It is data munging like this that Python really excels at.</p>
<section data-pdf-bookmark="A Simple Recipe Recommender" data-type="sect2"><div class="sect2" id="ch_0310-working-with-strings_a-simple-recipe-recommender">
<h2>A Simple Recipe Recommender</h2>
<p>Let’s go a bit further, and start working on a simple recipe
recommendation system: given a list of ingredients, we want to find any
recipes that use all those ingredients. While conceptually
straightforward, the task is complicated by the heterogeneity of the
data: there is no easy operation, for example, to extract a clean list
of ingredients from each row. So, we will cheat a bit: we’ll
start with a list of common ingredients, and simply search to see
whether they are in each recipe’s ingredient list. For
simplicity, let’s just stick with herbs and spices for the
time being:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">24</code><code class="p">]:</code> <code class="n">spice_list</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'salt'</code><code class="p">,</code> <code class="s1">'pepper'</code><code class="p">,</code> <code class="s1">'oregano'</code><code class="p">,</code> <code class="s1">'sage'</code><code class="p">,</code> <code class="s1">'parsley'</code><code class="p">,</code>
                       <code class="s1">'rosemary'</code><code class="p">,</code> <code class="s1">'tarragon'</code><code class="p">,</code> <code class="s1">'thyme'</code><code class="p">,</code> <code class="s1">'paprika'</code><code class="p">,</code> <code class="s1">'cumin'</code><code class="p">]</code></pre>
<p>We can then build a Boolean <code>DataFrame</code> consisting of <code>True</code> and <code>False</code>
values, indicating whether each ingredient appears in the list:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">25</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">re</code>
         <code class="n">spice_df</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">({</code>
             <code class="n">spice</code><code class="p">:</code> <code class="n">recipes</code><code class="o">.</code><code class="n">ingredients</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">contains</code><code class="p">(</code><code class="n">spice</code><code class="p">,</code> <code class="n">re</code><code class="o">.</code><code class="n">IGNORECASE</code><code class="p">)</code>
             <code class="k">for</code> <code class="n">spice</code> <code class="ow">in</code> <code class="n">spice_list</code><code class="p">})</code>
         <code class="n">spice_df</code><code class="o">.</code><code class="n">head</code><code class="p">()</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">25</code><code class="p">]:</code>     <code class="n">salt</code>  <code class="n">pepper</code>  <code class="n">oregano</code>   <code class="n">sage</code>  <code class="n">parsley</code>  <code class="n">rosemary</code>  <code class="n">tarragon</code>  <code class="n">thyme</code>   \
         <code class="mi">0</code>  <code class="kc">False</code>   <code class="kc">False</code>    <code class="kc">False</code>   <code class="kc">True</code>    <code class="kc">False</code>     <code class="kc">False</code>     <code class="kc">False</code>  <code class="kc">False</code>
         <code class="mi">1</code>  <code class="kc">False</code>   <code class="kc">False</code>    <code class="kc">False</code>  <code class="kc">False</code>    <code class="kc">False</code>     <code class="kc">False</code>     <code class="kc">False</code>  <code class="kc">False</code>
         <code class="mi">2</code>   <code class="kc">True</code>    <code class="kc">True</code>    <code class="kc">False</code>  <code class="kc">False</code>    <code class="kc">False</code>     <code class="kc">False</code>     <code class="kc">False</code>  <code class="kc">False</code>
         <code class="mi">3</code>  <code class="kc">False</code>   <code class="kc">False</code>    <code class="kc">False</code>  <code class="kc">False</code>    <code class="kc">False</code>     <code class="kc">False</code>     <code class="kc">False</code>  <code class="kc">False</code>
         <code class="mi">4</code>  <code class="kc">False</code>   <code class="kc">False</code>    <code class="kc">False</code>  <code class="kc">False</code>    <code class="kc">False</code>     <code class="kc">False</code>     <code class="kc">False</code>  <code class="kc">False</code>

            <code class="n">paprika</code>   <code class="n">cumin</code>
         <code class="mi">0</code>    <code class="kc">False</code>   <code class="kc">False</code>
         <code class="mi">1</code>    <code class="kc">False</code>   <code class="kc">False</code>
         <code class="mi">2</code>    <code class="kc">False</code>    <code class="kc">True</code>
         <code class="mi">3</code>    <code class="kc">False</code>   <code class="kc">False</code>
         <code class="mi">4</code>    <code class="kc">False</code>   <code class="kc">False</code></pre>
<p>Now, as an example, let’s say we’d like to find
a recipe that uses parsley, paprika, and tarragon. We can compute this
very quickly using the <code>query</code> method of <code>DataFrame</code>s, discussed further
in <a data-type="xref" href="ch24.xhtml#section-0312-performance-eval-and-query">Chapter 24</a>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">26</code><code class="p">]:</code> <code class="n">selection</code> <code class="o">=</code> <code class="n">spice_df</code><code class="o">.</code><code class="n">query</code><code class="p">(</code><code class="s1">'parsley &amp; paprika &amp; tarragon'</code><code class="p">)</code>
         <code class="nb">len</code><code class="p">(</code><code class="n">selection</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">26</code><code class="p">]:</code> <code class="mi">10</code></pre>
<p>We find only 10 recipes with this combination. Let’s use the
index returned by this selection to discover the names of those recipes:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">27</code><code class="p">]:</code> <code class="n">recipes</code><code class="o">.</code><code class="n">name</code><code class="p">[</code><code class="n">selection</code><code class="o">.</code><code class="n">index</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">27</code><code class="p">]:</code> <code class="mi">2069</code>      <code class="n">All</code> <code class="n">cremat</code> <code class="k">with</code> <code class="n">a</code> <code class="n">Little</code> <code class="n">Gem</code><code class="p">,</code> <code class="n">dandelion</code> <code class="ow">and</code> <code class="n">wa</code><code class="o">...</code>
         <code class="mi">74964</code>                         <code class="n">Lobster</code> <code class="k">with</code> <code class="n">Thermidor</code> <code class="n">butter</code>
         <code class="mi">93768</code>      <code class="n">Burton</code><code class="s1">'s Southern Fried Chicken with White Gravy</code>
         <code class="mi">113926</code>                     <code class="n">Mijo</code><code class="s1">'s Slow Cooker Shredded Beef</code>
         <code class="mi">137686</code>                     <code class="n">Asparagus</code> <code class="n">Soup</code> <code class="k">with</code> <code class="n">Poached</code> <code class="n">Eggs</code>
         <code class="mi">140530</code>                                 <code class="n">Fried</code> <code class="n">Oyster</code> <code class="n">Po</code><code class="err">’</code><code class="n">boys</code>
         <code class="mi">158475</code>                <code class="n">Lamb</code> <code class="n">shank</code> <code class="n">tagine</code> <code class="k">with</code> <code class="n">herb</code> <code class="n">tabbouleh</code>
         <code class="mi">158486</code>                 <code class="n">Southern</code> <code class="n">fried</code> <code class="n">chicken</code> <code class="ow">in</code> <code class="n">buttermilk</code>
         <code class="mi">163175</code>            <code class="n">Fried</code> <code class="n">Chicken</code> <code class="n">Sliders</code> <code class="k">with</code> <code class="n">Pickles</code> <code class="o">+</code> <code class="n">Slaw</code>
         <code class="mi">165243</code>                        <code class="n">Bar</code> <code class="n">Tartine</code> <code class="n">Cauliflower</code> <code class="n">Salad</code>
         <code class="n">Name</code><code class="p">:</code> <code class="n">name</code><code class="p">,</code> <code class="n">dtype</code><code class="p">:</code> <code class="nb">object</code></pre>
<p>Now that we have narrowed down our recipe selection from 175,000 to 10,
we are in a position to make a more informed decision about what
we’d like to cook for dinner.</p>
</div></section>
<section data-pdf-bookmark="Going Further with Recipes" data-type="sect2"><div class="sect2" id="ch_0310-working-with-strings_going-further-with-recipes">
<h2>Going Further with Recipes</h2>
<p>Hopefully this example has given you a bit of a flavor (heh) of the
types of data cleaning operations that are efficiently enabled by Pandas
string methods. Of course, building a robust recipe recommendation
system would require a <em>lot</em> more work! Extracting full ingredient lists
from each recipe would be an important piece of the task; unfortunately,
the wide variety of formats used makes this a relatively time-consuming
process. This points to the truism that in data science, cleaning and
munging of real-world data often comprises the majority of the work—and
Pandas provides the tools that can help you do this efficiently<a data-startref="ix_ch22-asciidoc3" data-type="indexterm" id="idm45858768967920"/>.<a data-startref="ix_ch22-asciidoc1" data-type="indexterm" id="idm45858768967088"/><a data-startref="ix_ch22-asciidoc0" data-type="indexterm" id="idm45858768966384"/></p>
</div></section>
</div></section>
</div></section></div></body></html>