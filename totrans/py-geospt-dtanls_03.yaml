- en: 'Chapter 3\. QGIS: Exploring PyQGIS and Native Algorithms for Spatial Analytics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will continue to focus on QGIS as you level up your skills
    with Python and QGIS. These are foundational concepts, and learning them will
    be critical to future geospatial analysis skills, including spatial algorithms,
    data engineering, prediction modeling and forecasting, and machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: The QGIS integration of Python is called *PyQGIS*, a Python API that uses defined
    protocols and customization to automate workflows. Automation is important when
    running large scripts or building applications. The integration with an API allows
    you access to a large variety of datasets for exploration and analysis. You can
    create, modify, and query digital objects of interest that represent features
    in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: PyQGIS is a wrapper around the underlying C++ library. All the methods and class
    variables implemented by the C++ version of `QgisInterface` are made available
    through the Python wrapper. PyQGIS *classes* target functionality within QGIS.
    You do not need a separate installation of Python because it is installed with
    QGIS directly into your system.
  prefs: []
  type: TYPE_NORMAL
- en: Python is an object-oriented programming language. You can think of objects
    as chunks of data (*attributes*) and behaviors (*methods*). In Python, objects
    also include functions. Attributes can be either data or functions. Methods are
    also attributes, which means you can store them in variables, just like any other
    attribute. A Python class describes instructions for how to change the state of
    an object and the attributes of the object.
  prefs: []
  type: TYPE_NORMAL
- en: I will revisit these concepts when we briefly explore Python scripting templates
    later in the chapter, but I will also highlight them when we use methods or functions
    that are defined by the `QgisInterface` class. We will begin by using PyQGIS to
    navigate a sample project. You will upload data layers and learn how to interact
    with them using the Python Console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exploring the QGIS Workspace: Tree Cover and Inequality in San Francisco'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You learned about urban heat islands in [Chapter 2](ch02.xhtml#essential_facilities_for_spatial_analys),
    and we’re going to expand on that here. It is well known that neighborhoods with
    less tree cover tend to be hotter, often leading to increased health risks. We’re
    going to explore that idea in the first example of this chapter as it plays out
    in one US city, San Francisco, with the research question: *which neighborhoods
    in San Francisco are less likely to have tree cover?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The map in [Figure 3-1](#urban_heat_islands_in_san_franciscocomm) has four
    layers of data superimposed onto it: one delineating neighborhood boundaries,
    one that provides data about tree cover in San Francisco, one that provides data
    about income level and race, and an OpenStreetMap for location context. The purple
    lines indicate neighborhood boundaries represented as a summary feature class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing we need is a *proxy*, or stand-in, for low-income neighborhoods.
    Is there a measure already in use that will tell us what we need to know? In fact,
    there is: [Equity Strategy Neighborhoods](https://oreil.ly/HeLPB). The San Francisco
    Municipal Transportation Agency (SFMTA) uses this measure in applying equity policies
    that attempt to address disparities in transit performance. These neighborhoods
    were identified based on their percentage of low-income households and public
    housing and residents’ access to personal vehicles, race/ethnicity, and disability.
    This could serve our purpose as a proxy for low-income neighborhoods.'
  prefs: []
  type: TYPE_NORMAL
- en: With these layers in place, we can think about where areas of adequate tree
    cover are located and compare them to neighborhoods of different income levels
    and racial composition.
  prefs: []
  type: TYPE_NORMAL
- en: '![Urban heat islands in San Francisco, generated in ArcGIS Online](assets/pgda_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. Urban heat islands in San Francisco, generated in ArcGIS Online
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You’ll be looking at sample data from [DataSF](https://oreil.ly/pLNTb) (pictured
    in [Figure 3-2](#sample_data_visible_in_the_qgis_map_can)). Download the shapefiles
    from these three data resource links: [Equity Strategy Neighborhoods](https://oreil.ly/HPve3),
    [SF Urban Tree Canopy](https://oreil.ly/RIKUa), and [SF_neighborhoods](https://oreil.ly/qNEsQ).
    You will return to these files as soon as you set up your workspace.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sample data visible in the QGIS map canvas](assets/pgda_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. Sample data visible in the QGIS map canvas
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Python Plug-in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the Python Console, just as you did in [Chapter 2](ch02.xhtml#essential_facilities_for_spatial_analys),
    by either selecting the icon in the toolbar at the top of your window or opening
    Plugins >> Python Console from the menu bar. You can click the console, and the
    plug-in will be added to your work space, like in [Figure 3-3](#installing_the_python_plug_in).
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the Python plug-in](assets/pgda_0303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. Installing the Python plug-in
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `QgisInterface` class provides methods for interacting with the QGIS environment.
    When QGIS is running, a variable called `iface` is set up to provide an object
    of the `QgisInterface` class to interact with the running QGIS environment. This
    interface allows access to the map canvas, menus, toolbars, and other parts of
    the QGIS application. Both the Python Console and plug-in can use `iface` to access
    various parts of the QGIS interface.
  prefs: []
  type: TYPE_NORMAL
- en: In the QGIS desktop application, `iface.activeLayer()` gives access to the currently
    selected layer in the legend. The most common use of the `iface` class is to get
    a reference to the canvas where maps are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The prompt at the bottom left of [Figure 3-4](#python_console_left_parenthesisleftrigh)
    is where you will enter your short code snippets. The results of your queries
    will appear in the upper console. The code editor, on the right, accommodates
    longer lines of code and lets you work with your code a bit before you run it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Python Console (left) and a Python code editor (right)](assets/pgda_0304.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4\. Python Console (left) and a Python code editor (right)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Reading the toolbar icons from left to right in [Figure 3-4](#python_console_left_parenthesisleftrigh),
    you will see Clear Console (removes the contents in the console), Run Command,
    Show Editor, Options, and Help.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting Options in the toolbar lets you set the font and perform additional
    customization. The code editor also lists icons for functions, which you can use
    when creating scripts directly in the editor window. A full list is given in [Table 3-1](#function_icons_in_qgis).
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-1\. Function icons in QGIS
  prefs: []
  type: TYPE_NORMAL
- en: '| ![Inline](assets/icon01.png) | Clear Console |'
  prefs: []
  type: TYPE_TB
- en: '| ![Inline](assets/icon02.png) | Run Command/Run Script |'
  prefs: []
  type: TYPE_TB
- en: '| ![Inline](assets/icon03.png) | Show Editor/Open in External Editor |'
  prefs: []
  type: TYPE_TB
- en: '| ![Inline](assets/icon04.png) | Options |'
  prefs: []
  type: TYPE_TB
- en: '| ![Inline](assets/icon05.png) | Python Console Help |'
  prefs: []
  type: TYPE_TB
- en: '| ![Inline](assets/icon06.png) | Open Script |'
  prefs: []
  type: TYPE_TB
- en: '| ![Inline](assets/icon07.png) | Save |'
  prefs: []
  type: TYPE_TB
- en: '| ![Inline](assets/icon08.png) | Save As |'
  prefs: []
  type: TYPE_TB
- en: '| ![Inline](assets/icon09.png) | Cut |'
  prefs: []
  type: TYPE_TB
- en: '| ![Inline](assets/icon10.png) | Copy |'
  prefs: []
  type: TYPE_TB
- en: '| ![Inline](assets/icon11.png) | Paste |'
  prefs: []
  type: TYPE_TB
- en: '| ![Inline](assets/icon12.png) | Find Text |'
  prefs: []
  type: TYPE_TB
- en: '| ![Inline](assets/icon13.png) | Comment |'
  prefs: []
  type: TYPE_TB
- en: '| ![Inline](assets/icon14.png) | Uncomment |'
  prefs: []
  type: TYPE_TB
- en: '| ![Inline](assets/icon15.png) | Object Inspector |'
  prefs: []
  type: TYPE_TB
- en: 'Type into the console at the >>> prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Hit Enter and you get the output: Save the Planet!'
  prefs: []
  type: TYPE_NORMAL
- en: I also want to point out that the string “Save the Planet!” appears in red in
    the GQIS console when you type in this code, while the rest appears in black.
    This is called *syntax highlighting*, and it’s a helpful tool that makes it easier
    to spot if you’ve made any typing mistakes in your code. Brackets will also be
    highlighted, because it is a common mistake to accidentally leave out a required
    opening or closing bracket.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we explore a multilayer example, let’s load a vector layer using Python.
    This is the neighborhood layer from [Figure 3-1](#urban_heat_islands_in_san_franciscocomm).
    You will need to know the URL from where you downloaded your files. If you go
    to the Browser panel and locate the downloaded file, the URL is retrievable from
    Layer Properties, as shown in [Figure 3-5](#loading_data_from_the_browser).
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading data from the Browser](assets/pgda_0305.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-5\. Loading data from the Browser
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You’ll have to tell `iface` to add the vector layer. In the code snippet that
    follows, `ogr` is the provider key name you saw in [Chapter 2](ch02.xhtml#essential_facilities_for_spatial_analys).
    You will work with a few different provider keys in this chapter. Replace `*Path
    to your shape file.shp*` with the URL you retrieved from the Layer Properties.
    You’ll also create a variable for San Francisco, `SF`, and store the location
    information in it, which lets you refer to it later without having to reenter
    the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code here is obtaining the polygon shapes for the neighborhoods in the layer
    we’re calling SF_neighborhoods. If the vector is valid, this code will add the
    layer to the canvas. The `.isValid``():` is a program check to verify that the
    input entered is correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have now loaded a layer onto the canvas from the Python Console. The color
    of the vector layer is random, but you can modify the attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, you’ll want to include the names of the neighborhoods. Select Layer Properties
    and format the Labels to update the map with the names. In [Figure 3-6](#layer_properties_adding_labels_to_a_map),
    you can see how to adjust the Font, Style (bold), Size, Color, and Opacity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Layer properties: adding labels to a map](assets/pgda_0306.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-6\. Layer properties: adding labels to a map'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The labels are added to the canvas ([Figure 3-7](#sf_neighborhood_layer_from_qgiscomma_wi))
    when you select Apply and OK.
  prefs: []
  type: TYPE_NORMAL
- en: 'Load in the remaining layers. The quickest way is to use the `addVectorLayer()`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![SF neighborhood layer from QGIS, with labels](assets/pgda_0307.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-7\. SF neighborhood layer from QGIS, with labels
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Earlier, you used the method `QgsProject.instance().addMapLayer(SF)` to set
    the active layer. Here, you are adding the vector layer, `iface.addVectorLayer`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Layer Panels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we view the final map, I want to rewind a little to show you how we got
    here. On your canvas you have three vector layers.
  prefs: []
  type: TYPE_NORMAL
- en: Click on View in the menu bar and scroll down to Panels ([Figure 3-8](#types_of_panels_available_in_qgis))
    to see a nested menu of Panel options. You can dock these options onto your canvas
    to make them accessible while you are building a visualization (map) and interacting
    with the features and underlying data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Types of panels available in QGIS](assets/pgda_0308.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-8\. Types of panels available in QGIS
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To dock panels, you can drag them on top of one another to save space and move
    between them as needed by selecting the panel. If you decide you prefer to undock
    them, click the stacked image next to the X, and one by one they will undock.
    I suggest docking Layers >> Layer Styling >> Browser >> Processing Toolbox. As
    you begin working, you can remove or add panels simply by returning to your canvas
    or by clicking View in the menu and scrolling to Panels, then checking or unchecking
    options.
  prefs: []
  type: TYPE_NORMAL
- en: The panels are a type of widget. You can use them to provide inputs and visibility,
    digitize coordinates, perform statistical analysis, and add data sources, to name
    a few examples. See the [QGIS User Guide](https://oreil.ly/QWQF1) for details
    on all the different options. I will walk you through the panels I use in almost
    all of the map projects I create.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 3-9](#editing_the_layers_on_the_map_canvas), you can see that the
    layers in the upper left window have been moved into a hierarchy that allows each
    to be visible. For example, the labels for the neighborhoods are at the highest
    level, so they aren’t buried beneath the other features or the polygons.
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing the layers on the map canvas](assets/pgda_0309.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-9\. Editing the layers on the map canvas
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the Layers panel, you can also adjust opacity and colors. You want to be
    certain that the Equity Strategy Neighborhoods data is visible but not masking
    the SF Urban Tree Canopy beneath. Select the panels and arrange them on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that you have been introduced to writing Python code in the console, the
    [QGIS Cheat sheet for PyQGIS](https://oreil.ly/yXc82) has a list of code snippets
    for you.  Feel free to experiment with them and decide which might introduce efficiencies
    in your workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Addressing the Research Question
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s address our original research question. How *does* the tree-cover
    data line up with low-income neighborhoods? Can you get a sense of the answer
    by looking at the map?
  prefs: []
  type: TYPE_NORMAL
- en: At a glance, the tree cover seems sparse in many of the low-income areas we’ve
    identified. Performing additional calculations of tree-cover density would be
    the next step in quantifying what we observe in the maps. Selecting one of the
    neighborhoods reveals the underlying data ([Figure 3-10](#selecting_a_neighborhood_and_exploring)).
    We won’t come to any formal conclusions here, but I encourage you to see how deep
    you can go.
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting a neighborhood and exploring the features](assets/pgda_0310.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-10\. Selecting a neighborhood and exploring the features
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This exercise helped you get familiar with the QGIS workspace and the Python
    plug-in. You learned how to work with layers and add labels. You also learned
    about finding existing datasets that can serve as a proxy for something you want
    to measure, and you got a sense of how aligning two datasets on a map can help
    address research questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Web Feature Service: Identifying Environmental Threats in Massachusetts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next example, you will explore another open dataset. The Massachusetts
    state government’s [MassGIS Bureau of Geographic Information](https://oreil.ly/SNfaJ)
    provides a GIS tool called [MassMapper](https://oreil.ly/JickV). One of the many
    data layers provided within this tool is called [Areas of Critical Environmental
    Concern (ACECs)](https://oreil.ly/9Z3zd). This layer is developed and maintained
    by the Massachusetts Department of Conservation and Recreation (DCR). According
    to the site, this data provides information about places in Massachusetts selected
    for the “quality, uniqueness, and significance of their natural and cultural resources.”
    Using the ACECs data, we can build a map and see how these areas might be affected
    by local features, such as the density of nearby roadways and proximity to wetlands
    or airports.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways to connect to data in QGIS, so here we’ll explore a new
    one.
  prefs: []
  type: TYPE_NORMAL
- en: The Web Feature Service (WFS) specification is a type of provider key that allows
    access to geographic features, with geometry and attributes available for your
    queries and analyses.  Connect to the data by selecting Layer >> Data Source Manager
    or by clicking the icon in the toolbar. Select WFS/OGC API - Features. You can
    also scroll vertically in your Browser panel. Click on the WFS/OGC API, and the
    pop-up in [Figure 3-11](#creating_a_new_wfs_connection) will become visible.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new WFS connection](assets/pgda_0311.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-11\. Creating a new WFS connection
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Connect to the service by entering the URL *http://giswebservices.massgis.state.ma.us/geoserver/wfs*
    into the dialog field ([Figure 3-12](#wfs_connection_details)). You’ll be prompted
    to create a name for the connection: use MASS_Sample and click OK. The defaults
    are fine.'
  prefs: []
  type: TYPE_NORMAL
- en: '![WFS connection details](assets/pgda_0312.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-12\. WFS connection details
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The new connection appears in Server Connections. Click Connect and you will
    see the list of available layers, as pictured in [Figure 3-13](#data_source_manager_wfs_connection).
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down to find and select the following layers, then click Add:'
  prefs: []
  type: TYPE_NORMAL
- en: GISDATA.AIRPORTS_PT (locations of airports)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GISDATA.BM2_CH_BIOMAP2_WETLANDS (locations of wetlands)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GISDATA.ACECS_POLY (areas of critical environmental concern)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GISDATA.CENSUS2010TIGERROADS_ARC (locations of roads)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Data Source Manager WFS connection](assets/pgda_0313.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-13\. Data Source Manager WFS connection
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Discovering Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enter the following code into the console and hit run (the green arrow):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This creates a reference to the active layer, in this case, GISDATA.AIRPORTS_PT.
    Once you create this reference, you can access the properties of the layer.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can explore a few of the options or access them directly in the console.
    First, select Open Attribute Table to view the attributes associated with the
    layer. You can do the same for any layer you want to explore.
  prefs: []
  type: TYPE_NORMAL
- en: As you type code into the console, you may notice that suggestions appear, as
    shown in [Figure 3-14](#automatic_suggestions_in_the_qgis_pytho).
  prefs: []
  type: TYPE_NORMAL
- en: '![Automatic suggestions in the QGIS Python Console](assets/pgda_0314.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-14\. Automatic suggestions in the QGIS Python Console
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s look at the snippet that appears when opening the attribute table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The yellow box contains the arguments you can supply to the `showAttributeTable`
    method and what will be delivered. Here you are calling the `QgsVectorLayer` object
    and a string that represents a filter expression, which you can use to filter
    the data by identifying a specific field, as shown in [Figure 3-15](#layers_and_attribute_table).
    The `filterExpression` is not required, which is indicated by the empty string:
    `=''''`. If left empty, it simply provides the default, an empty string in this
    case. The output `QDialog` constructs the actual attribute table. This is just
    a brief sample; to learn more about the full functionalities of this particular
    class, see the [`QgisInterface` documentation](https://oreil.ly/70feB).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layers and attribute table](assets/pgda_0315.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-15\. Layers and attribute table
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Working with Iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let’s find the airports. Writing the following code directly into the
    console identifies the layer and feature count of the towns where airports are
    located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is a snippet of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'An iterator is a type of Python object that contains items that can be iterated
    upon. Iterators give you a window into a larger dataset, one element at a time.
    They are similar to other objects, like lists, but with a key difference: when
    you create an iterator, you don’t store all the items in memory. The iterator
    loads a single item at a time and then fetches the next item when asked for it.
    This makes iterators very efficient. They can read large amounts of data without
    having to read the entire dataset. QGIS implements iterators for many different
    object types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, the result of calling `layer.getFeatures()` is an iterator;
    the `next()` function is a manual iterator; and lists, tuples, and strings are
    iterables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want a list of all the layers in your map, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It then outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Selecting Layer Properties will also open up tables, as shown in [Figure 3-16](#attributes_and_properties_of_the_select).
    Running the code `layer.featureCount()` earlier showed 42 features total, in this
    case, airports (the active layer) plus the 23 fields (columns) listed in the Layer
    Properties panel.
  prefs: []
  type: TYPE_NORMAL
- en: '![Attributes and properties of the selected layer, GISDATA.AIRPORTS_PT](assets/pgda_0316.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-16\. Attributes and properties of the selected layer, GISDATA.AIRPORTS_PT
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Adding sample code to the Python Console will generate the information for
    the map layer. When running code a single line at a time, you can use the console
    and type your code at the >>> prompt. When running multiline scripts, you will
    want to use the editor: the panel on the right in [Figure 3-17](#running_python_code_in_the_console_to_a).
    Line numbers populate as the code runs. You will see this in the final example
    in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running Python code in the console to add data to the canvas](assets/pgda_0317.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-17\. Running Python code in the console to add data to the canvas
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Layer Styling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The layers can now be modified to make features visible and clear so that your
    audience will understand them. The colors generated are often random, so I like
    to customize them using Layer Styling.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can view the map ([Figure 3-18](#map_of_massachusetts_acecs_areas))
    and explore airport locations, roadways, and wetlands and how they relate to ACECs
    areas. Where do you see potential for these features to affect the health of these
    environmentally sensitive areas? What other features might you want to look for
    in answering this research question?
  prefs: []
  type: TYPE_NORMAL
- en: '![Map of Massachusetts ACECs areas](assets/pgda_0318.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-18\. Map of Massachusetts ACECs areas
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This exercise gave you some more practice with QGIS layers and introduced you
    to layer styling. You also learned how to work with iterators and discover attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Using Processing Algorithms in the Python Console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you’ve been learning about the capabilities of both the Python Console
    and QGIS in geospatial analysis. You are gaining familiarity with an information
    system that combines geographic data with robust software for managing, analyzing,
    and visualizing that data. By now, you’ve likely discovered even more plug-ins
    and powerful tools in the Processing Toolbox. You’ve got a great start on using
    Python for engaging with a system like QGIS.
  prefs: []
  type: TYPE_NORMAL
- en: 'From here on, you can continue building your expertise by making use of help
    functions, QGIS documentation, and other resources. You’ll practice that in the
    following exercise. For this exercise, our research question will be: *which cities
    are located along the Amazonas River?* Perhaps you are hoping to focus your attention
    on how flooding or agricultural runoff affect local communities. The exercise
    is an opportunity to try filtering and analyzing a large open source dataset.
    Explore the attribute tables and customize a query!'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the biggest advantages of Python scripting is that your tasks can be
    flexible and easy to reproduce. In the final section of this chapter, you will
    learn how to use *processing algorithms:* algorithms that let you save your scripts
    and chain them together. Adapting existing scripts is one of the best ways to
    learn how Python operates. You’ll be working with a script adapted from Anita
    Graser^([1](ch03.xhtml#ch01fn8)) to build a workflow in the Python console. This
    workflow will use three processing algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: native:extractbyexpression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: native:buffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: native:extractbylocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we did in [Chapter 2](ch02.xhtml#essential_facilities_for_spatial_analys),
    we’ll use data from Natural Earth Data. The canvas in [Figure 3-19](#exploring_the_area_of_interest_in_the_m)
    shows two kinds of data for Brazil: populated places and rivers and lakes. Download
    [GeoPackage](https://oreil.ly/IMccr), if you have not done so already. Select
    GeoPackage from Data Source Manager to upload the files.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the area of interest in the map canvas](assets/pgda_0319.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-19\. Exploring the area of interest in the map canvas
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Working with Algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start, you need to understand where these algorithms originate and
    how to work with the different parameters. Write the following code in your Python
    Console to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When working with functions, it’s important to call algorithms by name so that
    they execute reliably. The [`QgsProcessingRegistry`](https://oreil.ly/yXOkX) will
    list the algorithms correctly. Registries are where you can access algorithms,
    parameters, and different outputs. You can access the registry by writing this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Algorithms with names starting with `native` are processing algorithms that
    still port to C++ and impart a speed advantage over other algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can scroll through the long list in the output (excerpted below) to see
    the others, but you can also access them directly with a little bit of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: I counted more than two thousand algorithms when I ran this code. Each algorithm
    needs certain parameters to execute its code successfully. Use the parameter `processing.algorithmHelp("algorithmID")`
    with the name of the algorithm to output the characteristics of the syntax. This
    will help familiarize you with writing the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s look at the script we’ll use. Don’t run it yet! Before you do,
    I’ll break down each piece:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice that it runs your three algorithms in order. First, you’ll extract by
    expression. The result is a layer that is stored in the `amazonas` variable and
    passed as input into the next algorithm. The buffer algorithm creates buffers
    that intersect with buffered river centerlines. The distance from the river, for
    example, should be within a certain distance of the city. The buffer sets this
    distance. Next, `extractbylocation` pulls your list of cities along the river.
  prefs: []
  type: TYPE_NORMAL
- en: Extract by Expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s how the `algorithmHelp()` function describes native:extractbyexpression:'
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm creates a new vector layer that only contains matching features
    from an input layer. The criteria for adding features to the resulting layer is
    based on a QGIS expression.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Take a moment to run `processing.algorithmHelp("native:extractbyexpression")`
    and read the rest now. It will provide important details and describe the output
    you can anticipate. If you don’t list a parameter, the default will be applied
    and output is sent to memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the segment of the script that uses this algorithm, so you can examine
    it in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Buffer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see what the [help documentation](https://oreil.ly/pNmzd) tells us about
    native:buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm computes a buffer area for all the features in an input layer,
    using a fixed or dynamic distance.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The segments parameter controls the number of line segments to use to approximate
    a quarter circle when creating rounded offsets.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The end cap style parameter controls how line endings are handled in the buffer.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The join style parameter specifies whether round, miter or beveled joins should
    be used when offsetting corners in a line.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The miter limit parameter is only applicable for miter join styles, and controls
    the maximum distance from the offset curve to use when creating a mitered join.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Read the full output for the information you need to understand the algorithm
    and the inputs and outputs needed. In particular, you need to understand the parameters
    so you can include them in your query. You will see information for `INPUT`, `DISTANCE`,
    `SEGMENTS`, `END_CAP_STYLE`, `JOIN_STYLE`, `MITER_LIMIT`, `DISSOLVE`, and `OUTPUT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the script segment that includes this algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What is this code doing? What can you tell from the syntax here? From reading
    the output of the `algorithmHelp` function, you can see that the location vector
    is now the input for the native.buffer. The buffer will be interested only in
    data within the buffer range. For example, the rivers and cities should be within
    10 kilometers.
  prefs: []
  type: TYPE_NORMAL
- en: Extract by Location
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our third algorithm is native:extractbylocation. Next, we’ll *intersect* the
    buffered Amazonas data–that is, compare the two sets of data we now have–to combine
    the rivers data with the places data. This will include the cities along the river
    we are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The help documentation again contains important information about the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the section of our script that uses extract by location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The QGIS GUI contains similar tools in the Processing Toolbox functions ([Figure 3-20](#algorithms_in_the_qgis_gui)),
    but you need to run the processes separately and locate the suitable input and
    output parameters in output (which will resemble that in [Figure 3-21](#the_input_and_output_parameters_buried)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![Algorithms in the QGIS GUI](assets/pgda_0320.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-20\. Algorithms in the QGIS GUI
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![The input and output parameters buried in the QGIS GUI output](assets/pgda_0321.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-21\. The input and output parameters buried in the QGIS GUI output
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that you’ve examined it, go ahead and run the script in the console. The
    output, shown in [Figure 3-22](#the_amazonas_river_with_cities_along_it), is a
    map of cities along the Amazonas river in Brazil. This exercise is an example
    of how creating algorithms to run on large datasets reinforces efficient and repeatable
    workflows. Now you can query the data with your own ideas. Use the attribute tables
    available for each dataset to note how the variables or column headings are listed.
    Saving your Python scripts will allow you to create templates to practice and
    update as your curiosity grows!
  prefs: []
  type: TYPE_NORMAL
- en: '![The Amazonas River with cities along its route](assets/pgda_0322.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-22\. The Amazonas River with cities along its route
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter showed you how to download QGIS, customize your workspace, and
    upload data from different provider keys, both within the Python Console and directly
    from the Browser. You also learned to customize your maps to increase their legibility
    and started becoming familiar with the canvas and layer styling. You were introduced
    to the Processing Tools. These are complex, but splitting the code into small
    sections and learning about the syntax is often perfect practice for gaining more
    advanced skills. You learned how to chain three algorithms together and store
    results in a variable, to be used as input.
  prefs: []
  type: TYPE_NORMAL
- en: In coming chapters, you will continue to build your Python skills by interacting
    with additional tools like Google Earth Engine and ArcGIS.
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](ch03.xhtml#ch01fn8-marker)) This workflow is adapted from Anita Graser’s
    undated blog post [“PyQGIS 101: Chaining Processing Tools”](https://oreil.ly/RdQxx),
    a tutorial for working with processing tools.'
  prefs: []
  type: TYPE_NORMAL
