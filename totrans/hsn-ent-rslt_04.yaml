- en: Chapter 4\. Probabilistic Matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html#chapter_3), we explored how to use approximate matching
    techniques to measure the degree of similarity between attribute values. We set
    a threshold above which we declared equivalence and then combined these matching
    features, with equal weight, to conclude that two records referred to the same
    entity when both were a match. We evaluated our performance against exact matches
    only.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will examine how to use probability-based techniques to
    calculate the optimum weighting for each equivalent attribute in calculating the
    likelihood of an overall entity match. This probability-based approach allows
    us to declare a match when the most statistically significant attributes are equivalent
    (either exact or approximate) but those with less significance are insufficiently
    similar. It also allows us to grade our confidence in the declaration of a match
    and apply appropriate match thresholds. The model that will be introduced in this
    section is known as the Fellegi-Sunter (FS) model.
  prefs: []
  type: TYPE_NORMAL
- en: We will also introduce a probabilistic entity resolution framework, Splink,
    that we will use to help us calculate these metrics and resolve our entities together.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s return to our exact match results from the end of [Chapter 2](ch02.html#chapter_2).
    Opening the *Chapter4.ipynb* notebook we reload the standardized datasets from
    the Wikipedia and TheyWorkForYou websites. As in [Chapter 3](ch03.html#chapter_3),
    we start by calculating the Cartesian, or cross, product of the two datasets as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This gives us our total population of 650 × 650 = 422,500 record pairs—a pair
    for every name combination between the Wikipedia and TheyWorkForYou datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we will be using exact matches between the `Firstname`,
    `Lastname`, and `Constituency` fields of each of these record pairs multiple times.
    Thus, it’s more efficient to calculate these matches once and store them as additional
    feature columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We also calculate the total number of matching columns, which we will use later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on our exploration of the data in [Chapter 2](ch02.html#chapter_2), we
    know that within our total population of 422,500 combinations we have 637 record
    pairs that have an exact match on constituency and either first name or last name.
    This is our `match` population:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The remainder, our `notmatch` population, is extracted as the inverse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: These combinations are summarized in [Table 4-1](#table-4-1).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1\. Match and not match combinations
  prefs: []
  type: TYPE_NORMAL
- en: '| Match/not match population | Constituency match | First name match | Last
    name match |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Not match | No | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| Not match | No | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Not match | No | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Not match | No | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Not match | Yes | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| Match | Yes | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Match | Yes | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Match | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: We will now examine how well first name and last name equivalence, both individually
    and together, can predict whether an individual record belongs in either the `match`
    or `notmatch` population.
  prefs: []
  type: TYPE_NORMAL
- en: Single Attribute Match Probability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s begin by considering whether first name equivalence alone is a good indicator
    that two entities within a record pair refer to the same person. We will examine
    both the `match` and `notmatch` populations and establish, within each of those
    subsets, how many first names match and how many do not.
  prefs: []
  type: TYPE_NORMAL
- en: Naming Convention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we work through various subsets of these populations, it’s helpful to adopt
    a standard naming convention so that we can see at a glance how each population
    of records was selected. As we select records we add the selection criteria to
    the population name, right to left, e.g., `first_match` should be read as first
    selecting those records that are part of the `match` population and within that
    subset of the population further selecting only those rows where the first names
    are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: First Name Match Probability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting with the `match` population we can select those records where the
    first names are equivalent to give us our `first_match` population:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Repeating this for the three other combinations of match/not match, and first
    name equivalence or not, we can draw up a population map, as shown in [Figure 4-1](#fig-4-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. First name population map
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Therefore, based on first name equivalence only, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper T r u e p o s i t i v e m a t c h e s left-parenthesis
    upper T upper P right-parenthesis equals 632"><mrow><mi>T</mi> <mi>r</mi> <mi>u</mi>
    <mi>e</mi> <mi>p</mi> <mi>o</mi> <mi>s</mi> <mi>i</mi> <mi>t</mi> <mi>i</mi> <mi>v</mi>
    <mi>e</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>e</mi> <mi>s</mi>
    <mo>(</mo> <mi>T</mi> <mi>P</mi> <mo>)</mo> <mo>=</mo> <mn>632</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F a l s e p o s i t i v e m a t c h e s left-parenthesis
    upper F upper P right-parenthesis equals 2052"><mrow><mi>F</mi> <mi>a</mi> <mi>l</mi>
    <mi>s</mi> <mi>e</mi> <mi>p</mi> <mi>o</mi> <mi>s</mi> <mi>i</mi> <mi>t</mi> <mi>i</mi>
    <mi>v</mi> <mi>e</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>e</mi>
    <mi>s</mi> <mo>(</mo> <mi>F</mi> <mi>P</mi> <mo>)</mo> <mo>=</mo> <mn>2052</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper T r u e n e g a t i v e m a t c h e s left-parenthesis
    upper T upper N right-parenthesis equals 419811"><mrow><mi>T</mi> <mi>r</mi> <mi>u</mi>
    <mi>e</mi> <mi>n</mi> <mi>e</mi> <mi>g</mi> <mi>a</mi> <mi>t</mi> <mi>i</mi> <mi>v</mi>
    <mi>e</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>e</mi> <mi>s</mi>
    <mo>(</mo> <mi>T</mi> <mi>N</mi> <mo>)</mo> <mo>=</mo> <mn>419811</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F a l s e n e g a t i v e m a t c h e s left-parenthesis
    upper F upper N right-parenthesis equals 5"><mrow><mi>F</mi> <mi>a</mi> <mi>l</mi>
    <mi>s</mi> <mi>e</mi> <mi>n</mi> <mi>e</mi> <mi>g</mi> <mi>a</mi> <mi>t</mi> <mi>i</mi>
    <mi>v</mi> <mi>e</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>e</mi>
    <mi>s</mi> <mo>(</mo> <mi>F</mi> <mi>N</mi> <mo>)</mo> <mo>=</mo> <mn>5</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can calculate some probability values. First, the probability that a
    record pair whose first names are equivalent is actually a true positive match
    can be calculated as the number of pairs within the `match` population whose first
    names match divided by the number of pairs whose first names match across both
    the `match` and `notmatch` populations:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="p r o b normal bar m a t c h normal bar f i r s t equals StartFraction
    l e n left-parenthesis f i r s t normal bar m a t c h right-parenthesis Over left-parenthesis
    l e n left-parenthesis f i r s t normal bar m a t c h right-parenthesis plus l
    e n left-parenthesis f i r s t normal bar n o t m a t c h right-parenthesis right-parenthesis
    EndFraction equals StartFraction 632 Over left-parenthesis 632 plus 2052 right-parenthesis
    EndFraction almost-equals 0.2355"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi>
    <mo>_</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>_</mo> <mi>f</mi>
    <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>=</mo> <mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mfrac><mn>632</mn> <mrow><mo>(</mo><mn>632</mn><mo>+</mo><mn>2052</mn><mo>)</mo></mrow></mfrac>
    <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>2355</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'From this we can see that, at only about 23%, first name equivalence alone
    isn’t a great predictor of a match between two records. This value is a conditional
    probability, that is, it is the probability of a true positive match conditional
    on the first name being a match. This can be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis"><mrow><mi>P</mi>
    <mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo> <mi>f</mi>
    <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: where the pipe character (|) is read as “given that.”
  prefs: []
  type: TYPE_NORMAL
- en: Last Name Match Probability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applying the same calculations to the last name, we can draw a second population
    map, as shown in [Figure 4-2](#fig-4-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. Last name population map
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As for first name, the probability that a pair of records whose last names are
    equivalent is actually a match can be calculated as the number of pairs within
    the `match` population whose last names match divided by the number of pairs whose
    last names match across both the `match` and `notmatch` populations.
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="p r o b normal bar m a t c h normal bar l a s t equals StartFraction
    l e n left-parenthesis l a s t normal bar m a t c h right-parenthesis Over left-parenthesis
    l e n left-parenthesis l a s t normal bar m a t c h right-parenthesis plus l e
    n left-parenthesis l a s t normal bar n o t m a t c h right-parenthesis right-parenthesis
    EndFraction equals StartFraction 633 Over left-parenthesis 633 plus 349 right-parenthesis
    EndFraction almost-equals 0.6446"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi>
    <mo>_</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>_</mo> <mi>l</mi>
    <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>=</mo> <mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mfrac><mn>633</mn> <mrow><mo>(</mo><mn>633</mn><mo>+</mo><mn>349</mn><mo>)</mo></mrow></mfrac>
    <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>6446</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: For these records last name equivalence is clearly a better predictor of a true
    match than first name, which instinctively makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, this can be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P left-parenthesis m a t c h vertical-bar l a s t right-parenthesis"><mrow><mi>P</mi>
    <mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo> <mi>l</mi>
    <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Attribute Match Probability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now if we consider both first name and last name equivalence we can further
    subdivide our population map. Starting with our first name map and further subdividing
    each first name category into last name equivalence, and not, we can view our
    population as shown in [Figure 4-3](#fig-4-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_0403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. First name, last name population map
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Extending our calculation to both first name and last name exact matches, we
    can calculate the probability of a true positive match given both first name and
    last name equivalence as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="p r o b normal bar m a t c h normal bar l a s t normal bar f
    i r s t equals StartFraction l e n left-parenthesis l a s t normal bar f i r s
    t normal bar m a t c h right-parenthesis Over left-parenthesis l e n left-parenthesis
    l a s t normal bar f i r s t normal bar m a t c h right-parenthesis plus l e n
    left-parenthesis l a s t normal bar f i r s t normal bar n o t m a t c h right-parenthesis
    EndFraction equals StartFraction 628 Over left-parenthesis 628 plus 0 right-parenthesis
    EndFraction equals 1.0"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mo>_</mo>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>_</mo> <mi>l</mi> <mi>a</mi>
    <mi>s</mi> <mi>t</mi> <mo>_</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi>
    <mo>=</mo> <mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mfrac><mn>628</mn> <mrow><mo>(</mo><mn>628</mn><mo>+</mo><mn>0</mn><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mn>1</mn> <mo>.</mo> <mn>0</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: If the first name matches but last name doesn’t, what is the probability that
    it’s a match?
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="p r o b normal bar m a t c h normal bar n o t l a s t normal
    bar f i r s t equals StartFraction l e n left-parenthesis n o t l a s t normal
    bar f i r s t normal bar m a t c h right-parenthesis Over left-parenthesis l e
    n left-parenthesis n o t l a s t normal bar f i r s t normal bar m a t c h right-parenthesis
    plus l e n left-parenthesis n o t l a s t normal bar f i r s t normal bar n o
    t m a t c h right-parenthesis right-parenthesis EndFraction equals StartFraction
    4 Over left-parenthesis 4 plus 2052 right-parenthesis EndFraction almost-equals
    0.0019"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mo>_</mo> <mi>m</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>_</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi>
    <mi>l</mi> <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>_</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi>
    <mi>s</mi> <mi>t</mi> <mo>=</mo> <mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mfrac><mn>4</mn> <mrow><mo>(</mo><mn>4</mn><mo>+</mo><mn>2052</mn><mo>)</mo></mrow></mfrac>
    <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>0019</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: If the first name doesn’t match but the last name does, what is the probability
    that it’s a match?
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="p r o b normal bar m a t c h normal bar l a s t normal bar n
    o t f i r s t equals StartFraction l e n left-parenthesis l a s t normal bar n
    o t f i r s t normal bar m a t c h right-parenthesis Over left-parenthesis l e
    n left-parenthesis l a s t normal bar n o t f i r s t normal bar m a t c h right-parenthesis
    plus l e n left-parenthesis l a s t normal bar n o t f i r s t normal bar n o
    t m a t c h right-parenthesis right-parenthesis EndFraction equals StartFraction
    5 Over left-parenthesis 5 plus 349 right-parenthesis EndFraction almost-equals
    0.0141"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mo>_</mo> <mi>m</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>_</mo> <mi>l</mi> <mi>a</mi> <mi>s</mi>
    <mi>t</mi> <mo>_</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>f</mi> <mi>i</mi> <mi>r</mi>
    <mi>s</mi> <mi>t</mi> <mo>=</mo> <mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mfrac><mn>5</mn> <mrow><mo>(</mo><mn>5</mn><mo>+</mo><mn>349</mn><mo>)</mo></mrow></mfrac>
    <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>0141</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: As we expected, if either first name or last name isn’t an exact match, then
    the probability of a true positive match is low, but a last name match gives us
    more confidence than a first name one.
  prefs: []
  type: TYPE_NORMAL
- en: 'If neither first name nor last name matches, the probability that it is a match
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="p r o b normal bar m a t c h normal bar n o t l a s t normal
    bar n o t f i r s t equals"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi>
    <mo>_</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>_</mo> <mi>n</mi>
    <mi>o</mi> <mi>t</mi> <mi>l</mi> <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>_</mo> <mi>n</mi>
    <mi>o</mi> <mi>t</mi> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>=</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction l e n left-parenthesis n o t l a s t normal bar
    n o t f i r s t normal bar m a t c h right-parenthesis Over left-parenthesis l
    e n left-parenthesis n o t l a s t normal bar n o t f i r s t normal bar m a t
    c h right-parenthesis plus l e n left-parenthesis n o t l a s t normal bar n o
    t f i r s t normal bar n o t m a t c h right-parenthesis right-parenthesis EndFraction
    equals StartFraction 0 Over left-parenthesis 0 plus 419462 right-parenthesis EndFraction
    equals 0"><mrow><mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mfrac><mn>0</mn> <mrow><mo>(</mo><mn>0</mn><mo>+</mo><mn>419462</mn><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mn>0</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: This is not surprising given that we defined true positive matches as records
    with an exact match on constituency and either first name or last name.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, we can use these probabilities to inform our decision making
    on whether we are likely to have a true positive match or not. In this example,
    we would place more weight on a last name match than a first name one. This is
    an improvement on our method in [Chapter 3](ch03.html#chapter_3), where we gave
    them the same weighting (and required them both to be equivalent) to declare a
    match.
  prefs: []
  type: TYPE_NORMAL
- en: But wait, we have a problem. In the preceding example, we started with a known
    population of matches that we used to compute the probabilities that first name
    and last name equivalence equate to a match. However, in most situations we don’t
    have a known `match` population; otherwise we wouldn’t need to perform matching
    in the first place! How do we overcome this? To do so, we need to reframe our
    calculation a little and then employ some clever estimation techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Probabilistic Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned that some attributes are more informative
    than others; that is, they have more predictive power to help us decide whether
    a match is likely to be correct. In this section, we examine how to calculate
    these contributions and how to combine them to assess the overall likelihood of
    a match.
  prefs: []
  type: TYPE_NORMAL
- en: We start with a little statistical theory (using first name equivalence as an
    example) before we generalize to model what we can deploy at scale.
  prefs: []
  type: TYPE_NORMAL
- en: Bayes’ Theorem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Bayes’ theorem*, named after Thomas Bayes, states that the conditional probability
    of an event, based on the occurrence of another event, is equal to the probability
    of the second event given the first event, multiplied by the probability of the
    first event.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the probability that two records chosen at random are a true positive
    match, P(match), multiplied by the probability that within those matches the first
    names match, P (first|match):'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P left-parenthesis f i r s t vertical-bar m a t c h right-parenthesis
    times upper P left-parenthesis m a t c h right-parenthesis"><mrow><mi>P</mi> <mo>(</mo>
    <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>m</mi> <mi>a</mi>
    <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo> <mo>×</mo> <mi>P</mi> <mo>(</mo> <mi>m</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Equally, we could calculate the same value in the reverse order, starting with
    the probability that the first name matches, P(first) multiplied by the probability
    that records within this population are a true positive match:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis
    times upper P left-parenthesis f i r s t right-parenthesis"><mrow><mi>P</mi> <mo>(</mo>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi>
    <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo> <mo>×</mo> <mi>P</mi> <mo>(</mo> <mi>f</mi>
    <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Equating these probabilities, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis
    times upper P left-parenthesis f i r s t right-parenthesis equals upper P left-parenthesis
    f i r s t vertical-bar m a t c h right-parenthesis times upper P left-parenthesis
    m a t c h right-parenthesis"><mrow><mi>P</mi> <mo>(</mo> <mi>m</mi> <mi>a</mi>
    <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi>
    <mi>t</mi> <mo>)</mo> <mo>×</mo> <mi>P</mi> <mo>(</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi>
    <mi>s</mi> <mi>t</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>f</mi> <mi>i</mi>
    <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi>
    <mi>h</mi> <mo>)</mo> <mo>×</mo> <mi>P</mi> <mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi>
    <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Rearranging we can calculate:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis
    equals StartFraction upper P left-parenthesis f i r s t vertical-bar m a t c h
    right-parenthesis times upper P left-parenthesis m a t c h right-parenthesis Over
    upper P left-parenthesis f i r s t right-parenthesis EndFraction"><mrow><mi>P</mi>
    <mrow><mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo>
    <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mfrac><mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>×</mo><mi>P</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>)</mo></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'We can calculate P(first) as the sum of the probabilities across both the `match`
    and `notmatch` populations:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mtable columnalign="right left" displaystyle="true"><mtr><mtd
    class="tml-right" style="padding:0.7ex 0em 0.7ex 0em;"><mrow><mi>P</mi> <mo form="prefix"
    stretchy="false">(</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi>
    <mo form="postfix" stretchy="false">)</mo></mrow></mtd> <mtd class="tml-left"
    style="padding:0.7ex 0em 0.7ex 0em;"><mrow><mo>=</mo> <mo form="prefix" stretchy="false">(</mo>
    <mi>P</mi> <mo form="prefix" stretchy="false">(</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi>
    <mi>s</mi> <mi>t</mi> <mi>|</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi>
    <mo form="postfix" stretchy="false">)</mo> <mo>×</mo> <mi>P</mi> <mo form="prefix"
    stretchy="false">(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi>
    <mo form="postfix" stretchy="false">)</mo></mrow></mtd></mtr> <mtr><mtd class="tml-left"
    style="padding:0.7ex 0em 0.7ex 0em;"><mrow><mo>+</mo> <mi>P</mi> <mo form="prefix"
    stretchy="false">(</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi>
    <mi>|</mi> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi>
    <mi>h</mi> <mo form="postfix" stretchy="false">)</mo> <mo>×</mo> <mi>P</mi> <mo
    form="prefix" stretchy="false">(</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>m</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo form="postfix" stretchy="false">)</mo>
    <mo form="postfix" stretchy="false">)</mo></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Substituting in the preceding equation, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis
    equals StartFraction upper P left-parenthesis f i r s t vertical-bar m a t c h
    right-parenthesis times upper P left-parenthesis m a t c h right-parenthesis Over
    upper P left-parenthesis f i r s t vertical-bar m a t c h right-parenthesis times
    upper P left-parenthesis m a t c h right-parenthesis plus upper P left-parenthesis
    f i r s t vertical-bar n o t m a t c h right-parenthesis times upper P left-parenthesis
    n o t m a t c h right-parenthesis EndFraction"><mrow><mi>P</mi> <mrow><mo>(</mo>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi>
    <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>×</mo><mi>P</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>×</mo><mi>P</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>×</mo><mi>P</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can rearrange this as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis
    equals 1 minus left-parenthesis 1 plus StartFraction upper P left-parenthesis
    f i r s t vertical-bar m a t c h right-parenthesis Over upper P left-parenthesis
    f i r s t vertical-bar n o t m a t c h right-parenthesis EndFraction times StartFraction
    upper P left-parenthesis m a t c h right-parenthesis Over upper P left-parenthesis
    n o t m a t c h right-parenthesis EndFraction right-parenthesis Superscript negative
    1"><mrow><mi>P</mi> <mrow><mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi>
    <mi>h</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>1</mn> <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><mrow><mi>P</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mi>P</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: If we can estimate the values in this equation, we can determine the probability
    that if a first name is equivalent, then the record pair really is a match.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine these values in a little more detail, simplifying the notation
    as we go along.
  prefs: []
  type: TYPE_NORMAL
- en: m Value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The conditional probability that an attribute will be equivalent within the
    overall `match` population is known as the *m value*. Using our `Firstname` example,
    we can denote this as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="m Subscript f Baseline equals upper P left-parenthesis f i r
    s t vertical-bar m a t c h right-parenthesis"><mrow><msub><mi>m</mi> <mi>f</mi></msub>
    <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi>
    <mi>t</mi> <mo>|</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: In a perfect dataset, all the first names within the `match` population would
    be exactly equivalent and the *m* value would be 1\. This value can therefore
    be thought of as a measure of data quality, i.e., how much variability there is
    in how an attribute has been captured across the datasets. A higher value indicates
    a better-quality attribute.
  prefs: []
  type: TYPE_NORMAL
- en: u Value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The conditional probability that an attribute will be equivalent within the
    overall `notmatch` population is known as the *u value*. Again, using our `Firstname`
    example, we can denote this as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="u Subscript f Baseline equals upper P left-parenthesis f i r
    s t vertical-bar n o t m a t c h right-parenthesis"><mrow><msub><mi>u</mi> <mi>f</mi></msub>
    <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi>
    <mi>t</mi> <mo>|</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi>
    <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: This value reflects how much commonality there is in this attribute across the
    datasets. A lower value indicates a less common, more distinguishing attribute
    that, if found to be equivalent in a particular case, would lead us to question
    whether it belongs in the `notmatch` population and is really a match. Conversely,
    a higher *u* value tells us that this particular attribute is not as valuable
    for determining overall matches.
  prefs: []
  type: TYPE_NORMAL
- en: A good example of *u* value is a month of birth attribute, which, assuming the
    population is equally distributed across the year, will have a *u* value of <math
    alttext="one-twelfth"><mfrac><mn>1</mn> <mn>12</mn></mfrac></math> .
  prefs: []
  type: TYPE_NORMAL
- en: Lambda ( <math alttext="lamda"><mi>λ</mi></math> ) Value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *lambda value*,  <math alttext="lamda"><mi>λ</mi></math> , also known as
    the prior, is the probability that two randomly chosen records match.
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="lamda equals upper P left-parenthesis m a t c h right-parenthesis"><mrow><mi>λ</mi>
    <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi>
    <mo>)</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: In contrast with the *m* and *u* values, the  <math alttext="lamda"><mi>λ</mi></math>
     value is a record-level value not associated with any particular attribute. This
    value is a measure of how much duplication there is in the dataset overall and
    is the starting point for our probability calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inverse, the likelihood that two randomly chosen records are not a match,
    can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="1 minus lamda equals upper P left-parenthesis n o t m a t c h
    right-parenthesis"><mrow><mn>1</mn> <mo>-</mo> <mi>λ</mi> <mo>=</mo> <mi>P</mi>
    <mo>(</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi>
    <mi>h</mi> <mo>)</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Bayes Factor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Substituting these compact notations can result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis
    equals 1 minus left-parenthesis 1 plus StartFraction m Subscript f Baseline Over
    u Subscript f Baseline EndFraction times StartFraction lamda Over left-parenthesis
    1 minus lamda right-parenthesis EndFraction right-parenthesis Superscript negative
    1"><mrow><mi>P</mi> <mrow><mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi>
    <mi>h</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>1</mn> <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><msub><mi>m</mi>
    <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>×</mo><mfrac><mi>λ</mi>
    <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: The ratio  <math alttext="StartFraction m Subscript f Baseline Over u Subscript
    f Baseline EndFraction"><mfrac><msub><mi>m</mi> <mi>f</mi></msub> <msub><mi>u</mi>
    <mi>f</mi></msub></mfrac></math> is also known as the *Bayes factor*, in this
    case of the `Firstname` parameter. The Bayes factor, as a combination of both
    the *m* and *u* values, gives a measure of the significance we should attach to
    the fact that the `Firstname` values were equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Fellegi-Sunter Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Fellegi-Sunter model*, named after Ivan P. Fellegi and Alan B. Sunter,^([1](ch04.html#id429))
    describes how we can extend our simple Bayesian approach, combining the contribution
    of multiple attributes, to calculate the overall likelihood of a match. It relies
    on the simplifying assumption of conditional independence between attributes,
    also known as *naive Bayes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the FS model, we can combine the Bayes factors associated with each attribute
    in our record by simply multiplying them together. Taking our `Firstname` example
    and extending it to consider when the `Lastname` is also equivalent we have:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue l a s t
    EndAbsoluteValue f i r s t right-parenthesis equals 1 minus left-parenthesis 1
    plus StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction
    times StartFraction m Subscript l Baseline Over u Subscript l Baseline EndFraction
    times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis
    EndFraction right-parenthesis Superscript negative 1"><mrow><mi>P</mi> <mrow><mo>(</mo>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo> <mi>l</mi> <mi>a</mi>
    <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mn>1</mn> <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><msub><mi>m</mi>
    <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>×</mo><mfrac><msub><mi>m</mi>
    <mi>l</mi></msub> <msub><mi>u</mi> <mi>l</mi></msub></mfrac> <mo>×</mo><mfrac><mi>λ</mi>
    <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'When an attribute isn’t equivalent, the Bayes factor is calculated as the inverse, 
    <math alttext="StartFraction left-parenthesis 1 minus m Subscript l Baseline right-parenthesis
    Over left-parenthesis 1 minus u Subscript l Baseline right-parenthesis EndFraction"><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac></math> . Therefore when the `Firstname`
    is equivalent but the `Lastname` is not, we calculate the probability of an overall
    match as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue n o t l
    a s t EndAbsoluteValue f i r s t right-parenthesis equals 1 minus left-parenthesis
    1 plus StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction
    times StartFraction left-parenthesis 1 minus m Subscript l Baseline right-parenthesis
    Over left-parenthesis 1 minus u Subscript l Baseline right-parenthesis EndFraction
    times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis
    EndFraction right-parenthesis Superscript negative 1"><mrow><mi>P</mi> <mrow><mo>(</mo>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo> <mi>n</mi> <mi>o</mi>
    <mi>t</mi> <mi>l</mi> <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi>
    <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>1</mn> <mo>-</mo>
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><msub><mi>m</mi> <mi>f</mi></msub>
    <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>×</mo><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Once we can calculate the *m* and *u* values for each attribute, and the  <math
    alttext="lamda"><mi>λ</mi></math>  value for the overall dataset, we can easily
    calculate the probabilities for each record pair. We simply determine the equivalence
    of each attribute (either exact or approximate as appropriate), select the appropriate
    Bayes factors, and multiply them together using the preceding formula to calculate
    the overall probability for that record pair.
  prefs: []
  type: TYPE_NORMAL
- en: For our simple example, our Bayes factors are therefore calculated as shown
    in [Table 4-2](#table-4-2).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-2\. `Firstname`, `Lastname` match factor calculations
  prefs: []
  type: TYPE_NORMAL
- en: '| `Firstname` equivalence | `Lastname` equivalence | `Firstname` Bayes factor
    | `Lastname` Bayes factor | Combined Bayes factor |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| No | No | <math alttext="StartFraction left-parenthesis 1 minus m Subscript
    f Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript f Baseline
    right-parenthesis EndFraction"><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow></mfrac></math> | <math alttext="StartFraction
    left-parenthesis 1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis
    1 minus u Subscript l Baseline right-parenthesis EndFraction"><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac></math> | <math alttext="StartFraction
    left-parenthesis 1 minus m Subscript f Baseline right-parenthesis Over left-parenthesis
    1 minus u Subscript f Baseline right-parenthesis EndFraction times StartFraction
    left-parenthesis 1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis
    1 minus u Subscript l Baseline right-parenthesis EndFraction"><mrow><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow></mfrac> <mo>×</mo> <mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac></mrow></math> |'
  prefs: []
  type: TYPE_TB
- en: '| No | Yes | <math alttext="StartFraction left-parenthesis 1 minus m Subscript
    f Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript f Baseline
    right-parenthesis EndFraction"><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow></mfrac></math> | <math alttext="StartFraction
    m Subscript l Baseline Over u Subscript l Baseline EndFraction"><mfrac><msub><mi>m</mi>
    <mi>l</mi></msub> <msub><mi>u</mi> <mi>l</mi></msub></mfrac></math> | <math alttext="StartFraction
    left-parenthesis 1 minus m Subscript f Baseline right-parenthesis Over left-parenthesis
    1 minus u Subscript f Baseline right-parenthesis EndFraction times StartFraction
    m Subscript l Baseline Over u Subscript l Baseline EndFraction"><mrow><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow></mfrac> <mo>×</mo> <mfrac><msub><mi>m</mi>
    <mi>l</mi></msub> <msub><mi>u</mi> <mi>l</mi></msub></mfrac></mrow></math> |'
  prefs: []
  type: TYPE_TB
- en: '| Yes | No | <math alttext="StartFraction m Subscript f Baseline Over u Subscript
    f Baseline EndFraction"><mfrac><msub><mi>m</mi> <mi>f</mi></msub> <msub><mi>u</mi>
    <mi>f</mi></msub></mfrac></math> | <math alttext="StartFraction left-parenthesis
    1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis 1 minus
    u Subscript l Baseline right-parenthesis EndFraction"><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac></math> | <math alttext="StartFraction
    m Subscript f Baseline Over u Subscript f Baseline EndFraction times StartFraction
    left-parenthesis 1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis
    1 minus u Subscript l Baseline right-parenthesis EndFraction"><mrow><mfrac><msub><mi>m</mi>
    <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>×</mo> <mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac></mrow></math> |'
  prefs: []
  type: TYPE_TB
- en: '| Yes | Yes | <math alttext="StartFraction m Subscript f Baseline Over u Subscript
    f Baseline EndFraction"><mfrac><msub><mi>m</mi> <mi>f</mi></msub> <msub><mi>u</mi>
    <mi>f</mi></msub></mfrac></math> | <math alttext="StartFraction m Subscript l
    Baseline Over u Subscript l Baseline EndFraction"><mfrac><msub><mi>m</mi> <mi>l</mi></msub>
    <msub><mi>u</mi> <mi>l</mi></msub></mfrac></math> | <math alttext="StartFraction
    m Subscript f Baseline Over u Subscript f Baseline EndFraction times StartFraction
    m Subscript l Baseline Over u Subscript l Baseline EndFraction"><mrow><mfrac><msub><mi>m</mi>
    <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>×</mo> <mfrac><msub><mi>m</mi>
    <mi>l</mi></msub> <msub><mi>u</mi> <mi>l</mi></msub></mfrac></mrow></math> |'
  prefs: []
  type: TYPE_TB
- en: Match Weight
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make overall match calculations more intuitive, the logarithm of the Bayes
    factors is sometimes used so that they can be added together rather than multiplied.
    In this way it is easy to visualize the relative contribution of each attribute
    to the overall score.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our simple first name and last name equivalence example, the logarithmic
    match weight might be calculated (using base 2) as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper M a t c h upper W e i g h t equals l o g 2 StartFraction
    m Subscript f Baseline Over u Subscript f Baseline EndFraction plus l o g 2 StartFraction
    m Subscript l Baseline Over u Subscript l Baseline EndFraction plus l o g 2 StartFraction
    lamda Over left-parenthesis 1 minus lamda right-parenthesis EndFraction"><mrow><mi>M</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>W</mi> <mi>e</mi> <mi>i</mi> <mi>g</mi>
    <mi>h</mi> <mi>t</mi> <mo>=</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub>
    <mfrac><msub><mi>m</mi> <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac>
    <mo>+</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub> <mfrac><msub><mi>m</mi>
    <mi>l</mi></msub> <msub><mi>u</mi> <mi>l</mi></msub></mfrac> <mo>+</mo> <mi>l</mi>
    <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub> <mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'We can calculate probability from the match weight as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P r o b a b i l i t y equals 1 minus left-parenthesis 1
    plus 2 Superscript upper M a t c h upper W e i g h t Baseline right-parenthesis
    Superscript negative 1"><mrow><mi>P</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mi>a</mi>
    <mi>b</mi> <mi>i</mi> <mi>l</mi> <mi>i</mi> <mi>t</mi> <mi>y</mi> <mo>=</mo> <mn>1</mn>
    <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><msup><mn>2</mn> <mrow><mi>M</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to combine our individual attribute probabilities,
    or match weights, together let’s consider how to estimate our  <math alttext="lamda"><mi>λ</mi></math>
     value and our *m* and *u* values for each attribute when we don’t have a known
    `match` population. One technique that we can use is called the [*expectation-maximization
    (EM) algorithm*](https://oreil.ly/kvWD3).
  prefs: []
  type: TYPE_NORMAL
- en: Expectation-Maximization Algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The expectation-maximization algorithm uses an iterative approach to approximating
    the <math alttext="lamda"><mi>λ</mi></math>  and *m* and *u* values. Let’s see
    a simplified form of this in action applied to our sample problem.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the first iteration we make the opening assumption that record pairs where
    the majority of the feature columns are equivalent are matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us a pseudo `match` population, `it1_match`, of 637 records. In
    addition to the 628 perfect matches we found in [Chapter 2](ch02.html#chapter_2),
    we also have 9 matches where either `Firstname` or `Lastname` (but not both) doesn’t
    match, as we see in [Figure 4-4](#fig-4-4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/hoer_0404.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4\. Expectation-maximization iteration 1 additional matches
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Our initial  <math alttext="lamda"><mi>λ</mi></math>  value is therefore:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="lamda 1 equals StartFraction 637 Over 650 times 650 EndFraction
    almost-equals 0.0015"><mrow><msub><mi>λ</mi> <mn>1</mn></msub> <mo>=</mo> <mfrac><mn>637</mn>
    <mrow><mn>650</mn><mo>×</mo><mn>650</mn></mrow></mfrac> <mo>≈</mo> <mn>0</mn>
    <mo>.</mo> <mn>0015</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="left-parenthesis 1 minus lamda 1 right-parenthesis equals left-parenthesis
    1 minus 0.0015 right-parenthesis almost-equals 0.9985"><mrow><mrow><mo>(</mo>
    <mn>1</mn> <mo>-</mo> <msub><mi>λ</mi> <mn>1</mn></msub> <mo>)</mo></mrow> <mo>=</mo>
    <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mn>0</mn> <mo>.</mo> <mn>0015</mn> <mo>)</mo></mrow>
    <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>9985</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Our initial prior match weight is therefore   <math alttext="l o g 2 StartFraction
    lamda 1 Over left-parenthesis 1 minus lamda 1 right-parenthesis EndFraction almost-equals
    negative 9.371"><mrow><mrow><mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub>
    <mfrac><msub><mi>λ</mi> <mn>1</mn></msub> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>λ</mi>
    <mn>1</mn></msub> <mo>)</mo></mrow></mfrac></mrow> <mo>≈</mo> <mo>-</mo> <mn>9</mn>
    <mo>.</mo> <mn>371</mn></mrow></math> .
  prefs: []
  type: TYPE_NORMAL
- en: As a starting point, it’s therefore extremely unlikely that two records are
    a match. Now let’s calculate our *m* and *u* values so that we can update our
    probability on a per-record basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have a pseudo `match` and `notmatch` population, it’s straightforward
    to calculate our *m* and *u* values as the proportion of each population with
    an equivalent attribute. For `Firstname`, `Lastname`, and `Constituency` we use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 4-3](#table-4-3) shows these values and the resulting match weight values
    per attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-3\. Iteration 1 *m* and *u* values
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | *m* value | *u* value | Match Bayes factor | Match weight | Not
    match Bayes factor | Not match weight |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Firstname` | 0.9921 | 0.0049 | 203.97 | 7.67 | 0.0079 | –6.98 |'
  prefs: []
  type: TYPE_TB
- en: '| `Lastname` | 0.9937 | 0.0008 | 1201.19 | 10.23 | 0.0063 | –7.31 |'
  prefs: []
  type: TYPE_TB
- en: '| `Constituency` | 1.0 | 0.0 | <math alttext="normal infinity"><mi>∞</mi></math>
    | <math alttext="normal infinity"><mi>∞</mi></math> | 0 | <math alttext="negative
    normal infinity"><mrow><mo>-</mo> <mi>∞</mi></mrow></math> |'
  prefs: []
  type: TYPE_TB
- en: There are no record pairs where the constituency is equivalent in the `notmatch`
    population, so its *u* value is 0 and therefore its `match` weight is mathematically
    infinity and its `notmatch` weight is negative infinity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use these values in the Fellegi-Sunter model to calculate the match
    probability for every record pair in the full population. We use a helper function
    to calculate these probabilities based on the values of the `Constituency`, `Firstname`,
    and `Lastname` match features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We apply this function to the whole population with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once we’ve calculated these values we can iterate again, resegmenting our population
    into `match` and `notmatch` populations based on the calculated match probabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For illustration purposes, we use an overall match probability of greater than
    0.99 to define our new assumed `match` population and assign any record with an
    equal or lower probability to our `notmatch` population:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying this 0.99 threshold gives us a slightly reduced `match` population
    of 633\. Let’s see why. If we select the records just below the threshold we can
    see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/hoer_0405.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-5\. Iteration 2 records with below-the-line match thresholds
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As we see in [Figure 4-5](#fig-4-5), if the `Lastname` isn’t equivalent, the
    new match probability falls just below our 0.99 threshold. Using these new `match`
    and `notmatch` populations we can revise our <math alttext="lamda"><mi>λ</mi></math>
    , *m*, and *u* values and iterate again, recalculating the match probabilities
    for each record pair.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, our  <math alttext="lamda"><mi>λ</mi></math>  doesn’t materially
    change:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="lamda 2 equals StartFraction 633 Over 650 times 650 EndFraction
    almost-equals 0.0015"><mrow><msub><mi>λ</mi> <mn>2</mn></msub> <mo>=</mo> <mfrac><mn>633</mn>
    <mrow><mn>650</mn><mo>×</mo><mn>650</mn></mrow></mfrac> <mo>≈</mo> <mn>0</mn>
    <mo>.</mo> <mn>0015</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Only the `Lastname` values change slightly, as shown in [Table 4-4](#table-4-4).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-4\. Iteration 2 *m* and *u* values
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | *m* value | *u* value | Match Bayes factor | Match weight | Not
    match Bayes factor | Not match weight |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Firstname` | 0.9921 | 0.0049 | 203.97 | 7.67 | 0.0079 | –6.98 |'
  prefs: []
  type: TYPE_TB
- en: '| *`Lastname`* | *1.0* | *0.0008* | *1208.79* | *10.24* | *0* | <math alttext="negative
    normal infinity"><mrow><mo>-</mo> <mi>∞</mi></mrow></math> |'
  prefs: []
  type: TYPE_TB
- en: '| `Constituency` | 1.0 | 0.0 | <math alttext="normal infinity"><mi>∞</mi></math>
    | <math alttext="normal infinity"><mi>∞</mi></math> | 0 | <math alttext="negative
    normal infinity"><mrow><mo>-</mo> <mi>∞</mi></mrow></math> |'
  prefs: []
  type: TYPE_TB
- en: Iteration 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this simple example, this next iteration doesn’t change the `match` population,
    which remains at 633, because the EM algorithm has already converged.
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us our final parameter values of:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="lamda almost-equals 0.0015"><mrow><mi>λ</mi> <mo>≈</mo> <mn>0</mn>
    <mo>.</mo> <mn>0015</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="m Subscript f Baseline equals upper P left-parenthesis f i r
    s t vertical-bar m a t c h right-parenthesis almost-equals 0.9921"><mrow><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>f</mi> <mi>i</mi>
    <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi>
    <mi>h</mi> <mo>)</mo></mrow> <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>9921</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="m Subscript l Baseline equals upper P left-parenthesis l a s
    t vertical-bar m a t c h right-parenthesis almost-equals 1.0"><mrow><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>l</mi> <mi>a</mi>
    <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi>
    <mo>)</mo></mrow> <mo>≈</mo> <mn>1</mn> <mo>.</mo> <mn>0</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="m Subscript c Baseline equals upper P left-parenthesis c o n
    s t i t u e n c y vertical-bar m a t c h right-parenthesis almost-equals 1.0"><mrow><msub><mi>m</mi>
    <mi>c</mi></msub> <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>c</mi> <mi>o</mi>
    <mi>n</mi> <mi>s</mi> <mi>t</mi> <mi>i</mi> <mi>t</mi> <mi>u</mi> <mi>e</mi> <mi>n</mi>
    <mi>c</mi> <mi>y</mi> <mo>|</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi>
    <mo>)</mo></mrow> <mo>≈</mo> <mn>1</mn> <mo>.</mo> <mn>0</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="u Subscript f Baseline equals upper P left-parenthesis f i r
    s t vertical-bar n o t m a t c h right-parenthesis almost-equals 0.0049"><mrow><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>f</mi> <mi>i</mi>
    <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>m</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow> <mo>≈</mo> <mn>0</mn>
    <mo>.</mo> <mn>0049</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="u Subscript l Baseline equals upper P left-parenthesis l a s
    t vertical-bar n o t m a t c h right-parenthesis almost-equals 0.0008"><mrow><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>l</mi> <mi>a</mi>
    <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi>
    <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow> <mo>≈</mo> <mn>0</mn> <mo>.</mo>
    <mn>0008</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="u Subscript c Baseline equals upper P left-parenthesis c o n
    s t i t u e n c y vertical-bar n o t m a t c h right-parenthesis almost-equals
    0"><mrow><msub><mi>u</mi> <mi>c</mi></msub> <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo>
    <mi>c</mi> <mi>o</mi> <mi>n</mi> <mi>s</mi> <mi>t</mi> <mi>i</mi> <mi>t</mi> <mi>u</mi>
    <mi>e</mi> <mi>n</mi> <mi>c</mi> <mi>y</mi> <mo>|</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow> <mo>≈</mo>
    <mn>0</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: This instinctively feels right. We know that a match will always have an equivalent
    constituency and either first name or last name will match, with last name slightly
    more likely to be equivalent than first name (five out of nine versus four out
    of nine in the preceding sample).
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we know the constituency will never be the same in a `notmatch` record
    pair and it’s very unlikely that either the first name or last name will accidentally
    match either (with first name slightly more likely).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can turn these estimated values into match probabilities using the equations
    in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue l a s t
    EndAbsoluteValue f i r s t right-parenthesis equals 1 minus left-parenthesis 1
    plus StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction
    times StartFraction m Subscript l Baseline Over u Subscript l Baseline EndFraction
    times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis
    EndFraction right-parenthesis Superscript negative 1 Baseline equals 1.0"><mrow><mi>P</mi>
    <mrow><mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo>
    <mi>l</mi> <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi>
    <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>1</mn> <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><msub><mi>m</mi>
    <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>×</mo><mfrac><msub><mi>m</mi>
    <mi>l</mi></msub> <msub><mi>u</mi> <mi>l</mi></msub></mfrac> <mo>×</mo><mfrac><mi>λ</mi>
    <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mn>1</mn> <mo>.</mo> <mn>0</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue n o t l
    a s t EndAbsoluteValue f i r s t right-parenthesis equals 1 minus left-parenthesis
    1 plus StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction
    times StartFraction left-parenthesis 1 minus m Subscript l Baseline right-parenthesis
    Over left-parenthesis 1 minus u Subscript l Baseline right-parenthesis EndFraction
    times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis
    EndFraction right-parenthesis Superscript negative 1 Baseline almost-equals 0.0019"><mrow><mi>P</mi>
    <mrow><mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo>
    <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>l</mi> <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>|</mo>
    <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mn>1</mn> <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><msub><mi>m</mi>
    <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>×</mo><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>0019</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue n o t f
    i r s t EndAbsoluteValue l a s t right-parenthesis equals 1 minus left-parenthesis
    1 plus StartFraction left-parenthesis 1 minus m Subscript f Baseline right-parenthesis
    Over left-parenthesis 1 minus u Subscript f Baseline right-parenthesis EndFraction
    times StartFraction m Subscript l Baseline Over u Subscript l Baseline EndFraction
    times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis
    EndFraction right-parenthesis Superscript negative 1 Baseline almost-equals 0.0141"><mrow><mi>P</mi>
    <mrow><mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo>
    <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi>
    <mo>|</mo> <mi>l</mi> <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mn>1</mn> <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><msub><mi>m</mi> <mi>l</mi></msub>
    <msub><mi>u</mi> <mi>l</mi></msub></mfrac> <mo>×</mo><mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>0141</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue n o t f
    i r s t EndAbsoluteValue n o t l a s t right-parenthesis equals 1 minus left-parenthesis
    1 plus StartFraction left-parenthesis 1 minus m Subscript f Baseline right-parenthesis
    Over left-parenthesis 1 minus u Subscript f Baseline right-parenthesis EndFraction
    times StartFraction left-parenthesis 1 minus m Subscript l Baseline right-parenthesis
    Over left-parenthesis 1 minus u Subscript l Baseline right-parenthesis EndFraction
    times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis
    EndFraction right-parenthesis Superscript negative 1 Baseline equals 0"><mrow><mi>P</mi>
    <mrow><mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo>
    <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi>
    <mo>|</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>l</mi> <mi>a</mi> <mi>s</mi> <mi>t</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mn>1</mn> <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mn>0</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: As expected, these probabilities match the values we calculated using the probability
    maps in [Figure 4-3](#fig-4-3) when we knew the `match` and `notmatch` population
    upfront.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, we are now able to estimate match probabilities for all the different
    permutations of attribute equivalence without having to know the `match` population
    in advance. This probabilistic approach is both powerful and scalable to large
    datasets with multiple attributes. To help us apply these techniques more easily,
    we introduce a performant and easy-to-use open source library, Splink, in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Splink
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Splink is a Python package for probabilistic entity resolution. Splink implements
    the Fellegi-Sunter model and includes a variety of interactive outputs to help
    users understand models and diagnose linkage problems.
  prefs: []
  type: TYPE_NORMAL
- en: Splink supports a number of backends to perform the matching calculations. To
    begin with, we will use DuckDB, an in-process SQL database management system,
    that we can run locally on our laptop.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Splink
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To import Splink into our notebook, we use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Splink requires a unique ID column in each dataset, so we need to create these
    by copying their respective DataFrame indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Splink also needs the same columns to be present in both datasets. Therefore,
    we need to create blank columns where these are present in only one set of records
    and then remove unnecessary columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next step is to configure Splink settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Splink supports both deduplication of records within a single dataset and linking
    between one or more separate datasets. Here we set `link_type` to `link_only`
    to tell Splink that we want only to match, not deduplicate, between our two datasets.
    We also tell Splink the comparisons we wish to use, in this case exact matches
    across our three attributes. Lastly, we instantiate the linker with these settings
    and our source DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help us understand our datasets, Splink provides a visualization of the
    distribution of the columns to be matched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The graphs we see in [Figure 4-6](#fig-4-6) show us the combined population
    across both datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with distribution of first names we can see from the bottom right of
    the graph that, within the population of 352 distinct names, approximately 35%
    occur only twice, most probably once in each dataset. Then, moving right to left,
    we see a gradual increase in frequency to the most popular name, with 32 occurrences.
    Looking at the top 10 values by value count we see that John is the most popular
    name, followed by Andrew, David, etc. This tells us that `Firstname` is a reasonable
    attribute to match on, but used alone, it will result in some false positives.
  prefs: []
  type: TYPE_NORMAL
- en: For last name the pattern is more stark, with a larger population of 574 distinct
    names, of which nearly 80% occur only twice. Looking at the top 10 values, the
    most common last names, Smith and Jones, occur 18 times, almost half as common
    as the most popular first name. As expected, this tells us that `Lastname` is
    a richer attribute than `Firstname` and therefore its equivalence is a better
    predictor of matching entities.
  prefs: []
  type: TYPE_NORMAL
- en: As expected, constituencies are uniquely paired across the two datasets, so
    all values appear exactly twice.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_0406.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-6\. Splink column profiles
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'For the purposes of this simple example, we’re going to ask Splink to calculate
    all the parameters of the model using the expectation-maximization algorithm we
    introduced earlier. The initial `True` parameter tells Splink to compare all the
    records across both datasets without blocking (we’ll see this in the next chapter).
    We also tell Splink to recalculate the *u* values at each iteration by setting
    `fix_u_probabilities` to `False`. Setting the `fix_probability_two_random_records_match`
    to `False` means the <math alttext="lamda"><mi>λ</mi></math> value (the overall
    match probability between the two datasets) will be recalculated at each iteration.
    Finally, we tell Splink to use the updated  <math alttext="lamda"><mi>λ</mi></math>
     value when  calculating probabilities for record pairs.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Splink Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The EM model converges after three iterations.  Splink produces an interactive
    chart showing the iterative progression of the relative match weights values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/hoer_0407.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-7\. Splink match weights
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 4-7](#fig-4-7) shows the final match weights that Splink has calculated
    after the third iteration. First, we have the prior (starting) match weight, which
    is a measure of how likely it is that two records chosen at random match. If you
    hover over the match weight bars you can see the calculated match weight value
    together with the underlying *m* and *u* parameters. These are calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P r i o r left-parenthesis s t a r t i n g right-parenthesis
    m a t c h w e i g h t equals l o g 2 StartFraction lamda Over left-parenthesis
    1 minus lamda right-parenthesis EndFraction almost-equals negative 9.38"><mrow><mi>P</mi>
    <mi>r</mi> <mi>i</mi> <mi>o</mi> <mi>r</mi> <mrow><mo>(</mo> <mi>s</mi> <mi>t</mi>
    <mi>a</mi> <mi>r</mi> <mi>t</mi> <mi>i</mi> <mi>n</mi> <mi>g</mi> <mo>)</mo></mrow>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>w</mi> <mi>e</mi> <mi>i</mi>
    <mi>g</mi> <mi>h</mi> <mi>t</mi> <mo>=</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi>
    <mn>2</mn></msub> <mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac>
    <mo>≈</mo> <mo>-</mo> <mn>9</mn> <mo>.</mo> <mn>38</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F i r s t n a m e m a t c h w e i g h t left-parenthesis
    e x a c t m a t c h right-parenthesis equals l o g 2 StartFraction m Subscript
    f Baseline Over u Subscript f Baseline EndFraction almost-equals 7.67"><mrow><mi>F</mi>
    <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mi>n</mi> <mi>a</mi> <mi>m</mi> <mi>e</mi>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>w</mi> <mi>e</mi> <mi>i</mi>
    <mi>g</mi> <mi>h</mi> <mi>t</mi> <mrow><mo>(</mo> <mi>e</mi> <mi>x</mi> <mi>a</mi>
    <mi>c</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub> <mfrac><msub><mi>m</mi>
    <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>≈</mo> <mn>7</mn>
    <mo>.</mo> <mn>67</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F i r s t n a m e m a t c h w e i g h t left-parenthesis
    n o t e x a c t m a t c h right-parenthesis equals l o g 2 StartFraction left-parenthesis
    1 minus m Subscript f Baseline right-parenthesis Over left-parenthesis 1 minus
    u Subscript f Baseline right-parenthesis EndFraction almost-equals negative 6.98"><mrow><mi>F</mi>
    <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mi>n</mi> <mi>a</mi> <mi>m</mi> <mi>e</mi>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>w</mi> <mi>e</mi> <mi>i</mi>
    <mi>g</mi> <mi>h</mi> <mi>t</mi> <mrow><mo>(</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi>
    <mi>e</mi> <mi>x</mi> <mi>a</mi> <mi>c</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi>
    <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi>
    <mn>2</mn></msub> <mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow></mfrac> <mo>≈</mo> <mo>-</mo> <mn>6</mn> <mo>.</mo>
    <mn>98</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper L a s t n a m e m a t c h w e i g h t left-parenthesis
    e x a c t m a t c h right-parenthesis equals l o g 2 StartFraction m Subscript
    l Baseline Over u Subscript l Baseline EndFraction almost-equals 10.23"><mrow><mi>L</mi>
    <mi>a</mi> <mi>s</mi> <mi>t</mi> <mi>n</mi> <mi>a</mi> <mi>m</mi> <mi>e</mi> <mi>m</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>w</mi> <mi>e</mi> <mi>i</mi> <mi>g</mi>
    <mi>h</mi> <mi>t</mi> <mrow><mo>(</mo> <mi>e</mi> <mi>x</mi> <mi>a</mi> <mi>c</mi>
    <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub> <mfrac><msub><mi>m</mi>
    <mi>l</mi></msub> <msub><mi>u</mi> <mi>l</mi></msub></mfrac> <mo>≈</mo> <mn>10</mn>
    <mo>.</mo> <mn>23</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper L a s t n a m e m a t c h w e i g h t left-parenthesis
    n o t e x a c t m a t c h right-parenthesis equals l o g 2 StartFraction left-parenthesis
    1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis 1 minus
    u Subscript l Baseline right-parenthesis EndFraction almost-equals negative 7.32"><mrow><mi>L</mi>
    <mi>a</mi> <mi>s</mi> <mi>t</mi> <mi>n</mi> <mi>a</mi> <mi>m</mi> <mi>e</mi> <mi>m</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>w</mi> <mi>e</mi> <mi>i</mi> <mi>g</mi>
    <mi>h</mi> <mi>t</mi> <mrow><mo>(</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>e</mi>
    <mi>x</mi> <mi>a</mi> <mi>c</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi>
    <mi>h</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi>
    <mn>2</mn></msub> <mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac> <mo>≈</mo> <mo>-</mo> <mn>7</mn> <mo>.</mo>
    <mn>32</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper C o n s t i t u e n c y m a t c h w e i g h t left-parenthesis
    e x a c t m a t c h right-parenthesis equals l o g 2 StartFraction m Subscript
    c Baseline Over u Subscript c Baseline EndFraction almost-equals 14.98"><mrow><mi>C</mi>
    <mi>o</mi> <mi>n</mi> <mi>s</mi> <mi>t</mi> <mi>i</mi> <mi>t</mi> <mi>u</mi> <mi>e</mi>
    <mi>n</mi> <mi>c</mi> <mi>y</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi>
    <mi>w</mi> <mi>e</mi> <mi>i</mi> <mi>g</mi> <mi>h</mi> <mi>t</mi> <mrow><mo>(</mo>
    <mi>e</mi> <mi>x</mi> <mi>a</mi> <mi>c</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi>
    <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi>
    <mn>2</mn></msub> <mfrac><msub><mi>m</mi> <mi>c</mi></msub> <msub><mi>u</mi> <mi>c</mi></msub></mfrac>
    <mo>≈</mo> <mn>14</mn> <mo>.</mo> <mn>98</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: For illustration purposes, Splink approximates the `Constituency` not exact
    match weight as negative infinity and displays it in a different color. This is
    because there are no cases where the `Firstname` and `Lastname` attributes match
    but the `Constituency` does not.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the discrete values Splink has calculated using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The *m* and *u* probabilities match those we calculated manually using the expectation-maximization
    algorithm earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, as before, we apply a threshold match probability and select the record
    pair above the threshold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Analysis of these predictions shows that all 633 are true positives, leaving
    the 13 by-election true negatives and 4 false negatives. We can view the 4 false
    negatives with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The output, shown in [Figure 4-8](#fig-4-8), shows that the mismatch on `Lastname`
    is the reason these entities fall below the match threshold.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_0408.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-8\. Splink below the threshold due to `Lastname` mismatch
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In comparison to the unweighted results in [Chapter 3](ch03.html#chapter_3),
    Splink declares a match for “Liz Truss” versus “Elizabeth Truss,” but does not
    match “Anne Marie Morris” to “Anne Morris,” nor “Martin Docherty-Hughes” to “Martin
    Docherty.” This is because it is  more heavily influenced by a mismatch on `Lastname`,
    which is statistically a better negative predictor, than a mismatch on `Firstname`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To recap, we took two sets of records and combined them into a composite dataset
    containing every record pair combination. We then computed exact match features
    between equivalent fields and then combined those features, weighted according
    to how often they occurred in both the matching and nonmatching populations, to
    determine the overall likelihood of a match.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to use probability theory to calculate the match weights using the
    iterative expectation-maximization algorithm when we don’t have known `match`
    populations.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we introduced the probabilistic entity resolution framework Splink,
    which greatly simplified the calculations when combining multiple attributes and
    helped us visualize and understand our match results.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have worked through a small-scale example, we will apply the techniques
    of approximate and probabilistic matching on a larger scale.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch04.html#id429-marker)) The original paper is available [online](https://oreil.ly/gcfWx).
  prefs: []
  type: TYPE_NORMAL
