- en: Chapter 4\. Probabilistic Matching
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 概率匹配
- en: In [Chapter 3](ch03.html#chapter_3), we explored how to use approximate matching
    techniques to measure the degree of similarity between attribute values. We set
    a threshold above which we declared equivalence and then combined these matching
    features, with equal weight, to conclude that two records referred to the same
    entity when both were a match. We evaluated our performance against exact matches
    only.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html#chapter_3)中，我们探讨了如何使用近似匹配技术来衡量属性值之间的相似程度。我们设定了一个阈值，超过此阈值我们宣布它们等价，并将这些匹配特征以相等的权重结合起来，以确定两条记录指代同一实体。我们仅针对精确匹配评估了我们的性能。
- en: In this chapter, we will examine how to use probability-based techniques to
    calculate the optimum weighting for each equivalent attribute in calculating the
    likelihood of an overall entity match. This probability-based approach allows
    us to declare a match when the most statistically significant attributes are equivalent
    (either exact or approximate) but those with less significance are insufficiently
    similar. It also allows us to grade our confidence in the declaration of a match
    and apply appropriate match thresholds. The model that will be introduced in this
    section is known as the Fellegi-Sunter (FS) model.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将探讨如何使用基于概率的技术来计算每个等效属性的最佳加权，以计算整体实体匹配的可能性。这种基于概率的方法允许我们在最具统计显著性的属性等价（精确或近似）时宣布匹配，但那些重要性较低的属性不足够相似时则不匹配。它还允许我们对匹配声明的信心进行分级，并应用适当的匹配阈值。本节将介绍的模型被称为Fellegi-Sunter（FS）模型。
- en: We will also introduce a probabilistic entity resolution framework, Splink,
    that we will use to help us calculate these metrics and resolve our entities together.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍一种概率实体解析框架Splink，该框架将帮助我们计算这些指标并解决我们的实体问题。
- en: Sample Problem
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例问题
- en: 'Let’s return to our exact match results from the end of [Chapter 2](ch02.html#chapter_2).
    Opening the *Chapter4.ipynb* notebook we reload the standardized datasets from
    the Wikipedia and TheyWorkForYou websites. As in [Chapter 3](ch03.html#chapter_3),
    we start by calculating the Cartesian, or cross, product of the two datasets as:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到从[第2章](ch02.html#chapter_2)末尾的精确匹配结果。打开*Chapter4.ipynb*笔记本，我们重新加载维基百科和TheyWorkForYou网站的标准化数据集。与[第3章](ch03.html#chapter_3)一样，我们首先通过以下方式计算两个数据集的笛卡尔积或交叉乘积：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This gives us our total population of 650 × 650 = 422,500 record pairs—a pair
    for every name combination between the Wikipedia and TheyWorkForYou datasets.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了650 × 650 = 422,500对记录的总人口——维基百科和TheyWorkForYou数据集之间每个姓名组合的一对。
- en: 'Throughout this chapter, we will be using exact matches between the `Firstname`,
    `Lastname`, and `Constituency` fields of each of these record pairs multiple times.
    Thus, it’s more efficient to calculate these matches once and store them as additional
    feature columns:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将多次使用每个记录对的`Firstname`、`Lastname`和`Constituency`字段之间的精确匹配。因此，一次计算这些匹配并将它们存储为额外的特征列更为高效：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We also calculate the total number of matching columns, which we will use later:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还计算了后续将使用的匹配列的总数：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Based on our exploration of the data in [Chapter 2](ch02.html#chapter_2), we
    know that within our total population of 422,500 combinations we have 637 record
    pairs that have an exact match on constituency and either first name or last name.
    This is our `match` population:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在[第2章](ch02.html#chapter_2)中对数据的探索，我们知道在总共422,500个组合中，有637对记录具有选区和名字中的第一个名字或姓氏的精确匹配。这是我们的`match`人口：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The remainder, our `notmatch` population, is extracted as the inverse:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的`notmatch`人口则是反向提取：
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These combinations are summarized in [Table 4-1](#table-4-1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组合总结在[表 4-1](#table-4-1)中。
- en: Table 4-1\. Match and not match combinations
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Table 4-1\. 匹配与不匹配的组合
- en: '| Match/not match population | Constituency match | First name match | Last
    name match |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 匹配/不匹配人口 | 选区匹配 | 第一个名字匹配 | 姓氏匹配 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Not match | No | No | No |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 不匹配 | 否 | 否 | 否 |'
- en: '| Not match | No | No | Yes |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 不匹配 | 否 | 否 | 是 |'
- en: '| Not match | No | Yes | No |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 不匹配 | 否 | 是 | 否 |'
- en: '| Not match | No | Yes | Yes |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 不匹配 | 否 | 是 | 是 |'
- en: '| Not match | Yes | No | No |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 不匹配 | 是 | 否 | 否 |'
- en: '| Match | Yes | No | Yes |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 匹配 | 是 | 否 | 是 |'
- en: '| Match | Yes | Yes | No |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 匹配 | 是 | 是 | 否 |'
- en: '| Match | Yes | Yes | Yes |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 匹配 | 是 | 是 | 是 |'
- en: We will now examine how well first name and last name equivalence, both individually
    and together, can predict whether an individual record belongs in either the `match`
    or `notmatch` population.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将检查名字和姓氏等价性，无论是单独还是一起，能多大程度上预测一个个体记录应属于`match`或`notmatch`人群。
- en: Single Attribute Match Probability
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单属性匹配概率
- en: Let’s begin by considering whether first name equivalence alone is a good indicator
    that two entities within a record pair refer to the same person. We will examine
    both the `match` and `notmatch` populations and establish, within each of those
    subsets, how many first names match and how many do not.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先考虑单单以名字等价作为一个记录对中的两个实体是否指向同一个人的良好指标。我们将检查`match`和`notmatch`人群，并在每个子集内部建立，有多少个名字匹配和多少个不匹配。
- en: Naming Convention
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名约定
- en: As we work through various subsets of these populations, it’s helpful to adopt
    a standard naming convention so that we can see at a glance how each population
    of records was selected. As we select records we add the selection criteria to
    the population name, right to left, e.g., `first_match` should be read as first
    selecting those records that are part of the `match` population and within that
    subset of the population further selecting only those rows where the first names
    are equivalent.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理这些人群的各种子集时，采用标准的命名约定是有帮助的，这样我们可以一眼看出每个记录人群是如何被选中的。当我们选择记录时，我们将选择标准添加到人群名称中，从右向左添加，例如，`first_match`应该被理解为首先选择那些属于`match`人群的记录，并在该人群子集中进一步选择只有名字相等的行。
- en: First Name Match Probability
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名字匹配概率
- en: 'Starting with the `match` population we can select those records where the
    first names are equivalent to give us our `first_match` population:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从`match`人群开始，我们可以选择那些名字等于的记录，以获得我们的`first_match`人群：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Repeating this for the three other combinations of match/not match, and first
    name equivalence or not, we can draw up a population map, as shown in [Figure 4-1](#fig-4-1).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他三种匹配/不匹配组合以及名字等价性或非等价性的重复，我们可以制作一个人口分布图，如[图 4-1](#fig-4-1)所示。
- en: '![](assets/hoer_0401.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0401.png)'
- en: Figure 4-1\. First name population map
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1\. 名字人口分布图
- en: 'Therefore, based on first name equivalence only, we have:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基于名字等价性，我们有：
- en: <math alttext="upper T r u e p o s i t i v e m a t c h e s left-parenthesis
    upper T upper P right-parenthesis equals 632"><mrow><mi>T</mi> <mi>r</mi> <mi>u</mi>
    <mi>e</mi> <mi>p</mi> <mi>o</mi> <mi>s</mi> <mi>i</mi> <mi>t</mi> <mi>i</mi> <mi>v</mi>
    <mi>e</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>e</mi> <mi>s</mi>
    <mo>(</mo> <mi>T</mi> <mi>P</mi> <mo>)</mo> <mo>=</mo> <mn>632</mn></mrow></math>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper T r u e p o s i t i v e m a t c h e s left-parenthesis
    upper T upper P right-parenthesis equals 632"><mrow><mi>T</mi> <mi>r</mi> <mi>u</mi>
    <mi>e</mi> <mi>p</mi> <mi>o</mi> <mi>s</mi> <mi>i</mi> <mi>t</mi> <mi>i</mi> <mi>v</mi>
    <mi>e</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>e</mi> <mi>s</mi>
    <mo>(</mo> <mi>T</mi> <mi>P</mi> <mo>)</mo> <mo>=</mo> <mn>632</mn></mrow></math>
- en: <math alttext="upper F a l s e p o s i t i v e m a t c h e s left-parenthesis
    upper F upper P right-parenthesis equals 2052"><mrow><mi>F</mi> <mi>a</mi> <mi>l</mi>
    <mi>s</mi> <mi>e</mi> <mi>p</mi> <mi>o</mi> <mi>s</mi> <mi>i</mi> <mi>t</mi> <mi>i</mi>
    <mi>v</mi> <mi>e</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>e</mi>
    <mi>s</mi> <mo>(</mo> <mi>F</mi> <mi>P</mi> <mo>)</mo> <mo>=</mo> <mn>2052</mn></mrow></math>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper F a l s e p o s i t i v e m a t c h e s left-parenthesis
    upper F upper P right-parenthesis equals 2052"><mrow><mi>F</mi> <mi>a</mi> <mi>l</mi>
    <mi>s</mi> <mi>e</mi> <mi>p</mi> <mi>o</mi> <mi>s</mi> <mi>i</mi> <mi>t</mi> <mi>i</mi>
    <mi>v</mi> <mi>e</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>e</mi>
    <mi>s</mi> <mo>(</mo> <mi>F</mi> <mi>P</mi> <mo>)</mo> <mo>=</mo> <mn>2052</mn></mrow></math>
- en: <math alttext="upper T r u e n e g a t i v e m a t c h e s left-parenthesis
    upper T upper N right-parenthesis equals 419811"><mrow><mi>T</mi> <mi>r</mi> <mi>u</mi>
    <mi>e</mi> <mi>n</mi> <mi>e</mi> <mi>g</mi> <mi>a</mi> <mi>t</mi> <mi>i</mi> <mi>v</mi>
    <mi>e</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>e</mi> <mi>s</mi>
    <mo>(</mo> <mi>T</mi> <mi>N</mi> <mo>)</mo> <mo>=</mo> <mn>419811</mn></mrow></math>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper T r u e n e g a t i v e m a t c h e s left-parenthesis
    upper T upper N right-parenthesis equals 419811"><mrow><mi>T</mi> <mi>r</mi> <mi>u</mi>
    <mi>e</mi> <mi>n</mi> <mi>e</mi> <mi>g</mi> <mi>a</mi> <mi>t</mi> <mi>i</mi> <mi>v</mi>
    <mi>e</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>e</mi> <mi>s</mi>
    <mo>(</mo> <mi>T</mi> <mi>N</mi> <mo>)</mo> <mo>=</mo> <mn>419811</mn></mrow></math>
- en: <math alttext="upper F a l s e n e g a t i v e m a t c h e s left-parenthesis
    upper F upper N right-parenthesis equals 5"><mrow><mi>F</mi> <mi>a</mi> <mi>l</mi>
    <mi>s</mi> <mi>e</mi> <mi>n</mi> <mi>e</mi> <mi>g</mi> <mi>a</mi> <mi>t</mi> <mi>i</mi>
    <mi>v</mi> <mi>e</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>e</mi>
    <mi>s</mi> <mo>(</mo> <mi>F</mi> <mi>N</mi> <mo>)</mo> <mo>=</mo> <mn>5</mn></mrow></math>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper F a l s e n e g a t i v e m a t c h e s left-parenthesis
    upper F upper N right-parenthesis equals 5"><mrow><mi>F</mi> <mi>a</mi> <mi>l</mi>
    <mi>s</mi> <mi>e</mi> <mi>n</mi> <mi>e</mi> <mi>g</mi> <mi>a</mi> <mi>t</mi> <mi>i</mi>
    <mi>v</mi> <mi>e</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>e</mi>
    <mi>s</mi> <mo>(</mo> <mi>F</mi> <mi>N</mi> <mo>)</mo> <mo>=</mo> <mn>5</mn></mrow></math>
- en: 'Now we can calculate some probability values. First, the probability that a
    record pair whose first names are equivalent is actually a true positive match
    can be calculated as the number of pairs within the `match` population whose first
    names match divided by the number of pairs whose first names match across both
    the `match` and `notmatch` populations:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以计算一些概率值。首先，一个名字等价的记录对实际上是真正匹配的概率可以计算为在`match`人群中，名字匹配的记录对数除以在`match`和`notmatch`人群中名字匹配的记录对数：
- en: <math alttext="p r o b normal bar m a t c h normal bar f i r s t equals StartFraction
    l e n left-parenthesis f i r s t normal bar m a t c h right-parenthesis Over left-parenthesis
    l e n left-parenthesis f i r s t normal bar m a t c h right-parenthesis plus l
    e n left-parenthesis f i r s t normal bar n o t m a t c h right-parenthesis right-parenthesis
    EndFraction equals StartFraction 632 Over left-parenthesis 632 plus 2052 right-parenthesis
    EndFraction almost-equals 0.2355"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi>
    <mo>_</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>_</mo> <mi>f</mi>
    <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>=</mo> <mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mfrac><mn>632</mn> <mrow><mo>(</mo><mn>632</mn><mo>+</mo><mn>2052</mn><mo>)</mo></mrow></mfrac>
    <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>2355</mn></mrow></math>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="p r o b normal bar m a t c h normal bar f i r s t equals StartFraction
    l e n left-parenthesis f i r s t normal bar m a t c h right-parenthesis Over left-parenthesis
    l e n left-parenthesis f i r s t normal bar m a t c h right-parenthesis plus l
    e n left-parenthesis f i r s t normal bar n o t m a t c h right-parenthesis right-parenthesis
    EndFraction equals StartFraction 632 Over left-parenthesis 632 plus 2052 right-parenthesis
    EndFraction almost-equals 0.2355"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi>
    <mo>_</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>_</mo> <mi>f</mi>
    <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>=</mo> <mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mfrac><mn>632</mn> <mrow><mo>(</mo><mn>632</mn><mo>+</mo><mn>2052</mn><mo>)</mo></mrow></mfrac>
    <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>2355</mn></mrow></math>
- en: 'From this we can see that, at only about 23%, first name equivalence alone
    isn’t a great predictor of a match between two records. This value is a conditional
    probability, that is, it is the probability of a true positive match conditional
    on the first name being a match. This can be written as:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从中可以看出，仅有约23%的名字等价性并不是两个记录匹配的很好预测器。这个值是一个条件概率，即在名字匹配的条件下是真正匹配的概率。可以写成：
- en: <math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis"><mrow><mi>P</mi>
    <mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo> <mi>f</mi>
    <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow></math>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis"><mrow><mi>P</mi>
    <mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo> <mi>f</mi>
    <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow></math>
- en: where the pipe character (|) is read as “given that.”
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 管道字符（|）被读作“给定于”。
- en: Last Name Match Probability
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 姓氏匹配概率
- en: Applying the same calculations to the last name, we can draw a second population
    map, as shown in [Figure 4-2](#fig-4-2).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将相同的计算应用于姓氏，我们可以制作第二个人口分布图，如[图 4-2](#fig-4-2)所示。
- en: '![](assets/hoer_0402.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0402.png)'
- en: Figure 4-2\. Last name population map
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2\. 姓氏人口分布图
- en: As for first name, the probability that a pair of records whose last names are
    equivalent is actually a match can be calculated as the number of pairs within
    the `match` population whose last names match divided by the number of pairs whose
    last names match across both the `match` and `notmatch` populations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 至于名字，一个姓氏等价的记录对实际上是匹配的概率可以计算为在`match`人群中，姓氏匹配的记录对数除以在`match`和`notmatch`人群中姓氏匹配的记录对数。
- en: <math alttext="p r o b normal bar m a t c h normal bar l a s t equals StartFraction
    l e n left-parenthesis l a s t normal bar m a t c h right-parenthesis Over left-parenthesis
    l e n left-parenthesis l a s t normal bar m a t c h right-parenthesis plus l e
    n left-parenthesis l a s t normal bar n o t m a t c h right-parenthesis right-parenthesis
    EndFraction equals StartFraction 633 Over left-parenthesis 633 plus 349 right-parenthesis
    EndFraction almost-equals 0.6446"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi>
    <mo>_</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>_</mo> <mi>l</mi>
    <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>=</mo> <mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mfrac><mn>633</mn> <mrow><mo>(</mo><mn>633</mn><mo>+</mo><mn>349</mn><mo>)</mo></mrow></mfrac>
    <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>6446</mn></mrow></math>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="p r o b normal bar m a t c h normal bar l a s t equals StartFraction
    l e n left-parenthesis l a s t normal bar m a t c h right-parenthesis Over left-parenthesis
    l e n left-parenthesis l a s t normal bar m a t c h right-parenthesis plus l e
    n left-parenthesis l a s t normal bar n o t m a t c h right-parenthesis right-parenthesis
    EndFraction equals StartFraction 633 Over left-parenthesis 633 plus 349 right-parenthesis
    EndFraction almost-equals 0.6446"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi>
    <mo>_</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>_</mo> <mi>l</mi>
    <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>=</mo> <mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mfrac><mn>633</mn> <mrow><mo>(</mo><mn>633</mn><mo>+</mo><mn>349</mn><mo>)</mo></mrow></mfrac>
    <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>6446</mn></mrow></math>
- en: For these records last name equivalence is clearly a better predictor of a true
    match than first name, which instinctively makes sense.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些记录来说，姓氏等价性显然是一个比名字更好的真实匹配预测器，这从直觉上讲是有道理的。
- en: 'Again, this can be written as:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这可以写成：
- en: <math alttext="upper P left-parenthesis m a t c h vertical-bar l a s t right-parenthesis"><mrow><mi>P</mi>
    <mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo> <mi>l</mi>
    <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow></math>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis m a t c h vertical-bar l a s t right-parenthesis"><mrow><mi>P</mi>
    <mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo> <mi>l</mi>
    <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow></math>
- en: Multiple Attribute Match Probability
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多属性匹配概率
- en: Now if we consider both first name and last name equivalence we can further
    subdivide our population map. Starting with our first name map and further subdividing
    each first name category into last name equivalence, and not, we can view our
    population as shown in [Figure 4-3](#fig-4-3).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们考虑同时名字和姓氏的等效性，我们可以进一步将我们的人口地图细分。从我们的名字地图开始，进一步将每个名字类别细分为姓氏等效和非等效，我们可以查看我们的人口如[图4-3](#fig-4-3)所示。
- en: '![](assets/hoer_0403.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0403.png)'
- en: Figure 4-3\. First name, last name population map
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-3\. 名字，姓氏人口地图
- en: 'Extending our calculation to both first name and last name exact matches, we
    can calculate the probability of a true positive match given both first name and
    last name equivalence as:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的计算扩展到同时名字和姓氏完全匹配，我们可以计算给定名字和姓氏等效的真正正匹配的概率为：
- en: <math alttext="p r o b normal bar m a t c h normal bar l a s t normal bar f
    i r s t equals StartFraction l e n left-parenthesis l a s t normal bar f i r s
    t normal bar m a t c h right-parenthesis Over left-parenthesis l e n left-parenthesis
    l a s t normal bar f i r s t normal bar m a t c h right-parenthesis plus l e n
    left-parenthesis l a s t normal bar f i r s t normal bar n o t m a t c h right-parenthesis
    EndFraction equals StartFraction 628 Over left-parenthesis 628 plus 0 right-parenthesis
    EndFraction equals 1.0"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mo>_</mo>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>_</mo> <mi>l</mi> <mi>a</mi>
    <mi>s</mi> <mi>t</mi> <mo>_</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi>
    <mo>=</mo> <mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mfrac><mn>628</mn> <mrow><mo>(</mo><mn>628</mn><mo>+</mo><mn>0</mn><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mn>1</mn> <mo>.</mo> <mn>0</mn></mrow></math>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="p r o b normal bar m a t c h normal bar l a s t normal bar f
    i r s t equals StartFraction l e n left-parenthesis l a s t normal bar f i r s
    t normal bar m a t c h right-parenthesis Over left-parenthesis l e n left-parenthesis
    l a s t normal bar f i r s t normal bar m a t c h right-parenthesis plus l e n
    left-parenthesis l a s t normal bar f i r s t normal bar n o t m a t c h right-parenthesis
    EndFraction equals StartFraction 628 Over left-parenthesis 628 plus 0 right-parenthesis
    EndFraction equals 1.0"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mo>_</mo>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>_</mo> <mi>l</mi> <mi>a</mi>
    <mi>s</mi> <mi>t</mi> <mo>_</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi>
    <mo>=</mo> <mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mfrac><mn>628</mn> <mrow><mo>(</mo><mn>628</mn><mo>+</mo><mn>0</mn><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mn>1</mn> <mo>.</mo> <mn>0</mn></mrow></math>
- en: If the first name matches but last name doesn’t, what is the probability that
    it’s a match?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果名字匹配但姓氏不匹配，那么它是匹配的概率是多少？
- en: <math alttext="p r o b normal bar m a t c h normal bar n o t l a s t normal
    bar f i r s t equals StartFraction l e n left-parenthesis n o t l a s t normal
    bar f i r s t normal bar m a t c h right-parenthesis Over left-parenthesis l e
    n left-parenthesis n o t l a s t normal bar f i r s t normal bar m a t c h right-parenthesis
    plus l e n left-parenthesis n o t l a s t normal bar f i r s t normal bar n o
    t m a t c h right-parenthesis right-parenthesis EndFraction equals StartFraction
    4 Over left-parenthesis 4 plus 2052 right-parenthesis EndFraction almost-equals
    0.0019"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mo>_</mo> <mi>m</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>_</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi>
    <mi>l</mi> <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>_</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi>
    <mi>s</mi> <mi>t</mi> <mo>=</mo> <mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mfrac><mn>4</mn> <mrow><mo>(</mo><mn>4</mn><mo>+</mo><mn>2052</mn><mo>)</mo></mrow></mfrac>
    <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>0019</mn></mrow></math>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="p r o b normal bar m a t c h normal bar n o t l a s t normal
    bar f i r s t equals StartFraction l e n left-parenthesis n o t l a s t normal
    bar f i r s t normal bar m a t c h right-parenthesis Over left-parenthesis l e
    n left-parenthesis n o t l a s t normal bar f i r s t normal bar m a t c h right-parenthesis
    plus l e n left-parenthesis n o t l a s t normal bar f i r s t normal bar n o
    t m a t c h right-parenthesis right-parenthesis EndFraction equals StartFraction
    4 Over left-parenthesis 4 plus 2052 right-parenthesis EndFraction almost-equals
    0.0019"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mo>_</mo> <mi>m</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>_</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi>
    <mi>l</mi> <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>_</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi>
    <mi>s</mi> <mi>t</mi> <mo>=</mo> <mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mfrac><mn>4</mn> <mrow><mo>(</mo><mn>4</mn><mo>+</mo><mn>2052</mn><mo>)</mo></mrow></mfrac>
    <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>0019</mn></mrow></math>
- en: If the first name doesn’t match but the last name does, what is the probability
    that it’s a match?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果名字不匹配但姓氏匹配，那么它是匹配的概率是多少？
- en: <math alttext="p r o b normal bar m a t c h normal bar l a s t normal bar n
    o t f i r s t equals StartFraction l e n left-parenthesis l a s t normal bar n
    o t f i r s t normal bar m a t c h right-parenthesis Over left-parenthesis l e
    n left-parenthesis l a s t normal bar n o t f i r s t normal bar m a t c h right-parenthesis
    plus l e n left-parenthesis l a s t normal bar n o t f i r s t normal bar n o
    t m a t c h right-parenthesis right-parenthesis EndFraction equals StartFraction
    5 Over left-parenthesis 5 plus 349 right-parenthesis EndFraction almost-equals
    0.0141"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mo>_</mo> <mi>m</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>_</mo> <mi>l</mi> <mi>a</mi> <mi>s</mi>
    <mi>t</mi> <mo>_</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>f</mi> <mi>i</mi> <mi>r</mi>
    <mi>s</mi> <mi>t</mi> <mo>=</mo> <mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mfrac><mn>5</mn> <mrow><mo>(</mo><mn>5</mn><mo>+</mo><mn>349</mn><mo>)</mo></mrow></mfrac>
    <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>0141</mn></mrow></math>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="p r o b normal bar m a t c h normal bar l a s t normal bar n
    o t f i r s t equals StartFraction l e n left-parenthesis l a s t normal bar n
    o t f i r s t normal bar m a t c h right-parenthesis Over left-parenthesis l e
    n left-parenthesis l a s t normal bar n o t f i r s t normal bar m a t c h right-parenthesis
    plus l e n left-parenthesis l a s t normal bar n o t f i r s t normal bar n o
    t m a t c h right-parenthesis right-parenthesis EndFraction equals StartFraction
    5 Over left-parenthesis 5 plus 349 right-parenthesis EndFraction almost-equals
    0.0141"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mo>_</mo> <mi>m</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>_</mo> <mi>l</mi> <mi>a</mi> <mi>s</mi>
    <mi>t</mi> <mo>_</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>f</mi> <mi>i</mi> <mi>r</mi>
    <mi>s</mi> <mi>t</mi> <mo>=</mo> <mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mfrac><mn>5</mn> <mrow><mo>(</mo><mn>5</mn><mo>+</mo><mn>349</mn><mo>)</mo></mrow></mfrac>
    <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>0141</mn></mrow></math>
- en: As we expected, if either first name or last name isn’t an exact match, then
    the probability of a true positive match is low, but a last name match gives us
    more confidence than a first name one.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的那样，如果名字或姓氏任一不完全匹配，那么真正正匹配的概率是低的，但姓氏匹配比名字匹配给我们更多的信心。
- en: 'If neither first name nor last name matches, the probability that it is a match
    is:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果既没有名字匹配也没有姓氏匹配，那么它是匹配的概率是多少？
- en: <math alttext="p r o b normal bar m a t c h normal bar n o t l a s t normal
    bar n o t f i r s t equals"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi>
    <mo>_</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>_</mo> <mi>n</mi>
    <mi>o</mi> <mi>t</mi> <mi>l</mi> <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>_</mo> <mi>n</mi>
    <mi>o</mi> <mi>t</mi> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>=</mo></mrow></math>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="p r o b normal bar m a t c h normal bar n o t l a s t normal
    bar n o t f i r s t equals"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi>
    <mo>_</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>_</mo> <mi>n</mi>
    <mi>o</mi> <mi>t</mi> <mi>l</mi> <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>_</mo> <mi>n</mi>
    <mi>o</mi> <mi>t</mi> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>=</mo></mrow></math>
- en: <math alttext="StartFraction l e n left-parenthesis n o t l a s t normal bar
    n o t f i r s t normal bar m a t c h right-parenthesis Over left-parenthesis l
    e n left-parenthesis n o t l a s t normal bar n o t f i r s t normal bar m a t
    c h right-parenthesis plus l e n left-parenthesis n o t l a s t normal bar n o
    t f i r s t normal bar n o t m a t c h right-parenthesis right-parenthesis EndFraction
    equals StartFraction 0 Over left-parenthesis 0 plus 419462 right-parenthesis EndFraction
    equals 0"><mrow><mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mfrac><mn>0</mn> <mrow><mo>(</mo><mn>0</mn><mo>+</mo><mn>419462</mn><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mn>0</mn></mrow></math>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction l e n left-parenthesis n o t l a s t normal bar
    n o t f i r s t normal bar m a t c h right-parenthesis Over left-parenthesis l
    e n left-parenthesis n o t l a s t normal bar n o t f i r s t normal bar m a t
    c h right-parenthesis plus l e n left-parenthesis n o t l a s t normal bar n o
    t f i r s t normal bar n o t m a t c h right-parenthesis right-parenthesis EndFraction
    equals StartFraction 0 Over left-parenthesis 0 plus 419462 right-parenthesis EndFraction
    equals 0"><mrow><mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mfrac><mn>0</mn> <mrow><mo>(</mo><mn>0</mn><mo>+</mo><mn>419462</mn><mo>)</mo></mrow></mfrac>
    <mo>=</mo> <mn>0</mn></mrow></math>
- en: This is not surprising given that we defined true positive matches as records
    with an exact match on constituency and either first name or last name.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不奇怪，因为我们定义了真正正匹配为在成分上具有完全匹配和名字或姓氏之一的记录。
- en: In conclusion, we can use these probabilities to inform our decision making
    on whether we are likely to have a true positive match or not. In this example,
    we would place more weight on a last name match than a first name one. This is
    an improvement on our method in [Chapter 3](ch03.html#chapter_3), where we gave
    them the same weighting (and required them both to be equivalent) to declare a
    match.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们可以利用这些概率来指导我们是否可能有一个真正的正匹配。在这个例子中，我们会更加重视姓氏匹配而不是名字匹配。这是我们在[第三章](ch03.html#chapter_3)中方法的改进，我们在那里给了它们相同的权重（并要求它们都等效）来声明匹配。
- en: But wait, we have a problem. In the preceding example, we started with a known
    population of matches that we used to compute the probabilities that first name
    and last name equivalence equate to a match. However, in most situations we don’t
    have a known `match` population; otherwise we wouldn’t need to perform matching
    in the first place! How do we overcome this? To do so, we need to reframe our
    calculation a little and then employ some clever estimation techniques.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等，我们有一个问题。在前面的例子中，我们从已知的匹配人口开始，用于计算名字和姓氏等效是否等于匹配的概率。然而，在大多数情况下，我们没有已知的`match`人口；否则我们一开始就不需要执行匹配！我们如何克服这一点呢？为了做到这一点，我们需要稍微重新构思我们的计算，然后使用一些聪明的估算技术。
- en: Probabilistic Models
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概率模型
- en: In the previous section, we learned that some attributes are more informative
    than others; that is, they have more predictive power to help us decide whether
    a match is likely to be correct. In this section, we examine how to calculate
    these contributions and how to combine them to assess the overall likelihood of
    a match.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们了解到一些属性比其他属性更具信息量；也就是说，它们具有更多预测能力来帮助我们决定匹配是否可能是正确的。在本节中，我们将探讨如何计算这些贡献以及如何结合它们来评估匹配的总体可能性。
- en: We start with a little statistical theory (using first name equivalence as an
    example) before we generalize to model what we can deploy at scale.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先从一点统计理论开始（以使用名字相等为例），然后我们将其推广为我们可以大规模部署的模型。
- en: Bayes’ Theorem
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 贝叶斯定理
- en: '*Bayes’ theorem*, named after Thomas Bayes, states that the conditional probability
    of an event, based on the occurrence of another event, is equal to the probability
    of the second event given the first event, multiplied by the probability of the
    first event.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*贝叶斯定理*，以托马斯·贝叶斯命名，陈述了一个事件的条件概率，基于另一个事件的发生，等于第一个事件的概率乘以第二个事件发生的概率。'
- en: 'Consider the probability that two records chosen at random are a true positive
    match, P(match), multiplied by the probability that within those matches the first
    names match, P (first|match):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑随机选择两条记录是真正正匹配的概率P(match)，乘以在这些匹配中名字匹配的概率P(first|match)：
- en: <math alttext="upper P left-parenthesis f i r s t vertical-bar m a t c h right-parenthesis
    times upper P left-parenthesis m a t c h right-parenthesis"><mrow><mi>P</mi> <mo>(</mo>
    <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>m</mi> <mi>a</mi>
    <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo> <mo>×</mo> <mi>P</mi> <mo>(</mo> <mi>m</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow></math>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis f i r s t vertical-bar m a t c h right-parenthesis
    times upper P left-parenthesis m a t c h right-parenthesis"><mrow><mi>P</mi> <mo>(</mo>
    <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>m</mi> <mi>a</mi>
    <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo> <mo>×</mo> <mi>P</mi> <mo>(</mo> <mi>m</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow></math>
- en: 'Equally, we could calculate the same value in the reverse order, starting with
    the probability that the first name matches, P(first) multiplied by the probability
    that records within this population are a true positive match:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们可以按相反顺序计算相同的值，从匹配的第一个名字的概率开始，乘以此人口内的记录是真正的正匹配的概率：
- en: <math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis
    times upper P left-parenthesis f i r s t right-parenthesis"><mrow><mi>P</mi> <mo>(</mo>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi>
    <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo> <mo>×</mo> <mi>P</mi> <mo>(</mo> <mi>f</mi>
    <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow></math>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis
    times upper P left-parenthesis f i r s t right-parenthesis"><mrow><mi>P</mi> <mo>(</mo>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi>
    <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo> <mo>×</mo> <mi>P</mi> <mo>(</mo> <mi>f</mi>
    <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow></math>
- en: 'Equating these probabilities, we have:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 等价这些概率，我们有：
- en: <math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis
    times upper P left-parenthesis f i r s t right-parenthesis equals upper P left-parenthesis
    f i r s t vertical-bar m a t c h right-parenthesis times upper P left-parenthesis
    m a t c h right-parenthesis"><mrow><mi>P</mi> <mo>(</mo> <mi>m</mi> <mi>a</mi>
    <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi>
    <mi>t</mi> <mo>)</mo> <mo>×</mo> <mi>P</mi> <mo>(</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi>
    <mi>s</mi> <mi>t</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>f</mi> <mi>i</mi>
    <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi>
    <mi>h</mi> <mo>)</mo> <mo>×</mo> <mi>P</mi> <mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi>
    <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow></math>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis
    times upper P left-parenthesis f i r s t right-parenthesis equals upper P left-parenthesis
    f i r s t vertical-bar m a t c h right-parenthesis times upper P left-parenthesis
    m a t c h right-parenthesis"><mrow><mi>P</mi> <mo>(</mo> <mi>m</mi> <mi>a</mi>
    <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi>
    <mi>t</mi> <mo>)</mo> <mo>×</mo> <mi>P</mi> <mo>(</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi>
    <mi>s</mi> <mi>t</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>f</mi> <mi>i</mi>
    <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi>
    <mi>h</mi> <mo>)</mo> <mo>×</mo> <mi>P</mi> <mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi>
    <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow></math>
- en: 'Rearranging we can calculate:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 重新排列后，我们可以计算：
- en: <math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis
    equals StartFraction upper P left-parenthesis f i r s t vertical-bar m a t c h
    right-parenthesis times upper P left-parenthesis m a t c h right-parenthesis Over
    upper P left-parenthesis f i r s t right-parenthesis EndFraction"><mrow><mi>P</mi>
    <mrow><mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo>
    <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mfrac><mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>×</mo><mi>P</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>)</mo></mrow></mfrac></mrow></math>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis
    equals StartFraction upper P left-parenthesis f i r s t vertical-bar m a t c h
    right-parenthesis times upper P left-parenthesis m a t c h right-parenthesis Over
    upper P left-parenthesis f i r s t right-parenthesis EndFraction"><mrow><mi>P</mi>
    <mrow><mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo>
    <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mfrac><mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>×</mo><mi>P</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>)</mo></mrow></mfrac></mrow></math>
- en: 'We can calculate P(first) as the sum of the probabilities across both the `match`
    and `notmatch` populations:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以计算P(first)为`match`和`notmatch`人口的概率之和：
- en: <math display="block"><mtable columnalign="right left" displaystyle="true"><mtr><mtd
    class="tml-right" style="padding:0.7ex 0em 0.7ex 0em;"><mrow><mi>P</mi> <mo form="prefix"
    stretchy="false">(</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi>
    <mo form="postfix" stretchy="false">)</mo></mrow></mtd> <mtd class="tml-left"
    style="padding:0.7ex 0em 0.7ex 0em;"><mrow><mo>=</mo> <mo form="prefix" stretchy="false">(</mo>
    <mi>P</mi> <mo form="prefix" stretchy="false">(</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi>
    <mi>s</mi> <mi>t</mi> <mi>|</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi>
    <mo form="postfix" stretchy="false">)</mo> <mo>×</mo> <mi>P</mi> <mo form="prefix"
    stretchy="false">(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi>
    <mo form="postfix" stretchy="false">)</mo></mrow></mtd></mtr> <mtr><mtd class="tml-left"
    style="padding:0.7ex 0em 0.7ex 0em;"><mrow><mo>+</mo> <mi>P</mi> <mo form="prefix"
    stretchy="false">(</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi>
    <mi>|</mi> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi>
    <mi>h</mi> <mo form="postfix" stretchy="false">)</mo> <mo>×</mo> <mi>P</mi> <mo
    form="prefix" stretchy="false">(</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>m</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo form="postfix" stretchy="false">)</mo>
    <mo form="postfix" stretchy="false">)</mo></mrow></mtd></mtr></mtable></math>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right left" displaystyle="true"><mtr><mtd
    class="tml-right" style="padding:0.7ex 0em 0.7ex 0em;"><mrow><mi>P</mi> <mo form="prefix"
    stretchy="false">(</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi>
    <mo form="postfix" stretchy="false">)</mo></mrow></mtd> <mtd class="tml-left"
    style="padding:0.7ex 0em 0.7ex 0em;"><mrow><mo>=</mo> <mo form="prefix" stretchy="false">(</mo>
    <mi>P</mi> <mo form="prefix" stretchy="false">(</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi>
    <mi>s</mi> <mi>t</mi> <mi>|</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi>
    <mo form="postfix" stretchy="false">)</mo> <mo>×</mo> <mi>P</mi> <mo form="prefix"
    stretchy="false">(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi>
    <mo form="postfix" stretchy="false">)</mo></mrow></mtd></mtr> <mtr><mtd class="tml-left"
    style="padding:0.7ex 0em 0.7ex 0em;"><mrow><mo>+</mo> <mi>P</mi> <mo form="prefix"
    stretchy="false">(</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi>
    <mi>|</mi> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi>
    <mi>h</mi> <mo form="postfix" stretchy="false">)</mo> <mo>×</mo> <mi>P</mi> <mo
    form="prefix" stretchy="false">(</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>m</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo form="postfix" stretchy="false">)</mo>
    <mo form="postfix" stretchy="false">)</mo></mrow></mtd></mtr></mtable></math>
- en: 'Substituting in the preceding equation, we have:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 代入上述方程，我们有：
- en: <math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis
    equals StartFraction upper P left-parenthesis f i r s t vertical-bar m a t c h
    right-parenthesis times upper P left-parenthesis m a t c h right-parenthesis Over
    upper P left-parenthesis f i r s t vertical-bar m a t c h right-parenthesis times
    upper P left-parenthesis m a t c h right-parenthesis plus upper P left-parenthesis
    f i r s t vertical-bar n o t m a t c h right-parenthesis times upper P left-parenthesis
    n o t m a t c h right-parenthesis EndFraction"><mrow><mi>P</mi> <mrow><mo>(</mo>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi>
    <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>×</mo><mi>P</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>×</mo><mi>P</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>×</mo><mi>P</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow></mfrac></mrow></math>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis
    equals StartFraction upper P left-parenthesis f i r s t vertical-bar m a t c h
    right-parenthesis times upper P left-parenthesis m a t c h right-parenthesis Over
    upper P left-parenthesis f i r s t vertical-bar m a t c h right-parenthesis times
    upper P left-parenthesis m a t c h right-parenthesis plus upper P left-parenthesis
    f i r s t vertical-bar n o t m a t c h right-parenthesis times upper P left-parenthesis
    n o t m a t c h right-parenthesis EndFraction"><mrow><mi>P</mi> <mrow><mo>(</mo>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi>
    <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>×</mo><mi>P</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>×</mo><mi>P</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>×</mo><mi>P</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow></mfrac></mrow></math>
- en: 'Alternatively, we can rearrange this as:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将其重新排列为：
- en: <math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis
    equals 1 minus left-parenthesis 1 plus StartFraction upper P left-parenthesis
    f i r s t vertical-bar m a t c h right-parenthesis Over upper P left-parenthesis
    f i r s t vertical-bar n o t m a t c h right-parenthesis EndFraction times StartFraction
    upper P left-parenthesis m a t c h right-parenthesis Over upper P left-parenthesis
    n o t m a t c h right-parenthesis EndFraction right-parenthesis Superscript negative
    1"><mrow><mi>P</mi> <mrow><mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi>
    <mi>h</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>1</mn> <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><mrow><mi>P</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mi>P</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis
    equals 1 minus left-parenthesis 1 plus StartFraction upper P left-parenthesis
    f i r s t vertical-bar m a t c h right-parenthesis Over upper P left-parenthesis
    f i r s t vertical-bar n o t m a t c h right-parenthesis EndFraction times StartFraction
    upper P left-parenthesis m a t c h right-parenthesis Over upper P left-parenthesis
    n o t m a t c h right-parenthesis EndFraction right-parenthesis Superscript negative
    1"><mrow><mi>P</mi> <mrow><mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi>
    <mi>h</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>1</mn> <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><mrow><mi>P</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow>
    <mrow><mi>P</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
- en: If we can estimate the values in this equation, we can determine the probability
    that if a first name is equivalent, then the record pair really is a match.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以估算出这个方程中的值，我们就能确定如果一个名字相等，那么记录对确实是一次匹配的概率。
- en: Let’s examine these values in a little more detail, simplifying the notation
    as we go along.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微详细地检查这些值，随着符号的简化而进行。
- en: m Value
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: m值
- en: 'The conditional probability that an attribute will be equivalent within the
    overall `match` population is known as the *m value*. Using our `Firstname` example,
    we can denote this as:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个`match`人口中，一个属性将会相等的条件概率被称为*m值*。使用我们的`Firstname`示例，我们可以表示为：
- en: <math alttext="m Subscript f Baseline equals upper P left-parenthesis f i r
    s t vertical-bar m a t c h right-parenthesis"><mrow><msub><mi>m</mi> <mi>f</mi></msub>
    <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi>
    <mi>t</mi> <mo>|</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="m Subscript f Baseline equals upper P left-parenthesis f i r
    s t vertical-bar m a t c h right-parenthesis"><mrow><msub><mi>m</mi> <mi>f</mi></msub>
    <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi>
    <mi>t</mi> <mo>|</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow></mrow></math>
- en: In a perfect dataset, all the first names within the `match` population would
    be exactly equivalent and the *m* value would be 1\. This value can therefore
    be thought of as a measure of data quality, i.e., how much variability there is
    in how an attribute has been captured across the datasets. A higher value indicates
    a better-quality attribute.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在完美的数据集中，`match`人口中的所有名字将完全相等，*m*值将为1。因此，这个值可以被认为是数据质量的一种度量，即属性在数据集中被捕捉到的变异程度。更高的值表示更高质量的属性。
- en: u Value
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: u值
- en: 'The conditional probability that an attribute will be equivalent within the
    overall `notmatch` population is known as the *u value*. Again, using our `Firstname`
    example, we can denote this as:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个`notmatch`人口中，一个属性将会相等的条件概率被称为*u值*。同样地，使用我们的`Firstname`示例，我们可以表示为：
- en: <math alttext="u Subscript f Baseline equals upper P left-parenthesis f i r
    s t vertical-bar n o t m a t c h right-parenthesis"><mrow><msub><mi>u</mi> <mi>f</mi></msub>
    <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi>
    <mi>t</mi> <mo>|</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi>
    <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="u Subscript f Baseline equals upper P left-parenthesis f i r
    s t vertical-bar n o t m a t c h right-parenthesis"><mrow><msub><mi>u</mi> <mi>f</mi></msub>
    <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi>
    <mi>t</mi> <mo>|</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi>
    <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow></mrow></math>
- en: This value reflects how much commonality there is in this attribute across the
    datasets. A lower value indicates a less common, more distinguishing attribute
    that, if found to be equivalent in a particular case, would lead us to question
    whether it belongs in the `notmatch` population and is really a match. Conversely,
    a higher *u* value tells us that this particular attribute is not as valuable
    for determining overall matches.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值反映了在数据集中此属性有多少共同性。较低的值表示较不常见、更具区别性的属性，如果在特定情况下发现等效，则会使我们质疑它是否属于`notmatch`人口，并且是否真的匹配。相反，较高的*u*值告诉我们，这个特定的属性不太有价值，不能确定整体匹配。
- en: A good example of *u* value is a month of birth attribute, which, assuming the
    population is equally distributed across the year, will have a *u* value of <math
    alttext="one-twelfth"><mfrac><mn>1</mn> <mn>12</mn></mfrac></math> .
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*u*值的一个很好的例子是出生月份属性，假设人口在全年内均匀分布，将有一个*u*值为<math alttext="one-twelfth"><mfrac><mn>1</mn>
    <mn>12</mn></mfrac></math>。'
- en: Lambda ( <math alttext="lamda"><mi>λ</mi></math> ) Value
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda（<math alttext="lamda"><mi>λ</mi></math>）值
- en: The *lambda value*,  <math alttext="lamda"><mi>λ</mi></math> , also known as
    the prior, is the probability that two randomly chosen records match.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*λ值*，也称为先验，是两个随机选取的记录匹配的概率。'
- en: <math alttext="lamda equals upper P left-parenthesis m a t c h right-parenthesis"><mrow><mi>λ</mi>
    <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi>
    <mo>)</mo></mrow></math>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="lamda equals upper P left-parenthesis m a t c h right-parenthesis"><mrow><mi>λ</mi>
    <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi>
    <mo>)</mo></mrow></math>
- en: In contrast with the *m* and *u* values, the  <math alttext="lamda"><mi>λ</mi></math>
     value is a record-level value not associated with any particular attribute. This
    value is a measure of how much duplication there is in the dataset overall and
    is the starting point for our probability calculations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与*m*和*u*值相比，*λ*值是一个与任何特定属性都不相关的记录级值。这个值是数据集整体重复的程度的度量，并且是我们概率计算的起点。
- en: 'The inverse, the likelihood that two randomly chosen records are not a match,
    can be written as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 其倒数，即两个随机选取的记录不匹配的可能性，可以写为：
- en: <math alttext="1 minus lamda equals upper P left-parenthesis n o t m a t c h
    right-parenthesis"><mrow><mn>1</mn> <mo>-</mo> <mi>λ</mi> <mo>=</mo> <mi>P</mi>
    <mo>(</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi>
    <mi>h</mi> <mo>)</mo></mrow></math>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="1 minus lamda equals upper P left-parenthesis n o t m a t c h
    right-parenthesis"><mrow><mn>1</mn> <mo>-</mo> <mi>λ</mi> <mo>=</mo> <mi>P</mi>
    <mo>(</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi>
    <mi>h</mi> <mo>)</mo></mrow></math>
- en: Bayes Factor
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 贝叶斯因子
- en: 'Substituting these compact notations can result in the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 代入这些紧凑的符号可能会导致以下结果：
- en: <math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis
    equals 1 minus left-parenthesis 1 plus StartFraction m Subscript f Baseline Over
    u Subscript f Baseline EndFraction times StartFraction lamda Over left-parenthesis
    1 minus lamda right-parenthesis EndFraction right-parenthesis Superscript negative
    1"><mrow><mi>P</mi> <mrow><mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi>
    <mi>h</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>1</mn> <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><msub><mi>m</mi>
    <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>×</mo><mfrac><mi>λ</mi>
    <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis
    equals 1 minus left-parenthesis 1 plus StartFraction m Subscript f Baseline Over
    u Subscript f Baseline EndFraction times StartFraction lamda Over left-parenthesis
    1 minus lamda right-parenthesis EndFraction right-parenthesis Superscript negative
    1"><mrow><mi>P</mi> <mrow><mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi>
    <mi>h</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>1</mn> <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><msub><mi>m</mi>
    <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>×</mo><mfrac><mi>λ</mi>
    <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
- en: The ratio  <math alttext="StartFraction m Subscript f Baseline Over u Subscript
    f Baseline EndFraction"><mfrac><msub><mi>m</mi> <mi>f</mi></msub> <msub><mi>u</mi>
    <mi>f</mi></msub></mfrac></math> is also known as the *Bayes factor*, in this
    case of the `Firstname` parameter. The Bayes factor, as a combination of both
    the *m* and *u* values, gives a measure of the significance we should attach to
    the fact that the `Firstname` values were equivalent.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 比率  <math alttext="StartFraction m Subscript f Baseline Over u Subscript f Baseline
    EndFraction"><mfrac><msub><mi>m</mi> <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac></math>
    也被称为*贝叶斯因子*，在本例中是关于`Firstname`参数的。贝叶斯因子作为*m*和*u*值的组合，用于衡量我们应该给予`Firstname`值等效性的重要性。
- en: Fellegi-Sunter Model
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 费勒吉-桑特模型
- en: The *Fellegi-Sunter model*, named after Ivan P. Fellegi and Alan B. Sunter,^([1](ch04.html#id429))
    describes how we can extend our simple Bayesian approach, combining the contribution
    of multiple attributes, to calculate the overall likelihood of a match. It relies
    on the simplifying assumption of conditional independence between attributes,
    also known as *naive Bayes*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 费勒吉-桑特模型，以伊凡·P·费勒吉和艾伦·B·桑特命名，^([1](ch04.html#id429)) 描述了我们如何扩展简单的贝叶斯方法，结合多个属性的贡献，计算匹配的总体可能性。它依赖于属性之间条件独立的简化假设，也称为*朴素贝叶斯*。
- en: 'Using the FS model, we can combine the Bayes factors associated with each attribute
    in our record by simply multiplying them together. Taking our `Firstname` example
    and extending it to consider when the `Lastname` is also equivalent we have:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FS模型，我们可以通过简单地将记录中每个属性的贝叶斯因子相乘来组合它们。以我们的`Firstname`示例为例，考虑`Lastname`也等效时：
- en: <math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue l a s t
    EndAbsoluteValue f i r s t right-parenthesis equals 1 minus left-parenthesis 1
    plus StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction
    times StartFraction m Subscript l Baseline Over u Subscript l Baseline EndFraction
    times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis
    EndFraction right-parenthesis Superscript negative 1"><mrow><mi>P</mi> <mrow><mo>(</mo>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo> <mi>l</mi> <mi>a</mi>
    <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mn>1</mn> <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><msub><mi>m</mi>
    <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>×</mo><mfrac><msub><mi>m</mi>
    <mi>l</mi></msub> <msub><mi>u</mi> <mi>l</mi></msub></mfrac> <mo>×</mo><mfrac><mi>λ</mi>
    <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue l a s t
    EndAbsoluteValue f i r s t right-parenthesis equals 1 minus left-parenthesis 1
    plus StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction
    times StartFraction m Subscript l Baseline Over u Subscript l Baseline EndFraction
    times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis
    EndFraction right-parenthesis Superscript negative 1"><mrow><mi>P</mi> <mrow><mo>(</mo>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo> <mi>l</mi> <mi>a</mi>
    <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mn>1</mn> <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><msub><mi>m</mi>
    <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>×</mo><mfrac><msub><mi>m</mi>
    <mi>l</mi></msub> <msub><mi>u</mi> <mi>l</mi></msub></mfrac> <mo>×</mo><mfrac><mi>λ</mi>
    <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
- en: 'When an attribute isn’t equivalent, the Bayes factor is calculated as the inverse, 
    <math alttext="StartFraction left-parenthesis 1 minus m Subscript l Baseline right-parenthesis
    Over left-parenthesis 1 minus u Subscript l Baseline right-parenthesis EndFraction"><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac></math> . Therefore when the `Firstname`
    is equivalent but the `Lastname` is not, we calculate the probability of an overall
    match as:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当属性不等效时，贝叶斯因子被计算为其倒数， <math alttext="StartFraction left-parenthesis 1 minus
    m Subscript l Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript
    l Baseline right-parenthesis EndFraction"><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac></math> 。因此，当`Firstname`相等而`Lastname`不等时，我们计算整体匹配的概率为：
- en: <math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue n o t l
    a s t EndAbsoluteValue f i r s t right-parenthesis equals 1 minus left-parenthesis
    1 plus StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction
    times StartFraction left-parenthesis 1 minus m Subscript l Baseline right-parenthesis
    Over left-parenthesis 1 minus u Subscript l Baseline right-parenthesis EndFraction
    times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis
    EndFraction right-parenthesis Superscript negative 1"><mrow><mi>P</mi> <mrow><mo>(</mo>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo> <mi>n</mi> <mi>o</mi>
    <mi>t</mi> <mi>l</mi> <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi>
    <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>1</mn> <mo>-</mo>
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><msub><mi>m</mi> <mi>f</mi></msub>
    <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>×</mo><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue n o t l
    a s t EndAbsoluteValue f i r s t right-parenthesis equals 1 minus left-parenthesis
    1 plus StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction
    times StartFraction left-parenthesis 1 minus m Subscript l Baseline right-parenthesis
    Over left-parenthesis 1 minus u Subscript l Baseline right-parenthesis EndFraction
    times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis
    EndFraction right-parenthesis Superscript negative 1"><mrow><mi>P</mi> <mrow><mo>(</mo>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo> <mi>n</mi> <mi>o</mi>
    <mi>t</mi> <mi>l</mi> <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi>
    <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>1</mn> <mo>-</mo>
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><msub><mi>m</mi> <mi>f</mi></msub>
    <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>×</mo><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
- en: Once we can calculate the *m* and *u* values for each attribute, and the  <math
    alttext="lamda"><mi>λ</mi></math>  value for the overall dataset, we can easily
    calculate the probabilities for each record pair. We simply determine the equivalence
    of each attribute (either exact or approximate as appropriate), select the appropriate
    Bayes factors, and multiply them together using the preceding formula to calculate
    the overall probability for that record pair.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们可以计算每个属性的*m*和*u*值，以及整体数据集的 <math alttext="lamda"><mi>λ</mi></math> 值，我们可以轻松地计算每对记录的概率。我们只需确定每个属性的等效性（精确或适当的近似），选择适当的贝叶斯因子，并使用前述公式将它们相乘，以计算该记录对的总体概率。
- en: For our simple example, our Bayes factors are therefore calculated as shown
    in [Table 4-2](#table-4-2).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的简单示例，我们的贝叶斯因子如 [Table 4-2](#table-4-2) 所示计算。
- en: Table 4-2\. `Firstname`, `Lastname` match factor calculations
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-2\. `Firstname`，`Lastname` 匹配因子计算
- en: '| `Firstname` equivalence | `Lastname` equivalence | `Firstname` Bayes factor
    | `Lastname` Bayes factor | Combined Bayes factor |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `Firstname` 等效性 | `Lastname` 等效性 | `Firstname` 贝叶斯因子 | `Lastname` 贝叶斯因子 |
    组合贝叶斯因子 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| No | No | <math alttext="StartFraction left-parenthesis 1 minus m Subscript
    f Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript f Baseline
    right-parenthesis EndFraction"><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow></mfrac></math> | <math alttext="StartFraction
    left-parenthesis 1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis
    1 minus u Subscript l Baseline right-parenthesis EndFraction"><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac></math> | <math alttext="StartFraction
    left-parenthesis 1 minus m Subscript f Baseline right-parenthesis Over left-parenthesis
    1 minus u Subscript f Baseline right-parenthesis EndFraction times StartFraction
    left-parenthesis 1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis
    1 minus u Subscript l Baseline right-parenthesis EndFraction"><mrow><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow></mfrac> <mo>×</mo> <mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac></mrow></math> |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 否 | 否 | <math alttext="StartFraction left-parenthesis 1 minus m Subscript
    f Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript f Baseline
    right-parenthesis EndFraction"><mfrac><mrow><mo>（</mo><mn>1</mn><mo>−</mo><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>）</mo></mrow> <mrow><mo>（</mo><mn>1</mn><mo>−</mo><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>）</mo></mrow></mfrac></math> | <math alttext="StartFraction
    left-parenthesis 1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis
    1 minus u Subscript l Baseline right-parenthesis EndFraction"><mfrac><mrow><mo>（</mo><mn>1</mn><mo>−</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>）</mo></mrow> <mrow><mo>（</mo><mn>1</mn><mo>−</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>）</mo></mrow></mfrac></math> | <math alttext="StartFraction
    left-parenthesis 1 minus m Subscript f Baseline right-parenthesis Over left-parenthesis
    1 minus u Subscript f Baseline right-parenthesis EndFraction times StartFraction
    left-parenthesis 1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis
    1 minus u Subscript l Baseline right-parenthesis EndFraction"><mrow><mfrac><mrow><mo>（</mo><mn>1</mn><mo>−</mo><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>）</mo></mrow> <mrow><mo>（</mo><mn>1</mn><mo>−</mo><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>）</mo></mrow></mfrac> <mo>×</mo> <mfrac><mrow><mo>（</mo><mn>1</mn><mo>−</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>）</mo></mrow> <mrow><mo>（</mo><mn>1</mn><mo>−</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>）</mo></mrow></mfrac></mrow></math> |'
- en: '| No | Yes | <math alttext="StartFraction left-parenthesis 1 minus m Subscript
    f Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript f Baseline
    right-parenthesis EndFraction"><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow></mfrac></math> | <math alttext="StartFraction
    m Subscript l Baseline Over u Subscript l Baseline EndFraction"><mfrac><msub><mi>m</mi>
    <mi>l</mi></msub> <msub><mi>u</mi> <mi>l</mi></msub></mfrac></math> | <math alttext="StartFraction
    left-parenthesis 1 minus m Subscript f Baseline right-parenthesis Over left-parenthesis
    1 minus u Subscript f Baseline right-parenthesis EndFraction times StartFraction
    m Subscript l Baseline Over u Subscript l Baseline EndFraction"><mrow><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow></mfrac> <mo>×</mo> <mfrac><msub><mi>m</mi>
    <mi>l</mi></msub> <msub><mi>u</mi> <mi>l</mi></msub></mfrac></mrow></math> |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 否 | 是 | <math alttext="StartFraction left-parenthesis 1 minus m Subscript
    f Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript f Baseline
    right-parenthesis EndFraction"><mfrac><mrow><mo>（</mo><mn>1</mn><mo>−</mo><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>）</mo></mrow> <mrow><mo>（</mo><mn>1</mn><mo>−</mo><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>）</mo></mrow></mfrac></math> | <math alttext="StartFraction
    m Subscript l Baseline Over u Subscript l Baseline EndFraction"><mfrac><msub><mi>m</mi>
    <mi>l</mi></msub> <msub><mi>u</mi> <mi>l</mi></msub></mfrac></math> | <math alttext="StartFraction
    left-parenthesis 1 minus m Subscript f Baseline right-parenthesis Over left-parenthesis
    1 minus u Subscript f Baseline right-parenthesis EndFraction times StartFraction
    m Subscript l Baseline Over u Subscript l Baseline EndFraction"><mrow><mfrac><mrow><mo>（</mo><mn>1</mn><mo>−</mo><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>）</mo></mrow> <mrow><mo>（</mo><mn>1</mn><mo>−</mo><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>）</mo></mrow></mfrac> <mo>×</mo> <mfrac><msub><mi>m</mi>
    <mi>l</mi></msub> <msub><mi>u</mi> <mi>l</mi></msub></mfrac></mrow></math> |'
- en: '| Yes | No | <math alttext="StartFraction m Subscript f Baseline Over u Subscript
    f Baseline EndFraction"><mfrac><msub><mi>m</mi> <mi>f</mi></msub> <msub><mi>u</mi>
    <mi>f</mi></msub></mfrac></math> | <math alttext="StartFraction left-parenthesis
    1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis 1 minus
    u Subscript l Baseline right-parenthesis EndFraction"><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac></math> | <math alttext="StartFraction
    m Subscript f Baseline Over u Subscript f Baseline EndFraction times StartFraction
    left-parenthesis 1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis
    1 minus u Subscript l Baseline right-parenthesis EndFraction"><mrow><mfrac><msub><mi>m</mi>
    <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>×</mo> <mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac></mrow></math> |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 是 | 否 | <math alttext="StartFraction m Subscript f Baseline Over u Subscript
    f Baseline EndFraction"><mfrac><msub><mi>m</mi> <mi>f</mi></msub> <msub><mi>u</mi>
    <mi>f</mi></msub></mfrac></math> | <math alttext="StartFraction left-parenthesis
    1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis 1 minus
    u Subscript l Baseline right-parenthesis EndFraction"><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac></math> | <math alttext="StartFraction
    m Subscript f Baseline Over u Subscript f Baseline EndFraction times StartFraction
    left-parenthesis 1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis
    1 minus u Subscript l Baseline right-parenthesis EndFraction"><mrow><mfrac><msub><mi>m</mi>
    <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>×</mo> <mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac></mrow></math> |'
- en: '| Yes | Yes | <math alttext="StartFraction m Subscript f Baseline Over u Subscript
    f Baseline EndFraction"><mfrac><msub><mi>m</mi> <mi>f</mi></msub> <msub><mi>u</mi>
    <mi>f</mi></msub></mfrac></math> | <math alttext="StartFraction m Subscript l
    Baseline Over u Subscript l Baseline EndFraction"><mfrac><msub><mi>m</mi> <mi>l</mi></msub>
    <msub><mi>u</mi> <mi>l</mi></msub></mfrac></math> | <math alttext="StartFraction
    m Subscript f Baseline Over u Subscript f Baseline EndFraction times StartFraction
    m Subscript l Baseline Over u Subscript l Baseline EndFraction"><mrow><mfrac><msub><mi>m</mi>
    <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>×</mo> <mfrac><msub><mi>m</mi>
    <mi>l</mi></msub> <msub><mi>u</mi> <mi>l</mi></msub></mfrac></mrow></math> |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 是 | 是 | <math alttext="StartFraction m Subscript f Baseline Over u Subscript
    f Baseline EndFraction"><mfrac><msub><mi>m</mi> <mi>f</mi></msub> <msub><mi>u</mi>
    <mi>f</mi></msub></mfrac></math> | <math alttext="StartFraction m Subscript l
    Baseline Over u Subscript l Baseline EndFraction"><mfrac><msub><mi>m</mi> <mi>l</mi></msub>
    <msub><mi>u</mi> <mi>l</mi></msub></mfrac></math> | <math alttext="StartFraction
    m Subscript f Baseline Over u Subscript f Baseline EndFraction times StartFraction
    m Subscript l Baseline Over u Subscript l Baseline EndFraction"><mrow><mfrac><msub><mi>m</mi>
    <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>×</mo> <mfrac><msub><mi>m</mi>
    <mi>l</mi></msub> <msub><mi>u</mi> <mi>l</mi></msub></mfrac></mrow></math> |'
- en: Match Weight
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配权重
- en: To make overall match calculations more intuitive, the logarithm of the Bayes
    factors is sometimes used so that they can be added together rather than multiplied.
    In this way it is easy to visualize the relative contribution of each attribute
    to the overall score.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使整体匹配计算更直观，有时会使用贝叶斯因子的对数，这样它们可以相加而不是相乘。这样可以更容易地可视化每个属性对总体分数的相对贡献。
- en: 'For our simple first name and last name equivalence example, the logarithmic
    match weight might be calculated (using base 2) as:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们简单的名字等价示例，可以计算对数匹配权重（使用基数2）如下：
- en: <math alttext="upper M a t c h upper W e i g h t equals l o g 2 StartFraction
    m Subscript f Baseline Over u Subscript f Baseline EndFraction plus l o g 2 StartFraction
    m Subscript l Baseline Over u Subscript l Baseline EndFraction plus l o g 2 StartFraction
    lamda Over left-parenthesis 1 minus lamda right-parenthesis EndFraction"><mrow><mi>M</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>W</mi> <mi>e</mi> <mi>i</mi> <mi>g</mi>
    <mi>h</mi> <mi>t</mi> <mo>=</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub>
    <mfrac><msub><mi>m</mi> <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac>
    <mo>+</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub> <mfrac><msub><mi>m</mi>
    <mi>l</mi></msub> <msub><mi>u</mi> <mi>l</mi></msub></mfrac> <mo>+</mo> <mi>l</mi>
    <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub> <mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac></mrow></math>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper M a t c h upper W e i g h t equals l o g 2 StartFraction
    m Subscript f Baseline Over u Subscript f Baseline EndFraction plus l o g 2 StartFraction
    m Subscript l Baseline Over u Subscript l Baseline EndFraction plus l o g 2 StartFraction
    lamda Over left-parenthesis 1 minus lamda right-parenthesis EndFraction"><mrow><mi>M</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>W</mi> <mi>e</mi> <mi>i</mi> <mi>g</mi>
    <mi>h</mi> <mi>t</mi> <mo>=</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub>
    <mfrac><msub><mi>m</mi> <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac>
    <mo>+</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub> <mfrac><msub><mi>m</mi>
    <mi>l</mi></msub> <msub><mi>u</mi> <mi>l</mi></msub></mfrac> <mo>+</mo> <mi>l</mi>
    <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub> <mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac></mrow></math>
- en: 'We can calculate probability from the match weight as:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从匹配权重计算概率：
- en: <math alttext="upper P r o b a b i l i t y equals 1 minus left-parenthesis 1
    plus 2 Superscript upper M a t c h upper W e i g h t Baseline right-parenthesis
    Superscript negative 1"><mrow><mi>P</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mi>a</mi>
    <mi>b</mi> <mi>i</mi> <mi>l</mi> <mi>i</mi> <mi>t</mi> <mi>y</mi> <mo>=</mo> <mn>1</mn>
    <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><msup><mn>2</mn> <mrow><mi>M</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P r o b a b i l i t y equals 1 minus left-parenthesis 1
    plus 2 Superscript upper M a t c h upper W e i g h t Baseline right-parenthesis
    Superscript negative 1"><mrow><mi>P</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mi>a</mi>
    <mi>b</mi> <mi>i</mi> <mi>l</mi> <mi>i</mi> <mi>t</mi> <mi>y</mi> <mo>=</mo> <mn>1</mn>
    <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><msup><mn>2</mn> <mrow><mi>M</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
- en: Now that we understand how to combine our individual attribute probabilities,
    or match weights, together let’s consider how to estimate our  <math alttext="lamda"><mi>λ</mi></math>
     value and our *m* and *u* values for each attribute when we don’t have a known
    `match` population. One technique that we can use is called the [*expectation-maximization
    (EM) algorithm*](https://oreil.ly/kvWD3).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了如何将个体属性的概率或匹配权重组合在一起，让我们考虑在没有已知`match`群体时如何估计我们的 <math alttext="lamda"><mi>λ</mi></math>
    值以及每个属性的*m*和*u*值。我们可以使用的一种技术称为[*期望最大化算法（EM算法）*](https://oreil.ly/kvWD3)。
- en: Expectation-Maximization Algorithm
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 期望最大化算法
- en: The expectation-maximization algorithm uses an iterative approach to approximating
    the <math alttext="lamda"><mi>λ</mi></math>  and *m* and *u* values. Let’s see
    a simplified form of this in action applied to our sample problem.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 期望最大化算法使用迭代方法来逼近 <math alttext="lamda"><mi>λ</mi></math> 和 *m* 和 *u* 值。让我们看一个简化形式的示例，应用于我们的样本问题。
- en: Iteration 1
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一次迭代
- en: 'For the first iteration we make the opening assumption that record pairs where
    the majority of the feature columns are equivalent are matches:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次迭代中，我们做出假设，即大多数特征列等效的记录对是匹配的：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This gives us a pseudo `match` population, `it1_match`, of 637 records. In
    addition to the 628 perfect matches we found in [Chapter 2](ch02.html#chapter_2),
    we also have 9 matches where either `Firstname` or `Lastname` (but not both) doesn’t
    match, as we see in [Figure 4-4](#fig-4-4):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个伪匹配人口 `it1_match`，共 637 条记录。除了我们在 [第 2 章](ch02.html#chapter_2) 中找到的
    628 个完美匹配外，我们还有 9 个匹配，其中 `Firstname` 或 `Lastname`（但不是两者同时）不匹配，如图 4-4 所示：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](assets/hoer_0404.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0404.png)'
- en: Figure 4-4\. Expectation-maximization iteration 1 additional matches
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-4\. 期望最大化迭代 1 附加匹配
- en: 'Our initial  <math alttext="lamda"><mi>λ</mi></math>  value is therefore:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的初始 <math alttext="lamda"><mi>λ</mi></math> 值是：
- en: <math alttext="lamda 1 equals StartFraction 637 Over 650 times 650 EndFraction
    almost-equals 0.0015"><mrow><msub><mi>λ</mi> <mn>1</mn></msub> <mo>=</mo> <mfrac><mn>637</mn>
    <mrow><mn>650</mn><mo>×</mo><mn>650</mn></mrow></mfrac> <mo>≈</mo> <mn>0</mn>
    <mo>.</mo> <mn>0015</mn></mrow></math>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="lamda 1 equals StartFraction 637 Over 650 times 650 EndFraction
    almost-equals 0.0015"><mrow><msub><mi>λ</mi> <mn>1</mn></msub> <mo>=</mo> <mfrac><mn>637</mn>
    <mrow><mn>650</mn><mo>×</mo><mn>650</mn></mrow></mfrac> <mo>≈</mo> <mn>0</mn>
    <mo>.</mo> <mn>0015</mn></mrow></math>
- en: <math alttext="left-parenthesis 1 minus lamda 1 right-parenthesis equals left-parenthesis
    1 minus 0.0015 right-parenthesis almost-equals 0.9985"><mrow><mrow><mo>(</mo>
    <mn>1</mn> <mo>-</mo> <msub><mi>λ</mi> <mn>1</mn></msub> <mo>)</mo></mrow> <mo>=</mo>
    <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mn>0</mn> <mo>.</mo> <mn>0015</mn> <mo>)</mo></mrow>
    <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>9985</mn></mrow></math>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="left-parenthesis 1 minus lamda 1 right-parenthesis equals left-parenthesis
    1 minus 0.0015 right-parenthesis almost-equals 0.9985"><mrow><mrow><mo>(</mo>
    <mn>1</mn> <mo>-</mo> <msub><mi>λ</mi> <mn>1</mn></msub> <mo>)</mo></mrow> <mo>=</mo>
    <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mn>0</mn> <mo>.</mo> <mn>0015</mn> <mo>)</mo></mrow>
    <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>9985</mn></mrow></math>
- en: Our initial prior match weight is therefore   <math alttext="l o g 2 StartFraction
    lamda 1 Over left-parenthesis 1 minus lamda 1 right-parenthesis EndFraction almost-equals
    negative 9.371"><mrow><mrow><mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub>
    <mfrac><msub><mi>λ</mi> <mn>1</mn></msub> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>λ</mi>
    <mn>1</mn></msub> <mo>)</mo></mrow></mfrac></mrow> <mo>≈</mo> <mo>-</mo> <mn>9</mn>
    <mo>.</mo> <mn>371</mn></mrow></math> .
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的初始先验匹配权重是 <math alttext="l o g 2 StartFraction lamda 1 Over left-parenthesis
    1 minus lamda 1 right-parenthesis EndFraction almost-equals negative 9.371"><mrow><mrow><mi>l</mi>
    <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub> <mfrac><msub><mi>λ</mi> <mn>1</mn></msub>
    <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>λ</mi> <mn>1</mn></msub> <mo>)</mo></mrow></mfrac></mrow>
    <mo>≈</mo> <mo>-</mo> <mn>9</mn> <mo>.</mo> <mn>371</mn></mrow></math> 。
- en: As a starting point, it’s therefore extremely unlikely that two records are
    a match. Now let’s calculate our *m* and *u* values so that we can update our
    probability on a per-record basis.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为起点，两个记录匹配的可能性极低。现在让我们计算我们的 *m* 和 *u* 值，以便我们可以根据每个记录更新我们的概率。
- en: 'As we have a pseudo `match` and `notmatch` population, it’s straightforward
    to calculate our *m* and *u* values as the proportion of each population with
    an equivalent attribute. For `Firstname`, `Lastname`, and `Constituency` we use:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个伪匹配和 `notmatch` 人口，因此可以直接计算我们的 *m* 和 *u* 值，作为每种人口中具有等效属性的比例。对于 `名`、`姓`
    和 `选区`，我们使用：
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Table 4-3](#table-4-3) shows these values and the resulting match weight values
    per attribute.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-3](#table-4-3) 显示了这些值以及每个属性的匹配权重值。'
- en: Table 4-3\. Iteration 1 *m* and *u* values
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-3\. 迭代 1 的 *m* 和 *u* 值
- en: '| Attribute | *m* value | *u* value | Match Bayes factor | Match weight | Not
    match Bayes factor | Not match weight |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | *m* 值 | *u* 值 | 匹配贝叶斯因子 | 匹配权重 | 不匹配贝叶斯因子 | 不匹配权重 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| `Firstname` | 0.9921 | 0.0049 | 203.97 | 7.67 | 0.0079 | –6.98 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `名` | 0.9921 | 0.0049 | 203.97 | 7.67 | 0.0079 | –6.98 |'
- en: '| `Lastname` | 0.9937 | 0.0008 | 1201.19 | 10.23 | 0.0063 | –7.31 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `姓` | 0.9937 | 0.0008 | 1201.19 | 10.23 | 0.0063 | –7.31 |'
- en: '| `Constituency` | 1.0 | 0.0 | <math alttext="normal infinity"><mi>∞</mi></math>
    | <math alttext="normal infinity"><mi>∞</mi></math> | 0 | <math alttext="negative
    normal infinity"><mrow><mo>-</mo> <mi>∞</mi></mrow></math> |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `选区` | 1.0 | 0.0 | <math alttext="normal infinity"><mi>∞</mi></math> | <math
    alttext="normal infinity"><mi>∞</mi></math> | 0 | <math alttext="negative normal
    infinity"><mrow><mo>-</mo> <mi>∞</mi></mrow></math> |'
- en: There are no record pairs where the constituency is equivalent in the `notmatch`
    population, so its *u* value is 0 and therefore its `match` weight is mathematically
    infinity and its `notmatch` weight is negative infinity.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `notmatch` 人群中，没有记录对其“选区”等价，因此其 *u* 值为 0，因此其 `match` 权重在数学上为无穷大，而 `notmatch`
    权重为负无穷大。
- en: 'Now we can use these values in the Fellegi-Sunter model to calculate the match
    probability for every record pair in the full population. We use a helper function
    to calculate these probabilities based on the values of the `Constituency`, `Firstname`,
    and `Lastname` match features:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将这些值用于 Fellegi-Sunter 模型中，计算完整人口中每对记录的匹配概率。我们使用一个辅助函数基于 `选区`、`姓` 和 `名`
    的匹配特征值来计算这些概率：
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We apply this function to the whole population with:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此函数应用于整个人口，得到：
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once we’ve calculated these values we can iterate again, resegmenting our population
    into `match` and `notmatch` populations based on the calculated match probabilities.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们计算了这些值，我们可以再次迭代，根据计算出的匹配概率重新将我们的人口分成`match`和`notmatch`人口。
- en: Iteration 2
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代2
- en: 'For illustration purposes, we use an overall match probability of greater than
    0.99 to define our new assumed `match` population and assign any record with an
    equal or lower probability to our `notmatch` population:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明目的，我们使用大于0.99的总体匹配概率来定义我们的新假设`match`人口，并将任何匹配概率等于或低于此值的记录分配给我们的`notmatch`人口：
- en: '[PRE11]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Applying this 0.99 threshold gives us a slightly reduced `match` population
    of 633\. Let’s see why. If we select the records just below the threshold we can
    see:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个0.99的阈值应用于我们略微减少的`match`人口，即633人。让我们看看为什么。如果我们选择略低于阈值的记录，我们可以看到：
- en: '[PRE12]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](assets/hoer_0405.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0405.png)'
- en: Figure 4-5\. Iteration 2 records with below-the-line match thresholds
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-5。迭代2下线匹配阈值的记录
- en: As we see in [Figure 4-5](#fig-4-5), if the `Lastname` isn’t equivalent, the
    new match probability falls just below our 0.99 threshold. Using these new `match`
    and `notmatch` populations we can revise our <math alttext="lamda"><mi>λ</mi></math>
    , *m*, and *u* values and iterate again, recalculating the match probabilities
    for each record pair.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[图4-5](#fig-4-5)中看到的，如果`Lastname`不等效，新的匹配概率就会略低于我们的0.99阈值。使用这些新的`match`和`notmatch`人口，我们可以修订我们的
    <math alttext="lamda"><mi>λ</mi></math> 、*m* 和 *u* 值，并再次迭代，重新计算每对记录的匹配概率。
- en: 'In this case, our  <math alttext="lamda"><mi>λ</mi></math>  doesn’t materially
    change:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的 <math alttext="lamda"><mi>λ</mi></math> 实际上没有太大变化：
- en: <math alttext="lamda 2 equals StartFraction 633 Over 650 times 650 EndFraction
    almost-equals 0.0015"><mrow><msub><mi>λ</mi> <mn>2</mn></msub> <mo>=</mo> <mfrac><mn>633</mn>
    <mrow><mn>650</mn><mo>×</mo><mn>650</mn></mrow></mfrac> <mo>≈</mo> <mn>0</mn>
    <mo>.</mo> <mn>0015</mn></mrow></math>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="lamda 2 equals StartFraction 633 Over 650 times 650 EndFraction
    almost-equals 0.0015"><mrow><msub><mi>λ</mi> <mn>2</mn></msub> <mo>=</mo> <mfrac><mn>633</mn>
    <mrow><mn>650</mn><mo>×</mo><mn>650</mn></mrow></mfrac> <mo>≈</mo> <mn>0</mn>
    <mo>.</mo> <mn>0015</mn></mrow></math>
- en: Only the `Lastname` values change slightly, as shown in [Table 4-4](#table-4-4).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`Lastname`的值稍微改变，如表格4-4所示。
- en: Table 4-4\. Iteration 2 *m* and *u* values
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 表格4-4。迭代2 *m* 和 *u* 值
- en: '| Attribute | *m* value | *u* value | Match Bayes factor | Match weight | Not
    match Bayes factor | Not match weight |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | *m* 值 | *u* 值 | 匹配贝叶斯因子 | 匹配权重 | 不匹配贝叶斯因子 | 不匹配权重 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| `Firstname` | 0.9921 | 0.0049 | 203.97 | 7.67 | 0.0079 | –6.98 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `Firstname` | 0.9921 | 0.0049 | 203.97 | 7.67 | 0.0079 | –6.98 |'
- en: '| *`Lastname`* | *1.0* | *0.0008* | *1208.79* | *10.24* | *0* | <math alttext="negative
    normal infinity"><mrow><mo>-</mo> <mi>∞</mi></mrow></math> |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| *`Lastname`* | *1.0* | *0.0008* | *1208.79* | *10.24* | *0* | <math alttext="negative
    normal infinity"><mrow><mo>-</mo> <mi>∞</mi></mrow></math> |'
- en: '| `Constituency` | 1.0 | 0.0 | <math alttext="normal infinity"><mi>∞</mi></math>
    | <math alttext="normal infinity"><mi>∞</mi></math> | 0 | <math alttext="negative
    normal infinity"><mrow><mo>-</mo> <mi>∞</mi></mrow></math> |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `Constituency` | 1.0 | 0.0 | <math alttext="normal infinity"><mi>∞</mi></math>
    | <math alttext="normal infinity"><mi>∞</mi></math> | 0 | <math alttext="negative
    normal infinity"><mrow><mo>-</mo> <mi>∞</mi></mrow></math> |'
- en: Iteration 3
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Iteration 3
- en: In this simple example, this next iteration doesn’t change the `match` population,
    which remains at 633, because the EM algorithm has already converged.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，这一次迭代不会改变`match`人口，仍然为633，因为EM算法已经收敛。
- en: 'This gives us our final parameter values of:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们我们的最终参数值：
- en: <math alttext="lamda almost-equals 0.0015"><mrow><mi>λ</mi> <mo>≈</mo> <mn>0</mn>
    <mo>.</mo> <mn>0015</mn></mrow></math>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="lamda almost-equals 0.0015"><mrow><mi>λ</mi> <mo>≈</mo> <mn>0</mn>
    <mo>.</mo> <mn>0015</mn></mrow></math>
- en: <math alttext="m Subscript f Baseline equals upper P left-parenthesis f i r
    s t vertical-bar m a t c h right-parenthesis almost-equals 0.9921"><mrow><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>f</mi> <mi>i</mi>
    <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi>
    <mi>h</mi> <mo>)</mo></mrow> <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>9921</mn></mrow></math>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="m Subscript f Baseline equals upper P left-parenthesis f i r
    s t vertical-bar m a t c h right-parenthesis almost-equals 0.9921"><mrow><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>f</mi> <mi>i</mi>
    <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi>
    <mi>h</mi> <mo>)</mo></mrow> <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>9921</mn></mrow></math>
- en: <math alttext="m Subscript l Baseline equals upper P left-parenthesis l a s
    t vertical-bar m a t c h right-parenthesis almost-equals 1.0"><mrow><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>l</mi> <mi>a</mi>
    <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi>
    <mo>)</mo></mrow> <mo>≈</mo> <mn>1</mn> <mo>.</mo> <mn>0</mn></mrow></math>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="m Subscript l Baseline equals upper P left-parenthesis l a s
    t vertical-bar m a t c h right-parenthesis almost-equals 1.0"><mrow><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>l</mi> <mi>a</mi>
    <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi>
    <mo>)</mo></mrow> <mo>≈</mo> <mn>1</mn> <mo>.</mo> <mn>0</mn></mrow></math>
- en: <math alttext="m Subscript c Baseline equals upper P left-parenthesis c o n
    s t i t u e n c y vertical-bar m a t c h right-parenthesis almost-equals 1.0"><mrow><msub><mi>m</mi>
    <mi>c</mi></msub> <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>c</mi> <mi>o</mi>
    <mi>n</mi> <mi>s</mi> <mi>t</mi> <mi>i</mi> <mi>t</mi> <mi>u</mi> <mi>e</mi> <mi>n</mi>
    <mi>c</mi> <mi>y</mi> <mo>|</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi>
    <mo>)</mo></mrow> <mo>≈</mo> <mn>1</mn> <mo>.</mo> <mn>0</mn></mrow></math>
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="m Subscript c Baseline equals upper P left-parenthesis c o n
    s t i t u e n c y vertical-bar m a t c h right-parenthesis almost-equals 1.0"><mrow><msub><mi>m</mi>
    <mi>c</mi></msub> <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>c</mi> <mi>o</mi>
    <mi>n</mi> <mi>s</mi> <mi>t</mi> <mi>i</mi> <mi>t</mi> <mi>u</mi> <mi>e</mi> <mi>n</mi>
    <mi>c</mi> <mi>y</mi> <mo>|</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi>
    <mo>)</mo></mrow> <mo>≈</mo> <mn>1</mn> <mo>.</mo> <mn>0</mn></mrow></math>
- en: <math alttext="u Subscript f Baseline equals upper P left-parenthesis f i r
    s t vertical-bar n o t m a t c h right-parenthesis almost-equals 0.0049"><mrow><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>f</mi> <mi>i</mi>
    <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>m</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow> <mo>≈</mo> <mn>0</mn>
    <mo>.</mo> <mn>0049</mn></mrow></math>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="u Subscript f Baseline equals upper P left-parenthesis f i r
    s t vertical-bar n o t m a t c h right-parenthesis almost-equals 0.0049"><mrow><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>f</mi> <mi>i</mi>
    <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>m</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow> <mo>≈</mo> <mn>0</mn>
    <mo>.</mo> <mn>0049</mn></mrow></math>
- en: <math alttext="u Subscript l Baseline equals upper P left-parenthesis l a s
    t vertical-bar n o t m a t c h right-parenthesis almost-equals 0.0008"><mrow><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>l</mi> <mi>a</mi>
    <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi>
    <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow> <mo>≈</mo> <mn>0</mn> <mo>.</mo>
    <mn>0008</mn></mrow></math>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="u Subscript l Baseline equals upper P left-parenthesis l a s
    t vertical-bar n o t m a t c h right-parenthesis almost-equals 0.0008"><mrow><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>l</mi> <mi>a</mi>
    <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi>
    <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow> <mo>≈</mo> <mn>0</mn> <mo>.</mo>
    <mn>0008</mn></mrow></math>
- en: <math alttext="u Subscript c Baseline equals upper P left-parenthesis c o n
    s t i t u e n c y vertical-bar n o t m a t c h right-parenthesis almost-equals
    0"><mrow><msub><mi>u</mi> <mi>c</mi></msub> <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo>
    <mi>c</mi> <mi>o</mi> <mi>n</mi> <mi>s</mi> <mi>t</mi> <mi>i</mi> <mi>t</mi> <mi>u</mi>
    <mi>e</mi> <mi>n</mi> <mi>c</mi> <mi>y</mi> <mo>|</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow> <mo>≈</mo>
    <mn>0</mn></mrow></math>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="u Subscript c Baseline equals upper P left-parenthesis c o n
    s t i t u e n c y vertical-bar n o t m a t c h right-parenthesis almost-equals
    0"><mrow><msub><mi>u</mi> <mi>c</mi></msub> <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo>
    <mi>c</mi> <mi>o</mi> <mi>n</mi> <mi>s</mi> <mi>t</mi> <mi>i</mi> <mi>t</mi> <mi>u</mi>
    <mi>e</mi> <mi>n</mi> <mi>c</mi> <mi>y</mi> <mo>|</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow> <mo>≈</mo>
    <mn>0</mn></mrow></math>
- en: This instinctively feels right. We know that a match will always have an equivalent
    constituency and either first name or last name will match, with last name slightly
    more likely to be equivalent than first name (five out of nine versus four out
    of nine in the preceding sample).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这种直觉感觉对。我们知道，每次匹配都会有一个相应的选区，名字要么是姓要么是名字匹配，姓氏比名字更有可能是等效的（在前述样本中，九个中的五个对九个中的四个）。
- en: Similarly, we know the constituency will never be the same in a `notmatch` record
    pair and it’s very unlikely that either the first name or last name will accidentally
    match either (with first name slightly more likely).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们知道在一个`notmatch`记录对中选区永远不会相同，而且名字或姓氏意外匹配的可能性也非常小（名字比姓氏稍有可能）。
- en: 'We can turn these estimated values into match probabilities using the equations
    in the previous section:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前一节中的方程将这些估计值转换为匹配概率：
- en: <math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue l a s t
    EndAbsoluteValue f i r s t right-parenthesis equals 1 minus left-parenthesis 1
    plus StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction
    times StartFraction m Subscript l Baseline Over u Subscript l Baseline EndFraction
    times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis
    EndFraction right-parenthesis Superscript negative 1 Baseline equals 1.0"><mrow><mi>P</mi>
    <mrow><mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo>
    <mi>l</mi> <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi>
    <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>1</mn> <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><msub><mi>m</mi>
    <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>×</mo><mfrac><msub><mi>m</mi>
    <mi>l</mi></msub> <msub><mi>u</mi> <mi>l</mi></msub></mfrac> <mo>×</mo><mfrac><mi>λ</mi>
    <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mn>1</mn> <mo>.</mo> <mn>0</mn></mrow></math>
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue l a s t
    EndAbsoluteValue f i r s t right-parenthesis equals 1 minus left-parenthesis 1
    plus StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction
    times StartFraction m Subscript l Baseline Over u Subscript l Baseline EndFraction
    times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis
    EndFraction right-parenthesis Superscript negative 1 Baseline equals 1.0"><mrow><mi>P</mi>
    <mrow><mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo>
    <mi>l</mi> <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>|</mo> <mi>f</mi> <mi>i</mi> <mi>r</mi>
    <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>1</mn> <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><msub><mi>m</mi>
    <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>×</mo><mfrac><msub><mi>m</mi>
    <mi>l</mi></msub> <msub><mi>u</mi> <mi>l</mi></msub></mfrac> <mo>×</mo><mfrac><mi>λ</mi>
    <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mn>1</mn> <mo>.</mo> <mn>0</mn></mrow></math>
- en: <math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue n o t l
    a s t EndAbsoluteValue f i r s t right-parenthesis equals 1 minus left-parenthesis
    1 plus StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction
    times StartFraction left-parenthesis 1 minus m Subscript l Baseline right-parenthesis
    Over left-parenthesis 1 minus u Subscript l Baseline right-parenthesis EndFraction
    times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis
    EndFraction right-parenthesis Superscript negative 1 Baseline almost-equals 0.0019"><mrow><mi>P</mi>
    <mrow><mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo>
    <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>l</mi> <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>|</mo>
    <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mn>1</mn> <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><msub><mi>m</mi>
    <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>×</mo><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>0019</mn></mrow></math>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue n o t l
    a s t EndAbsoluteValue f i r s t right-parenthesis equals 1 minus left-parenthesis
    1 plus StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction
    times StartFraction left-parenthesis 1 minus m Subscript l Baseline right-parenthesis
    Over left-parenthesis 1 minus u Subscript l Baseline right-parenthesis EndFraction
    times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis
    EndFraction right-parenthesis Superscript negative 1 Baseline almost-equals 0.0019"><mrow><mi>P</mi>
    <mrow><mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo>
    <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>l</mi> <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>|</mo>
    <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mn>1</mn> <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><msub><mi>m</mi>
    <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>×</mo><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>0019</mn></mrow></math>
- en: <math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue n o t f
    i r s t EndAbsoluteValue l a s t right-parenthesis equals 1 minus left-parenthesis
    1 plus StartFraction left-parenthesis 1 minus m Subscript f Baseline right-parenthesis
    Over left-parenthesis 1 minus u Subscript f Baseline right-parenthesis EndFraction
    times StartFraction m Subscript l Baseline Over u Subscript l Baseline EndFraction
    times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis
    EndFraction right-parenthesis Superscript negative 1 Baseline almost-equals 0.0141"><mrow><mi>P</mi>
    <mrow><mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo>
    <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi>
    <mo>|</mo> <mi>l</mi> <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mn>1</mn> <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><msub><mi>m</mi> <mi>l</mi></msub>
    <msub><mi>u</mi> <mi>l</mi></msub></mfrac> <mo>×</mo><mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>0141</mn></mrow></math>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue n o t f
    i r s t EndAbsoluteValue l a s t right-parenthesis equals 1 minus left-parenthesis
    1 plus StartFraction left-parenthesis 1 minus m Subscript f Baseline right-parenthesis
    Over left-parenthesis 1 minus u Subscript f Baseline right-parenthesis EndFraction
    times StartFraction m Subscript l Baseline Over u Subscript l Baseline EndFraction
    times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis
    EndFraction right-parenthesis Superscript negative 1 Baseline almost-equals 0.0141"><mrow><mi>P</mi>
    <mrow><mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo>
    <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi>
    <mo>|</mo> <mi>l</mi> <mi>a</mi> <mi>s</mi> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mn>1</mn> <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><msub><mi>m</mi> <mi>l</mi></msub>
    <msub><mi>u</mi> <mi>l</mi></msub></mfrac> <mo>×</mo><mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>≈</mo> <mn>0</mn> <mo>.</mo> <mn>0141</mn></mrow></math>
- en: <math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue n o t f
    i r s t EndAbsoluteValue n o t l a s t right-parenthesis equals 1 minus left-parenthesis
    1 plus StartFraction left-parenthesis 1 minus m Subscript f Baseline right-parenthesis
    Over left-parenthesis 1 minus u Subscript f Baseline right-parenthesis EndFraction
    times StartFraction left-parenthesis 1 minus m Subscript l Baseline right-parenthesis
    Over left-parenthesis 1 minus u Subscript l Baseline right-parenthesis EndFraction
    times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis
    EndFraction right-parenthesis Superscript negative 1 Baseline equals 0"><mrow><mi>P</mi>
    <mrow><mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo>
    <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi>
    <mo>|</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>l</mi> <mi>a</mi> <mi>s</mi> <mi>t</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mn>1</mn> <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mn>0</mn></mrow></math>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue n o t f
    i r s t EndAbsoluteValue n o t l a s t right-parenthesis equals 1 minus left-parenthesis
    1 plus StartFraction left-parenthesis 1 minus m Subscript f Baseline right-parenthesis
    Over left-parenthesis 1 minus u Subscript f Baseline right-parenthesis EndFraction
    times StartFraction left-parenthesis 1 minus m Subscript l Baseline right-parenthesis
    Over left-parenthesis 1 minus u Subscript l Baseline right-parenthesis EndFraction
    times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis
    EndFraction right-parenthesis Superscript negative 1 Baseline equals 0"><mrow><mi>P</mi>
    <mrow><mo>(</mo> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>|</mo>
    <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>f</mi> <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi>
    <mo>|</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>l</mi> <mi>a</mi> <mi>s</mi> <mi>t</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mn>1</mn> <mo>-</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mn>0</mn></mrow></math>
- en: As expected, these probabilities match the values we calculated using the probability
    maps in [Figure 4-3](#fig-4-3) when we knew the `match` and `notmatch` population
    upfront.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，这些概率与我们在[图4-3](#fig-4-3)中使用概率图计算的值相匹配，当我们预先知道`match`和`notmatch`人口时。
- en: In conclusion, we are now able to estimate match probabilities for all the different
    permutations of attribute equivalence without having to know the `match` population
    in advance. This probabilistic approach is both powerful and scalable to large
    datasets with multiple attributes. To help us apply these techniques more easily,
    we introduce a performant and easy-to-use open source library, Splink, in the
    next section.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们现在能够对属性等价的各种排列组合进行匹配概率估计，而无需事先了解`match`人口。这种概率方法既强大又可扩展，适用于具有多个属性的大型数据集。为了帮助我们更轻松地应用这些技术，我们在下一节中介绍了一个性能卓越且易于使用的开源库
    Splink。
- en: Introducing Splink
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入 Splink
- en: Splink is a Python package for probabilistic entity resolution. Splink implements
    the Fellegi-Sunter model and includes a variety of interactive outputs to help
    users understand models and diagnose linkage problems.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Splink 是用于概率实体解析的 Python 包。Splink 实现了 Fellegi-Sunter 模型，并包含各种交互式输出，帮助用户理解模型并诊断链接问题。
- en: Splink supports a number of backends to perform the matching calculations. To
    begin with, we will use DuckDB, an in-process SQL database management system,
    that we can run locally on our laptop.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Splink 支持多种后端来执行匹配计算。首先，我们将使用 DuckDB，这是一个在本地笔记本电脑上可以运行的进程内 SQL 数据库管理系统。
- en: Configuring Splink
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Splink
- en: 'To import Splink into our notebook, we use:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的笔记本中导入 Splink，请使用：
- en: '[PRE13]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Splink requires a unique ID column in each dataset, so we need to create these
    by copying their respective DataFrame indexes:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Splink 需要每个数据集中都有一个唯一的 ID 列，因此我们需要通过复制它们各自的 DataFrame 索引来创建这些列：
- en: '[PRE14]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Splink also needs the same columns to be present in both datasets. Therefore,
    we need to create blank columns where these are present in only one set of records
    and then remove unnecessary columns:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Splink 还需要在两个数据集中存在相同的列。因此，我们需要在只有一组记录中存在的情况下创建空白列，然后删除不必要的列：
- en: '[PRE15]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our next step is to configure Splink settings:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是配置 Splink 设置：
- en: '[PRE16]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Splink supports both deduplication of records within a single dataset and linking
    between one or more separate datasets. Here we set `link_type` to `link_only`
    to tell Splink that we want only to match, not deduplicate, between our two datasets.
    We also tell Splink the comparisons we wish to use, in this case exact matches
    across our three attributes. Lastly, we instantiate the linker with these settings
    and our source DataFrames.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Splink 支持对单个数据集中的记录进行去重，也支持在一个或多个独立数据集之间进行链接。在这里，我们将`link_type`设置为`link_only`，告诉
    Splink 我们只想在两个数据集之间进行匹配，不想进行去重。我们还告诉 Splink 我们希望使用哪些比较，本例中是在我们的三个属性上进行精确匹配。最后，我们使用这些设置和我们的源
    DataFrames 实例化链接器。
- en: 'To help us understand our datasets, Splink provides a visualization of the
    distribution of the columns to be matched:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们理解我们的数据集，Splink 提供了匹配列的分布可视化：
- en: '[PRE17]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The graphs we see in [Figure 4-6](#fig-4-6) show us the combined population
    across both datasets.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [图 4-6](#fig-4-6) 中看到的图表显示了两个数据集的综合人口。
- en: Starting with distribution of first names we can see from the bottom right of
    the graph that, within the population of 352 distinct names, approximately 35%
    occur only twice, most probably once in each dataset. Then, moving right to left,
    we see a gradual increase in frequency to the most popular name, with 32 occurrences.
    Looking at the top 10 values by value count we see that John is the most popular
    name, followed by Andrew, David, etc. This tells us that `Firstname` is a reasonable
    attribute to match on, but used alone, it will result in some false positives.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 从名字分布开始，我们可以从图表的右下方看到，在 352 个不同名称的人口中，大约有 35% 仅出现两次，很可能一次在每个数据集中。然后，从右到左移动，我们看到频率逐渐增加到最受欢迎的名称，有
    32 次出现。按值计数查看前 10 个值时，我们发现 John 是最流行的名字，其次是 Andrew、David 等。这告诉我们，`Firstname`是一个合理的匹配属性，但单独使用，它会导致一些误报。
- en: For last name the pattern is more stark, with a larger population of 574 distinct
    names, of which nearly 80% occur only twice. Looking at the top 10 values, the
    most common last names, Smith and Jones, occur 18 times, almost half as common
    as the most popular first name. As expected, this tells us that `Lastname` is
    a richer attribute than `Firstname` and therefore its equivalence is a better
    predictor of matching entities.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于姓氏，模式更加明显，有 574 个不同的姓氏，其中近 80% 仅出现两次。查看前 10 个值，最常见的姓氏，Smith 和 Jones，出现了 18
    次，几乎是最流行的名字的一半。正如预期的那样，这告诉我们`Lastname`是比`Firstname`更丰富的属性，因此其等价性是匹配实体的更好预测器。
- en: As expected, constituencies are uniquely paired across the two datasets, so
    all values appear exactly twice.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 预料之中，两个数据集之间的选区是唯一配对的，因此所有数值都恰好出现两次。
- en: '![](assets/hoer_0406.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0406.png)'
- en: Figure 4-6\. Splink column profiles
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-6\. Splink 列配置
- en: 'For the purposes of this simple example, we’re going to ask Splink to calculate
    all the parameters of the model using the expectation-maximization algorithm we
    introduced earlier. The initial `True` parameter tells Splink to compare all the
    records across both datasets without blocking (we’ll see this in the next chapter).
    We also tell Splink to recalculate the *u* values at each iteration by setting
    `fix_u_probabilities` to `False`. Setting the `fix_probability_two_random_records_match`
    to `False` means the <math alttext="lamda"><mi>λ</mi></math> value (the overall
    match probability between the two datasets) will be recalculated at each iteration.
    Finally, we tell Splink to use the updated  <math alttext="lamda"><mi>λ</mi></math>
     value when  calculating probabilities for record pairs.:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的示例中，我们将要求Splink使用我们之前介绍的期望最大化算法来计算模型的所有参数。初始的`True`参数告诉Splink比较两个数据集中所有的记录而不进行阻塞（我们将在下一章看到）。我们还告诉Splink在每次迭代时重新计算*u*值，通过设置`fix_u_probabilities`为`False`。将`fix_probability_two_random_records_match`设置为`False`意味着<math
    alttext="lamda"><mi>λ</mi></math>值（两个数据集之间的总体匹配概率）将在每次迭代时重新计算。最后，我们告诉Splink在计算记录对的概率时使用更新后的<math
    alttext="lamda"><mi>λ</mi></math>值：
- en: '[PRE18]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Splink Performance
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Splink 性能
- en: 'The EM model converges after three iterations.  Splink produces an interactive
    chart showing the iterative progression of the relative match weights values:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: EM模型在三次迭代后收敛。Splink生成一个交互式图表，显示相对匹配权重值的迭代进展：
- en: '[PRE19]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![](assets/hoer_0407.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0407.png)'
- en: Figure 4-7\. Splink match weights
  id: totrans-229
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-7\. Splink 匹配权重
- en: '[Figure 4-7](#fig-4-7) shows the final match weights that Splink has calculated
    after the third iteration. First, we have the prior (starting) match weight, which
    is a measure of how likely it is that two records chosen at random match. If you
    hover over the match weight bars you can see the calculated match weight value
    together with the underlying *m* and *u* parameters. These are calculated as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-7](#fig-4-7)显示了Splink在第三次迭代后计算的最终匹配权重。首先，我们有先验（起始）匹配权重，这是两个随机选择的记录匹配的可能性的度量。如果你将鼠标悬停在匹配权重条上，你可以看到计算出的匹配权重值以及底层的*m*和*u*参数。这些计算方法如下：'
- en: <math alttext="upper P r i o r left-parenthesis s t a r t i n g right-parenthesis
    m a t c h w e i g h t equals l o g 2 StartFraction lamda Over left-parenthesis
    1 minus lamda right-parenthesis EndFraction almost-equals negative 9.38"><mrow><mi>P</mi>
    <mi>r</mi> <mi>i</mi> <mi>o</mi> <mi>r</mi> <mrow><mo>(</mo> <mi>s</mi> <mi>t</mi>
    <mi>a</mi> <mi>r</mi> <mi>t</mi> <mi>i</mi> <mi>n</mi> <mi>g</mi> <mo>)</mo></mrow>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>w</mi> <mi>e</mi> <mi>i</mi>
    <mi>g</mi> <mi>h</mi> <mi>t</mi> <mo>=</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi>
    <mn>2</mn></msub> <mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac>
    <mo>≈</mo> <mo>-</mo> <mn>9</mn> <mo>.</mo> <mn>38</mn></mrow></math>
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P r i o r left-parenthesis s t a r t i n g right-parenthesis
    m a t c h w e i g h t equals l o g 2 StartFraction lamda Over left-parenthesis
    1 minus lamda right-parenthesis EndFraction almost-equals negative 9.38"><mrow><mi>P</mi>
    <mi>r</mi> <mi>i</mi> <mi>o</mi> <mi>r</mi> <mrow><mo>(</mo> <mi>s</mi> <mi>t</mi>
    <mi>a</mi> <mi>r</mi> <mi>t</mi> <mi>i</mi> <mi>n</mi> <mi>g</mi> <mo>)</mo></mrow>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>w</mi> <mi>e</mi> <mi>i</mi>
    <mi>g</mi> <mi>h</mi> <mi>t</mi> <mo>=</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi>
    <mn>2</mn></msub> <mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac>
    <mo>≈</mo> <mo>-</mo> <mn>9</mn> <mo>.</mo> <mn>38</mn></mrow></math>
- en: <math alttext="upper F i r s t n a m e m a t c h w e i g h t left-parenthesis
    e x a c t m a t c h right-parenthesis equals l o g 2 StartFraction m Subscript
    f Baseline Over u Subscript f Baseline EndFraction almost-equals 7.67"><mrow><mi>F</mi>
    <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mi>n</mi> <mi>a</mi> <mi>m</mi> <mi>e</mi>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>w</mi> <mi>e</mi> <mi>i</mi>
    <mi>g</mi> <mi>h</mi> <mi>t</mi> <mrow><mo>(</mo> <mi>e</mi> <mi>x</mi> <mi>a</mi>
    <mi>c</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub> <mfrac><msub><mi>m</mi>
    <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>≈</mo> <mn>7</mn>
    <mo>.</mo> <mn>67</mn></mrow></math>
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper F i r s t n a m e m a t c h w e i g h t left-parenthesis
    e x a c t m a t c h right-parenthesis equals l o g 2 StartFraction m Subscript
    f Baseline Over u Subscript f Baseline EndFraction almost-equals 7.67"><mrow><mi>F</mi>
    <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mi>n</mi> <mi>a</mi> <mi>m</mi> <mi>e</mi>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>w</mi> <mi>e</mi> <mi>i</mi>
    <mi>g</mi> <mi>h</mi> <mi>t</mi> <mrow><mo>(</mo> <mi>e</mi> <mi>x</mi> <mi>a</mi>
    <mi>c</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub> <mfrac><msub><mi>m</mi>
    <mi>f</mi></msub> <msub><mi>u</mi> <mi>f</mi></msub></mfrac> <mo>≈</mo> <mn>7</mn>
    <mo>.</mo> <mn>67</mn></mrow></math>
- en: <math alttext="upper F i r s t n a m e m a t c h w e i g h t left-parenthesis
    n o t e x a c t m a t c h right-parenthesis equals l o g 2 StartFraction left-parenthesis
    1 minus m Subscript f Baseline right-parenthesis Over left-parenthesis 1 minus
    u Subscript f Baseline right-parenthesis EndFraction almost-equals negative 6.98"><mrow><mi>F</mi>
    <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mi>n</mi> <mi>a</mi> <mi>m</mi> <mi>e</mi>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>w</mi> <mi>e</mi> <mi>i</mi>
    <mi>g</mi> <mi>h</mi> <mi>t</mi> <mrow><mo>(</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi>
    <mi>e</mi> <mi>x</mi> <mi>a</mi> <mi>c</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi>
    <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi>
    <mn>2</mn></msub> <mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow></mfrac> <mo>≈</mo> <mo>-</mo> <mn>6</mn> <mo>.</mo>
    <mn>98</mn></mrow></math>
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper F i r s t n a m e m a t c h w e i g h t left-parenthesis
    n o t e x a c t m a t c h right-parenthesis equals l o g 2 StartFraction left-parenthesis
    1 minus m Subscript f Baseline right-parenthesis Over left-parenthesis 1 minus
    u Subscript f Baseline right-parenthesis EndFraction almost-equals negative 6.98"><mrow><mi>F</mi>
    <mi>i</mi> <mi>r</mi> <mi>s</mi> <mi>t</mi> <mi>n</mi> <mi>a</mi> <mi>m</mi> <mi>e</mi>
    <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>w</mi> <mi>e</mi> <mi>i</mi>
    <mi>g</mi> <mi>h</mi> <mi>t</mi> <mrow><mo>(</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi>
    <mi>e</mi> <mi>x</mi> <mi>a</mi> <mi>c</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi>
    <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi>
    <mn>2</mn></msub> <mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>f</mi></msub> <mo>)</mo></mrow></mfrac> <mo>≈</mo> <mo>-</mo> <mn>6</mn> <mo>.</mo>
    <mn>98</mn></mrow></math>
- en: <math alttext="upper L a s t n a m e m a t c h w e i g h t left-parenthesis
    e x a c t m a t c h right-parenthesis equals l o g 2 StartFraction m Subscript
    l Baseline Over u Subscript l Baseline EndFraction almost-equals 10.23"><mrow><mi>L</mi>
    <mi>a</mi> <mi>s</mi> <mi>t</mi> <mi>n</mi> <mi>a</mi> <mi>m</mi> <mi>e</mi> <mi>m</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>w</mi> <mi>e</mi> <mi>i</mi> <mi>g</mi>
    <mi>h</mi> <mi>t</mi> <mrow><mo>(</mo> <mi>e</mi> <mi>x</mi> <mi>a</mi> <mi>c</mi>
    <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub> <mfrac><msub><mi>m</mi>
    <mi>l</mi></msub> <msub><mi>u</mi> <mi>l</mi></msub></mfrac> <mo>≈</mo> <mn>10</mn>
    <mo>.</mo> <mn>23</mn></mrow></math>
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper L a s t n a m e m a t c h w e i g h t left-parenthesis
    e x a c t m a t c h right-parenthesis equals l o g 2 StartFraction m Subscript
    l Baseline Over u Subscript l Baseline EndFraction almost-equals 10.23"><mrow><mi>L</mi>
    <mi>a</mi> <mi>s</mi> <mi>t</mi> <mi>n</mi> <mi>a</mi> <mi>m</mi> <mi>e</mi> <mi>m</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>w</mi> <mi>e</mi> <mi>i</mi> <mi>g</mi>
    <mi>h</mi> <mi>t</mi> <mrow><mo>(</mo> <mi>e</mi> <mi>x</mi> <mi>a</mi> <mi>c</mi>
    <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub> <mfrac><msub><mi>m</mi>
    <mi>l</mi></msub> <msub><mi>u</mi> <mi>l</mi></msub></mfrac> <mo>≈</mo> <mn>10</mn>
    <mo>.</mo> <mn>23</mn></mrow></math>
- en: <math alttext="upper L a s t n a m e m a t c h w e i g h t left-parenthesis
    n o t e x a c t m a t c h right-parenthesis equals l o g 2 StartFraction left-parenthesis
    1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis 1 minus
    u Subscript l Baseline right-parenthesis EndFraction almost-equals negative 7.32"><mrow><mi>L</mi>
    <mi>a</mi> <mi>s</mi> <mi>t</mi> <mi>n</mi> <mi>a</mi> <mi>m</mi> <mi>e</mi> <mi>m</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>w</mi> <mi>e</mi> <mi>i</mi> <mi>g</mi>
    <mi>h</mi> <mi>t</mi> <mrow><mo>(</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>e</mi>
    <mi>x</mi> <mi>a</mi> <mi>c</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi>
    <mi>h</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi>
    <mn>2</mn></msub> <mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac> <mo>≈</mo> <mo>-</mo> <mn>7</mn> <mo>.</mo>
    <mn>32</mn></mrow></math>
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper L a s t n a m e m a t c h w e i g h t left-parenthesis
    n o t e x a c t m a t c h right-parenthesis equals l o g 2 StartFraction left-parenthesis
    1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis 1 minus
    u Subscript l Baseline right-parenthesis EndFraction almost-equals negative 7.32"><mrow><mi>L</mi>
    <mi>a</mi> <mi>s</mi> <mi>t</mi> <mi>n</mi> <mi>a</mi> <mi>m</mi> <mi>e</mi> <mi>m</mi>
    <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi> <mi>w</mi> <mi>e</mi> <mi>i</mi> <mi>g</mi>
    <mi>h</mi> <mi>t</mi> <mrow><mo>(</mo> <mi>n</mi> <mi>o</mi> <mi>t</mi> <mi>e</mi>
    <mi>x</mi> <mi>a</mi> <mi>c</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi>
    <mi>h</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi>
    <mn>2</mn></msub> <mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi>
    <mi>l</mi></msub> <mo>)</mo></mrow></mfrac> <mo>≈</mo> <mo>-</mo> <mn>7</mn> <mo>.</mo>
    <mn>32</mn></mrow></math>
- en: <math alttext="upper C o n s t i t u e n c y m a t c h w e i g h t left-parenthesis
    e x a c t m a t c h right-parenthesis equals l o g 2 StartFraction m Subscript
    c Baseline Over u Subscript c Baseline EndFraction almost-equals 14.98"><mrow><mi>C</mi>
    <mi>o</mi> <mi>n</mi> <mi>s</mi> <mi>t</mi> <mi>i</mi> <mi>t</mi> <mi>u</mi> <mi>e</mi>
    <mi>n</mi> <mi>c</mi> <mi>y</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi>
    <mi>w</mi> <mi>e</mi> <mi>i</mi> <mi>g</mi> <mi>h</mi> <mi>t</mi> <mrow><mo>(</mo>
    <mi>e</mi> <mi>x</mi> <mi>a</mi> <mi>c</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi>
    <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi>
    <mn>2</mn></msub> <mfrac><msub><mi>m</mi> <mi>c</mi></msub> <msub><mi>u</mi> <mi>c</mi></msub></mfrac>
    <mo>≈</mo> <mn>14</mn> <mo>.</mo> <mn>98</mn></mrow></math>
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper C o n s t i t u e n c y m a t c h w e i g h t left-parenthesis
    e x a c t m a t c h right-parenthesis equals l o g 2 StartFraction m Subscript
    c Baseline Over u Subscript c Baseline EndFraction almost-equals 14.98"><mrow><mi>C</mi>
    <mi>o</mi> <mi>n</mi> <mi>s</mi> <mi>t</mi> <mi>i</mi> <mi>t</mi> <mi>u</mi> <mi>e</mi>
    <mi>n</mi> <mi>c</mi> <mi>y</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi> <mi>c</mi> <mi>h</mi>
    <mi>w</mi> <mi>e</mi> <mi>i</mi> <mi>g</mi> <mi>h</mi> <mi>t</mi> <mrow><mo>(</mo>
    <mi>e</mi> <mi>x</mi> <mi>a</mi> <mi>c</mi> <mi>t</mi> <mi>m</mi> <mi>a</mi> <mi>t</mi>
    <mi>c</mi> <mi>h</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>l</mi> <mi>o</mi> <msub><mi>g</mi>
    <mn>2</mn></msub> <mfrac><msub><mi>m</mi> <mi>c</mi></msub> <msub><mi>u</mi> <mi>c</mi></msub></mfrac>
    <mo>≈</mo> <mn>14</mn> <mo>.</mo> <mn>98</mn></mrow></math>
- en: For illustration purposes, Splink approximates the `Constituency` not exact
    match weight as negative infinity and displays it in a different color. This is
    because there are no cases where the `Firstname` and `Lastname` attributes match
    but the `Constituency` does not.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，Splink将`Constituency`的非精确匹配权重近似为负无穷，并以不同颜色显示。这是因为没有情况下`Firstname`和`Lastname`属性匹配但`Constituency`不匹配。
- en: 'We can see the discrete values Splink has calculated using:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Splink使用以下方法计算的离散值：
- en: '[PRE20]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The *m* and *u* probabilities match those we calculated manually using the expectation-maximization
    algorithm earlier in the chapter.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*m*和*u*概率与我们在本章早些时候使用期望最大化算法手动计算的那些匹配。'
- en: 'Finally, as before, we apply a threshold match probability and select the record
    pair above the threshold:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，和之前一样，我们应用一个阈值匹配概率，并选择高于阈值的记录对：
- en: '[PRE22]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Analysis of these predictions shows that all 633 are true positives, leaving
    the 13 by-election true negatives and 4 false negatives. We can view the 4 false
    negatives with:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些预测的分析显示，所有的633个都是真正例，剩下13个补选真负例和4个假负例。我们可以用以下方式查看这4个假负例：
- en: '[PRE23]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The output, shown in [Figure 4-8](#fig-4-8), shows that the mismatch on `Lastname`
    is the reason these entities fall below the match threshold.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果，如[图 4-8](#fig-4-8)所示，显示`Lastname`不匹配是这些实体未达到匹配阈值的原因。
- en: '![](assets/hoer_0408.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0408.png)'
- en: Figure 4-8\. Splink below the threshold due to `Lastname` mismatch
  id: totrans-248
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-8\. Splink 由于`Lastname`不匹配而低于阈值
- en: In comparison to the unweighted results in [Chapter 3](ch03.html#chapter_3),
    Splink declares a match for “Liz Truss” versus “Elizabeth Truss,” but does not
    match “Anne Marie Morris” to “Anne Morris,” nor “Martin Docherty-Hughes” to “Martin
    Docherty.” This is because it is  more heavily influenced by a mismatch on `Lastname`,
    which is statistically a better negative predictor, than a mismatch on `Firstname`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第三章](ch03.html#chapter_3)中的非加权结果相比，Splink认为“Liz Truss”与“Elizabeth Truss”匹配，但不将“Anne
    Marie Morris”与“Anne Morris”，以及“Martin Docherty-Hughes”与“Martin Docherty”匹配。这是因为它更受到`Lastname`不匹配的影响，统计上它是一个更好的负面预测因子，而不是`Firstname`不匹配。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: To recap, we took two sets of records and combined them into a composite dataset
    containing every record pair combination. We then computed exact match features
    between equivalent fields and then combined those features, weighted according
    to how often they occurred in both the matching and nonmatching populations, to
    determine the overall likelihood of a match.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们拿到了两组记录，并将它们合并成一个包含每对记录组合的复合数据集。然后，我们计算了等效字段之间的精确匹配特征，再根据它们在匹配和非匹配人群中出现的频率加权组合这些特征，以确定匹配的总体可能性。
- en: We saw how to use probability theory to calculate the match weights using the
    iterative expectation-maximization algorithm when we don’t have known `match`
    populations.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到如何在没有已知`match`人群的情况下，利用概率论来使用迭代期望最大化算法计算匹配权重。
- en: Finally, we introduced the probabilistic entity resolution framework Splink,
    which greatly simplified the calculations when combining multiple attributes and
    helped us visualize and understand our match results.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了概率实体解析框架Splink，它在组合多个属性时大大简化了计算，并帮助我们可视化和理解我们的匹配结果。
- en: Now that we have worked through a small-scale example, we will apply the techniques
    of approximate and probabilistic matching on a larger scale.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过一个小规模示例了解了如何在更大规模上应用近似和概率匹配的技术。
- en: ^([1](ch04.html#id429-marker)) The original paper is available [online](https://oreil.ly/gcfWx).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch04.html#id429-marker)) 原始论文可以在[网上](https://oreil.ly/gcfWx)找到。
