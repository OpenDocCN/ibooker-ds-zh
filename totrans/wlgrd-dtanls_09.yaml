- en: '10 Rapid prototyping: Data analysis'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prototyping ideas quickly to support a business case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring a dataset to build a proof of concept
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, data analysis is about investigating whether an idea is viable. For
    example, is the available data good enough for the business to build a data-driven
    app? We can answer questions like this one by analyzing the data, but it would
    be even more powerful if we could build a working *proof of concept*. By doing
    this, we make the idea come to life for our stakeholders. Crucially, we also discover
    any obstacles to using the data for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Real business case: Building a proof of concept'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This chapter was inspired by one of the first projects I delivered as a data
    scientist. The data team was tasked with creating a revenue-generating product.
    The idea was an app that lets someone enter a vehicle’s registration and display
    the current market conditions for that vehicle and vehicles similar to it. Defining
    what made a vehicle similar enough was the hard part, and that was the data-driven
    secret sauce behind the product. Once we’d established some rules, I built a quick
    proof of concept to show stakeholders that the idea worked. Building this proof
    of concept also meant I could communicate the specific challenges of building
    the product for real, which I knew because I had actually tried to make it work
    with the available data and systems.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, spanning this chapter and the next, we practice the skill of
    *rapid prototyping* by exploring a new dataset and building a proof of concept.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1 The rapid prototyping process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data teams often sit in an R&D function or are expected to do R&D as part of
    their job. This means they don’t just analyze data to answer questions but sometimes
    build things that don’t currently exist in the company. A valuable and often overlooked
    skill for an analyst is to be able to put something functional together to investigate
    the feasibility of an idea. This something is often called a *proof of concept*
    (POC), a *prototype*, or a *minimum viable product* (MVP), although an MVP is
    often even further along than a prototype.
  prefs: []
  type: TYPE_NORMAL
- en: Note  Terminology in this area tends to vary. In this chapter, I will be using
    specific definitions of “proof of concept” and “prototype.” The project task will
    be to build a proof of concept, but in the chapter title, the more general process
    of building something to test an idea is called “rapid prototyping.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Although these terms tend to be used interchangeably, they are subtly different:'
  prefs: []
  type: TYPE_NORMAL
- en: A proof of concept is something that tests an idea. It doesn’t have to be a
    polished product; it just needs to be complex enough to see whether an idea is
    feasible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A prototype evolves from a proof of concept. Once an idea has been tested, we
    can build a small, usable product based on the proof of concept with real data.
    It won’t be finished, it can live in a development environment like someone’s
    laptop, and it won’t have the features of fully functioning software, but it is
    in a state that mimics a finished product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a prototype exists and has been presented to stakeholders, there might
    be a step where an MVP is created. An MVP is a pilot launch to get the product
    out into the hands of real users as soon as possible. It might be missing some
    features, but it’s in a production environment, and rigor has been applied to
    ensure it works correctly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether we are talking about an app, a website, or a machine learning model,
    there will be a notion of putting it into production. Production means it is working
    and people are using it, whether they are internal users or external customers.
    Reaching the MVP stage counts as putting something into production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 10.1 shows an example of this process, including the fact that an idea
    can be abandoned at any of the stages from initial ideation to after a working
    prototype is built.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 The path from an idea to production and the steps in between
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s see a concrete example.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1.1 Rapid prototyping example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose your stakeholders want to know which customers are likely to churn from
    their e-commerce platform. In other words, which customers are likely to stop
    using the service? They want to see a list of at-risk customers in some kind of
    tool or dashboard, like an “early warning system,” so they can take action and
    prevent those users from churning.
  prefs: []
  type: TYPE_NORMAL
- en: As an analyst, you might build a model to predict users who are at risk of churning
    and then incorporate that into such an interactive tool. Table 10.1 shows the
    three stages of this product’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Table 10.1 An example walkthrough of the three stages
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Stage | Task | Success criteria | Possible reasons to abandon at this stage
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1) Proof of concept  | Build a basic predictive model.  | • Basic model built
    to an acceptable level of accuracy. • Available data is sufficient to build a
    model.'
  prefs: []
  type: TYPE_NORMAL
- en: '| • Available data is insufficient for even a basic churn model.  |'
  prefs: []
  type: TYPE_TB
- en: '| 2) Prototype  | Build a working interactive tool.  | • Users can use the
    tool to take preventative measures to keep at-risk customers. • Predictions can
    be made in a timely manner.'
  prefs: []
  type: TYPE_NORMAL
- en: '| • Data required for predictions not available at prediction time. • No market
    for the product.'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 3) Production  | Build the tool as fully functioning software with a working
    data pipeline.  | • Preventative measures have a tangible financial effect.  |
    • Insufficient return on investment. • Low usage of the tool.'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Why is a proof of concept so important at the start? We want to understand
    the following as quickly as possible:'
  prefs: []
  type: TYPE_NORMAL
- en: Do we have the data to answer the question, build the predictive model, and
    create our app?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will we have the data when we need it once the product goes live? Plenty of
    machine learning projects have failed because, while historical data was available
    to train the model, new data wasn’t available for the model to make a prediction
    at a useful time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the challenges in building this product? These might be related to
    data availability, but they might be any number of other technical challenges.
    The key is that you don’t know all the challenges of building something until
    you actually try to build it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What distinguishes the prototype phase from the proof of concept is that we
    have different questions now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Is anyone interested in this product?* The product doesn’t have to exist to
    answer this question—a prototype is sufficient. Even a dashboard or a machine
    learning model deployed internally within a company needs to have product market
    fit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How would real users use this?* With a prototype, you can test your assumptions
    about how a real user of the product would use it without having to build the
    whole product. It is still early enough in the process that it shouldn’t be too
    costly to scrap the project at this phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These concepts are familiar to software developers and product managers, but
    they also have merit for analysts. The ability to put together a proof of concept
    and a subsequent prototype helps analysts identify what is valuable to work on
    and iterate ideas faster, which in turn means a more results-oriented way of working.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now put these ideas into practice. The project brief is only partly about
    analyzing data to answer a question. It is also about building something to evaluate
    whether the data could support a paying product.
  prefs: []
  type: TYPE_NORMAL
- en: '10.2 Project 7: Build a proof of concept to investigate Welsh property prices'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at the project, in which we will not only analyze some data, but
    also build a proof-of-concept data product to show to stakeholders. We will start
    by looking at the problem statement, the data dictionary, the outputs we are aiming
    for, and what tools we need to tackle the problem. We will spend more time than
    usual thinking about the output since we’re going beyond analysis and into creating
    products. We can then formulate a results-oriented action plan and dive into the
    example solution.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2.1 Problem statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’re working for CymruHomes Connect, a property company specializing in homes
    in Wales. They’re looking to expand their business with the help of data; they
    want to provide insights about the Welsh property market to customers in the form
    of a new app. This app would use historic property sales data to allow users to
    explore property prices in their area of interest.
  prefs: []
  type: TYPE_NORMAL
- en: They have discovered that the UK government’s Land Registry has a dataset called
    “Price Paid,” which contains publicly available historical sales data. They have
    extracted and made available a few years’ worth of this data.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE  Original data come from [https://mng.bz/yWvB](https://mng.bz/yWvB). It
    contains HM Land Registry data © Crown copyright and database right 2021\. This
    data is licensed under the Open Government Licence v3.0\. Thank you both to the
    Land Registry and Royal Mail for permission to use the house price and address
    data, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'They have asked you to look into whether this data is indeed suitable for powering
    their new app. This is quite vague, but they have some ideas they’d like to incorporate:'
  prefs: []
  type: TYPE_NORMAL
- en: They are particularly interested in the analysis of property types, for example,
    whether a house is terraced or detached, because they believe it strongly influences
    their customers when choosing a property, so they’d like the analysis to include
    breakdowns by this dimension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They also believe users will be interested in comparing properties at the lowest
    level of granularity, so the ability to see street-level data is important.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have only asked you to explore the data and see what questions can be answered
    with it, focusing on the angles they mentioned previously. However, we will go
    beyond their request and build a proof of concept to showcase what the final app
    might look like and do.
  prefs: []
  type: TYPE_NORMAL
- en: An important lesson I’ve learned from working in data science is that stakeholders
    often cannot articulate exactly what they want because they lack understanding
    of what is possible. Creating proofs of concept is a way to help bridge this gap
    and provide additional value as a data professional.
  prefs: []
  type: TYPE_NORMAL
- en: Before we discuss what our steps might be in the process, let’s review the available
    data, the desired outcomes, and the tools we will need.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2.2 Data dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As always, a key initial step is to take a look at the available data. Table
    10.2 shows the data dictionary as provided by the Land Registry. Part of the data
    dictionary comes from Kaggle ([https://mng.bz/QDWG](https://mng.bz/QDWG)), and
    the address columns are detailed here: [https://mng.bz/XxWv](https://mng.bz/XxWv).
    The definitions from the original data dictionaries are provided as is.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 10.2 Data dictionary of the Price Paid data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Column | Definition |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Transaction unique identifier  | A reference number generated automatically,
    recording each published sale. The number is unique and will change each time
    a sale is recorded.  |'
  prefs: []
  type: TYPE_TB
- en: '| Price  | Sale price stated on the transfer deed.  |'
  prefs: []
  type: TYPE_TB
- en: '| Date of transfer  | Date when the sale was completed, as stated on the transfer
    deed.  |'
  prefs: []
  type: TYPE_TB
- en: '| Postcode  | Postal code of the address.  |'
  prefs: []
  type: TYPE_TB
- en: '| Property type  | D = Detached, S = Semi-detached, T = Terraced, F = Flats/Maisonettes,
    O = Other  |'
  prefs: []
  type: TYPE_TB
- en: '| Old/New  | Indicates the age of the property and applies to all Price Paid
    transactions, residential and nonresidential. Y = A newly built property, N =
    An established residential building'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Duration  | Relates to the tenure: F = Freehold, L= Leasehold  |'
  prefs: []
  type: TYPE_TB
- en: '| Primary addressable object name (PAON)  | Typically house number/name (e.g.,
    42 or “Oak Cottage”).  |'
  prefs: []
  type: TYPE_TB
- en: '| Second addressable object name (SAON)  | If there is a sub-building, for
    example, the building is divided into flats, there will be a SAON.  |'
  prefs: []
  type: TYPE_TB
- en: '| Street  | The street part of the address.  |'
  prefs: []
  type: TYPE_TB
- en: '| Locality  | Additional detail about the location (e.g., a district in a city).  |'
  prefs: []
  type: TYPE_TB
- en: '| Town/City  | The town/city part of the address.  |'
  prefs: []
  type: TYPE_TB
- en: '| District  | The district part of the address.  |'
  prefs: []
  type: TYPE_TB
- en: '| County  | The county part of the address.  |'
  prefs: []
  type: TYPE_TB
- en: '| Category type  | Indicates the type of Price Paid transaction. A = Standard
    Price Paid entry; includes single residential property sold for full market value.'
  prefs: []
  type: TYPE_NORMAL
- en: B = Additional Price Paid entry; includes transfers under a power of sale/repossessions,
    buy-to-lets (where they can be identified by a mortgage) and transfers to nonprivate
    individuals.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Record status  | Relevant to monthly files only. Indicates additions, changes,
    and deletions to the records. Yearly files contain latest versions of all records.  |'
  prefs: []
  type: TYPE_TB
- en: Now that we have seen what’s available, let’s look at the outcomes of this project.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2.3 Desired outcomes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our stakeholders initially want recommendations about what kind of analyses
    we could include in a potential app with the available data. Recommendations about
    additional data sources to incorporate would also be useful. Finally, we have
    decided to build a proof of concept, partly to show the stakeholders what their
    potential app might look like, but also to test whether the data is sufficient
    to build a useful product.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2.4 Required tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What constitutes a proof of concept will depend on your preferred tools. It
    might be a working web application, such as the one built with the Python library
    `streamlit` in the example solution. However, it could be a dashboard, such as
    one built with the R language’s package Shiny, or with a business intelligence
    tool such as Tableau or Power BI.
  prefs: []
  type: TYPE_NORMAL
- en: In the example solution, I use Python and the `pandas` library for data exploration,
    and `matplotlib`, `seaborn`, and `ridgeplot` for visualization. I also introduce
    the `streamlit` library to build the interactive, web-based proof of concept.
    Your tools may differ, especially for the proof-of-concept stage. The checklist
    for this project is that your tool can
  prefs: []
  type: TYPE_NORMAL
- en: Load and combine large datasets from CSV files containing millions of rows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform basic data manipulation tasks, such as filtering, sorting, grouping,
    and reshaping data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create data visualizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an interactive application, whether a dashboard or a web application,
    where different artifacts, such as charts or other visualizations, are displayed
    based on user input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tip  You might find it easier to use two different tools for this project:
    one for the data analysis and another for building a proof of concept. If you
    use a programming language that contains libraries or packages for building applications,
    such as Shiny for R or `streamlit` for Python, you may want to use this project
    to try them out.'
  prefs: []
  type: TYPE_NORMAL
- en: 10.3 Applying the results-driven method to investigating Welsh property data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s now address this problem with our results-driven framework and formulate
    our action plan.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-unnumb-1.png)'
  prefs: []
  type: TYPE_IMG
- en: We have an idea of what our stakeholders want to see. Their interest is in whether
    the data is suitable to support the app idea they have. They have stated that
    they are particularly interested in property types and whether street-level data
    can be incorporated into their app. We also understand that building a proof of
    concept will allow us to identify possible problems with using this data, which
    is why we will spend the time doing so.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-unnumb-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Starting at the end means thinking about the app first and foremost. We cannot
    know exactly what will go in the app until we analyze the data, but keeping an
    eye on the app during the analysis phase will help us focus on getting results
    sooner. Whenever we create charts during the analysis phase, we should consider
    whether they would be useful in the proof of concept. Therefore, our analysis
    won’t just consider our stakeholders’ requests, but also the possible preferences
    of future users of the app. Our minimum viable answer in this project will look
    more like a minimum viable product would if we were designing software, which
    we are to an extent.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-unnumb-3.png)'
  prefs: []
  type: TYPE_IMG
- en: In this instance, the data has been identified for us. However, while building
    our proof of concept, we may identify gaps in the data or aspects of the property
    market that it doesn’t cover. We should consider additional data sources that
    would improve the quality of the app and recommend them when communicating our
    results to the stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-unnumb-4.png)'
  prefs: []
  type: TYPE_IMG
- en: The data has been downloaded for us in its raw form from the Land Registry.
    However, we will need to combine the different yearly files before we start exploring
    the data. We may also wish to spend some time looking at the source of the data,
    that is, the Land Registry website, to learn more about how it was collected and
    what its possible limitations may be.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-unnumb-5.png)'
  prefs: []
  type: TYPE_IMG
- en: We will work on the project in two phases. The first phase is analyzing the
    available data, so our high-level steps might be
  prefs: []
  type: TYPE_NORMAL
- en: Investigate the completeness of the data, such as identifying missing data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the geographic breakdown of the data, such as the different address
    levels, like locality and district.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we understand the geographic breakdown, we can extract Welsh properties
    to use in our app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also want to investigate property types as per our stakeholders’ request.
    Questions we may be interested in are the following: How does the sale price vary
    by property type? Which property types are more popular? Do these price and popularity
    patterns vary geographically?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we want to identify visualizations that can be recreated in our proof-of-concept
    app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we have completed our initial analysis, we can look to building our proof
    of concept. Our considerations for this phase, and therefore requirements for
    our proof-of-concept app, are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Any data and visualizations displayed in the app should change based on user
    input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The app should use all the real, available Welsh property data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Options that users can change should come from the data (e.g., a list of counties
    they can select from).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The proof of concept does not need to be a web application; it just needs to
    contain interactive elements based on real data that you can show your stakeholders.
    A dashboard built in a BI tool would meet these criteria. If you’re a Python and
    Jupyter user, even having interactive widgets inside a Jupyter notebook would
    suffice.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-unnumb-6.png)'
  prefs: []
  type: TYPE_IMG
- en: The presentation of the output would consist of communicating the results of
    the analysis phase, as well as allowing stakeholders to see and even try the interactive
    proof of concept. The two complement each other because any limitations of the
    proof of concept will be discovered in the analysis phase and can be communicated
    while demonstrating the proof of concept itself.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-unnumb-7.png)'
  prefs: []
  type: TYPE_IMG
- en: Iteration is key when rapidly prototyping ideas. Whatever tool we use to build
    our proof of concept should make it easy to quickly make wholesale changes to
    its functionality. At this stage, we are not bound by production considerations
    such as user authentication, permissions, or managing servers and databases. We
    should be able to make changes quickly based on feedback both at the proof-of-concept
    and prototype stages.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an action plan outlined, it’s time to start working on the
    project. If you are reading this chapter from start to end, I suggest that this
    is the time to attempt the project yourself before reading the next section, which
    details an example solution.
  prefs: []
  type: TYPE_NORMAL
- en: '10.4 An example solution: Building a prototype to explore using house price
    data'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s walk through an example solution. As ever, I strongly recommend attempting
    the project yourself first, as our solutions will differ, particularly for this
    project.
  prefs: []
  type: TYPE_NORMAL
- en: As for the action plan, we will combine the separate yearly files first. Then,
    we will explore the combined dataset, paying particular attention to property
    types and the geographical hierarchy of the data, as per our stakeholders’ request.
    We will decide which visualizations will go into our app before identifying an
    appropriate tool with which to build our proof of concept. Finally, we will build
    a proof of concept using the data, where the user can change the visualizations
    that are displayed based on their input.
  prefs: []
  type: TYPE_NORMAL
- en: 10.4.1 Analyzing data before prototyping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step in our process is to merge the different yearly files that our
    stakeholders provided. They cover the period from 2021 to 2023 inclusive. Initially,
    we will assume they have the same format, but we are prepared for this not to
    be the case.
  prefs: []
  type: TYPE_NORMAL
- en: Merging datasets without headings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s take a look at one of the files. The following code produces the output
    shown in figure 10.2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/10-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 A snapshot of the raw 2021 data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Upon inspection, the files contain no headers, so we need to provide column
    names based on the data dictionary. Apart from that, we will convert the date
    column to the correct type so we can verify that the data indeed covers the years
    it claims to. The following code reads in each of the yearly files in turn and
    combines them into a single `pandas` `DataFrame`. The output, a snapshot of the
    combined data, is shown in figure 10.3.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/10-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 A snapshot of the combined Price Paid data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s verify that this combined dataset starts at the beginning of 2021 and
    ends in late 2023\. We will look at the smallest and largest dates to do this,
    as shown in the following code, the output of which presented in figure 10.4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/10-4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 Verification that the data does indeed cover the years 2021–2023
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now that we have combined our data and verified the date range, we will export
    it for later use. This means our analysis and proof of concept code can reference
    the combined data directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to move on to the analysis phase.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating data quality
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s do some initial sanity checking of the combined data. We are interested
    in looking at missing data, outliers, especially in the sale price, and breakdowns
    of the various categories. We will start by reading the data again. If we continue
    from the previous code snippets, this is not strictly necessary, but because we
    decided it was good practice to split the merging and the analysis code, we will
    write the code that way. In the example code files, the merging and analysis phases
    happen in separate files, so we will be consistent here, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we also set something called the “float format.” This is a way to tell
    `pandas` how to display numbers. The reason we explicitly set it is that house
    prices will vary significantly, and it is likely that `pandas` will show the largest
    numbers using scientific notation. That is, one million would be shown as `1e6`
    or similar rather than displaying all the zeros. Setting the float format will
    avoid this problem, and as we will be working with prices that are monetary values,
    two decimal points makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by looking at missing data across our columns. The following code
    investigates this, and the output is shown in figure 10.5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/10-5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 Number of missing values by column
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This output tells us that all missing data is related to addresses. We have
    some missing postcodes, street names, and a lot of missing data for locality and
    the “second addressable object name” (SAON). These latter columns will be specific
    to different areas and properties, so they are unlikely to be a problem. The data
    dictionary even suggested that not all properties have a SAON.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should examine instances where there is no street name for a property, as
    this may be a problem, especially considering our stakeholders asked about street-level
    data. The following code investigates some missing street names, and the output
    is shown in figure 10.6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/10-6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 A sample of properties with no street details
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: While this is only a small selection of the over 50,000 rows with missing street
    names, it does appear that a lot of these instances are properties that have names
    like “The Barn” or “The Old School.” This might explain why parts of the address
    are missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could leave these missing street names intact since, in many cases, they
    appear to be not applicable rather than missing. However, if we are to surface
    street names to users in our app, we need an option to filter on properties with
    no street name. We could handle this in the app itself or fill in the missing
    data with a placeholder value. Let’s opt to make the data as clean as possible
    and fill in the missing value. The following code achieves this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take stock of what we have done so far and start building up our diagram
    to document our steps. Figure 10.7 shows what we have done so far, including the
    decision about what to do about missing street names.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 The first steps of our analysis
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Investigating missing geographic data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'More worrying than missing street names is the fact that we have thousands
    of missing postcodes. Again, let’s look at a selection of these. The following
    code finds some examples, and the output is shown in figure 10.8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/10-8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 A selection of records with missing postcode data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Looking at the house names, these also seem like properties with explicit names,
    as well as some references to garages. However, in this case, that does not explain
    why there is no postcode information since UK addresses generally have a postcode.
    We have a decision to make about this missing data. On the one hand, the missing
    records are a small percentage of the overall dataset, but on the other hand,
    these records still contribute to the housing market and, therefore, all contain
    relevant information.
  prefs: []
  type: TYPE_NORMAL
- en: We will keep records that have no postcode information, but we will be mindful
    of their presence while continuing our analysis. As we have reached another decision
    point, let’s add this to our diagram in figure 10.9 to record the latest step
    in our analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 The latest diagram of our analytical steps
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Investigating distribution and outliers in a price column
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We are also interested in the distribution of the price column as it is the
    key variable on which our app will be based. The following code produces a high-level
    statistical summary of the data, which is shown in figure 10.10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/10-10.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 Statistical overview of the `sale_price` column
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There are values ranging from £1 to over £500 million, so there will be outliers
    to handle. The mean is also significantly higher than the median, which is shown
    as 50% in the diagram, suggesting that the data is right-skewed. That in itself
    is not worrisome because price data tends to be in that shape, but we will investigate
    the outliers. To start with, let’s look at properties that sold for less than
    £1,000\. The following code applies this filter, and the output is shown in figure
    10.11:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/10-11.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 A sample of 10 properties that sold for less than £1,000
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Looking at the addresses of these transactions, there does not seem to be other
    data errors that could explain these low sale prices. However, all these transactions
    are in category B, according to the `category_type` column. Consulting the data
    dictionary in table 8.1, we can see that category B records are nonstandard transactions,
    including “transfers under a power of sale/repossessions.” It seems to be the
    case that properties categorized under B were sold for nominal amounts for reasons
    other than a standard property purchase. To verify this, let’s look at the proportion
    of category A versus B in the lower-valued properties. The following code does
    this and produces the output in figure 10.12:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/10-12.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 Distribution of `category_type` for low-valued properties
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This offers an explanation for the lowest values in our data. There are also
    properties in the range of over £500M, as evidenced by the table in figure 10.10\.
    Let’s inspect those to find out more. The following code identifies those high-value
    properties, and the output is shown in figure 10.13:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/10-13.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 Properties worth over £300M
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Based on the names, one of these is an entire science park, and after doing
    some research, it appears the most expensive transaction might be something called
    Nine Elms Park, a large green space in a development in London, situated on Nine
    Elms Lane.
  prefs: []
  type: TYPE_NORMAL
- en: 'To conclude our analysis of the price column, lower-valued transactions are
    due to being a special type, category B, and the highest-valued transactions are
    entire developments rather than individual properties. We don’t want to include
    those high-value transactions in our app, which is aimed at residential buyers,
    so we will drop the highest values. We could also consider dropping category B
    transactions, but perhaps users of the app might be interested if there were repossessions
    or other nonstandard transactions in the area they’re interested in, so we’ll
    leave that data intact. The following code keeps only the data under a high threshold,
    say £10M, which is a reasonable cutoff for most residential buyers. Anyone with
    a higher budget will be better served by more specialized real estate agencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Since we had to make a decision about outliers, let’s add another step to our
    diagram documenting the process so far, as shown in figure 10.14.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-14.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 Latest diagram of the process, including the investigation of price
    outliers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now, we are ready to look at other aspects of the data, namely, the various
    categorizations of our property transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating categorizations in the data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are several different ways that properties are categorized in our data.
    Judging by the data dictionary in table 8.1, we may want to update the names of
    these categories to be more descriptive. Let’s look at them in turn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Property type is of strong interest to our stakeholders. This data is labeled
    with individual letters (e.g., T for terraced houses). This is fine, but if we
    want to use the data in our app or even label charts correctly, the full names
    would be better. The following code remaps the property types to their full names
    and then creates the chart in figure 10.15, which shows the breakdown of property
    types in our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/10-15.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 Breakdown of property types in our data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you have seen what houses in the United Kingdom are generally like, it won’t
    be a surprise to see that most properties are either terraced or semi-detached.
    Now, let’s remap the other categorizing columns, starting with whether a property
    is a new build or not, that is, newly built at the time of purchase. The following
    code recategorizes the data and produces the output in figure 10.16 to investigate
    the breakdown of this column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/10-16.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 The breakdown of existing vs. newly built properties
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The sanity check of this column should be that most properties were already
    built at the time of purchase, which is what we see in the data. Let’s now update
    the `duration` column, which differentiates freehold from leasehold properties.
    Leasehold means you don’t own the land your structure is on; you need to pay additional
    fees and renew your lease if it is expiring. The majority of properties in the
    United Kingdom should be freeholds. Let’s verify this while also recategorizing
    the data. The following code does this, and the output is shown in figure 10.17:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/10-17.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 Breakdown of freehold vs. leasehold properties
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now that we have investigated most of our property data, we should turn our
    attention to the aspect we haven’t touched yet: geography.'
  prefs: []
  type: TYPE_NORMAL
- en: 10.4.2 Investigating geographic aspects of a dataset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our stakeholders are interested only in the Welsh property market, so we need
    to extract only the transactions that occurred in Wales before we can build our
    proof of concept. This will require extracting that information somehow as we
    do not have an obvious country column. For more practice extracting information
    from addresses, see a related project in chapter 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever we work with addresses, we have several options to extract additional
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, there is a column that stores the necessary information already. In
    this case, there isn’t.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have a combined address field, such as the project in chapter 2, we could
    extract the right address component. We also do not have that in this case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could use an existing column to cross-reference against official lists, similar
    to what we did in the example solution of chapter 2, where we cross-referenced
    address data with a definitive list of cities in the United Kingdom. In the case
    of this project, we could also cross-reference one of the address categorizations
    and find the ones corresponding to Wales.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A more complex, but possibly more accurate, method would be to use a third-party
    geocoding service to get a structured version of our address data. For the data
    in this project, we could send the service the combination of all the address
    columns we have and get back the same address in a standardized format, which
    would include the country column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out of these options, the third one seems to strike a balance between accuracy
    and effort. The last option is something to consider for a future iteration if
    we want to maximize accuracy, but only if we identify that the extra work is worth
    the effort. Let’s now investigate the different address categorizations in the
    data and see which one could be cross-referenced against a relevant, official
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to look at the `town_city` column and cross-reference it against
    a list of Welsh cities. Running the following command reveals that we have 1,150
    unique values for the town/city component. We will also uppercase the column just
    in case we have some inconsistent casing in the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Having so many values increases the possibility of errors. There could be misspellings
    and other duplicate values, and there are town names that exist in both England
    and Wales, such as Newport. Let’s look at a higher level of geography instead:
    counties. The following code investigates the frequency of counties present in
    the data and also reveals the number of unique items, as shown in figure 10.18:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/10-18.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.18 A breakdown of the number of records by county
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'From this output, we can tell there are 115 unique county values in the data,
    Greater London being the most common. The most frequent records tell us that the
    number of records per county is in the region of the tens of thousands, which
    makes some of the least common values suspicious. Northamptonshire is not a small
    county, so we would expect more than 707 records. Perhaps there are misspellings
    or overlapping county values. We will investigate these by looking for just the
    word NORTH and see what is returned. The following code does this, and the output
    is shown in figure 10.19:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/10-19.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.19 All counties containing the word NORTH
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We find that there are also records for both North and West Northamptonshire.
    If we were interested in counties in England, we may consider combining these.
    It is possible this data doesn’t exactly match official lists, but it is easier
    to clean 115 county records than over 1,000 town names.
  prefs: []
  type: TYPE_NORMAL
- en: Sanity checking our data from external sources
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For now, we want an official list of counties in Wales to cross-reference against
    our data. The Welsh government has this list published on their website: [https://law.gov.wales/local-government-bodies](https://law.gov.wales/local-government-bodies).'
  prefs: []
  type: TYPE_NORMAL
- en: Note  If the website is inaccessible, a copy of its relevant content is included
    in the supplementary materials for this chapter. The file is called `wales-local-government-bodies.htm`.
    It can be found in the `data` folder and is viewable in any web browser.
  prefs: []
  type: TYPE_NORMAL
- en: The list is in bullet points about halfway down the page, as shown in figure
    10.20.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-20.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.20 Official list of counties in Wales
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'From this page, we can extract the unique names of counties. Our data is in
    English, not Welsh, so we only need the English part of this list. We also don’t
    need the “County Borough Council” part, as those phrases are not contained in
    the `county` column of our data. We will take this list of counties and assume
    any record that contains one of these counties is a Welsh property, and everything
    else is in England. The following code categorizes the records into England or
    Wales based on their county. We’ll then look at the distribution of this new `country`
    column, which is shown in figure 10.21:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/10-21.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.21 The breakdown of England vs. Wales in our data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As we said earlier, it is possible that some of the values in the `county`
    column don’t match the list of Welsh counties exactly. We should look at all the
    counties categorized as England with our method and check if any are misspellings
    of the Welsh counties. The following code retrieves these counties, as shown in
    figure 10.22:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/10-22.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.22 A list of counties we categorized as belonging to England
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We could employ more sophisticated methods to find county names in this list
    that are almost like one of the Welsh counties, but since there aren’t that many
    counties in total, we can do this manually. See the example solution in chapter
    3 for ideas on how to do more sophisticated string matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a glance, the only county that seems miscategorized is Rhondda Cynon Taf,
    which appears in the data with a double f at the end. Let’s manually recategorize
    those instances as Wales to make the data more accurate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As a final step in this part, we will extract only the Welsh properties into
    their own DataFrame so that all our analyses will be limited to Welsh properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to explore this subset of Welsh transactions to see what aspects
    of the data should be included in our proof-of-concept app. But before we move
    on, let’s review our progress so far in the form of a diagram, shown in figure
    10.23\. Then, we’ll be ready to explore the Welsh property data to identify visualizations
    we want to include in our proof-of-concept app.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-23.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.23 The process up until the point of identifying Welsh properties
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 10.4.3 Identifying how to present data in the prototype
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have separated the data by country, let’s explore different aspects
    of the Welsh property market.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating variations in geography
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, let’s see the difference in sale price between counties. When a user
    wants to purchase a property, the app should help them identify what property
    prices look like in their desired area. The plot is shown in figure 10.24, and
    the code after the figure calculates and plots the median sale price by county
    for Welsh properties only.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-24.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.24 Median property price by county in Wales
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There is clear geographic disparity across counties. This data covers multiple
    years, so we should also investigate its temporal aspects. How has the number
    of transactions changed over time? The following code creates the plot in figure
    10.25:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/10-25.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.25 Number of annual property transactions in Wales
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There is a definite overall downward trend in the number of transactions. Does
    this pattern also affect prices? We can calculate the median sale price by county
    and year to investigate this. The following code calculates this and visualizes
    it with the heatmap shown in figure 10.26:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/10-26.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.26 Heatmap showing property prices by county and year
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In most counties, we observe an increase in the median sale price from 2021
    to 2022 and then a decrease again in 2023\. Although the number of transactions
    seems to be steadily dropping, it appears the prices have only been affected in
    the latest full year of data. We will want to include some aspects of this information
    in our final app.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of the difference across counties might be in property type,
    which is something our stakeholders are specifically interested in. The code following
    figure 10.27 calculates the median price by county and property type and plots
    the heatmap in the figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-27.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.27 A heatmap showing property prices across county and property type
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Reduces the font size of the axis labels'
  prefs: []
  type: TYPE_NORMAL
- en: 'This heatmap tells us that detached properties have the highest value in all
    counties, but there is high variability in the “Other” category. This matches
    what is typical for the UK property market: detached properties are more desirable
    than semi-detached ones, which are more desirable than terraced properties. This
    pattern seems to exist across counties.'
  prefs: []
  type: TYPE_NORMAL
- en: Using ridgeline plots to look at distribution across groups
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What these heatmaps don’t tell us is the distribution of prices. We could use
    histograms or box plots to show this by county or by year. However, we might want
    to get a bit more adventurous to make the app stand out more visually. One option
    is something called a *ridgeline plots*, which looks like a smoothed histogram
    by category, but the histograms are stacked behind each other. To illustrate this
    better, the following code creates a ridgeline plot of the distribution of prices
    by year, as shown in figure 10.28\. The data needs to be a list of prices, one
    list per year. Because the number of transactions is not constant for each year,
    we cannot use a tabular data structure, so we created three lists of prices that
    can be of different lengths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Creates a list of prices per year and collects this list in another list'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 annual_sales will be a list of pandas Series objects.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 The ridgeplot module is specialized for this kind of plot.'
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-28.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.28 A ridgeline plot showing property prices over time
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This plot shows the distribution of prices changing over time and conserves
    space by having the plots overlap in a 3D effect. Let’s do something similar with
    prices by county to better show the spread of prices rather than simple averages.
    The following code collects the data for prices by county and creates the associated
    ridgeline plot, which is shown in figure 10.29\. This time, we will remove the
    temporal aspect and focus only on properties that were sold in 2023, so our plot
    is as up to date and relevant as possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/10-29.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.29 A ridgeline plot of prices by county
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This plot is more information dense than the one in figure 10.24, which shows
    only median prices. We’ll include this plot in the app as a reference, so users
    have an idea of property prices across the country. We will also include the number
    of transactions over time for the area a user is interested in, as well as a breakdown
    by property type, such as the chart in figure 10.15\. These visualizations, coupled
    with the interactivity that we plan to add, will form our minimum viable answer
    for this project.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s revisit the entire process up until this point. Figure 10.30 shows what
    we have done so far, including the most recent step of deciding which visuals
    to include in the app.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-30.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.30 The process until the decision of which visualizations to include
    in the proof of concept
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Beyond the visualizations we have chosen to include, we will want to add some
    interactivity to the app. We will do this in the form of filters so that the user
    can filter the data down to just the area they are interested in, which will update
    the charts accordingly. To do this, we need to understand what levels of granularity
    we will let users drill down to. Our stakeholders requested street-level information
    in the app if possible, so let’s investigate whether this is possible with the
    available data.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating geographic hierarchy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have several columns in the data that refer to different address components.
    To devise our filters for the app, we need to understand their hierarchy. Based
    on knowledge of address hierarchies, we would assume that the hierarchy consists
    of counties, districts, towns, and streets. However, the words “county” and “district”
    may have different meanings in different datasets, so we will verify whether this
    hierarchy is correct. To do this, we will count the number of distinct records
    in each category. The smaller the number of distinct values, the higher the level
    that category is in the hierarchy. The following code calculates this and produces
    the result in figure 10.31.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/10-31.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.31 Number of distinct records for each address component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Interestingly, there seems to be a one-to-one mapping between counties and
    districts. To verify this, we should see whether any county has more than one
    district mapped to it in the data or vice versa. We achieve this with the following
    code. Our assumption is that if both these lines of code return 0 results, then
    we have a perfect one-to-one mapping between counties and districts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Both results return nothing, meaning there are no districts attached to more
    than one county, and no counties attached to more than one district. Perhaps the
    district column is relevant for England, but it is redundant for Wales. We can,
    therefore, conclude that our address hierarchy is counties, then towns and cities,
    and, finally, streets. These are, therefore, the three filters we will include
    in the app. Before we start building the app, let’s export our Welsh properties
    as a dataset of their own, which the app can read. The app should read our cleaned
    and filtered data, and it should not have to manipulate it in any way. The following
    code exports the data to the optimized Parquet format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: That concludes the first part of the project; we prepared our data and are ready
    to build the proof of concept. Let’s revisit what we have done so far before moving
    on to build the proof of concept in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 10.4.4 Project progress so far
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far in the project, we
  prefs: []
  type: TYPE_NORMAL
- en: Merged multiple years of property sales data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Investigated the quality of the data, including missing values and outliers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identified geographic data of interest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Investigated the distribution and outliers of the sale price column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhanced our geographic data with external government data to separate English
    property transactions from Welsh ones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identified appropriate visualizations for our proof of concept, including a
    ridgeline plot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exported the relevant, cleaned Welsh property transactions, which our proof
    of concept will use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we move on to the final part, figure 10.32 shows our progress so far.
    In the next chapter, we will move on to the final part of the project, which is
    to build the proof-of-concept tool itself.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/10-32.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.32 Part 1 of the project before building the proof of concept
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building a working proof of concept can be the best way to identify problems
    in the data that would prevent it from being used for a particular purpose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring data with a view to building a proof of concept includes assessing
    whether the data is appropriate for the task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output of the analysis should be a cleaned dataset that our proof of concept
    can use as is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
