<html><head></head><body><section data-pdf-bookmark="Preface" data-type="preface" epub:type="preface"><div class="preface" id="idm45963637040680">&#13;
<h1>Preface</h1>&#13;
&#13;
&#13;
<p>Programming is a force multiplier.&#13;
We can write computer programs to free ourselves from tedious manual tasks and to accelerate research.&#13;
Programming in <em>any</em> language will likely improve your productivity, but each language has different learning curves and tools that improve or impede the process of coding.</p>&#13;
&#13;
<p>There is an adage in business that says you have three choices:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Fast</p>&#13;
</li>&#13;
<li>&#13;
<p>Good</p>&#13;
</li>&#13;
<li>&#13;
<p>Cheap</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Pick any two.</p>&#13;
&#13;
<p>When it comes to programming languages, Python hits a sweet spot in that it’s <em>fast</em> because <a data-primary="Python" data-secondary="about" data-type="indexterm" id="idm45963637035528"/>it’s fairly easy to learn and to write a working prototype of an idea—it’s pretty much always the first language I’ll use to write any program.&#13;
I find Python to be <em>cheap</em> because my programs will usually run well enough on commodity hardware like my laptop or a tiny AWS instance.&#13;
However, I would contend that it’s not necessarily easy to make <em>good</em> programs using Python because the language itself is fairly lax.&#13;
For instance, it allows one to mix characters and numbers in operations that will crash the program.</p>&#13;
&#13;
<p>This book has been written for the aspiring bioinformatics programmer who wants to learn about Python’s best practices and tools such as the following:<a data-primary="Python" data-secondary="best practices" data-type="indexterm" id="idm45963637080248"/><a data-primary="best practices" data-secondary="about" data-type="indexterm" id="idm45963636944200"/><a data-primary="reproducible programs" data-secondary="about best practices" data-type="indexterm" id="idm45963636939240"/></p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Since Python 3.6, you can add type hints to indicate, for instance, that a variable should be a <em>type</em> like a number or a list, and you can use the <code>mypy</code> tool to ensure the types are used correctly.</p>&#13;
</li>&#13;
<li>&#13;
<p>Testing frameworks like <code>pytest</code> can exercise your code with both good and bad data to ensure that it reacts in some predictable way.<a data-primary="pytest tool" data-secondary="about" data-type="indexterm" id="idm45963636969160"/><a data-primary="test-driven development (TDD)" data-secondary="pytest tool" data-type="indexterm" id="idm45963636995400"/></p>&#13;
</li>&#13;
<li>&#13;
<p>Tools like <code>pylint</code> and <code>flake8</code> can find potential errors and stylistic problems that would make your programs more difficult to understand.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>argparse</code> module can document and validate the arguments to your &#13;
<span class="keep-together">programs.</span></p>&#13;
</li>&#13;
<li>&#13;
<p>The Python ecosystem allows you to leverage hundreds of existing modules like Biopython to shorten programs and make them more reliable.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Using these tools practices individually will improve your programs, but combining them all will improve your code in compounding ways.&#13;
This book is not a textbook on bioinformatics per se.&#13;
The focus is on what Python offers that makes it suitable for writing scientific programs that are <em>reproducible</em>.&#13;
That is, I’ll show you how to design and test programs that will always produce the same outputs given the same inputs.&#13;
Bioinformatics is saturated with poorly written, undocumented programs, and my goal is to reverse this trend, one program at a time.</p>&#13;
&#13;
<p>The criteria for program reproducibility include:<a data-primary="reproducible programs" data-secondary="criteria for" data-type="indexterm" id="idm45963636952152"/><a data-primary="best practices" data-secondary="reproducible programs" data-type="indexterm" id="idm45963637082008"/></p>&#13;
<dl>&#13;
<dt>Parameters</dt>&#13;
<dd>&#13;
<p>All program parameters can be set as runtime arguments. This means no hard-coded values which would require changing the source code to change the program’s behavior.</p>&#13;
</dd>&#13;
<dt>Documentation</dt>&#13;
<dd>&#13;
<p>A program should respond to a <code>--help</code> argument by printing the parameters and usage.</p>&#13;
</dd>&#13;
<dt>Testing</dt>&#13;
<dd>&#13;
<p>You should be able to run a test suite that proves the code meets some &#13;
<span class="keep-together">specifications</span></p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>You might expect that this would logically lead to programs that are perhaps correct, but alas, as Edsger Dijkstra famously said, “Program testing can be used to show the presence of bugs, but never to show their absence!”<a data-primary="Dijkstra, Edsger" data-type="indexterm" id="idm45963613662232"/><a data-primary="test-driven development (TDD)" data-secondary="bug presence not absence" data-type="indexterm" id="idm45963635132744"/></p>&#13;
&#13;
<p>Most bioinformaticians are either scientists who’ve learned programming or programmers who’ve learned biology (or people like me who had to learn both).&#13;
No matter how you’ve come to the field of bioinformatics, I want to show you practical programming techniques that will help you write correct programs quickly.&#13;
I’ll start with how to write programs that document and validate their arguments.&#13;
Then I’ll show how to write and run tests to ensure the programs do what they purport.</p>&#13;
&#13;
<p>For instance, the first chapter shows you how to report the tetranucleotide frequency from a string of DNA.&#13;
Sounds pretty simple, right?&#13;
It’s a trivial idea, but I’ll take about 40 pages to show how to structure, document, and test this program.&#13;
I’ll spend a lot of time on how to write and test several different versions of the program so that I can explore many aspects of Python data structures, syntax, modules, and tools.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Who Should Read This?" data-type="sect1"><div class="sect1" id="idm45963637037336">&#13;
<h1>Who Should Read This?</h1>&#13;
&#13;
<p>You should read this book if you care about the craft of programming, and if you want to learn how to write programs that produce documentation, validate their parameters, fail gracefully, and work reliably.&#13;
Testing is a key skill both for understanding your code and for verifying its correctness.&#13;
I’ll show you how to use the tests I’ve written as well as how to write tests for your programs.</p>&#13;
&#13;
<p>To get the most out of this book, you should already have a solid understanding of Python.&#13;
I will build on the skills I taught in <em>Tiny Python Projects</em> (Manning, 2020), where I show how to use Python data structures like strings, lists, tuples, dictionaries, sets, and named tuples.&#13;
You need not be an expert in Python, but I definitely will push you to understand some advanced concepts I introduce in that book, such as types, regular expressions, and ideas about higher-order functions, along with testing and how to use tools like <code>pylint</code>, <code>flake8</code>, <code>yapf</code>, and <code>pytest</code> to check style, syntax, and correctness.&#13;
One notable difference is that I will consistently use type annotations for all code in this book and will use the <code>mypy</code> tool to ensure the correct use of types.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Programming Style: Why I Avoid OOP and Exceptions" data-type="sect1"><div class="sect1" id="idm45963636986264">&#13;
<h1>Programming Style: Why I Avoid OOP and Exceptions</h1>&#13;
&#13;
<p>I tend to avoid object-oriented programming (OOP).&#13;
If you don’t know what OOP means, that’s OK.<a data-primary="OOP (object-oriented programming)" data-type="indexterm" id="idm45963636983160"/><a data-primary="Python" data-secondary="about OOP" data-type="indexterm" id="idm45963636982520"/><a data-primary="functions" data-secondary="about OOP" data-type="indexterm" id="idm45963637089496"/>&#13;
Python itself is an OO language, and almost every element from a string to a set is technically an object with internal state and methods.&#13;
You will encounter enough objects to get a feel for what OOP means, but the programs I present will mostly avoid using objects to represent ideas.</p>&#13;
&#13;
<p>That said, <a data-type="xref" href="ch01.html#ch01">Chapter 1</a> shows how to use a <code>class</code> to represent a complex data structure.<a data-primary="classes" data-secondary="about" data-type="indexterm" id="idm45963636948232"/>&#13;
The <code>class</code> allows me to define a data structure with type annotations so that I can verify that I’m using the data types correctly.&#13;
It does help to understand a bit about OOP.&#13;
For instance, classes define the attributes of an object, and classes can inherit attributes from parent classes, but this essentially describes the limits of how and why I use OOP in Python.&#13;
If you don’t entirely follow that right now, don’t worry.&#13;
You’ll understand it once you see it.</p>&#13;
&#13;
<p>Instead of object-oriented code, I demonstrate programs composed almost entirely of <em>functions</em>.<a data-primary="functions" data-secondary="about" data-type="indexterm" id="idm45963636963928"/><a data-primary="functional programming (FP)" data-secondary="pure functions versus OOP" data-type="indexterm" id="idm45963636962984"/>&#13;
These functions are also <em>pure</em> in that they will only act on the values given to them.<a data-primary="functions" data-secondary="pure functions" data-type="indexterm" id="idm45963636940648"/><a data-primary="pure functions" data-type="indexterm" id="idm45963636939704"/>&#13;
That is, pure functions never rely on some hidden, mutable state like global variables, and they will always return the same values given the same arguments.&#13;
Additionally, every function will have an associated test that I can run to verify it behaves predictably.&#13;
It’s my opinion that this leads to shorter programs that are more transparent and easier to test than solutions written using OOP.&#13;
You may disagree and are of course welcome to write your solutions using whatever style of programming you prefer, so long as they pass the tests.&#13;
The Python <a href="https://docs.python.org/3/howto/functional.html">Functional Programming HOWTO documentation</a><a data-primary="functional programming (FP)" data-secondary="Functional Programming HOWTO" data-tertiary="Python suited for FP" data-type="indexterm" id="idm45963637211448"/><a data-primary="resources" data-secondary="functional programming in Python" data-type="indexterm" id="idm45963637072104"/><a data-primary="Python" data-secondary="functional programming online guide" data-type="indexterm" id="idm45963637071192"/> makes a good case for why Python is suited for functional programming (FP).</p>&#13;
&#13;
<p>Finally, the programs in this book also avoid the use of exceptions, which I think is appropriate for short programs you write for personal use.<a data-primary="exceptions not caught" data-seealso="errors" data-type="indexterm" id="idm45963636975144"/><a data-primary="errors" data-secondary="exceptions not caught" data-type="indexterm" id="idm45963636994328"/>&#13;
Managing exceptions so that they don’t interrupt the flow of a program adds another level of complexity that I feel detracts from one’s ability to understand a program.&#13;
I’m generally unhappy with how to write functions in Python that return errors.&#13;
Many people would raise an exception and let a <code>try</code>/<code>catch</code> block handle the mistakes.&#13;
If I feel an exception is warranted, I will often choose to <em>not</em> catch it, instead letting the program crash.&#13;
In this respect, I’m following an idea from Joe Armstrong, the creator of the Erlang language, who said, “The Erlang <em>way</em> is to write the happy path, and not write twisty little passages full of error correcting code.”<a data-primary="errors" data-secondary="Erlang way" data-type="indexterm" id="idm45963613651960"/></p>&#13;
&#13;
<p>If you choose to write programs and modules for public release, you will need to learn much more about exceptions and error handling, but that’s beyond the scope of this book.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Structure" data-type="sect1"><div class="sect1" id="idm45963637085800">&#13;
<h1>Structure</h1>&#13;
&#13;
<p>The book is divided into two main parts.&#13;
The first part tackles 14 of the programming challenges found at the <a href="http://rosalind.info/about">Rosalind.info website.</a><sup><a data-type="noteref" href="preface01.html#idm45963637034392" id="idm45963637034392-marker">1</a></sup><a data-primary="Franklin, Rosalind" data-type="indexterm" id="idm45963637033720"/><a data-primary="Rosalind.info challenges" data-secondary="URL for 14 programming challenges" data-type="indexterm" id="idm45963637033048"/><a data-primary="Rosalind.info challenges" data-secondary="about Rosalind Franklin" data-type="indexterm" id="idm45963636967384"/>&#13;
The second part shows more complicated programs that demonstrate other patterns or concepts I feel are important in bioinformatics.&#13;
Every chapter of the book describes a coding challenge for you to write and provides a test suite for you to determine when you’ve written a working program.</p>&#13;
&#13;
<p>Although the <a href="https://oreil.ly/20PSy">“Zen of Python”</a> says “There should be one—and preferably only one—obvious way to do it,” I believe you can learn quite a bit by attempting many different approaches to a problem.<a data-primary="Python" data-secondary="Zen of Python" data-type="indexterm" id="idm45963637199064"/>&#13;
Perl was my gateway into bioinformatics, and the Perl community’s spirit of “There’s More Than One Way To Do It” (TMTOWTDI) still resonates with me.&#13;
I generally follow a theme-and-variations approach to each chapter, showing many solutions to explore different aspects of Python syntax and data structures.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Test-Driven Development" data-type="sect1"><div class="sect1" id="idm45963637197336">&#13;
<h1>Test-Driven Development</h1>&#13;
<blockquote>&#13;
<p>More than the act of testing, the act of designing tests is one of the best bug preventers known.<a data-primary="Beizer, Boris" data-type="indexterm" id="idm45963637031224"/><a data-primary="test-driven development (TDD)" data-secondary="designing tests prevents bugs" data-type="indexterm" id="idm45963637030552"/><a data-primary="best practices" data-secondary="test-driven development" data-type="indexterm" id="idm45963637029576"/><a data-primary="reproducible programs" data-secondary="test-driven development" data-type="indexterm" id="idm45963636990888"/> The thinking that must be done to create a useful test can discover and eliminate bugs before they are coded—indeed, test-design thinking can discover and eliminate bugs at every stage in the creation of software, from conception to specification, to design, coding, and the rest.</p>&#13;
<p data-type="attribution">Boris Beizer, <cite>Software Testing Techniques (Thompson Computer Press)</cite></p>&#13;
</blockquote>&#13;
&#13;
<p>Underlying all my experimentation will be test suites that I’ll constantly run to ensure the programs continue to work correctly.<a data-primary="test-driven development (TDD)" data-secondary="about" data-type="indexterm" id="idm45963636937752"/><a data-primary="Beck, Kent" data-type="indexterm" id="idm45963636936792"/><a data-primary="Test-Driven Development (Beck)" data-type="indexterm" id="idm45963636936120"/><a data-primary="resources" data-secondary="Test-Driven Development book" data-type="indexterm" id="idm45963636935432"/>&#13;
Whenever I have the opportunity, I try to teach <em>test-driven development</em> (TDD), an idea explained in a book by that title written by Kent Beck (Addison-Wesley, 2002).&#13;
TDD advocates writing tests for code <em>before</em> writing the code.&#13;
The typical cycle involves the following:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Add a test.</p>&#13;
</li>&#13;
<li>&#13;
<p>Run all tests and see if the new test fails.</p>&#13;
</li>&#13;
<li>&#13;
<p>Write the code.</p>&#13;
</li>&#13;
<li>&#13;
<p>Run tests.</p>&#13;
</li>&#13;
<li>&#13;
<p>Refactor code.</p>&#13;
</li>&#13;
<li>&#13;
<p>Repeat.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>In the book’s <a href="https://oreil.ly/yrTZZ">GitHub repository</a>, you’ll find the tests for each program you’ll write.<a data-primary="test-driven development (TDD)" data-secondary="book test GitHub repository" data-type="indexterm" id="idm45963636921080"/><a data-primary="resources" data-secondary="book code and tests on GitHub" data-type="indexterm" id="idm45963636920104"/>&#13;
I’ll explain how to run and write tests, and I hope by the end of the material you’ll believe in the common sense and basic decency of using TDD.&#13;
I hope that thinking about tests first will start to change the way you understand and explore coding.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using the Command Line and Installing Python" data-type="sect1"><div class="sect1" id="idm45963625728504">&#13;
<h1>Using the Command Line and Installing Python</h1>&#13;
&#13;
<p>My experience in bioinformatics has always been centered around the Unix command line.<a data-primary="command line (Unix)" data-secondary="about using" data-type="indexterm" id="idm45963625727384"/><a data-primary="Unix command line" data-secondary="about using" data-type="indexterm" id="idm45963625726440"/><a data-primary="bash shell" data-secondary="about using Unix command line" data-seealso="Unix command line" data-type="indexterm" id="idm45963636919000"/>&#13;
Much of my day-to-day work has been on some flavor of Linux server, stitching together existing command-line programs using shell scripts, Perl, and Python.&#13;
While I might write and debug a program or a pipeline on my laptop, I will often deploy my tools to a high-performance compute (HPC) cluster where a scheduler will run my programs asynchronously, often in the middle of the night or over a weekend and without any supervision or intervention by me.&#13;
Additionally, all my work building databases and websites and administering servers is done entirely from the command line, so I feel strongly that you need to master this environment to be successful in bioinformatics.</p>&#13;
&#13;
<p>I used a Macintosh to write and test all the material for this book, and macOS has the Terminal app you can use for a command line.<a data-primary="Macintosh Terminal for command line" data-type="indexterm" id="idm45963636916392"/>&#13;
I have also tested all the programs using various Linux distributions, and the GitHub repository includes instructions on how to use a Linux virtual machine with Docker.<a data-primary="Linux virtual machine with Docker" data-type="indexterm" id="idm45963636915384"/><a data-primary="Docker and Linux virtual machine" data-type="indexterm" id="idm45963636930360"/>&#13;
Additionally, I tested all the programs on Windows 10 using the Ubuntu distribution Windows Subsystem for Linux (WSL) version 1.<a data-primary="Windows" data-secondary="Windows Subsystem for Linux (WSL)" data-type="indexterm" id="idm45963636929400"/>&#13;
I <em>highly</em> recommend WSL for Windows users to have a true Unix command line, but Windows shells like <code>cmd.exe</code>, PowerShell, and Git Bash can sometimes work sufficiently well for some programs.</p>&#13;
&#13;
<p>I would encourage you to explore integrated development environments (IDEs) like VS Code, PyCharm, or Spyder to help you write, run, and test your programs.<a data-primary="IDEs (integrated development environments)" data-secondary="about" data-type="indexterm" id="idm45963636926744"/>&#13;
These tools integrate text editors, help documentation, and terminals.&#13;
Although I wrote all the programs, tests, and even this book using the <code>vim</code> editor in a terminal, most people would probably prefer to use at least a more modern text editor like Sublime, TextMate, or Notepad++.</p>&#13;
&#13;
<p>I wrote and tested all the examples using Python versions 3.8.6 and 3.9.1.<a data-primary="Python" data-secondary="versions of Python" data-type="indexterm" id="idm45963625724488"/>&#13;
Some examples use Python syntax that was not present in version 3.6, so I would recommend you not use that version.&#13;
Python version 2.x is no longer supported and should not be used.&#13;
I tend to get the latest version of Python 3 from <a href="https://www.python.org/downloads">the Python download page</a>, but I’ve also had success using the <a href="https://www.anaconda.com">Anaconda Python distribution</a>.<a data-primary="Python" data-secondary="downloading Python" data-type="indexterm" id="idm45963625721688"/><a data-primary="resources" data-secondary="Python" data-tertiary="download pages" data-type="indexterm" id="idm45963625720744"/><a data-primary="installation" data-secondary="downloading Python" data-type="indexterm" id="idm45963637022904"/>&#13;
You may have a package manager like <code>apt</code> on Ubuntu or <code>brew</code> on Mac that can install a recent version, or you may choose to build from source.&#13;
Whatever your platform and installation method, I would recommend you try to use the most recent version as the language continues to change, mostly for the better.</p>&#13;
&#13;
<p>Note that I’ve chosen to present the programs as command-line programs and not as Jupyter Notebooks for several reasons.<a data-primary="Jupyter Notebooks" data-type="indexterm" id="idm45963637020104"/><a data-primary="Notebooks (Jupyter)" data-type="indexterm" id="idm45963637019432"/><a data-primary="JSON (JavaScript Object Notation)" data-type="indexterm" id="idm45963637018760"/>&#13;
I like Notebooks for data exploration, but the source code for Notebooks is stored in JavaScript Object Notation (JSON) and not as line-oriented text.&#13;
This makes it very difficult to use tools like <code>diff</code> to find the differences between two Notebooks.&#13;
Also, Notebooks cannot be parameterized, meaning I cannot pass in arguments from outside the program to change the behavior but instead have to change the source code itself.&#13;
This makes the programs inflexible and automated testing impossible.&#13;
While I encourage you to explore Notebooks, especially as an interactive way to run Python, I will focus on how to write command-line programs.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Getting the Code and Tests" data-type="sect1"><div class="sect1" id="gettingCodeandTests">&#13;
<h1>Getting the Code and Tests</h1>&#13;
&#13;
<p>All the code and tests are available from the book’s GitHub repository.<a data-primary="Python" data-secondary="downloading Python" data-tertiary="book code and tests" data-type="indexterm" id="idm45963637013928"/><a data-primary="GitHub" data-secondary="cloning book code and tests" data-type="indexterm" id="idm45963637012712"/><a data-primary="book code and tests on GitHub" data-type="indexterm" id="idm45963637011752"/><a data-primary="command line (Unix)" data-secondary="cloning book code and test repository" data-type="indexterm" id="idm45963637011064"/><a data-primary="Unix command line" data-secondary="cloning book code and test repository" data-type="indexterm" id="idm45963637010104"/><a data-primary="Git" data-secondary="cloning book code and test repository" data-type="indexterm" id="idm45963637009352"/><a data-primary="installation" data-secondary="book code and tests" data-type="indexterm" id="idm45963637008440"/>&#13;
You can use the program Git (which you may need to install) to copy the code to your computer with the following command.<a data-primary="resources" data-secondary="book code and tests on GitHub" data-tertiary="clone command line" data-type="indexterm" id="idm45963637007224"/>&#13;
This will create a new directory called <em>biofx_python</em> on your computer with the contents of the repository:</p>&#13;
&#13;
<pre data-type="programlisting">$ git clone https://github.com/kyclark/biofx_python</pre>&#13;
&#13;
<p>If you enjoy using an IDE, it may be possible to clone the repository through that interface, as shown in Figure P-1.<a data-primary="IDEs (integrated development environments)" data-secondary="cloning book code and test repository" data-type="indexterm" id="idm45963637004216"/><a data-primary="PyCharm to clone GitHub repository" data-type="indexterm" id="idm45963637003288"/>&#13;
Many IDEs can help you manage projects and write code, but they all work differently.&#13;
To keep things simple, I will show how to use the command line to accomplish most tasks.</p>&#13;
&#13;
<figure><div class="figure" id="fig_0.1">&#13;
<img alt="mpfb 0001" src="assets/mpfb_0001.png"/>&#13;
<h6><span class="label">Figure P-1. </span>The PyCharm tool can directly clone the GitHub repository for you</h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note">&#13;
<p>Some tools, like PyCharm, may automatically try to create a <em>virtual environment</em> inside the project directory. <a data-primary="PyCharm to clone GitHub repository" data-secondary="virtual environment optional" data-type="indexterm" id="idm45963636891496"/>This is a way to insulate the version of Python and modules from other projects on your computer. Whether or not you use virtual environments is a personal preference. It is not a requirement to use them.</p>&#13;
</div>&#13;
&#13;
<p>You may prefer to make a copy of the code in your own account so that you can track your changes and share your solutions with others.<a data-primary="Git" data-secondary="forking to own repository" data-type="indexterm" id="idm45963636889448"/><a data-primary="GitHub" data-secondary="forking book code and tests" data-type="indexterm" id="idm45963636888488"/><a data-primary="forking book code and tests to repository" data-type="indexterm" id="idm45963636887528"/>&#13;
This is called <em>forking</em> because you’re breaking off from my code and adding your programs to the repository.</p>&#13;
&#13;
<p>To fork my GitHub repository, do the following:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Create an account on GitHub.com.</p>&#13;
</li>&#13;
<li>&#13;
<p>Go to <a href="https://github.com/kyclark/biofx_python"><em class="hyperlink">https://github.com/kyclark/biofx_python</em></a>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Click the Fork button in the upper-right corner (see Figure P-2) to make a copy of the repository in your account.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<figure><div class="figure" id="fig_0.2">&#13;
<img alt="mpfb 0002" src="assets/mpfb_0002.png"/>&#13;
<h6><span class="label">Figure P-2. </span>The Fork button on my GitHub repository will make a copy of the code in your account</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now that you have a copy of all my code in your repository, you can use Git to copy that code to your computer.&#13;
Be sure to replace <code><em>YOUR_GITHUB_ID</em></code> with your actual GitHub ID:</p>&#13;
&#13;
<pre data-type="programlisting">$ git clone https://github.com/<em>YOUR_GITHUB_ID</em>/biofx_python</pre>&#13;
&#13;
<p>I may update the repo after you make your copy.<a data-primary="GitHub" data-secondary="forking book code and tests" data-tertiary="upstream source" data-type="indexterm" id="idm45963637201656"/><a data-primary="Git" data-secondary="forking to own repository" data-tertiary="upstream source" data-type="indexterm" id="idm45963636771768"/><a data-primary="forking book code and tests to repository" data-secondary="upstream source" data-type="indexterm" id="idm45963636770536"/>&#13;
If you would like to be able to get those updates, you will need to configure Git to set my repository as an <em>upstream</em> source.&#13;
To do so, after you have cloned your repository to your computer, go into your <em>biofx_python</em> directory:</p>&#13;
&#13;
<pre data-type="programlisting">$ cd biofx_python</pre>&#13;
&#13;
<p>Then execute this command:</p>&#13;
&#13;
<pre data-type="programlisting">$ git remote add upstream https://github.com/kyclark/biofx_python.git</pre>&#13;
&#13;
<p>Whenever you would like to update your repository from mine, you can execute this command:</p>&#13;
&#13;
<pre data-type="programlisting">$ git pull upstream main</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Installing Modules" data-type="sect1"><div class="sect1" id="idm45963636764936">&#13;
<h1>Installing Modules</h1>&#13;
&#13;
<p>You will need to install several Python modules and tools.<a data-primary="Python" data-secondary="downloading Python" data-tertiary="installing modules and tools" data-type="indexterm" id="idm45963636763672"/><a data-primary="requirements.txt for Python modules" data-type="indexterm" id="idm45963636762440"/><a data-primary="installation" data-secondary="modules and tools" data-type="indexterm" id="idm45963625699432"/><a data-primary="IDEs (integrated development environments)" data-secondary="cloning book code and test repository" data-tertiary="installing modules" data-type="indexterm" id="idm45963625698488"/>&#13;
I’ve included a <em>requirements.txt</em> file in the top level of the repository.&#13;
This file lists all the modules needed to run the programs in the book.&#13;
Some IDEs may detect this file and offer to install these for you, or you can use the following command:</p>&#13;
&#13;
<pre data-type="programlisting">$ python3 -m pip install -r requirements.txt</pre>&#13;
&#13;
<p class="pagebreak-before">Or use the <code>pip3</code> tool:</p>&#13;
&#13;
<pre data-type="programlisting">$ pip3 install -r requirements.txt</pre>&#13;
&#13;
<p>Sometimes <code>pylint</code> may complain about some of the variable names in the programs, and <code>mypy</code> will raise<a data-primary="pylint" data-secondary="errors with variable names" data-type="indexterm" id="idm45963625692568"/><a data-primary="mypy" data-secondary="imported files missing type annotations" data-type="indexterm" id="idm45963625691608"/><a data-primary="installation" data-secondary="pylint and mypy initialization files" data-type="indexterm" id="idm45963625690648"/><a data-primary="Python" data-secondary="downloading Python" data-tertiary="pylint and mypy initialization files" data-type="indexterm" id="idm45963625689688"/><a data-primary="errors" data-secondary="pylint" data-tertiary="variable names" data-type="indexterm" id="idm45963625688456"/><a data-primary="errors" data-secondary="mypy" data-tertiary="imported files missing type annotations" data-type="indexterm" id="idm45963636911960"/> some issues when you import modules that do not have type annotations.&#13;
To silence these errors, you can create initialization files in your home directory that these programs will use to customize their behavior.&#13;
In the root of the source repository, there are files called <em>pylintrc</em> and <em>mypy.ini</em> that you should copy to your home directory like so:</p>&#13;
&#13;
<pre data-type="programlisting">$ cp pylintrc ~/.pylintrc&#13;
$ cp mypy.ini ~/.mypy.ini</pre>&#13;
&#13;
<p>Alternatively, you can generate a new <em>pylintrc</em> with the following command:</p>&#13;
&#13;
<pre data-type="programlisting">$ cd ~&#13;
$ pylint --generate-rcfile &gt; .pylintrc</pre>&#13;
&#13;
<p>Feel free to customize these files to suit your tastes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Installing the new.py Program" data-type="sect1"><div class="sect1" id="idm45963636906216">&#13;
<h1>Installing the new.py Program</h1>&#13;
&#13;
<p>I wrote a Python program called <code>new.py</code> that creates Python programs.<a data-primary="Python" data-secondary="creating programs with new.py" data-type="indexterm" id="idm45963636904424"/><a data-primary="new.py for new Python programs" data-secondary="installing" data-type="indexterm" id="idm45963636903464"/><a data-primary="installation" data-secondary="new.py for new programs" data-type="indexterm" id="idm45963636902504"/><a data-primary="Python" data-secondary="downloading Python" data-tertiary="new.py for new programs" data-type="indexterm" id="idm45963636901560"/>&#13;
So meta, I know.&#13;
I wrote this for myself and then gave it to my students because I think it’s quite difficult to start writing a program from an empty screen.&#13;
The <code>new.py</code> program will create a new, well-structured Python program that uses the <code>argparse</code> module to interpret command-line arguments.&#13;
It should have been installed in the preceding section with the module dependencies.&#13;
If not, you can use the <code>pip</code> module to install it, like so:</p>&#13;
&#13;
<pre data-type="programlisting">$ python3 -m pip install new-py</pre>&#13;
&#13;
<p>You should now be able to execute <strong><code>new.py</code></strong> and see something like this:</p>&#13;
&#13;
<pre data-type="programlisting">$ new.py&#13;
usage: new.py [-h] [-n NAME] [-e EMAIL] [-p PURPOSE] [-t] [-f] [--version]&#13;
              program&#13;
new.py: error: the following arguments are required: program</pre>&#13;
&#13;
<p>Each exercise will suggest that you use <code>new.py</code> to start writing your new programs.&#13;
For instance, in <a data-type="xref" href="ch01.html#ch01">Chapter 1</a> you will create a program called <code>dna.py</code> in the <em>01_dna</em> directory, like so:<a data-primary="exercises in the book" data-type="indexterm" id="idm45963636883464"/><a data-primary="new.py for new Python programs" data-secondary="about the process" data-type="indexterm" id="idm45963636882792"/></p>&#13;
&#13;
<pre data-type="programlisting">$ cd 01_dna/&#13;
$ new.py dna.py&#13;
Done, see new script "dna.py".</pre>&#13;
&#13;
<p>If you then execute <strong><code>./dna.py --help</code></strong>, you will see that it generates help documentation on how to use the program.&#13;
You should open the <code>dna.py</code> program in your editor, modify the arguments, and add your code to satisfy the requirements of the program and the tests.</p>&#13;
&#13;
<p>Note that it’s never a requirement that you use <code>new.py</code>.&#13;
I only offer this as an aid to getting started.&#13;
This is how I start every one of my own programs, but, while I find it useful, you may prefer to go a different route.&#13;
As long as your programs pass the test suites, you are welcome to write them however you please.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Why Did I Write This Book?" data-type="sect1"><div class="sect1" id="idm45963636877976">&#13;
<h1>Why Did I Write This Book?</h1>&#13;
&#13;
<p>Richard Hamming spent decades as a mathematician and researcher at Bell Labs.<a data-primary="Hamming, Richard" data-type="indexterm" id="idm45963636876696"/>&#13;
He was known for seeking out people he didn’t know and asking them about their research.&#13;
Then he would ask them what they thought were the biggest, most pressing unanswered questions in their field.&#13;
If their answers for both of these weren’t the same, he’d ask, “So why aren’t you working on that?”</p>&#13;
&#13;
<p>I feel that one of the most pressing problems in bioinformatics is that much of the software is poorly written<a data-primary="reproducible programs" data-secondary="about best practices" data-type="indexterm" id="idm45963636875032"/><a data-primary="best practices" data-secondary="about" data-type="indexterm" id="idm45963636874088"/><a data-primary="Python" data-secondary="best practices" data-seealso="best practices" data-type="indexterm" id="idm45963636873144"/> and lacks proper documentation and testing, if it has any at all.&#13;
I want to show you that it’s <em>less</em> difficult to use types and tests and linters and formatters because it will prove easier over time to add new features and release more and better software.&#13;
You will have the confidence to know for certain when your program is correct, for at least some measure of correctness.</p>&#13;
&#13;
<p>To that end, I will demonstrate best practices in software development.&#13;
Though I’m using Python as the medium, the principles apply to any language from C to R to JavaScript.&#13;
The most important thing you can learn from this book is the craft of developing, testing, documenting, releasing, and supporting software, so that together we can all advance scientific research computing.</p>&#13;
&#13;
<p>My career in bioinformatics was a product of wandering and happy accidents.&#13;
I studied English literature and music in college, and then started playing with databases, HTML, and eventually learned programming on the job in the mid-1990s.&#13;
By 2001, I’d become a decent Perl hacker, and I managed to get a job as a web developer for Dr. Lincoln Stein, an author of several Perl modules and books, at Cold Spring Harbor Laboratory (CSHL).&#13;
He and my boss, Dr. Doreen Ware, patiently spoon-fed me enough biology to understand the programs they wanted to be written.&#13;
I spent 13 years working on a comparative plant genomics database called Gramene.org, learning a decent amount of science while continuing to explore programming languages and computer science.</p>&#13;
&#13;
<p>Lincoln was passionate about sharing everything from data and code to education.&#13;
He started the Programming for Biology course at CSHL, a two-week intensive crash course to teach Unix command-line, Perl programming, and bioinformatics skills.&#13;
The course is still being taught, although using Python nowadays, and I’ve had several opportunities to act as a teaching assistant.&#13;
I’ve always found it rewarding to help someone learn a skill they will use to further their research.</p>&#13;
&#13;
<p>It was during my tenure at CSHL that I met Bonnie Hurwitz, who eventually left to pursue her PhD at the University of Arizona (UA).&#13;
When she started her new lab at UA, I was her first hire.&#13;
Bonnie and I worked together for several years, and teaching became one of my favorite parts of the job.&#13;
As with Lincoln’s course, we introduced basic programming skills to scientists who wanted to branch out into more computational approaches.</p>&#13;
&#13;
<p>Some of the materials I wrote for these classes became the foundation for my first book, <em>Tiny Python Projects</em>, where I try to teach the essential elements of Python language syntax as well as how to use tests to ensure that programs are correct and reproducible—elements crucial to scientific programming.&#13;
This book picks up from there and focuses on the elements of Python that will help you write programs for biology.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Conventions Used in This Book" data-type="sect1"><div class="sect1" id="idm45963636495672">&#13;
<h1>Conventions Used in This Book</h1>&#13;
&#13;
<p>The following typographical conventions are used in this book:</p>&#13;
<dl>&#13;
<dt><em>Italic</em></dt>&#13;
<dd>&#13;
<p>Indicates new terms, URLs, email addresses, filenames, and file extensions, as well as codons and DNA bases.</p>&#13;
</dd>&#13;
<dt><code>Constant width</code></dt>&#13;
<dd>&#13;
<p>Used for program listings, as well as within paragraphs to refer to program elements such as variable or function names, databases, data types, environment variables, statements, and keywords.</p>&#13;
</dd>&#13;
<dt><strong><code>Constant width bold</code></strong></dt>&#13;
<dd>&#13;
<p>Shows commands or other text that should be typed literally by the user.</p>&#13;
</dd>&#13;
<dt><em><code>Constant width italic</code></em></dt>&#13;
<dd>&#13;
<p>Shows text that should be replaced with user-supplied values or by values determined by context.</p>&#13;
</dd>&#13;
</dl>&#13;
<div data-type="tip">&#13;
<p>This element signifies a tip or suggestion.</p>&#13;
</div>&#13;
<div data-type="note" epub:type="note">&#13;
<p>This element signifies a general note.</p>&#13;
</div>&#13;
<div data-type="warning" epub:type="warning">&#13;
<p>This element indicates a warning or caution.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Code Examples" data-type="sect1"><div class="sect1" id="idm45963636483576">&#13;
<h1>Using Code Examples</h1>&#13;
<!--PROD: Please reach out to author to find out if they will be uploading code examples to oreilly.com or their own site (e.g., GitHub). If there is no code download, delete this whole section. If there is, when you email digidist with the link, let them know what you filled in for title_title (should be as close to book title as possible, i.e., learning_python_2e). This info will determine where digidist loads the files.-->&#13;
&#13;
<p>Supplemental material (code examples, exercises, etc.) is available for download at <a href="https://github.com/kyclark/biofx_python"><em class="hyperlink">https://github.com/kyclark/biofx_python</em></a>.<a data-primary="GitHub" data-secondary="supplemental book material" data-type="indexterm" id="idm45963636480440"/><a data-primary="resources" data-secondary="book code and tests on GitHub" data-tertiary="supplemental book material" data-type="indexterm" id="idm45963636479480"/><a data-primary="book code and tests on GitHub" data-secondary="supplemental book material" data-type="indexterm" id="idm45963636478232"/></p>&#13;
&#13;
<p>If you have a technical question or a problem using the code examples, please send email to <a class="email" href="mailto:bookquestions@oreilly.com"><em>bookquestions@oreilly.com</em></a>.<a data-primary="installation" data-secondary="book code and tests" data-tertiary="technical questions or problems" data-type="indexterm" id="idm45963636475576"/><a data-primary="book code and tests on GitHub" data-secondary="technical questions or problems" data-type="indexterm" id="idm45963636474344"/></p>&#13;
&#13;
<p>This book is here to help you get your job done. In general, if example code is offered with this book, you may use it in your programs and documentation. You do not need to contact us for permission unless you’re reproducing a significant portion of the code. For example, writing a program that uses several chunks of code from this book does not require permission. Selling or distributing examples from O’Reilly books does require permission. Answering a question by citing this book and quoting example code does not require permission. Incorporating a significant amount of example code from this book into your product’s documentation does require permission.</p>&#13;
&#13;
<p>We appreciate, but generally do not require, attribution. An attribution usually includes the title, author, publisher, and ISBN. For example: “<em>Mastering Python for Bioinformatics</em> by Ken Youens-Clark (O’Reilly). Copyright 2021 Charles Kenneth Youens-Clark, 978-1-098-10088-9.”</p>&#13;
&#13;
<p>If you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at <a class="email" href="mailto:permissions@oreilly.com"><em>permissions@oreilly.com</em></a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="O’Reilly Online Learning" data-type="sect1"><div class="sect1" id="idm45963636808840">&#13;
<h1>O’Reilly Online Learning</h1>&#13;
<div class="ormenabled" data-type="note" epub:type="note">&#13;
<p>For more than 40 years, <a class="orm:hideurl" href="http://oreilly.com"><em class="hyperlink">O’Reilly Media</em></a> has provided technology and business training, knowledge, and insight to help companies succeed.</p>&#13;
</div>&#13;
&#13;
<p>Our unique network of experts and innovators share their knowledge and expertise through books, articles, and our online learning platform. O’Reilly’s online learning platform gives you on-demand access to live training courses, in-depth learning paths, interactive coding environments, and a vast collection of text and video from O’Reilly and 200+ other publishers. For more information, visit <a class="orm:hideurl" href="http://oreilly.com"><em>http://oreilly.com</em></a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How to Contact Us" data-type="sect1"><div class="sect1" id="idm45963636802776">&#13;
<h1>How to Contact Us</h1>&#13;
&#13;
<p>Please address comments and questions concerning this book to the publisher:</p>&#13;
<ul class="simplelist">&#13;
  <li>O’Reilly Media, Inc.</li>&#13;
  <li>1005 Gravenstein Highway North</li>&#13;
  <li>Sebastopol, CA 95472</li>&#13;
  <li>800-998-9938 (in the United States or Canada)</li>&#13;
  <li>707-829-0515 (international or local)</li>&#13;
  <li>707-829-0104 (fax)</li>&#13;
</ul>&#13;
&#13;
<p>We have a web page for this book, where we list errata, examples, and any additional information. You can access this page at <a href="https://oreil.ly/mastering-bioinformatics-python"><em class="hyperlink">https://oreil.ly/mastering-bioinformatics-python</em></a>.</p>&#13;
<!--Don't forget to update the link above.-->&#13;
&#13;
<p>Email <a class="email" href="mailto:bookquestions@oreilly.com"><em>bookquestions@oreilly.com</em></a> to comment or ask technical questions about this book.</p>&#13;
&#13;
<p>For news and information about our books and courses, visit <a href="http://oreilly.com"><em class="hyperlink">http://oreilly.com</em></a>.</p>&#13;
&#13;
<p>Find us on Facebook: <a href="http://facebook.com/oreilly"><em class="hyperlink">http://facebook.com/oreilly</em></a></p>&#13;
&#13;
<p>Follow us on Twitter: <a href="http://twitter.com/oreillymedia"><em class="hyperlink">http://twitter.com/oreillymedia</em></a></p>&#13;
&#13;
<p>Watch us on YouTube: <a href="http://www.youtube.com/oreillymedia"><em class="hyperlink">http://www.youtube.com/oreillymedia</em></a></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Acknowledgments" data-type="sect1"><div class="sect1" id="idm45963636788152">&#13;
<h1>Acknowledgments</h1>&#13;
&#13;
<p>I want to thank the many people who have reviewed this book, including my editor, Corbin Collins; the entire production team but especially my production editor, &#13;
<span class="keep-together">Caitlin</span> Ghegan; my technical reviewers, Al Scherer, Brad Fulton, Bill Lubanovic, &#13;
<span class="keep-together">Rangarajan</span> Janani, and Joshua Orvis; and the many other people who provided much-appreciated feedback, including Mark Henderson, Marc Bañuls Tornero, and Dr. Scott Cain.</p>&#13;
&#13;
<p>In my professional career, I’ve been extremely fortunate to have had many wonderful bosses, supervisors, and colleagues who’ve helped me grow and pushed me to be better.&#13;
Eric Thorsen was the first person to see I had the potential to learn how to code, and he helped me learn various languages and databases as well as important lessons about sales and support.&#13;
Steve Reppucci was my boss at boston.com, and he provided a much deeper understanding of Perl and Unix and how to be an honest and thoughtful team leader.&#13;
Dr. Lincoln Stein at CSHL took a chance to hire someone who had no knowledge of biology to work in his lab, and he pushed me to create programs I didn’t imagine I could.&#13;
Dr. Doreen Ware patiently taught me biology and pushed me to assume leadership roles and publish.&#13;
Dr. Bonnie Hurwitz supported me through many years of learning about high-performance computing, more programming languages, mentoring, teaching, and writing.&#13;
In every position, I also had many &#13;
<span class="keep-together">colleagues</span> who taught me as much about programming as about being human, and I thank everyone who has helped me along the way.</p>&#13;
&#13;
<p>In my personal life, I would be nowhere without my family, who have loved and supported me.&#13;
My parents have shown great support throughout my life, and I surely wouldn’t be the person I am without them.&#13;
Lori Kindler and I have been married 25 years, and I can’t imagine a life without her.&#13;
Together we generated three offspring who have been an incredible source of delight and challenge.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45963637034392"><sup><a href="preface01.html#idm45963637034392-marker">1</a></sup> Named for Rosalind Franklin, who should have received a Nobel Prize for her contributions to discovering the structure of DNA.</p></div></div></section></body></html>