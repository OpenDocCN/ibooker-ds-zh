["```py\nIn [1]: %matplotlib inline\n        import matplotlib.pyplot as plt\n        plt.style.use('seaborn-whitegrid')\n        import numpy as np\n```", "```py\nIn [2]: rng = np.random.RandomState(1)\n        x = 10 * rng.rand(50)\n        y = 2 * x - 5 + rng.randn(50)\n        plt.scatter(x, y);\n```", "```py\nIn [3]: from sklearn.linear_model import LinearRegression\n        model = LinearRegression(fit_intercept=True)\n\n        model.fit(x[:, np.newaxis], y)\n\n        xfit = np.linspace(0, 10, 1000)\n        yfit = model.predict(xfit[:, np.newaxis])\n\n        plt.scatter(x, y)\n        plt.plot(xfit, yfit);\n```", "```py\nIn [4]: print(\"Model slope:    \", model.coef_[0])\n        print(\"Model intercept:\", model.intercept_)\nOut[4]: Model slope:     2.0272088103606953\n        Model intercept: -4.998577085553204\n```", "```py\nIn [5]: rng = np.random.RandomState(1)\n        X = 10 * rng.rand(100, 3)\n        y = 0.5 + np.dot(X, [1.5, -2., 1.])\n\n        model.fit(X, y)\n        print(model.intercept_)\n        print(model.coef_)\nOut[5]: 0.50000000000001\n        [ 1.5 -2.   1. ]\n```", "```py\nIn [6]: from sklearn.preprocessing import PolynomialFeatures\n        x = np.array([2, 3, 4])\n        poly = PolynomialFeatures(3, include_bias=False)\n        poly.fit_transform(x[:, None])\nOut[6]: array([[ 2.,  4.,  8.],\n               [ 3.,  9., 27.],\n               [ 4., 16., 64.]])\n```", "```py\nIn [7]: from sklearn.pipeline import make_pipeline\n        poly_model = make_pipeline(PolynomialFeatures(7),\n                                   LinearRegression())\n```", "```py\nIn [8]: rng = np.random.RandomState(1)\n        x = 10 * rng.rand(50)\n        y = np.sin(x) + 0.1 * rng.randn(50)\n\n        poly_model.fit(x[:, np.newaxis], y)\n        yfit = poly_model.predict(xfit[:, np.newaxis])\n\n        plt.scatter(x, y)\n        plt.plot(xfit, yfit);\n```", "```py\nIn [9]: from sklearn.base import BaseEstimator, TransformerMixin\n\n        class GaussianFeatures(BaseEstimator, TransformerMixin):\n            \"\"\"Uniformly spaced Gaussian features for one-dimensional input\"\"\"\n\n            def __init__(self, N, width_factor=2.0):\n                self.N = N\n                self.width_factor = width_factor\n\n            @staticmethod\n            def _gauss_basis(x, y, width, axis=None):\n                arg = (x - y) / width\n                return np.exp(-0.5 * np.sum(arg ** 2, axis))\n\n            def fit(self, X, y=None):\n                # create N centers spread along the data range\n                self.centers_ = np.linspace(X.min(), X.max(), self.N)\n                self.width_ = self.width_factor*(self.centers_[1]-self.centers_[0])\n                return self\n\n            def transform(self, X):\n                return self._gauss_basis(X[:, :, np.newaxis], self.centers_,\n                                         self.width_, axis=1)\n\n        gauss_model = make_pipeline(GaussianFeatures(20),\n                                    LinearRegression())\n        gauss_model.fit(x[:, np.newaxis], y)\n        yfit = gauss_model.predict(xfit[:, np.newaxis])\n\n        plt.scatter(x, y)\n        plt.plot(xfit, yfit)\n        plt.xlim(0, 10);\n```", "```py\nIn [10]: model = make_pipeline(GaussianFeatures(30),\n                               LinearRegression())\n         model.fit(x[:, np.newaxis], y)\n\n         plt.scatter(x, y)\n         plt.plot(xfit, model.predict(xfit[:, np.newaxis]))\n\n         plt.xlim(0, 10)\n         plt.ylim(-1.5, 1.5);\n```", "```py\nIn [11]: def basis_plot(model, title=None):\n             fig, ax = plt.subplots(2, sharex=True)\n             model.fit(x[:, np.newaxis], y)\n             ax[0].scatter(x, y)\n             ax[0].plot(xfit, model.predict(xfit[:, np.newaxis]))\n             ax[0].set(xlabel='x', ylabel='y', ylim=(-1.5, 1.5))\n\n             if title:\n                 ax[0].set_title(title)\n\n             ax[1].plot(model.steps[0][1].centers_,\n                        model.steps[1][1].coef_)\n             ax[1].set(xlabel='basis location',\n                       ylabel='coefficient',\n                       xlim=(0, 10))\n\n         model = make_pipeline(GaussianFeatures(30), LinearRegression())\n         basis_plot(model)\n```", "```py\nIn [12]: from sklearn.linear_model import Ridge\n         model = make_pipeline(GaussianFeatures(30), Ridge(alpha=0.1))\n         basis_plot(model, title='Ridge Regression')\n```", "```py\nIn [13]: from sklearn.linear_model import Lasso\n         model = make_pipeline(GaussianFeatures(30),\n                               Lasso(alpha=0.001, max_iter=2000))\n         basis_plot(model, title='Lasso Regression')\n```", "```py\nIn [14]: # url = 'https://raw.githubusercontent.com/jakevdp/bicycle-data/main'\n         # !curl -O {url}/FremontBridge.csv\n         # !curl -O {url}/SeattleWeather.csv\n```", "```py\nIn [15]: import pandas as pd\n         counts = pd.read_csv('FremontBridge.csv',\n                              index_col='Date', parse_dates=True)\n         weather = pd.read_csv('SeattleWeather.csv',\n                               index_col='DATE', parse_dates=True)\n```", "```py\nIn [16]: counts = counts[counts.index < \"2020-01-01\"]\n         weather = weather[weather.index < \"2020-01-01\"]\n```", "```py\nIn [17]: daily = counts.resample('d').sum()\n         daily['Total'] = daily.sum(axis=1)\n         daily = daily[['Total']] # remove other columns\n```", "```py\nIn [18]: days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']\n         for i in range(7):\n             daily[days[i]] = (daily.index.dayofweek == i).astype(float)\n```", "```py\nIn [19]: from pandas.tseries.holiday import USFederalHolidayCalendar\n         cal = USFederalHolidayCalendar()\n         holidays = cal.holidays('2012', '2020')\n         daily = daily.join(pd.Series(1, index=holidays, name='holiday'))\n         daily['holiday'].fillna(0, inplace=True)\n```", "```py\nIn [20]: def hours_of_daylight(date, axis=23.44, latitude=47.61):\n             \"\"\"Compute the hours of daylight for the given date\"\"\"\n             days = (date - pd.datetime(2000, 12, 21)).days\n             m = (1. - np.tan(np.radians(latitude))\n                  * np.tan(np.radians(axis) * np.cos(days * 2 * np.pi / 365.25)))\n             return 24. * np.degrees(np.arccos(1 - np.clip(m, 0, 2))) / 180.\n\n         daily['daylight_hrs'] = list(map(hours_of_daylight, daily.index))\n         daily[['daylight_hrs']].plot()\n         plt.ylim(8, 17)\nOut[20]: (8.0, 17.0)\n```", "```py\nIn [21]: weather['Temp (F)'] = 0.5 * (weather['TMIN'] + weather['TMAX'])\n         weather['Rainfall (in)'] = weather['PRCP']\n         weather['dry day'] = (weather['PRCP'] == 0).astype(int)\n\n         daily = daily.join(weather[['Rainfall (in)', 'Temp (F)', 'dry day']])\n```", "```py\nIn [22]: daily['annual'] = (daily.index - daily.index[0]).days / 365.\n```", "```py\nIn [23]: daily.head()\nOut[23]:               Total  Mon  Tue  Wed  Thu  Fri  Sat  Sun  holiday \\\n         Date\n         2012-10-03  14084.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0      0.0\n         2012-10-04  13900.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0      0.0\n         2012-10-05  12592.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0      0.0\n         2012-10-06   8024.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0      0.0\n         2012-10-07   8568.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0      0.0\n\n                     daylight_hrs Rainfall (in)  Temp (F)  dry day    annual\n         Date\n         2012-10-03     11.277359           0.0      56.0        1  0.000000\n         2012-10-04     11.219142           0.0      56.5        1  0.002740\n         2012-10-05     11.161038           0.0      59.5        1  0.005479\n         2012-10-06     11.103056           0.0      60.5        1  0.008219\n         2012-10-07     11.045208           0.0      60.5        1  0.010959\n```", "```py\nIn [24]: # Drop any rows with null values\n         daily.dropna(axis=0, how='any', inplace=True)\n\n         column_names = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun',\n                         'holiday', 'daylight_hrs', 'Rainfall (in)',\n                         'dry day', 'Temp (F)', 'annual']\n         X = daily[column_names]\n         y = daily['Total']\n\n         model = LinearRegression(fit_intercept=False)\n         model.fit(X, y)\n         daily['predicted'] = model.predict(X)\n```", "```py\nIn [25]: daily[['Total', 'predicted']].plot(alpha=0.5);\n```", "```py\nIn [26]: params = pd.Series(model.coef_, index=X.columns)\n         params\nOut[26]: Mon              -3309.953439\n         Tue              -2860.625060\n         Wed              -2962.889892\n         Thu              -3480.656444\n         Fri              -4836.064503\n         Sat             -10436.802843\n         Sun             -10795.195718\n         holiday          -5006.995232\n         daylight_hrs       409.146368\n         Rainfall (in)    -2789.860745\n         dry day           2111.069565\n         Temp (F)           179.026296\n         annual             324.437749\n         dtype: float64\n```", "```py\nIn [27]: from sklearn.utils import resample\n         np.random.seed(1)\n         err = np.std([model.fit(*resample(X, y)).coef_\n                       for i in range(1000)], 0)\n```", "```py\nIn [28]: print(pd.DataFrame({'effect': params.round(0),\n                             'uncertainty': err.round(0)}))\nOut[28]:                 effect  uncertainty\n         Mon            -3310.0        265.0\n         Tue            -2861.0        274.0\n         Wed            -2963.0        268.0\n         Thu            -3481.0        268.0\n         Fri            -4836.0        261.0\n         Sat           -10437.0        259.0\n         Sun           -10795.0        267.0\n         holiday        -5007.0        401.0\n         daylight_hrs     409.0         26.0\n         Rainfall (in)  -2790.0        186.0\n         dry day         2111.0        101.0\n         Temp (F)         179.0          7.0\n         annual           324.0         22.0\n```"]