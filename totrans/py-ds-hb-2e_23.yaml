- en: Chapter 20\. Aggregation and Grouping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A fundamental piece of many data analysis tasks is efficient summarization:
    computing aggregations like `sum`, `mean`, `median`, `min`, and `max`, in which
    a single number summarizes aspects of a potentially large dataset. In this chapter,
    we’ll explore aggregations in Pandas, from simple operations akin to what we’ve
    seen on NumPy arrays to more sophisticated operations based on the concept of
    a `groupby`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For convenience, we’ll use the same `display` magic function that we used in
    the previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Planets Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here we will use the Planets dataset, available via the [Seaborn package](http://seaborn.pydata.org)
    (see [Chapter 36](ch36.xhtml#section-0414-visualization-with-seaborn)). It gives
    information on planets that astronomers have discovered around other stars (known
    as *extrasolar planets*, or *exoplanets* for short). It can be downloaded with
    a simple Seaborn command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This has some details on the more than one thousand extrasolar planets discovered
    up to 2014.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Aggregation in Pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 7](ch07.xhtml#section-0204-computation-on-arrays-aggregates), we
    explored some of the data aggregations available for NumPy arrays. As with a one-dimensional
    NumPy array, for a Pandas `Series` the aggregates return a single value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For a `DataFrame`, by default the aggregates return results within each column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'By specifying the `axis` argument, you can instead aggregate within each row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Pandas `Series` and `DataFrame` objects include all of the common aggregates
    mentioned in [Chapter 7](ch07.xhtml#section-0204-computation-on-arrays-aggregates);
    in addition, there is a convenience method, `describe`, that computes several
    common aggregates for each column and returns the result. Let’s use this on the
    Planets data, for now dropping rows with missing values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This method helps us understand the overall properties of a dataset. For example,
    we see in the `year` column that although exoplanets were discovered as far back
    as 1989, half of all planets in the dataset were not discovered until 2010 or
    after. This is largely thanks to the *Kepler* mission, which aimed to find eclipsing
    planets around other stars using a specially designed space telescope.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 20-1](#table-20-1) summarizes some other built-in Pandas aggregations.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 20-1\. Listing of Pandas aggregation methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Aggregation | Returns |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `count` | Total number of items |'
  prefs: []
  type: TYPE_TB
- en: '| `first`, `last` | First and last item |'
  prefs: []
  type: TYPE_TB
- en: '| `mean`, `median` | Mean and median |'
  prefs: []
  type: TYPE_TB
- en: '| `min`, `max` | Minimum and maximum |'
  prefs: []
  type: TYPE_TB
- en: '| `std`, `var` | Standard deviation and variance |'
  prefs: []
  type: TYPE_TB
- en: '| `mad` | Mean absolute deviation |'
  prefs: []
  type: TYPE_TB
- en: '| `prod` | Product of all items |'
  prefs: []
  type: TYPE_TB
- en: '| `sum` | Sum of all items |'
  prefs: []
  type: TYPE_TB
- en: These are all methods of `DataFrame` and `Series` objects.
  prefs: []
  type: TYPE_NORMAL
- en: To go deeper into the data, however, simple aggregates are often not enough.
    The next level of data summarization is the `groupby` operation, which allows
    you to quickly and efficiently compute aggregates on subsets of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'groupby: Split, Apply, Combine'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Simple aggregations can give you a flavor of your dataset, but often we would
    prefer to aggregate conditionally on some label or index: this is implemented
    in the so-called `groupby` operation. The name “group by” comes from a command
    in the SQL database language, but it is perhaps more illuminative to think of
    it in the terms first coined by Hadley Wickham of Rstats fame: *split, apply,
    combine*.'
  prefs: []
  type: TYPE_NORMAL
- en: Split, Apply, Combine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A canonical example of this split-apply-combine operation, where the “apply”
    is a summation aggregation, is illustrated [Figure 20-1](#fig_images_in_0308-split-apply-combine).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 20-1](#fig_images_in_0308-split-apply-combine) shows what the `groupby`
    operation accomplishes:'
  prefs: []
  type: TYPE_NORMAL
- en: The *split* step involves breaking up and grouping a `DataFrame` depending on
    the value of the specified key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *apply* step involves computing some function, usually an aggregate, transformation,
    or filtering, within the individual groups.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *combine* step merges the results of these operations into an output array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![03.08 split apply combine](assets/03.08-split-apply-combine.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-1\. A visual representation of a groupby operation^([1](ch20.xhtml#idm45858775097184))
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'While this could certainly be done manually using some combination of the masking,
    aggregation, and merging commands covered earlier, an important realization is
    that *the intermediate splits do not need to be explicitly instantiated*. Rather,
    the `groupby` can (often) do this in a single pass over the data, updating the
    sum, mean, count, min, or other aggregate for each group along the way. The power
    of the `groupby` is that it abstracts away these steps: the user need not think
    about *how* the computation is done under the hood, but rather can think about
    the *operation as a whole*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a concrete example, let’s take a look at using Pandas for the computation
    shown in the following table. We’ll start by creating the input `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The most basic split-apply-combine operation can be computed with the `groupby`
    method of the `DataFrame`, passing the name of the desired key column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that what is returned is a `DataFrameGroupBy` object, not a set of `DataFrame`
    objects. This object is where the magic is: you can think of it as a special view
    of the `DataFrame`, which is poised to dig into the groups but does no actual
    computation until the aggregation is applied. This “lazy evaluation” approach
    means that common aggregates can be implemented efficiently in a way that is almost
    transparent to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To produce a result, we can apply an aggregate to this `DataFrameGroupBy` object,
    which will perform the appropriate apply/combine steps to produce the desired
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `sum` method is just one possibility here; you can apply most Pandas or
    NumPy aggregation functions, as well as most `DataFrame` operations, as you will
    see in the following discussion.
  prefs: []
  type: TYPE_NORMAL
- en: The GroupBy Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `GroupBy` object is a flexible abstraction: in many ways, it can be treated
    as simply a collection of `DataFrame`s, though it is doing more sophisticated
    things under the hood. Let’s see some examples using the Planets data.'
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most important operations made available by a `GroupBy` are *aggregate*,
    *filter*, *transform*, and *apply*. We’ll discuss each of these more fully in
    the next section, but before that let’s take a look at some of the other functionality
    that can be used with the basic `GroupBy` operation.
  prefs: []
  type: TYPE_NORMAL
- en: Column indexing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `GroupBy` object supports column indexing in the same way as the `DataFrame`,
    and returns a modified `GroupBy` object. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we’ve selected a particular `Series` group from the original `DataFrame`
    group by reference to its column name. As with the `GroupBy` object, no computation
    is done until we call some aggregate on the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This gives an idea of the general scale of orbital periods (in days) that each
    method is sensitive to.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration over groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `GroupBy` object supports direct iteration over the groups, returning each
    group as a `Series` or `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This can be useful for manual inspection of groups for the sake of debugging,
    but it is often much faster to use the built-in `apply` functionality, which we
    will discuss momentarily.
  prefs: []
  type: TYPE_NORMAL
- en: Dispatch methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Through some Python class magic, any method not explicitly implemented by the
    `GroupBy` object will be passed through and called on the groups, whether they
    are `DataFrame` or `Series` objects. For example, using the `describe` method
    is equivalent to calling `describe` on the `DataFrame` representing each group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at this table helps us to better understand the data: for example,
    the vast majority of planets until 2014 were discovered by the Radial Velocity
    and Transit methods, though the latter method became common more recently. The
    newest methods seem to be Transit Timing Variation and Orbital Brightness Modulation,
    which were not used to discover a new planet until 2011.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that these dispatch methods are applied *to each individual group*, and
    the results are then combined within `GroupBy` and returned. Again, any valid
    `DataFrame`/`Series` method can be called in a similar manner on the corresponding
    `GroupBy` object.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregate, Filter, Transform, Apply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding discussion focused on aggregation for the combine operation, but
    there are more options available. In particular, `GroupBy` objects have `aggregate`,
    `filter`, `transform`, and `apply` methods that efficiently implement a variety
    of useful operations before combining the grouped data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purpose of the following subsections, we’ll use this `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Aggregation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’re now familiar with `GroupBy` aggregations with `sum`, `median`, and the
    like, but the `aggregate` method allows for even more flexibility. It can take
    a string, a function, or a list thereof, and compute all the aggregates at once.
    Here is a quick example combining all of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common pattern is to pass a dictionary mapping column names to operations
    to be applied on that column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Filtering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A filtering operation allows you to drop data based on the group properties.
    For example, we might want to keep all groups in which the standard deviation
    is larger than some critical value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The filter function should return a Boolean value specifying whether the group
    passes the filtering. Here, because group A does not have a standard deviation
    greater than 4, it is dropped from the result.
  prefs: []
  type: TYPE_NORMAL
- en: Transformation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While aggregation must return a reduced version of the data, transformation
    can return some transformed version of the full data to recombine. For such a
    transformation, the output is the same shape as the input. A common example is
    to center the data by subtracting the group-wise mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The apply method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `apply` method lets you apply an arbitrary function to the group results.
    The function should take a `DataFrame` and returns either a Pandas object (e.g.,
    `DataFrame`, `Series`) or a scalar; the behavior of the combine step will be tailored
    to the type of output returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is an `apply` operation that normalizes the first column
    by the sum of the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`apply` within a `GroupBy` is flexible: the only criterion is that the function
    takes a `Data⁠Frame` and returns a Pandas object or scalar. What you do in between
    is up to you!'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the Split Key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the simple examples presented before, we split the `DataFrame` on a single
    column name. This is just one of many options by which the groups can be defined,
    and we’ll go through some other options for group specification here.
  prefs: []
  type: TYPE_NORMAL
- en: A list, array, series, or index providing the grouping keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The key can be any series or list with a length matching that of the `DataFrame`.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this means there’s another, more verbose way of accomplishing the
    `df.groupby(''key'')` from before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A dictionary or series mapping index to group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another method is to provide a dictionary that maps index values to the group
    keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Any Python function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similar to mapping, you can pass any Python function that will input the index
    value and output the group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: A list of valid keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Further, any of the preceding key choices can be combined to group on a multi-index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Grouping Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an example of this, in a few lines of Python code we can put all these together
    and count discovered planets by method and by decade:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows the power of combining many of the operations we’ve discussed up
    to this point when looking at realistic datasets: we quickly gain a coarse understanding
    of when and how extrasolar planets were detected in the years after the first
    discovery.'
  prefs: []
  type: TYPE_NORMAL
- en: I would suggest digging into these few lines of code and evaluating the individual
    steps to make sure you understand exactly what they are doing to the result. It’s
    certainly a somewhat complicated example, but understanding these pieces will
    give you the means to similarly explore your own data.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch20.xhtml#idm45858775097184-marker)) Code to produce this figure can
    be found in the [online appendix](https://oreil.ly/zHqzu).
  prefs: []
  type: TYPE_NORMAL
