<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 17. Hierarchical Indexing" data-type="chapter" epub:type="chapter"><div class="chapter" id="section-0305-hierarchical-indexing">
<h1><span class="label">Chapter 17. </span>Hierarchical Indexing</h1>
<p><a data-primary="hierarchical indexing" data-seealso="MultiIndex type" data-type="indexterm" id="ix_ch17-asciidoc0"/><a data-primary="Pandas" data-secondary="hierarchical indexing" data-type="indexterm" id="ix_ch17-asciidoc1"/><a data-primary="Series object (Pandas)" data-secondary="hierarchical indexing in" data-type="indexterm" id="ix_ch17-asciidoc2"/>Up to this point we’ve been focused primarily on
one-dimensional and two-dimensional data, stored in Pandas <code>Series</code> and
<code>DataFrame</code> objects, respectively. Often it is useful to go beyond this
and store higher-dimensional data—that is, data indexed by more than one
or two keys. Early Pandas versions provided <code>Panel</code> and <code>Panel4D</code>
objects that could be thought of as 3D or 4D analogs to the 2D
<code>DataFrame</code>, but they were somewhat clunky to use in practice. A far
more common pattern for handling higher-dimensional data is to make use
of <em>hierarchical indexing</em> (also known as <em>multi-indexing</em>) to
incorporate multiple index <em>levels</em> within a single index. In this way,
higher-dimensional data can be compactly represented within the familiar
one-dimensional <code>Series</code> and two-dimensional <code>DataFrame</code> objects. (If
you’re interested in true <em>N</em>-dimensional arrays with
Pandas-style flexible indices, you can look into the excellent
<a href="https://xarray.pydata.org">Xarray package</a>.)</p>
<p>In this chapter, we’ll explore the direct creation of
<code>MultiIndex</code> objects; considerations when indexing, slicing, and
computing statistics across multiply indexed data; and useful routines
for converting between simple and hierarchically indexed representations
of data.</p>
<p>We begin with the standard imports:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>
        <code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code></pre>
<section data-pdf-bookmark="A Multiply Indexed Series" data-type="sect1"><div class="sect1" id="ch_0305-hierarchical-indexing_a-multiply-indexed-series">
<h1>A Multiply Indexed Series</h1>
<p><a data-primary="hierarchical indexing" data-secondary="in one-dimensional Series" data-secondary-sortas="one-dimensional" data-type="indexterm" id="ix_ch17-asciidoc3"/><a data-primary="MultiIndex type" data-type="indexterm" id="ix_ch17-asciidoc4"/>Let’s start by considering how we might represent
two-dimensional data within a one-dimensional <code>Series</code>. For
concreteness, we will consider a series of data where each point has a
character and numerical key.</p>
<section data-pdf-bookmark="The Bad Way" data-type="sect2"><div class="sect2" id="ch_0305-hierarchical-indexing_the-bad-way">
<h2>The Bad Way</h2>
<p><a data-primary="hierarchical indexing" data-secondary="with Python tuples as keys" data-secondary-sortas="Python tuples" data-type="indexterm" id="idm45858784637104"/>Suppose you would like to track data about states from two different
years. Using the Pandas tools we’ve already covered, you
might be tempted to simply use Python tuples as keys:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="n">index</code> <code class="o">=</code> <code class="p">[(</code><code class="s1">'California'</code><code class="p">,</code> <code class="mi">2010</code><code class="p">),</code> <code class="p">(</code><code class="s1">'California'</code><code class="p">,</code> <code class="mi">2020</code><code class="p">),</code>
                 <code class="p">(</code><code class="s1">'New York'</code><code class="p">,</code> <code class="mi">2010</code><code class="p">),</code> <code class="p">(</code><code class="s1">'New York'</code><code class="p">,</code> <code class="mi">2020</code><code class="p">),</code>
                 <code class="p">(</code><code class="s1">'Texas'</code><code class="p">,</code> <code class="mi">2010</code><code class="p">),</code> <code class="p">(</code><code class="s1">'Texas'</code><code class="p">,</code> <code class="mi">2020</code><code class="p">)]</code>
        <code class="n">populations</code> <code class="o">=</code> <code class="p">[</code><code class="mi">37253956</code><code class="p">,</code> <code class="mi">39538223</code><code class="p">,</code>
                       <code class="mi">19378102</code><code class="p">,</code> <code class="mi">20201249</code><code class="p">,</code>
                       <code class="mi">25145561</code><code class="p">,</code> <code class="mi">29145505</code><code class="p">]</code>
        <code class="n">pop</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">(</code><code class="n">populations</code><code class="p">,</code> <code class="n">index</code><code class="o">=</code><code class="n">index</code><code class="p">)</code>
        <code class="n">pop</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="p">(</code><code class="n">California</code><code class="p">,</code> <code class="mi">2010</code><code class="p">)</code>    <code class="mi">37253956</code>
        <code class="p">(</code><code class="n">California</code><code class="p">,</code> <code class="mi">2020</code><code class="p">)</code>    <code class="mi">39538223</code>
        <code class="p">(</code><code class="n">New</code> <code class="n">York</code><code class="p">,</code> <code class="mi">2010</code><code class="p">)</code>      <code class="mi">19378102</code>
        <code class="p">(</code><code class="n">New</code> <code class="n">York</code><code class="p">,</code> <code class="mi">2020</code><code class="p">)</code>      <code class="mi">20201249</code>
        <code class="p">(</code><code class="n">Texas</code><code class="p">,</code> <code class="mi">2010</code><code class="p">)</code>         <code class="mi">25145561</code>
        <code class="p">(</code><code class="n">Texas</code><code class="p">,</code> <code class="mi">2020</code><code class="p">)</code>         <code class="mi">29145505</code>
        <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>With this indexing scheme, you can straightforwardly index or slice the
series based on this tuple index:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="n">pop</code><code class="p">[(</code><code class="s1">'California'</code><code class="p">,</code> <code class="mi">2020</code><code class="p">):(</code><code class="s1">'Texas'</code><code class="p">,</code> <code class="mi">2010</code><code class="p">)]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="p">(</code><code class="n">California</code><code class="p">,</code> <code class="mi">2020</code><code class="p">)</code>    <code class="mi">39538223</code>
        <code class="p">(</code><code class="n">New</code> <code class="n">York</code><code class="p">,</code> <code class="mi">2010</code><code class="p">)</code>      <code class="mi">19378102</code>
        <code class="p">(</code><code class="n">New</code> <code class="n">York</code><code class="p">,</code> <code class="mi">2020</code><code class="p">)</code>      <code class="mi">20201249</code>
        <code class="p">(</code><code class="n">Texas</code><code class="p">,</code> <code class="mi">2010</code><code class="p">)</code>         <code class="mi">25145561</code>
        <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>But the convenience ends there. For example, if you need to select all
values from 2010, you’ll need to do some messy (and
potentially slow) munging to make it 
<span class="keep-together">happen</span>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="n">pop</code><code class="p">[[</code><code class="n">i</code> <code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="n">pop</code><code class="o">.</code><code class="n">index</code> <code class="k">if</code> <code class="n">i</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">==</code> <code class="mi">2010</code><code class="p">]]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="p">(</code><code class="n">California</code><code class="p">,</code> <code class="mi">2010</code><code class="p">)</code>    <code class="mi">37253956</code>
        <code class="p">(</code><code class="n">New</code> <code class="n">York</code><code class="p">,</code> <code class="mi">2010</code><code class="p">)</code>      <code class="mi">19378102</code>
        <code class="p">(</code><code class="n">Texas</code><code class="p">,</code> <code class="mi">2010</code><code class="p">)</code>         <code class="mi">25145561</code>
        <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>This produces the desired result, but is not as clean (or as efficient
for large datasets) as the slicing syntax we’ve grown to
love in Pandas.</p>
</div></section>
<section data-pdf-bookmark="The Better Way: The Pandas MultiIndex" data-type="sect2"><div class="sect2" id="ch_0305-hierarchical-indexing_the-better-way-the-pandas-multiindex">
<h2>The Better Way: The Pandas MultiIndex</h2>
<p>Fortunately, Pandas provides a better way. Our tuple-based indexing is
essentially a rudimentary multi-index, and the Pandas <code>MultiIndex</code> type
gives us the types of operations we wish to have. We can create a
multi-index from the tuples as follows:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">index</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">MultiIndex</code><code class="o">.</code><code class="n">from_tuples</code><code class="p">(</code><code class="n">index</code><code class="p">)</code></pre>
<p>The <code>MultiIndex</code> represents multiple <em>levels</em> of indexing—in this case,
the state names and the years—as well as multiple <em>labels</em> for each data
point which encode these 
<span class="keep-together">levels</span>.</p>
<p>If we reindex our series with this <code>MultiIndex</code>, we see the hierarchical
representation of the data:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">pop</code> <code class="o">=</code> <code class="n">pop</code><code class="o">.</code><code class="n">reindex</code><code class="p">(</code><code class="n">index</code><code class="p">)</code>
        <code class="n">pop</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">California</code>  <code class="mi">2010</code>    <code class="mi">37253956</code>
                    <code class="mi">2020</code>    <code class="mi">39538223</code>
        <code class="n">New</code> <code class="n">York</code>    <code class="mi">2010</code>    <code class="mi">19378102</code>
                    <code class="mi">2020</code>    <code class="mi">20201249</code>
        <code class="n">Texas</code>       <code class="mi">2010</code>    <code class="mi">25145561</code>
                    <code class="mi">2020</code>    <code class="mi">29145505</code>
        <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>Here the first two columns of the Series representation show the
multiple index values, while the third column shows the data. Notice
that some entries are missing in the first column: in this multi-index
representation, any blank entry indicates the same value as the line
above it.</p>
<p>Now to access all data for which the second index is 2020, we can use
the Pandas slicing notation:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">pop</code><code class="p">[:,</code> <code class="mi">2020</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">California</code>    <code class="mi">39538223</code>
        <code class="n">New</code> <code class="n">York</code>      <code class="mi">20201249</code>
        <code class="n">Texas</code>         <code class="mi">29145505</code>
        <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>The result is a singly indexed Series with just the keys
we’re interested in. This syntax is much more convenient
(and the operation is much more efficient!) than the home-spun
tuple-based multi-indexing solution that we started with.
We’ll now further discuss this sort of indexing operation on
hierarchically indexed data.</p>
</div></section>
<section data-pdf-bookmark="MultiIndex as Extra Dimension" data-type="sect2"><div class="sect2" id="ch_0305-hierarchical-indexing_multiindex-as-extra-dimension">
<h2>MultiIndex as Extra Dimension</h2>
<p><a data-primary="MultiIndex type" data-secondary="extra dimension of data with" data-type="indexterm" id="idm45858784145984"/>You might notice something else here: we could easily have stored the
same data using a simple <code>DataFrame</code> with index and column labels. In
fact, Pandas is built with this equivalence in mind. <a data-primary="hierarchical indexing" data-secondary="unstack() method" data-type="indexterm" id="idm45858784144192"/><a data-primary="unstack() method" data-type="indexterm" id="idm45858784174656"/>The <code>unstack</code>
method will quickly convert a multiply indexed <code>Series</code> into a
conventionally indexed <code>DataFrame</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">pop_df</code> <code class="o">=</code> <code class="n">pop</code><code class="o">.</code><code class="n">unstack</code><code class="p">()</code>
        <code class="n">pop_df</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">8</code><code class="p">]:</code>                 <code class="mi">2010</code>      <code class="mi">2020</code>
        <code class="n">California</code>  <code class="mi">37253956</code>  <code class="mi">39538223</code>
        <code class="n">New</code> <code class="n">York</code>    <code class="mi">19378102</code>  <code class="mi">20201249</code>
        <code class="n">Texas</code>       <code class="mi">25145561</code>  <code class="mi">29145505</code></pre>
<p>Naturally, the <code>stack</code> method provides the opposite operation:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">pop_df</code><code class="o">.</code><code class="n">stack</code><code class="p">()</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">California</code>  <code class="mi">2010</code>    <code class="mi">37253956</code>
                    <code class="mi">2020</code>    <code class="mi">39538223</code>
        <code class="n">New</code> <code class="n">York</code>    <code class="mi">2010</code>    <code class="mi">19378102</code>
                    <code class="mi">2020</code>    <code class="mi">20201249</code>
        <code class="n">Texas</code>       <code class="mi">2010</code>    <code class="mi">25145561</code>
                    <code class="mi">2020</code>    <code class="mi">29145505</code>
        <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>Seeing this, you might wonder why would we would bother with
hierarchical indexing at all. The reason is simple: just as we were able
to use multi-indexing to manipulate two-dimensional data within a
one-dimensional <code>Series</code>, we can also use it to manipulate data of three
or more dimensions in a <code>Series</code> or <code>DataFrame</code>. Each extra level in a
multi-index represents an extra dimension of data; taking advantage of
this property gives us much more flexibility in the types of data we can
represent. Concretely, we might want to add another column of
demographic data for each state at each year (say, population under 18);
with a <code>MultiIndex</code> this is as easy as adding another column to the
<code>DataFrame</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">pop_df</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">({</code><code class="s1">'total'</code><code class="p">:</code> <code class="n">pop</code><code class="p">,</code>
                                <code class="s1">'under18'</code><code class="p">:</code> <code class="p">[</code><code class="mi">9284094</code><code class="p">,</code> <code class="mi">8898092</code><code class="p">,</code>
                                            <code class="mi">4318033</code><code class="p">,</code> <code class="mi">4181528</code><code class="p">,</code>
                                            <code class="mi">6879014</code><code class="p">,</code> <code class="mi">7432474</code><code class="p">]})</code>
         <code class="n">pop_df</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">10</code><code class="p">]:</code>                     <code class="n">total</code>  <code class="n">under18</code>
         <code class="n">California</code> <code class="mi">2010</code>  <code class="mi">37253956</code>  <code class="mi">9284094</code>
                    <code class="mi">2020</code>  <code class="mi">39538223</code>  <code class="mi">8898092</code>
         <code class="n">New</code> <code class="n">York</code>   <code class="mi">2010</code>  <code class="mi">19378102</code>  <code class="mi">4318033</code>
                    <code class="mi">2020</code>  <code class="mi">20201249</code>  <code class="mi">4181528</code>
         <code class="n">Texas</code>      <code class="mi">2010</code>  <code class="mi">25145561</code>  <code class="mi">6879014</code>
                    <code class="mi">2020</code>  <code class="mi">29145505</code>  <code class="mi">7432474</code></pre>
<p>In addition, all the ufuncs and other functionality discussed in
<a data-type="xref" href="ch15.xhtml#section-0303-operations-in-pandas">Chapter 15</a> work
with hierarchical indices as well. Here we compute the fraction of
people under 18 by year, given the above data:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">f_u18</code> <code class="o">=</code> <code class="n">pop_df</code><code class="p">[</code><code class="s1">'under18'</code><code class="p">]</code> <code class="o">/</code> <code class="n">pop_df</code><code class="p">[</code><code class="s1">'total'</code><code class="p">]</code>
         <code class="n">f_u18</code><code class="o">.</code><code class="n">unstack</code><code class="p">()</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">11</code><code class="p">]:</code>                 <code class="mi">2010</code>      <code class="mi">2020</code>
         <code class="n">California</code>  <code class="mf">0.249211</code>  <code class="mf">0.225050</code>
         <code class="n">New</code> <code class="n">York</code>    <code class="mf">0.222831</code>  <code class="mf">0.206994</code>
         <code class="n">Texas</code>       <code class="mf">0.273568</code>  <code class="mf">0.255013</code></pre>
<p>This allows us to easily and quickly manipulate and explore even
high-dimensional data.<a data-startref="ix_ch17-asciidoc4" data-type="indexterm" id="idm45858783912080"/><a data-startref="ix_ch17-asciidoc3" data-type="indexterm" id="idm45858783876560"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Methods of MultiIndex Creation" data-type="sect1"><div class="sect1" id="ch_0305-hierarchical-indexing_methods-of-multiindex-creation">
<h1>Methods of MultiIndex Creation</h1>
<p><a data-primary="MultiIndex type" data-secondary="creation methods" data-type="indexterm" id="ix_ch17-asciidoc5"/>The most straightforward way to construct a multiply indexed <code>Series</code> or
<code>DataFrame</code> is to simply pass a list of two or more index arrays to the
constructor. For example:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="n">df</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">rand</code><code class="p">(</code><code class="mi">4</code><code class="p">,</code> <code class="mi">2</code><code class="p">),</code>
                           <code class="n">index</code><code class="o">=</code><code class="p">[[</code><code class="s1">'a'</code><code class="p">,</code> <code class="s1">'a'</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">],</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">]],</code>
                           <code class="n">columns</code><code class="o">=</code><code class="p">[</code><code class="s1">'data1'</code><code class="p">,</code> <code class="s1">'data2'</code><code class="p">])</code>
         <code class="n">df</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">12</code><code class="p">]:</code>         <code class="n">data1</code>     <code class="n">data2</code>
         <code class="n">a</code> <code class="mi">1</code>  <code class="mf">0.748464</code>  <code class="mf">0.561409</code>
           <code class="mi">2</code>  <code class="mf">0.379199</code>  <code class="mf">0.622461</code>
         <code class="n">b</code> <code class="mi">1</code>  <code class="mf">0.701679</code>  <code class="mf">0.687932</code>
           <code class="mi">2</code>  <code class="mf">0.436200</code>  <code class="mf">0.950664</code></pre>
<p>The work of creating the <code>MultiIndex</code> is done in the background.</p>
<p>Similarly, if you pass a dictionary with appropriate tuples as keys,
Pandas will automatically recognize this and use a <code>MultiIndex</code> by
default:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="n">data</code> <code class="o">=</code> <code class="p">{(</code><code class="s1">'California'</code><code class="p">,</code> <code class="mi">2010</code><code class="p">):</code> <code class="mi">37253956</code><code class="p">,</code>
                 <code class="p">(</code><code class="s1">'California'</code><code class="p">,</code> <code class="mi">2020</code><code class="p">):</code> <code class="mi">39538223</code><code class="p">,</code>
                 <code class="p">(</code><code class="s1">'New York'</code><code class="p">,</code> <code class="mi">2010</code><code class="p">):</code> <code class="mi">19378102</code><code class="p">,</code>
                 <code class="p">(</code><code class="s1">'New York'</code><code class="p">,</code> <code class="mi">2020</code><code class="p">):</code> <code class="mi">20201249</code><code class="p">,</code>
                 <code class="p">(</code><code class="s1">'Texas'</code><code class="p">,</code> <code class="mi">2010</code><code class="p">):</code> <code class="mi">25145561</code><code class="p">,</code>
                 <code class="p">(</code><code class="s1">'Texas'</code><code class="p">,</code> <code class="mi">2020</code><code class="p">):</code> <code class="mi">29145505</code><code class="p">}</code>
         <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">(</code><code class="n">data</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="n">California</code>  <code class="mi">2010</code>    <code class="mi">37253956</code>
                     <code class="mi">2020</code>    <code class="mi">39538223</code>
         <code class="n">New</code> <code class="n">York</code>    <code class="mi">2010</code>    <code class="mi">19378102</code>
                     <code class="mi">2020</code>    <code class="mi">20201249</code>
         <code class="n">Texas</code>       <code class="mi">2010</code>    <code class="mi">25145561</code>
                     <code class="mi">2020</code>    <code class="mi">29145505</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>Nevertheless, it is sometimes useful to explicitly create a
<code>MultiIndex</code>; we’ll look at a couple of methods for doing
this next.</p>
<section data-pdf-bookmark="Explicit MultiIndex Constructors" data-type="sect2"><div class="sect2" id="ch_0305-hierarchical-indexing_explicit-multiindex-constructors">
<h2>Explicit MultiIndex Constructors</h2>
<p><a data-primary="MultiIndex type" data-secondary="explicit constructors for" data-type="indexterm" id="idm45858783679088"/>For more flexibility in how the index is constructed, you can instead
use the constructor methods available in the <code>pd.MultiIndex</code> class. For
example, as we did before, you can construct a <code>MultiIndex</code> from a
simple list of arrays giving the index values within each level:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="n">pd</code><code class="o">.</code><code class="n">MultiIndex</code><code class="o">.</code><code class="n">from_arrays</code><code class="p">([[</code><code class="s1">'a'</code><code class="p">,</code> <code class="s1">'a'</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">],</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">]])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="n">MultiIndex</code><code class="p">([(</code><code class="s1">'a'</code><code class="p">,</code> <code class="mi">1</code><code class="p">),</code>
                     <code class="p">(</code><code class="s1">'a'</code><code class="p">,</code> <code class="mi">2</code><code class="p">),</code>
                     <code class="p">(</code><code class="s1">'b'</code><code class="p">,</code> <code class="mi">1</code><code class="p">),</code>
                     <code class="p">(</code><code class="s1">'b'</code><code class="p">,</code> <code class="mi">2</code><code class="p">)],</code>
                    <code class="p">)</code></pre>
<p>Or you can construct it from a list of tuples giving the multiple index
values of each point:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="n">pd</code><code class="o">.</code><code class="n">MultiIndex</code><code class="o">.</code><code class="n">from_tuples</code><code class="p">([(</code><code class="s1">'a'</code><code class="p">,</code> <code class="mi">1</code><code class="p">),</code> <code class="p">(</code><code class="s1">'a'</code><code class="p">,</code> <code class="mi">2</code><code class="p">),</code> <code class="p">(</code><code class="s1">'b'</code><code class="p">,</code> <code class="mi">1</code><code class="p">),</code> <code class="p">(</code><code class="s1">'b'</code><code class="p">,</code> <code class="mi">2</code><code class="p">)])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="n">MultiIndex</code><code class="p">([(</code><code class="s1">'a'</code><code class="p">,</code> <code class="mi">1</code><code class="p">),</code>
                     <code class="p">(</code><code class="s1">'a'</code><code class="p">,</code> <code class="mi">2</code><code class="p">),</code>
                     <code class="p">(</code><code class="s1">'b'</code><code class="p">,</code> <code class="mi">1</code><code class="p">),</code>
                     <code class="p">(</code><code class="s1">'b'</code><code class="p">,</code> <code class="mi">2</code><code class="p">)],</code>
                    <code class="p">)</code></pre>
<p>You can even construct it from a Cartesian product of single indices:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="n">pd</code><code class="o">.</code><code class="n">MultiIndex</code><code class="o">.</code><code class="n">from_product</code><code class="p">([[</code><code class="s1">'a'</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">],</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">]])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="n">MultiIndex</code><code class="p">([(</code><code class="s1">'a'</code><code class="p">,</code> <code class="mi">1</code><code class="p">),</code>
                     <code class="p">(</code><code class="s1">'a'</code><code class="p">,</code> <code class="mi">2</code><code class="p">),</code>
                     <code class="p">(</code><code class="s1">'b'</code><code class="p">,</code> <code class="mi">1</code><code class="p">),</code>
                     <code class="p">(</code><code class="s1">'b'</code><code class="p">,</code> <code class="mi">2</code><code class="p">)],</code>
                    <code class="p">)</code></pre>
<p>Similarly, you can construct a <code>MultiIndex</code> directly using its internal
encoding by passing <code>levels</code> (a list of lists containing available index
values for each level) and <code>codes</code> (a list of lists that reference these
labels):</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="n">pd</code><code class="o">.</code><code class="n">MultiIndex</code><code class="p">(</code><code class="n">levels</code><code class="o">=</code><code class="p">[[</code><code class="s1">'a'</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">],</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">]],</code>
                       <code class="n">codes</code><code class="o">=</code><code class="p">[[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">],</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">]])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="n">MultiIndex</code><code class="p">([(</code><code class="s1">'a'</code><code class="p">,</code> <code class="mi">1</code><code class="p">),</code>
                     <code class="p">(</code><code class="s1">'a'</code><code class="p">,</code> <code class="mi">2</code><code class="p">),</code>
                     <code class="p">(</code><code class="s1">'b'</code><code class="p">,</code> <code class="mi">1</code><code class="p">),</code>
                     <code class="p">(</code><code class="s1">'b'</code><code class="p">,</code> <code class="mi">2</code><code class="p">)],</code>
                    <code class="p">)</code></pre>
<p>Any of these objects can be passed as the <code>index</code> argument when creating
a <code>Series</code> or <code>DataFrame</code>, or be passed to the <code>reindex</code> method of an
existing <code>Series</code> or <code>DataFrame</code>.</p>
</div></section>
<section data-pdf-bookmark="MultiIndex Level Names" data-type="sect2"><div class="sect2" id="ch_0305-hierarchical-indexing_multiindex-level-names">
<h2>MultiIndex Level Names</h2>
<p><a data-primary="levels, naming" data-type="indexterm" id="idm45858783268752"/><a data-primary="MultiIndex type" data-secondary="level names" data-type="indexterm" id="idm45858783267824"/>Sometimes it is convenient to name the levels of the <code>MultiIndex</code>. This
can be accomplished by passing the <code>names</code> argument to any of the
previously discussed <code>MultiIndex</code> constructors, or by setting the
<code>names</code> attribute of the index after the fact:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">18</code><code class="p">]:</code> <code class="n">pop</code><code class="o">.</code><code class="n">index</code><code class="o">.</code><code class="n">names</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'state'</code><code class="p">,</code> <code class="s1">'year'</code><code class="p">]</code>
         <code class="n">pop</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">18</code><code class="p">]:</code> <code class="n">state</code>       <code class="n">year</code>
         <code class="n">California</code>  <code class="mi">2010</code>    <code class="mi">37253956</code>
                     <code class="mi">2020</code>    <code class="mi">39538223</code>
         <code class="n">New</code> <code class="n">York</code>    <code class="mi">2010</code>    <code class="mi">19378102</code>
                     <code class="mi">2020</code>    <code class="mi">20201249</code>
         <code class="n">Texas</code>       <code class="mi">2010</code>    <code class="mi">25145561</code>
                     <code class="mi">2020</code>    <code class="mi">29145505</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>With more involved datasets, this can be a useful way to keep track of
the meaning of various index values.</p>
</div></section>
<section data-pdf-bookmark="MultiIndex for Columns" data-type="sect2"><div class="sect2" id="ch_0305-hierarchical-indexing_multiindex-for-columns">
<h2>MultiIndex for Columns</h2>
<p><a data-primary="column(s)" data-secondary="MultiIndex for" data-type="indexterm" id="idm45858783176672"/><a data-primary="MultiIndex type" data-secondary="for columns" data-secondary-sortas="columns" data-type="indexterm" id="idm45858783175696"/>In a <code>DataFrame</code>, the rows and columns are completely symmetric, and
just as the rows can have multiple levels of indices, the columns can
have multiple levels as well. Consider the following, which is a mock-up
of some (somewhat realistic) medical data:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">19</code><code class="p">]:</code> <code class="c1"># hierarchical indices and columns</code>
         <code class="n">index</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">MultiIndex</code><code class="o">.</code><code class="n">from_product</code><code class="p">([[</code><code class="mi">2013</code><code class="p">,</code> <code class="mi">2014</code><code class="p">],</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">]],</code>
                                            <code class="n">names</code><code class="o">=</code><code class="p">[</code><code class="s1">'year'</code><code class="p">,</code> <code class="s1">'visit'</code><code class="p">])</code>
         <code class="n">columns</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">MultiIndex</code><code class="o">.</code><code class="n">from_product</code><code class="p">([[</code><code class="s1">'Bob'</code><code class="p">,</code> <code class="s1">'Guido'</code><code class="p">,</code> <code class="s1">'Sue'</code><code class="p">],</code>
                                              <code class="p">[</code><code class="s1">'HR'</code><code class="p">,</code> <code class="s1">'Temp'</code><code class="p">]],</code>
                                              <code class="n">names</code><code class="o">=</code><code class="p">[</code><code class="s1">'subject'</code><code class="p">,</code> <code class="s1">'type'</code><code class="p">])</code>

         <code class="c1"># mock some data</code>
         <code class="n">data</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">round</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">randn</code><code class="p">(</code><code class="mi">4</code><code class="p">,</code> <code class="mi">6</code><code class="p">),</code> <code class="mi">1</code><code class="p">)</code>
         <code class="n">data</code><code class="p">[:,</code> <code class="p">::</code><code class="mi">2</code><code class="p">]</code> <code class="o">*=</code> <code class="mi">10</code>
         <code class="n">data</code> <code class="o">+=</code> <code class="mi">37</code>

         <code class="c1"># create the DataFrame</code>
         <code class="n">health_data</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> <code class="n">index</code><code class="o">=</code><code class="n">index</code><code class="p">,</code> <code class="n">columns</code><code class="o">=</code><code class="n">columns</code><code class="p">)</code>
         <code class="n">health_data</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">19</code><code class="p">]:</code> <code class="n">subject</code>      <code class="n">Bob</code>       <code class="n">Guido</code>         <code class="n">Sue</code>
         <code class="nb">type</code>          <code class="n">HR</code>  <code class="n">Temp</code>    <code class="n">HR</code>  <code class="n">Temp</code>    <code class="n">HR</code>  <code class="n">Temp</code>
         <code class="n">year</code> <code class="n">visit</code>
         <code class="mi">2013</code> <code class="mi">1</code>      <code class="mf">30.0</code>  <code class="mf">38.0</code>  <code class="mf">56.0</code>  <code class="mf">38.3</code>  <code class="mf">45.0</code>  <code class="mf">35.8</code>
              <code class="mi">2</code>      <code class="mf">47.0</code>  <code class="mf">37.1</code>  <code class="mf">27.0</code>  <code class="mf">36.0</code>  <code class="mf">37.0</code>  <code class="mf">36.4</code>
         <code class="mi">2014</code> <code class="mi">1</code>      <code class="mf">51.0</code>  <code class="mf">35.9</code>  <code class="mf">24.0</code>  <code class="mf">36.7</code>  <code class="mf">32.0</code>  <code class="mf">36.2</code>
              <code class="mi">2</code>      <code class="mf">49.0</code>  <code class="mf">36.3</code>  <code class="mf">48.0</code>  <code class="mf">39.2</code>  <code class="mf">31.0</code>  <code class="mf">35.7</code></pre>
<p>This is fundamentally four-dimensional data, where the dimensions are
the subject, the measurement type, the year, and the visit number. With
this in place we can, for example, index the top-level column by the
person’s name and get a full <code>DataFrame</code> containing just
that person’s information:<a data-startref="ix_ch17-asciidoc5" data-type="indexterm" id="idm45858782941664"/></p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">20</code><code class="p">]:</code> <code class="n">health_data</code><code class="p">[</code><code class="s1">'Guido'</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">20</code><code class="p">]:</code> <code class="nb">type</code>          <code class="n">HR</code>  <code class="n">Temp</code>
         <code class="n">year</code> <code class="n">visit</code>
         <code class="mi">2013</code> <code class="mi">1</code>      <code class="mf">56.0</code>  <code class="mf">38.3</code>
              <code class="mi">2</code>      <code class="mf">27.0</code>  <code class="mf">36.0</code>
         <code class="mi">2014</code> <code class="mi">1</code>      <code class="mf">24.0</code>  <code class="mf">36.7</code>
              <code class="mi">2</code>      <code class="mf">48.0</code>  <code class="mf">39.2</code></pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Indexing and Slicing a MultiIndex" data-type="sect1"><div class="sect1" id="ch_0305-hierarchical-indexing_indexing-and-slicing-a-multiindex">
<h1>Indexing and Slicing a MultiIndex</h1>
<p><a data-primary="MultiIndex type" data-secondary="indexing and slicing" data-type="indexterm" id="ix_ch17-asciidoc6"/>Indexing and slicing on a <code>MultiIndex</code> is designed to be intuitive, and
it helps if you think about the indices as added dimensions.
We’ll first look at indexing multiply indexed <code>Series</code>, and
then multiply indexed <code>DataFrame</code> objects.</p>
<section data-pdf-bookmark="Multiply Indexed Series" data-type="sect2"><div class="sect2" id="ch_0305-hierarchical-indexing_multiply-indexed-series">
<h2>Multiply Indexed Series</h2>
<p><a data-primary="MultiIndex type" data-secondary="multiply indexed Series" data-type="indexterm" id="idm45858782890304"/><a data-primary="Series object (Pandas)" data-secondary="multiply indexed" data-type="indexterm" id="idm45858782889328"/>Consider the multiply indexed <code>Series</code> of state populations we saw
earlier:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">21</code><code class="p">]:</code> <code class="n">pop</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">21</code><code class="p">]:</code> <code class="n">state</code>       <code class="n">year</code>
         <code class="n">California</code>  <code class="mi">2010</code>    <code class="mi">37253956</code>
                     <code class="mi">2020</code>    <code class="mi">39538223</code>
         <code class="n">New</code> <code class="n">York</code>    <code class="mi">2010</code>    <code class="mi">19378102</code>
                     <code class="mi">2020</code>    <code class="mi">20201249</code>
         <code class="n">Texas</code>       <code class="mi">2010</code>    <code class="mi">25145561</code>
                     <code class="mi">2020</code>    <code class="mi">29145505</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>We can access single elements by indexing with multiple terms:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">22</code><code class="p">]:</code> <code class="n">pop</code><code class="p">[</code><code class="s1">'California'</code><code class="p">,</code> <code class="mi">2010</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">22</code><code class="p">]:</code> <code class="mi">37253956</code></pre>
<p>The <code>MultiIndex</code> also supports <em>partial indexing</em>, or indexing just one
of the levels in the index. The result is another <code>Series</code>, with the
lower-level indices maintained:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">23</code><code class="p">]:</code> <code class="n">pop</code><code class="p">[</code><code class="s1">'California'</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">23</code><code class="p">]:</code> <code class="n">year</code>
         <code class="mi">2010</code>    <code class="mi">37253956</code>
         <code class="mi">2020</code>    <code class="mi">39538223</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p><a data-primary="partial slicing" data-type="indexterm" id="idm45858782792816"/>Partial slicing is available as well, as long as the <code>MultiIndex</code> is
sorted (see the discussion in <a data-type="xref" href="#ch_0305-hierarchical-indexing_sorted-and-unsorted-indices">“Sorted and Unsorted Indices”</a>):</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">24</code><code class="p">]:</code> <code class="n">poploc</code><code class="p">[</code><code class="s1">'california'</code><code class="p">:</code><code class="s1">'new york'</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">24</code><code class="p">]:</code> <code class="n">state</code>       <code class="n">year</code>
         <code class="n">california</code>  <code class="mi">2010</code>    <code class="mi">37253956</code>
                     <code class="mi">2020</code>    <code class="mi">39538223</code>
         <code class="n">new</code> <code class="n">york</code>    <code class="mi">2010</code>    <code class="mi">19378102</code>
                     <code class="mi">2020</code>    <code class="mi">20201249</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>with sorted indices, partial indexing can be performed on lower levels
by passing an empty slice in the first index:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">25</code><code class="p">]:</code> <code class="n">pop</code><code class="p">[:,</code> <code class="mi">2010</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">25</code><code class="p">]:</code> <code class="n">state</code>
         <code class="n">california</code>    <code class="mi">37253956</code>
         <code class="n">new</code> <code class="n">york</code>      <code class="mi">19378102</code>
         <code class="n">texas</code>         <code class="mi">25145561</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>Other types of indexing and selection (discussed in
<a data-type="xref" href="ch14.xhtml#section-0302-data-indexing-and-selection">Chapter 14</a>) work as well; for example, selection based on Boolean masks:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">26</code><code class="p">]:</code> <code class="n">pop</code><code class="p">[</code><code class="n">pop</code> <code class="o">&gt;</code> <code class="mi">22000000</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">26</code><code class="p">]:</code> <code class="n">state</code>       <code class="n">year</code>
         <code class="n">California</code>  <code class="mi">2010</code>    <code class="mi">37253956</code>
                     <code class="mi">2020</code>    <code class="mi">39538223</code>
         <code class="n">Texas</code>       <code class="mi">2010</code>    <code class="mi">25145561</code>
                     <code class="mi">2020</code>    <code class="mi">29145505</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>Selection based on fancy indexing also works:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">27</code><code class="p">]:</code> <code class="n">pop</code><code class="p">[[</code><code class="s1">'California'</code><code class="p">,</code> <code class="s1">'Texas'</code><code class="p">]]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">27</code><code class="p">]:</code> <code class="n">state</code>       <code class="n">year</code>
         <code class="n">California</code>  <code class="mi">2010</code>    <code class="mi">37253956</code>
                     <code class="mi">2020</code>    <code class="mi">39538223</code>
         <code class="n">Texas</code>       <code class="mi">2010</code>    <code class="mi">25145561</code>
                     <code class="mi">2020</code>    <code class="mi">29145505</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
</div></section>
<section data-pdf-bookmark="Multiply Indexed DataFrames" data-type="sect2"><div class="sect2" id="ch_0305-hierarchical-indexing_multiply-indexed-dataframes">
<h2>Multiply Indexed DataFrames</h2>
<p><a data-primary="DataFrame object (Pandas)" data-secondary="multiply indexed" data-type="indexterm" id="idm45858782518144"/><a data-primary="MultiIndex type" data-secondary="multiply indexed DataFrames" data-type="indexterm" id="idm45858782517232"/>A multiply indexed <code>DataFrame</code> behaves in a similar manner. Consider our
toy medical <code>DataFrame</code> from before:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">28</code><code class="p">]:</code> <code class="n">health_data</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">28</code><code class="p">]:</code> <code class="n">subject</code>      <code class="n">Bob</code>       <code class="n">Guido</code>         <code class="n">Sue</code>
         <code class="nb">type</code>          <code class="n">HR</code>  <code class="n">Temp</code>    <code class="n">HR</code>  <code class="n">Temp</code>    <code class="n">HR</code>  <code class="n">Temp</code>
         <code class="n">year</code> <code class="n">visit</code>
         <code class="mi">2013</code> <code class="mi">1</code>      <code class="mf">30.0</code>  <code class="mf">38.0</code>  <code class="mf">56.0</code>  <code class="mf">38.3</code>  <code class="mf">45.0</code>  <code class="mf">35.8</code>
              <code class="mi">2</code>      <code class="mf">47.0</code>  <code class="mf">37.1</code>  <code class="mf">27.0</code>  <code class="mf">36.0</code>  <code class="mf">37.0</code>  <code class="mf">36.4</code>
         <code class="mi">2014</code> <code class="mi">1</code>      <code class="mf">51.0</code>  <code class="mf">35.9</code>  <code class="mf">24.0</code>  <code class="mf">36.7</code>  <code class="mf">32.0</code>  <code class="mf">36.2</code>
              <code class="mi">2</code>      <code class="mf">49.0</code>  <code class="mf">36.3</code>  <code class="mf">48.0</code>  <code class="mf">39.2</code>  <code class="mf">31.0</code>  <code class="mf">35.7</code></pre>
<p>Remember that columns are primary in a <code>DataFrame</code>, and the syntax used
for multiply indexed <code>Series</code> applies to the columns. For example, we
can recover Guido’s heart rate data with a simple operation:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">29</code><code class="p">]:</code> <code class="n">health_data</code><code class="p">[</code><code class="s1">'Guido'</code><code class="p">,</code> <code class="s1">'HR'</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">29</code><code class="p">]:</code> <code class="n">year</code>  <code class="n">visit</code>
         <code class="mi">2013</code>  <code class="mi">1</code>        <code class="mf">56.0</code>
               <code class="mi">2</code>        <code class="mf">27.0</code>
         <code class="mi">2014</code>  <code class="mi">1</code>        <code class="mf">24.0</code>
               <code class="mi">2</code>        <code class="mf">48.0</code>
         <code class="n">Name</code><code class="p">:</code> <code class="p">(</code><code class="n">Guido</code><code class="p">,</code> <code class="n">HR</code><code class="p">),</code> <code class="n">dtype</code><code class="p">:</code> <code class="n">float64</code></pre>
<p>Also, as with the single-index case, we can use the <code>loc</code>, <code>iloc</code>, and
<code>ix</code> indexers introduced in
<a data-type="xref" href="ch14.xhtml#section-0302-data-indexing-and-selection">Chapter 14</a>. For example:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">30</code><code class="p">]:</code> <code class="n">health_data</code><code class="o">.</code><code class="n">iloc</code><code class="p">[:</code><code class="mi">2</code><code class="p">,</code> <code class="p">:</code><code class="mi">2</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">30</code><code class="p">]:</code> <code class="n">subject</code>      <code class="n">Bob</code>
         <code class="nb">type</code>          <code class="n">HR</code>  <code class="n">Temp</code>
         <code class="n">year</code> <code class="n">visit</code>
         <code class="mi">2013</code> <code class="mi">1</code>      <code class="mf">30.0</code>  <code class="mf">38.0</code>
              <code class="mi">2</code>      <code class="mf">47.0</code>  <code class="mf">37.1</code></pre>
<p>These indexers provide an array-like view of the underlying
two-dimensional data, but each individual index in <code>loc</code> or <code>iloc</code> can
be passed a tuple of multiple indices. For example:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">31</code><code class="p">]:</code> <code class="n">health_data</code><code class="o">.</code><code class="n">loc</code><code class="p">[:,</code> <code class="p">(</code><code class="s1">'Bob'</code><code class="p">,</code> <code class="s1">'HR'</code><code class="p">)]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">31</code><code class="p">]:</code> <code class="n">year</code>  <code class="n">visit</code>
         <code class="mi">2013</code>  <code class="mi">1</code>        <code class="mf">30.0</code>
               <code class="mi">2</code>        <code class="mf">47.0</code>
         <code class="mi">2014</code>  <code class="mi">1</code>        <code class="mf">51.0</code>
               <code class="mi">2</code>        <code class="mf">49.0</code>
         <code class="n">Name</code><code class="p">:</code> <code class="p">(</code><code class="n">Bob</code><code class="p">,</code> <code class="n">HR</code><code class="p">),</code> <code class="n">dtype</code><code class="p">:</code> <code class="n">float64</code></pre>
<p><a data-primary="slicing" data-secondary="multiply indexed DataFrames" data-type="indexterm" id="idm45858782262608"/>Working with slices within these index tuples is not especially
convenient; trying to create a slice within a tuple will lead to a
syntax error:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">32</code><code class="p">]:</code> <code class="n">health_data</code><code class="o">.</code><code class="n">loc</code><code class="p">[(:,</code> <code class="mi">1</code><code class="p">),</code> <code class="p">(:,</code> <code class="s1">'HR'</code><code class="p">)]</code>
<code class="ne">SyntaxError</code><code class="p">:</code> <code class="n">invalid</code> <code class="n">syntax</code> <code class="p">(</code><code class="mf">3311942670.</code><code class="n">py</code><code class="p">,</code> <code class="n">line</code> <code class="mi">1</code><code class="p">)</code></pre>
<p>You could get around this by building the desired slice explicitly using
Python’s built-in <code>slice</code> function, <a data-primary="IndexSlice object" data-type="indexterm" id="idm45858782194304"/>but a better way in this
context is to use an <code>IndexSlice</code> object, which Pandas provides for
precisely this situation. For example:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">33</code><code class="p">]:</code> <code class="n">idx</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">IndexSlice</code>
         <code class="n">health_data</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="n">idx</code><code class="p">[:,</code> <code class="mi">1</code><code class="p">],</code> <code class="n">idx</code><code class="p">[:,</code> <code class="s1">'HR'</code><code class="p">]]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">33</code><code class="p">]:</code> <code class="n">subject</code>      <code class="n">Bob</code> <code class="n">Guido</code>   <code class="n">Sue</code>
         <code class="nb">type</code>          <code class="n">HR</code>    <code class="n">HR</code>    <code class="n">HR</code>
         <code class="n">year</code> <code class="n">visit</code>
         <code class="mi">2013</code> <code class="mi">1</code>      <code class="mf">30.0</code>  <code class="mf">56.0</code>  <code class="mf">45.0</code>
         <code class="mi">2014</code> <code class="mi">1</code>      <code class="mf">51.0</code>  <code class="mf">24.0</code>  <code class="mf">32.0</code></pre>
<p>As you can see, there are many ways to interact with data in multiply
indexed <code>Series</code> and <code>DataFrame</code>s, and as with many tools in this book
the best way to become familiar with them is to try them out!<a data-startref="ix_ch17-asciidoc6" data-type="indexterm" id="idm45858782083056"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Rearranging Multi-Indexes" data-type="sect1"><div class="sect1" id="ch_0305-hierarchical-indexing_rearranging-multi-indexes">
<h1>Rearranging Multi-Indexes</h1>
<p><a data-primary="hierarchical indexing" data-secondary="rearranging multi-indices" data-type="indexterm" id="ix_ch17-asciidoc7"/><a data-primary="MultiIndex type" data-secondary="rearranging" data-type="indexterm" id="ix_ch17-asciidoc8"/>One of the keys to working with multiply indexed data is knowing how to
effectively transform the data. There are a number of operations that
will preserve all the information in the dataset, but rearrange it for
the purposes of various computations. We saw a brief example of this in
the <code>stack</code> and <code>unstack</code> methods, but there are many more ways to
finely control the rearrangement of data between hierarchical indices
and columns, and we’ll explore them here.</p>
<section data-pdf-bookmark="Sorted and Unsorted Indices" data-type="sect2"><div class="sect2" id="ch_0305-hierarchical-indexing_sorted-and-unsorted-indices">
<h2>Sorted and Unsorted Indices</h2>
<p><a data-primary="MultiIndex type" data-secondary="sorted/unsorted indices with" data-type="indexterm" id="idm45858782075664"/><a data-primary="slicing" data-secondary="MultiIndex with sorted/unsorted indices" data-type="indexterm" id="idm45858782074720"/>Earlier I briefly mentioned a caveat, but I should emphasize it more
here. <em>Many of the <code>MultiIndex</code> slicing operations will fail if the
index is not sorted.</em> Let’s take a closer look.</p>
<p>We’ll start by creating some simple multiply indexed data
where the indices are <em>not lexographically sorted</em>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">34</code><code class="p">]:</code> <code class="n">index</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">MultiIndex</code><code class="o">.</code><code class="n">from_product</code><code class="p">([[</code><code class="s1">'a'</code><code class="p">,</code> <code class="s1">'c'</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">],</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">]])</code>
         <code class="n">data</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">rand</code><code class="p">(</code><code class="mi">6</code><code class="p">),</code> <code class="n">index</code><code class="o">=</code><code class="n">index</code><code class="p">)</code>
         <code class="n">data</code><code class="o">.</code><code class="n">index</code><code class="o">.</code><code class="n">names</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'char'</code><code class="p">,</code> <code class="s1">'int'</code><code class="p">]</code>
         <code class="n">data</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">34</code><code class="p">]:</code> <code class="n">char</code>  <code class="nb">int</code>
         <code class="n">a</code>     <code class="mi">1</code>      <code class="mf">0.280341</code>
               <code class="mi">2</code>      <code class="mf">0.097290</code>
         <code class="n">c</code>     <code class="mi">1</code>      <code class="mf">0.206217</code>
               <code class="mi">2</code>      <code class="mf">0.431771</code>
         <code class="n">b</code>     <code class="mi">1</code>      <code class="mf">0.100183</code>
               <code class="mi">2</code>      <code class="mf">0.015851</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">float64</code></pre>
<p>If we try to take a partial slice of this index, it will result in an
error:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">35</code><code class="p">]:</code> <code class="k">try</code><code class="p">:</code>
             <code class="n">data</code><code class="p">[</code><code class="s1">'a'</code><code class="p">:</code><code class="s1">'b'</code><code class="p">]</code>
         <code class="k">except</code> <code class="ne">KeyError</code> <code class="k">as</code> <code class="n">e</code><code class="p">:</code>
             <code class="nb">print</code><code class="p">(</code><code class="s2">"KeyError"</code><code class="p">,</code> <code class="n">e</code><code class="p">)</code>
<code class="ne">KeyError</code> <code class="s1">'Key length (1) was greater than MultiIndex lexsort depth (0)'</code></pre>
<p>Although it is not entirely clear from the error message, this is the
result of the <code>MultiIndex</code> not being sorted. For various reasons,
partial slices and other similar operations require the levels in the
<code>MultiIndex</code> to be in sorted (i.e., lexographical) order. Pandas
provides a number of convenience routines to perform this type of
sorting, such as the <code>sort_index</code> and <code>sortlevel</code> methods of the
<code>DataFrame</code>. We’ll use the simplest, <code>sort_index</code>, here:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">36</code><code class="p">]:</code> <code class="n">data</code> <code class="o">=</code> <code class="n">data</code><code class="o">.</code><code class="n">sort_index</code><code class="p">()</code>
         <code class="n">data</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">36</code><code class="p">]:</code> <code class="n">char</code>  <code class="nb">int</code>
         <code class="n">a</code>     <code class="mi">1</code>      <code class="mf">0.280341</code>
               <code class="mi">2</code>      <code class="mf">0.097290</code>
         <code class="n">b</code>     <code class="mi">1</code>      <code class="mf">0.100183</code>
               <code class="mi">2</code>      <code class="mf">0.015851</code>
         <code class="n">c</code>     <code class="mi">1</code>      <code class="mf">0.206217</code>
               <code class="mi">2</code>      <code class="mf">0.431771</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">float64</code></pre>
<p>With the index sorted in this way, partial slicing will work as
expected:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">37</code><code class="p">]:</code> <code class="n">data</code><code class="p">[</code><code class="s1">'a'</code><code class="p">:</code><code class="s1">'b'</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">37</code><code class="p">]:</code> <code class="n">char</code>  <code class="nb">int</code>
         <code class="n">a</code>     <code class="mi">1</code>      <code class="mf">0.280341</code>
               <code class="mi">2</code>      <code class="mf">0.097290</code>
         <code class="n">b</code>     <code class="mi">1</code>      <code class="mf">0.100183</code>
               <code class="mi">2</code>      <code class="mf">0.015851</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">float64</code></pre>
</div></section>
<section data-pdf-bookmark="Stacking and Unstacking Indices" data-type="sect2"><div class="sect2" id="ch_0305-hierarchical-indexing_stacking-and-unstacking-indices">
<h2>Stacking and Unstacking Indices</h2>
<p><a data-primary="MultiIndex type" data-secondary="stacking/unstacking indices" data-type="indexterm" id="idm45858781786128"/>As we saw briefly before, it is possible to convert a dataset from a
stacked multi-index to a simple two-dimensional representation,
optionally specifying the level to use:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">38</code><code class="p">]:</code> <code class="n">pop</code><code class="o">.</code><code class="n">unstack</code><code class="p">(</code><code class="n">level</code><code class="o">=</code><code class="mi">0</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">38</code><code class="p">]:</code> <code class="n">year</code>            <code class="mi">2010</code>      <code class="mi">2020</code>
         <code class="n">state</code>
         <code class="n">California</code>  <code class="mi">37253956</code>  <code class="mi">39538223</code>
         <code class="n">New</code> <code class="n">York</code>    <code class="mi">19378102</code>  <code class="mi">20201249</code>
         <code class="n">Texas</code>       <code class="mi">25145561</code>  <code class="mi">29145505</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">39</code><code class="p">]:</code> <code class="n">pop</code><code class="o">.</code><code class="n">unstack</code><code class="p">(</code><code class="n">level</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">39</code><code class="p">]:</code> <code class="n">state</code>       <code class="n">year</code>
         <code class="n">California</code>  <code class="mi">2010</code>    <code class="mi">37253956</code>
                     <code class="mi">2020</code>    <code class="mi">39538223</code>
         <code class="n">New</code> <code class="n">York</code>    <code class="mi">2010</code>    <code class="mi">19378102</code>
                     <code class="mi">2020</code>    <code class="mi">20201249</code>
         <code class="n">Texas</code>       <code class="mi">2010</code>    <code class="mi">25145561</code>
                     <code class="mi">2020</code>    <code class="mi">29145505</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>The opposite of <code>unstack</code> is <code>stack</code>, which here can be used to recover
the original 
<span class="keep-together">series</span>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">40</code><code class="p">]:</code> <code class="n">pop</code><code class="o">.</code><code class="n">unstack</code><code class="p">()</code><code class="o">.</code><code class="n">stack</code><code class="p">()</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">40</code><code class="p">]:</code> <code class="n">state</code>       <code class="n">year</code>
         <code class="n">California</code>  <code class="mi">2010</code>    <code class="mi">37253956</code>
                     <code class="mi">2020</code>    <code class="mi">39538223</code>
         <code class="n">New</code> <code class="n">York</code>    <code class="mi">2010</code>    <code class="mi">19378102</code>
                     <code class="mi">2020</code>    <code class="mi">20201249</code>
         <code class="n">Texas</code>       <code class="mi">2010</code>    <code class="mi">25145561</code>
                     <code class="mi">2020</code>    <code class="mi">29145505</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
</div></section>
<section data-pdf-bookmark="Index Setting and Resetting" data-type="sect2"><div class="sect2" id="ch_0305-hierarchical-indexing_index-setting-and-resetting">
<h2>Index Setting and Resetting</h2>
<p><a data-primary="MultiIndex type" data-secondary="index setting/resetting" data-type="indexterm" id="idm45858781575232"/><a data-primary="reset_index() method" data-type="indexterm" id="idm45858781574064"/>Another way to rearrange hierarchical data is to turn the index labels
into columns; this can be accomplished with the <code>reset_index</code> method.
Calling this on the population dictionary will result in a <code>DataFrame</code>
with <code>state</code> and <code>year</code> columns holding the information that was
formerly in the index. For clarity, we can optionally specify the name
of the data for the column representation:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">41</code><code class="p">]:</code> <code class="n">pop_flat</code> <code class="o">=</code> <code class="n">pop</code><code class="o">.</code><code class="n">reset_index</code><code class="p">(</code><code class="n">name</code><code class="o">=</code><code class="s1">'population'</code><code class="p">)</code>
         <code class="n">pop_flat</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">41</code><code class="p">]:</code>         <code class="n">state</code>  <code class="n">year</code>  <code class="n">population</code>
         <code class="mi">0</code>  <code class="n">California</code>  <code class="mi">2010</code>    <code class="mi">37253956</code>
         <code class="mi">1</code>  <code class="n">California</code>  <code class="mi">2020</code>    <code class="mi">39538223</code>
         <code class="mi">2</code>    <code class="n">New</code> <code class="n">York</code>  <code class="mi">2010</code>    <code class="mi">19378102</code>
         <code class="mi">3</code>    <code class="n">New</code> <code class="n">York</code>  <code class="mi">2020</code>    <code class="mi">20201249</code>
         <code class="mi">4</code>       <code class="n">Texas</code>  <code class="mi">2010</code>    <code class="mi">25145561</code>
         <code class="mi">5</code>       <code class="n">Texas</code>  <code class="mi">2020</code>    <code class="mi">29145505</code></pre>
<p>A common pattern is to build a <code>MultiIndex</code> from the column values. This
can be done with the <code>set_index</code> method of the <code>DataFrame</code>, which
returns a multiply indexed <code>DataFrame</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">42</code><code class="p">]:</code> <code class="n">pop_flat</code><code class="o">.</code><code class="n">set_index</code><code class="p">([</code><code class="s1">'state'</code><code class="p">,</code> <code class="s1">'year'</code><code class="p">])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">42</code><code class="p">]:</code>                  <code class="n">population</code>
         <code class="n">state</code>      <code class="n">year</code>
         <code class="n">California</code> <code class="mi">2010</code>    <code class="mi">37253956</code>
                    <code class="mi">2020</code>    <code class="mi">39538223</code>
         <code class="n">New</code> <code class="n">York</code>   <code class="mi">2010</code>    <code class="mi">19378102</code>
                    <code class="mi">2020</code>    <code class="mi">20201249</code>
         <code class="n">Texas</code>      <code class="mi">2010</code>    <code class="mi">25145561</code>
                    <code class="mi">2020</code>    <code class="mi">29145505</code></pre>
<p>In practice, this type of reindexing is one of the more useful patterns
when exploring real-world datasets<a data-startref="ix_ch17-asciidoc8" data-type="indexterm" id="idm45858781463664"/><a data-startref="ix_ch17-asciidoc7" data-type="indexterm" id="idm45858781428912"/>.<a data-startref="ix_ch17-asciidoc2" data-type="indexterm" id="idm45858781428176"/><a data-startref="ix_ch17-asciidoc1" data-type="indexterm" id="idm45858781427504"/><a data-startref="ix_ch17-asciidoc0" data-type="indexterm" id="idm45858781426832"/></p>
</div></section>
</div></section>
</div></section></div></body></html>