- en: Chapter 14\. Data Indexing and Selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Part II](part02.xhtml#section-0200-introduction-to-numpy), we looked in
    detail at methods and tools to access, set, and modify values in NumPy arrays.
    These included indexing (e.g., `arr[2, 1]`), slicing (e.g., `arr[:, 1:5]`), masking
    (e.g., `arr[arr > 0]`), fancy indexing (e.g., `arr[0, [1, 5]]`), and combinations
    thereof (e.g., `arr[:, [1, 5]]`). Here we’ll look at similar means of accessing
    and modifying values in Pandas `Series` and `DataFrame` objects. If you have used
    the NumPy patterns, the corresponding patterns in Pandas will feel very familiar,
    though there are a few quirks to be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with the simple case of the one-dimensional `Series` object, and
    then move on to the more complicated two-dimensional `DataFrame` object.
  prefs: []
  type: TYPE_NORMAL
- en: Data Selection in Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw in the previous chapter, a `Series` object acts in many ways like
    a one-dimensional NumPy array, and in many ways like a standard Python dictionary.
    If you keep these two overlapping analogies in mind, it will help you understand
    the patterns of data indexing and selection in these arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Series as Dictionary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like a dictionary, the `Series` object provides a mapping from a collection
    of keys to a collection of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use dictionary-like Python expressions and methods to examine the
    keys/indices and values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`Series` objects can also be modified with a dictionary-like syntax. Just as
    you can extend a dictionary by assigning to a new key, you can extend a `Series`
    by assigning to a new index value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This easy mutability of the objects is a convenient feature: under the hood,
    Pandas is making decisions about memory layout and data copying that might need
    to take place, and the user generally does not need to worry about these issues.'
  prefs: []
  type: TYPE_NORMAL
- en: Series as One-Dimensional Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `Series` builds on this dictionary-like interface and provides array-style
    item selection via the same basic mechanisms as NumPy arrays—that is, slices,
    masking, and fancy indexing. Examples of these are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Of these, slicing may be the source of the most confusion. Notice that when
    slicing with an explicit index (e.g., `data['a':'c']`), the final index is *included*
    in the slice, while when slicing with an implicit index (e.g., `data[0:2]`), the
    final index is *excluded* from the slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indexers: loc and iloc'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If your `Series` has an explicit integer index, an indexing operation such
    as `data[1]` will use the explicit indices, while a slicing operation like `data[1:3]`
    will use the implicit Python-style indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Because of this potential confusion in the case of integer indexes, Pandas provides
    some special *indexer* attributes that explicitly expose certain indexing schemes.
    These are not functional methods, but attributes that expose a particular slicing
    interface to the data in the `Series`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `loc` attribute allows indexing and slicing that always references
    the explicit index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `iloc` attribute allows indexing and slicing that always references the
    implicit Python-style index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: One guiding principle of Python code is that “explicit is better than implicit.”
    The explicit nature of `loc` and `iloc` makes them helpful in maintaining clean
    and readable code; especially in the case of integer indexes, using them consistently
    can prevent subtle bugs due to the mixed indexing/slicing convention.
  prefs: []
  type: TYPE_NORMAL
- en: Data Selection in DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall that a `DataFrame` acts in many ways like a two-dimensional or structured
    array, and in other ways like a dictionary of `Series` structures sharing the
    same index. These analogies can be helpful to keep in mind as we explore data
    selection within this structure.
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame as Dictionary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first analogy we will consider is the `DataFrame` as a dictionary of related
    `Series` objects. Let’s return to our example of areas and populations of states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The individual `Series` that make up the columns of the `DataFrame` can be
    accessed via dictionary-style indexing of the column name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Equivalently, we can use attribute-style access with column names that are
    strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Though this is a useful shorthand, keep in mind that it does not work for all
    cases! For example, if the column names are not strings, or if the column names
    conflict with methods of the `DataFrame`, this attribute-style access is not possible.
    For example, the `DataFrame` has a `pop` method, so `data.pop` will point to this
    rather than the `pop` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In particular, you should avoid the temptation to try column assignment via
    attributes (i.e., use `data['pop'] = z` rather than `data.pop = z`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Like with the `Series` objects discussed earlier, this dictionary-style syntax
    can also be used to modify the object, in this case adding a new column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This shows a preview of the straightforward syntax of element-by-element arithmetic
    between `Series` objects; we’ll dig into this further in [Chapter 15](ch15.xhtml#section-0303-operations-in-pandas).
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame as Two-Dimensional Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned previously, we can also view the `DataFrame` as an enhanced two-dimensional
    array. We can examine the raw underlying data array using the `values` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With this picture in mind, many familiar array-like operations can be done
    on the `DataFrame` itself. For example, we can transpose the full `DataFrame`
    to swap rows and columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When it comes to indexing of a `DataFrame` object, however, it is clear that
    the dictionary-style indexing of columns precludes our ability to simply treat
    it as a NumPy array. In particular, passing a single index to an array accesses
    a row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'and passing a single “index” to a `DataFrame` accesses a column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, for array-style indexing, we need another convention. Here Pandas again
    uses the `loc` and `iloc` indexers mentioned earlier. Using the `iloc` indexer,
    we can index the underlying array as if it were a simple NumPy array (using the
    implicit Python-style index), but the `DataFrame` index and column labels are
    maintained in the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, using the `loc` indexer we can index the underlying data in an array-like
    style but using the explicit index and column names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Any of the familiar NumPy-style data access patterns can be used within these
    indexers. For example, in the `loc` indexer we can combine masking and fancy indexing
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Any of these indexing conventions may also be used to set or modify values;
    this is done in the standard way that you might be accustomed to from working
    with NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To build up your fluency in Pandas data manipulation, I suggest spending some
    time with a simple `DataFrame` and exploring the types of indexing, slicing, masking,
    and fancy indexing that are allowed by these various indexing approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Indexing Conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a couple of extra indexing conventions that might seem at odds with
    the preceding discussion, but nevertheless can be useful in practice. First, while
    *indexing* refers to columns, *slicing* refers to rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Such slices can also refer to rows by number rather than by index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, direct masking operations are interpreted row-wise rather than column-wise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: These two conventions are syntactically similar to those on a NumPy array, and
    while they may not precisely fit the mold of the Pandas conventions, they are
    included due to their practical utility.
  prefs: []
  type: TYPE_NORMAL
