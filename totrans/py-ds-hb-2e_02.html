<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 1. Getting Started in IPython and Jupyter" data-type="chapter" epub:type="chapter"><div class="chapter" id="section-0101-help-and-documentation">
<h1><span class="label">Chapter 1. </span>Getting Started in IPython and Jupyter</h1>
<p>In writing Python code for data science, I generally go between three
modes of working: I use the IPython shell for trying out short sequences
of commands, the Jupyter Notebook for longer interactive analysis and
for sharing content with others, and interactive development
environments (IDEs) like Emacs or VSCode for creating reusable Python
packages. This chapter focuses on the first two modes: the IPython shell
and the Jupyter Notebook. Use of an IDE for software development is an
important third tool in the data scientist’s repertoire, but
we will not directly address that here.</p>
<section data-pdf-bookmark="Launching the IPython Shell" data-type="sect1"><div class="sect1" id="ch_0101-help-and-documentation_launching-the-ipython-shell">
<h1>Launching the IPython Shell</h1>
<p><a data-primary="IPython" data-secondary="launching shell" data-type="indexterm" id="idm45858813417888"/><a data-primary="shell, IPython" data-secondary="launching" data-type="indexterm" id="idm45858813786096"/>The text in this part, like most of this book, is not designed to be
absorbed passively. I recommend that as you read through it, you follow
along and experiment with the tools and syntax we cover: the muscle
memory you build through doing this will be far more useful than the
simple act of reading about it. Start by launching the IPython
interpreter by typing <strong><code>ipython</code></strong> on the command line; alternatively, if
you’ve installed a distribution like Anaconda or EPD, there
may be a launcher specific to your system.</p>
<p>Once you do this, you should see a prompt like the following:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">Python</code> <code class="mf">3.9.2</code> <code class="p">(</code><code class="n">v3</code><code class="mf">.9.2</code><code class="p">:</code><code class="mi">1</code><code class="n">a79785e3e</code><code class="p">,</code> <code class="n">Feb</code> <code class="mi">19</code> <code class="mi">2021</code><code class="p">,</code> <code class="mi">09</code><code class="p">:</code><code class="mi">06</code><code class="p">:</code><code class="mi">10</code><code class="p">)</code>
<code class="n">Type</code> <code class="s1">'copyright'</code><code class="p">,</code> <code class="s1">'credits'</code> <code class="ow">or</code> <code class="s1">'license'</code> <code class="k">for</code> <code class="n">more</code> <code class="n">information</code>
<code class="n">IPython</code> <code class="mf">7.21.0</code> <code class="o">--</code> <code class="n">An</code> <code class="n">enhanced</code> <code class="n">Interactive</code> <code class="n">Python</code><code class="o">.</code> <code class="n">Type</code> <code class="s1">'?'</code> <code class="k">for</code> <code class="n">help</code><code class="o">.</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code></pre>
<p>With that, you’re ready to follow along.</p>
</div></section>
<section data-pdf-bookmark="Launching the Jupyter Notebook" data-type="sect1"><div class="sect1" id="ch_0101-help-and-documentation_launching-the-jupyter-notebook">
<h1>Launching the Jupyter Notebook</h1>
<p><a data-primary="documentation, accessing" data-secondary="IPython" data-type="indexterm" id="idm45858822664080"/><a data-primary="help" data-secondary="IPython" data-type="indexterm" id="idm45858817097840"/><a data-primary="IPython" data-secondary="documentation" data-type="indexterm" id="idm45858815831136"/><a data-primary="IPython" data-secondary="help and documentation" data-type="indexterm" id="idm45858813741888"/><a data-primary="IPython" data-secondary="launching Jupyter notebook" data-type="indexterm" id="idm45858813700720"/><a data-primary="Jupyter notebook" data-secondary="launching" data-type="indexterm" id="idm45858813974320"/>The Jupyter Notebook is a browser-based graphical interface to the
IPython shell, and builds on it a rich set of dynamic display
capabilities. As well as executing Python/IPython statements, notebooks
allow the user to include formatted text, static and dynamic
visualizations, mathematical equations, JavaScript widgets, and much
more. Furthermore, these documents can be saved in a way that lets other
people open them and execute the code on their own systems.</p>
<p>Though you’ll view and edit Jupyter notebooks through your
web browser window, they must connect to a running Python process in
order to execute code. You can start this process (known as a
“kernel”) by running the following command in your system shell:</p>
<pre data-type="programlisting">
$ <strong>jupyter lab</strong>
</pre>
<p>This command launches a local web server that will be visible to your
browser. It immediately spits out a log showing what it is doing; that
log will look something like this:</p>
<pre data-type="programlisting">
$ <strong>jupyter lab</strong>
[ServerApp] Serving notebooks from local directory: /Users/jakevdp/ \
PythonDataScienceHandbook
[ServerApp] Jupyter Server 1.4.1 is running at:
[ServerApp] http://localhost:8888/lab?token=dd852649
[ServerApp] Use Control-C to stop this server and shut down all kernels
(twice to skip confirmation).
</pre>
<p>Upon issuing the command, your default browser should automatically open
and navigate to the listed local URL; the exact address will depend on
your system. If the browser does not open automatically, you can open a
window and manually open this address (<em>http://localhost:8888/lab/</em> in
this example).</p>
</div></section>
<section data-pdf-bookmark="Help and Documentation in IPython" data-type="sect1"><div class="sect1" id="ch_0101-help-and-documentation_help-and-documentation-in-ipython">
<h1>Help and Documentation in IPython</h1>
<p>If you read no other section in this chapter, read this one: I find the
tools discussed here to be the most transformative contributions of
IPython to my daily workflow.</p>
<p>When a technologically minded person is asked to help a friend, family
member, or colleague with a computer problem, most of the time
it’s less a matter of knowing the answer than of knowing how
to quickly find an unknown answer. In data science it’s the
same: searchable web resources such as online documentation, mailing
list threads, and Stack Overflow answers contain a wealth of
information, even (especially?) about topics you’ve found
yourself searching on before. Being an effective practitioner of data
science is less about memorizing the tool or command you should use for
every possible situation, and more about learning to effectively find
the information you don’t know, whether through a web search
engine or another means.</p>
<p>One of the most useful functions of IPython/Jupyter is to shorten the
gap between the user and the type of documentation and search that will
help them do their work effectively. While web searches still play a
role in answering complicated questions, an amazing amount of
information can be found through IPython alone. Some examples of the
questions IPython can help answer in a few keystrokes include:</p>
<ul>
<li>
<p>How do I call this function? What arguments and options does it have?</p>
</li>
<li>
<p>What does the source code of this Python object look like?</p>
</li>
<li>
<p>What is in this package I imported?</p>
</li>
<li>
<p>What attributes or methods does this object have?</p>
</li>
</ul>
<p>Here we’ll discuss the tools provided in the IPython shell
and Jupyter Notebook to quickly access this information, namely the <code>?</code>
character to explore documentation, the <code>??</code> characters to explore
source code, and the Tab key for autocompletion.</p>
<section data-pdf-bookmark="Accessing Documentation with ?" data-type="sect2"><div class="sect2" id="ch_0101-help-and-documentation_accessing-documentation-with">
<h2>Accessing Documentation with ?</h2>
<p><a data-primary="? (question mark)" data-type="indexterm" id="idm45858813807296"/><a data-primary="IPython" data-secondary="accessing documentation with ?" data-type="indexterm" id="idm45858816534416"/><a data-primary="question mark (?), accessing IPython documentation with" data-type="indexterm" id="idm45858821497760"/>The Python language and its data science ecosystem are built with the
user in mind, and one big part of that is access to documentation. Every
Python object contains a reference to a string, known as a <em>docstring</em>,
which in most cases will contain a concise summary of the object and how
to use it. <a data-primary="help() function" data-type="indexterm" id="idm45858831237968"/>Python has a built-in <code>help</code> function that can access this
information and print the results. For example, to see the
documentation of the built-in <code>len</code> function, you can do the following:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="n">help</code><code class="p">(</code><code class="nb">len</code><code class="p">)</code>
<code class="n">Help</code> <code class="n">on</code> <code class="n">built</code><code class="o">-</code><code class="ow">in</code> <code class="n">function</code> <code class="nb">len</code> <code class="ow">in</code> <code class="n">module</code> <code class="n">builtins</code><code class="p">:</code>

<code class="nb">len</code><code class="p">(</code><code class="n">obj</code><code class="p">,</code> <code class="o">/</code><code class="p">)</code>
    <code class="n">Return</code> <code class="n">the</code> <code class="n">number</code> <code class="n">of</code> <code class="n">items</code> <code class="ow">in</code> <code class="n">a</code> <code class="n">container</code><code class="o">.</code></pre>
<p>Depending on your interpreter, this information may be displayed as
inline text or in a separate pop-up window.</p>
<p>Because finding help on an object is so common and useful, IPython and
Jupyter introduce the <code>?</code> character as a shorthand for accessing this
documentation and other relevant information:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> len<code class="o">?</code>
<code class="n">Signature</code><code class="p">:</code> <code class="nb">len</code><code class="p">(</code><code class="n">obj</code><code class="p">,</code> <code class="o">/</code><code class="p">)</code>
<code class="n">Docstring</code><code class="p">:</code> <code class="n">Return</code> <code class="n">the</code> <code class="n">number</code> <code class="n">of</code> <code class="n">items</code> <code class="ow">in</code> <code class="n">a</code> <code class="n">container</code><code class="o">.</code>
<code class="n">Type</code><code class="p">:</code>      <code class="n">builtin_function_or_method</code></pre>
<p class="pagebreak-before less_space">This notation works for just about anything, including object methods:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="n">L</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> L.insert<code class="o">?</code>
<code class="n">Signature</code><code class="p">:</code> <code class="n">L</code><code class="o">.</code><code class="n">insert</code><code class="p">(</code><code class="n">index</code><code class="p">,</code> <code class="nb">object</code><code class="p">,</code> <code class="o">/</code><code class="p">)</code>
<code class="n">Docstring</code><code class="p">:</code> <code class="n">Insert</code> <code class="nb">object</code> <code class="n">before</code> <code class="n">index</code><code class="o">.</code>
<code class="n">Type</code><code class="p">:</code>      <code class="n">builtin_function_or_method</code></pre>
<p>or even objects themselves, with the documentation from their type:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> L<code class="o">?</code>
<code class="n">Type</code><code class="p">:</code>        <code class="nb">list</code>
<code class="n">String</code> <code class="n">form</code><code class="p">:</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]</code>
<code class="n">Length</code><code class="p">:</code>      <code class="mi">3</code>
<code class="n">Docstring</code><code class="p">:</code>
<code class="n">Built</code><code class="o">-</code><code class="ow">in</code> <code class="n">mutable</code> <code class="n">sequence</code><code class="o">.</code>

<code class="n">If</code> <code class="n">no</code> <code class="n">argument</code> <code class="ow">is</code> <code class="n">given</code><code class="p">,</code> <code class="n">the</code> <code class="n">constructor</code> <code class="n">creates</code> <code class="n">a</code> <code class="n">new</code> <code class="n">empty</code> <code class="nb">list</code><code class="o">.</code>
<code class="n">The</code> <code class="n">argument</code> <code class="n">must</code> <code class="n">be</code> <code class="n">an</code> <code class="n">iterable</code> <code class="k">if</code> <code class="n">specified</code><code class="o">.</code></pre>
<p>Importantly, this will even work for functions or other objects you
create yourself! Here we’ll define a small function with a
docstring:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="k">def</code> <code class="nf">square</code><code class="p">(</code><code class="n">a</code><code class="p">):</code>
  <code class="o">....</code><code class="p">:</code>     <code class="s2">"""Return the square of a."""</code>
  <code class="o">....</code><code class="p">:</code>     <code class="k">return</code> <code class="n">a</code> <code class="o">**</code> <code class="mi">2</code>
  <code class="o">....</code><code class="p">:</code></pre>
<p>Note that to create a docstring for our function, we simply placed a
string literal in the first line. Because docstrings are usually
multiple lines, by convention we used Python’s triple-quote
notation for multiline strings.</p>
<p>Now we’ll use the <code>?</code> to find this docstring:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> square<code class="o">?</code>
<code class="n">Signature</code><code class="p">:</code> <code class="n">square</code><code class="p">(</code><code class="n">a</code><code class="p">)</code>
<code class="n">Docstring</code><code class="p">:</code> <code class="n">Return</code> <code class="n">the</code> <code class="n">square</code> <code class="n">of</code> <code class="n">a</code><code class="o">.</code>
<code class="n">File</code><code class="p">:</code>      <code class="o">&lt;</code><code class="n">ipython</code><code class="o">-</code><code class="nb">input</code><code class="o">-</code><code class="mi">6</code><code class="o">&gt;</code>
<code class="n">Type</code><code class="p">:</code>      <code class="n">function</code></pre>
<p>This quick access to documentation via docstrings is one reason you
should get in the habit of always adding such inline documentation to
the code you write.</p>
</div></section>
<section data-pdf-bookmark="Accessing Source Code with ??" data-type="sect2"><div class="sect2" id="ch_0101-help-and-documentation_accessing-source-code-with">
<h2>Accessing Source Code with ??</h2>
<p><a data-primary="?? (double question mark)" data-type="indexterm" id="idm45858819994416"/><a data-primary="double question mark (??)" data-type="indexterm" id="idm45858819993744"/><a data-primary="IPython" data-secondary="accessing source code with ??" data-type="indexterm" id="idm45858819993104"/><a data-primary="source code, accessing" data-type="indexterm" id="idm45858819992192"/>Because the Python language is so easily readable, another level of
insight can usually be gained by reading the source code of the object
you’re curious about. IPython and Jupyter provide a shortcut
to the source code with the double question mark (<code>??</code>):</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]:</code> square<code class="o">??</code>
<code class="n">Signature</code><code class="p">:</code> <code class="n">square</code><code class="p">(</code><code class="n">a</code><code class="p">)</code>
<code class="n">Source</code><code class="p">:</code>
<code class="k">def</code> <code class="nf">square</code><code class="p">(</code><code class="n">a</code><code class="p">):</code>
    <code class="sd">"""Return the square of a."""</code>
    <code class="k">return</code> <code class="n">a</code> <code class="o">**</code> <code class="mi">2</code>
<code class="n">File</code><code class="p">:</code>      <code class="o">&lt;</code><code class="n">ipython</code><code class="o">-</code><code class="nb">input</code><code class="o">-</code><code class="mi">6</code><code class="o">&gt;</code>
<code class="n">Type</code><code class="p">:</code>      <code class="n">function</code></pre>
<p>For simple functions like this, the double question mark can give quick
insight into the under-the-hood details.</p>
<p>If you play with this much, you’ll notice that sometimes the
<code>??</code> suffix doesn’t display any source code: this is
generally because the object in question is not implemented in Python,
but in C or some other compiled extension language. If this is the case,
the <code>??</code> suffix gives the same output as the <code>?</code> suffix.
You’ll find this particularly with many of
Python’s built-in objects and types, including the <code>len</code>
function from earlier:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">9</code><code class="p">]:</code> len<code class="o">??</code>
<code class="n">Signature</code><code class="p">:</code> <code class="nb">len</code><code class="p">(</code><code class="n">obj</code><code class="p">,</code> <code class="o">/</code><code class="p">)</code>
<code class="n">Docstring</code><code class="p">:</code> <code class="n">Return</code> <code class="n">the</code> <code class="n">number</code> <code class="n">of</code> <code class="n">items</code> <code class="ow">in</code> <code class="n">a</code> <code class="n">container</code><code class="o">.</code>
<code class="n">Type</code><code class="p">:</code>      <code class="n">builtin_function_or_method</code></pre>
<p>Using <code>?</code> and/or <code>??</code> is a powerful and quick way of finding information
about what any Python function or module does.</p>
</div></section>
<section data-pdf-bookmark="Exploring Modules with Tab Completion" data-type="sect2"><div class="sect2" id="ch_0101-help-and-documentation_exploring-modules-with-tab-completion">
<h2>Exploring Modules with Tab Completion</h2>
<p><a data-primary="IPython" data-secondary="exploring modules with tab completion" data-type="indexterm" id="ix_ch01-asciidoc0"/><a data-primary="modules, IPython" data-type="indexterm" id="ix_ch01-asciidoc1"/><a data-primary="tab completion" data-secondary="exploring IPython modules with" data-type="indexterm" id="ix_ch01-asciidoc2"/>Another useful interface is the use of the Tab key for autocompletion
and exploration of the contents of objects, modules, and namespaces. In
the examples that follow, I’ll use <code>&lt;TAB&gt;</code> to indicate when
the Tab key should be pressed.</p>
<section data-pdf-bookmark="Tab completion of object contents" data-type="sect3"><div class="sect3" id="ch_0101-help-and-documentation_tab-completion-of-object-contents">
<h3>Tab completion of object contents</h3>
<p><a data-primary="tab completion" data-secondary="of object contents" data-type="indexterm" id="idm45858819842832"/>Every Python object has various attributes and methods associated with
it. Like the <code>help</code> function mentioned earlier, Python has a built-in
<code>dir</code> function that returns a list of these, but the tab-completion
interface is much easier to use in practice. To see a list of all
available attributes of an object, you can type the name of the object
followed by a period (<code>.</code>) character and the Tab key:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">L</code><code class="o">.&lt;</code><code class="n">TAB</code><code class="o">&gt;</code>
            <code class="n">append</code><code class="p">()</code> <code class="n">count</code>    <code class="n">insert</code>   <code class="n">reverse</code>
            <code class="n">clear</code>    <code class="n">extend</code>   <code class="n">pop</code>      <code class="n">sort</code>
            <code class="n">copy</code>     <code class="n">index</code>    <code class="n">remove</code></pre>
<p>To narrow down the list, you can type the first character or several
characters of the name, and the Tab key will find the matching
attributes and methods:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">L</code><code class="o">.</code><code class="n">c</code><code class="o">&lt;</code><code class="n">TAB</code><code class="o">&gt;</code>
             <code class="n">clear</code><code class="p">()</code> <code class="n">count</code><code class="p">()</code>
             <code class="n">copy</code><code class="p">()</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">L</code><code class="o">.</code><code class="n">co</code><code class="o">&lt;</code><code class="n">TAB</code><code class="o">&gt;</code>
              <code class="n">copy</code><code class="p">()</code>  <code class="n">count</code><code class="p">()</code></pre>
<p>If there is only a single option, pressing the Tab key will complete the
line for you. For example, the following will instantly be replaced with
<code>L.count</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">L</code><code class="o">.</code><code class="n">cou</code><code class="o">&lt;</code><code class="n">TAB</code><code class="o">&gt;</code></pre>
<p>Though Python has no strictly enforced distinction between
public/external attributes and private/internal attributes, by
convention a preceding underscore is used to denote the latter. For
clarity, these private methods and special methods are omitted from the
list by default, but it’s possible to list them by
explicitly typing the underscore:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">L</code><code class="o">.</code><code class="n">_</code><code class="o">&lt;</code><code class="n">TAB</code><code class="o">&gt;</code>
           <code class="fm">__add__</code>             <code class="fm">__delattr__</code>     <code class="fm">__eq__</code>
           <code class="vm">__class__</code>           <code class="fm">__delitem__</code>     <code class="fm">__format__</code><code class="p">()</code>
           <code class="n">__class_getitem__</code><code class="p">()</code> <code class="fm">__dir__</code><code class="p">()</code>       <code class="fm">__ge__</code>            <code class="o">&gt;</code>
           <code class="fm">__contains__</code>        <code class="vm">__doc__</code>         <code class="fm">__getattribute__</code></pre>
<p>For brevity, I’ve only shown the first few columns of the
output. Most of these are Python’s special double-underscore
methods (often nicknamed “dunder” methods).</p>
</div></section>
<section data-pdf-bookmark="Tab completion when importing" data-type="sect3"><div class="sect3" id="ch_0101-help-and-documentation_tab-completion-when-importing">
<h3>Tab completion when importing</h3>
<p><a data-primary="importing, tab completion for" data-type="indexterm" id="idm45858819691280"/><a data-primary="tab completion" data-secondary="when importing" data-type="indexterm" id="idm45858819690608"/>Tab completion is also useful when importing objects from packages. Here
we’ll use it to find all possible imports in the <code>itertools</code>
package that start with <code>co</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="kn">from</code> <code class="nn">itertools</code> <code class="kn">import</code> <code class="n">co</code><code class="o">&lt;</code><code class="n">TAB</code><code class="o">&gt;</code>
         <code class="n">combinations</code><code class="p">()</code>                  <code class="n">compress</code><code class="p">()</code>
         <code class="n">combinations_with_replacement</code><code class="p">()</code> <code class="n">count</code><code class="p">()</code></pre>
<p>Similarly, you can use tab-completion to see which imports are available
on your system (this will change depending on which third-party scripts
and modules are visible to your Python session):</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="kn">import</code> <code class="o">&lt;</code><code class="n">TAB</code><code class="o">&gt;</code>
            <code class="n">abc</code>                 <code class="n">anyio</code>
            <code class="n">activate_this</code>       <code class="n">appdirs</code>
            <code class="n">aifc</code>                <code class="n">appnope</code>        <code class="o">&gt;</code>
            <code class="n">antigravity</code>         <code class="n">argon2</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">h</code><code class="o">&lt;</code><code class="n">TAB</code><code class="o">&gt;</code>
            <code class="n">hashlib</code> <code class="n">html</code>
            <code class="n">heapq</code>   <code class="n">http</code>
            <code class="n">hmac</code></pre>
</div></section>
<section data-pdf-bookmark="Beyond tab completion: Wildcard matching" data-type="sect3"><div class="sect3" id="ch_0101-help-and-documentation_beyond-tab-completion-wildcard-matching">
<h3>Beyond tab completion: Wildcard matching</h3>
<p><a data-primary="* (asterisk)" data-type="indexterm" id="idm45858819591232"/><a data-primary="asterisk (*)" data-type="indexterm" id="idm45858819590560"/><a data-primary="IPython" data-secondary="wildcard matching" data-type="indexterm" id="idm45858819589888"/><a data-primary="wildcard matching" data-type="indexterm" id="idm45858819588944"/>Tab completion is useful if you know the first few characters of the
name of the object or attribute you’re looking for, but is
little help if you’d like to match characters in the middle
or at the end of the name. For this use case, IPython and Jupyter
provide a means of wildcard matching for names using the <code>*</code> character.</p>
<p>For example, we can use this to list every object in the namespace whose
name ends with <code>Warning</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> *Warning<code class="o">?</code>
<code class="ne">BytesWarning</code>                  <code class="ne">RuntimeWarning</code>
<code class="ne">DeprecationWarning</code>            <code class="ne">SyntaxWarning</code>
<code class="ne">FutureWarning</code>                 <code class="ne">UnicodeWarning</code>
<code class="ne">ImportWarning</code>                 <code class="ne">UserWarning</code>
<code class="ne">PendingDeprecationWarning</code>     <code class="ne">Warning</code>
<code class="ne">ResourceWarning</code></pre>
<p>Notice that the <code>*</code> character matches any string, including the empty
string.</p>
<p>Similarly, suppose we are looking for a string method that contains the
word <code>find</code> somewhere in its name. We can search for it this way:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">11</code><code class="p">]:</code> str.*find*<code class="o">?</code>
<code class="nb">str</code><code class="o">.</code><code class="n">find</code>
<code class="nb">str</code><code class="o">.</code><code class="n">rfind</code></pre>
<p>I find this type of flexible wildcard search can be useful for finding a
particular command when getting to know a new package or reacquainting
myself with a familiar one<a data-startref="ix_ch01-asciidoc2" data-type="indexterm" id="idm45858819515760"/><a data-startref="ix_ch01-asciidoc1" data-type="indexterm" id="idm45858819515152"/><a data-startref="ix_ch01-asciidoc0" data-type="indexterm" id="idm45858819514544"/>.</p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Keyboard Shortcuts in the IPython Shell" data-type="sect1"><div class="sect1" id="section-0102-shell-keyboard-shortcuts">
<h1>Keyboard Shortcuts in the IPython Shell</h1>
<p><a data-primary="IPython" data-secondary="keyboard shortcuts in shell" data-type="indexterm" id="ix_ch01-asciidoc3"/><a data-primary="keyboard shortcuts, IPython shell" data-type="indexterm" id="ix_ch01-asciidoc4"/><a data-primary="shell, IPython" data-secondary="keyboard shortcuts in" data-type="indexterm" id="ix_ch01-asciidoc5"/><a data-primary="shortcuts" data-secondary="IPython shell" data-type="indexterm" id="ix_ch01-asciidoc6"/>If you spend any amount of time on a computer, you’ve
probably found a use for keyboard shortcuts in your workflow. Most
familiar perhaps are Cmd-c and Cmd-v (or Ctrl-c and Ctrl-v), used for
copying and pasting in a wide variety of programs and systems. Power
users tend to go even further: popular text editors like Emacs, Vim, and
others provide users an incredible range of operations through intricate
combinations of keystrokes.</p>
<p>The IPython shell doesn’t go this far, but does provide a
number of keyboard shortcuts for fast navigation while typing commands.
While some of these shortcuts do work in the browser-based notebooks,
this section is primarily about shortcuts in the IPython shell.</p>
<p>Once you get accustomed to these, they can be very useful for quickly
performing certain commands without moving your hands from the “home”
keyboard position. If you’re an Emacs user or if you have
experience with Linux-style shells, the following will be very familiar.
I’ll group these shortcuts into a few categories:
<em>navigation shortcuts</em>, <em>text entry shortcuts</em>, <em>command history
shortcuts</em>, and <em>miscellaneous shortcuts</em>.</p>
<section data-pdf-bookmark="Navigation Shortcuts" data-type="sect2"><div class="sect2" id="ch_0102-shell-keyboard-shortcuts_navigation-shortcuts">
<h2>Navigation Shortcuts</h2>
<p><a data-primary="keyboard shortcuts, IPython shell" data-secondary="navigation" data-type="indexterm" id="idm45858819465952"/><a data-primary="navigation shortcuts" data-type="indexterm" id="idm45858819465008"/><a data-primary="shortcuts" data-secondary="navigation" data-type="indexterm" id="idm45858819464336"/>While the use of the left and right arrow keys to move backward and
forward in the line is quite obvious, there are other options that
don’t require moving your hands from the “home” keyboard
position:</p>
<table>
<thead>
<tr>
<th>Keystroke</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Ctrl-a</p></td>
<td><p>Move cursor to beginning of line</p></td>
</tr>
<tr>
<td><p>Ctrl-e</p></td>
<td><p>Move cursor to end of the line</p></td>
</tr>
<tr>
<td><p>Ctrl-b or the left arrow key</p></td>
<td><p>Move cursor back one character</p></td>
</tr>
<tr>
<td><p>Ctrl-f or the right arrow key</p></td>
<td><p>Move cursor forward one character</p></td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="Text Entry Shortcuts" data-type="sect2"><div class="sect2" id="ch_0102-shell-keyboard-shortcuts_text-entry-shortcuts">
<h2>Text Entry Shortcuts</h2>
<p><a data-primary="keyboard shortcuts, IPython shell" data-secondary="text entry" data-type="indexterm" id="idm45858819452528"/><a data-primary="shortcuts" data-secondary="text entry" data-type="indexterm" id="idm45858819451488"/><a data-primary="text entry shortcuts" data-type="indexterm" id="idm45858819450544"/>While everyone is familiar with using the Backspace key to delete the
previous character, reaching for the key often requires some minor
finger gymnastics, and it only deletes a single character at a time. In
IPython there are several shortcuts for removing some portion of the
text you’re typing; the most immediately useful of these are
the commands to delete entire lines of text. You’ll know
these have become second-nature if you find yourself using a combination
of Ctrl-b and Ctrl-d instead of reaching for Backspace to delete the
previous character!</p>
<table>
<thead>
<tr>
<th>Keystroke</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Backspace key</p></td>
<td><p>Delete previous character in line</p></td>
</tr>
<tr>
<td><p>Ctrl-d</p></td>
<td><p>Delete next character in line</p></td>
</tr>
<tr>
<td><p>Ctrl-k</p></td>
<td><p>Cut text from cursor to end of line</p></td>
</tr>
<tr>
<td><p>Ctrl-u</p></td>
<td><p>Cut text from beginning of line to cursor</p></td>
</tr>
<tr>
<td><p>Ctrl-y</p></td>
<td><p>Yank (i.e., paste) text that was previously cut</p></td>
</tr>
<tr>
<td><p>Ctrl-t</p></td>
<td><p>Transpose (i.e., switch) previous two characters</p></td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="Command History Shortcuts" data-type="sect2"><div class="sect2" id="ch_0102-shell-keyboard-shortcuts_command-history-shortcuts">
<h2>Command History Shortcuts</h2>
<p><a data-primary="command history shortcuts" data-type="indexterm" id="idm45858819435472"/><a data-primary="keyboard shortcuts, IPython shell" data-secondary="command history" data-type="indexterm" id="idm45858819434704"/><a data-primary="shortcuts" data-secondary="command history" data-type="indexterm" id="idm45858819433744"/>Perhaps the most impactful shortcuts discussed here are the ones IPython
provides for navigating the command history. This command history goes
beyond your current IPython session: your entire command history is
stored in a SQLite database in your IPython profile directory.</p>
<p class="pagebreak-before less_space">The most
straightforward way to access previous commands is by using the up and
down arrow keys to step through the history, but other options exist as
well:</p>
<table>
<thead>
<tr>
<th>Keystroke</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Ctrl-p (or the up arrow key)</p></td>
<td><p>Access previous command in history</p></td>
</tr>
<tr>
<td><p>Ctrl-n (or the down arrow key)</p></td>
<td><p>Access next command in history</p></td>
</tr>
<tr>
<td><p>Ctrl-r</p></td>
<td><p>Reverse-search through command history</p></td>
</tr>
</tbody>
</table>
<p>The reverse-search option can be particularly useful. Recall that
earlier we defined a function called <code>square</code>. Let’s
reverse-search our Python history from a new IPython shell and find this
definition again. When you press Ctrl-r in the IPython terminal,
you’ll see the following prompt:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code>
<code class="p">(</code><code class="n">reverse</code><code class="o">-</code><code class="n">i</code><code class="o">-</code><code class="n">search</code><code class="p">)</code><code class="err">`</code><code class="s1">':</code></pre>
<p>If you start typing characters at this prompt, IPython will autofill the
most recent command, if any, that matches those characters:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code>
<code class="p">(</code><code class="n">reverse</code><code class="o">-</code><code class="n">i</code><code class="o">-</code><code class="n">search</code><code class="p">)</code><code class="err">`</code><code class="n">sqa</code><code class="s1">': square??</code></pre>
<p>At any point, you can add more characters to refine the search, or press
Ctrl-r again to search further for another command that matches the
query. If you followed along earlier, pressing Ctrl-r twice more gives:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code>
<code class="p">(</code><code class="n">reverse</code><code class="o">-</code><code class="n">i</code><code class="o">-</code><code class="n">search</code><code class="p">)</code><code class="err">`</code><code class="n">sqa</code><code class="s1">': def square(a):</code>
    <code class="sd">"""Return the square of a"""</code>
    <code class="k">return</code> <code class="n">a</code> <code class="o">**</code> <code class="mi">2</code></pre>
<p>Once you have found the command you’re looking for, press
Return and the search will end. You can then use the retrieved command
and carry on with your session:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="k">def</code> <code class="nf">square</code><code class="p">(</code><code class="n">a</code><code class="p">):</code>
    <code class="sd">"""Return the square of a"""</code>
    <code class="k">return</code> <code class="n">a</code> <code class="o">**</code> <code class="mi">2</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="n">square</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="mi">4</code></pre>
<p>Note that you can use Ctrl-p/Ctrl-n or the up/down arrow keys to search
through your history in a similar way, but only by matching characters
at the beginning of the line. That is, if you type <strong><code>def</code></strong> and then
press Ctrl-p, it will find the most recent command (if any) in your
history that begins with the characters <code>def</code>.</p>
</div></section>
<section class="pagebreak-before less_space" data-pdf-bookmark="Miscellaneous Shortcuts" data-type="sect2"><div class="sect2" id="ch_0102-shell-keyboard-shortcuts_miscellaneous-shortcuts">
<h2>Miscellaneous Shortcuts</h2>
<p>Finally, there are a few miscellaneous shortcuts that don’t
fit into any of the preceding categories, but are nevertheless useful to
know:</p>
<table>
<thead>
<tr>
<th>Keystroke</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Ctrl-l</p></td>
<td><p>Clear terminal screen</p></td>
</tr>
<tr>
<td><p>Ctrl-c</p></td>
<td><p>Interrupt current Python command</p></td>
</tr>
<tr>
<td><p>Ctrl-d</p></td>
<td><p>Exit IPython session</p></td>
</tr>
</tbody>
</table>
<p>The Ctrl-c shortcut in particular can be useful when you inadvertently
start a very long-running job.</p>
<p>While some of the shortcuts discussed here may seem a bit obscure at
first, they quickly become automatic with practice. Once you develop
that muscle memory, I suspect you will even find yourself wishing they
were available in other contexts.<a data-startref="ix_ch01-asciidoc6" data-type="indexterm" id="idm45858813236880"/><a data-startref="ix_ch01-asciidoc5" data-type="indexterm" id="idm45858813235792"/><a data-startref="ix_ch01-asciidoc4" data-type="indexterm" id="idm45858813235120"/><a data-startref="ix_ch01-asciidoc3" data-type="indexterm" id="idm45858813234448"/><a data-primary="APIs" data-see="Estimator API" data-type="indexterm" id="idm45858813233776"/><a data-primary="bandwidth" data-see="kernel bandwidth" data-type="indexterm" id="idm45858813232832"/><a data-primary="data" data-secondary="missing" data-see="missing data" data-type="indexterm" id="idm45858813231888"/><a data-primary="density estimator" data-secondary="KDE" data-see="kernel density estimation" data-type="indexterm" id="idm45858813230672"/><a data-primary="digits, recognition of" data-see="optical character recognition" data-type="indexterm" id="idm45858813203680"/><a data-primary="errors" data-see="uncertainties, visualizing" data-type="indexterm" id="idm45858813202832"/><a data-primary="GMMs" data-see="Gaussian mixture models" data-type="indexterm" id="idm45858813201984"/><a data-primary="handwritten digits, recognition of" data-see="optical character recognition" data-type="indexterm" id="idm45858813201136"/><a data-primary="HOG" data-see="Histogram of Oriented Gradients" data-type="indexterm" id="idm45858813200288"/><a data-primary="indexing" data-secondary="fancy" data-see="fancy indexing" data-type="indexterm" id="idm45858813199440"/><a data-primary="indexing" data-secondary="hierarchical" data-see="hierarchical indexing" data-type="indexterm" id="idm45858813198352"/><a data-primary="IPython" data-secondary="notebook" data-see="Jupyter notebook" data-type="indexterm" id="idm45858813197264"/><a data-primary="manifold learning" data-secondary="k-means clustering" data-see="k-means clustering" data-type="indexterm" id="idm45858813196176"/><a data-primary="MDS" data-see="multidimensional scaling" data-type="indexterm" id="idm45858813195088"/><a data-primary="multi-indexing" data-see="hierarchical indexing" data-type="indexterm" id="idm45858813194240"/><a data-primary="PCA" data-see="principal component analysis" data-type="indexterm" id="idm45858813193392"/><a data-primary="scatter plots" data-see="simple scatter plots" data-type="indexterm" id="idm45858813192544"/><a data-primary="string operations" data-see="vectorized string operations" data-type="indexterm" id="idm45858813191696"/><a data-primary="ufuncs" data-see="universal functions" data-type="indexterm" id="idm45858813190848"/><a data-primary="unsupervised learning" data-secondary="PCA" data-see="principal component analysis" data-type="indexterm" id="idm45858813190000"/><a data-primary="validation" data-see="model validation" data-type="indexterm" id="idm45858813188912"/><a data-primary="visualization software" data-see="Matplotlib; Seaborn" data-type="indexterm" id="idm45858813188064"/></p>
</div></section>
</div></section>
</div></section></div></body></html>