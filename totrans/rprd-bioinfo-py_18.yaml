- en: 'Chapter 16\. FASTX grep: Creating a Utility Program to Select Sequences'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章。FASTX grep：创建一个选择序列的实用程序
- en: A colleague asked me once to find all the RNA sequences in a FASTQ file that
    had a description or name containing the string *LSU* (for *long subunit* RNA).
    Although it’s possible to solve this problem for FASTQ files by using the `grep`
    program^([1](ch16.html#idm45963628251688)) to find all the lines of a file matching
    some pattern, writing a solution in Python allows you to create a program that
    could be expanded to handle other formats, like FASTA, as well as to select records
    based on other criteria, such as length or GC content. Additionally, you can add
    options to change the output sequence format and introduce conveniences for the
    user like guessing the input file’s format based on the file extension.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有一次，一个同事让我找出FASTQ文件中所有具有包含字符串*LSU*（表示*长亚单位*RNA）的描述或名称的RNA序列。虽然可以通过使用`grep`程序在FASTQ文件中找到与某些模式匹配的所有行来解决此问题^([1](ch16.html#idm45963628251688))，但是使用Python编写解决方案可以创建一个可以扩展到处理其他格式（如FASTA）的程序，并且可以根据其他标准（如长度或GC含量）选择记录。此外，您还可以添加选项以更改输出序列格式，并为用户提供方便，例如根据文件扩展名猜测输入文件的格式。
- en: 'In this chapter, you will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学到：
- en: About the structure of a FASTQ file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于FASTQ文件的结构
- en: How to perform a case-insensitive regular expression match
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何执行不区分大小写的正则表达式匹配
- en: About DWIM (Do What I Mean) and DRY (Don’t Repeat Yourself) ideas in code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关在代码中实现DWIM（做我想要的）和DRY（不要重复自己）思想
- en: How to use `and` and `or` operations to reduce Boolean values and bits
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`and`和`or`操作来减少布尔值和位
- en: Finding Lines in a File Using grep
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用grep在文件中查找行
- en: 'The `grep` program can find all the lines in a file matching a given pattern.
    If I search for *LSU* in one of the FASTQ files, it finds two header lines containing
    this pattern:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`程序可以找到文件中与给定模式匹配的所有行。如果我在FASTQ文件中搜索*LSU*，它会找到包含此模式的两个标题行：'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If the goal were only to find how many sequences contain this string, I could
    pipe this into `wc` (word count) to count the lines using the `-l` option:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标只是查找多少序列包含此字符串，我可以将其管道传递到`wc`（单词计数）以使用`-l`选项计算行数：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since my goal is to extract the sequence records where the header contains the
    substring *LSU*, I have to do a little more work. As long as the input files are
    in FASTQ format, I can still use `grep`, but this requires a better understanding
    of the format.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我的目标是提取头部包含子字符串*LSU*的序列记录，我必须做更多的工作。只要输入文件是FASTQ格式，我仍然可以使用`grep`，但这需要更好地理解格式。
- en: The Structure of a FASTQ Record
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FASTQ记录的结构
- en: The FASTQ sequence format is a common way to receive sequence data from a sequencer
    as it includes both the base calls and the quality scores for each base. That
    is, sequencers generally report both a base and a measure of certainty that the
    base is correct. Some sequencing technologies have trouble, for instance, with
    homopolymer runs, like a poly(*A*) run of many *A*s where the sequencer may be
    unable to count the correct number. Many sequencers also lose confidence in base
    calls as the reads grow longer. Quality scores are an important means for rejecting
    or truncating low-quality reads.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: FASTQ序列格式是从测序仪接收序列数据的常见方式，因为它包括每个碱基的碱基调用和质量分数。也就是说，测序仪通常报告一个碱基及其正确的测量确定性。例如，一些测序技术可能在同源聚合物串中遇到麻烦，比如许多*A*的聚(*A*)串，其中测序仪可能无法正确计数。随着读数变长，许多测序仪也会对碱基调用失去信心。质量分数是拒绝或截断低质量读数的重要手段。
- en: Depending on the sequencer, some bases can be hard to distinguish, and the ambiguity
    may be reported using IUPAC codes I describe in [Chapter 1](ch01.html#ch01), such
    as *R* for *A* or *G* or *N* for any base.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据测序仪的不同，有些碱基可能很难区分，模糊性可能会使用我在[第1章](ch01.html#ch01)中描述的IUPAC代码来报告，例如用*R*表示*A*或*G*，或者用*N*表示任意碱基。
- en: The FASTQ format is somewhat similar to the FASTA format used in many of the
    problems in the Rosalind challenges. As a reminder, FASTA records start with a
    `>` symbol followed by a header line that identifies the sequence and may contain
    metadata. The sequence itself follows, which may be one (possibly long) line of
    text or might be split over multiple lines. In contrast, FASTQ records must always
    be exactly four lines, as shown in [Figure 16-1](#fig_16.1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: FASTQ格式在许多Rosalind挑战中使用的FASTA格式有些相似。作为提醒，FASTA记录以`>`符号开头，后跟标识序列并可能包含元数据的标题行。然后是序列本身，可能是一行（可能很长）文本，也可能是分成多行。相比之下，FASTQ记录必须始终是确切的四行，如[图16-1](#fig_16.1)所示。
- en: '![mpfb 1601](assets/mpfb_1601.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 1601](assets/mpfb_1601.png)'
- en: Figure 16-1\. The elements of a FASTQ record—although the long lines are wrapped
    in this display, the actual record contains exactly four lines
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-1\. FASTQ 记录的元素 —— 尽管此显示中的长行已换行，但实际记录包含四行。
- en: 'Let’s take a closer look at the contents of this figure:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看一下这个图的内容：
- en: The first line starts with the `@` symbol and contains the header information.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一行以 `@` 符号开头，并包含头部信息。
- en: The second line contains the sequence with no line breaks.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二行包含没有换行的序列。
- en: The third line begins with the `+` symbol. Often it will be only this symbol,
    but sometimes the header information may be repeated.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三行以 `+` 符号开头。通常只有这个符号，但有时头部信息可能会重复。
- en: The fourth line contains the quality scores for each base in the sequence and
    also has no line breaks.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四行包含序列中每个碱基的质量分数，且没有换行。
- en: The sequence ID is all characters up to the first space.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 序列 ID 是直到第一个空格的所有字符。
- en: Additional metadata may follow the ID and is included in the description.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 附加元数据可能跟随 ID 并包含在描述中。
- en: Each base in the sequence has a partner in the quality line representing the
    confidence that this base is correct.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 序列中的每个碱基在质量行中都有一个对应的伙伴，表示此碱基正确的置信度。
- en: A FASTQ header has the same structure as the header in a FASTA record, with
    the exception that it starts with the `@` sign instead of the `>`. The sequence
    identifier is usually all the characters after `@` up to the first space. The
    second line containing the sequence cannot contain any line breaks, and each base
    in the sequence has a corresponding quality value in the fourth line. The quality
    scores on the fourth line use the ASCII values of the characters to encode the
    certainty of the base call. These scores are represented using the printable characters
    from the ASCII table first introduced in [Chapter 3](ch03.html#ch03).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: FASTQ 头部具有与 FASTA 记录中头部相同的结构，唯一的区别是它以 `@` 符号而不是 `>` 符号开头。序列标识符通常是从 `@` 到第一个空格之间的所有字符。包含序列的第二行不能包含任何换行，序列中的每个碱基都有对应的质量值在第四行中。第四行上的质量分数使用字符的
    ASCII 值来编码基本调用的确定性。这些分数首先使用 ASCII 表中的可打印字符，最初是在 [第 3 章](ch03.html#ch03) 中介绍的。
- en: 'The first 32 values in the ASCII table are unprintable control characters and
    the space. The printable characters start at 33, with punctuation followed by
    numbers. The first letter, *A*, is not found until 65, and uppercase characters
    precede lowercase. The following is the output from the `asciitbl.py` program
    included in the repository that shows the ordinal values of the 128 values from
    the ASCII table:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII 表中的前 32 个值是不可打印的控制字符和空格。可打印字符从第 33 个开始，标点符号后跟数字。第一个字母 *A* 直到 65 才出现，大写字符在小写字符之前。以下是存储库中包含的
    `asciitbl.py` 程序输出的 ASCII 表中 128 个值的序号值：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Look at the quality line of the FASTQ record in [Figure 16-1](#fig_16.1) and
    see how the characters change from higher values like uppercase letters at the
    beginning to lower values like punctuation and numbers toward the end. Note that
    the `@` and `+` symbols on the fourth line represent possible quality values and
    so would not be metacharacters denoting the beginning of a record or the separator
    line. For this reason, FASTQ records can’t use newlines to break the sequence
    (like in FASTA records) or quality lines: the symbols `@` and `+` might end up
    as the first character on a line, making it impossible to find the start of a
    record. Combine this with the utterly useless third line that often consists of
    a single `+` symbol, and which sometimes needlessly recapitulates all the header
    information, and you see why biologists should never be allowed to define a file
    format.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [图 16-1](#fig_16.1) 中 FASTQ 记录的质量行，看看字符是如何从开始的大写字母到末尾的标点符号和数字进行变化的。请注意，第四行上的
    `@` 和 `+` 符号表示可能的质量值，因此它们不是表示记录开头或分隔线的元字符。因此，FASTQ 记录不能使用换行符来断开序列（如 FASTA 记录）或质量行：符号
    `@` 和 `+` 可能会成为行中的第一个字符，使得无法找到记录的起始位置。结合这一点与通常由一个单独的 `+` 符号组成的完全无用的第三行，有时无端地重述了所有的头部信息，你就会明白为什么不应该让生物学家定义文件格式。
- en: There are multiple encoding standards using various ranges to represent the
    quality scores.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种使用不同范围表示质量分数的编码标准。
- en: 'Because FASTQ records must be four lines long, I can use the `-A|--after-context`
    option for `grep` to specify the number of lines of trailing context after each
    match:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This works as long as the substring of interest occurs only in the header, which
    is the first line of a record. If `grep` managed to find a match in any other
    line in the record, it would print that line plus the following three, yielding
    unusable garbage. Given that I would like to control exactly which parts of the
    record to search and the fact that the input files might be in FASTQ, FASTA, or
    any number of other formats, it quickly becomes evident that `grep` won’t take
    me very far.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, I’ll show you how my solution works, and then I’ll challenge you to
    implement your version. All the code and tests for this exercise are in the *16_fastx_grep*
    directory of the repository. Start by changing into this directory and copying
    the solution to `fastx_grep.py`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `grep` usage shows that it accepts two positional arguments, a pattern
    and one or more files:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Request help from the `fastx_grep.py` program and see that it has a similar
    interface that requires a pattern and one or more input files. Additionally, this
    program can parse different input file formats, produce various output formats,
    write the output to a file, and perform case-insensitive matching:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-1)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The regular expression (pattern) is the first positional argument.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-2)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: One or more positional file arguments are required second.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-3)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: The input file format of the sequences, either *fasta* or *fastq*. The default
    is to guess from the file extension.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-4)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The output file format, one of *fasta*, *fastq*, or *fasta-2line*. The default
    is to use the same as the input file.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-5)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The output filename; the default is `STDOUT`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-6)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Whether to perform case-insensitive matches; the default is `False`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'This program has a more complicated set of arguments than many of the programs
    from [Part I](part01.html#part_one). As usual, I like to use a `NamedTuple` to
    model the options:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-1)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The regular expression to use.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-2)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-2)'
- en: One or more input files.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个或多个输入文件。
- en: '[![3](assets/3.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-3)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-3)'
- en: The format of the input file, such as FASTA or FASTQ.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文件的格式，例如FASTA或FASTQ。
- en: '[![4](assets/4.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-4)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-4)'
- en: The format of the output file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文件的格式。
- en: '[![5](assets/5.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-5)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-5)'
- en: The name of the output file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文件的名称。
- en: '[![6](assets/6.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-6)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-6)'
- en: Whether to perform case-insensitive searching.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 是否执行不区分大小写的搜索。
- en: 'Here is how I define the program’s parameters:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我定义程序参数的方法：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-1)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-1)'
- en: The pattern will be a string.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 模式将是一个字符串。
- en: '[![2](assets/2.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-2)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-2)'
- en: The inputs must be readable text files.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 输入必须是可读的文本文件。
- en: '[![3](assets/3.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-3)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-3)'
- en: Use `choices` to constrain the input values. The default will be guessed from
    the input file extension.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`choices`来约束输入值。默认值将从输入文件扩展名中猜测。
- en: '[![4](assets/4.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-4)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-4)'
- en: Constrain values using `choices`; default to using the input format. The *fasta-2line*
    option will not break long sequences over multiple lines and so will use only
    two lines per record.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`choices`来约束值；默认使用输入格式。*fasta-2line*选项不会将长序列分割成多行，因此每条记录只使用两行。
- en: '[![5](assets/5.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-5)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-5)'
- en: The output file will be a writable text file. The default is `STDOUT`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文件将是可写的文本文件。默认为`STDOUT`。
- en: '[![6](assets/6.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-6)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-6)'
- en: A flag to indicate case-insensitive searching. The default is `False`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个标志来指示不区分大小写的搜索。默认值为`False`。
- en: 'If you run the following command to search for *LSU* in the *lsu.fq* test file,
    you should see eight lines of output representing two FASTQ records:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行以下命令在*lsu.fq*测试文件中搜索*LSU*，您应该看到八行输出，表示两个FASTQ记录：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you search for lowercase *lsu*, however, you should see no output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您搜索小写的*lsu*，您应该看不到输出：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use the `-i|--insensitive` flag to perform a case-insensitive search:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-i|--insensitive`标志执行不区分大小写的搜索：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can use the `-o|--outfile` option to write the results to a file instead
    of `STDOUT`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`-o|--outfile`选项将结果写入文件，而不是`STDOUT`：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you look at the *out.fq* file, you’ll see it’s in FASTQ format just like
    the original input. You can use the `-O|--outfmt` option to change this to something
    like FASTA and look at the output file to verify the format:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看*out.fq*文件，您会看到它的格式与原始输入一样是FASTQ格式。您可以使用`-O|--outfmt`选项将其更改为类似FASTA的格式，并查看输出文件以验证格式：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Try using the *fasta-2line* output format to see how the long sequences are
    not broken over multiple lines. Note that the program also works on FASTA input
    without my having to indicate the file format because it is guessed from the *.fa*
    file extension:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用*fasta-2line*输出格式，看看长序列如何不会被分割成多行。请注意，该程序也可以处理FASTA输入，无需我指示文件格式，因为它是从*.fa*文件扩展名中猜测出来的：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run **`pytest -v`** to see all the tests for the program, which include guessing
    the file format, handling empty files, searching lowercase and uppercase input
    both with and without case-sensitivity, writing output files, and writing different
    output formats. When you think you understand all the options your program must
    handle, start over:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 运行**`pytest -v`**以查看程序的所有测试，这些测试包括猜测文件格式、处理空文件、搜索小写和大写输入，同时包括大小写敏感和不敏感的情况、写入输出文件以及写入不同的输出格式。当您认为自己了解了程序必须处理的所有选项时，请重新开始：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Guessing the File Format
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 猜测文件格式
- en: 'If you look at *out.fa* created in the preceding section, you’ll see it’s in
    FASTA format, matching the input format, but I never indicated the input file
    format. The program intelligently checks the file extension of the input file
    and guesses at the format using the assumptions in [Table 16-1](#table_16.1).
    Similarly, if no output format is specified, then the input file format is assumed
    to be the desired output format. This is an example of the *DWIM* principle in
    software development: Do What I Mean.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看前一节中创建的*out.fa*，您会发现它是以FASTA格式保存的，与输入格式匹配，但我从未指定过输入文件格式。程序智能地检查输入文件的文件扩展名，并根据表16-1中的假设猜测格式。类似地，如果没有指定输出格式，则假定输入文件格式为所需的输出格式。这是软件开发中*DWIM*原则的一个例子：做我所想要的。
- en: Table 16-1\. Common file extensions for FASTA/Q files
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 表16-1\. FASTA/Q文件的常见文件扩展名
- en: '| Extension | Format |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| Extension | Format |'
- en: '| --- | --- |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *.fasta* | FASTA |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| *.fasta* | FASTA |'
- en: '| *.fa* | FASTA |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| *.fa* | FASTA |'
- en: '| *.fna* | FASTA (nucleotides) |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| *.fna* | FASTA（核苷酸） |'
- en: '| *.faa* | FASTA (amino acids) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| *.faa* | FASTA（氨基酸） |'
- en: '| *.fq* | FASTQ |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| *.fq* | FASTQ |'
- en: '| *.fastq* | FASTQ |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| *.fastq* | FASTQ |'
- en: 'Your program will similarly need to guess the format of the input files. I
    created a `guess_format()` function that takes the name of a file and returns
    a string of either `fasta` or `fastq`. Here is a stub for the function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您的程序同样需要猜测输入文件的格式。我创建了一个`guess_format()`函数，它接受文件名并返回一个字符串，要么是`fasta`，要么是`fastq`。这是函数的一个桩代码：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is the test I wrote. After defining the arguments, I would recommend you
    start with this function. Do not proceed until your code passes this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我写的测试。在定义了参数之后，我建议您从这个函数开始。在您的代码通过这个测试之前，请不要继续：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It might help to sketch out how the program should work:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有助于勾勒出程序应该如何工作：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For instance, I can run the program on three input files by using the shell
    glob `*.f[aq]` to indicate all the files with an extension starting with the letter
    *f* and followed by either *a* or *q*:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我可以通过使用shell glob `*.f[aq]`在三个输入文件上运行程序，以指示所有以字母*f*开头并以字母*a*或*q*结尾的文件：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This should write four sequences to the file *out.fa*:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该向文件*out.fa*写入四个序列：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is a complex program that may take you quite a while to finish. There is
    value in your struggle, so just keep writing and running the tests, which you
    should also read to understand how to challenge your program.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个复杂的程序，可能需要您相当长的时间才能完成。在你的挣扎中有价值，所以只需继续编写并运行测试，你还应该阅读以了解如何挑战你的程序。
- en: Solution
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: In my experience, this is a realistically complicated program that captures
    many patterns I write often. It starts by validating and processing some number
    of input files. I’m a truly lazy programmer^([2](ch16.html#idm45963628022792))
    who always wants to give as little information as possible to my programs, so
    I’m happy to write a little code to guess the file formats for me.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，这是一个真实复杂的程序，捕捉了我经常编写的许多模式。它开始验证和处理一些输入文件。我是一个真正懒惰的程序员^([2](ch16.html#idm45963628022792))，总是希望给我的程序尽可能少的信息，所以我很高兴写一点代码来猜测文件格式。
- en: Guessing the File Format from the File Extension
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从文件扩展名猜测文件格式
- en: 'I’ll start with the function for guessing a file’s format from the file extension:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从猜测文件格式的函数开始：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](assets/1.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO4-1)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO4-1)'
- en: Use the `os.path.splitext()` function to get the file extension and remove the
    leading dot.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`os.path.splitext()`函数获取文件扩展名并去除前导点。
- en: '[![2](assets/2.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO4-2)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO4-2)'
- en: Return the string `fasta` if the extension matches one of the patterns for FASTA
    files from [Table 16-1](#table_16.1), `fastq` if it matches a FASTQ pattern, and
    the empty string otherwise.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that `os.path.splitext()` will return both the root of the filename
    and the extension as a 2-tuple:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Since I’m only interested in the second part, I can use the `_` to assign the
    first member of the tuple to a throwaway:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Instead, I chose to index the tuple to select only the extension:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Since I don’t want the leading dot, I could use a string slice to remove this,
    but this looks cryptic and unreadable to me:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Instead, I’d prefer to use the `re.sub()` function I first introduced in [Chapter 2](ch02.html#ch02).
    The pattern I’m looking for is a literal dot at the beginning of the string. The
    caret `^` indicates the start of the string, and the `.` is a metacharacter that
    means one of anything. To show that I want a literal dot, I must either place
    a backslash in front of it like `^\.` or place it inside a character class as
    in `^[.]`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](assets/1.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO5-1)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Use `re.sub()` to remove a literal dot at the beginning of the file extension.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in [Table 16-1](#table_16.1), there are four common extensions for
    FASTA files which I can represent using one compact regular expression. Recall
    that there are two functions in the `re` module for searching:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '`re.match()` finds a match from the beginning of a string.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`re.search()` finds a match anywhere inside a string.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, I’m using the `re.match()` function to ensure that the pattern
    (the first argument) is found at the beginning of the extension (the second argument):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To get the same results from `re.search()`, I would need to use a caret at
    the beginning to anchor the pattern to the start of the string:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[Figure 16-2](#fig_16.2) describes each part of the regular expression.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1602](assets/mpfb_1602.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: Figure 16-2\. A regular expression for matching the four FASTA patterns
  id: totrans-148
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It may help to see this drawn as a finite state machine diagram, as shown in
    [Figure 16-3](#fig_16.3).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1603](assets/mpfb_1603.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: Figure 16-3\. A finite state machine diagram for matching the four FASTA patterns
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As there are only two patterns for FASTQ files, the pattern is somewhat simpler:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[Figure 16-4](#fig_16.4) explains this regular expression.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1604](assets/mpfb_1604.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: Figure 16-4\. A regular expression for matching the two FASTQ patterns
  id: totrans-156
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 16-5](#fig_16.5) shows the same idea expressed as a finite state machine.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1605](assets/mpfb_1605.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: Figure 16-5\. A finite state machine diagram for matching the two FASTQ patterns
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I Love It When a Plan Comes Together
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is how I wrote `main()` using the structure I introduced in the first
    part of the chapter:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](assets/1.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-1)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Compile a regular expression to find the given pattern.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 编译正则表达式以找到给定的模式。
- en: '[![2](assets/2.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-2)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-2)'
- en: Iterate through the input files.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历输入文件。
- en: '[![3](assets/3.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-3)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-3)'
- en: Use the input format or guess it from the filename.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用输入格式或从文件名猜测它。
- en: '[![4](assets/4.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-4)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-4)'
- en: Exit with an error if there is no input file format.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有输入文件格式，则报错退出。
- en: '[![5](assets/5.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-5)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-5)'
- en: Use the output format or use the input format.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用输出格式或使用输入格式。
- en: '[![6](assets/6.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-6)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-6)'
- en: Iterate through each sequence in the file.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历文件中的每个序列。
- en: '[![7](assets/7.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-7)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-7)'
- en: See if either the sequence ID or description matches the pattern.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 查看序列ID或描述是否与模式匹配。
- en: '[![8](assets/8.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-8)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-8)'
- en: If so, write the sequence to the output file.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，请将序列写入输出文件。
- en: There are several items I’d like to highlight, and I’ll start with my use of
    `sys.exit()` to halt the program in the middle of processing the files if I’m
    unable to decide on the output file format. This is a value I don’t necessarily
    expect from the user, and one that I’m hoping I can figure out when the program
    is running. If I can’t, then I need to return an error message to the user and
    an exit value to the operating system to indicate a failure. I need the user to
    start over and correct the missing information before I can continue.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有几件事我想要强调，我将从使用`sys.exit()`来中断程序处理文件的过程中，如果我无法决定输出文件格式。这是一个我不一定期望用户提供的值，希望在程序运行时能够弄清楚。如果不能，那么我需要向用户返回一个错误消息，并向操作系统返回一个退出值，指示失败。我需要用户重新开始并纠正缺失的信息，然后才能继续。
- en: 'I also want to point out my use of the `any()` function, which has a corollary
    in the `all()` function. Both functions reduce a list of truthy values to a single
    Boolean value. The `all()` function will return `True` if *all* the values are
    truthy, and `False` otherwise:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我还要指出我使用`any()`函数的地方，该函数在`all()`函数中有一个类似物。这两个函数将一系列真值值减少为单个布尔值。`all()`函数将返回`True`，如果*所有*值为真，否则为`False`：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'While the `any()` function will return `True` if *any* of the values are truthy
    and `False` otherwise:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当`any()`函数返回`True`时，*任何*值为真，否则为`False`：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: I use this with the compiled regular expression to search the record’s ID and
    description fields. That regex is also using the `re.IGNORECASE` flag to turn
    on case-insensitive matching. To explain this, I’d like to go on a tangent into
    how Python combines Boolean values using `and` and `or` and bits using the respective
    bitwise operators `&` and `|`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我将此与编译的正则表达式一起使用，搜索记录的ID和描述字段。该正则表达式还使用`re.IGNORECASE`标志来开启不区分大小写的匹配。为了解释这一点，我想离题讨论一下Python如何使用`and`和`or`结合布尔值，以及使用相应的位运算符`&`和`|`。
- en: Combining Regular Expression Search Flags
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并正则表达式搜索标志
- en: 'By default, regular expressions are case-sensitive, but this program needs
    to handle both case-sensitive and case-insensitive searching. For example, if
    I search for lowercase *lsu* but the record header has only uppercase *LSU*, I
    would expect this to fail:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，正则表达式区分大小写，但该程序需要处理大小写敏感和不敏感的搜索。例如，如果我搜索小写的*lsu*但记录标头只有大写的*LSU*，我期望这次搜索失败：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'One way to disregard case is to force both the search pattern and string to
    uppercase or lowercase:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一种忽略大小写的方法是强制搜索模式和字符串都转换为大写或小写：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Another method is to provide an optional flag to the `re.search()` function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是向`re.search()`函数提供一个可选标志：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This can be shortened to `re.I`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 可以缩短为`re.I`：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the program, I use this when I compile the regular expression:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，当我编译正则表达式时使用这个：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[![1](assets/1.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO7-1)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO7-1)'
- en: If `args.insensitive` is `True`, then use the `re.IGNORECASE` option when compiling
    the pattern; otherwise, use `0`, which means no options.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`args.insensitive`为`True`，则在编译模式时使用`re.IGNORECASE`选项；否则，使用`0`，表示没有选项。
- en: 'I first showed how to compile a regular expression in [Chapter 11](ch11.html#ch11).
    The advantage is that Python only has to parse the pattern once, which usually
    makes your code run faster. Here I need to decide whether to change to case-insensitive
    matching using an optional flag. I can alter many aspects of the regular expression
    matching with other such flags, which can be combined using the bitwise or `|`
    operator. I think it’s best to start with the documentation from `help(re)`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先展示了如何在[第11章](ch11.html#ch11)中编译正则表达式。优点是Python只需解析模式一次，通常可以使代码运行更快。这里我需要决定是否使用可选标志进行不区分大小写匹配。我可以使用其他标志改变正则表达式匹配的许多方面，这些标志可以使用位或`|`运算符组合。我认为最好从`help(re)`的文档开始：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Looking closely, I can find that `re.IGNORECASE` is an [`enum`](https://oreil.ly/J6Wsy)
    or *enumeration* of possible values:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，我发现`re.IGNORECASE`是一个[`enum`](https://oreil.ly/J6Wsy)或*枚举*，具有可能值：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'According to the [documentation](https://oreil.ly/nONMy), this is “a subclass
    of `enum.IntFlag`,” which is [described thusly](https://oreil.ly/l1dyG):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[文档](https://oreil.ly/nONMy)，这是“`enum.IntFlag`的子类”描述如下：（https://oreil.ly/l1dyG）
- en: Base class for creating enumerated constants that can be combined using the
    bitwise operators without losing their `IntFlag` membership. `IntFlag` members
    are also subclasses of `int`.
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建枚举常量的基类，可以使用位运算符组合它们而不失去它们的`IntFlag`成员资格。`IntFlag`成员也是`int`的子类。
- en: 'This means that `re.IGNORECASE` is deep down an `int`, just like `False` is
    actually `0` and `True` is actually `1`. I used a little detective work to figure
    out the integer values of the flags by adding `0`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`re.IGNORECASE`深层次上是一个`int`，就像`False`实际上是`0`，`True`实际上是`1`一样。我进行了一些侦探工作，通过添加`0`来确定标志的整数值：
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note how each value is a power of 2 so that each flag can be represented by
    a single, unique bit. This makes it possible to combine flags using the `|` operator
    mentioned in the documentation. To demonstrate, I can use the prefix `0b` to represent
    a string of raw bytes. Here are the binary representations of the numbers 1 and
    2. Note that each uses just a single bit set to 1:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个值都是2的幂，因此每个标志可以由单个唯一位表示。这使得可以使用文档中提到的`|`运算符组合标志。为了演示，我可以使用前缀`0b`表示原始字节字符串。以下是数字1和2的二进制表示。请注意，每个值仅使用一个设置为1的位：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If I use `|` to *or* the bits together, each of the three bits is combined using
    the truth table shown in [Table 16-2](#table_16.2).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我使用`|`来对位进行*或*操作，每个三位数都将使用[表16-2](#table_16.2)中显示的真值表进行组合。
- en: Table 16-2\. Truth table for *or* (`|`)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 表16-2\. 或运算（`|`）的真值表
- en: '| First | Second | Result |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 第一 | 第二 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| T | T | T |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| T | T | T |'
- en: '| T | F | T |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| T | F | T |'
- en: '| F | T | T |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| F | T | T |'
- en: '| F | F | F |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| F | F | F |'
- en: 'As shown in [Figure 16-6](#fig_16.6), Python will look at each bit and select
    1 if either bit is 1, and 0 only if both bits are 0, resulting in `0b011`, which
    is the binary representation of the number 3 because the bits for positions 1
    and 2 are both set:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如图[16-6](#fig_16.6)所示，Python 将查看每个位，并且如果任一位为1，则选择1，仅当两个位都为0时，结果为0，导致`0b011`，这是数字3的二进制表示，因为位置1和2的位均已设置：
- en: '[PRE42]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![mpfb 1606](assets/mpfb_1606.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 1606](assets/mpfb_1606.png)'
- en: Figure 16-6\. When or-ing each column of bits, a 1 in any position yields a
    1; if all bits are 0, the result is 0
  id: totrans-219
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图16-6\. 当对每列位进行或运算时，任何位置为1的情况都会得到1；如果所有位都为0，则结果为0。
- en: When using the `&` operator, Python will only yield a 1 when both bits are 1;
    otherwise, it will return 0, as shown in [Table 16-3](#table_16.3).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`&`运算符时，Python仅当两个位都为1时才会返回1；否则，会返回0，如[表16-3](#table_16.3)所示。
- en: Table 16-3\. Truth table for and (`&`)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 表16-3\. 与运算（`&`）的真值表
- en: '| First | Second | Result |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 第一 | 第二 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| T | T | T |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| T | T | T |'
- en: '| T | F | F |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| T | F | F |'
- en: '| F | T | F |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| F | T | F |'
- en: '| F | F | F |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| F | F | F |'
- en: 'Therefore, using `&` to combine `one` and `two` will result in the value `0b000`,
    which is the binary representation of 0:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用`&`来组合`one`和`two`将导致值为`0b000`，这是 0 的二进制表示：
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'I can use the `|` operator to join multiple regular expression bitflags. For
    example, `re.IGNORECASE` is 2, which is represented as `0b010`, and `re.LOCALE`
    is 4, which is represented as `0b100`. Bitwise or combines these as `0b110`, which
    is the number 6:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用`|`运算符来连接多个正则表达式标志位。例如，`re.IGNORECASE`是 2，表示为`0b010`，`re.LOCALE`是 4，表示为`0b100`。按位或将它们组合为`0b110`，这是数字
    6：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'I can verify that this is true:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以验证这一点：
- en: '[PRE45]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To return to the `re.compile()` function, the default is to match case:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回到`re.compile()`函数，默认情况下是区分大小写的：
- en: '[PRE46]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If the user wants case-insensitive searching, then I want to execute something
    like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户想要执行不区分大小写的搜索，那么我想要执行类似这样的操作：
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'One way to avoid this would be to use an `if` statement:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这种情况的一种方法是使用一个`if`语句：
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'I dislike this solution as it violates the *DRY* principle: Don’t Repeat Yourself.
    I can write an `if` expression to choose either the `re.IGNORECASE` flag or some
    default value that means *no flags*, which turns out to be the number 0:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我不喜欢这个解决方案，因为它违反了*DRY*原则：不要重复自己。我可以编写一个`if`表达式来选择`re.IGNORECASE`标志或一些表示*无标志*的默认值，这个值恰好是数字
    0：
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If I wanted to expand this program to include any of the additional search
    flags from the documentation, I could use `|` to combine them. Chapters [6](ch06.html#ch06)
    and [12](ch12.html#ch12) talk about the idea of *reducing* multiple values to
    a single value. For instance, I can use addition to reduce a list of numbers to
    their sum, or multiplication to create the product, and reduce a list of strings
    to a single value using the `str.join()` function. I can similarly use bitwise
    `|` to reduce all the regex flags:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想要扩展这个程序以包括文档中的任何其他搜索标志，我可以使用`|`来组合它们。第[6](ch06.html#ch06)章和第[12](ch12.html#ch12)章讨论了将多个值*减少*为单个值的思想。例如，我可以使用加法将数字列表减少到它们的和，或者使用乘法创建乘积，并使用`str.join()`函数将字符串列表减少到单个值。我可以类似地使用按位`|`来减少所有的正则表达式标志：
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Because these flags use unique bits, it’s possible to find out exactly which
    flags were used to generate a particular value by using the `&` operator to determine
    if a given bit is on. For instance, earlier I showed how to combine the flags
    `re.IGNORECASE` and `re.LOCALE` using `|`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些标志使用唯一的位，所以可以通过使用`&`运算符来确定特定位是否处于打开状态，从而确切地找出生成特定值时使用了哪些标志。例如，前面我展示了如何使用`|`组合标志`re.IGNORECASE`和`re.LOCALE`：
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To see if a given flag is present in the `flags` variable, I use `&`. It will
    be returned when I *and* it because only the 1 bits present in both values will
    be returned:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`flags`变量中是否存在特定标志，我使用`&`。当我进行*与*操作时，只有两个值中都存在的 1 位才会返回：
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If I *and* a flag that’s not present in the combined values, the result is
    0:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我*与*一个不在组合值中的标志，结果将为 0：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: That’s a lot of information about combining bits. So, if you don’t know, now
    you know.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 关于组合位的信息太多了。所以，如果你不知道，现在你知道了。
- en: Reducing Boolean Values
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少布尔值
- en: 'I’d like to bring this back to the `any()` function I used in this program.
    As with the bitwise combinations of integer values, I can similarly reduce multiple
    Boolean values. That is, here is the same information as in [Table 16-2](#table_16.2),
    using the `or` operator to combine Booleans:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我想把这个带回我在这个程序中使用的`any()`函数。与整数值的按位组合类似，我可以类似地减少多个布尔值。也就是说，这里是与[表 16-2](#table_16.2)中相同的信息，使用`or`运算符来组合布尔值：
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This is the same as using `any()` with a list of Booleans. If *any* of the
    values is truthy, then the whole expression is `True`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这与使用`any()`和布尔值列表是一样的。如果*任何*值为真，则整个表达式为`True`：
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'And here is the same data as in [Table 16-3](#table_16.3), using `and` to combine
    Booleans:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是与[表 16-3](#table_16.3)中相同的数据，使用`and`来组合布尔值：
- en: '[PRE56]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is the same as using `all()`. Only if *all* of the values are truthy will
    the whole expression be `True`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这与使用`all()`是一样的。只有当*所有*值都为真时，整个表达式才为`True`：
- en: '[PRE57]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here is the line of code where I use this idea:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我使用这个想法的代码行：
- en: '[PRE58]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `map()` function feeds each of the `rec.id` and `rec.description` values
    to the `regex.search()` function, resulting in a list of values that can be interpreted
    for their truthiness. If any of these is truthy—meaning I found a match in at
    least one of the fields—then `any()` will return `True` and the sequence should
    be written to the output file.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 函数将每个 `rec.id` 和 `rec.description` 的值传递给 `regex.search()` 函数，返回一个可以解释其真实性的值列表。如果其中任何一个是真的——意味着至少在一个字段中找到了匹配——则
    `any()` 将返回 `True`，并且应将序列写入输出文件。'
- en: Going Further
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步探索
- en: Sometimes the sequence header contains key/value metadata like “Organism=Oryza
    sativa.” Add an option to search these values. Be sure you add an input file example
    to the *tests/inputs* directory and the appropriate tests to *tests/fastx_grep_test.py*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 有时序列头部包含键/值元数据，如“Organism=Oryza sativa”。添加一个选项来搜索这些值。确保将输入文件示例添加到 *tests/inputs*
    目录，并将相应的测试添加到 *tests/fastx_grep_test.py* 中。
- en: Expand the program to handle additional input sequence formats like GenBank,
    EMBL, and SwissProt. Again, be sure to add example files and tests to ensure that
    your program works.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展程序以处理额外的输入序列格式，如 GenBank、EMBL 和 SwissProt。同样，请确保添加示例文件和测试以确保程序正常工作。
- en: Alter the program to select sequences with some minimum length and quality score.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 修改程序以选择具有一些最小长度和质量分数的序列。
- en: Review
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习
- en: 'Key points from this chapter:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点：
- en: 'The FASTQ file format requires each record to be represented by four lines:
    a header, the sequence, a separator, and the quality scores.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FASTQ 文件格式要求每个记录由四行表示：一个头部、序列、一个分隔符和质量分数。
- en: Regular expression matches can accept flags that control, for example, whether
    to perform a case-insensitive match. By default, regexes are case-sensitive.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式匹配可以接受控制标志，例如是否执行大小写不敏感匹配。默认情况下，正则表达式是区分大小写的。
- en: To indicate multiple regex flags, use the `|` (*or*) bitwise operator to combine
    the integer values of the flags.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要指定多个正则表达式标志，请使用 `|`（*或*）按位运算符来组合标志的整数值。
- en: Boolean values can be reduced using `and` and `or` operations as well as the
    `any()` and `all()` functions.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值可以使用 `and` 和 `or` 操作符以及 `any()` 和 `all()` 函数进行简化。
- en: The DWIM (Do What I Mean) aesthetic means you try to anticipate what your user
    would want a program to do naturally and intelligently.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DWIM（做我想要的）美学意味着你尝试预测用户自然和智能地希望程序做什么。
- en: The DRY (Don’t Repeat Yourself) principle means that you never duplicate the
    same idea in your code but rather isolate it to one locus or function.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DRY（不要重复自己）原则意味着你永远不要在代码中重复相同的想法，而是将其隔离到一个位置或函数中。
- en: ^([1](ch16.html#idm45963628251688-marker)) Some say this is short for *global
    regular expression print*.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch16.html#idm45963628251688-marker)) 有人说这是 *全局正则表达式打印* 的缩写。
- en: ^([2](ch16.html#idm45963628022792-marker)) According to [*Programming Perl*](https://oreil.ly/XnvaC)
    by Tom Christiansen et al. (O’Reilly, 2012), the three great virtues of a programmer
    are laziness, impatience, and hubris.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch16.html#idm45963628022792-marker)) 根据[*Perl 编程*](https://oreil.ly/XnvaC)（Tom
    Christiansen 等著，O’Reilly，2012）中的描述，程序员的三大美德是懒惰、急躁和傲慢。
