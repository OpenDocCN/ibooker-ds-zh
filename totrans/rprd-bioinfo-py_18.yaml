- en: 'Chapter 16\. FASTX grep: Creating a Utility Program to Select Sequences'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A colleague asked me once to find all the RNA sequences in a FASTQ file that
    had a description or name containing the string *LSU* (for *long subunit* RNA).
    Although it’s possible to solve this problem for FASTQ files by using the `grep`
    program^([1](ch16.html#idm45963628251688)) to find all the lines of a file matching
    some pattern, writing a solution in Python allows you to create a program that
    could be expanded to handle other formats, like FASTA, as well as to select records
    based on other criteria, such as length or GC content. Additionally, you can add
    options to change the output sequence format and introduce conveniences for the
    user like guessing the input file’s format based on the file extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: About the structure of a FASTQ file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to perform a case-insensitive regular expression match
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About DWIM (Do What I Mean) and DRY (Don’t Repeat Yourself) ideas in code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use `and` and `or` operations to reduce Boolean values and bits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding Lines in a File Using grep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `grep` program can find all the lines in a file matching a given pattern.
    If I search for *LSU* in one of the FASTQ files, it finds two header lines containing
    this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If the goal were only to find how many sequences contain this string, I could
    pipe this into `wc` (word count) to count the lines using the `-l` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since my goal is to extract the sequence records where the header contains the
    substring *LSU*, I have to do a little more work. As long as the input files are
    in FASTQ format, I can still use `grep`, but this requires a better understanding
    of the format.
  prefs: []
  type: TYPE_NORMAL
- en: The Structure of a FASTQ Record
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The FASTQ sequence format is a common way to receive sequence data from a sequencer
    as it includes both the base calls and the quality scores for each base. That
    is, sequencers generally report both a base and a measure of certainty that the
    base is correct. Some sequencing technologies have trouble, for instance, with
    homopolymer runs, like a poly(*A*) run of many *A*s where the sequencer may be
    unable to count the correct number. Many sequencers also lose confidence in base
    calls as the reads grow longer. Quality scores are an important means for rejecting
    or truncating low-quality reads.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the sequencer, some bases can be hard to distinguish, and the ambiguity
    may be reported using IUPAC codes I describe in [Chapter 1](ch01.html#ch01), such
    as *R* for *A* or *G* or *N* for any base.
  prefs: []
  type: TYPE_NORMAL
- en: The FASTQ format is somewhat similar to the FASTA format used in many of the
    problems in the Rosalind challenges. As a reminder, FASTA records start with a
    `>` symbol followed by a header line that identifies the sequence and may contain
    metadata. The sequence itself follows, which may be one (possibly long) line of
    text or might be split over multiple lines. In contrast, FASTQ records must always
    be exactly four lines, as shown in [Figure 16-1](#fig_16.1).
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1601](assets/mpfb_1601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-1\. The elements of a FASTQ record—although the long lines are wrapped
    in this display, the actual record contains exactly four lines
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the contents of this figure:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line starts with the `@` symbol and contains the header information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second line contains the sequence with no line breaks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third line begins with the `+` symbol. Often it will be only this symbol,
    but sometimes the header information may be repeated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The fourth line contains the quality scores for each base in the sequence and
    also has no line breaks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The sequence ID is all characters up to the first space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additional metadata may follow the ID and is included in the description.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each base in the sequence has a partner in the quality line representing the
    confidence that this base is correct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A FASTQ header has the same structure as the header in a FASTA record, with
    the exception that it starts with the `@` sign instead of the `>`. The sequence
    identifier is usually all the characters after `@` up to the first space. The
    second line containing the sequence cannot contain any line breaks, and each base
    in the sequence has a corresponding quality value in the fourth line. The quality
    scores on the fourth line use the ASCII values of the characters to encode the
    certainty of the base call. These scores are represented using the printable characters
    from the ASCII table first introduced in [Chapter 3](ch03.html#ch03).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first 32 values in the ASCII table are unprintable control characters and
    the space. The printable characters start at 33, with punctuation followed by
    numbers. The first letter, *A*, is not found until 65, and uppercase characters
    precede lowercase. The following is the output from the `asciitbl.py` program
    included in the repository that shows the ordinal values of the 128 values from
    the ASCII table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the quality line of the FASTQ record in [Figure 16-1](#fig_16.1) and
    see how the characters change from higher values like uppercase letters at the
    beginning to lower values like punctuation and numbers toward the end. Note that
    the `@` and `+` symbols on the fourth line represent possible quality values and
    so would not be metacharacters denoting the beginning of a record or the separator
    line. For this reason, FASTQ records can’t use newlines to break the sequence
    (like in FASTA records) or quality lines: the symbols `@` and `+` might end up
    as the first character on a line, making it impossible to find the start of a
    record. Combine this with the utterly useless third line that often consists of
    a single `+` symbol, and which sometimes needlessly recapitulates all the header
    information, and you see why biologists should never be allowed to define a file
    format.'
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple encoding standards using various ranges to represent the
    quality scores.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because FASTQ records must be four lines long, I can use the `-A|--after-context`
    option for `grep` to specify the number of lines of trailing context after each
    match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This works as long as the substring of interest occurs only in the header, which
    is the first line of a record. If `grep` managed to find a match in any other
    line in the record, it would print that line plus the following three, yielding
    unusable garbage. Given that I would like to control exactly which parts of the
    record to search and the fact that the input files might be in FASTQ, FASTA, or
    any number of other formats, it quickly becomes evident that `grep` won’t take
    me very far.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, I’ll show you how my solution works, and then I’ll challenge you to
    implement your version. All the code and tests for this exercise are in the *16_fastx_grep*
    directory of the repository. Start by changing into this directory and copying
    the solution to `fastx_grep.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `grep` usage shows that it accepts two positional arguments, a pattern
    and one or more files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Request help from the `fastx_grep.py` program and see that it has a similar
    interface that requires a pattern and one or more input files. Additionally, this
    program can parse different input file formats, produce various output formats,
    write the output to a file, and perform case-insensitive matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The regular expression (pattern) is the first positional argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: One or more positional file arguments are required second.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The input file format of the sequences, either *fasta* or *fastq*. The default
    is to guess from the file extension.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The output file format, one of *fasta*, *fastq*, or *fasta-2line*. The default
    is to use the same as the input file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The output filename; the default is `STDOUT`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Whether to perform case-insensitive matches; the default is `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This program has a more complicated set of arguments than many of the programs
    from [Part I](part01.html#part_one). As usual, I like to use a `NamedTuple` to
    model the options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The regular expression to use.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: One or more input files.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The format of the input file, such as FASTA or FASTQ.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The format of the output file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the output file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Whether to perform case-insensitive searching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how I define the program’s parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The pattern will be a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The inputs must be readable text files.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `choices` to constrain the input values. The default will be guessed from
    the input file extension.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Constrain values using `choices`; default to using the input format. The *fasta-2line*
    option will not break long sequences over multiple lines and so will use only
    two lines per record.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The output file will be a writable text file. The default is `STDOUT`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: A flag to indicate case-insensitive searching. The default is `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the following command to search for *LSU* in the *lsu.fq* test file,
    you should see eight lines of output representing two FASTQ records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you search for lowercase *lsu*, however, you should see no output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `-i|--insensitive` flag to perform a case-insensitive search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `-o|--outfile` option to write the results to a file instead
    of `STDOUT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the *out.fq* file, you’ll see it’s in FASTQ format just like
    the original input. You can use the `-O|--outfmt` option to change this to something
    like FASTA and look at the output file to verify the format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Try using the *fasta-2line* output format to see how the long sequences are
    not broken over multiple lines. Note that the program also works on FASTA input
    without my having to indicate the file format because it is guessed from the *.fa*
    file extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Run **`pytest -v`** to see all the tests for the program, which include guessing
    the file format, handling empty files, searching lowercase and uppercase input
    both with and without case-sensitivity, writing output files, and writing different
    output formats. When you think you understand all the options your program must
    handle, start over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Guessing the File Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you look at *out.fa* created in the preceding section, you’ll see it’s in
    FASTA format, matching the input format, but I never indicated the input file
    format. The program intelligently checks the file extension of the input file
    and guesses at the format using the assumptions in [Table 16-1](#table_16.1).
    Similarly, if no output format is specified, then the input file format is assumed
    to be the desired output format. This is an example of the *DWIM* principle in
    software development: Do What I Mean.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-1\. Common file extensions for FASTA/Q files
  prefs: []
  type: TYPE_NORMAL
- en: '| Extension | Format |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *.fasta* | FASTA |'
  prefs: []
  type: TYPE_TB
- en: '| *.fa* | FASTA |'
  prefs: []
  type: TYPE_TB
- en: '| *.fna* | FASTA (nucleotides) |'
  prefs: []
  type: TYPE_TB
- en: '| *.faa* | FASTA (amino acids) |'
  prefs: []
  type: TYPE_TB
- en: '| *.fq* | FASTQ |'
  prefs: []
  type: TYPE_TB
- en: '| *.fastq* | FASTQ |'
  prefs: []
  type: TYPE_TB
- en: 'Your program will similarly need to guess the format of the input files. I
    created a `guess_format()` function that takes the name of a file and returns
    a string of either `fasta` or `fastq`. Here is a stub for the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the test I wrote. After defining the arguments, I would recommend you
    start with this function. Do not proceed until your code passes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It might help to sketch out how the program should work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, I can run the program on three input files by using the shell
    glob `*.f[aq]` to indicate all the files with an extension starting with the letter
    *f* and followed by either *a* or *q*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This should write four sequences to the file *out.fa*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is a complex program that may take you quite a while to finish. There is
    value in your struggle, so just keep writing and running the tests, which you
    should also read to understand how to challenge your program.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In my experience, this is a realistically complicated program that captures
    many patterns I write often. It starts by validating and processing some number
    of input files. I’m a truly lazy programmer^([2](ch16.html#idm45963628022792))
    who always wants to give as little information as possible to my programs, so
    I’m happy to write a little code to guess the file formats for me.
  prefs: []
  type: TYPE_NORMAL
- en: Guessing the File Format from the File Extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I’ll start with the function for guessing a file’s format from the file extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `os.path.splitext()` function to get the file extension and remove the
    leading dot.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Return the string `fasta` if the extension matches one of the patterns for FASTA
    files from [Table 16-1](#table_16.1), `fastq` if it matches a FASTQ pattern, and
    the empty string otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that `os.path.splitext()` will return both the root of the filename
    and the extension as a 2-tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Since I’m only interested in the second part, I can use the `_` to assign the
    first member of the tuple to a throwaway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, I chose to index the tuple to select only the extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Since I don’t want the leading dot, I could use a string slice to remove this,
    but this looks cryptic and unreadable to me:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, I’d prefer to use the `re.sub()` function I first introduced in [Chapter 2](ch02.html#ch02).
    The pattern I’m looking for is a literal dot at the beginning of the string. The
    caret `^` indicates the start of the string, and the `.` is a metacharacter that
    means one of anything. To show that I want a literal dot, I must either place
    a backslash in front of it like `^\.` or place it inside a character class as
    in `^[.]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `re.sub()` to remove a literal dot at the beginning of the file extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in [Table 16-1](#table_16.1), there are four common extensions for
    FASTA files which I can represent using one compact regular expression. Recall
    that there are two functions in the `re` module for searching:'
  prefs: []
  type: TYPE_NORMAL
- en: '`re.match()` finds a match from the beginning of a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`re.search()` finds a match anywhere inside a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, I’m using the `re.match()` function to ensure that the pattern
    (the first argument) is found at the beginning of the extension (the second argument):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the same results from `re.search()`, I would need to use a caret at
    the beginning to anchor the pattern to the start of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 16-2](#fig_16.2) describes each part of the regular expression.'
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1602](assets/mpfb_1602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-2\. A regular expression for matching the four FASTA patterns
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It may help to see this drawn as a finite state machine diagram, as shown in
    [Figure 16-3](#fig_16.3).
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1603](assets/mpfb_1603.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-3\. A finite state machine diagram for matching the four FASTA patterns
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As there are only two patterns for FASTQ files, the pattern is somewhat simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 16-4](#fig_16.4) explains this regular expression.'
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1604](assets/mpfb_1604.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-4\. A regular expression for matching the two FASTQ patterns
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 16-5](#fig_16.5) shows the same idea expressed as a finite state machine.'
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1605](assets/mpfb_1605.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-5\. A finite state machine diagram for matching the two FASTQ patterns
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I Love It When a Plan Comes Together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is how I wrote `main()` using the structure I introduced in the first
    part of the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Compile a regular expression to find the given pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through the input files.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the input format or guess it from the filename.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Exit with an error if there is no input file format.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the output format or use the input format.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through each sequence in the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-7)'
  prefs: []
  type: TYPE_NORMAL
- en: See if either the sequence ID or description matches the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-8)'
  prefs: []
  type: TYPE_NORMAL
- en: If so, write the sequence to the output file.
  prefs: []
  type: TYPE_NORMAL
- en: There are several items I’d like to highlight, and I’ll start with my use of
    `sys.exit()` to halt the program in the middle of processing the files if I’m
    unable to decide on the output file format. This is a value I don’t necessarily
    expect from the user, and one that I’m hoping I can figure out when the program
    is running. If I can’t, then I need to return an error message to the user and
    an exit value to the operating system to indicate a failure. I need the user to
    start over and correct the missing information before I can continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'I also want to point out my use of the `any()` function, which has a corollary
    in the `all()` function. Both functions reduce a list of truthy values to a single
    Boolean value. The `all()` function will return `True` if *all* the values are
    truthy, and `False` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'While the `any()` function will return `True` if *any* of the values are truthy
    and `False` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: I use this with the compiled regular expression to search the record’s ID and
    description fields. That regex is also using the `re.IGNORECASE` flag to turn
    on case-insensitive matching. To explain this, I’d like to go on a tangent into
    how Python combines Boolean values using `and` and `or` and bits using the respective
    bitwise operators `&` and `|`.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Regular Expression Search Flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, regular expressions are case-sensitive, but this program needs
    to handle both case-sensitive and case-insensitive searching. For example, if
    I search for lowercase *lsu* but the record header has only uppercase *LSU*, I
    would expect this to fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'One way to disregard case is to force both the search pattern and string to
    uppercase or lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Another method is to provide an optional flag to the `re.search()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be shortened to `re.I`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the program, I use this when I compile the regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: If `args.insensitive` is `True`, then use the `re.IGNORECASE` option when compiling
    the pattern; otherwise, use `0`, which means no options.
  prefs: []
  type: TYPE_NORMAL
- en: 'I first showed how to compile a regular expression in [Chapter 11](ch11.html#ch11).
    The advantage is that Python only has to parse the pattern once, which usually
    makes your code run faster. Here I need to decide whether to change to case-insensitive
    matching using an optional flag. I can alter many aspects of the regular expression
    matching with other such flags, which can be combined using the bitwise or `|`
    operator. I think it’s best to start with the documentation from `help(re)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking closely, I can find that `re.IGNORECASE` is an [`enum`](https://oreil.ly/J6Wsy)
    or *enumeration* of possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'According to the [documentation](https://oreil.ly/nONMy), this is “a subclass
    of `enum.IntFlag`,” which is [described thusly](https://oreil.ly/l1dyG):'
  prefs: []
  type: TYPE_NORMAL
- en: Base class for creating enumerated constants that can be combined using the
    bitwise operators without losing their `IntFlag` membership. `IntFlag` members
    are also subclasses of `int`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This means that `re.IGNORECASE` is deep down an `int`, just like `False` is
    actually `0` and `True` is actually `1`. I used a little detective work to figure
    out the integer values of the flags by adding `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how each value is a power of 2 so that each flag can be represented by
    a single, unique bit. This makes it possible to combine flags using the `|` operator
    mentioned in the documentation. To demonstrate, I can use the prefix `0b` to represent
    a string of raw bytes. Here are the binary representations of the numbers 1 and
    2. Note that each uses just a single bit set to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If I use `|` to *or* the bits together, each of the three bits is combined using
    the truth table shown in [Table 16-2](#table_16.2).
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-2\. Truth table for *or* (`|`)
  prefs: []
  type: TYPE_NORMAL
- en: '| First | Second | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| T | T | T |'
  prefs: []
  type: TYPE_TB
- en: '| T | F | T |'
  prefs: []
  type: TYPE_TB
- en: '| F | T | T |'
  prefs: []
  type: TYPE_TB
- en: '| F | F | F |'
  prefs: []
  type: TYPE_TB
- en: 'As shown in [Figure 16-6](#fig_16.6), Python will look at each bit and select
    1 if either bit is 1, and 0 only if both bits are 0, resulting in `0b011`, which
    is the binary representation of the number 3 because the bits for positions 1
    and 2 are both set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![mpfb 1606](assets/mpfb_1606.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-6\. When or-ing each column of bits, a 1 in any position yields a
    1; if all bits are 0, the result is 0
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When using the `&` operator, Python will only yield a 1 when both bits are 1;
    otherwise, it will return 0, as shown in [Table 16-3](#table_16.3).
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-3\. Truth table for and (`&`)
  prefs: []
  type: TYPE_NORMAL
- en: '| First | Second | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| T | T | T |'
  prefs: []
  type: TYPE_TB
- en: '| T | F | F |'
  prefs: []
  type: TYPE_TB
- en: '| F | T | F |'
  prefs: []
  type: TYPE_TB
- en: '| F | F | F |'
  prefs: []
  type: TYPE_TB
- en: 'Therefore, using `&` to combine `one` and `two` will result in the value `0b000`,
    which is the binary representation of 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'I can use the `|` operator to join multiple regular expression bitflags. For
    example, `re.IGNORECASE` is 2, which is represented as `0b010`, and `re.LOCALE`
    is 4, which is represented as `0b100`. Bitwise or combines these as `0b110`, which
    is the number 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'I can verify that this is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To return to the `re.compile()` function, the default is to match case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user wants case-insensitive searching, then I want to execute something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'One way to avoid this would be to use an `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'I dislike this solution as it violates the *DRY* principle: Don’t Repeat Yourself.
    I can write an `if` expression to choose either the `re.IGNORECASE` flag or some
    default value that means *no flags*, which turns out to be the number 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If I wanted to expand this program to include any of the additional search
    flags from the documentation, I could use `|` to combine them. Chapters [6](ch06.html#ch06)
    and [12](ch12.html#ch12) talk about the idea of *reducing* multiple values to
    a single value. For instance, I can use addition to reduce a list of numbers to
    their sum, or multiplication to create the product, and reduce a list of strings
    to a single value using the `str.join()` function. I can similarly use bitwise
    `|` to reduce all the regex flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Because these flags use unique bits, it’s possible to find out exactly which
    flags were used to generate a particular value by using the `&` operator to determine
    if a given bit is on. For instance, earlier I showed how to combine the flags
    `re.IGNORECASE` and `re.LOCALE` using `|`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To see if a given flag is present in the `flags` variable, I use `&`. It will
    be returned when I *and* it because only the 1 bits present in both values will
    be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If I *and* a flag that’s not present in the combined values, the result is
    0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: That’s a lot of information about combining bits. So, if you don’t know, now
    you know.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing Boolean Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I’d like to bring this back to the `any()` function I used in this program.
    As with the bitwise combinations of integer values, I can similarly reduce multiple
    Boolean values. That is, here is the same information as in [Table 16-2](#table_16.2),
    using the `or` operator to combine Booleans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same as using `any()` with a list of Booleans. If *any* of the
    values is truthy, then the whole expression is `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the same data as in [Table 16-3](#table_16.3), using `and` to combine
    Booleans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same as using `all()`. Only if *all* of the values are truthy will
    the whole expression be `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the line of code where I use this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `map()` function feeds each of the `rec.id` and `rec.description` values
    to the `regex.search()` function, resulting in a list of values that can be interpreted
    for their truthiness. If any of these is truthy—meaning I found a match in at
    least one of the fields—then `any()` will return `True` and the sequence should
    be written to the output file.
  prefs: []
  type: TYPE_NORMAL
- en: Going Further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes the sequence header contains key/value metadata like “Organism=Oryza
    sativa.” Add an option to search these values. Be sure you add an input file example
    to the *tests/inputs* directory and the appropriate tests to *tests/fastx_grep_test.py*.
  prefs: []
  type: TYPE_NORMAL
- en: Expand the program to handle additional input sequence formats like GenBank,
    EMBL, and SwissProt. Again, be sure to add example files and tests to ensure that
    your program works.
  prefs: []
  type: TYPE_NORMAL
- en: Alter the program to select sequences with some minimum length and quality score.
  prefs: []
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Key points from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The FASTQ file format requires each record to be represented by four lines:
    a header, the sequence, a separator, and the quality scores.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expression matches can accept flags that control, for example, whether
    to perform a case-insensitive match. By default, regexes are case-sensitive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To indicate multiple regex flags, use the `|` (*or*) bitwise operator to combine
    the integer values of the flags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean values can be reduced using `and` and `or` operations as well as the
    `any()` and `all()` functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DWIM (Do What I Mean) aesthetic means you try to anticipate what your user
    would want a program to do naturally and intelligently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DRY (Don’t Repeat Yourself) principle means that you never duplicate the
    same idea in your code but rather isolate it to one locus or function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch16.html#idm45963628251688-marker)) Some say this is short for *global
    regular expression print*.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch16.html#idm45963628022792-marker)) According to [*Programming Perl*](https://oreil.ly/XnvaC)
    by Tom Christiansen et al. (O’Reilly, 2012), the three great virtues of a programmer
    are laziness, impatience, and hubris.
  prefs: []
  type: TYPE_NORMAL
