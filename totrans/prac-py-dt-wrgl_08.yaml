- en: Chapter 8\. Structuring and Refactoring Your Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move on to the analyzing and visualizing aspects of data wrangling,
    we’re going to take a brief “detour” to discuss some strategies for making the
    most of everything we’ve done so far. In the last few chapters, we’ve explored
    how to access and parse data from a variety of data formats and sources, how to
    evaluate its quality in practical terms, and how to clean and augment it for eventual
    analysis. In the process, our relatively simple programs have evolved and changed,
    becoming—inevitably—more convoluted and complex. Our `for` loops now have one
    or (more) nested `if` statements, and some of those now have apparently “magic”
    numbers embedded in them (like our `the_date.weekday() <= 4` in [Example 7-5](ch07.html#weekday_rides)).
    Is this just the price of more functional code?
  prefs: []
  type: TYPE_NORMAL
- en: Remember that commenting our code can do a lot to help keep the logic of our
    scripts understandable, both to potential collaborators and our future selves.
    But it turns out that detailed documentation (much as I love it) isn’t the only
    way that we improve the clarity of our Python code. Just like other types of written
    documents, Python supports a range of useful mechanisms for structuring and organizing
    our code. By making judicious use of these, we can make it simpler to both use
    and reuse our programming work down the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'So in this chapter, we’re going to go over the tools and concepts that will
    allow us to refine our code in such a way that it is both readable and reusable.
    This process, known as *refactoring*, exemplifies yet another way that using Python
    for our data wrangling work makes it possible to get more output for our effort:
    while we can rely on the functionality that *someone else*’s library offers when
    we need to, we can *also* create new coding “shortcuts” that are customized to
    exactly our own preferences and needs.'
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting Custom Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we were covering the Python fundamentals way back in [Chapter 2](ch02.html#chapter2),
    one of the things we touched on was the concept of “custom” or *user-defined*
    functions.^([1](ch08.html#idm45143401447136)) In [Example 2-7](ch02.html#greet_me),
    we saw how a custom function could be used to encapsulate the simple task of printing
    out a greeting when a particular name was provided—but of course we can create
    custom functions that are as simple or as complex as we like. Before we dive into
    the mechanics of writing our own custom functions, however, let’s take a step
    back and think about which design considerations can best help us decide *when*
    writing a custom function is likely to be most helpful. Of course, like all writing,
    there are few hard-and-fast rules, but what follows are a few heuristics that
    can help you decide when and how refactoring is likely to be worth it.
  prefs: []
  type: TYPE_NORMAL
- en: Will You Use It More Than Once?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like variables, one way to identify parts of your code that could benefit from
    being repackaged into custom functions is to look for any particular task that
    gets done more than once. From validating input to formatting output (as we did,
    say, in [Example 7-7](ch07.html#xls_meta_and_date_parsing)) and everything in
    between, if your current script includes lots of fiddly conditionals or repetitive
    steps, that’s an indicator that you may want to think about designing some custom
    functions. Keep in mind, too, that the repetition you’re considering doesn’t need
    to exist within a single script for refactoring to be worthwhile. If you find
    that there are particular tasks that you’re doing frequently *across* the scripts
    that you’re writing (for example, testing to see if a given day is a weekday,
    as we did in [Example 7-5](ch07.html#weekday_rides)), you can always put the custom
    function into an external script and include it anywhere you might need it, just
    as we did with our credentials files in [Chapter 5](ch05.html#chapter5).
  prefs: []
  type: TYPE_NORMAL
- en: Is It Ugly and Confusing?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documenting your work as you go is a gift to both current collaborators and
    your future self.^([2](ch08.html#idm45143402674080)) At the same time, thoroughly
    commenting your code—especially if you include not just the *how* but the *why*
    of your approach, which I still recommend—can eventually make it a bit unwieldy
    to read. Creating really comprehensible code, then, is a balancing act between
    providing enough detail to be comprehensive while *also* being sufficiently concise
    so your documentation actually gets read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Packaging relevant bits of code into custom functions is actually a key way
    you can help thread this needle: like variables, custom functions can (and should!)
    have descriptive names. Just by *reading* the function name, whoever is looking
    at your code will get some essential information about what is happening, without
    your needing to add multiple lines of descriptive comments immediately around
    it. If the function name is descriptive enough and/or a particular reader doesn’t
    need more detail right away, they can just move on. Meanwhile, they’ll still be
    able to find your lovely, descriptive documentation for that function if they
    need it—neatly tucked away in another part of the program (or another file altogether).
    This means that the *inline* comments for your main script can stay relatively
    succinct without sacrificing the completeness of your documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Do You Just Really **Hate** the Default Functionality?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OK, so this is maybe not the *best* reason to write a custom function, but it
    is a real one. Over time, you may find that there are tasks you need to complete
    over and over again as part of your data wrangling endeavors, and that there’s
    something about the existing functions and libraries that just *bugs* you. Maybe
    it’s a function name that you find confusing so you *always* have to remind yourself
    precisely what it’s called. Or maybe there’s a parameter you consistently forget
    to add that just makes everything more difficult (I’m looking at you, `pd.read_csv()`,
    with your `dtype='string'` parameter!). If you’re working alone or in a small
    team, it’s perfectly fine to write custom functions that help make your life easier
    just because they *do*. You don’t need a grand rationale. If it will make your
    life easier, go ahead! That’s the power of being the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are some limits to this. Unless you want to take a much more
    formal and involved approach to writing Python code, you can’t very effectively
    do things like define a new function that has the same name as an existing function
    or make operators like `+` or `-` behave differently.^([3](ch08.html#idm45143402658928))
    However, if you just really wish that an existing function you have to use all
    the time worked a *little* bit differently, go with it—just make sure you document
    the heck out of your version!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we’ve gone over some of the *reasons* you might refactor your code
    with custom functions, it’s time to discuss the mechanics a little bit. Probably
    the most important concept to understand when you start writing custom functions
    is *scope*. Although we haven’t used this term before, *scope* is something that
    we’ve actually been working with since we declared our first variables way back
    in [“What’s in a name?”](ch02.html#whats_in_a_name). In that example, we saw that
    we could:'
  prefs: []
  type: TYPE_NORMAL
- en: Create and assign a value to a variable (`author = "Susan E. McGregor"`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use that variable to refer to its contents later and pass its value to a function
    (`print(author)`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the same time, we know that if we created a program that simply consisted
    of the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: we’d get an error, because in the universe of our one-line script, there is
    no memory-box labeled `author`. So Python chucks an error at us and declines to
    go any further.
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about *scope* in programming, what we’re actually talking about
    is the current “universe” from the perspective of a particular piece of code.
    An individual script has a scope that evolves as each line of code is read by
    the computer, from top to bottom, which is what leads to the (very much expected)
    behaviors of the scripts in Examples [8-1](#no_scope) and [8-2](#author_scope).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-1\. No `author` variable in scope
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Example 8-2\. An `author` variable in scope
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as every time we create a new variable, a new “box” is created in the
    computer’s memory, each time we define a new custom function, a new little universe,
    or *scope*, is created for it as well. This means that when we use custom functions,
    we are compartmentalizing our code not just *visually* but *logically* and *functionally*.
    This means that we can treat our *own* custom functions much the way we do the
    built-in Python methods and library functions that we’ve been using throughout
    this book: as “recipes” to which we provide “ingredients” and which return to
    us some value or freshly made Python object in return. The only difference is
    that with custom functions, we are the chefs!'
  prefs: []
  type: TYPE_NORMAL
- en: To get a handle on what this all means in practice, let’s revisit [Example 2-7](ch02.html#greet_me)
    from [Chapter 2](ch02.html#chapter2) but with a couple of tweaks, as shown in
    [Example 8-3](#greet_me_revisited).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-3\. greet_me_revisited.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Because any custom function automatically gets its own scope, that function
    can only “see” the variables and values that are explicitly passed into it. In
    turn, the values and variables inside that function are effectively “hidden” from
    the primary script. One consequence of this is that when we write custom functions,
    we don’t need to worry about what variable names have already been used in the
    primary script, or vice versa. As a result, we need to define fewer unique variable
    names in general, which is helpful as we begin to write longer and more complex
    scripts. It *also* means that once we have a custom function working as we expect,
    we can use—and even modify—the details of how it functions *without* having to
    make adjustments to the variables and functions in the surrounding script.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Parameters for Function “Ingredients”
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already have a fair amount of experience with providing “ingredients” (officially
    known as *arguments*) to the methods and functions that come built into Python,
    or that we’ve had access to through the many libraries we’ve used so far. As we
    begin to write custom functions, however, we need to explore in more detail what
    the process is for defining the *parameters* that those functions will accept.^([4](ch08.html#idm45143401186992))
  prefs: []
  type: TYPE_NORMAL
- en: 'First, know that—unlike some programming languages—Python doesn’t require (or
    even really allow) you to *insist* that a function’s parameters have specific
    data types.^([5](ch08.html#idm45143401184608)) If someone wants to pass entirely
    the wrong types of data into your function, they can absolutely do that. As the
    function author, then, it’s up to you to decide whether and how you want to confirm
    (or *validate*) the appropriateness of the arguments or “ingredients” that have
    been passed into your custom functions. In principle, there are three ways to
    approach this:'
  prefs: []
  type: TYPE_NORMAL
- en: Check the data types of all the arguments that have been passed into your function
    and complain to the programmer if you find something you don’t like.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrap your code in [Python’s `try...except` blocks](https://w3schools.com/python/python_try_except.asp)
    so that you can capture certain types of errors without halting the entire program.
    You can also use this to customize the message to the programmer about what went
    wrong.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not worry about it and let the user of the function (in other words, the programmer)
    work through any problems using the default Python error messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While it may seem a bit laissez-faire, my primary recommendation at this point
    is actually to go with option three: don’t worry about it. Not because errors
    won’t happen (they will—you can revisit [“Fast Forward”](ch02.html#greet_me_ff)
    if you need a refresher on what some of them look like) but because our primary
    interest here is wrangling data, not writing enterprise-level Python. As with
    the scripts we wrote in [Chapter 4](ch04.html#chapter4), we want to strike a balance
    between what we try to handle programmatically and what we rely on the programmer
    (whoever they may be) to investigate and handle for themselves. Since the programs
    we’re writing won’t bring down a website or corrupt the only copy of our data
    if they work incorrectly, not trying to anticipate and handle every possible error
    that might arise seems more than reasonable. Of course, if you document your functions
    clearly—a process we’ll look at in more detail in [“Documenting Your Custom Scripts
    and Functions with pydoc”](#documenting_custom_functions)—then other programmers
    will have everything they need to avoid errors in the first place.'
  prefs: []
  type: TYPE_NORMAL
- en: What Are Your Options?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even if we’re not trying to write custom functions for use by thousands of people,
    we can still make them flexible and fully featured. One of the simplest ways to
    do this is to write our functions to solve the most common version of our problem
    but allow optional arguments—like those we’ve seen in *pandas*^([6](ch08.html#idm45143401170704))
    and other libraries—that make them somewhat adaptable. For example, we could modify
    our `greet_me()` function to have a default greeting of “Hello” that can *also*
    be overridden by an optional value passed in by the programmer. This lets us craft
    functions that can be used effectively in multiple contexts. As an example, let’s
    look at the modified version of `greet_me` shown in [Example 8-4](#greet_me_options).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-4\. greet_me_options.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, adding optional arguments is really as simple as specifying
    a default value in the function definition; if the programmer passes a different
    value, it will simply overwrite that default when the function is called.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Into Arguments?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Providing a default value in the function declaration is not the only way to
    add optional arguments to your custom functions. Python also supports two generic
    types of optional arguments, `*args` and `**kwargs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*args`'
  prefs: []
  type: TYPE_NORMAL
- en: The `*args` parameter is useful when you want to be able to pass a list of several
    values into a function and giving all of them names and/or default values would
    be tedious. Values passed in as `*args` are stored as a list, so they can be accessed
    within the function by writing a `for...in` loop to go through them one by one
    (e.g., `for arg in args`).
  prefs: []
  type: TYPE_NORMAL
- en: '`**kwargs`'
  prefs: []
  type: TYPE_NORMAL
- en: The `**kwargs` parameter is similar to `*args`, except that it allows an arbitrary
    number of keyword arguments to be passed to the function without assigning any
    of them a default value, as we did for `greeting` in [Example 8-4](#greet_me_options).
    Values passed this way can be accessed via the `kwargs.get()` method (e.g., `my_var
    = kwargs.get("greeting")`).
  prefs: []
  type: TYPE_NORMAL
- en: If using `*args` and `**kwargs` seems like a handy way to (literally) leave
    your options open when writing custom functions, I’m here to tell you that it’s
    *always* better to write custom functions (and scripts!) that solve the problems
    you *have*—not the ones you *think* you might have somewhere down the line. While
    the idea of extreme flexibility may seem attractive at first, it will usually
    lead to spending lots of time *thinking* about “someday” problems, rather than
    *actually* solving the ones right in front of us. And who has time for that? We’ve
    got data to wrangle!
  prefs: []
  type: TYPE_NORMAL
- en: Return Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our variations on the `greet_me()` function have been of pretty limited
    ambition; we’ve really just used them to print (slightly) customized messages
    to the console. By comparison, the functions we’ve used from external libraries
    have proven incredibly powerful; they can take a humble *.csv* and transform it
    into a *pandas* DataFrame or convert a whole *.xls* file into a collection of
    detailed lists and attributes that capture almost every aspect of this multitiered
    file type. While that level of Python programming is beyond the scope of this
    book, we can still create clean, super-useful custom functions harnessing the
    power of *return values*.
  prefs: []
  type: TYPE_NORMAL
- en: If parameters/arguments are the “ingredients” in our function “recipes,” then
    *return values* are the final dish—the outputs that get consumed by the rest of
    our program. Really, return values are just pieces of data; they can be *literals*
    (like the string “Hello”), or they can be variables of any data type. They are
    useful because they let us hand off to a function whatever it needs and get back
    the thing that we need, without worrying (at least from the perspective—or *scope*—of
    the main program) how the proverbial sausage gets made. If we restructure the
    basic `greet_me()` function in [Example 8-3](#greet_me_revisited) to use a return
    value, it might look something like [Example 8-5](#make_greeting).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-5\. make_greeting.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'At first you might be thinking, “How did that help?” While it’s true that our
    main program actually got *longer*, it also arguably became a little bit more
    flexible and easier to understand. Because my `make_greeting()` function *returns*
    the greeting (rather than just printing it directly), I can do more things with
    it. Sure, I can just print it as we did in [Example 8-5](#make_greeting), but
    I can now also store its return value in a variable and do something else with
    it later. For example, I could add the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: While that new message might not seem so exciting, it lets me both compartmentalize
    *some* work into the function (in this case, adding “Hello” to any name) while
    *also* giving me more flexibility about what to do with the output (for example,
    add more text to one but not the other).
  prefs: []
  type: TYPE_NORMAL
- en: Climbing the “Stack”
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, creating a whole new variable just to store a simple greeting, as
    we did in [Example 8-5](#make_greeting), does seem like a little bit more trouble
    than it’s worth. And in fact, there’s no rule that says we have to stash the output
    from a function in a variable before passing it to another function—we can actually
    “nest” our function calls so that the first function’s *output* just becomes the
    next function’s *input*. This is a strategy that we’ve actually used before, usually
    when we were manipulating strings and passing them to the `print()` function,
    as we did when we added the `strip()` function call to our *.csv* building process
    in [Example 7-8](ch07.html#fixed_width_strip_parsing). But we can do this with
    *any* set of functions, assuming the first one returns what the next one needs.
    To see how this works in practice, take a look at the rewrite of [Example 8-5](#make_greeting)
    shown in [Example 8-6](#make_greeting_no_vars), where I’ve added a new function
    to append the “, how are you?” text to a greeting message.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-6\. make_greeting_no_vars.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'While the code statement `print(make_greeting(author))` is still fairly easy
    to interpret, things start to get more complicated with `print(add_question(make_greeting(editor)))`,
    which I hope helps illustrate that there’s a limit to the utility of function
    call nesting. The more function calls you nest, the more difficult it is to read
    the code, even though the “order of operations” logic stays the same: the “innermost”
    function is always executed first, and its return value “bubbles up” to become
    the input for the next function. *That* return value then bubbles up to the next
    function, and so on and so forth. In traditional programming terminology this,
    is known as the *function stack*, where the innermost function is the “bottom”
    of the stack and the outermost is the “top.”^([7](ch08.html#idm45143400844448))
    An illustration of the function stack for the last line of [Example 8-6](#make_greeting_no_vars)
    is shown in [Figure 8-1](#nested_function_stack).'
  prefs: []
  type: TYPE_NORMAL
- en: While this sort of function-call nesting is at the heart of [an entire programming
    philosophy](https://en.wikipedia.org/wiki/Functional_programming), for the sake
    of readability it is best used sparingly in most instances.
  prefs: []
  type: TYPE_NORMAL
- en: '![A nested function call stack.](assets/ppdw_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. A nested function call stack
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Refactoring for Fun and Profit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve explored some of the key principles and mechanisms for refactoring
    our code, let’s see how it can be used to improve the clarity of some of our scripts
    from previous chapters. As we move through the follwoing examples, remember that
    choices about what to refactor and how (as with *any* kind of editing process)
    are partly a matter of preference and style. To that end, I’ll describe the reasoning
    behind my choices below each example; you may find these to be useful models when
    it comes to developing your *own* refactoring practice.
  prefs: []
  type: TYPE_NORMAL
- en: A Function for Identifying Weekdays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Example 7-5](ch07.html#weekday_rides), we created a small script designed
    to read in our [Citi Bike rides data](https://s3.amazonaws.com/tripdata/index.html)
    and output a new file containing only the rides that took place on a weekday.
    While there was nothing fundamentally wrong with the approach we used in that
    example, I think it is a good candidate for refactoring for a couple of reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the existing script relies on a couple of ugly and not-very-descriptive
    function calls. The first one is required to convert the available date string
    into an actual `datetime` format that Python can evaluate meaningfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, though the built-in `weekday()` method is reasonably straightforward
    (although it might be better named `dayofweek()`), we have to compare it to the
    “magic number” `4` in order to determine if `the_date` is, in fact, a weekday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Overall, I think these parts of the code would be more readable without these
    relatively obscure formats and comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: Second, checking whether a particular date-like string is a Monday-through-Friday
    weekday seems like the kind of thing that might come up reasonably frequently
    in data wrangling work. If I encapsulate this task into a custom function, I can
    easily reuse it in other scripts.
  prefs: []
  type: TYPE_NORMAL
- en: To see how I’ve gone about refactoring the [Example 7-5](ch07.html#weekday_rides)
    script, take a look at [Example 8-7](#weekday_rides_refactored).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-7\. weekday_rides_refactored.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_structuring_and_refactoring_your_code_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping our top-level script into a function called `main()` is a Python convention
    that also serves an important functional purpose. Because the computer reads Python
    top to bottom, if we *don’t* wrap this code in a function, then the computer won’t
    have gotten to the definition of `is_weekday()` when it reaches `if is_weekday(a_row['starttime'])`
    and will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_structuring_and_refactoring_your_code_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `is_weekday()` function to handle the finicky details of converting
    our date string to both a “real” date and its weekday value. The descriptive function
    name conveys what is happening at a high level without forcing the reader to wade
    through the particulars.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_structuring_and_refactoring_your_code_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The computer still reads from top to bottom as usual, but while it encounters
    both the `main()` and `is_weekday()` function definitions first, we aren’t asking
    it to execute anything until the very bottom of the script.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, while the bulk of the code (and even many of the comments) in
    [Example 8-7](#weekday_rides_refactored) are the same as those in [Example 7-5](ch07.html#weekday_rides),
    things have been reorganized in a way that makes the `main()` part of the program
    much more concise and readable. Sure, if the programmer *wants* to know the details
    of how weekdays are identified, the specifics are available right there in the
    `is_weekday()` function definition. Otherwise, though, they can just read through
    the primary part of the script and very easily confirm that it is doing what the
    outline alleges.
  prefs: []
  type: TYPE_NORMAL
- en: Metadata Without the Mess
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Example 7-7](ch07.html#xls_meta_and_date_parsing), we built on code from
    Examples [4-6](ch04.html#xls_parsing) and [7-6](ch07.html#xls_meta_parsing) to
    create a single script that both effectively interpreted Microsoft Excel dates
    *and* split our source data file into a metadata text file and a structured *.csv*.
    While the resulting script did everything we needed, its code became leggy and
    hard to read, full of hard-to-interpret conditionals and obscure date-formatting
    function calls.
  prefs: []
  type: TYPE_NORMAL
- en: Here we can clean things up a little bit by handling the formatting of the different
    types of row content (for the *.csv* or the *.txt* file, respectively) in separate
    functions. This requires rearranging (and clarifying) our script’s logic somewhat.
    It also illustrates some of the challenges that can arise when it comes to getting
    all the requisite information *into* our custom functions. The approach outlined
    in [Example 8-8](#xls_meta_and_date_parsing_refactored) illustrates my currently
    preferred way of handling these issues.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-8\. xls_meta_and_date_parsing_refactored.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_structuring_and_refactoring_your_code_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Though they should be used sparingly, creating a *global* variable here called
    `the_datemode` means its value can be accessed by *any* function (the `global`
    here refers to its scope). Note that in Python, global variables cannot be assigned
    a value in the same line they are declared, which is why this has been done across
    two separate code statements.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_structuring_and_refactoring_your_code_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we *didn’t* create a global variable, for the date mode, we
    would have to pass it as another argument to `create_table_row()`, which feels
    a bit incongruous.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you compare [Example 8-8](#xls_meta_and_date_parsing_refactored) with [Example 8-7](#weekday_rides_refactored),
    you’ll see they have several key features in common: instead of code that executes
    automatically, everything in this script has been compartmentalized into functions,
    with the conventional `main()` function call protected by an `if __name__ == "__main__":`
    conditional. This example also overlaps with [Example 7-7](ch07.html#xls_meta_and_date_parsing)
    almost perfectly: the includes are all the same, and while it has been rearranged
    into three functions instead of a single, linear script, most of the code is almost
    identical.'
  prefs: []
  type: TYPE_NORMAL
- en: Part of what I want to illustrate here is that refactoring your code doesn’t
    have to be an enormous undertaking, but the results are invaluable. As a program,
    the structure of [Example 8-8](#xls_meta_and_date_parsing_refactored) is now basically
    all logic and no particulars—fiddly details are handled by our new functions.
    If I suddenly needed to download and parse a new data series from the FRED database,
    I would feel comfortable just throwing it at this script to see what happens,
    because if there are problems, *I know exactly where to go to fix them*. Instead
    of having to wade through the entire program, any formatting issues that might
    arise with a new data source are almost certainly going to be the result of code
    in either `create_table_row()` or `create_meta_text()`—and even then, problems
    will probably only appear in one or the other. That means that in order to adapt
    this script to work with new (similar) data sources, I’ll probably only have to
    look at (maybe) a dozen lines of code. That’s certainly better than wading through
    close to 100!
  prefs: []
  type: TYPE_NORMAL
- en: In other words, while refactoring your data wrangling scripts usually doesn’t
    mean *writing* too much more code, it can really save you from *reading* more
    than you need to when you want to use, reuse, or adapt it later—and that’s yet
    another way that Python can help you scale your data wrangling work.
  prefs: []
  type: TYPE_NORMAL
- en: Given all the reasons *not* to use global variables, why did I ultimately decide
    to use one here? First, there is only *one* possible value for `source_workbook.datemode`,
    because there is only one `datemode` attribute per Excel spreadsheet. So even
    if a particular workbook had 20 different sheets each containing 100 columns of
    data, there would still only be one, single, unchanging value for `datemode` for
    all of them. So conceptually, the value of `datemode` is actually “global”; it’s
    reasonable that the variable we use to store this value would be as well. And
    since the value of `datemode` will never need to be updated within the script,
    there is less risk of retrieving an unexpected value from it.
  prefs: []
  type: TYPE_NORMAL
- en: As with all writing, however, these choices are partly a matter of taste—and
    even our own taste can change over time. While at first I liked the symmetry of
    creating one function to “build” each row of table data and another function to
    “build” each line of metadata text, there’s also something to be said for breaking
    that symmetry and avoiding the use of the global `datemode` variable altogether,
    as shown in [Example 8-9](#xls_meta_and_date_parsing_refactored_again).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-9\. xls_meta_and_date_parsing_refactored_again.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_structuring_and_refactoring_your_code_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Although I no longer pass parallel information to a custom function in order
    to generate the table-type and metadata output files, abandoning that symmetry
    prevents my having to create a global variable.
  prefs: []
  type: TYPE_NORMAL
- en: Which of these is the better solution? As with all writing, it depends on your
    preferences, your use cases, and your *audience*. Some groups or institutions
    will be “opinionated” about the choice to use—or avoid—global variables; some
    will feel that shorter solutions are preferable, while others will prize structural
    symmetry, or reusability. While [Example 8-9](#xls_meta_and_date_parsing_refactored_again)
    sacrifices some structural symmetry, it *generates* a function that may be more
    broadly reusable. The choice of which is more important is, as always, up to you
    to determine.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting Your Custom Scripts and Functions with pydoc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we’ve taken a thorough but free-form approach to documenting our
    code. There’s nothing wrong with this in principle, especially if it helps ensure
    you actually *do* the documentation in the first place. As your inventory of Python
    scripts (and their potential audience) expands, however, it is useful to be able
    to review your personal collection of custom functions without individually opening
    up and reading through each and every Python file. If nothing else, having lots
    of files open makes it that much more likely that a stray keystroke will introduce
    an error into a function you rely on in lots of other scripts—which is a really
    quick way to ruin your day.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, with just a little bit of formatting we can adapt our existing
    program descriptions and comments to work with a command-line function called
    `pydoc`. This will let us print out our script and function descriptions to the
    command line just by providing the relevant filename.
  prefs: []
  type: TYPE_NORMAL
- en: To see this in action, let’s start by refactoring one more script. In this case,
    we’ll revise [Example 7-8](ch07.html#fixed_width_strip_parsing) to make it a little
    bit more concise. In the process, I’ll also update the comments at the top of
    the script (and add some to our new function) to make them compatible with the
    `pydoc` command. You can see what this looks like in [Example 8-10](#fixed_width_string_parsing_refactored).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-10\. fixed_width_strip_parsing_refactored.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_structuring_and_refactoring_your_code_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: By starting and ending the file and the `convert_to_columns()` function descriptions
    with a set of three double quotation marks (`"""`), they visually stand from the
    rest of the comments in the file and will now be accessible to `pydoc` by running
    the following in a terminal:^([9](ch08.html#idm45143398618416))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will display all of the file and function descriptions within the command-line
    interface (use the arrow keys to scroll up and down, or the space bar to move
    an entire “page” down at once). To exit the documentation and return to the command
    line, just hit the q key.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_structuring_and_refactoring_your_code_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of writing a unique line of code to pull each column of data out of
    a given line of text, I’ve put all the start/end values for each column into a
    list of [Python `tuple`s](http://docs.python.org/3.3/library/stdtypes.html?highlight=tuple#tuples),
    which are essentially unchangeable lists.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_structuring_and_refactoring_your_code_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: By passing the column start/end information to the `convert_to_columns()` function
    along with each line of data, we can use a `for...in` loop to convert the text
    to columns. This makes our main script easier to read *and* results in a function
    that could be reused with *any* line of text we need to split into columns, as
    long as we pass in the start/end index pairs in the correct format. I’ve even
    added a flag value called `zero_index`, which lets us use this function with start/end
    pairs that consider zero to be the first position (the default value assumes—as
    this dataset does—that the first position is “1”).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that in addition to viewing the documentation for the whole file, it is
    possible to use `pydoc` to view the documentation for a single function (for example,
    the `convert_to_columns()` function) by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: and moving through/exiting its documentation in the same way as you did for
    the entire file.
  prefs: []
  type: TYPE_NORMAL
- en: The Case for Command-Line Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refactoring one long script into a series of functions isn’t the only way we
    can make our data wrangling code more reusable. For multistep data wrangling processes
    (such as those that involve downloading data, like [Example 5-8](ch05.html#downloading_turnstile_index),
    or converting PDF images to text, like [Example 4-16](ch04.html#pdf_parsing)),
    breaking up our *code* into multiple scripts is yet another way to save time and
    effort. For one thing, this approach lets us minimize how often we do resource-intensive
    tasks, like downloading data or actually converting PDF pages to images. Even
    more, these tasks tend to be pretty rote—it doesn’t make much difference *what*
    data we’re downloading or *which* PDF we’re converting to images; our script will
    pretty much always be doing the same thing. As a result, all we need are a few
    additional tricks to transform our currently bespoke data wrangling scripts into
    standalone code that we can reuse as is—over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s look back at [Example 5-8](ch05.html#downloading_turnstile_index).
    In this script, the main thing we’re doing is downloading the contents of a web
    page; it’s just that in this instance we’ve “hard-coded” the [target file](http://web.mta.info/developers/turnstile.html)
    specifically. Likewise, the code that downloaded the XML and JSON files in [Example 5-1](ch05.html#data_download)
    was almost identical—the only real difference was the source URLs and the filenames
    of the local copies. If there was a way that we could refactor these scripts so
    that the *whole thing* acted more like a function, that could potentially save
    us a lot of time and effort in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, this is very achievable with standalone Python files, thanks to
    the built-in *argparse* Python library, which lets us write our scripts to both
    require—and use—arguments passed in from the command line. Thanks to *argparse*,
    we don’t need to write a new script for every individual web page we want to download,
    because it lets us specify both the target URL *and* the name of our output file
    right from the command line, as shown in [Example 8-11](#webpage_saver).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-11\. webpage_saver.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_structuring_and_refactoring_your_code_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Here we’re assigning the parameter name we can use to access the values passed
    via the command-line from within our script. The help text is important! Be descriptive
    but concise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we *should* have an easy way to download any web page to our device, without
    having to write a script for every unique URL. For example, if we run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'we will get exactly the same result as in [Example 5-8](ch05.html#downloading_turnstile_index),
    but we can *also* run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: to get the Citi Bike operating reports without having to even *open*, much less
    modify, our script. Handy, no?
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Using command-line arguments with your task-specific scripts can save you time,
    but not if you end up copying complex URLs into your command-line interface character
    by character. To make things simpler, here’s a quick overview of how to copy/paste
    to the command line, depending on your operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: Linux (including Chromebook)
  prefs: []
  type: TYPE_NORMAL
- en: Highlight the URL/text you want to copy, then context-click and select Copy.
    In your command-line window, just click and it will automatically paste.
  prefs: []
  type: TYPE_NORMAL
- en: Windows/Macintosh
  prefs: []
  type: TYPE_NORMAL
- en: Highlight the URL/text you want to copy, then context-click and select Copy.
    In your command-line window, context-click again and select Paste.
  prefs: []
  type: TYPE_NORMAL
- en: Where Scripts and Notebooks Diverge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now you may have noticed that in the preceding sections, I *didn’t* describe
    a way to get arguments from the command line into a Jupyter notebook, nor have
    I talked much about generating and interacting with script and function documentation
    for Jupyter notebooks, either. This is not because these things are impossible
    but because Jupyter notebooks are designed to let you interact with Python differently
    than standalone scripts, and some of these concepts are less applicable to them.
    As someone who started working with Python before Jupyter (formerly IPython) notebooks
    existed, my bias is still toward standalone scripts for the majority of my rubber-to-the-road
    Python data wrangling. While notebooks are (generally) great for testing and tweaking
    chunks of code, I almost always end up migrating back to standalone scripts once
    I’ve identified the approach that works for a particular data wrangling task.
    This is mostly because as I move further along in a project, I often get impatient
    even with the process of opening and modifying a script unless I have to—much
    less launching a webserver or waiting for a web page to load (I might not even
    have an internet connection!). These are some of the reasons why I favor using
    command-line arguments and standalone scripts for common, straightforward tasks.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ll soon see, however, the interactivity of Jupyter notebooks makes them
    somewhat superior to standalone Python scripts when it comes to experimenting
    with—and especially sharing—the data analysis and visualization portion of our
    data wrangling work. As a result, you’ll find more references to Jupyter notebooks
    in particular as we turn to those topics in Chapters [9](ch09.html#chapter9) and
    [10](ch10.html#chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve taken a bit of a break from data wrangling per se to
    revisit some of our prior work where the code had gotten unwieldy. Through the
    process of refactoring, we explored how we can reorganize code that *works* into
    code that *works well*, because it is more readable and reusable. As our data
    wrangling projects evolve, this will help us build up and make use of our own
    collection of custom functions that meet our own particular data wrangling needs.
    Similarly, by applying a bit more structure to our documentation, we made it accessible—and
    useful—right from the command line so that we can find the script or function
    that we’re looking for without opening a single script. And in a similar vein,
    we applied that refactoring logic to our scripts so that we can customize their
    functionality without having to open *them*, either!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll return to our focus on data with an overview of some
    of essential data analysis techniques. After that, in [Chapter 10](ch10.html#chapter10)
    we’ll (briefly) cover the core visualization approaches that will help you understand
    and present your data effectively so that you can better share your data wrangling
    insights with the world!
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch08.html#idm45143401447136-marker)) In this case, the programmer is actually
    considered the “user.”
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch08.html#idm45143402674080-marker)) Truly, good documentation will save
    your $h!t sometimes.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch08.html#idm45143402658928-marker)) Doing these things is definitely
    possible but is well beyond the scope of most data wrangling activities, and therefore
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch08.html#idm45143401186992-marker)) Technically, *parameters* describe
    the variable names assigned in the function definition, while *arguments* are
    the actual values that are passed to the function when it is called. In practice,
    though, these terms are often used interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch08.html#idm45143401184608-marker)) So-called “statically typed” programming
    languages will actually complain *before* your code runs if you’ve passed the
    wrong data type to a function or method.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch08.html#idm45143401170704-marker)) There’s that `dtype='string'` again!
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch08.html#idm45143400844448-marker)) This term is also why the forum is
    called *Stack* Exchange.
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch08.html#idm45143400593680-marker)) You can find a helpful description/demonstration
    of the reasoning behind this convention at [*https://freecodecamp.org/news/if-name-main-python-example*](https://freecodecamp.org/news/if-name-main-python-example).
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch08.html#idm45143398618416-marker)) The actual structure/formatting I’ve
    used here a mashup of different styles derived from the guide at [*https://realpython.com/documenting-python-code/#documenting-your-python-code-base-using-docstrings*](https://realpython.com/documenting-python-code/#documenting-your-python-code-base-using-docstrings).
    While using a standard approach may matter if you are working with a large team,
    if you are working alone or in a small group, find a style that works for you!
  prefs: []
  type: TYPE_NORMAL
