- en: Chapter 8\. Structuring and Refactoring Your Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章。结构化和重构你的代码
- en: Before we move on to the analyzing and visualizing aspects of data wrangling,
    we’re going to take a brief “detour” to discuss some strategies for making the
    most of everything we’ve done so far. In the last few chapters, we’ve explored
    how to access and parse data from a variety of data formats and sources, how to
    evaluate its quality in practical terms, and how to clean and augment it for eventual
    analysis. In the process, our relatively simple programs have evolved and changed,
    becoming—inevitably—more convoluted and complex. Our `for` loops now have one
    or (more) nested `if` statements, and some of those now have apparently “magic”
    numbers embedded in them (like our `the_date.weekday() <= 4` in [Example 7-5](ch07.html#weekday_rides)).
    Is this just the price of more functional code?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行数据整理的分析和可视化工作之前，我们将简要“绕道”，讨论一些关于如何充分利用我们迄今为止所做的一切的策略。在过去的几章中，我们探讨了如何从各种数据格式和来源中访问和解析数据，如何从实际角度评估其质量，以及如何清理和增强数据以便进行最终的分析。在这个过程中，我们相对简单的程序已经发生了演变和变化，不可避免地变得更加复杂和深奥。我们的`for`循环现在有了一个或者（更多）嵌套的`if`语句，而其中一些现在嵌入了明显的“魔法”数字（比如我们在
    [示例 7-5](ch07.html#weekday_rides) 中的 `the_date.weekday() <= 4`）。这只是更功能化代码的代价吗？
- en: Remember that commenting our code can do a lot to help keep the logic of our
    scripts understandable, both to potential collaborators and our future selves.
    But it turns out that detailed documentation (much as I love it) isn’t the only
    way that we improve the clarity of our Python code. Just like other types of written
    documents, Python supports a range of useful mechanisms for structuring and organizing
    our code. By making judicious use of these, we can make it simpler to both use
    and reuse our programming work down the line.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，注释我们的代码可以在很大程度上帮助我们保持脚本逻辑对潜在合作者和我们未来自己的可理解性。但事实证明，详细的文档（尽管我很喜欢）并不是提高Python代码清晰度的唯一方式。就像其他类型的书面文件一样，Python支持一系列有用的机制来结构化和组织我们的代码。通过明智地利用这些机制，我们可以使将来更加简单地使用和重用我们的编程工作。
- en: 'So in this chapter, we’re going to go over the tools and concepts that will
    allow us to refine our code in such a way that it is both readable and reusable.
    This process, known as *refactoring*, exemplifies yet another way that using Python
    for our data wrangling work makes it possible to get more output for our effort:
    while we can rely on the functionality that *someone else*’s library offers when
    we need to, we can *also* create new coding “shortcuts” that are customized to
    exactly our own preferences and needs.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将讨论工具和概念，使我们能够以既可读又可重用的方式优化我们的代码。这个过程被称为*重构*，它展示了使用Python进行数据整理工作的又一种方式，即使我们在需要时可以依赖于*别人*的库所提供的功能，我们也可以*同时*创建新的编码“捷径”，这些捷径可以完全按照我们自己的偏好和需求定制。
- en: Revisiting Custom Functions
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视自定义函数
- en: When we were covering the Python fundamentals way back in [Chapter 2](ch02.html#chapter2),
    one of the things we touched on was the concept of “custom” or *user-defined*
    functions.^([1](ch08.html#idm45143401447136)) In [Example 2-7](ch02.html#greet_me),
    we saw how a custom function could be used to encapsulate the simple task of printing
    out a greeting when a particular name was provided—but of course we can create
    custom functions that are as simple or as complex as we like. Before we dive into
    the mechanics of writing our own custom functions, however, let’s take a step
    back and think about which design considerations can best help us decide *when*
    writing a custom function is likely to be most helpful. Of course, like all writing,
    there are few hard-and-fast rules, but what follows are a few heuristics that
    can help you decide when and how refactoring is likely to be worth it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第二章](ch02.html#chapter2)远古时期介绍Python基础知识时，我们碰到的一个概念是“定制”或*用户定义*函数。^([1](ch08.html#idm45143401447136))
    在 [示例 2-7](ch02.html#greet_me) 中，我们看到了一个自定义函数如何用于封装当提供特定名称时打印问候语的简单任务——当然，我们可以创建简单或复杂得多的自定义函数。然而，在我们深入探讨编写自己的自定义函数的机制之前，让我们退后一步，思考哪些设计考量最有助于我们决定*何时*编写自定义函数可能最有帮助。当然，就像所有写作一样，没有多少硬性规则，但接下来的一些启发法则可以帮助您决定何时以及如何重构可能是值得的。
- en: Will You Use It More Than Once?
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你会多次使用它吗？
- en: Like variables, one way to identify parts of your code that could benefit from
    being repackaged into custom functions is to look for any particular task that
    gets done more than once. From validating input to formatting output (as we did,
    say, in [Example 7-7](ch07.html#xls_meta_and_date_parsing)) and everything in
    between, if your current script includes lots of fiddly conditionals or repetitive
    steps, that’s an indicator that you may want to think about designing some custom
    functions. Keep in mind, too, that the repetition you’re considering doesn’t need
    to exist within a single script for refactoring to be worthwhile. If you find
    that there are particular tasks that you’re doing frequently *across* the scripts
    that you’re writing (for example, testing to see if a given day is a weekday,
    as we did in [Example 7-5](ch07.html#weekday_rides)), you can always put the custom
    function into an external script and include it anywhere you might need it, just
    as we did with our credentials files in [Chapter 5](ch05.html#chapter5).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 像变量一样，识别出可以从中受益于重新打包成自定义函数的代码部分的一种方法是查找任何被多次执行的特定任务。从验证输入到格式化输出（比如我们在[示例 7-7](ch07.html#xls_meta_and_date_parsing)中所做的），以及其中的一切内容，如果你当前的脚本包含大量繁琐的条件语句或重复的步骤，那就表明你可能需要考虑设计一些自定义函数。同时要记住，你考虑的重复并不一定需要存在于单个脚本中，重构仍然是值得的。如果你发现你经常在你写的脚本中频繁地执行某些特定任务（例如，测试给定日期是否为工作日，就像我们在[示例 7-5](ch07.html#weekday_rides)中所做的那样），你可以将自定义函数放入外部脚本，并在可能需要的任何地方引用它，就像我们在[第 5
    章](ch05.html#chapter5)中处理凭据文件时所做的那样。
- en: Is It Ugly and Confusing?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是不是又丑又令人困惑？
- en: Documenting your work as you go is a gift to both current collaborators and
    your future self.^([2](ch08.html#idm45143402674080)) At the same time, thoroughly
    commenting your code—especially if you include not just the *how* but the *why*
    of your approach, which I still recommend—can eventually make it a bit unwieldy
    to read. Creating really comprehensible code, then, is a balancing act between
    providing enough detail to be comprehensive while *also* being sufficiently concise
    so your documentation actually gets read.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行工作的同时记录你的工作是对当前合作者和未来自己的一种礼物^([2](ch08.html#idm45143402674080))。同时，彻底地注释你的代码——特别是如果你不仅包含*如何*而且*为什么*采取这种方法的解释，我仍然建议——最终可能会使代码变得有些难以管理。因此，创建真正易于理解的代码，实际上是在提供足够详细的同时也足够简洁，以便你的文档实际上被阅读到。
- en: 'Packaging relevant bits of code into custom functions is actually a key way
    you can help thread this needle: like variables, custom functions can (and should!)
    have descriptive names. Just by *reading* the function name, whoever is looking
    at your code will get some essential information about what is happening, without
    your needing to add multiple lines of descriptive comments immediately around
    it. If the function name is descriptive enough and/or a particular reader doesn’t
    need more detail right away, they can just move on. Meanwhile, they’ll still be
    able to find your lovely, descriptive documentation for that function if they
    need it—neatly tucked away in another part of the program (or another file altogether).
    This means that the *inline* comments for your main script can stay relatively
    succinct without sacrificing the completeness of your documentation.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将相关的代码片段打包成自定义函数实际上是帮助你解决这个难题的关键方法：像变量一样，自定义函数可以（而且应该！）具有描述性的名称。仅仅通过*读取*函数名称，查看你的代码的人就会获得关于正在发生的事情的一些基本信息，而无需立即在其周围添加多行描述性评论。如果函数名称足够描述性，或者某个读者暂时不需要更多细节，他们可以直接继续进行。与此同时，如果他们需要，他们仍然可以找到你那些可爱的、描述性的函数文档——这些文档被整齐地放在程序的另一部分（或者完全是另一个文件）中。这意味着你的主脚本的*内联*注释可以保持相对简洁，而不会牺牲文档的完整性。
- en: Do You Just Really **Hate** the Default Functionality?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你只是真的**讨厌**默认功能吗？
- en: OK, so this is maybe not the *best* reason to write a custom function, but it
    is a real one. Over time, you may find that there are tasks you need to complete
    over and over again as part of your data wrangling endeavors, and that there’s
    something about the existing functions and libraries that just *bugs* you. Maybe
    it’s a function name that you find confusing so you *always* have to remind yourself
    precisely what it’s called. Or maybe there’s a parameter you consistently forget
    to add that just makes everything more difficult (I’m looking at you, `pd.read_csv()`,
    with your `dtype='string'` parameter!). If you’re working alone or in a small
    team, it’s perfectly fine to write custom functions that help make your life easier
    just because they *do*. You don’t need a grand rationale. If it will make your
    life easier, go ahead! That’s the power of being the programmer.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，也许这并不是编写自定义函数的*最佳*理由，但这是一个真实存在的理由。随着时间的推移，你可能会发现，在数据整理工作中，有一些你需要反复完成的任务，而现有的函数和库中总是有一些让你感到*困扰*的地方。也许是一个你觉得名称令人困惑的函数名，因此你*总是*不得不准确地记住它叫什么。或者可能是有一个你总是忘记添加的参数，这使得一切都变得更加困难（我在看你，`pd.read_csv()`，带上你的`dtype='string'`参数！）。如果你是独自工作或是在一个小团队中，编写帮助简化生活的自定义函数完全没问题，因为它们*确实*有用。你不需要一个宏伟的理由。如果它能让你的生活变得更轻松，那就去做吧！这就是作为程序员的力量。
- en: Of course, there are some limits to this. Unless you want to take a much more
    formal and involved approach to writing Python code, you can’t very effectively
    do things like define a new function that has the same name as an existing function
    or make operators like `+` or `-` behave differently.^([3](ch08.html#idm45143402658928))
    However, if you just really wish that an existing function you have to use all
    the time worked a *little* bit differently, go with it—just make sure you document
    the heck out of your version!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这也有一些限制。除非你想以更正式和深入的方式编写Python代码，否则你不能有效地做一些事情，比如定义一个与现有函数同名的新函数，或者让像`+`或`-`这样的运算符表现得有所不同。^([3](ch08.html#idm45143402658928))
    但是，如果你只是希望一个经常使用的现有函数工作方式略有不同，那就去做吧——只要确保你充分记录你的版本！
- en: Understanding Scope
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解作用域
- en: 'Now that we’ve gone over some of the *reasons* you might refactor your code
    with custom functions, it’s time to discuss the mechanics a little bit. Probably
    the most important concept to understand when you start writing custom functions
    is *scope*. Although we haven’t used this term before, *scope* is something that
    we’ve actually been working with since we declared our first variables way back
    in [“What’s in a name?”](ch02.html#whats_in_a_name). In that example, we saw that
    we could:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了一些可能会使用自定义函数重构代码的*理由*，是时候稍微讨论一下具体的实现方式了。当你开始编写自定义函数时，可能最重要的概念就是*作用域*。虽然我们以前没有用过这个术语，但*作用域*实际上是我们自从在[“名字的背后”](ch02.html#whats_in_a_name)中声明第一个变量以来一直在使用的概念。在那个例子中，我们看到我们可以：
- en: Create and assign a value to a variable (`author = "Susan E. McGregor"`).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并赋值给一个变量（`author = "Susan E. McGregor"`）。
- en: Use that variable to refer to its contents later and pass its value to a function
    (`print(author)`).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用该变量后面引用其内容并将其值传递给一个函数（`print(author)`）。
- en: 'At the same time, we know that if we created a program that simply consisted
    of the line:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们知道，如果我们创建了一个仅仅包含以下一行代码的程序：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: we’d get an error, because in the universe of our one-line script, there is
    no memory-box labeled `author`. So Python chucks an error at us and declines to
    go any further.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会得到一个错误，因为在我们这个仅有一行的脚本的宇宙中，没有标记为`author`的内存盒。因此，Python会向我们抛出一个错误，并拒绝继续执行。
- en: When we talk about *scope* in programming, what we’re actually talking about
    is the current “universe” from the perspective of a particular piece of code.
    An individual script has a scope that evolves as each line of code is read by
    the computer, from top to bottom, which is what leads to the (very much expected)
    behaviors of the scripts in Examples [8-1](#no_scope) and [8-2](#author_scope).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论编程中的*作用域*时，我们实际上是在讨论从特定代码片段的视角看当前“宇宙”的范围。每个脚本都有一个作用域，在计算机逐行读取每行代码时，从顶部到底部逐步演变，这就是导致例子[8-1](#no_scope)和[8-2](#author_scope)中脚本（非常预期的）行为的原因。
- en: Example 8-1\. No `author` variable in scope
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-1\. 在作用域中没有`author`变量
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Example 8-2\. An `author` variable in scope
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-2\. 在作用域中的`author`变量
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Just as every time we create a new variable, a new “box” is created in the
    computer’s memory, each time we define a new custom function, a new little universe,
    or *scope*, is created for it as well. This means that when we use custom functions,
    we are compartmentalizing our code not just *visually* but *logically* and *functionally*.
    This means that we can treat our *own* custom functions much the way we do the
    built-in Python methods and library functions that we’ve been using throughout
    this book: as “recipes” to which we provide “ingredients” and which return to
    us some value or freshly made Python object in return. The only difference is
    that with custom functions, we are the chefs!'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每当我们创建一个新变量时，计算机内存中都会创建一个新的“盒子”一样，每当我们定义一个新的自定义函数时，也会为其创建一个新的小宇宙或*作用域*。这意味着当我们使用自定义函数时，我们不仅在视觉上而且在逻辑上和功能上将我们的代码分隔开。这意味着我们可以像对待我们一直在本书中使用的内置Python方法和库函数那样对待我们*自己*的自定义函数：作为我们提供“配料”并返回某个值或新制作的Python对象的“食谱”。唯一的区别在于，使用自定义函数时，我们就是厨师！
- en: To get a handle on what this all means in practice, let’s revisit [Example 2-7](ch02.html#greet_me)
    from [Chapter 2](ch02.html#chapter2) but with a couple of tweaks, as shown in
    [Example 8-3](#greet_me_revisited).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在实践中理解这一切的含义，让我们重新访问[示例 2-7](ch02.html#greet_me)来自[第二章](ch02.html#chapter2)，但稍作调整，如[示例 8-3](#greet_me_revisited)所示。
- en: Example 8-3\. greet_me_revisited.py
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-3\. greet_me_revisited.py
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This yields the following output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Because any custom function automatically gets its own scope, that function
    can only “see” the variables and values that are explicitly passed into it. In
    turn, the values and variables inside that function are effectively “hidden” from
    the primary script. One consequence of this is that when we write custom functions,
    we don’t need to worry about what variable names have already been used in the
    primary script, or vice versa. As a result, we need to define fewer unique variable
    names in general, which is helpful as we begin to write longer and more complex
    scripts. It *also* means that once we have a custom function working as we expect,
    we can use—and even modify—the details of how it functions *without* having to
    make adjustments to the variables and functions in the surrounding script.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因为任何自定义函数都会自动获得其自己的作用域，所以该函数只能“看到”显式传递给它的变量和值。反过来，在该函数内部的值和变量实际上是从主脚本中“隐藏”的。这一结果之一是，当我们编写自定义函数时，我们无需担心主脚本中已经使用了哪些变量名，反之亦然。因此，我们通常需要更少地定义唯一的变量名，这在我们开始编写更长和更复杂的脚本时非常有帮助。它*还*意味着一旦我们的自定义函数按预期工作，我们可以使用甚至修改其功能细节*而不*需要调整周围脚本中的变量和函数。
- en: Defining the Parameters for Function “Ingredients”
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义函数“配料”的参数
- en: We already have a fair amount of experience with providing “ingredients” (officially
    known as *arguments*) to the methods and functions that come built into Python,
    or that we’ve had access to through the many libraries we’ve used so far. As we
    begin to write custom functions, however, we need to explore in more detail what
    the process is for defining the *parameters* that those functions will accept.^([4](ch08.html#idm45143401186992))
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了相当多的经验，提供给Python内置方法和函数（正式称为*参数*）或者我们迄今为止使用的许多库提供的“配料”。然而，当我们开始编写自定义函数时，我们需要更详细地探索定义这些函数将接受的*参数*的过程。^([4](ch08.html#idm45143401186992))
- en: 'First, know that—unlike some programming languages—Python doesn’t require (or
    even really allow) you to *insist* that a function’s parameters have specific
    data types.^([5](ch08.html#idm45143401184608)) If someone wants to pass entirely
    the wrong types of data into your function, they can absolutely do that. As the
    function author, then, it’s up to you to decide whether and how you want to confirm
    (or *validate*) the appropriateness of the arguments or “ingredients” that have
    been passed into your custom functions. In principle, there are three ways to
    approach this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要知道的是，与某些编程语言不同，Python不需要（甚至实际上不允许）*坚持*函数的参数具有特定的数据类型。^([5](ch08.html#idm45143401184608))
    如果有人想要将完全错误类型的数据传递给您的函数，他们完全可以这样做。因此，作为函数的作者，您需要决定是否以及如何确认（或*验证*）传递给您自定义函数的参数或“配料”的适当性。原则上，有三种方法可以处理这个问题：
- en: Check the data types of all the arguments that have been passed into your function
    and complain to the programmer if you find something you don’t like.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查已传递到函数中的所有参数的数据类型，如果发现不喜欢的内容，请向程序员提出投诉。
- en: Wrap your code in [Python’s `try...except` blocks](https://w3schools.com/python/python_try_except.asp)
    so that you can capture certain types of errors without halting the entire program.
    You can also use this to customize the message to the programmer about what went
    wrong.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的代码包装在[Python 的 `try...except` 块](https://w3schools.com/python/python_try_except.asp)中，以便您可以捕获某些类型的错误而不会停止整个程序。您还可以使用这个来自定义向程序员传达发生了什么错误的消息。
- en: Not worry about it and let the user of the function (in other words, the programmer)
    work through any problems using the default Python error messages.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不用担心它，让函数的用户（换句话说，程序员）通过使用默认的 Python 错误消息来解决任何问题。
- en: 'While it may seem a bit laissez-faire, my primary recommendation at this point
    is actually to go with option three: don’t worry about it. Not because errors
    won’t happen (they will—you can revisit [“Fast Forward”](ch02.html#greet_me_ff)
    if you need a refresher on what some of them look like) but because our primary
    interest here is wrangling data, not writing enterprise-level Python. As with
    the scripts we wrote in [Chapter 4](ch04.html#chapter4), we want to strike a balance
    between what we try to handle programmatically and what we rely on the programmer
    (whoever they may be) to investigate and handle for themselves. Since the programs
    we’re writing won’t bring down a website or corrupt the only copy of our data
    if they work incorrectly, not trying to anticipate and handle every possible error
    that might arise seems more than reasonable. Of course, if you document your functions
    clearly—a process we’ll look at in more detail in [“Documenting Your Custom Scripts
    and Functions with pydoc”](#documenting_custom_functions)—then other programmers
    will have everything they need to avoid errors in the first place.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这看起来有点随意，但在这一点上，我的主要建议实际上是选择第三种选择：不要担心它。并非因为不会发生错误（它们会发生——如果需要恢复对它们的某些了解，可以重新访问[“快进”](ch02.html#greet_me_ff)），而是因为我们在这里的主要兴趣是处理数据，而不是编写企业级
    Python。与我们在[第 4 章](ch04.html#chapter4)中编写的脚本一样，我们希望在尝试通过程序处理的内容和依赖程序员（无论他们是谁）自行调查和处理之间取得平衡。由于我们编写的程序如果出错不会使网站崩溃或破坏数据的唯一副本，因此似乎不去预料和处理可能出现的每一个错误更为合理。当然，如果您清楚地记录了您的函数——这是我们将在[“使用
    pydoc 记录自定义脚本和函数的详细过程”](#documenting_custom_functions)中更详细地查看的过程，那么其他程序员在首次避免错误方面将拥有一切所需。
- en: What Are Your Options?
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的选择是什么？
- en: Even if we’re not trying to write custom functions for use by thousands of people,
    we can still make them flexible and fully featured. One of the simplest ways to
    do this is to write our functions to solve the most common version of our problem
    but allow optional arguments—like those we’ve seen in *pandas*^([6](ch08.html#idm45143401170704))
    and other libraries—that make them somewhat adaptable. For example, we could modify
    our `greet_me()` function to have a default greeting of “Hello” that can *also*
    be overridden by an optional value passed in by the programmer. This lets us craft
    functions that can be used effectively in multiple contexts. As an example, let’s
    look at the modified version of `greet_me` shown in [Example 8-4](#greet_me_options).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们不试图为数千人使用编写自定义函数，我们仍然可以使它们灵活且功能齐全。其中一个最简单的方法是编写我们的函数来解决问题的最常见版本，但允许像我们在*pandas*^([6](ch08.html#idm45143401170704))和其他库中看到的那样的可选参数，这使它们在某种程度上可以适应。例如，我们可以修改我们的`greet_me()`函数，使其具有默认的问候语“Hello”，*同时*可以被程序员传入的可选值覆盖。这使我们能够编写可以在多种情境下有效使用的函数。例如，让我们看看在[示例
    8-4](#greet_me_options)中显示的`greet_me`的修改版本。
- en: Example 8-4\. greet_me_options.py
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-4\. greet_me_options.py
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, adding optional arguments is really as simple as specifying
    a default value in the function definition; if the programmer passes a different
    value, it will simply overwrite that default when the function is called.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，添加可选参数实际上就是在函数定义中指定默认值；如果程序员传递了不同的值，那么在调用函数时它将简单地覆盖该默认值。
- en: Getting Into Arguments?
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Getting Into Arguments?
- en: 'Providing a default value in the function declaration is not the only way to
    add optional arguments to your custom functions. Python also supports two generic
    types of optional arguments, `*args` and `**kwargs`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数声明中提供默认值并不是向自定义函数添加可选参数的唯一方法。Python 还支持两种通用类型的可选参数，`*args` 和 `**kwargs`：
- en: '`*args`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`*args`'
- en: The `*args` parameter is useful when you want to be able to pass a list of several
    values into a function and giving all of them names and/or default values would
    be tedious. Values passed in as `*args` are stored as a list, so they can be accessed
    within the function by writing a `for...in` loop to go through them one by one
    (e.g., `for arg in args`).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`*args` 参数在想要将多个值列表传递到函数中并且给所有这些值分配名称和/或默认值会很麻烦时非常有用。作为 `*args` 传递的值被存储为列表，因此它们可以通过编写
    `for...in` 循环逐个访问（例如 `for arg in args`）。'
- en: '`**kwargs`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`**kwargs`'
- en: The `**kwargs` parameter is similar to `*args`, except that it allows an arbitrary
    number of keyword arguments to be passed to the function without assigning any
    of them a default value, as we did for `greeting` in [Example 8-4](#greet_me_options).
    Values passed this way can be accessed via the `kwargs.get()` method (e.g., `my_var
    = kwargs.get("greeting")`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`**kwargs` 参数类似于 `*args`，不同之处在于它允许将任意数量的关键字参数传递给函数，而不为它们分配默认值，就像我们在 [示例 8-4](https://wiki.example.org/greet_me_options)
    中为 `greeting` 所做的那样。通过这种方式传递的值可以通过 `kwargs.get()` 方法访问（例如 `my_var = kwargs.get("greeting")`）。'
- en: If using `*args` and `**kwargs` seems like a handy way to (literally) leave
    your options open when writing custom functions, I’m here to tell you that it’s
    *always* better to write custom functions (and scripts!) that solve the problems
    you *have*—not the ones you *think* you might have somewhere down the line. While
    the idea of extreme flexibility may seem attractive at first, it will usually
    lead to spending lots of time *thinking* about “someday” problems, rather than
    *actually* solving the ones right in front of us. And who has time for that? We’ve
    got data to wrangle!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 `*args` 和 `**kwargs` 看起来像是在编写自定义函数时保持选项开放的一种便利方式，我要告诉你的是，最好始终编写解决你*实际问题*的自定义函数（和脚本！），而不是你*认为*可能在未来某处出现的问题。虽然极限灵活性的概念一开始可能看起来很吸引人，但通常会导致花费大量时间*思考*“某天”的问题，而不是*实际*解决我们面前的问题。谁有时间去做那些呢？我们有数据要处理！
- en: Return Values
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回值
- en: So far, our variations on the `greet_me()` function have been of pretty limited
    ambition; we’ve really just used them to print (slightly) customized messages
    to the console. By comparison, the functions we’ve used from external libraries
    have proven incredibly powerful; they can take a humble *.csv* and transform it
    into a *pandas* DataFrame or convert a whole *.xls* file into a collection of
    detailed lists and attributes that capture almost every aspect of this multitiered
    file type. While that level of Python programming is beyond the scope of this
    book, we can still create clean, super-useful custom functions harnessing the
    power of *return values*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对 `greet_me()` 函数的变化目标相当有限；我们实际上只是用它们来打印（稍微）定制的消息到控制台。相比之下，我们从外部库中使用的函数非常强大；它们可以将一个简单的
    *.csv* 文件转换为 *pandas* DataFrame，或者将一个整个 *.xls* 文件转换为详细列表和属性的集合，几乎可以捕捉到这种多层文件类型的每个方面。尽管这种级别的
    Python 编程超出了本书的范围，但我们仍然可以创建干净、超级有用的自定义函数，利用*返回值*的威力。
- en: If parameters/arguments are the “ingredients” in our function “recipes,” then
    *return values* are the final dish—the outputs that get consumed by the rest of
    our program. Really, return values are just pieces of data; they can be *literals*
    (like the string “Hello”), or they can be variables of any data type. They are
    useful because they let us hand off to a function whatever it needs and get back
    the thing that we need, without worrying (at least from the perspective—or *scope*—of
    the main program) how the proverbial sausage gets made. If we restructure the
    basic `greet_me()` function in [Example 8-3](#greet_me_revisited) to use a return
    value, it might look something like [Example 8-5](#make_greeting).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数/参数是我们函数“食谱”中的“成分”，那么*返回值*就是最终的菜肴——被我们程序的其余部分消耗的输出。实际上，返回值只是数据片段；它们可以是*字面值*（如字符串“Hello”），或者它们可以是任何数据类型的变量。它们之所以有用，是因为它们让我们可以将函数需要的任何东西交给它，并获取我们需要的东西，而不必担心（至少从主程序的视角或*作用域*来看）如何制造这个比喻的香肠。如果我们重新构造
    [示例 8-3](https://wiki.example.org/greet_me_revisited) 中基本的 `greet_me()` 函数以使用返回值，它可能看起来像
    [示例 8-5](https://wiki.example.org/make_greeting)。
- en: Example 8-5\. make_greeting.py
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-5\. make_greeting.py
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At first you might be thinking, “How did that help?” While it’s true that our
    main program actually got *longer*, it also arguably became a little bit more
    flexible and easier to understand. Because my `make_greeting()` function *returns*
    the greeting (rather than just printing it directly), I can do more things with
    it. Sure, I can just print it as we did in [Example 8-5](#make_greeting), but
    I can now also store its return value in a variable and do something else with
    it later. For example, I could add the line:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，你可能会想，“这有什么帮助？” 虽然我们的主程序实际上*变得更长*了，但它也可以说变得更加灵活和易于理解。 因为我的`make_greeting()`函数*返回*问候语（而不是直接打印它），我可以对其做更多事情。
    当然，我可以像我们在[示例 8-5](#make_greeting)中所做的那样直接打印它，但我现在也可以将其返回值存储在变量中，并稍后做其他事情。 例如，我可以添加以下行：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While that new message might not seem so exciting, it lets me both compartmentalize
    *some* work into the function (in this case, adding “Hello” to any name) while
    *also* giving me more flexibility about what to do with the output (for example,
    add more text to one but not the other).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这条新消息看起来可能不那么令人兴奋，但它允许我将*一些*工作分隔到函数中（在本例中，向任何姓名添加“你好”），同时*也*为输出提供了更多灵活性（例如，向其中一个添加更多文本而不是另一个）。
- en: Climbing the “Stack”
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攀登“堆栈”
- en: Of course, creating a whole new variable just to store a simple greeting, as
    we did in [Example 8-5](#make_greeting), does seem like a little bit more trouble
    than it’s worth. And in fact, there’s no rule that says we have to stash the output
    from a function in a variable before passing it to another function—we can actually
    “nest” our function calls so that the first function’s *output* just becomes the
    next function’s *input*. This is a strategy that we’ve actually used before, usually
    when we were manipulating strings and passing them to the `print()` function,
    as we did when we added the `strip()` function call to our *.csv* building process
    in [Example 7-8](ch07.html#fixed_width_strip_parsing). But we can do this with
    *any* set of functions, assuming the first one returns what the next one needs.
    To see how this works in practice, take a look at the rewrite of [Example 8-5](#make_greeting)
    shown in [Example 8-6](#make_greeting_no_vars), where I’ve added a new function
    to append the “, how are you?” text to a greeting message.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了存储一个简单的问候语而创建一个全新的变量似乎比它值得的麻烦多了。 实际上，没有规定我们必须在将函数的输出存储在变量中之前将其传递给另一个函数——我们实际上可以“嵌套”我们的函数调用，以便第一个函数的*输出*直接成为下一个函数的*输入*。
    这是一种策略，我们以前实际上已经使用过，通常是在操作字符串并将其传递给`print()`函数时，就像我们在[示例 7-8](ch07.html#fixed_width_strip_parsing)中将`strip()`函数调用添加到我们的*.csv*构建过程中所做的那样。
    但是，我们可以对*任何*一组函数执行此操作，假设第一个函数返回下一个函数需要的内容。 要了解实际操作的工作原理，请查看[示例 8-5](#make_greeting)的重写，显示在[示例 8-6](#make_greeting_no_vars)中，我添加了一个新函数来向问候消息附加“，你好吗？”文本。
- en: Example 8-6\. make_greeting_no_vars.py
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-6\. make_greeting_no_vars.py
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'While the code statement `print(make_greeting(author))` is still fairly easy
    to interpret, things start to get more complicated with `print(add_question(make_greeting(editor)))`,
    which I hope helps illustrate that there’s a limit to the utility of function
    call nesting. The more function calls you nest, the more difficult it is to read
    the code, even though the “order of operations” logic stays the same: the “innermost”
    function is always executed first, and its return value “bubbles up” to become
    the input for the next function. *That* return value then bubbles up to the next
    function, and so on and so forth. In traditional programming terminology this,
    is known as the *function stack*, where the innermost function is the “bottom”
    of the stack and the outermost is the “top.”^([7](ch08.html#idm45143400844448))
    An illustration of the function stack for the last line of [Example 8-6](#make_greeting_no_vars)
    is shown in [Figure 8-1](#nested_function_stack).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码语句`print(make_greeting(author))`仍然相当容易解释，但使用`print(add_question(make_greeting(editor)))`时情况开始变得更加复杂，希望这有助于说明函数调用嵌套的实用性是有限的。
    函数调用嵌套越多，阅读代码就越困难，即使“操作顺序”逻辑保持不变：始终首先执行“最内层”函数，并且其返回值“上升”以成为下一个函数的输入。 *那*个返回值然后上升到下一个函数，依此类推。
    在传统编程术语中，这被称为*函数堆栈*，其中最内层函数是堆栈的“底部”，最外层函数是“顶部”。^([7](ch08.html#idm45143400844448))
    [示例 8-6](#make_greeting_no_vars)的最后一行的函数堆栈示意图如[图 8-1](#nested_function_stack)所示。
- en: While this sort of function-call nesting is at the heart of [an entire programming
    philosophy](https://en.wikipedia.org/wiki/Functional_programming), for the sake
    of readability it is best used sparingly in most instances.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种函数调用嵌套是[整个编程哲学](https://en.wikipedia.org/wiki/Functional_programming)的核心，但出于可读性考虑，在大多数情况下最好谨慎使用。
- en: '![A nested function call stack.](assets/ppdw_0801.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![一个嵌套的函数调用堆栈。](assets/ppdw_0801.png)'
- en: Figure 8-1\. A nested function call stack
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-1\. 一个嵌套的函数调用堆栈
- en: Refactoring for Fun and Profit
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为了乐趣和利润进行重构
- en: Now that we’ve explored some of the key principles and mechanisms for refactoring
    our code, let’s see how it can be used to improve the clarity of some of our scripts
    from previous chapters. As we move through the follwoing examples, remember that
    choices about what to refactor and how (as with *any* kind of editing process)
    are partly a matter of preference and style. To that end, I’ll describe the reasoning
    behind my choices below each example; you may find these to be useful models when
    it comes to developing your *own* refactoring practice.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经探讨了一些重构我们代码的关键原则和机制，让我们看看如何利用它来提高之前章节中一些脚本的清晰度。当我们浏览以下示例时，请记住，关于什么时候以及如何重构（就像*任何*编辑过程一样）部分取决于个人偏好和风格。因此，在每个示例下面，我将描述我的选择背后的推理；当您开发*自己*的重构实践时，您可能会发现这些是有用的模型。
- en: A Function for Identifying Weekdays
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于识别工作日的函数
- en: In [Example 7-5](ch07.html#weekday_rides), we created a small script designed
    to read in our [Citi Bike rides data](https://s3.amazonaws.com/tripdata/index.html)
    and output a new file containing only the rides that took place on a weekday.
    While there was nothing fundamentally wrong with the approach we used in that
    example, I think it is a good candidate for refactoring for a couple of reasons.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 7-5](ch07.html#weekday_rides)中，我们创建了一个小脚本，旨在读取我们的[Citi Bike骑行数据](https://s3.amazonaws.com/tripdata/index.html)，并输出一个仅包含工作日骑行的新文件。虽然在那个示例中我们所使用的方法本质上没有什么问题，但出于几个原因，我认为它是重构的一个好候选项。
- en: 'First, the existing script relies on a couple of ugly and not-very-descriptive
    function calls. The first one is required to convert the available date string
    into an actual `datetime` format that Python can evaluate meaningfully:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，现有脚本依赖于一些笨拙且不太描述性的函数调用。第一个调用是将可用日期字符串转换为Python可以有意义地评估的实际`datetime`格式所必需的：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Similarly, though the built-in `weekday()` method is reasonably straightforward
    (although it might be better named `dayofweek()`), we have to compare it to the
    “magic number” `4` in order to determine if `the_date` is, in fact, a weekday:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，尽管内置的`weekday()`方法相对直观（尽管它可能更好地命名为`dayofweek()`），我们必须将其与“魔术数字”`4`进行比较，以确定`the_date`实际上是一个工作日：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Overall, I think these parts of the code would be more readable without these
    relatively obscure formats and comparisons.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，我认为如果去除这些相对隐晦的格式和比较，代码的这些部分会更易读。
- en: Second, checking whether a particular date-like string is a Monday-through-Friday
    weekday seems like the kind of thing that might come up reasonably frequently
    in data wrangling work. If I encapsulate this task into a custom function, I can
    easily reuse it in other scripts.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，检查特定的类似日期的字符串是否是周一至周五的工作日似乎是在数据整理工作中可能会频繁遇到的问题。如果我将这个任务封装到一个自定义函数中，我可以在其他脚本中轻松重复使用它。
- en: To see how I’ve gone about refactoring the [Example 7-5](ch07.html#weekday_rides)
    script, take a look at [Example 8-7](#weekday_rides_refactored).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我是如何重构[示例 7-5](ch07.html#weekday_rides)脚本的，可以参考[示例 8-7](#weekday_rides_refactored)。
- en: Example 8-7\. weekday_rides_refactored.py
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-7\. weekday_rides_refactored.py
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_structuring_and_refactoring_your_code_CO1-1)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_structuring_and_refactoring_your_code_CO1-1)'
- en: Wrapping our top-level script into a function called `main()` is a Python convention
    that also serves an important functional purpose. Because the computer reads Python
    top to bottom, if we *don’t* wrap this code in a function, then the computer won’t
    have gotten to the definition of `is_weekday()` when it reaches `if is_weekday(a_row['starttime'])`
    and will throw an error.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的顶级脚本包装成名为`main()`的函数是Python的一种约定，也具有重要的功能目的。因为计算机按顺序从上到下读取Python代码，如果我们*不*将此代码包装在函数中，那么当计算机在达到`if
    is_weekday(a_row['starttime'])`时还没有到达`is_weekday()`的定义时，会抛出错误。
- en: '[![2](assets/2.png)](#co_structuring_and_refactoring_your_code_CO1-2)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_structuring_and_refactoring_your_code_CO1-2)'
- en: We can use the `is_weekday()` function to handle the finicky details of converting
    our date string to both a “real” date and its weekday value. The descriptive function
    name conveys what is happening at a high level without forcing the reader to wade
    through the particulars.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`is_weekday()`函数来处理将我们的日期字符串转换为“真实”日期及其工作日值的微妙细节。这个描述性函数名以高层次传达了正在发生的事情，而不强迫读者深入研究具体细节。
- en: '[![3](assets/3.png)](#co_structuring_and_refactoring_your_code_CO1-4)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_structuring_and_refactoring_your_code_CO1-4)'
- en: The computer still reads from top to bottom as usual, but while it encounters
    both the `main()` and `is_weekday()` function definitions first, we aren’t asking
    it to execute anything until the very bottom of the script.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机仍然像往常一样从顶部到底部阅读，但是当它首先遇到`main()`和`is_weekday()`函数定义时，我们不要求它执行任何操作，直到脚本的最底部。
- en: As you can see, while the bulk of the code (and even many of the comments) in
    [Example 8-7](#weekday_rides_refactored) are the same as those in [Example 7-5](ch07.html#weekday_rides),
    things have been reorganized in a way that makes the `main()` part of the program
    much more concise and readable. Sure, if the programmer *wants* to know the details
    of how weekdays are identified, the specifics are available right there in the
    `is_weekday()` function definition. Otherwise, though, they can just read through
    the primary part of the script and very easily confirm that it is doing what the
    outline alleges.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，尽管[示例 8-7](#weekday_rides_refactored)中的大部分代码（甚至许多注释）与[示例 7-5](ch07.html#weekday_rides)中的代码相同，但它们已经以一种使程序的`main()`部分更加简洁和可读的方式重新组织了。当然，如果程序员*想*知道如何识别工作日的细节，那么`is_weekday()`函数定义中的具体内容就在那里。但是，如果他们只是简单地阅读脚本的主要部分，并且非常容易确认它正在按照概述所述的方式执行。
- en: Metadata Without the Mess
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元数据无需混乱
- en: In [Example 7-7](ch07.html#xls_meta_and_date_parsing), we built on code from
    Examples [4-6](ch04.html#xls_parsing) and [7-6](ch07.html#xls_meta_parsing) to
    create a single script that both effectively interpreted Microsoft Excel dates
    *and* split our source data file into a metadata text file and a structured *.csv*.
    While the resulting script did everything we needed, its code became leggy and
    hard to read, full of hard-to-interpret conditionals and obscure date-formatting
    function calls.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 7-7](ch07.html#xls_meta_and_date_parsing)中，我们构建了一个单一脚本，基于示例[4-6](ch04.html#xls_parsing)和[7-6](ch07.html#xls_meta_parsing)中的代码，它有效地解释了Microsoft
    Excel日期，并将我们的源数据文件分割成元数据文本文件和结构化的*.csv*文件。虽然生成的脚本完成了所有我们需要的工作，但其代码变得臃肿且难以阅读，充斥着难以理解的条件语句和晦涩的日期格式化函数调用。
- en: Here we can clean things up a little bit by handling the formatting of the different
    types of row content (for the *.csv* or the *.txt* file, respectively) in separate
    functions. This requires rearranging (and clarifying) our script’s logic somewhat.
    It also illustrates some of the challenges that can arise when it comes to getting
    all the requisite information *into* our custom functions. The approach outlined
    in [Example 8-8](#xls_meta_and_date_parsing_refactored) illustrates my currently
    preferred way of handling these issues.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以通过处理不同类型的行内容（分别为*.csv*或*.txt*文件）的格式化来稍作整理。这需要在我们脚本的逻辑上进行一定的重新排列（和澄清）。这也展示了在将所有必要信息*传递给*我们自定义函数时可能会遇到的一些挑战。在[示例 8-8](#xls_meta_and_date_parsing_refactored)中概述的方法展示了我目前首选的处理这些问题的方式。
- en: Example 8-8\. xls_meta_and_date_parsing_refactored.py
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-8\. xls_meta_and_date_parsing_refactored.py
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_structuring_and_refactoring_your_code_CO2-1)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_structuring_and_refactoring_your_code_CO2-1)'
- en: Though they should be used sparingly, creating a *global* variable here called
    `the_datemode` means its value can be accessed by *any* function (the `global`
    here refers to its scope). Note that in Python, global variables cannot be assigned
    a value in the same line they are declared, which is why this has been done across
    two separate code statements.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管应该节制使用，但在这里创建一个称为`the_datemode`的*全局*变量意味着它的值可以被*任何*函数访问（这里的`global`指的是它的作用域）。请注意，在Python中，全局变量不能在声明它们的同一行中赋值，这就是为什么这在两个单独的代码语句中完成的原因。
- en: '[![2](assets/2.png)](#co_structuring_and_refactoring_your_code_CO2-3)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_structuring_and_refactoring_your_code_CO2-3)'
- en: For example, if we *didn’t* create a global variable, for the date mode, we
    would have to pass it as another argument to `create_table_row()`, which feels
    a bit incongruous.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们*没有*创建一个全局变量来作为日期模式，那么我们将不得不将其作为另一个参数传递给`create_table_row()`，这在某种程度上感觉有些不协调。
- en: 'If you compare [Example 8-8](#xls_meta_and_date_parsing_refactored) with [Example 8-7](#weekday_rides_refactored),
    you’ll see they have several key features in common: instead of code that executes
    automatically, everything in this script has been compartmentalized into functions,
    with the conventional `main()` function call protected by an `if __name__ == "__main__":`
    conditional. This example also overlaps with [Example 7-7](ch07.html#xls_meta_and_date_parsing)
    almost perfectly: the includes are all the same, and while it has been rearranged
    into three functions instead of a single, linear script, most of the code is almost
    identical.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将 [示例 8-8](#xls_meta_and_date_parsing_refactored) 与 [示例 8-7](#weekday_rides_refactored)
    进行比较，您会发现它们有几个关键特征是相同的：脚本中的所有内容都已被划分为函数，并且常规的 `main()` 函数调用受到 `if __name__ ==
    "__main__":` 条件保护。这个示例还与 [示例 7-7](ch07.html#xls_meta_and_date_parsing) 几乎完美重叠：包含的内容都是一样的，虽然它已被重新排列为三个函数而不是单一的线性脚本，但大部分代码几乎完全相同。
- en: Part of what I want to illustrate here is that refactoring your code doesn’t
    have to be an enormous undertaking, but the results are invaluable. As a program,
    the structure of [Example 8-8](#xls_meta_and_date_parsing_refactored) is now basically
    all logic and no particulars—fiddly details are handled by our new functions.
    If I suddenly needed to download and parse a new data series from the FRED database,
    I would feel comfortable just throwing it at this script to see what happens,
    because if there are problems, *I know exactly where to go to fix them*. Instead
    of having to wade through the entire program, any formatting issues that might
    arise with a new data source are almost certainly going to be the result of code
    in either `create_table_row()` or `create_meta_text()`—and even then, problems
    will probably only appear in one or the other. That means that in order to adapt
    this script to work with new (similar) data sources, I’ll probably only have to
    look at (maybe) a dozen lines of code. That’s certainly better than wading through
    close to 100!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在这里要说明的一部分是，重构您的代码并不一定是一项巨大的工程，但其结果是无价的。作为一个程序，[示例 8-8](#xls_meta_and_date_parsing_refactored)
    的结构现在基本上是全部逻辑而没有具体细节——烦琐的细节由我们的新函数处理。如果我突然需要从 FRED 数据库下载并解析新的数据系列，我会很自信地将其扔给这个脚本看看会发生什么，因为如果有问题，*我知道该去哪里修复它们*。而不是不得不深入整个程序，可能出现新数据源的任何格式问题几乎肯定是由
    `create_table_row()` 或 `create_meta_text()` 中的代码导致的——即使出现问题，也只会出现在其中之一。这意味着为了使此脚本适应新的（类似的）数据源，我可能只需要查看（也许）十几行代码。这肯定比浏览接近
    100 行要好得多！
- en: In other words, while refactoring your data wrangling scripts usually doesn’t
    mean *writing* too much more code, it can really save you from *reading* more
    than you need to when you want to use, reuse, or adapt it later—and that’s yet
    another way that Python can help you scale your data wrangling work.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，虽然重构数据处理脚本通常不意味着*编写*更多的代码，但当您希望以后使用、重复使用或调整它时，这确实可以节省*阅读*的时间——这也是 Python
    帮助您扩展数据处理工作的另一种方式。
- en: Given all the reasons *not* to use global variables, why did I ultimately decide
    to use one here? First, there is only *one* possible value for `source_workbook.datemode`,
    because there is only one `datemode` attribute per Excel spreadsheet. So even
    if a particular workbook had 20 different sheets each containing 100 columns of
    data, there would still only be one, single, unchanging value for `datemode` for
    all of them. So conceptually, the value of `datemode` is actually “global”; it’s
    reasonable that the variable we use to store this value would be as well. And
    since the value of `datemode` will never need to be updated within the script,
    there is less risk of retrieving an unexpected value from it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于所有不使用全局变量的理由，为什么我最终决定在这里使用一个？首先，`source_workbook.datemode` 只有*一个*可能的值，因为每个
    Excel 电子表格只有一个 `datemode` 属性。因此，即使一个特定的工作簿包含了 20 个不同的工作表，每个工作表包含 100 列数据，所有这些工作表的
    `datemode` 值仍然只有一个、单一、不变的值。因此，在概念上，`datemode` 的值实际上是“全局”的；我们用来存储此值的变量也应该如此。并且由于
    `datemode` 的值不会在脚本内部更新，因此从中检索到意外值的风险较小。
- en: As with all writing, however, these choices are partly a matter of taste—and
    even our own taste can change over time. While at first I liked the symmetry of
    creating one function to “build” each row of table data and another function to
    “build” each line of metadata text, there’s also something to be said for breaking
    that symmetry and avoiding the use of the global `datemode` variable altogether,
    as shown in [Example 8-9](#xls_meta_and_date_parsing_refactored_again).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与所有写作一样，这些选择部分取决于品味——即使我们自己的品味随时间也可能改变。起初，我喜欢创建一个函数来“构建”每个表数据行和另一个函数来“构建”每行元数据文本的对称性，但是打破这种对称性并完全避免使用全局
    `datemode` 变量，如 [Example 8-9](#xls_meta_and_date_parsing_refactored_again) 中所示，也有其可取之处。
- en: Example 8-9\. xls_meta_and_date_parsing_refactored_again.py
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-9\. xls_meta_and_date_parsing_refactored_again.py
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_structuring_and_refactoring_your_code_CO3-1)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_structuring_and_refactoring_your_code_CO3-1)'
- en: Although I no longer pass parallel information to a custom function in order
    to generate the table-type and metadata output files, abandoning that symmetry
    prevents my having to create a global variable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我不再将并行信息传递给自定义函数以生成表格类型和元数据输出文件，但放弃对称性可以避免我创建全局变量的需求。
- en: Which of these is the better solution? As with all writing, it depends on your
    preferences, your use cases, and your *audience*. Some groups or institutions
    will be “opinionated” about the choice to use—or avoid—global variables; some
    will feel that shorter solutions are preferable, while others will prize structural
    symmetry, or reusability. While [Example 8-9](#xls_meta_and_date_parsing_refactored_again)
    sacrifices some structural symmetry, it *generates* a function that may be more
    broadly reusable. The choice of which is more important is, as always, up to you
    to determine.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些哪一个是更好的解决方案呢？与所有写作一样，这取决于您的偏好、使用案例和*受众*。有些团体或机构会对选择使用或避免全局变量持有“见解”，有些会认为更短的解决方案更可取，而另一些则会重视结构对称性或可重用性。虽然
    [Example 8-9](#xls_meta_and_date_parsing_refactored_again) 牺牲了一些结构对称性，但它*生成*的函数可能更广泛地可重用。哪一个更重要的选择，如常，由您自己来确定。
- en: Documenting Your Custom Scripts and Functions with pydoc
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `pydoc` 记录自定义脚本和函数
- en: Up until now, we’ve taken a thorough but free-form approach to documenting our
    code. There’s nothing wrong with this in principle, especially if it helps ensure
    you actually *do* the documentation in the first place. As your inventory of Python
    scripts (and their potential audience) expands, however, it is useful to be able
    to review your personal collection of custom functions without individually opening
    up and reading through each and every Python file. If nothing else, having lots
    of files open makes it that much more likely that a stray keystroke will introduce
    an error into a function you rely on in lots of other scripts—which is a really
    quick way to ruin your day.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在对我们的代码采取彻底但自由的文档方法。从原则上讲，这种方法没有任何问题，特别是如果它确实帮助确保您首先*进行*文档编制。然而，随着您的
    Python 脚本清单（及其潜在的受众）的扩展，有能力查看您的个人自定义函数集合而无需逐个打开和阅读每个 Python 文件是非常有用的。即使没有其他影响，打开大量文件会增加误操作引入错误到您依赖的其他许多脚本中的函数的风险，这是毁掉您一天的一种非常快速的方法。
- en: Fortunately, with just a little bit of formatting we can adapt our existing
    program descriptions and comments to work with a command-line function called
    `pydoc`. This will let us print out our script and function descriptions to the
    command line just by providing the relevant filename.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，通过稍微格式化，我们可以调整现有的程序描述和注释，使其适用于称为 `pydoc` 的命令行函数。这将使我们能够仅通过提供相关文件名就可以在命令行打印出我们的脚本和函数描述。
- en: To see this in action, let’s start by refactoring one more script. In this case,
    we’ll revise [Example 7-8](ch07.html#fixed_width_strip_parsing) to make it a little
    bit more concise. In the process, I’ll also update the comments at the top of
    the script (and add some to our new function) to make them compatible with the
    `pydoc` command. You can see what this looks like in [Example 8-10](#fixed_width_string_parsing_refactored).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到实际效果，让我们从重构另一个脚本开始。在这种情况下，我们将修改 [Example 7-8](ch07.html#fixed_width_strip_parsing)
    以使其更加简洁。在此过程中，我还将更新脚本顶部的注释（并向我们的新函数添加一些注释），使它们与 `pydoc` 命令兼容。您可以在 [Example 8-10](#fixed_width_string_parsing_refactored)
    中看到这个效果。
- en: Example 8-10\. fixed_width_strip_parsing_refactored.py
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-10\. fixed_width_strip_parsing_refactored.py
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_structuring_and_refactoring_your_code_CO4-1)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_structuring_and_refactoring_your_code_CO4-1)'
- en: By starting and ending the file and the `convert_to_columns()` function descriptions
    with a set of three double quotation marks (`"""`), they visually stand from the
    rest of the comments in the file and will now be accessible to `pydoc` by running
    the following in a terminal:^([9](ch08.html#idm45143398618416))
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在文件和`convert_to_columns()`函数描述的开头和结尾使用一对三个双引号(`"""`)，它们在文件中可视化显示，与文件中其他注释区分开，并且现在可以通过在终端中运行以下命令来访问`pydoc`：^([9](ch08.html#idm45143398618416))
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will display all of the file and function descriptions within the command-line
    interface (use the arrow keys to scroll up and down, or the space bar to move
    an entire “page” down at once). To exit the documentation and return to the command
    line, just hit the q key.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在命令行界面中显示所有文件和函数描述（使用箭头键上下滚动，或者使用空格键一次向下移动整个“页面”）。要退出文档并返回命令行，只需按下 q 键。
- en: '[![2](assets/2.png)](#co_structuring_and_refactoring_your_code_CO4-2)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_structuring_and_refactoring_your_code_CO4-2)'
- en: Instead of writing a unique line of code to pull each column of data out of
    a given line of text, I’ve put all the start/end values for each column into a
    list of [Python `tuple`s](http://docs.python.org/3.3/library/stdtypes.html?highlight=tuple#tuples),
    which are essentially unchangeable lists.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是编写用于从给定文本行中提取每列数据的独特代码行，我将所有列的起始/结束值放入了一个[Python `tuple`](http://docs.python.org/3.3/library/stdtypes.html?highlight=tuple#tuples)列表中，这些值基本上是不可改变的列表。
- en: '[![3](assets/3.png)](#co_structuring_and_refactoring_your_code_CO4-3)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_structuring_and_refactoring_your_code_CO4-3)'
- en: By passing the column start/end information to the `convert_to_columns()` function
    along with each line of data, we can use a `for...in` loop to convert the text
    to columns. This makes our main script easier to read *and* results in a function
    that could be reused with *any* line of text we need to split into columns, as
    long as we pass in the start/end index pairs in the correct format. I’ve even
    added a flag value called `zero_index`, which lets us use this function with start/end
    pairs that consider zero to be the first position (the default value assumes—as
    this dataset does—that the first position is “1”).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将每行数据与列的起始/结束信息一起传递给`convert_to_columns()`函数，我们可以使用`for...in`循环将文本转换为列。这不仅使我们的主脚本更易读，*而且*使得这个函数可重复使用，适用于我们需要拆分成列的*任何*文本行，只要我们按正确格式传入起始/结束索引对。我甚至添加了一个名为`zero_index`的标志值，允许我们使用这个函数处理考虑零为第一位置的起始/结束对（默认值假定—如此数据集—第一位置是“1”）。
- en: 'Note that in addition to viewing the documentation for the whole file, it is
    possible to use `pydoc` to view the documentation for a single function (for example,
    the `convert_to_columns()` function) by running:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，除了查看整个文件的文档之外，还可以使用`pydoc`通过运行以下命令查看单个函数（例如`convert_to_columns()`函数）的文档：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: and moving through/exiting its documentation in the same way as you did for
    the entire file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 并且像您为整个文件所做的那样浏览/退出其文档。
- en: The Case for Command-Line Arguments
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行参数的案例
- en: Refactoring one long script into a series of functions isn’t the only way we
    can make our data wrangling code more reusable. For multistep data wrangling processes
    (such as those that involve downloading data, like [Example 5-8](ch05.html#downloading_turnstile_index),
    or converting PDF images to text, like [Example 4-16](ch04.html#pdf_parsing)),
    breaking up our *code* into multiple scripts is yet another way to save time and
    effort. For one thing, this approach lets us minimize how often we do resource-intensive
    tasks, like downloading data or actually converting PDF pages to images. Even
    more, these tasks tend to be pretty rote—it doesn’t make much difference *what*
    data we’re downloading or *which* PDF we’re converting to images; our script will
    pretty much always be doing the same thing. As a result, all we need are a few
    additional tricks to transform our currently bespoke data wrangling scripts into
    standalone code that we can reuse as is—over and over again.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个长脚本重构为一系列函数并不是使我们的数据整理代码更可重用的唯一方法。对于多步骤的数据整理过程（例如涉及下载数据的，如[示例 5-8](ch05.html#downloading_turnstile_index)，或者转换PDF图像为文本的，如[示例 4-16](ch04.html#pdf_parsing)），将我们的*代码*分解成多个脚本是节省时间和精力的另一种方式。首先，这种方法使我们最大限度地减少了执行下载数据或实际转换PDF页到图像等资源密集型任务的频率。更重要的是，这些任务往往相当机械化—我们下载的数据或我们转换的PDF是什么并不重要；我们的脚本几乎总是在做同样的事情。因此，我们只需要一些额外的技巧，就可以将我们当前定制的数据整理脚本转换为可以一次又一次重复使用的独立代码。
- en: As an example, let’s look back at [Example 5-8](ch05.html#downloading_turnstile_index).
    In this script, the main thing we’re doing is downloading the contents of a web
    page; it’s just that in this instance we’ve “hard-coded” the [target file](http://web.mta.info/developers/turnstile.html)
    specifically. Likewise, the code that downloaded the XML and JSON files in [Example 5-1](ch05.html#data_download)
    was almost identical—the only real difference was the source URLs and the filenames
    of the local copies. If there was a way that we could refactor these scripts so
    that the *whole thing* acted more like a function, that could potentially save
    us a lot of time and effort in the long run.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们回顾一下[示例5-8](ch05.html#downloading_turnstile_index)。在这个脚本中，我们主要是下载网页内容；只是在这种情况下，我们已经“硬编码”了特定的[target
    file](http://web.mta.info/developers/turnstile.html)。同样，下载XML和JSON文件的代码在[示例5-1](ch05.html#data_download)中几乎相同——唯一的区别是源URL和本地副本的文件名。如果有一种方法可以重构这些脚本，使得*整个过程*更像一个函数，那么从长远来看，这可能会为我们节省大量的时间和精力。
- en: Fortunately, this is very achievable with standalone Python files, thanks to
    the built-in *argparse* Python library, which lets us write our scripts to both
    require—and use—arguments passed in from the command line. Thanks to *argparse*,
    we don’t need to write a new script for every individual web page we want to download,
    because it lets us specify both the target URL *and* the name of our output file
    right from the command line, as shown in [Example 8-11](#webpage_saver).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这对于独立的Python文件来说非常容易实现，多亏了内置的*argparse* Python库，它允许我们编写脚本来需要并且使用从命令行传入的参数。得益于*argparse*，我们无需为每个想要下载的单个网页编写新脚本，因为它允许我们直接从命令行指定目标URL*和*输出文件的名称，如示例[8-11](#webpage_saver)所示。
- en: Example 8-11\. webpage_saver.py
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例8-11\. webpage_saver.py
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](assets/1.png)](#co_structuring_and_refactoring_your_code_CO5-1)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_structuring_and_refactoring_your_code_CO5-1)'
- en: Here we’re assigning the parameter name we can use to access the values passed
    via the command-line from within our script. The help text is important! Be descriptive
    but concise.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在分配参数名称，我们可以用它来从我们的脚本内部访问通过命令行传递的值。帮助文本很重要！要描述清楚但简洁。
- en: 'Now we *should* have an easy way to download any web page to our device, without
    having to write a script for every unique URL. For example, if we run:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们*应该*有一个简单的方法来下载任何网页到我们的设备，而无需为每个独特的URL编写脚本。例如，如果我们运行：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'we will get exactly the same result as in [Example 5-8](ch05.html#downloading_turnstile_index),
    but we can *also* run:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到与[示例5-8](ch05.html#downloading_turnstile_index)完全相同的结果，但我们也可以*同时*运行：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: to get the Citi Bike operating reports without having to even *open*, much less
    modify, our script. Handy, no?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 无需*打开*，更不用说修改我们的脚本，就可以获取Citi Bike的运营报告。方便，不是吗？
- en: Tip
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'Using command-line arguments with your task-specific scripts can save you time,
    but not if you end up copying complex URLs into your command-line interface character
    by character. To make things simpler, here’s a quick overview of how to copy/paste
    to the command line, depending on your operating system:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特定于任务的脚本和命令行参数可以节省时间，但如果最终将复杂的URL逐字符复制到命令行界面，则不能。为了简化事情，这里有一个快速概述如何根据您的操作系统复制/粘贴到命令行：
- en: Linux (including Chromebook)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Linux（包括Chromebook）
- en: Highlight the URL/text you want to copy, then context-click and select Copy.
    In your command-line window, just click and it will automatically paste.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮显示您要复制的URL/文本，然后上下文右键单击并选择复制。在您的命令行窗口中，只需单击即可自动粘贴。
- en: Windows/Macintosh
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Windows/Macintosh
- en: Highlight the URL/text you want to copy, then context-click and select Copy.
    In your command-line window, context-click again and select Paste.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮显示您要复制的URL/文本，然后上下文右键单击并选择复制。在您的命令行窗口中，再次上下文右键单击并选择粘贴。
- en: Where Scripts and Notebooks Diverge
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本和笔记本之间的区别
- en: By now you may have noticed that in the preceding sections, I *didn’t* describe
    a way to get arguments from the command line into a Jupyter notebook, nor have
    I talked much about generating and interacting with script and function documentation
    for Jupyter notebooks, either. This is not because these things are impossible
    but because Jupyter notebooks are designed to let you interact with Python differently
    than standalone scripts, and some of these concepts are less applicable to them.
    As someone who started working with Python before Jupyter (formerly IPython) notebooks
    existed, my bias is still toward standalone scripts for the majority of my rubber-to-the-road
    Python data wrangling. While notebooks are (generally) great for testing and tweaking
    chunks of code, I almost always end up migrating back to standalone scripts once
    I’ve identified the approach that works for a particular data wrangling task.
    This is mostly because as I move further along in a project, I often get impatient
    even with the process of opening and modifying a script unless I have to—much
    less launching a webserver or waiting for a web page to load (I might not even
    have an internet connection!). These are some of the reasons why I favor using
    command-line arguments and standalone scripts for common, straightforward tasks.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经注意到，在前面的章节中，我*没有*描述一种将命令行参数传递到 Jupyter 笔记本中的方法，也没有多谈论如何为 Jupyter
    笔记本生成和交互式地使用脚本和函数文档。这并不是因为这些事情是不可能的，而是因为 Jupyter 笔记本的设计是为了让你与 Python 交互的方式与独立脚本不同，而且这些概念对它们的适用性较少。作为一个在
    Jupyter（原名 IPython）笔记本出现之前就开始使用 Python 的人，我的偏好仍然倾向于独立的脚本来处理大多数的 Python 数据整理任务。虽然笔记本（通常）非常适合于测试和调整代码片段，但一旦我确定了适合特定数据整理任务的方法，我几乎总是会回到独立的脚本上来。这主要是因为在项目进展更深时，我常常会对打开和修改脚本的过程感到不耐烦，更不用说启动一个
    Web 服务器或等待网页加载（我甚至可能没有互联网连接！）。这些都是我更喜欢使用命令行参数和独立脚本来处理常见而直接的任务的原因之一。
- en: As we’ll soon see, however, the interactivity of Jupyter notebooks makes them
    somewhat superior to standalone Python scripts when it comes to experimenting
    with—and especially sharing—the data analysis and visualization portion of our
    data wrangling work. As a result, you’ll find more references to Jupyter notebooks
    in particular as we turn to those topics in Chapters [9](ch09.html#chapter9) and
    [10](ch10.html#chapter10).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们很快将看到的那样，Jupyter 笔记本的交互性使它们在实验和尤其是分享数据分析和可视化部分时，比独立的 Python 脚本稍显优越。因此，在我们转向第
    [9](ch09.html#chapter9) 和 [10](ch10.html#chapter10) 章节的这些主题时，你会发现更多关于 Jupyter
    笔记本的引用。
- en: Conclusion
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, we’ve taken a bit of a break from data wrangling per se to
    revisit some of our prior work where the code had gotten unwieldy. Through the
    process of refactoring, we explored how we can reorganize code that *works* into
    code that *works well*, because it is more readable and reusable. As our data
    wrangling projects evolve, this will help us build up and make use of our own
    collection of custom functions that meet our own particular data wrangling needs.
    Similarly, by applying a bit more structure to our documentation, we made it accessible—and
    useful—right from the command line so that we can find the script or function
    that we’re looking for without opening a single script. And in a similar vein,
    we applied that refactoring logic to our scripts so that we can customize their
    functionality without having to open *them*, either!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们暂时离开了数据整理的实质性工作，重新审视了一些之前因代码难以掌控而变得杂乱的工作。通过重构的过程，我们探讨了如何将*能用*的代码重组成*用得好*的代码，因为这样的代码更易读且可重用。随着我们的数据整理项目的发展，这将帮助我们建立并利用我们自己的一套自定义函数集，以满足我们特定的数据整理需求。同样地，通过为我们的文档应用更多结构，我们使其能够从命令行直接访问并且变得有用，这样我们可以在不打开一个单独的脚本的情况下找到我们需要的脚本或函数。而且，我们也将重构的逻辑应用到了我们的脚本中，这样我们就能够定制它们的功能而无需打开*它们*！
- en: In the next chapter, we’ll return to our focus on data with an overview of some
    of essential data analysis techniques. After that, in [Chapter 10](ch10.html#chapter10)
    we’ll (briefly) cover the core visualization approaches that will help you understand
    and present your data effectively so that you can better share your data wrangling
    insights with the world!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将回到数据分析的焦点，并概述一些基本的数据分析技术。之后，在[第 10 章](ch10.html#chapter10)中，我们将（简要地）介绍一些核心的可视化方法，这将帮助你更好地理解和展示你的数据，从而更好地与世界分享你的数据整理见解！
- en: ^([1](ch08.html#idm45143401447136-marker)) In this case, the programmer is actually
    considered the “user.”
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch08.html#idm45143401447136-marker)) 在这种情况下，程序员实际上被认为是“用户”。
- en: ^([2](ch08.html#idm45143402674080-marker)) Truly, good documentation will save
    your $h!t sometimes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch08.html#idm45143402674080-marker)) 实际上，良好的文档有时会挽救你的生活。
- en: ^([3](ch08.html#idm45143402658928-marker)) Doing these things is definitely
    possible but is well beyond the scope of most data wrangling activities, and therefore
    this book.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch08.html#idm45143402658928-marker)) 虽然做这些事情确实可能，但远远超出了大多数数据整理活动的范围，因此也超出了本书的范围。
- en: ^([4](ch08.html#idm45143401186992-marker)) Technically, *parameters* describe
    the variable names assigned in the function definition, while *arguments* are
    the actual values that are passed to the function when it is called. In practice,
    though, these terms are often used interchangeably.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch08.html#idm45143401186992-marker)) 在技术上，*参数*描述的是在函数定义中分配的变量名称，而*参数*则是在调用函数时传递的实际值。尽管在实践中，这些术语经常互换使用。
- en: ^([5](ch08.html#idm45143401184608-marker)) So-called “statically typed” programming
    languages will actually complain *before* your code runs if you’ve passed the
    wrong data type to a function or method.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch08.html#idm45143401184608-marker)) 所谓的“静态类型”编程语言实际上会在你的代码运行之前就抱怨你向函数或方法传递了错误的数据类型。
- en: ^([6](ch08.html#idm45143401170704-marker)) There’s that `dtype='string'` again!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch08.html#idm45143401170704-marker)) 又来了，`dtype='string'`！
- en: ^([7](ch08.html#idm45143400844448-marker)) This term is also why the forum is
    called *Stack* Exchange.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch08.html#idm45143400844448-marker)) 这个术语也是为什么论坛被称为*Stack* Exchange的原因。
- en: ^([8](ch08.html#idm45143400593680-marker)) You can find a helpful description/demonstration
    of the reasoning behind this convention at [*https://freecodecamp.org/news/if-name-main-python-example*](https://freecodecamp.org/news/if-name-main-python-example).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch08.html#idm45143400593680-marker)) 你可以在[*https://freecodecamp.org/news/if-name-main-python-example*](https://freecodecamp.org/news/if-name-main-python-example)找到有关此约定背后推理的有用描述/演示。
- en: ^([9](ch08.html#idm45143398618416-marker)) The actual structure/formatting I’ve
    used here a mashup of different styles derived from the guide at [*https://realpython.com/documenting-python-code/#documenting-your-python-code-base-using-docstrings*](https://realpython.com/documenting-python-code/#documenting-your-python-code-base-using-docstrings).
    While using a standard approach may matter if you are working with a large team,
    if you are working alone or in a small group, find a style that works for you!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch08.html#idm45143398618416-marker)) 我在这里使用的实际结构/格式是从[*https://realpython.com/documenting-python-code/#documenting-your-python-code-base-using-docstrings*](https://realpython.com/documenting-python-code/#documenting-your-python-code-base-using-docstrings)的指南中衍生出的不同风格的混合。虽然在与大团队合作时使用标准方法可能很重要，但如果你是单独工作或在小团队中工作，那就找到适合你的风格吧！
