- en: Chapter 7\. Working with Relations Using SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html#ch-pandas), we used dataframes to represent tables
    of data. This chapter introduces *relations*, another widely used way to represent
    data tables. We also introduce SQL, the standard programming language for working
    with relations. Here’s an example of a relation that holds information about popular
    dog breeds.
  prefs: []
  type: TYPE_NORMAL
- en: Like dataframes, each row in a relation represents a single record—in this case,
    a single dog breed. Each column represents a feature about the record—for example,
    the `grooming` column represents how often each dog breed needs to be groomed.
  prefs: []
  type: TYPE_NORMAL
- en: Both relations and dataframes have labels for each column in the table. However,
    one key difference is that the rows in a relation don’t have labels, while rows
    in a dataframe do.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we demonstrate common relation operations using SQL. We start
    by explaining the structure of SQL queries. Then we show how to use SQL to perform
    common data manipulation tasks, like slicing, filtering, sorting, grouping, and
    joining.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This chapter replicates the data analyses in [Chapter 6](ch06.html#ch-pandas)
    using relations and SQL instead of dataframes and Python. The datasets, data manipulations,
    and conclusions are nearly identical across the two chapters for ease of comparison
    between performing data manipulations in `pandas` and SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Subsetting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To work with relations, we’ll introduce a domain-specific programming language
    called *SQL* (Structured Query Language). We commonly pronounce “SQL” like “sequel”
    instead of spelling out the acronym. SQL is a specialized language for working
    with relations—as such, SQL has a different syntax than Python for writing programs
    that operate on relational data.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll use SQL queries within Python programs. This illustrates
    a common workflow—data scientists often process and subset data in SQL before
    loading the data into Python for further analysis. SQL databases make it easier
    to work with large amounts of data compared to `pandas` programs. However, loading
    data into `pandas` makes it easier to visualize the data and build statistical
    models.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Why do SQL systems tend to work better with larger datasets? In short, SQL systems
    have sophisticated algorithms for managing data stored on disk. For example, when
    working with a large dataset, SQL systems will transparently load and manipulate
    small portions of data at a time; doing this in `pandas` can be quite difficult
    in comparison. We cover this topic in more detail in [Chapter 8](ch08.html#ch-files).
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL Basics: SELECT and FROM'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll use the `pd.read_sql` function, which runs a SQL query and stores the
    output in a `pandas` dataframe. Using this function requires some setup. We start
    by importing the `pandas` and `sqlalchemy` Python packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Our database is stored in a file called *babynames.db*. This file is a [SQLite](https://oreil.ly/sGYWE)
    database, so we’ll set up a `sqlalchemy` object that can process this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this book, we use SQLite, an extremely useful database system for working
    with data stored locally. Other systems make different trade-offs that are useful
    for different domains. For instance, PostgreSQL and MySQL are more complex systems
    that are useful for large web applications where many end users are writing data
    at the same time. Although each SQL system has slight differences, they provide
    the same core SQL functionality. Readers may also be aware that Python provides
    SQLite support in its standard `sqlite3` library. We choose to use `sqlalchemy`
    because it’s easier to reuse the code for other SQL systems beyond SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use `pd.read_sql` to run SQL queries on this database. This database
    has two relations: `baby` and `nyt`. Here’s a simple example that reads in the
    entire `baby` relation. We write a SQL query as a Python string and pass it into
    `pd.read_sql`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | M | 19659 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | M | 18252 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **2020719** | Verona | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020720** | Vertie | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020721** | Wilma | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The text inside the `query` variable contains SQL code. `SELECT` and `FROM`
    are SQL keywords. We read the preceding query like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `baby` relation contains the same data as the `baby` dataframe in [Chapter 6](ch06.html#ch-pandas):
    the names of all babies registered by the US Social Security Administration.'
  prefs: []
  type: TYPE_NORMAL
- en: What’s a Relation?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s examine the `baby` relation in more detail. A relation has rows and columns.
    Every column has a label, as illustrated in [Figure 7-1](#fig-relation-labels).
    Unlike dataframes, however, individual rows in a relation don’t have labels. Also
    unlike dataframes, rows of a relation aren’t ordered.
  prefs: []
  type: TYPE_NORMAL
- en: '![relation-labels](assets/leds_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. The `baby` relation has labels for columns (boxed)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Relations have a long history. More formal  treatments of relations use the
    term *tuple* to refer to the rows of a relation, and *attribute* to refer to the
    columns. There is also a rigorous way to define data operations using relational
    algebra, which is derived from mathematical set algebra.
  prefs: []
  type: TYPE_NORMAL
- en: Slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Slicing* is an operation that creates a new relation by taking a subset of
    rows or columns out of another relation. Think about slicing a tomato—slices can
    go both vertically and horizontally. To slice columns of a relation, we give the
    `SELECT` statement the columns we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **2020719** | Verona |'
  prefs: []
  type: TYPE_TB
- en: '| **2020720** | Vertie |'
  prefs: []
  type: TYPE_TB
- en: '| **2020721** | Wilma |'
  prefs: []
  type: TYPE_TB
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Count |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | 19659 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | 18252 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | 14147 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **2020719** | Verona | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020720** | Vertie | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020721** | Wilma | 5 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To slice out a specific number of rows, use the `LIMIT` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **7** | Lucas |'
  prefs: []
  type: TYPE_TB
- en: '| **8** | Henry |'
  prefs: []
  type: TYPE_TB
- en: '| **9** | Alexander |'
  prefs: []
  type: TYPE_TB
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In sum, we use the `SELECT` and `LIMIT` keywords to slice columns and rows of
    a relation.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering Rows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we turn to *filtering* rows—taking subsets of rows using one or more criteria.
    In `pandas`, we slice dataframes using Boolean series objects. In SQL, we instead
    use the `WHERE` keyword with a predicate. The following query filters the `baby`
    relation to have only the baby names in 2020:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | M | 19659 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | M | 18252 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **31267** | Zylynn | F | 5 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **31268** | Zynique | F | 5 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **31269** | Zynlee | F | 5 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Note that when comparing for equality, SQL uses a single equals sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python, however, single equals signs are used for variable assignment. The
    statement `Year = 2020` will assign the value `2020` to the variable `Year`. To
    compare for equality, Python code uses double equals signs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To add more predicates to the filter, use the `AND` and `OR` keywords. For
    instance, to find the names that have more than 10,000 babies in either 2020 or
    2019, we write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | M | 19659 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | M | 18252 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **41** | Mia | F | 12452 | 2019 |'
  prefs: []
  type: TYPE_TB
- en: '| **42** | Harper | F | 10464 | 2019 |'
  prefs: []
  type: TYPE_TB
- en: '| **43** | Evelyn | F | 10412 | 2019 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to find the 10 most common names in 2020, we can sort the dataframe
    by `Count` in descending order using the `ORDER BY` keyword with the `DESC` option
    (short for DESCending):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | M | 19659 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | M | 18252 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Emma | F | 15581 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **7** | Sophia | F | 12976 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **8** | Amelia | F | 12704 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **9** | William | M | 12541 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We see that Liam, Noah, and Emma were the most popular baby names in 2020.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: How Recently Has Luna Become a Popular Name?'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned in [Chapter 6](ch06.html#ch-pandas), a *New York Times* article
    mentions that the name Luna was almost nonexistent before 2000 but has since grown
    to become a very popular name for girls. When exactly did Luna become popular?
    We can check this in SQL using slicing and filtering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Luna | F | 7770 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Luna | F | 7772 | 2019 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Luna | F | 6929 | 2018 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **125** | Luna | F | 17 | 1883 |'
  prefs: []
  type: TYPE_TB
- en: '| **126** | Luna | F | 18 | 1881 |'
  prefs: []
  type: TYPE_TB
- en: '| **127** | Luna | F | 15 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`pd.read_sql` returns a `pandas.DataFrame` object, which we can use to make
    a plot. This illustrates a common workflow—process the data using SQL, load it
    into a `pandas` dataframe, then visualize the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_07in01.png)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we introduced the common ways that data scientists subset relations—slicing
    with column labels and filtering using a boolean condition. In the next section,
    we explain how to aggregate rows together.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section introduces grouping and aggregating in SQL. We’ll work with the
    baby names data, as in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | M | 19659 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | M | 18252 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **7** | Lucas | M | 11281 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **8** | Henry | M | 10705 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **9** | Alexander | M | 10151 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Basic Group-Aggregate Using GROUP BY
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say we want to find out the total number of babies born as recorded in
    this data. This is simply the sum of the `Count` column. SQL provides functions
    that we use in the `SELECT` statement, like `SUM`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '|   | SUM(Count) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | 352554503 |'
  prefs: []
  type: TYPE_TB
- en: In [Chapter 6](ch06.html#ch-pandas), we used grouping and aggregation to figure
    out whether US births are trending upward over time. We grouped the dataset by
    year using `.groupby()`, then summed the counts within each group using `.sum()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In SQL, we instead group using the `GROUP BY` clause, then call aggregation
    functions in `SELECT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Year | SUM(Count) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | 1880 | 194419 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | 1881 | 185772 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | 1882 | 213385 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **138** | 2018 | 3487193 |'
  prefs: []
  type: TYPE_TB
- en: '| **139** | 2019 | 3437438 |'
  prefs: []
  type: TYPE_TB
- en: '| **140** | 2020 | 3287724 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As with dataframe grouping, notice that the `Year` column contains the unique
    `Year` values—there are no duplicate `Year` values anymore since we grouped them
    together. When grouping in `pandas`, the grouping columns become the index of
    the resulting dataframe. However, relations don’t have row labels, so the `Year`
    values are just a column in the resulting relation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the basic recipe for grouping in `SQL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that the order of clauses in a SQL statement is important. To avoid a syntax
    error, `SELECT` needs to appear first, then `FROM`, then `WHERE`, then `GROUP
    BY`.
  prefs: []
  type: TYPE_NORMAL
- en: When using `GROUP BY` we need to be careful about the columns given to `SELECT`.
    In general, we can only include columns without an aggregation when we use those
    columns to group. For instance, in the preceding example we grouped by the `Year`
    column, so we can include `Year` in the `SELECT` clause. All other columns included
    in `SELECT` should be aggregated, as we did earlier with `SUM(Count)`. If we included
    a “bare” column like `Name` that wasn’t used for grouping, it’s ambiguous which
    name within the group should be returned. Although bare columns won’t cause an
    error for SQLite, they cause other SQL engines to error, so we recommend avoiding
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping on Multiple Columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We pass multiple columns into `GROUP BY` to group by multiple columns at once.
    This is useful when we need to further subdivide our groups. For example, we can
    group by both year and sex to see how many male and female babies were born over
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Year | Sex | SUM(Count) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | 1880 | F | 83929 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | 1880 | M | 110490 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | 1881 | F | 85034 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **279** | 2019 | M | 1785527 |'
  prefs: []
  type: TYPE_TB
- en: '| **280** | 2020 | F | 1581301 |'
  prefs: []
  type: TYPE_TB
- en: '| **281** | 2020 | M | 1706423 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the preceding code is very similar to grouping by a single column,
    except that it gives multiple columns to `GROUP BY` to group by both `Year` and
    `Sex`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Unlike `pandas`, SQLite doesn’t provide a simple way to pivot a relation. Instead,
    we can use `GROUP BY` on two columns in SQL, read the result into a dataframe,
    and then use the `unstack()` dataframe method.
  prefs: []
  type: TYPE_NORMAL
- en: Other Aggregation Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLite has several other built-in aggregation functions besides `SUM`, such
    as `COUNT`, `AVG`, `MIN`, and `MAX`. For the full list of functions, consult [the
    SQLite website](https://oreil.ly/ALtjb).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use another aggregation function, we call it in the `SELECT` clause. For
    instance, we can use `MAX` instead of `SUM`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Year | MAX(Count) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | 1880 | 9655 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | 1881 | 8769 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | 1882 | 9557 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **138** | 2018 | 19924 |'
  prefs: []
  type: TYPE_TB
- en: '| **139** | 2019 | 20555 |'
  prefs: []
  type: TYPE_TB
- en: '| **140** | 2020 | 19659 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The built-in aggregation functions are one of the first places a data scientist
    may encounter differences in SQL implementations. For instance, SQLite has a relatively
    minimal set of aggregation functions while [PostgreSQL has many more](https://oreil.ly/gqYoK).
    That said, almost all SQL implementations provide `SUM`, `COUNT`, `MIN`, `MAX`,
    and `AVG`.
  prefs: []
  type: TYPE_NORMAL
- en: This section covered common ways to aggregate data in SQL using the `GROUP BY`
    keyword with one or more columns. In the next section, we’ll explain how to join
    relations together.
  prefs: []
  type: TYPE_NORMAL
- en: Joining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To connect records between two data tables, SQL relations can be joined together
    similar to dataframes. In this section, we introduce SQL joins to replicate our
    analysis of the baby names data. Recall that [Chapter 6](ch06.html#ch-pandas)
    mentions a *New York Times* article that talks about how certain name categories,
    like mythological and baby boomer names, have become more or less popular over
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve taken the names and categories in the *NYT* article and put them in a
    small relation named `nyt`. First, the code sets up a connection to a database,
    then runs a SQL query to display the `nyt` relation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '|   | nyt_name | category |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Lucifer | forbidden |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Lilith | forbidden |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Danger | forbidden |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **20** | Venus | celestial |'
  prefs: []
  type: TYPE_TB
- en: '| **21** | Celestia | celestial |'
  prefs: []
  type: TYPE_TB
- en: '| **22** | Skye | celestial |'
  prefs: []
  type: TYPE_TB
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that the preceding code runs a query on `babynames.db`, the same database
    that contains the larger `baby` relation from the previous sections. SQL databases
    can hold more than one relation, making them very useful when we need to work
    with many data tables at once. CSV files, on the other hand, typically contain
    one data table each—if we perform a data analysis that uses 20 data tables, we
    might need to keep track of the names, locations, and versions of 20 CSV files.
    Instead, it could be simpler to store all the data tables in a SQLite database
    stored in a single file.
  prefs: []
  type: TYPE_NORMAL
- en: To see how popular the categories of names are, we join the `nyt` relation with
    the `baby` relation to get the name counts from `baby`.
  prefs: []
  type: TYPE_NORMAL
- en: Inner Joins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As in [Chapter 6](ch06.html#ch-pandas), we’ve made smaller versions of the
    `baby` and `nyt` tables so that it’s easier to see what happens when we join tables
    together. The relations are called `baby_small` and `nyt_small`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Noah | M | 18252 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Julius | M | 960 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Karen | M | 6 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | Karen | F | 325 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **4** | Noah | F | 305 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '|   | nyt_name | category |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Karen | boomer |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Julius | mythology |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Freya | mythology |'
  prefs: []
  type: TYPE_TB
- en: 'To join relations in SQL, we use the `INNER JOIN` clause to say which tables
    we want to join and the `ON` clause to specify a predicate for joining the tables.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year | nyt_name | category |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Julius | M | 960 | 2020 | Julius | mythology |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Karen | M | 6 | 2020 | Karen | boomer |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Karen | F | 325 | 2020 | Karen | boomer |'
  prefs: []
  type: TYPE_TB
- en: 'Notice that this result is the same as doing an inner join in `pandas`: the
    new table has the columns of both the `baby_small` and `nyt_small` tables. The
    rows with the name Noah are gone, and the remaining rows have their matching `category`
    from `nyt_small`.'
  prefs: []
  type: TYPE_NORMAL
- en: To join two tables together, we tell SQL the column(s) from each table that
    we want to do the join with, using a predicate with the `ON` keyword. SQL matches
    rows together when the values in the joining columns fulfill the predicate, as
    shown in [Figure 7-2](#fig-sql-inner-join).
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `pandas`, SQL gives more flexibility on how rows are joined. The `pd.merge()`
    method can only join using simple equality, but the predicate in the `ON` clause
    can be arbitrarily complex. As an example, we take advantage of this extra versatility
    in [“Finding Collocated Sensors”](ch12.html#sec-pa-collocated).
  prefs: []
  type: TYPE_NORMAL
- en: '![sql-inner-join](assets/leds_0702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. Joining two tables together with SQL
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Left and Right Joins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like `pandas`, SQL also supports left joins. Instead of saying `INNER JOIN`,
    we use `LEFT JOIN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year | nyt_name | category |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Noah | M | 18252 | 2020 | None | None |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Julius | M | 960 | 2020 | Julius | mythology |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Karen | M | 6 | 2020 | Karen | boomer |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | Karen | F | 325 | 2020 | Karen | boomer |'
  prefs: []
  type: TYPE_TB
- en: '| **4** | Noah | F | 305 | 2020 | None | None |'
  prefs: []
  type: TYPE_TB
- en: As we might expect, the “left” side of the join refers to the table that appears
    on the left side of the `LEFT JOIN` keyword. We can see the `Noah` rows are kept
    in the resulting relation even when they don’t have a match in the righthand relation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that SQLite doesn’t support right joins directly, but we can perform the
    same join by swapping the order of relations, then using `LEFT JOIN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '|   | nyt_name | category | Name | Sex | Count | Year |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Karen | boomer | Karen | F | 325.0 | 2020.0 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Karen | boomer | Karen | M | 6.0 | 2020.0 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Julius | mythology | Julius | M | 960.0 | 2020.0 |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | Freya | mythology | None | None | NaN | NaN |'
  prefs: []
  type: TYPE_TB
- en: SQLite doesn’t have a built-in keyword for outer joins. In cases where an outer
    join is needed, we have to either use a different SQL engine or perform an outer
    join via `pandas`. However, in our (the authors’) experience, outer joins are
    rarely used in practice compared to inner and left joins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Popularity of NYT Name Categories'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s return to the full `baby` and `nyt` relations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to know how the popularity of name categories in `nyt` has changed
    over time. To answer this question, we should:'
  prefs: []
  type: TYPE_NORMAL
- en: Inner join `baby` with `nyt`, matching rows where the names are equal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Group the table by `category` and `Year`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Aggregate the counts using a sum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '|   | category | Year | count |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | boomer | 1880 | 292 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | boomer | 1881 | 298 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | boomer | 1882 | 326 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **647** | mythology | 2018 | 2944 |'
  prefs: []
  type: TYPE_TB
- en: '| **648** | mythology | 2019 | 3320 |'
  prefs: []
  type: TYPE_TB
- en: '| **649** | mythology | 2020 | 3489 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The numbers in square brackets (`[1]`, `[2]`, `[3]`) in the preceding query
    show how each step in our plan maps to the parts of the SQL query. The code re-creates
    the dataframe from [Chapter 6](ch06.html#ch-pandas), where we created plots to
    verify the claims of the *New York Times* article. For brevity, we omit duplicating
    the plots here.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that in the SQL code in this example, the numbers appear out of order—`[3]`,
    `[1]`, then `[2]`. As a rule of thumb for first-time SQL learners, we can often
    think of the `SELECT` statement as the *last* piece of the query to execute even
    though it appears first.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduced joins for relations. When joining relations together,
    we match rows using the `INNER JOIN` or `LEFT JOIN` keyword and a boolean predicate.
    In the next section, we’ll explain how to transform values in a relation.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming and Common Table Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we show how to call functions to transform columns of data
    using built-in SQL functions. We also demonstrate how to use common table expressions
    to build up complex queries from simpler ones. As usual, we start by loading the
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: SQL Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLite provides a variety of *scalar functions*, or functions that transform
    single data values. When called on a column of data, SQLite will apply these functions
    on each value in the column. In contrast, aggregation functions like `SUM` and
    `COUNT` take a column of values as input and compute a single value as output.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLite provides a comprehensive list of the built-in scalar functions in [its
    online documentation](https://oreil.ly/kznBO). For instance, to find the number
    of characters in each name, we use the `LENGTH` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | LENGTH(Name) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **7** | Lucas | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| **8** | Henry | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| **9** | Alexander | 9 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `LENGTH` function is applied to each value within the `Name`
    column.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Like aggregation functions, each implementation of SQL provides a different
    set of scalar functions. SQLite has a relatively minimal set of functions, while
    [PostgreSQL has many more](https://oreil.ly/i2KIA). That said, almost all SQL
    implementations provide some equivalent to SQLite’s `LENGTH`, `ROUND`, `SUBSTR`,
    and `LIKE` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although scalar functions use the same syntax as an aggregation function, they
    behave differently. This can result in confusing output if the two are mixed together
    in a single query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | LENGTH(Name) | AVG(Count) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | 4 | 174.47 |'
  prefs: []
  type: TYPE_TB
- en: Here, the `AVG(Name)` computes the average of the entire `Count` column, but
    the output is confusing—a reader could easily think the average is related to
    the name Liam. For this reason, we must be careful when scalar and aggregation
    functions appear together within a `SELECT` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract the first letter of each name, we can use the `SUBSTR` function
    (short for *substring*). As described in the documentation, the `SUBSTR` function
    takes three arguments. The first is the input string, the second is the position
    to begin the substring (1-indexed), and the third is the length of the substring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | SUBSTR(Name, 1, 1) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | L |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | N |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | O |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **7** | Lucas | L |'
  prefs: []
  type: TYPE_TB
- en: '| **8** | Henry | H |'
  prefs: []
  type: TYPE_TB
- en: '| **9** | Alexander | A |'
  prefs: []
  type: TYPE_TB
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `AS` keyword to rename the column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year | Firsts |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | M | 19659 | 2020 | L |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | M | 18252 | 2020 | N |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | M | 14147 | 2020 | O |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **7** | Lucas | M | 11281 | 2020 | L |'
  prefs: []
  type: TYPE_TB
- en: '| **8** | Henry | M | 10705 | 2020 | H |'
  prefs: []
  type: TYPE_TB
- en: '| **9** | Alexander | M | 10151 | 2020 | A |'
  prefs: []
  type: TYPE_TB
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: After calculating the first letter of each name, our analysis aims to understand
    the popularity of first letters over time. To do this, we want to take the output
    of this SQL query and use it as a single step within a longer chain of operations.
  prefs: []
  type: TYPE_NORMAL
- en: SQL provides several options to break queries into smaller steps, which is helpful
    in more complex analyses like this one. The most common options for doing this
    are to create a new relation using a `CREATE TABLE` statement, create a new view
    using `CREATE VIEW`, or create a temporary relation using `WITH`. Each of these
    methods has different use-cases. For simplicity, we only describe the `WITH` statement
    in this section and suggest that readers look over the SQLite documentation for
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Multistep Queries Using a WITH Clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `WITH` clause lets us assign a name to any `SELECT` query. Then we can
    treat that query as though it exists as a relation in the database just for the
    duration of the query. SQLite calls these temporary relations *common table expressions*.
    For instance, we can take the earlier query that calculates the first letter of
    each name and call it `letters`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year | Firsts |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | M | 19659 | 2020 | L |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | M | 18252 | 2020 | N |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | M | 14147 | 2020 | O |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **7** | Lucas | M | 11281 | 2020 | L |'
  prefs: []
  type: TYPE_TB
- en: '| **8** | Henry | M | 10705 | 2020 | H |'
  prefs: []
  type: TYPE_TB
- en: '| **9** | Alexander | M | 10151 | 2020 | A |'
  prefs: []
  type: TYPE_TB
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`WITH` statements are very useful since they can be chained together. We can
    create multiple temporary relations in a `WITH` statement that each perform a
    bit of work on the previous result, which lets us gradually build complicated
    queries a step at a time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Popularity of “L” Names'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use `WITH` statements to look at the popularity of names that start
    with the letter L over time. We’ll group the temporary `letters` relation by the
    first letter and year, then aggregate the `Count` column using a sum, then filter
    to get only names with the letter L:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Firsts | Year | Count |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | L | 1880 | 12799 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | L | 1881 | 12770 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | L | 1882 | 14923 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **138** | L | 2018 | 246251 |'
  prefs: []
  type: TYPE_TB
- en: '| **139** | L | 2019 | 249315 |'
  prefs: []
  type: TYPE_TB
- en: '| **140** | L | 2020 | 239760 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This relation contains the same data as the one from [Chapter 6](ch06.html#ch-pandas).
    In that chapter, we make a plot of the `Count` column over time, which we omit
    here for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduced data transformations. To transform values in
    a relation, we commonly use SQL functions like `LENGTH()` or `SUBSTR()`. We also
    explained how to build up complex queries using the `WITH` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explained what relations are, why they’re useful, and how
    to work with them using SQL code. SQL databases are useful for many real-world
    settings. For example, SQL databases typically have robust data recovery mechanisms—if
    the computer crashes while in the middle of a SQL operation, the database system
    can recover as much data as possible without corruption. As mentioned earlier,
    SQL databases can also handle larger scale; organizations use SQL databases to
    store and query databases that are far too large to analyze in memory using `pandas`
    code. These are just a few reasons why SQL is an important part of the data science
    toolbox, and we expect that many readers will soon encounter SQL code as part
    of their work.
  prefs: []
  type: TYPE_NORMAL
