- en: Chapter 7\. Working with Relations Using SQL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。使用SQL处理关系
- en: In [Chapter 6](ch06.html#ch-pandas), we used dataframes to represent tables
    of data. This chapter introduces *relations*, another widely used way to represent
    data tables. We also introduce SQL, the standard programming language for working
    with relations. Here’s an example of a relation that holds information about popular
    dog breeds.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html#ch-pandas)中，我们使用数据框表示数据表。本章介绍了*关系*，另一种广泛使用的表示数据表的方式。我们还介绍了SQL，这是处理关系的标准编程语言。以下是一个关于流行狗品种信息的关系示例。
- en: Like dataframes, each row in a relation represents a single record—in this case,
    a single dog breed. Each column represents a feature about the record—for example,
    the `grooming` column represents how often each dog breed needs to be groomed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 像数据框一样，关系中的每一行表示一个单狗品种记录。每一列表示记录的一个特征，例如，`grooming`列表示每个狗品种需要多频繁地梳理。
- en: Both relations and dataframes have labels for each column in the table. However,
    one key difference is that the rows in a relation don’t have labels, while rows
    in a dataframe do.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 关系和数据框都为表中的每一列都有标签。但是，一个关键区别在于关系中的行没有标签，而数据框中的行有。
- en: In this chapter, we demonstrate common relation operations using SQL. We start
    by explaining the structure of SQL queries. Then we show how to use SQL to perform
    common data manipulation tasks, like slicing, filtering, sorting, grouping, and
    joining.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们演示使用SQL进行常见的关系操作。我们首先解释SQL查询的结构。然后展示如何使用SQL执行常见的数据操作任务，如切片、过滤、排序、分组和连接。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter replicates the data analyses in [Chapter 6](ch06.html#ch-pandas)
    using relations and SQL instead of dataframes and Python. The datasets, data manipulations,
    and conclusions are nearly identical across the two chapters for ease of comparison
    between performing data manipulations in `pandas` and SQL.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章复制了[第6章](ch06.html#ch-pandas)中的数据分析，但使用的是关系和SQL，而不是数据框和Python。两章的数据集、数据操作和结论几乎相同，以便于在使用`pandas`和SQL执行数据操作时进行比较。
- en: Subsetting
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子集化
- en: To work with relations, we’ll introduce a domain-specific programming language
    called *SQL* (Structured Query Language). We commonly pronounce “SQL” like “sequel”
    instead of spelling out the acronym. SQL is a specialized language for working
    with relations—as such, SQL has a different syntax than Python for writing programs
    that operate on relational data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用关系，我们将介绍一种称为*SQL*（Structured Query Language）的领域特定编程语言。我们通常将“SQL”发音为“sequel”，而不是拼写首字母缩略词。SQL是一种专门用于处理关系的语言，因此，与Python在操作关系数据时相比，SQL具有不同的语法。
- en: In this chapter, we’ll use SQL queries within Python programs. This illustrates
    a common workflow—data scientists often process and subset data in SQL before
    loading the data into Python for further analysis. SQL databases make it easier
    to work with large amounts of data compared to `pandas` programs. However, loading
    data into `pandas` makes it easier to visualize the data and build statistical
    models.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在Python程序中使用SQL查询。这展示了一个常见的工作流程——数据科学家经常在SQL中处理和子集化数据，然后将数据加载到Python中进行进一步分析。与`pandas`程序相比，SQL数据库使处理大量数据变得更加容易。但是，将数据加载到`pandas`中使得可视化数据和构建统计模型变得更加容易。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Why do SQL systems tend to work better with larger datasets? In short, SQL systems
    have sophisticated algorithms for managing data stored on disk. For example, when
    working with a large dataset, SQL systems will transparently load and manipulate
    small portions of data at a time; doing this in `pandas` can be quite difficult
    in comparison. We cover this topic in more detail in [Chapter 8](ch08.html#ch-files).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么SQL系统往往更适合处理大型数据集？简而言之，SQL系统具有用于管理存储在磁盘上的数据的复杂算法。例如，当处理大型数据集时，SQL系统会透明地一次加载和操作小部分数据；相比之下，在`pandas`中做到这一点可能会更加困难。我们将在[第8章](ch08.html#ch-files)中更详细地讨论这个主题。
- en: 'SQL Basics: SELECT and FROM'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL基础知识：SELECT和FROM
- en: 'We’ll use the `pd.read_sql` function, which runs a SQL query and stores the
    output in a `pandas` dataframe. Using this function requires some setup. We start
    by importing the `pandas` and `sqlalchemy` Python packages:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`pd.read_sql`函数运行SQL查询，并将输出存储在`pandas`数据框中。使用此函数需要一些设置。我们首先导入`pandas`和`sqlalchemy`
    Python包：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our database is stored in a file called *babynames.db*. This file is a [SQLite](https://oreil.ly/sGYWE)
    database, so we’ll set up a `sqlalchemy` object that can process this format:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库存储在名为*babynames.db*的文件中。这个文件是一个[SQLite](https://oreil.ly/sGYWE)数据库，因此我们将设置一个可以处理这种格式的`sqlalchemy`对象：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: In this book, we use SQLite, an extremely useful database system for working
    with data stored locally. Other systems make different trade-offs that are useful
    for different domains. For instance, PostgreSQL and MySQL are more complex systems
    that are useful for large web applications where many end users are writing data
    at the same time. Although each SQL system has slight differences, they provide
    the same core SQL functionality. Readers may also be aware that Python provides
    SQLite support in its standard `sqlite3` library. We choose to use `sqlalchemy`
    because it’s easier to reuse the code for other SQL systems beyond SQLite.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用 SQLite，这是一个非常有用的本地数据存储数据库系统。其他系统做出了不同的权衡，适用于不同的领域。例如，PostgreSQL 和
    MySQL 是更复杂的系统，适用于大型 Web 应用程序，在这些应用程序中，许多最终用户同时写入数据。虽然每个 SQL 系统有细微的差异，但它们提供相同的核心
    SQL 功能。读者可能还知道 Python 在其标准 `sqlite3` 库中提供了对 SQLite 的支持。我们选择使用 `sqlalchemy` 是因为它更容易重用代码，以适用于
    SQLite 之外的其他 SQL 系统。
- en: 'Now we can use `pd.read_sql` to run SQL queries on this database. This database
    has two relations: `baby` and `nyt`. Here’s a simple example that reads in the
    entire `baby` relation. We write a SQL query as a Python string and pass it into
    `pd.read_sql`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用 `pd.read_sql` 在这个数据库上运行 SQL 查询。这个数据库有两个关系：`baby` 和 `nyt`。这是一个读取整个 `baby`
    关系的简单示例。我们将 SQL 查询作为 Python 字符串编写，并传递给 `pd.read_sql`：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|   | Name | Sex | Count | Year |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|   | Name | Sex | Count | Year |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **0** | Liam | M | 19659 | 2020 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | M | 19659 | 2020 |'
- en: '| **1** | Noah | M | 18252 | 2020 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | M | 18252 | 2020 |'
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver | M | 14147 | 2020 |'
- en: '| **...** | ... | ... | ... | ... |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... |'
- en: '| **2020719** | Verona | F | 5 | 1880 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **2020719** | Verona | F | 5 | 1880 |'
- en: '| **2020720** | Vertie | F | 5 | 1880 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **2020720** | Vertie | F | 5 | 1880 |'
- en: '| **2020721** | Wilma | F | 5 | 1880 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **2020721** | Wilma | F | 5 | 1880 |'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The text inside the `query` variable contains SQL code. `SELECT` and `FROM`
    are SQL keywords. We read the preceding query like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `query` 内的文本包含 SQL 代码。`SELECT` 和 `FROM` 是 SQL 关键字。我们读取前述查询如下：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `baby` relation contains the same data as the `baby` dataframe in [Chapter 6](ch06.html#ch-pandas):
    the names of all babies registered by the US Social Security Administration.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`baby` 关系包含与 [第六章](ch06.html#ch-pandas) 中 `baby` 数据帧相同的数据：所有由美国社会安全管理局注册的婴儿姓名。'
- en: What’s a Relation?
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是关系？
- en: Let’s examine the `baby` relation in more detail. A relation has rows and columns.
    Every column has a label, as illustrated in [Figure 7-1](#fig-relation-labels).
    Unlike dataframes, however, individual rows in a relation don’t have labels. Also
    unlike dataframes, rows of a relation aren’t ordered.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地检查 `baby` 关系。一个关系有行和列。每一列都有一个标签，如 [Figure 7-1](#fig-relation-labels)
    所示。不像数据帧，然而，关系中的个别行没有标签。也不像数据帧，关系的行不是有序的。
- en: '![relation-labels](assets/leds_0701.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![relation-labels](assets/leds_0701.png)'
- en: Figure 7-1\. The `baby` relation has labels for columns (boxed)
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-1\. `baby` 关系具有列的标签（用框框起来）
- en: Relations have a long history. More formal  treatments of relations use the
    term *tuple* to refer to the rows of a relation, and *attribute* to refer to the
    columns. There is also a rigorous way to define data operations using relational
    algebra, which is derived from mathematical set algebra.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 关系有着悠久的历史。对关系的更正式处理使用术语 *元组* 来指代关系的行，*属性* 来指代列。还有一种严格的方式使用关系代数来定义数据操作，它源自数学集合代数。
- en: Slicing
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片
- en: '*Slicing* is an operation that creates a new relation by taking a subset of
    rows or columns out of another relation. Think about slicing a tomato—slices can
    go both vertically and horizontally. To slice columns of a relation, we give the
    `SELECT` statement the columns we want:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*切片* 是通过从另一个关系中取出部分行或列来创建新关系的操作。想象切番茄——切片可以垂直和水平进行。要对关系的列进行切片，我们给 `SELECT`
    语句传递我们想要的列：'
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|   | Name |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|   | Name |'
- en: '| --- | --- |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **0** | Liam |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam |'
- en: '| **1** | Noah |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah |'
- en: '| **2** | Oliver |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver |'
- en: '| **...** | ... |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... |'
- en: '| **2020719** | Verona |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **2020719** | Verona |'
- en: '| **2020720** | Vertie |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **2020720** | Vertie |'
- en: '| **2020721** | Wilma |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **2020721** | Wilma |'
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|   | Name | Count |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|   | Name | Count |'
- en: '| --- | --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **0** | Liam | 19659 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | 19659 |'
- en: '| **1** | Noah | 18252 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | 18252 |'
- en: '| **2** | Oliver | 14147 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver | 14147 |'
- en: '| **...** | ... | ... |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... |'
- en: '| **2020719** | Verona | 5 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **2020719** | Verona | 5 |'
- en: '| **2020720** | Vertie | 5 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **2020720** | Vertie | 5 |'
- en: '| **2020721** | Wilma | 5 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **2020721** | Wilma | 5 |'
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To slice out a specific number of rows, use the `LIMIT` keyword:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要切片出特定数量的行，请使用 `LIMIT` 关键字：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|   | Name |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|   | 名称 |'
- en: '| --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **0** | Liam |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam |'
- en: '| **1** | Noah |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah |'
- en: '| **2** | Oliver |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver |'
- en: '| **...** | ... |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... |'
- en: '| **7** | Lucas |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **7** | Lucas |'
- en: '| **8** | Henry |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| **8** | Henry |'
- en: '| **9** | Alexander |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **9** | Alexander |'
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In sum, we use the `SELECT` and `LIMIT` keywords to slice columns and rows of
    a relation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们使用 `SELECT` 和 `LIMIT` 关键字来切片关系的列和行。
- en: Filtering Rows
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤行
- en: 'Now we turn to *filtering* rows—taking subsets of rows using one or more criteria.
    In `pandas`, we slice dataframes using Boolean series objects. In SQL, we instead
    use the `WHERE` keyword with a predicate. The following query filters the `baby`
    relation to have only the baby names in 2020:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向*过滤*行—使用一个或多个条件取子集的行。在 `pandas` 中，我们使用布尔系列对象切片数据帧。在 SQL 中，我们使用带有谓词的 `WHERE`
    关键字。以下查询将 `baby` 关系过滤为仅包含 2020 年的婴儿姓名：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|   | Name | Sex | Count | Year |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|   | 名称 | 性别 | 计数 | 年份 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **0** | Liam | M | 19659 | 2020 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | M | 19659 | 2020 |'
- en: '| **1** | Noah | M | 18252 | 2020 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | M | 18252 | 2020 |'
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver | M | 14147 | 2020 |'
- en: '| **...** | ... | ... | ... | ... |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... |'
- en: '| **31267** | Zylynn | F | 5 | 2020 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **31267** | Zylynn | F | 5 | 2020 |'
- en: '| **31268** | Zynique | F | 5 | 2020 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **31268** | Zynique | F | 5 | 2020 |'
- en: '| **31269** | Zynlee | F | 5 | 2020 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **31269** | Zynlee | F | 5 | 2020 |'
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Warning
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'Note that when comparing for equality, SQL uses a single equals sign:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在比较相等性时，SQL 使用单等号：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In Python, however, single equals signs are used for variable assignment. The
    statement `Year = 2020` will assign the value `2020` to the variable `Year`. To
    compare for equality, Python code uses double equals signs:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Python 中，单等号用于变量赋值。语句 `Year = 2020` 将值 `2020` 赋给变量 `Year`。要进行相等比较，Python
    代码使用双等号：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To add more predicates to the filter, use the `AND` and `OR` keywords. For
    instance, to find the names that have more than 10,000 babies in either 2020 or
    2019, we write:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要向过滤器添加更多谓词，使用 `AND` 和 `OR` 关键字。例如，要查找在 2020 年或 2019 年出生的超过 10,000 名婴儿的姓名，我们写道：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|   | Name | Sex | Count | Year |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|   | 名称 | 性别 | 计数 | 年份 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **0** | Liam | M | 19659 | 2020 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | M | 19659 | 2020 |'
- en: '| **1** | Noah | M | 18252 | 2020 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | M | 18252 | 2020 |'
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver | M | 14147 | 2020 |'
- en: '| **...** | ... | ... | ... | ... |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... |'
- en: '| **41** | Mia | F | 12452 | 2019 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **41** | Mia | F | 12452 | 2019 |'
- en: '| **42** | Harper | F | 10464 | 2019 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **42** | Harper | F | 10464 | 2019 |'
- en: '| **43** | Evelyn | F | 10412 | 2019 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **43** | Evelyn | F | 10412 | 2019 |'
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, to find the 10 most common names in 2020, we can sort the dataframe
    by `Count` in descending order using the `ORDER BY` keyword with the `DESC` option
    (short for DESCending):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要查找 2020 年最常见的 10 个名字，我们可以使用 `ORDER BY` 关键字和 `DESC` 选项（DESC 表示 DESCending）按
    `Count` 降序排序数据框：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|   | Name | Sex | Count | Year |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|   | 名称 | 性别 | 计数 | 年份 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **0** | Liam | M | 19659 | 2020 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | M | 19659 | 2020 |'
- en: '| **1** | Noah | M | 18252 | 2020 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | M | 18252 | 2020 |'
- en: '| **2** | Emma | F | 15581 | 2020 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Emma | F | 15581 | 2020 |'
- en: '| **...** | ... | ... | ... | ... |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... |'
- en: '| **7** | Sophia | F | 12976 | 2020 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| **7** | Sophia | F | 12976 | 2020 |'
- en: '| **8** | Amelia | F | 12704 | 2020 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **8** | Amelia | F | 12704 | 2020 |'
- en: '| **9** | William | M | 12541 | 2020 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **9** | William | M | 12541 | 2020 |'
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We see that Liam, Noah, and Emma were the most popular baby names in 2020.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，Liam、Noah 和 Emma 是 2020 年最受欢迎的婴儿名字。
- en: 'Example: How Recently Has Luna Become a Popular Name?'
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例如：Luna 何时成为流行名字？
- en: 'As we mentioned in [Chapter 6](ch06.html#ch-pandas), a *New York Times* article
    mentions that the name Luna was almost nonexistent before 2000 but has since grown
    to become a very popular name for girls. When exactly did Luna become popular?
    We can check this in SQL using slicing and filtering:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第 6 章](ch06.html#ch-pandas)中提到的，*纽约时报*文章提到，Luna 这个名字在 2000 年之前几乎不存在，但此后已成为女孩们非常流行的名字。Luna
    何时变得流行？我们可以使用 SQL 中的切片和过滤来检查：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|   | Name | Sex | Count | Year |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|   | 名称 | 性别 | 计数 | 年份 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **0** | Luna | F | 7770 | 2020 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Luna | F | 7770 | 2020 |'
- en: '| **1** | Luna | F | 7772 | 2019 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Luna | F | 7772 | 2019 |'
- en: '| **2** | Luna | F | 6929 | 2018 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Luna | F | 6929 | 2018 |'
- en: '| **...** | ... | ... | ... | ... |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... |'
- en: '| **125** | Luna | F | 17 | 1883 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **125** | Luna | F | 17 | 1883 |'
- en: '| **126** | Luna | F | 18 | 1881 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **126** | Luna | F | 18 | 1881 |'
- en: '| **127** | Luna | F | 15 | 1880 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **127** | Luna | F | 15 | 1880 |'
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`pd.read_sql` returns a `pandas.DataFrame` object, which we can use to make
    a plot. This illustrates a common workflow—process the data using SQL, load it
    into a `pandas` dataframe, then visualize the results:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.read_sql` 返回一个 `pandas.DataFrame` 对象，我们可以用它来绘制图表。这展示了一个常见的工作流程 —— 使用 SQL
    处理数据，将其加载到 `pandas` 数据框中，然后可视化结果：'
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](assets/leds_07in01.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_07in01.png)'
- en: In this section, we introduced the common ways that data scientists subset relations—slicing
    with column labels and filtering using a boolean condition. In the next section,
    we explain how to aggregate rows together.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了数据科学家对关系进行子集处理的常见方法 —— 使用列标签进行切片和使用布尔条件进行过滤。在下一节中，我们将解释如何将行聚合在一起。
- en: Aggregating
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合
- en: 'This section introduces grouping and aggregating in SQL. We’ll work with the
    baby names data, as in the previous section:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 SQL 中的分组和聚合。我们将使用与前一节相同的婴儿名数据：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|   | Name | Sex | Count | Year |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|   | Name | Sex | Count | Year |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **0** | Liam | M | 19659 | 2020 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | M | 19659 | 2020 |'
- en: '| **1** | Noah | M | 18252 | 2020 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | M | 18252 | 2020 |'
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver | M | 14147 | 2020 |'
- en: '| **...** | ... | ... | ... | ... |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... |'
- en: '| **7** | Lucas | M | 11281 | 2020 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **7** | Lucas | M | 11281 | 2020 |'
- en: '| **8** | Henry | M | 10705 | 2020 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **8** | Henry | M | 10705 | 2020 |'
- en: '| **9** | Alexander | M | 10151 | 2020 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **9** | Alexander | M | 10151 | 2020 |'
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Basic Group-Aggregate Using GROUP BY
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本的分组聚合使用 GROUP BY
- en: 'Let’s say we want to find out the total number of babies born as recorded in
    this data. This is simply the sum of the `Count` column. SQL provides functions
    that we use in the `SELECT` statement, like `SUM`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想找出记录在此数据中的总出生婴儿数。这只是 `Count` 列的总和。SQL 提供了我们在 `SELECT` 语句中使用的函数，比如 `SUM`：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|   | SUM(Count) |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|   | SUM(Count) |'
- en: '| --- | --- |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **0** | 352554503 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **0** | 352554503 |'
- en: In [Chapter 6](ch06.html#ch-pandas), we used grouping and aggregation to figure
    out whether US births are trending upward over time. We grouped the dataset by
    year using `.groupby()`, then summed the counts within each group using `.sum()`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 6 章](ch06.html#ch-pandas) 中，我们使用分组和聚合来判断随时间是否有上升趋势的美国出生率。我们使用 `.groupby()`
    按年份对数据集进行分组，然后使用 `.sum()` 在每个组内对计数进行求和。
- en: 'In SQL, we instead group using the `GROUP BY` clause, then call aggregation
    functions in `SELECT`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL 中，我们使用 `GROUP BY` 子句进行分组，然后在 `SELECT` 中调用聚合函数：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|   | Year | SUM(Count) |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|   | Year | SUM(Count) |'
- en: '| --- | --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **0** | 1880 | 194419 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **0** | 1880 | 194419 |'
- en: '| **1** | 1881 | 185772 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| **1** | 1881 | 185772 |'
- en: '| **2** | 1882 | 213385 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| **2** | 1882 | 213385 |'
- en: '| **...** | ... | ... |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... |'
- en: '| **138** | 2018 | 3487193 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| **138** | 2018 | 3487193 |'
- en: '| **139** | 2019 | 3437438 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **139** | 2019 | 3437438 |'
- en: '| **140** | 2020 | 3287724 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| **140** | 2020 | 3287724 |'
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As with dataframe grouping, notice that the `Year` column contains the unique
    `Year` values—there are no duplicate `Year` values anymore since we grouped them
    together. When grouping in `pandas`, the grouping columns become the index of
    the resulting dataframe. However, relations don’t have row labels, so the `Year`
    values are just a column in the resulting relation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据框分组一样，注意 `Year` 列包含唯一的 `Year` 值 —— 因为我们将它们分组在一起，所以不再有重复的 `Year` 值。在 `pandas`
    中进行分组时，分组列成为结果数据框的索引。但是，关系没有行标签，所以 `Year` 值只是结果关系的一列。
- en: 'Here’s the basic recipe for grouping in `SQL`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 `SQL` 中进行分组的基本步骤：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that the order of clauses in a SQL statement is important. To avoid a syntax
    error, `SELECT` needs to appear first, then `FROM`, then `WHERE`, then `GROUP
    BY`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，SQL 语句中子句的顺序很重要。为了避免语法错误，`SELECT` 需要首先出现，然后是 `FROM`，接着是 `WHERE`，最后是 `GROUP
    BY`。
- en: When using `GROUP BY` we need to be careful about the columns given to `SELECT`.
    In general, we can only include columns without an aggregation when we use those
    columns to group. For instance, in the preceding example we grouped by the `Year`
    column, so we can include `Year` in the `SELECT` clause. All other columns included
    in `SELECT` should be aggregated, as we did earlier with `SUM(Count)`. If we included
    a “bare” column like `Name` that wasn’t used for grouping, it’s ambiguous which
    name within the group should be returned. Although bare columns won’t cause an
    error for SQLite, they cause other SQL engines to error, so we recommend avoiding
    them.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `GROUP BY` 时，我们需要注意给 `SELECT` 的列。通常情况下，只有在使用这些列进行分组时，才能包括未经聚合的列。例如，在上述示例中我们按
    `Year` 列进行分组，因此可以在 `SELECT` 子句中包括 `Year`。所有其他包含在 `SELECT` 中的列应该进行聚合，就像我们之前用 `SUM(Count)`
    所做的那样。如果我们包含一个未使用于分组的“裸”列如 `Name`，SQLite 不会报错，但其他 SQL 引擎会报错，因此建议避免这样做。
- en: Grouping on Multiple Columns
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多列分组
- en: 'We pass multiple columns into `GROUP BY` to group by multiple columns at once.
    This is useful when we need to further subdivide our groups. For example, we can
    group by both year and sex to see how many male and female babies were born over
    time:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将多列传递给 `GROUP BY`，以便一次性按多列进行分组。当我们需要进一步细分我们的分组时，这是非常有用的。例如，我们可以按年份和性别分组，以查看随时间变化出生的男女婴儿数量：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|   | Year | Sex | SUM(Count) |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '|   | Year | Sex | SUM(Count) |'
- en: '| --- | --- | --- | --- |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **0** | 1880 | F | 83929 |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| **0** | 1880 | F | 83929 |'
- en: '| **1** | 1880 | M | 110490 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| **1** | 1880 | M | 110490 |'
- en: '| **2** | 1881 | F | 85034 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **2** | 1881 | F | 85034 |'
- en: '| **...** | ... | ... | ... |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... |'
- en: '| **279** | 2019 | M | 1785527 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| **279** | 2019 | M | 1785527 |'
- en: '| **280** | 2020 | F | 1581301 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| **280** | 2020 | F | 1581301 |'
- en: '| **281** | 2020 | M | 1706423 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| **281** | 2020 | M | 1706423 |'
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice that the preceding code is very similar to grouping by a single column,
    except that it gives multiple columns to `GROUP BY` to group by both `Year` and
    `Sex`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述代码与仅按单列进行分组非常相似，唯一的区别在于它为 `GROUP BY` 提供了多列，以便按 `Year` 和 `Sex` 进行分组。
- en: Note
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike `pandas`, SQLite doesn’t provide a simple way to pivot a relation. Instead,
    we can use `GROUP BY` on two columns in SQL, read the result into a dataframe,
    and then use the `unstack()` dataframe method.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `pandas` 不同，SQLite 没有提供简单的方法来对关系表进行透视。相反，我们可以在 SQL 中对两列使用 `GROUP BY`，将结果读取到数据框中，然后使用
    `unstack()` 数据框方法。
- en: Other Aggregation Functions
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他聚合函数
- en: SQLite has several other built-in aggregation functions besides `SUM`, such
    as `COUNT`, `AVG`, `MIN`, and `MAX`. For the full list of functions, consult [the
    SQLite website](https://oreil.ly/ALtjb).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 除了 `SUM` 外，还有几个内置的聚合函数，例如 `COUNT`、`AVG`、`MIN` 和 `MAX`。有关完整的函数列表，请参阅[SQLite
    网站](https://oreil.ly/ALtjb)。
- en: 'To use another aggregation function, we call it in the `SELECT` clause. For
    instance, we can use `MAX` instead of `SUM`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用其他聚合函数，我们在 `SELECT` 子句中调用它。例如，我们可以使用 `MAX` 替代 `SUM`：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|   | Year | MAX(Count) |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '|   | Year | MAX(Count) |'
- en: '| --- | --- | --- |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **0** | 1880 | 9655 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| **0** | 1880 | 9655 |'
- en: '| **1** | 1881 | 8769 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| **1** | 1881 | 8769 |'
- en: '| **2** | 1882 | 9557 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| **2** | 1882 | 9557 |'
- en: '| **...** | ... | ... |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... |'
- en: '| **138** | 2018 | 19924 |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| **138** | 2018 | 19924 |'
- en: '| **139** | 2019 | 20555 |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **139** | 2019 | 20555 |'
- en: '| **140** | 2020 | 19659 |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **140** | 2020 | 19659 |'
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-204
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The built-in aggregation functions are one of the first places a data scientist
    may encounter differences in SQL implementations. For instance, SQLite has a relatively
    minimal set of aggregation functions while [PostgreSQL has many more](https://oreil.ly/gqYoK).
    That said, almost all SQL implementations provide `SUM`, `COUNT`, `MIN`, `MAX`,
    and `AVG`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的聚合函数是数据科学家可能在 SQL 实现中首次遇到差异的地方之一。例如，SQLite 拥有相对较少的聚合函数，而[PostgreSQL 拥有更多](https://oreil.ly/gqYoK)。尽管如此，几乎所有
    SQL 实现都提供 `SUM`、`COUNT`、`MIN`、`MAX` 和 `AVG`。
- en: This section covered common ways to aggregate data in SQL using the `GROUP BY`
    keyword with one or more columns. In the next section, we’ll explain how to join
    relations together.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分涵盖了使用 SQL 中的 `GROUP BY` 关键字以一个或多个列对数据进行聚合的常见方法。在接下来的部分中，我们将解释如何将关系表进行连接。
- en: Joining
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接
- en: To connect records between two data tables, SQL relations can be joined together
    similar to dataframes. In this section, we introduce SQL joins to replicate our
    analysis of the baby names data. Recall that [Chapter 6](ch06.html#ch-pandas)
    mentions a *New York Times* article that talks about how certain name categories,
    like mythological and baby boomer names, have become more or less popular over
    time.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接两个数据表之间的记录，可以像数据框一样使用SQL关系进行连接。在本节中，我们介绍SQL连接以复制我们对婴儿姓名数据的分析。回想一下，[第6章](ch06.html#ch-pandas)提到了一篇*纽约时报*文章，讨论了某些姓名类别（如神话和婴儿潮时期的姓名）随着时间的推移变得更受欢迎或不受欢迎的情况。
- en: 'We’ve taken the names and categories in the *NYT* article and put them in a
    small relation named `nyt`. First, the code sets up a connection to a database,
    then runs a SQL query to display the `nyt` relation:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将*NYT*文章中的姓名和类别放入名为`nyt`的小关系中。首先，代码建立了与数据库的连接，然后运行SQL查询以显示`nyt`关系：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|   | nyt_name | category |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '|   | nyt_name | 类别 |'
- en: '| --- | --- | --- |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **0** | Lucifer | forbidden |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Lucifer | forbidden |'
- en: '| **1** | Lilith | forbidden |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Lilith | forbidden |'
- en: '| **2** | Danger | forbidden |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Danger | forbidden |'
- en: '| **...** | ... | ... |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... |'
- en: '| **20** | Venus | celestial |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| **20** | Venus | celestial |'
- en: '| **21** | Celestia | celestial |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| **21** | Celestia | celestial |'
- en: '| **22** | Skye | celestial |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| **22** | Skye | celestial |'
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: Notice that the preceding code runs a query on `babynames.db`, the same database
    that contains the larger `baby` relation from the previous sections. SQL databases
    can hold more than one relation, making them very useful when we need to work
    with many data tables at once. CSV files, on the other hand, typically contain
    one data table each—if we perform a data analysis that uses 20 data tables, we
    might need to keep track of the names, locations, and versions of 20 CSV files.
    Instead, it could be simpler to store all the data tables in a SQLite database
    stored in a single file.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到前面的代码在`babynames.db`上运行查询，这个数据库包含前几节中较大的`baby`关系。SQL数据库可以容纳多个关系，当我们需要同时处理多个数据表时非常有用。另一方面，CSV文件通常只包含一个数据表——如果我们执行一个使用20个数据表的数据分析，可能需要跟踪20个CSV文件的名称、位置和版本。相反，将所有数据表存储在单个文件中的SQLite数据库中可能更简单。
- en: To see how popular the categories of names are, we join the `nyt` relation with
    the `baby` relation to get the name counts from `baby`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看姓名类别的受欢迎程度，我们将`nyt`关系与`baby`关系连接，以从`baby`中获取姓名计数。
- en: Inner Joins
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内连接
- en: 'As in [Chapter 6](ch06.html#ch-pandas), we’ve made smaller versions of the
    `baby` and `nyt` tables so that it’s easier to see what happens when we join tables
    together. The relations are called `baby_small` and `nyt_small`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在[第6章](ch06.html#ch-pandas)中一样，我们制作了`baby`和`nyt`表的较小版本，以便更容易地查看在表合并时发生的情况。这些关系被称为`baby_small`和`nyt_small`：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|   | Name | Sex | Count | Year |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|   | 姓名 | 性别 | 数量 | 年份 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **0** | Noah | M | 18252 | 2020 |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Noah | M | 18252 | 2020 |'
- en: '| **1** | Julius | M | 960 | 2020 |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Julius | M | 960 | 2020 |'
- en: '| **2** | Karen | M | 6 | 2020 |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Karen | M | 6 | 2020 |'
- en: '| **3** | Karen | F | 325 | 2020 |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| **3** | Karen | F | 325 | 2020 |'
- en: '| **4** | Noah | F | 305 | 2020 |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| **4** | Noah | F | 305 | 2020 |'
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|   | nyt_name | category |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|   | nyt_name | 类别 |'
- en: '| --- | --- | --- |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **0** | Karen | boomer |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Karen | boomer |'
- en: '| **1** | Julius | mythology |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Julius | mythology |'
- en: '| **2** | Freya | mythology |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Freya | mythology |'
- en: 'To join relations in SQL, we use the `INNER JOIN` clause to say which tables
    we want to join and the `ON` clause to specify a predicate for joining the tables.
    Here’s an example:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要在SQL中连接关系，我们使用`INNER JOIN`子句来指定要连接的表，并使用`ON`子句来指定表连接的条件。这里是一个示例：
- en: '[PRE38]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|   | Name | Sex | Count | Year | nyt_name | category |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '|   | 姓名 | 性别 | 数量 | 年份 | nyt_name | 类别 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| **0** | Julius | M | 960 | 2020 | Julius | mythology |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Julius | M | 960 | 2020 | Julius | mythology |'
- en: '| **1** | Karen | M | 6 | 2020 | Karen | boomer |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Karen | M | 6 | 2020 | Karen | boomer |'
- en: '| **2** | Karen | F | 325 | 2020 | Karen | boomer |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Karen | F | 325 | 2020 | Karen | boomer |'
- en: 'Notice that this result is the same as doing an inner join in `pandas`: the
    new table has the columns of both the `baby_small` and `nyt_small` tables. The
    rows with the name Noah are gone, and the remaining rows have their matching `category`
    from `nyt_small`.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到这个结果与在`pandas`中进行内连接的结果相同：新表具有`baby_small`和`nyt_small`表的列。Noah的行已消失，并且剩余的行具有它们在`nyt_small`中的匹配`category`。
- en: To join two tables together, we tell SQL the column(s) from each table that
    we want to do the join with, using a predicate with the `ON` keyword. SQL matches
    rows together when the values in the joining columns fulfill the predicate, as
    shown in [Figure 7-2](#fig-sql-inner-join).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要将两个表连接在一起，我们告诉 SQL 我们想要使用的每个表的列，并使用带有 `ON` 关键字的谓词进行连接。当连接列中的值满足谓词时，SQL 将行进行匹配，如
    [Figure 7-2](#fig-sql-inner-join) 所示。
- en: Unlike `pandas`, SQL gives more flexibility on how rows are joined. The `pd.merge()`
    method can only join using simple equality, but the predicate in the `ON` clause
    can be arbitrarily complex. As an example, we take advantage of this extra versatility
    in [“Finding Collocated Sensors”](ch12.html#sec-pa-collocated).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `pandas` 不同，SQL 在行连接方面提供了更大的灵活性。`pd.merge()` 方法只能使用简单的相等条件进行连接，但是 `ON` 子句中的谓词可以是任意复杂的。例如，在
    [“Finding Collocated Sensors”](ch12.html#sec-pa-collocated) 中，我们利用了这种额外的多样性。
- en: '![sql-inner-join](assets/leds_0702.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![sql-inner-join](assets/leds_0702.png)'
- en: Figure 7-2\. Joining two tables together with SQL
  id: totrans-252
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-2\. 使用 SQL 将两个表连接在一起
- en: Left and Right Joins
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 左连接和右连接
- en: 'Like `pandas`, SQL also supports left joins. Instead of saying `INNER JOIN`,
    we use `LEFT JOIN`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `pandas`，SQL 也支持左连接。我们使用 `LEFT JOIN` 而不是 `INNER JOIN`：
- en: '[PRE39]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|   | Name | Sex | Count | Year | nyt_name | category |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '|   | Name | Sex | Count | Year | nyt_name | category |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| **0** | Noah | M | 18252 | 2020 | None | None |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Noah | M | 18252 | 2020 | None | None |'
- en: '| **1** | Julius | M | 960 | 2020 | Julius | mythology |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Julius | M | 960 | 2020 | Julius | mythology |'
- en: '| **2** | Karen | M | 6 | 2020 | Karen | boomer |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Karen | M | 6 | 2020 | Karen | 潮妈 |'
- en: '| **3** | Karen | F | 325 | 2020 | Karen | boomer |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| **3** | Karen | F | 325 | 2020 | Karen | 潮妈 |'
- en: '| **4** | Noah | F | 305 | 2020 | None | None |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| **4** | Noah | F | 305 | 2020 | None | None |'
- en: As we might expect, the “left” side of the join refers to the table that appears
    on the left side of the `LEFT JOIN` keyword. We can see the `Noah` rows are kept
    in the resulting relation even when they don’t have a match in the righthand relation.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所料，连接的“左”侧指的是出现在 `LEFT JOIN` 关键字左侧的表。我们可以看到即使 `Noah` 行在右侧关系中没有匹配时，它们仍然会保留在结果关系中。
- en: 'Note that SQLite doesn’t support right joins directly, but we can perform the
    same join by swapping the order of relations, then using `LEFT JOIN`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，SQLite 不直接支持右连接，但是我们可以通过交换关系的顺序，然后使用 `LEFT JOIN` 来执行相同的连接：
- en: '[PRE40]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|   | nyt_name | category | Name | Sex | Count | Year |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '|   | nyt_name | category | Name | Sex | Count | Year |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| **0** | Karen | boomer | Karen | F | 325.0 | 2020.0 |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Karen | 潮妈 | Karen | F | 325.0 | 2020.0 |'
- en: '| **1** | Karen | boomer | Karen | M | 6.0 | 2020.0 |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Karen | 潮妈 | Karen | M | 6.0 | 2020.0 |'
- en: '| **2** | Julius | mythology | Julius | M | 960.0 | 2020.0 |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Julius | mythology | Julius | M | 960.0 | 2020.0 |'
- en: '| **3** | Freya | mythology | None | None | NaN | NaN |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| **3** | Freya | mythology | None | None | NaN | NaN |'
- en: SQLite doesn’t have a built-in keyword for outer joins. In cases where an outer
    join is needed, we have to either use a different SQL engine or perform an outer
    join via `pandas`. However, in our (the authors’) experience, outer joins are
    rarely used in practice compared to inner and left joins.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 没有内置的外连接关键字。在需要外连接的情况下，我们可以使用不同的 SQL 引擎或通过 `pandas` 执行外连接。然而，在我们（作者）的经验中，与内连接和左连接相比，外连接在实践中很少使用。
- en: 'Example: Popularity of NYT Name Categories'
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：NYT 姓名类别的流行度
- en: Now let’s return to the full `baby` and `nyt` relations.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们返回到完整的 `baby` 和 `nyt` 关系。
- en: 'We want to know how the popularity of name categories in `nyt` has changed
    over time. To answer this question, we should:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想知道 `nyt` 中姓名类别的流行程度随时间的变化。要回答这个问题，我们应该：
- en: Inner join `baby` with `nyt`, matching rows where the names are equal.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ON` 关键字中指定的列内连接 `baby` 和 `nyt`，匹配姓名相等的行。
- en: Group the table by `category` and `Year`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 `category` 和 `Year` 对表进行分组。
- en: 'Aggregate the counts using a sum:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用求和对计数进行聚合：
- en: '[PRE41]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '|   | category | Year | count |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '|   | category | Year | count |'
- en: '| --- | --- | --- | --- |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **0** | boomer | 1880 | 292 |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| **0** | 潮妈 | 1880 | 292 |'
- en: '| **1** | boomer | 1881 | 298 |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| **1** | 潮妈 | 1881 | 298 |'
- en: '| **2** | boomer | 1882 | 326 |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| **2** | 潮妈 | 1882 | 326 |'
- en: '| **...** | ... | ... | ... |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... |'
- en: '| **647** | mythology | 2018 | 2944 |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| **647** | mythology | 2018 | 2944 |'
- en: '| **648** | mythology | 2019 | 3320 |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| **648** | mythology | 2019 | 3320 |'
- en: '| **649** | mythology | 2020 | 3489 |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| **649** | mythology | 2020 | 3489 |'
- en: '[PRE42]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The numbers in square brackets (`[1]`, `[2]`, `[3]`) in the preceding query
    show how each step in our plan maps to the parts of the SQL query. The code re-creates
    the dataframe from [Chapter 6](ch06.html#ch-pandas), where we created plots to
    verify the claims of the *New York Times* article. For brevity, we omit duplicating
    the plots here.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述查询中方括号中的数字（`[1]`、`[2]`、`[3]`）显示了我们计划中的每个步骤如何映射到 SQL 查询的部分。代码重新创建了来自 [第 6
    章](ch06.html#ch-pandas) 的数据框，我们在其中创建了图表以验证 *纽约时报* 文章的主张。为简洁起见，我们在此省略了重复绘制图表的部分。
- en: Note
  id: totrans-291
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that in the SQL code in this example, the numbers appear out of order—`[3]`,
    `[1]`, then `[2]`. As a rule of thumb for first-time SQL learners, we can often
    think of the `SELECT` statement as the *last* piece of the query to execute even
    though it appears first.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此示例中的 SQL 代码中，数字的顺序看起来是不正确的——`[3]`、`[1]`，然后是`[2]`。对于首次学习 SQL 的人来说，我们通常可以将
    `SELECT` 语句看作查询的*最后*执行的部分，即使它首先出现。
- en: In this section, we introduced joins for relations. When joining relations together,
    we match rows using the `INNER JOIN` or `LEFT JOIN` keyword and a boolean predicate.
    In the next section, we’ll explain how to transform values in a relation.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了用于关系的连接。当将关系连接在一起时，我们使用 `INNER JOIN` 或 `LEFT JOIN` 关键字以及布尔谓词来匹配行。在下一节中，我们将解释如何转换关系中的值。
- en: Transforming and Common Table Expressions
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换和公共表达式（CTE）
- en: 'In this section, we show how to call functions to transform columns of data
    using built-in SQL functions. We also demonstrate how to use common table expressions
    to build up complex queries from simpler ones. As usual, we start by loading the
    database:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了如何调用内置 SQL 函数来转换数据列。我们还演示了如何使用公共表达式（CTE）从简单查询构建复杂查询。与往常一样，我们首先加载数据库：
- en: '[PRE43]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: SQL Functions
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 函数
- en: SQLite provides a variety of *scalar functions*, or functions that transform
    single data values. When called on a column of data, SQLite will apply these functions
    on each value in the column. In contrast, aggregation functions like `SUM` and
    `COUNT` take a column of values as input and compute a single value as output.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 提供了多种*标量函数*，即用于转换单个数据值的函数。当在数据列上调用时，SQLite 将对列中的每个值应用这些函数。相比之下，像 `SUM`
    和 `COUNT` 这样的聚合函数以数据列作为输入，并计算单个值作为输出。
- en: 'SQLite provides a comprehensive list of the built-in scalar functions in [its
    online documentation](https://oreil.ly/kznBO). For instance, to find the number
    of characters in each name, we use the `LENGTH` function:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 在其[在线文档](https://oreil.ly/kznBO)中提供了内置标量函数的详尽列表。例如，要找出每个名称中的字符数，我们使用
    `LENGTH` 函数：
- en: '[PRE44]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '|   | Name | LENGTH(Name) |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '|   | Name | LENGTH(Name) |'
- en: '| --- | --- | --- |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **0** | Liam | 4 |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | 4 |'
- en: '| **1** | Noah | 4 |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | 4 |'
- en: '| **2** | Oliver | 6 |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver | 6 |'
- en: '| **...** | ... | ... |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... |'
- en: '| **7** | Lucas | 5 |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| **7** | Lucas | 5 |'
- en: '| **8** | Henry | 5 |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| **8** | Henry | 5 |'
- en: '| **9** | Alexander | 9 |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| **9** | Alexander | 9 |'
- en: '[PRE45]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Notice that the `LENGTH` function is applied to each value within the `Name`
    column.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`LENGTH` 函数应用于 `Name` 列中的每个值。
- en: Note
  id: totrans-312
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Like aggregation functions, each implementation of SQL provides a different
    set of scalar functions. SQLite has a relatively minimal set of functions, while
    [PostgreSQL has many more](https://oreil.ly/i2KIA). That said, almost all SQL
    implementations provide some equivalent to SQLite’s `LENGTH`, `ROUND`, `SUBSTR`,
    and `LIKE` functions.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 像聚合函数一样，每个 SQL 实现都提供了不同的标量函数集。SQLite 提供的函数集相对较少，而 [PostgreSQL 则更多](https://oreil.ly/i2KIA)。尽管如此，几乎所有
    SQL 实现都提供了与 SQLite 的 `LENGTH`、`ROUND`、`SUBSTR` 和 `LIKE` 函数相当的功能。
- en: 'Although scalar functions use the same syntax as an aggregation function, they
    behave differently. This can result in confusing output if the two are mixed together
    in a single query:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然标量函数与聚合函数使用相同的语法，但它们的行为不同。如果在单个查询中混合使用这两种函数，可能会导致输出结果混乱：
- en: '[PRE46]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '|   | Name | LENGTH(Name) | AVG(Count) |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '|   | Name | LENGTH(Name) | AVG(Count) |'
- en: '| --- | --- | --- | --- |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **0** | Liam | 4 | 174.47 |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | 4 | 174.47 |'
- en: Here, the `AVG(Name)` computes the average of the entire `Count` column, but
    the output is confusing—a reader could easily think the average is related to
    the name Liam. For this reason, we must be careful when scalar and aggregation
    functions appear together within a `SELECT` statement.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`AVG(Name)` 计算了整个 `Count` 列的平均值，但输出结果令人困惑——读者很容易会认为平均值与名字 Liam 有关。因此，当标量函数和聚合函数同时出现在
    `SELECT` 语句中时，我们必须格外小心。
- en: 'To extract the first letter of each name, we can use the `SUBSTR` function
    (short for *substring*). As described in the documentation, the `SUBSTR` function
    takes three arguments. The first is the input string, the second is the position
    to begin the substring (1-indexed), and the third is the length of the substring:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取每个名称的首字母，我们可以使用 `SUBSTR` 函数（缩写为*substring*）。如文档中所述，`SUBSTR` 函数接受三个参数。第一个是输入字符串，第二个是开始子字符串的位置（从
    1 开始索引），第三个是子字符串的长度：
- en: '[PRE47]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '|   | Name | SUBSTR(Name, 1, 1) |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '|   | 名称 | SUBSTR(名称, 1, 1) |'
- en: '| --- | --- | --- |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **0** | Liam | L |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | L |'
- en: '| **1** | Noah | N |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | N |'
- en: '| **2** | Oliver | O |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver | O |'
- en: '| **...** | ... | ... |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... |'
- en: '| **7** | Lucas | L |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| **7** | Lucas | L |'
- en: '| **8** | Henry | H |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| **8** | Henry | H |'
- en: '| **9** | Alexander | A |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| **9** | Alexander | A |'
- en: '[PRE48]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can use the `AS` keyword to rename the column:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `AS` 关键字重命名列：
- en: '[PRE49]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '|   | Name | Sex | Count | Year | Firsts |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '|   | 名称 | 性别 | 数量 | 年份 | 首字母 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| **0** | Liam | M | 19659 | 2020 | L |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | M | 19659 | 2020 | L |'
- en: '| **1** | Noah | M | 18252 | 2020 | N |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | M | 18252 | 2020 | N |'
- en: '| **2** | Oliver | M | 14147 | 2020 | O |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver | M | 14147 | 2020 | O |'
- en: '| **...** | ... | ... | ... | ... | ... |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... | ... |'
- en: '| **7** | Lucas | M | 11281 | 2020 | L |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| **7** | Lucas | M | 11281 | 2020 | L |'
- en: '| **8** | Henry | M | 10705 | 2020 | H |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| **8** | Henry | M | 10705 | 2020 | H |'
- en: '| **9** | Alexander | M | 10151 | 2020 | A |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| **9** | Alexander | M | 10151 | 2020 | A |'
- en: '[PRE50]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: After calculating the first letter of each name, our analysis aims to understand
    the popularity of first letters over time. To do this, we want to take the output
    of this SQL query and use it as a single step within a longer chain of operations.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算每个名称的首字母后，我们的分析旨在了解不同时间段内首字母的流行度。为此，我们希望将这个 SQL 查询的输出用作更长操作链中的单个步骤。
- en: SQL provides several options to break queries into smaller steps, which is helpful
    in more complex analyses like this one. The most common options for doing this
    are to create a new relation using a `CREATE TABLE` statement, create a new view
    using `CREATE VIEW`, or create a temporary relation using `WITH`. Each of these
    methods has different use-cases. For simplicity, we only describe the `WITH` statement
    in this section and suggest that readers look over the SQLite documentation for
    details.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 提供了几种选项来将查询分解为较小的步骤，这在像这样更复杂的分析中非常有帮助。最常见的选项是使用 `CREATE TABLE` 语句创建新关系，使用
    `CREATE VIEW` 创建新视图，或者使用 `WITH` 创建临时关系。每种方法都有不同的用例。为简单起见，我们在本节仅描述 `WITH` 语句，并建议读者查阅
    SQLite 文档以获取详细信息。
- en: Multistep Queries Using a WITH Clause
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `WITH` 子句进行多步查询
- en: 'The `WITH` clause lets us assign a name to any `SELECT` query. Then we can
    treat that query as though it exists as a relation in the database just for the
    duration of the query. SQLite calls these temporary relations *common table expressions*.
    For instance, we can take the earlier query that calculates the first letter of
    each name and call it `letters`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`WITH` 子句允许我们为任何 `SELECT` 查询指定一个名称。然后我们可以把该查询视为数据库中的一个关系，仅在查询的持续时间内存在。SQLite
    将这些临时关系称为*公共表达式*。例如，我们可以取之前计算每个名称的首字母的查询，并称其为 `letters`：'
- en: '[PRE51]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '|   | Name | Sex | Count | Year | Firsts |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '|   | 名称 | 性别 | 数量 | 年份 | 首字母 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| **0** | Liam | M | 19659 | 2020 | L |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | M | 19659 | 2020 | L |'
- en: '| **1** | Noah | M | 18252 | 2020 | N |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | M | 18252 | 2020 | N |'
- en: '| **2** | Oliver | M | 14147 | 2020 | O |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver | M | 14147 | 2020 | O |'
- en: '| **...** | ... | ... | ... | ... | ... |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... | ... |'
- en: '| **7** | Lucas | M | 11281 | 2020 | L |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| **7** | Lucas | M | 11281 | 2020 | L |'
- en: '| **8** | Henry | M | 10705 | 2020 | H |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| **8** | Henry | M | 10705 | 2020 | H |'
- en: '| **9** | Alexander | M | 10151 | 2020 | A |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| **9** | Alexander | M | 10151 | 2020 | A |'
- en: '[PRE52]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`WITH` statements are very useful since they can be chained together. We can
    create multiple temporary relations in a `WITH` statement that each perform a
    bit of work on the previous result, which lets us gradually build complicated
    queries a step at a time.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`WITH` 语句非常有用，因为它们可以链接在一起。我们可以在 `WITH` 语句中创建多个临时关系，每个关系对前一个结果执行一些工作，这样可以逐步构建复杂的查询。'
- en: 'Example: Popularity of “L” Names'
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例如：“L” 名字的流行度
- en: 'We can use `WITH` statements to look at the popularity of names that start
    with the letter L over time. We’ll group the temporary `letters` relation by the
    first letter and year, then aggregate the `Count` column using a sum, then filter
    to get only names with the letter L:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`WITH`语句来查看以字母L开头的名字随时间的流行度。我们将临时`letters`关系按首字母和年份分组，然后使用求和聚合`Count`列，然后筛选只获取字母L开头的名字：
- en: '[PRE53]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '|   | Firsts | Year | Count |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh:   | 首字母 | 年份 | 数量 |
- en: '| --- | --- | --- | --- |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **0** | L | 1880 | 12799 |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| **0** | L | 1880 | 12799 |'
- en: '| **1** | L | 1881 | 12770 |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| **1** | L | 1881 | 12770 |'
- en: '| **2** | L | 1882 | 14923 |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| **2** | L | 1882 | 14923 |'
- en: '| **...** | ... | ... | ... |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... |'
- en: '| **138** | L | 2018 | 246251 |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| **138** | L | 2018 | 246251 |'
- en: '| **139** | L | 2019 | 249315 |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| **139** | L | 2019 | 249315 |'
- en: '| **140** | L | 2020 | 239760 |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| **140** | L | 2020 | 239760 |'
- en: '[PRE54]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This relation contains the same data as the one from [Chapter 6](ch06.html#ch-pandas).
    In that chapter, we make a plot of the `Count` column over time, which we omit
    here for brevity.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关系包含与[第6章](ch06.html#ch-pandas)相同的数据。在那一章中，我们制作了`Count`列随时间变化的图表，这里为了简洁起见省略了。
- en: In this section, we introduced data transformations. To transform values in
    a relation, we commonly use SQL functions like `LENGTH()` or `SUBSTR()`. We also
    explained how to build up complex queries using the `WITH` clause.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们介绍了数据转换。为了转换关系中的值，我们通常使用SQL函数如`LENGTH()`或`SUBSTR()`。我们还解释了如何使用`WITH`子句构建复杂查询。
- en: Summary
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, we explained what relations are, why they’re useful, and how
    to work with them using SQL code. SQL databases are useful for many real-world
    settings. For example, SQL databases typically have robust data recovery mechanisms—if
    the computer crashes while in the middle of a SQL operation, the database system
    can recover as much data as possible without corruption. As mentioned earlier,
    SQL databases can also handle larger scale; organizations use SQL databases to
    store and query databases that are far too large to analyze in memory using `pandas`
    code. These are just a few reasons why SQL is an important part of the data science
    toolbox, and we expect that many readers will soon encounter SQL code as part
    of their work.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了什么是关系，它们为何有用，以及如何使用SQL代码处理它们。SQL数据库在许多现实世界的场景中非常有用。例如，SQL数据库通常具有强大的数据恢复机制——如果计算机在SQL操作中崩溃，数据库系统可以尽可能恢复数据而不会损坏。如前所述，SQL数据库还能处理更大规模的数据；组织使用SQL数据库来存储和查询那些用`pandas`代码无法在内存中分析的大型数据库。这些只是SQL成为数据科学工具箱中重要一环的几个原因，我们预计许多读者很快会在工作中遇到SQL代码。
