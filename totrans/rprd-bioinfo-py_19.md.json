["```py\n$ for LETTERS in bz qr st qu\n> do echo -n $LETTERS && grep $LETTERS /usr/share/dict/words | wc -l; done\nbz       4\nqr       1\nst   21433\nqu    3553\n```", "```py\n$ wc -l /usr/share/dict/words\n  235886 /usr/share/dict/words\n```", "```py\n$ grep -E '.*the.*the.*' /usr/share/dict/words | head -3\ndiathermotherapy\nenthelminthes\nhyperthermesthesia\n```", "```py\n$ grep -io thr /usr/share/dict/words | wc -l\n    1270\n$ grep -io the /usr/share/dict/words | wc -l\n    3593\n```", "```py\n$ cd 17_synth\n$ cp solution.py synth.py\n```", "```py\n$ ./synth.py -h\nusage: synth.py [-h] [-o FILE] [-f format] [-n number] [-x max] [-m min]\n                [-k kmer] [-s seed]\n                FILE [FILE ...]\n\nCreate synthetic DNA using Markov chain\n\npositional arguments:\n  FILE                  Training file(s) ![1](assets/1.png)\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -o FILE, --outfile FILE\n                        Output filename (default: out.fa) ![2](assets/2.png)\n  -f format, --format format\n                        Input file format (default: fasta) ![3](assets/3.png)\n  -n number, --num number\n                        Number of sequences to create (default: 100) ![4](assets/4.png)\n  -x max, --max_len max\n                        Maximum sequence length (default: 75) ![5](assets/5.png)\n  -m min, --min_len min\n                        Minimum sequence length (default: 50) ![6](assets/6.png)\n  -k kmer, --kmer kmer  Size of kmers (default: 10) ![7](assets/7.png)\n  -s seed, --seed seed  Random seed value (default: None) ![8](assets/8.png)\n```", "```py\nfrom typing import NamedTuple, List, TextIO, Dict, Optional\n\nclass Args(NamedTuple):\n    \"\"\" Command-line arguments \"\"\"\n    files: List[TextIO] ![1](assets/1.png)\n    outfile: TextIO ![2](assets/2.png)\n    file_format: str ![3](assets/3.png)\n    num: int ![4](assets/4.png)\n    min_len: int ![5](assets/5.png)\n    max_len: int ![6](assets/6.png)\n    k: int ![7](assets/7.png)\n    seed: Optional[int] ![8](assets/8.png)\n```", "```py\ndef get_args() -> Args:\n    \"\"\" Get command-line arguments \"\"\"\n\n    parser = argparse.ArgumentParser(\n        description='Create synthetic DNA using Markov chain',\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n\n    parser.add_argument('file',\n                        help='Training file(s)',\n                        metavar='FILE',\n                        nargs='+',\n                        type=argparse.FileType('rt')) ![1](assets/1.png)\n\n    parser.add_argument('-o',\n                        '--outfile',\n                        help='Output filename',\n                        metavar='FILE',\n                        type=argparse.FileType('wt'), ![2](assets/2.png)\n                        default='out.fa')\n\n    parser.add_argument('-f',\n                        '--format',\n                        help='Input file format',\n                        metavar='format',\n                        type=str,\n                        choices=['fasta', 'fastq'], ![3](assets/3.png)\n                        default='fasta')\n\n    parser.add_argument('-n',\n                        '--num',\n                        help='Number of sequences to create',\n                        metavar='number',\n                        type=int,\n                        default=100) ![4](assets/4.png)\n\n    parser.add_argument('-x',\n                        '--max_len',\n                        help='Maximum sequence length',\n                        metavar='max',\n                        type=int,\n                        default=75) ![5](assets/5.png)\n\n    parser.add_argument('-m',\n                        '--min_len',\n                        help='Minimum sequence length',\n                        metavar='min',\n                        type=int,\n                        default=50) ![6](assets/6.png)\n\n    parser.add_argument('-k',\n                        '--kmer',\n                        help='Size of kmers',\n                        metavar='kmer',\n                        type=int,\n                        default=10) ![7](assets/7.png)\n\n    parser.add_argument('-s',\n                        '--seed',\n                        help='Random seed value',\n                        metavar='seed',\n                        type=int,\n                        default=None) ![8](assets/8.png)\n\n    args = parser.parse_args()\n\n    return Args(files=args.file,\n                outfile=args.outfile,\n                file_format=args.format,\n                num=args.num,\n                min_len=args.min_len,\n                max_len=args.max_len,\n                k=args.kmer,\n                seed=args.seed)\n```", "```py\n>>> bases = list('ACGT')\n>>> import random\n>>> random.choice(bases)\n'G'\n```", "```py\n>>> [random.choice(bases) for _ in range(10)]\n['G', 'T', 'A', 'A', 'C', 'T', 'C', 'T', 'C', 'T']\n```", "```py\n>>> [random.choice(bases) for _ in range(random.randint(10, 20))]\n['G', 'T', 'C', 'A', 'C', 'C', 'A', 'G', 'C', 'A', 'G']\n```", "```py\n>>> random.seed(1)\n>>> [random.choice(bases) for _ in range(random.randint(10, 20))]\n['A', 'G', 'A', 'T', 'T', 'T', 'T', 'C', 'A', 'T', 'A', 'T']\n```", "```py\n>>> random.seed('markov')\n>>> [random.choice(bases) for _ in range(random.randint(10, 20))]\n['G', 'A', 'G', 'C', 'T', 'A', 'A', 'C', 'G', 'T', 'C', 'C', 'C', 'G', 'G']\n```", "```py\n>>> random.seed(4) ![1](assets/1.png)\n>>> [random.choice(bases) for _ in range(random.randint(10, 20))]\n['G', 'A', 'T', 'T', 'C', 'A', 'A', 'A', 'T', 'G', 'A', 'C', 'G']\n>>> random.seed('4') ![2](assets/2.png)\n>>> [random.choice(bases) for _ in range(random.randint(10, 20))]\n['G', 'A', 'T', 'C', 'G', 'G', 'A', 'G', 'A', 'C', 'C', 'A']\n```", "```py\ndef main() -> None:\n    args = get_args()\n    random.seed(args.seed)\n```", "```py\nWeightedChoice = Dict[str, float]\n```", "```py\n>>> choices = {'T': 0.5, 'C': 0.5}\n```", "```py\nChain = Dict[str, WeightedChoice]\n```", "```py\n>>> weighted = {'ACG': {'T': 0.5, 'C': 0.5}}\n```", "```py\ndef read_training(fhs: List[TextIO], file_format: str, k: int) -> Chain: ![1](assets/1.png)\n    \"\"\" Read training files, return dict of chains \"\"\"\n\n    pass ![2](assets/2.png)\n```", "```py\ndef find_kmers(seq: str, k: int) -> List[str]:\n    \"\"\" Find k-mers in string \"\"\"\n```", "```py\ndef test_find_kmers() -> None:\n    \"\"\" Test find_kmers \"\"\"\n\n    assert find_kmers('ACTG', 2) == ['AC', 'CT', 'TG']\n    assert find_kmers('ACTG', 3) == ['ACT', 'CTG']\n    assert find_kmers('ACTG', 4) == ['ACTG']\n```", "```py\ndef test_read_training() -> None: ![1](assets/1.png)\n    \"\"\" Test read_training \"\"\"\n\n    f1 = io.StringIO('>1\\nACGTACGC\\n') ![2](assets/2.png)\n    assert read_training([f1], 'fasta', 4) == { ![3](assets/3.png)\n        'ACG': { 'T': 0.5, 'C': 0.5 },\n        'CGT': { 'A': 1.0 },\n        'GTA': { 'C': 1.0 },\n        'TAC': { 'G': 1.0 }\n    }\n\n    f2 = io.StringIO('@1\\nACGTACGC\\n+\\n!!!!!!!!') ![4](assets/4.png)\n    assert read_training([f2], 'fastq', 5) == {  ![5](assets/5.png)\n        'ACGT': { 'A': 1.0 },\n        'CGTA': { 'C': 1.0 },\n        'GTAC': { 'G': 1.0 },\n        'TACG': { 'C': 1.0 }\n    }\n```", "```py\n$ ./kmer_tiler.py ACGTACGC -k 4\nThere are 5 4-mers in \"ACGTACGC.\"\nACGTACGC\nACGT ![1](assets/1.png)\n CGTA\n  GTAC\n   TACG\n    ACGC ![2](assets/2.png)\n```", "```py\n{\n    'ACG': Counter({'T': 1, 'C': 1}),\n    'CGT': Counter({'A': 1}),\n    'GTA': Counter({'C': 1}),\n    'TAC': Counter({'G': 1})\n}\n```", "```py\n{\n    'ACG': {'T': 0.5, 'C': 0.5},\n    'CGT': {'A': 1.0},\n    'GTA': {'C': 1.0},\n    'TAC': {'G': 1.0}\n}\n```", "```py\ndef gen_seq(chain: Chain, k: int, min_len: int, max_len: int) -> Optional[str]: ![1](assets/1.png)\n    \"\"\" Generate a sequence \"\"\"\n\n    return '' ![2](assets/2.png)\n```", "```py\ndef test_gen_seq() -> None: ![1](assets/1.png)\n    \"\"\" Test gen_seq \"\"\"\n\n    chain = { ![2](assets/2.png)\n        'ACG': { 'T': 0.5, 'C': 0.5 },\n        'CGT': { 'A': 1.0 },\n        'GTA': { 'C': 1.0 },\n        'TAC': { 'G': 1.0 }\n    }\n\n    state = random.getstate() ![3](assets/3.png)\n    random.seed(1) ![4](assets/4.png)\n    assert gen_seq(chain, k=4, min_len=6, max_len=12) == 'CGTACGTACG' ![5](assets/5.png)\n    random.seed(2) ![6](assets/6.png)\n    assert gen_seq(chain, k=4, min_len=5, max_len=10) == 'ACGTA' ![7](assets/7.png)\n    random.setstate(state) ![8](assets/8.png)\n```", "```py\n>>> min_len, max_len = 5, 10\n>>> import random\n>>> seq_len = random.randint(min_len, max_len)\n>>> seq_len\n9\n```", "```py\n>>> chain = {\n...     'ACG': { 'T': 0.5, 'C': 0.5 },\n...     'CGT': { 'A': 1.0 },\n...     'GTA': { 'C': 1.0 },\n...     'TAC': { 'G': 1.0 }\n... }\n>>> seq = random.choice(list(chain.keys()))\n>>> seq\n'ACG'\n```", "```py\n>>> k = 4\n>>> while len(seq) < seq_len:\n...     prev = seq[-1 * (k - 1):]\n...     print(prev)\n...     break\n...\nACG\n```", "```py\n>>> opts = chain['ACG']\n>>> pop = opts.keys()\n>>> pop\ndict_keys(['T', 'C'])\n```", "```py\n>>> weights = opts.values()\n>>> weights\ndict_values([0.5, 0.5])\n```", "```py\n>>> from random import choices\n>>> next = choices(population=list(pop), weights=list(weights), k=1)\n>>> next\n['T']\n```", "```py\n>>> seq += next[0]\n>>> seq\n'ACGT'\n```", "```py\ndef main() -> None:\n    args = get_args()\n    random.seed(args.seed)\n    chains = read_training(...)\n    seqs = calls to gen_seq(...)\n    print each sequence to the output file\n    print the final status\n```", "```py\n>1\nGGATTAGATA\n>2\nAGTCAACG\n```", "```py\ndef read_training(fhs: List[TextIO], file_format: str, k: int) -> Chain:\n    \"\"\" Read training files, return dict of chains \"\"\"\n\n    counts: Dict[str, Dict[str, int]] = defaultdict(Counter) ![1](assets/1.png)\n    for fh in fhs: ![2](assets/2.png)\n        for rec in SeqIO.parse(fh, file_format): ![3](assets/3.png)\n            for kmer in find_kmers(str(rec.seq), k): ![4](assets/4.png)\n                counts[kmer[:k - 1]][kmer[-1]] += 1 ![5](assets/5.png)\n\n    def weight(freqs: Dict[str, int]) -> Dict[str, float]: ![6](assets/6.png)\n        total = sum(freqs.values()) ![7](assets/7.png)\n        return {base: freq / total for base, freq in freqs.items()} ![8](assets/8.png)\n\n    return {kmer: weight(freqs) for kmer, freqs in counts.items()} ![9](assets/9.png)\n```", "```py\ndef find_kmers(seq: str, k: int) -> List[str]:\n    \"\"\" Find k-mers in string \"\"\"\n\n    n = len(seq) - k + 1 ![1](assets/1.png)\n    return [] if n < 1 else [seq[i:i + k] for i in range(n)] ![2](assets/2.png)\n```", "```py\ndef gen_seq(chain: Chain, k: int, min_len: int, max_len: int) -> Optional[str]:\n    \"\"\" Generate a sequence \"\"\"\n\n    seq = random.choice(list(chain.keys())) ![1](assets/1.png)\n    seq_len = random.randint(min_len, max_len) ![2](assets/2.png)\n\n    while len(seq) < seq_len: ![3](assets/3.png)\n        prev = seq[-1 * (k - 1):] ![4](assets/4.png)\n        if choices := chain.get(prev): ![5](assets/5.png)\n            seq += random.choices(population=list(choices.keys()), ![6](assets/6.png)\n                                  weights=list(choices.values()),\n                                  k=1)[0]\n        else:\n            break ![7](assets/7.png)\n\n    return seq if len(seq) >= min_len else None ![8](assets/8.png)\n```", "```py\ndef main() -> None:\n    args = get_args()\n    random.seed(args.seed) ![1](assets/1.png)\n    if chain := read_training(args.files, args.file_format, args.k): ![2](assets/2.png)\n        seqs = (gen_seq(chain, args.k, args.min_len, args.max_len) ![3](assets/3.png)\n                for _ in count())\n\n        for i, seq in enumerate(filter(None, seqs), start=1): ![4](assets/4.png)\n            print(f'>{i}\\n{seq}', file=args.outfile) ![5](assets/5.png)\n            if i == args.num: ![6](assets/6.png)\n                break\n\n        print(f'Done, see output in \"{args.outfile.name}\".') ![7](assets/7.png)\n    else:\n        sys.exit(f'No {args.k}-mers in input sequences.') ![8](assets/8.png)\n```", "```py\n>>> from solution import gen_seq, read_training\n>>> import io\n>>> f1 = io.StringIO('>1\\nACGTACGC\\n')\n>>> chain = read_training([f1], 'fasta', k=4)\n>>> [gen_seq(chain, k=4, min_len=3, max_len=5) for _ in range(3)]\n['CGTACG', 'CGTACG', 'TACGTA']\n```", "```py\n>>> seqs = (gen_seq(chain, k=4, min_len=3, max_len=5) for _ in range(3))\n>>> type(seqs)\n<class 'generator'>\n```", "```py\n>>> seqs = ['ACGT', None, 'CCCGT']\n>>> list(filter(None, seqs))\n['ACGT', 'CCCGT']\n```", "```py\n$ ./synth.py tests/inputs/*\nDone, see output in \"out.fa\".\n```", "```py\n$ ../15_seqmagique/seqmagique.py out.fa\nname      min_len    max_len    avg_len    num_seqs\nout.fa         50         75      63.56         100\n```"]