["```py\nimport random\nfrom typing import TypeVar, List, Tuple\nX = TypeVar('X')  # generic type to represent a data point\n\ndef split_data(data: List[X], prob: float) -> Tuple[List[X], List[X]]:\n    \"\"\"Split data into fractions [prob, 1 - prob]\"\"\"\n    data = data[:]                    # Make a shallow copy\n    random.shuffle(data)              # because shuffle modifies the list.\n    cut = int(len(data) * prob)       # Use prob to find a cutoff\n    return data[:cut], data[cut:]     # and split the shuffled list there.\n\ndata = [n for n in range(1000)]\ntrain, test = split_data(data, 0.75)\n\n# The proportions should be correct\nassert len(train) == 750\nassert len(test) == 250\n\n# And the original data should be preserved (in some order)\nassert sorted(train + test) == data\n```", "```py\nY = TypeVar('Y')  # generic type to represent output variables\n\ndef train_test_split(xs: List[X],\n                     ys: List[Y],\n                     test_pct: float) -> Tuple[List[X], List[X], List[Y],\n                                                                 List[Y]]:\n    # Generate the indices and split them\n    idxs = [i for i in range(len(xs))]\n    train_idxs, test_idxs = split_data(idxs, 1 - test_pct)\n\n    return ([xs[i] for i in train_idxs],  # x_train\n            [xs[i] for i in test_idxs],   # x_test\n            [ys[i] for i in train_idxs],  # y_train\n            [ys[i] for i in test_idxs])   # y_test\n```", "```py\nxs = [x for x in range(1000)]  # xs are 1 ... 1000\nys = [2 * x for x in xs]       # each y_i is twice x_i\nx_train, x_test, y_train, y_test = train_test_split(xs, ys, 0.25)\n\n# Check that the proportions are correct\nassert len(x_train) == len(y_train) == 750\nassert len(x_test) == len(y_test) == 250\n\n# Check that the corresponding data points are paired correctly\nassert all(y == 2 * x for x, y in zip(x_train, y_train))\nassert all(y == 2 * x for x, y in zip(x_test, y_test))\n```", "```py\nmodel = SomeKindOfModel()\nx_train, x_test, y_train, y_test = train_test_split(xs, ys, 0.33)\nmodel.train(x_train, y_train)\nperformance = model.test(x_test, y_test)\n```", "```py\ndef accuracy(tp: int, fp: int, fn: int, tn: int) -> float:\n    correct = tp + tn\n    total = tp + fp + fn + tn\n    return correct / total\n\nassert accuracy(70, 4930, 13930, 981070) == 0.98114\n```", "```py\ndef precision(tp: int, fp: int, fn: int, tn: int) -> float:\n    return tp / (tp + fp)\n\nassert precision(70, 4930, 13930, 981070) == 0.014\n```", "```py\ndef recall(tp: int, fp: int, fn: int, tn: int) -> float:\n    return tp / (tp + fn)\n\nassert recall(70, 4930, 13930, 981070) == 0.005\n```", "```py\ndef f1_score(tp: int, fp: int, fn: int, tn: int) -> float:\n    p = precision(tp, fp, fn, tn)\n    r = recall(tp, fp, fn, tn)\n\n    return 2 * p * r / (p + r)\n```"]