- en: Chapter 2\. A Crash Course in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: People are still crazy about Python after twenty-five years, which I find hard
    to believe.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Michael Palin
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: All new employees at DataSciencester are required to go through new employee
    orientation, the most interesting part of which is a crash course in Python.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a comprehensive Python tutorial but instead is intended to highlight
    the parts of the language that will be most important to us (some of which are
    often not the focus of Python tutorials). If you have never used Python before,
    you probably want to supplement this with some sort of beginner tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: The Zen of Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has a somewhat Zen [description of its design principles](http://legacy.python.org/dev/peps/pep-0020/),
    which you can also find inside the Python interpreter itself by typing “import
    this.”
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most discussed of these is:'
  prefs: []
  type: TYPE_NORMAL
- en: There should be one—and preferably only one—obvious way to do it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Code written in accordance with this “obvious” way (which may not be obvious
    at all to a newcomer) is often described as “Pythonic.” Although this is not a
    book about Python, we will occasionally contrast Pythonic and non-Pythonic ways
    of accomplishing the same things, and we will generally favor Pythonic solutions
    to our problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several others touch on aesthetics:'
  prefs: []
  type: TYPE_NORMAL
- en: Beautiful is better than ugly. Explicit is better than implicit. Simple is better
    than complex.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: and represent ideals that we will strive for in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As instructions about how to install things can change, while printed books
    cannot, up-to-date instructions on how to install Python can be found in [the
    book’s GitHub repo](https://github.com/joelgrus/data-science-from-scratch/blob/master/INSTALL.md).
  prefs: []
  type: TYPE_NORMAL
- en: If the ones printed here don’t work for you, check those.
  prefs: []
  type: TYPE_NORMAL
- en: You can download Python from [Python.org](https://www.python.org/). But if you
    don’t already have Python, I recommend instead installing the [Anaconda](https://www.anaconda.com/download/)
    distribution, which already includes most of the libraries that you need to do
    data science.
  prefs: []
  type: TYPE_NORMAL
- en: When I wrote the first version of *Data Science from Scratch*, Python 2.7 was
    still the preferred version of most data scientists. Accordingly, the first edition
    of the book was based on Python 2.7.
  prefs: []
  type: TYPE_NORMAL
- en: In the last several years, however, pretty much everyone who counts has migrated
    to Python 3\. Recent versions of Python have many features that make it easier
    to write clean code, and we’ll be taking ample advantage of features that are
    only available in Python 3.6 or later. This means that you should get Python 3.6
    or later. (In addition, many useful libraries are ending support for Python 2.7,
    which is another reason to switch.)
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting in the next chapter, we’ll be using the matplotlib library to generate
    plots and charts. This library is not a core part of Python; you have to install
    it yourself. Every data science project you do will require some combination of
    external libraries, sometimes with specific versions that differ from the specific
    versions you used for other projects. If you were to have a single Python installation,
    these libraries would conflict and cause you all sorts of problems.
  prefs: []
  type: TYPE_NORMAL
- en: The standard solution is to use *virtual environments*, which are sandboxed
    Python environments that maintain their own versions of Python libraries (and,
    depending on how you set up the environment, of Python itself).
  prefs: []
  type: TYPE_NORMAL
- en: I recommended you install the Anaconda Python distribution, so in this section
    I’m going to explain how Anaconda’s environments work. If you are not using Anaconda,
    you can either use the built-in [`venv`](https://docs.python.org/3/library/venv.html)
    module or install [`virtualenv`](https://virtualenv.pypa.io/en/latest/). In which
    case you should follow their instructions instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an (Anaconda) virtual environment, you just do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Follow the prompts, and you’ll have a virtual environment called “dsfs,” with
    the instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As indicated, you then activate the environment using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'at which point your command prompt should change to indicate the active environment.
    On my MacBook the prompt now looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As long as this environment is active, any libraries you install will be installed
    only in the dsfs environment. Once you finish this book and go on to your own
    projects, you should create your own environments for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have your environment, it’s worth installing [IPython](http://ipython.org/),
    which is a full-featured Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Anaconda comes with its own package manager, `conda`, but you can also just
    use the standard Python package manager `pip`, which is what we’ll be doing.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this book will assume that you have created and activated such a
    Python 3.6 virtual environment (although you can call it whatever you want), and
    later chapters may rely on the libraries that I told you to install in earlier
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: As a matter of good discipline, you should always work in a virtual environment,
    and never using the “base” Python installation.
  prefs: []
  type: TYPE_NORMAL
- en: Whitespace Formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many languages use curly braces to delimit blocks of code. Python uses indentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This makes Python code very readable, but it also means that you have to be
    very careful with your formatting.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Programmers will often argue over whether to use tabs or spaces for indentation.
    For many languages it doesn’t matter that much; however, Python considers tabs
    and spaces different indentation and will not be able to run your code if you
    mix the two. When writing Python you should always use spaces, never tabs. (If
    you write code in an editor you can configure it so that the Tab key just inserts
    spaces.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Whitespace is ignored inside parentheses and brackets, which can be helpful
    for long-winded computations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'and for making code easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use a backslash to indicate that a statement continues onto the
    next line, although we’ll rarely do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'One consequence of whitespace formatting is that it can be hard to copy and
    paste code into the Python shell. For example, if you tried to paste the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'into the ordinary Python shell, you would receive the complaint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: because the interpreter thinks the blank line signals the end of the `for` loop’s
    block.
  prefs: []
  type: TYPE_NORMAL
- en: IPython has a magic function called `%paste`, which correctly pastes whatever
    is on your clipboard, whitespace and all. This alone is a good reason to use IPython.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Certain features of Python are not loaded by default. These include both features
    that are included as part of the language as well as third-party features that
    you download yourself. In order to use these features, you’ll need to `import`
    the modules that contain them.
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach is to simply `import` the module itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, `re` is the module containing functions and constants for working with
    regular expressions. After this type of `import` you must prefix those functions
    with `re.` in order to access them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you already had a different `re` in your code, you could use an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You might also do this if your module has an unwieldy name or if you’re going
    to be typing it a lot. For example, a standard convention when visualizing data
    with matplotlib is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need a few specific values from a module, you can import them explicitly
    and use them without qualification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were a bad person, you could import the entire contents of a module
    into your namespace, which might inadvertently overwrite variables you’ve already
    defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: However, since you are not a bad person, you won’t ever do this.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function is a rule for taking zero or more inputs and returning a corresponding
    output. In Python, we typically define functions using `def`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Python functions are *first-class*, which means that we can assign them to
    variables and pass them into functions just like any other arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also easy to create short anonymous functions, or *lambdas*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can assign lambdas to variables, although most people will tell you that
    you should just use `def` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Function parameters can also be given default arguments, which only need to
    be specified when you want a value other than the default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It is sometimes useful to specify arguments by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We will be creating many, many functions.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Strings can be delimited by single or double quotation marks (but the quotes
    have to match):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Python uses backslashes to encode special characters. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want backslashes as backslashes (which you might in Windows directory
    names or in regular expressions), you can create *raw* strings using `r""`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create multiline strings using three double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A new feature in Python 3.6 is the *f-string*, which provides a simple way
    to substitute values into strings. For example, if we had the first name and last
    name given separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'we might want to combine them into a full name. There are multiple ways to
    construct such a `full_name` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'but the f-string way is much less unwieldy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: and we’ll prefer it throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When something goes wrong, Python raises an *exception*. Unhandled, exceptions
    will cause your program to crash. You can handle them using `try` and `except`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Although in many languages exceptions are considered bad, in Python there is
    no shame in using them to make your code cleaner, and we will sometimes do so.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Probably the most fundamental data structure in Python is the *list*, which
    is simply an ordered collection (it is similar to what in other languages might
    be called an *array*, but with some added functionality):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get or set the *n*th element of a list with square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use square brackets to *slice* lists. The slice `i:j` means all
    elements from `i` (inclusive) to `j` (not inclusive). If you leave off the start
    of the slice, you’ll slice from the beginning of the list, and if you leave of
    the end of the slice, you’ll slice until the end of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You can similarly slice strings and other “sequential” types.
  prefs: []
  type: TYPE_NORMAL
- en: 'A slice can take a third argument to indicate its *stride*, which can be negative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Python has an `in` operator to check for list membership:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This check involves examining the elements of the list one at a time, which
    means that you probably shouldn’t use it unless you know your list is pretty small
    (or unless you don’t care how long the check takes).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is easy to concatenate lists together. If you want to modify a list in place,
    you can use `extend` to add items from another collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t want to modify `x`, you can use list addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'More frequently we will append to lists one item at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s often convenient to *unpack* lists when you know how many elements they
    contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: although you will get a `ValueError` if you don’t have the same number of elements
    on both sides.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common idiom is to use an underscore for a value you’re going to throw away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tuples are lists’ immutable cousins. Pretty much anything you can do to a list
    that doesn’t involve modifying it, you can do to a tuple. You specify a tuple
    by using parentheses (or nothing) instead of square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuples are a convenient way to return multiple values from functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuples (and lists) can also be used for *multiple assignment*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another fundamental data structure is a dictionary, which associates *values*
    with *keys* and allows you to quickly retrieve the value corresponding to a given
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can look up the value for a key using square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'But you’ll get a `KeyError` if you ask for a key that’s not in the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check for the existence of a key using `in`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This membership check is fast even for large dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries have a `get` method that returns a default value (instead of raising
    an exception) when you look up a key that’s not in the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You can assign key/value pairs using the same square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As you saw in [Chapter 1](ch01.html#introduction), you can use dictionaries
    to represent structured data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: although we’ll soon see a better approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides looking for specific keys, we can look at all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary keys must be “hashable”; in particular, you cannot use lists as keys.
    If you need a multipart key, you should probably use a tuple or figure out a way
    to turn the key into a string.
  prefs: []
  type: TYPE_NORMAL
- en: defaultdict
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that you’re trying to count the words in a document. An obvious approach
    is to create a dictionary in which the keys are words and the values are counts.
    As you check each word, you can increment its count if it’s already in the dictionary
    and add it to the dictionary if it’s not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also use the “forgiveness is better than permission” approach and
    just handle the exception from trying to look up a missing key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'A third approach is to use `get`, which behaves gracefully for missing keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Every one of these is slightly unwieldy, which is why `defaultdict` is useful.
    A `defaultdict` is like a regular dictionary, except that when you try to look
    up a key it doesn’t contain, it first adds a value for it using a zero-argument
    function you provided when you created it. In order to use `defaultdict`s, you
    have to import them from `collections`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'They can also be useful with `list` or `dict`, or even your own functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: These will be useful when we’re using dictionaries to “collect” results by some
    key and don’t want to have to check every time to see if the key exists yet.
  prefs: []
  type: TYPE_NORMAL
- en: Counters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `Counter` turns a sequence of values into a `defaultdict(int)`-like object
    mapping keys to counts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us a very simple way to solve our `word_counts` problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Counter` instance has a `most_common` method that is frequently useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another useful data structure is set, which represents a collection of *distinct*
    elements. You can define a set by listing its elements between curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'However, that doesn’t work for empty `set`s, as `{}` already means “empty `dict`.”
    In that case you’ll need to use `set()` itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use sets for two main reasons. The first is that `in` is a very fast
    operation on sets. If we have a large collection of items that we want to use
    for a membership test, a set is more appropriate than a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The second reason is to find the *distinct* items in a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use sets less frequently than dictionaries and lists.
  prefs: []
  type: TYPE_NORMAL
- en: Control Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As in most programming languages, you can perform an action conditionally using
    `if`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also write a *ternary* if-then-else on one line, which we will do occasionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Python has a `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'although more often we’ll use `for` and `in`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need more complex logic, you can use `continue` and `break`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This will print `0`, `1`, `2`, and `4`.
  prefs: []
  type: TYPE_NORMAL
- en: Truthiness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Booleans in Python work as in most other languages, except that they’re capitalized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Python uses the value `None` to indicate a nonexistent value. It is similar
    to other languages’ `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Python lets you use any value where it expects a Boolean. The following are
    all “falsy”:'
  prefs: []
  type: TYPE_NORMAL
- en: '`False`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`None`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[]` (an empty `list`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{}` (an empty `dict`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`""`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pretty much anything else gets treated as `True`. This allows you to easily
    use `if` statements to test for empty lists, empty strings, empty dictionaries,
    and so on. It also sometimes causes tricky bugs if you’re not expecting this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'A shorter (but possibly more confusing) way of doing the same is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'since `and` returns its second value when the first is “truthy,” and the first
    value when it’s not. Similarly, if `x` is either a number or possibly `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'is definitely a number, although:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: is possibly more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has an `all` function, which takes an iterable and returns `True` precisely
    when every element is truthy, and an `any` function, which returns `True` when
    at least one element is truthy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every Python list has a `sort` method that sorts it in place. If you don’t
    want to mess up your list, you can use the `sorted` function, which returns a
    new list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: By default, `sort` (and `sorted`) sort a list from smallest to largest based
    on naively comparing the elements to one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want elements sorted from largest to smallest, you can specify a `reverse=True`
    parameter. And instead of comparing the elements themselves, you can compare the
    results of a function that you specify with `key`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: List Comprehensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Frequently, you’ll want to transform a list into another list by choosing only
    certain elements, by transforming elements, or both. The Pythonic way to do this
    is with *list comprehensions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'You can similarly turn lists into dictionaries or sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t need the value from the list, it’s common to use an underscore
    as the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'A list comprehension can include multiple `for`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'and later `for`s can use the results of earlier ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: We will use list comprehensions a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Automated Testing and assert
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As data scientists, we’ll be writing a lot of code. How can we be confident
    our code is correct? One way is with *types* (discussed shortly), but another
    way is with *automated tests*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are elaborate frameworks for writing and running tests, but in this book
    we’ll restrict ourselves to using `assert` statements, which will cause your code
    to raise an `AssertionError` if your specified condition is not truthy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the second case, you can optionally add a message to be printed
    if the assertion fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s not particularly interesting to assert that 1 + 1 = 2. What’s more interesting
    is to assert that functions you write are doing what you expect them to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Throughout the book we’ll be using `assert` in this way. It is a good practice,
    and I strongly encourage you to make liberal use of it in your own code. (If you
    look at the book’s code on GitHub, you will see that it contains many, many more
    `assert` statements than are printed in the book. This helps *me* be confident
    that the code I’ve written for you is correct.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Another less common use is to assert things about inputs to functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: We’ll occasionally do this, but more often we’ll use `assert` to check that
    our code is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like many languages, Python allows you to define *classes* that encapsulate
    data and the functions that operate on them. We’ll use them sometimes to make
    our code cleaner and simpler. It’s probably simplest to explain them by constructing
    a heavily annotated example.
  prefs: []
  type: TYPE_NORMAL
- en: Here we’ll construct a class representing a “counting clicker,” the sort that
    is used at the door to track how many people have shown up for the “advanced topics
    in data science” meetup.
  prefs: []
  type: TYPE_NORMAL
- en: It maintains a `count`, can be `click`ed to increment the count, allows you
    to `read_count`, and can be `reset` back to zero. (In real life one of these rolls
    over from 9999 to 0000, but we won’t bother with that.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a class, you use the `class` keyword and a PascalCase name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: A class contains zero or more *member* functions. By convention, each takes
    a first parameter, `self`, that refers to the particular class instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, a class has a constructor, named `__init__`. It takes whatever parameters
    you need to construct an instance of your class and does whatever setup you need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the constructor has a funny name, we construct instances of the clicker
    using just the class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `__init__` method name starts and ends with double underscores.
    These “magic” methods are sometimes called “dunder” methods (double-UNDERscore,
    get it?) and represent “special” behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Class methods whose names start with an underscore are—by convention—considered
    “private,” and users of the class are not supposed to directly call them. However,
    Python will not *stop* users from calling them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another such method is `__repr__`, which produces the string representation
    of a class instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally we need to implement the *public API* of our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Having defined it, let’s use `assert` to write some test cases for our clicker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Writing tests like these help us be confident that our code is working the way
    it’s designed to, and that it remains doing so whenever we make changes to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll also occasionally create *subclasses* that *inherit* some of their functionality
    from a parent class. For example, we could create a non-reset-able clicker by
    using `CountingClicker` as the base class and overriding the `reset` method to
    do nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Iterables and Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One nice thing about a list is that you can retrieve specific elements by their
    indices. But you don’t always need this! A list of a billion numbers takes up
    a lot of memory. If you only want the elements one at a time, there’s no good
    reason to keep them all around. If you only end up needing the first several elements,
    generating the entire billion is hugely wasteful.
  prefs: []
  type: TYPE_NORMAL
- en: Often all we need is to iterate over the collection using `for` and `in`. In
    this case we can create *generators*, which can be iterated over just like lists
    but generate their values lazily on demand.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to create generators is with functions and the `yield` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The following loop will consume the `yield`ed values one at a time until none
    are left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: (In fact, `range` is itself lazy, so there’s no point in doing this.)
  prefs: []
  type: TYPE_NORMAL
- en: 'With a generator, you can even create an infinite sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: although you probably shouldn’t iterate over it without using some kind of `break`
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The flip side of laziness is that you can only iterate through a generator once.
    If you need to iterate through something multiple times, you’ll need to either
    re-create the generator each time or use a list. If generating the values is expensive,
    that might be a good reason to use a list instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'A second way to create generators is by using `for` comprehensions wrapped
    in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Such a “generator comprehension” doesn’t do any work until you iterate over
    it (using `for` or `next`). We can use this to build up elaborate data-processing
    pipelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Not infrequently, when we’re iterating over a list or a generator we’ll want
    not just the values but also their indices. For this common case Python provides
    an `enumerate` function, which turns values into pairs `(index, value)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use this a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Randomness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we learn data science, we will frequently need to generate random numbers,
    which we can do with the `random` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The `random` module actually produces *pseudorandom* (that is, deterministic)
    numbers based on an internal state that you can set with `random.seed` if you
    want to get reproducible results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll sometimes use `random.randrange`, which takes either one or two arguments
    and returns an element chosen randomly from the corresponding `range`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few more methods that we’ll sometimes find convenient. For example,
    `random.shuffle` randomly reorders the elements of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to randomly pick one element from a list, you can use `random.choice`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you need to randomly choose a sample of elements without replacement
    (i.e., with no duplicates), you can use `random.sample`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'To choose a sample of elements *with* replacement (i.e., allowing duplicates),
    you can just make multiple calls to `random.choice`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regular expressions provide a way of searching text. They are incredibly useful,
    but also fairly complicated—so much so that there are entire books written about
    them. We will get into their details the few times we encounter them; here are
    a few examples of how to use them in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: One important thing to note is that `re.match` checks whether the *beginning*
    of a string matches a regular expression, while `re.search` checks whether *any
    part* of a string matches a regular expression. At some point you will mix these
    two up and it will cause you grief.
  prefs: []
  type: TYPE_NORMAL
- en: The [official documentation](https://docs.python.org/3/library/re.html) goes
    into much more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The first edition of this book introduced the Python functions `partial`, `map`,
    `reduce`, and `filter` at this point. On my journey toward enlightenment I have
    realized that these functions are best avoided, and their uses in the book have
    been replaced with list comprehensions, `for` loops, and other, more Pythonic
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: zip and Argument Unpacking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often we will need to *zip* two or more iterables together. The `zip` function
    transforms multiple iterables into a single iterable of tuples of corresponding
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: If the lists are different lengths, `zip` stops as soon as the first list ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also “unzip” a list using a strange trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The asterisk (`*`) performs *argument unpacking*, which uses the elements of
    `pairs` as individual arguments to `zip`. It ends up the same as if you’d called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use argument unpacking with any function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: It is rare that we’ll find this useful, but when we do it’s a neat trick.
  prefs: []
  type: TYPE_NORMAL
- en: args and kwargs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s say we want to create a higher-order function that takes as input some
    function `f` and returns a new function that for any input returns twice the value
    of `f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'This works in some cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it doesn’t work with functions that take more than a single argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'What we need is a way to specify a function that takes arbitrary arguments.
    We can do this with argument unpacking and a little bit of magic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, when we define a function like this, `args` is a tuple of its unnamed
    arguments and `kwargs` is a `dict` of its named arguments. It works the other
    way too, if you want to use a `list` (or `tuple`) and `dict` to *supply* arguments
    to a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'You could do all sorts of strange tricks with this; we will only use it to
    produce higher-order functions whose inputs can accept arbitrary arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: As a general rule, your code will be more correct and more readable if you are
    explicit about what sorts of arguments your functions require; accordingly, we
    will use `args` and `kwargs` only when we have no other option.
  prefs: []
  type: TYPE_NORMAL
- en: Type Annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python is a *dynamically typed* language. That means that it in general it
    doesn’t care about the types of objects we use, as long as we use them in valid
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'whereas in a *statically typed* language our functions and objects would have
    specific types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: In fact, recent versions of Python do (sort of) have this functionality. The
    preceding version of `add` with the `int` type annotations is valid Python 3.6!
  prefs: []
  type: TYPE_NORMAL
- en: However, these type annotations don’t actually *do* anything. You can still
    use the annotated `add` function to add strings, and the call to `add(10, "five")`
    will still raise the exact same `TypeError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, there are still (at least) four good reasons to use type annotations
    in your Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Types are an important form of documentation. This is doubly true in a book
    that is using code to teach you theoretical and mathematical concepts. Compare
    the following two function stubs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I find the second one exceedingly more informative; hopefully you do too. (At
    this point I have gotten so used to type hinting that I now find untyped Python
    difficult to read.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are external tools (the most popular is `mypy`) that will read your code,
    inspect the type annotations, and let you know about type errors *before you ever
    run your code*. For example, if you ran `mypy` over a file containing `add("hi
    ", "there")`, it would warn you:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Like `assert` testing, this is a good way to find mistakes in your code before
    you ever run it. The narrative in the book will not involve such a type checker;
    however, behind the scenes I will be running one, which will help ensure *that
    the book itself is correct*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Having to think about the types in your code forces you to design cleaner functions
    and interfaces:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we have a function whose `operation` parameter is allowed to be a `string`,
    or an `int`, or a `float`, or a `bool`. It is highly likely that this function
    is fragile and difficult to use, but it becomes far more clear when the types
    are made explicit. Doing so, then, will force us to design in a less clunky way,
    for which our users will thank us.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using types allows your editor to help you with things like autocomplete ([Figure 2-1](#VScode))
    and to get angry at type errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![VSCode, but likely your editor does the same.](assets/dsf2_02in01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. VSCode, but likely your editor does the same
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Sometimes people insist that type hints may be valuable on large projects but
    are not worth the time for small ones. However, since type hints take almost no
    additional time to type and allow your editor to save you time, I maintain that
    they actually allow you to write code more quickly, even for small projects.
  prefs: []
  type: TYPE_NORMAL
- en: For all these reasons, all of the code in the remainder of the book will use
    type annotations. I expect that some readers will be put off by the use of type
    annotations; however, I suspect by the end of the book they will have changed
    their minds.
  prefs: []
  type: TYPE_NORMAL
- en: How to Write Type Annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve seen, for built-in types like `int` and `bool` and `float`, you just
    use the type itself as the annotation. What if you had (say) a `list`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: This isn’t wrong, but the type is not specific enough. It’s clear we really
    want `xs` to be a `list` of `floats`, not (say) a `list` of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `typing` module provides a number of parameterized types that we can use
    to do just this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Up until now we’ve only specified annotations for function parameters and return
    types. For variables themselves it’s usually obvious what the type is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'However, sometimes it’s not obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'In such cases we will supply inline type hints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The `typing` module contains many other types, only a few of which we’ll ever
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, since Python has first-class functions, we need a type to represent
    those as well. Here’s a pretty contrived example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'As type annotations are just Python objects, we can assign them to variables
    to make them easier to refer to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: By the time you get to the end of the book, you’ll be quite familiar with reading
    and writing type annotations, and I hope you’ll use them in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to DataSciencester!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This concludes new employee orientation. Oh, and also: try not to embezzle
    anything.'
  prefs: []
  type: TYPE_NORMAL
- en: For Further Exploration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no shortage of Python tutorials in the world. The [official one](https://docs.python.org/3/tutorial/)
    is not a bad place to start.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [official IPython tutorial](http://ipython.readthedocs.io/en/stable/interactive/index.html)
    will help you get started with IPython, if you decide to use it. Please use it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`mypy` documentation](https://mypy.readthedocs.io/en/stable/) will tell
    you more than you ever wanted to know about Python type annotations and type checking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
