- en: Chapter 2\. A Crash Course in Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。Python速成课程
- en: People are still crazy about Python after twenty-five years, which I find hard
    to believe.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 二十五年过去了，人们仍然对Python着迷，这让我难以置信。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Michael Palin
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 迈克尔·帕林
- en: All new employees at DataSciencester are required to go through new employee
    orientation, the most interesting part of which is a crash course in Python.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在DataSciencester的所有新员工都必须通过新员工入职培训，其中最有趣的部分是Python的速成课程。
- en: This is not a comprehensive Python tutorial but instead is intended to highlight
    the parts of the language that will be most important to us (some of which are
    often not the focus of Python tutorials). If you have never used Python before,
    you probably want to supplement this with some sort of beginner tutorial.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一篇全面的Python教程，而是旨在突出我们最关心的语言部分的部分（其中一些通常不是Python教程的重点）。如果你以前从未使用过Python，你可能想要补充一些初学者教程。
- en: The Zen of Python
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python之禅
- en: Python has a somewhat Zen [description of its design principles](http://legacy.python.org/dev/peps/pep-0020/),
    which you can also find inside the Python interpreter itself by typing “import
    this.”
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一种有点禅意的[设计原则描述](http://legacy.python.org/dev/peps/pep-0020/)，你也可以在Python解释器内部通过输入“import
    this”来找到它。
- en: 'One of the most discussed of these is:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 其中最受讨论的之一是：
- en: There should be one—and preferably only one—obvious way to do it.
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应该有一种——最好只有一种——明显的方法来做到这一点。
- en: Code written in accordance with this “obvious” way (which may not be obvious
    at all to a newcomer) is often described as “Pythonic.” Although this is not a
    book about Python, we will occasionally contrast Pythonic and non-Pythonic ways
    of accomplishing the same things, and we will generally favor Pythonic solutions
    to our problems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这种“显而易见”的方式编写的代码（这对于新手来说可能根本不明显）通常被描述为“Pythonic”。尽管这不是一本关于Python的书，我们偶尔会对比Pythonic和非Pythonic的解决方案，并且我们通常会倾向于使用Pythonic的解决方案来解决问题。
- en: 'Several others touch on aesthetics:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个触及美学的：
- en: Beautiful is better than ugly. Explicit is better than implicit. Simple is better
    than complex.
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 美丽比丑陋好。显式优于隐式。简单优于复杂。
- en: and represent ideals that we will strive for in our code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 并代表我们在代码中努力追求的理想。
- en: Getting Python
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取Python
- en: Note
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: As instructions about how to install things can change, while printed books
    cannot, up-to-date instructions on how to install Python can be found in [the
    book’s GitHub repo](https://github.com/joelgrus/data-science-from-scratch/blob/master/INSTALL.md).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安装说明可能会更改，而印刷书籍不能，因此关于如何安装Python的最新说明可以在[该书的GitHub仓库](https://github.com/joelgrus/data-science-from-scratch/blob/master/INSTALL.md)中找到。
- en: If the ones printed here don’t work for you, check those.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这里打印的方法对你不起作用，请检查那些方法。
- en: You can download Python from [Python.org](https://www.python.org/). But if you
    don’t already have Python, I recommend instead installing the [Anaconda](https://www.anaconda.com/download/)
    distribution, which already includes most of the libraries that you need to do
    data science.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[Python.org](https://www.python.org/)下载Python。但如果你还没有Python，我建议你安装[Anaconda](https://www.anaconda.com/download/)发行版，它已经包含了你做数据科学所需的大多数库。
- en: When I wrote the first version of *Data Science from Scratch*, Python 2.7 was
    still the preferred version of most data scientists. Accordingly, the first edition
    of the book was based on Python 2.7.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我写《从零开始的数据科学》的第一版时，Python 2.7仍然是大多数数据科学家首选的版本。因此，该书的第一版是基于Python 2.7的。
- en: In the last several years, however, pretty much everyone who counts has migrated
    to Python 3\. Recent versions of Python have many features that make it easier
    to write clean code, and we’ll be taking ample advantage of features that are
    only available in Python 3.6 or later. This means that you should get Python 3.6
    or later. (In addition, many useful libraries are ending support for Python 2.7,
    which is another reason to switch.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在过去的几年里，几乎所有有份量的人都已经迁移到Python 3。Python的最新版本具有许多功能，使得编写清晰的代码更容易，并且我们将充分利用仅在Python
    3.6或更高版本中可用的功能。这意味着你应该获得Python 3.6或更高版本。（此外，许多有用的库正在终止对Python 2.7的支持，这是切换的另一个原因。）
- en: Virtual Environments
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟环境
- en: Starting in the next chapter, we’ll be using the matplotlib library to generate
    plots and charts. This library is not a core part of Python; you have to install
    it yourself. Every data science project you do will require some combination of
    external libraries, sometimes with specific versions that differ from the specific
    versions you used for other projects. If you were to have a single Python installation,
    these libraries would conflict and cause you all sorts of problems.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一章开始，我们将使用matplotlib库生成图表和图形。这个库不是Python的核心部分；你必须自己安装它。每个数据科学项目都需要某些外部库的组合，有时候具体版本可能与你用于其他项目的版本不同。如果你只有一个Python安装，这些库可能会冲突并引起各种问题。
- en: The standard solution is to use *virtual environments*, which are sandboxed
    Python environments that maintain their own versions of Python libraries (and,
    depending on how you set up the environment, of Python itself).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 标准解决方案是使用*虚拟环境*，它们是沙箱化的Python环境，维护其自己版本的Python库（根据环境设置，还可能包括Python本身的版本）。
- en: I recommended you install the Anaconda Python distribution, so in this section
    I’m going to explain how Anaconda’s environments work. If you are not using Anaconda,
    you can either use the built-in [`venv`](https://docs.python.org/3/library/venv.html)
    module or install [`virtualenv`](https://virtualenv.pypa.io/en/latest/). In which
    case you should follow their instructions instead.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你安装Anaconda Python发行版，因此在本节中我将解释Anaconda环境的工作原理。如果你不使用Anaconda，可以使用内置的[`venv`](https://docs.python.org/3/library/venv.html)模块或安装[`virtualenv`](https://virtualenv.pypa.io/en/latest/)。在这种情况下，应遵循它们的说明。
- en: 'To create an (Anaconda) virtual environment, you just do the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建（Anaconda）虚拟环境，只需执行以下操作：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Follow the prompts, and you’ll have a virtual environment called “dsfs,” with
    the instructions:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 按照提示操作，你将拥有一个名为“dsfs”的虚拟环境，带有以下指令：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As indicated, you then activate the environment using:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如指示的那样，你可以使用以下命令激活环境：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'at which point your command prompt should change to indicate the active environment.
    On my MacBook the prompt now looks like:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你的命令提示符应该更改以指示活动环境。在我的MacBook上，提示现在看起来像：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As long as this environment is active, any libraries you install will be installed
    only in the dsfs environment. Once you finish this book and go on to your own
    projects, you should create your own environments for them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 只要此环境处于活动状态，你安装的任何库都将仅安装在dsfs环境中。完成本书后，继续进行自己的项目时，应为它们创建自己的环境。
- en: 'Now that you have your environment, it’s worth installing [IPython](http://ipython.org/),
    which is a full-featured Python shell:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了自己的环境，值得安装[IPython](http://ipython.org/)，这是一个功能齐全的Python shell：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Anaconda comes with its own package manager, `conda`, but you can also just
    use the standard Python package manager `pip`, which is what we’ll be doing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Anaconda带有自己的包管理器`conda`，但你也可以使用标准的Python包管理器`pip`，这是我们将要做的事情。
- en: The rest of this book will assume that you have created and activated such a
    Python 3.6 virtual environment (although you can call it whatever you want), and
    later chapters may rely on the libraries that I told you to install in earlier
    chapters.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的其余部分假设你已经创建并激活了这样一个Python 3.6的虚拟环境（尽管你可以将其命名为任何你想要的名称），后续章节可能会依赖于我在早期章节中要求你安装的库。
- en: As a matter of good discipline, you should always work in a virtual environment,
    and never using the “base” Python installation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 作为良好纪律的一部分，你应该始终在虚拟环境中工作，而不是使用“基础”Python安装。
- en: Whitespace Formatting
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空白格式化
- en: 'Many languages use curly braces to delimit blocks of code. Python uses indentation:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言使用大括号来界定代码块。Python使用缩进：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This makes Python code very readable, but it also means that you have to be
    very careful with your formatting.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得Python代码非常易读，但这也意味着你必须非常注意你的格式。
- en: Warning
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Programmers will often argue over whether to use tabs or spaces for indentation.
    For many languages it doesn’t matter that much; however, Python considers tabs
    and spaces different indentation and will not be able to run your code if you
    mix the two. When writing Python you should always use spaces, never tabs. (If
    you write code in an editor you can configure it so that the Tab key just inserts
    spaces.)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员经常争论是否应该使用制表符（tabs）还是空格（spaces）进行缩进。对于许多语言来说，这并不是太重要；然而，Python认为制表符和空格是不同的缩进方式，如果混合使用两者，你的代码将无法正常运行。在编写Python代码时，应始终使用空格，而不是制表符。（如果你在编辑器中编写代码，可以配置Tab键插入空格。）
- en: 'Whitespace is ignored inside parentheses and brackets, which can be helpful
    for long-winded computations:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 圆括号和方括号内的空白会被忽略，这对于冗长的计算很有帮助：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'and for making code easier to read:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以及为了使代码更易于阅读：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also use a backslash to indicate that a statement continues onto the
    next line, although we’ll rarely do this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用反斜杠来指示语句在下一行继续，尽管我们很少这样做：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'One consequence of whitespace formatting is that it can be hard to copy and
    paste code into the Python shell. For example, if you tried to paste the code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 空白格式化的一个后果是，很难将代码复制粘贴到 Python shell 中。例如，如果你试图粘贴以下代码：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'into the ordinary Python shell, you would receive the complaint:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到普通的 Python shell 中，你会得到以下投诉：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: because the interpreter thinks the blank line signals the end of the `for` loop’s
    block.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因为解释器认为空白行表示`for`循环块的结束。
- en: IPython has a magic function called `%paste`, which correctly pastes whatever
    is on your clipboard, whitespace and all. This alone is a good reason to use IPython.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 有一个名为 `%paste` 的魔法函数，它可以正确地粘贴你剪贴板上的任何内容，包括空白等。这已经是使用 IPython 的一个很好的理由。
- en: Modules
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: Certain features of Python are not loaded by default. These include both features
    that are included as part of the language as well as third-party features that
    you download yourself. In order to use these features, you’ll need to `import`
    the modules that contain them.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的某些特性不会默认加载。这些特性既包括作为语言的一部分的功能，也包括你自己下载的第三方功能。为了使用这些特性，你需要`import`包含它们的模块。
- en: 'One approach is to simply `import` the module itself:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方法是简单地`import`模块本身：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, `re` is the module containing functions and constants for working with
    regular expressions. After this type of `import` you must prefix those functions
    with `re.` in order to access them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`re` 是包含用于处理正则表达式的函数和常量的模块。在这种类型的`import`之后，你必须使用`re.`前缀来访问这些函数。
- en: 'If you already had a different `re` in your code, you could use an alias:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码中已经有了不同的`re`，你可以使用别名：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You might also do this if your module has an unwieldy name or if you’re going
    to be typing it a lot. For example, a standard convention when visualizing data
    with matplotlib is:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的模块名称过长或者你需要频繁输入它，你也可以这样做。例如，在使用 matplotlib 可视化数据时的标准约定是：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you need a few specific values from a module, you can import them explicitly
    and use them without qualification:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从一个模块中获取几个特定的值，你可以显式导入它们并在不需要限定的情况下使用它们：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you were a bad person, you could import the entire contents of a module
    into your namespace, which might inadvertently overwrite variables you’ve already
    defined:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是个坏人，你可以将模块的整个内容导入到你的命名空间中，这可能会无意中覆盖你已定义的变量：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: However, since you are not a bad person, you won’t ever do this.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于你不是个坏人，你永远不会这样做。
- en: Functions
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'A function is a rule for taking zero or more inputs and returning a corresponding
    output. In Python, we typically define functions using `def`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一个规则，用于接收零个或多个输入，并返回相应的输出。在 Python 中，我们通常使用 `def` 来定义函数：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Python functions are *first-class*, which means that we can assign them to
    variables and pass them into functions just like any other arguments:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Python 函数是*一等公民*，这意味着我们可以将它们赋值给变量，并像任何其他参数一样传递给函数：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It is also easy to create short anonymous functions, or *lambdas*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建短匿名函数或*lambda*也很容易：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can assign lambdas to variables, although most people will tell you that
    you should just use `def` instead:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将lambda表达式赋值给变量，尽管大多数人会告诉你应该使用`def`代替：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Function parameters can also be given default arguments, which only need to
    be specified when you want a value other than the default:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数也可以给定默认参数，只有在需要其他值时才需要指定：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It is sometimes useful to specify arguments by name:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候通过名称指定参数也是很有用的：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We will be creating many, many functions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建很多很多函数。
- en: Strings
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Strings can be delimited by single or double quotation marks (but the quotes
    have to match):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以用单引号或双引号括起来（但引号必须匹配）：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Python uses backslashes to encode special characters. For example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用反斜杠来编码特殊字符。例如：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you want backslashes as backslashes (which you might in Windows directory
    names or in regular expressions), you can create *raw* strings using `r""`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要保留反斜杠作为反斜杠（例如在 Windows 目录名或正则表达式中），可以使用 `r""` 创建*原始*字符串：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can create multiline strings using three double quotes:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用三个双引号创建多行字符串：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A new feature in Python 3.6 is the *f-string*, which provides a simple way
    to substitute values into strings. For example, if we had the first name and last
    name given separately:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'we might want to combine them into a full name. There are multiple ways to
    construct such a `full_name` string:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'but the f-string way is much less unwieldy:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: and we’ll prefer it throughout the book.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When something goes wrong, Python raises an *exception*. Unhandled, exceptions
    will cause your program to crash. You can handle them using `try` and `except`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Although in many languages exceptions are considered bad, in Python there is
    no shame in using them to make your code cleaner, and we will sometimes do so.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Probably the most fundamental data structure in Python is the *list*, which
    is simply an ordered collection (it is similar to what in other languages might
    be called an *array*, but with some added functionality):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can get or set the *n*th element of a list with square brackets:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can also use square brackets to *slice* lists. The slice `i:j` means all
    elements from `i` (inclusive) to `j` (not inclusive). If you leave off the start
    of the slice, you’ll slice from the beginning of the list, and if you leave of
    the end of the slice, you’ll slice until the end of the list:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can similarly slice strings and other “sequential” types.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'A slice can take a third argument to indicate its *stride*, which can be negative:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Python has an `in` operator to check for list membership:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This check involves examining the elements of the list one at a time, which
    means that you probably shouldn’t use it unless you know your list is pretty small
    (or unless you don’t care how long the check takes).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'It is easy to concatenate lists together. If you want to modify a list in place,
    you can use `extend` to add items from another collection:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you don’t want to modify `x`, you can use list addition:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'More frequently we will append to lists one item at a time:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It’s often convenient to *unpack* lists when you know how many elements they
    contain:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: although you will get a `ValueError` if you don’t have the same number of elements
    on both sides.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'A common idiom is to use an underscore for a value you’re going to throw away:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Tuples
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tuples are lists’ immutable cousins. Pretty much anything you can do to a list
    that doesn’t involve modifying it, you can do to a tuple. You specify a tuple
    by using parentheses (or nothing) instead of square brackets:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Tuples are a convenient way to return multiple values from functions:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Tuples (and lists) can also be used for *multiple assignment*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Dictionaries
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another fundamental data structure is a dictionary, which associates *values*
    with *keys* and allows you to quickly retrieve the value corresponding to a given
    key:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can look up the value for a key using square brackets:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'But you’ll get a `KeyError` if you ask for a key that’s not in the dictionary:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can check for the existence of a key using `in`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This membership check is fast even for large dictionaries.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对于大字典来说，这种成员检查也很快。
- en: 'Dictionaries have a `get` method that returns a default value (instead of raising
    an exception) when you look up a key that’s not in the dictionary:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 字典有一个 `get` 方法，在查找不在字典中的键时返回默认值（而不是引发异常）：
- en: '[PRE47]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can assign key/value pairs using the same square brackets:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用相同的方括号分配键/值对：
- en: '[PRE48]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As you saw in [Chapter 1](ch01.html#introduction), you can use dictionaries
    to represent structured data:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第 1 章](ch01.html#introduction)看到的，你可以使用字典来表示结构化数据：
- en: '[PRE49]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: although we’ll soon see a better approach.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们很快会看到一种更好的方法。
- en: 'Besides looking for specific keys, we can look at all of them:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查找特定键外，我们还可以查看所有键：
- en: '[PRE50]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Dictionary keys must be “hashable”; in particular, you cannot use lists as keys.
    If you need a multipart key, you should probably use a tuple or figure out a way
    to turn the key into a string.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的键必须是“可哈希的”；特别是，你不能使用列表作为键。如果你需要一个多部分键，你可能应该使用元组或想出一种方法将键转换为字符串。
- en: defaultdict
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: defaultdict
- en: 'Imagine that you’re trying to count the words in a document. An obvious approach
    is to create a dictionary in which the keys are words and the values are counts.
    As you check each word, you can increment its count if it’s already in the dictionary
    and add it to the dictionary if it’s not:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在尝试计算文档中的单词数。一个明显的方法是创建一个字典，其中键是单词，值是计数。当你检查每个单词时，如果它已经在字典中，你可以增加它的计数，如果它不在字典中，你可以将其添加到字典中：
- en: '[PRE51]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You could also use the “forgiveness is better than permission” approach and
    just handle the exception from trying to look up a missing key:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以采用“宁可原谅，也不要求许可”的方法，只需处理尝试查找缺失键时引发的异常：
- en: '[PRE52]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'A third approach is to use `get`, which behaves gracefully for missing keys:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法是使用 `get`，它对于缺失的键行为优雅：
- en: '[PRE53]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Every one of these is slightly unwieldy, which is why `defaultdict` is useful.
    A `defaultdict` is like a regular dictionary, except that when you try to look
    up a key it doesn’t contain, it first adds a value for it using a zero-argument
    function you provided when you created it. In order to use `defaultdict`s, you
    have to import them from `collections`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个这些都稍微笨拙，这就是为什么 `defaultdict` 是有用的。`defaultdict` 类似于普通字典，但是当你尝试查找它不包含的键时，它会首先使用你创建时提供的零参数函数为其添加一个值。为了使用
    `defaultdict`，你必须从 `collections` 导入它们：
- en: '[PRE54]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'They can also be useful with `list` or `dict`, or even your own functions:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在处理 `list` 或 `dict` 甚至是你自己的函数时也很有用：
- en: '[PRE55]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: These will be useful when we’re using dictionaries to “collect” results by some
    key and don’t want to have to check every time to see if the key exists yet.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用字典以某个键“收集”结果时，并且不想每次都检查键是否已存在时，这些方法将非常有用。
- en: Counters
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数器
- en: 'A `Counter` turns a sequence of values into a `defaultdict(int)`-like object
    mapping keys to counts:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Counter` 将一系列值转换为类似于 `defaultdict(int)` 的对象，将键映射到计数：
- en: '[PRE56]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This gives us a very simple way to solve our `word_counts` problem:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个解决 `word_counts` 问题的非常简单的方法：
- en: '[PRE57]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'A `Counter` instance has a `most_common` method that is frequently useful:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter` 实例有一个经常有用的 `most_common` 方法：'
- en: '[PRE58]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Sets
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合（sets）
- en: 'Another useful data structure is set, which represents a collection of *distinct*
    elements. You can define a set by listing its elements between curly braces:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的数据结构是集合，它表示一组 *不同* 的元素。你可以通过在大括号之间列出其元素来定义一个集合：
- en: '[PRE59]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'However, that doesn’t work for empty `set`s, as `{}` already means “empty `dict`.”
    In that case you’ll need to use `set()` itself:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于空的 `set`，这并不适用，因为 `{}` 已经表示“空 `dict`”。在这种情况下，你需要使用 `set()` 本身：
- en: '[PRE60]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We’ll use sets for two main reasons. The first is that `in` is a very fast
    operation on sets. If we have a large collection of items that we want to use
    for a membership test, a set is more appropriate than a list:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会出于两个主要原因使用集合。首先，`in` 在集合上是一个非常快的操作。如果我们有一个大量项目的集合，我们想用于成员测试，那么集合比列表更合适：
- en: '[PRE61]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The second reason is to find the *distinct* items in a collection:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因是在集合中找到 *不同* 的项：
- en: '[PRE62]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We’ll use sets less frequently than dictionaries and lists.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会比较少使用集合（sets），相对于字典和列表来说。
- en: Control Flow
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流程
- en: 'As in most programming languages, you can perform an action conditionally using
    `if`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 就像大多数编程语言一样，你可以使用 `if` 有条件地执行一个操作：
- en: '[PRE63]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You can also write a *ternary* if-then-else on one line, which we will do occasionally:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在一行上写一个 *三元* if-then-else，我们偶尔会这样做：
- en: '[PRE64]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Python has a `while` loop:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有一个 `while` 循环：
- en: '[PRE65]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'although more often we’ll use `for` and `in`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然更多时我们会使用 `for` 和 `in`：
- en: '[PRE66]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If you need more complex logic, you can use `continue` and `break`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更复杂的逻辑，可以使用 `continue` 和 `break`：
- en: '[PRE67]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This will print `0`, `1`, `2`, and `4`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印`0`、`1`、`2`和`4`。
- en: Truthiness
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真值
- en: 'Booleans in Python work as in most other languages, except that they’re capitalized:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的布尔值与大多数其他语言的工作方式相同，只是它们大写了起来。
- en: '[PRE68]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Python uses the value `None` to indicate a nonexistent value. It is similar
    to other languages’ `null`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Python使用值`None`来表示不存在的值。它类似于其他语言的`null`：
- en: '[PRE69]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Python lets you use any value where it expects a Boolean. The following are
    all “falsy”:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许你在期望布尔值的地方使用任何值。以下值都是“假”的：
- en: '`False`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`False`'
- en: '`None`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None`'
- en: '`[]` (an empty `list`)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[]`（一个空的`list`）'
- en: '`{}` (an empty `dict`)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{}`（一个空的`dict`）'
- en: '`""`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`""`'
- en: '`set()`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set()`'
- en: '`0`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`'
- en: '`0.0`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.0`'
- en: 'Pretty much anything else gets treated as `True`. This allows you to easily
    use `if` statements to test for empty lists, empty strings, empty dictionaries,
    and so on. It also sometimes causes tricky bugs if you’re not expecting this behavior:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何其他东西都会被视为“真”。这使你可以轻松地使用`if`语句来测试空列表、空字符串、空字典等。但如果你没有预料到这种行为，有时会导致棘手的错误：
- en: '[PRE70]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'A shorter (but possibly more confusing) way of doing the same is:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的一种更简短（但可能更令人困惑）的方法是：
- en: '[PRE71]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'since `and` returns its second value when the first is “truthy,” and the first
    value when it’s not. Similarly, if `x` is either a number or possibly `None`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`and`在第一个值为“真”时返回第二个值，在第一个值不为“真”时返回第一个值。类似地，如果`x`是一个数字或可能是`None`：
- en: '[PRE72]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'is definitely a number, although:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 显然是一个数字，尽管：
- en: '[PRE73]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: is possibly more readable.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 可能更易读。
- en: 'Python has an `all` function, which takes an iterable and returns `True` precisely
    when every element is truthy, and an `any` function, which returns `True` when
    at least one element is truthy:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个`all`函数，它接受一个可迭代对象，在每个元素都为真时返回`True`，还有一个`any`函数，当至少一个元素为真时返回`True`：
- en: '[PRE74]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Sorting
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序
- en: 'Every Python list has a `sort` method that sorts it in place. If you don’t
    want to mess up your list, you can use the `sorted` function, which returns a
    new list:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Python列表都有一个`sort`方法，它会原地对列表进行排序。如果你不想改变你的列表，可以使用`sorted`函数，它会返回一个新的列表：
- en: '[PRE75]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: By default, `sort` (and `sorted`) sort a list from smallest to largest based
    on naively comparing the elements to one another.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`sort`（和`sorted`）根据简单地比较元素之间的结果将列表从最小到最大排序。
- en: 'If you want elements sorted from largest to smallest, you can specify a `reverse=True`
    parameter. And instead of comparing the elements themselves, you can compare the
    results of a function that you specify with `key`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将元素按从大到小的顺序排序，可以指定一个`reverse=True`参数。而且你可以使用`key`指定的函数的结果来比较元素本身而不是比较元素本身：
- en: '[PRE76]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: List Comprehensions
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表推导
- en: 'Frequently, you’ll want to transform a list into another list by choosing only
    certain elements, by transforming elements, or both. The Pythonic way to do this
    is with *list comprehensions*:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 经常情况下，你可能希望通过选择特定的元素、转换元素或两者兼而有之来将一个列表转换为另一个列表。在Python中，实现这一点的方式是使用*列表推导*：
- en: '[PRE77]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'You can similarly turn lists into dictionaries or sets:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以类似地将列表转换为字典或集合：
- en: '[PRE78]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'If you don’t need the value from the list, it’s common to use an underscore
    as the variable:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要列表中的值，使用下划线作为变量名是很常见的：
- en: '[PRE79]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'A list comprehension can include multiple `for`s:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导可以包含多个`for`：
- en: '[PRE80]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'and later `for`s can use the results of earlier ones:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以后的`for`循环可以使用先前的结果：
- en: '[PRE81]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We will use list comprehensions a lot.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会经常使用列表推导。
- en: Automated Testing and assert
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试和断言
- en: As data scientists, we’ll be writing a lot of code. How can we be confident
    our code is correct? One way is with *types* (discussed shortly), but another
    way is with *automated tests*.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数据科学家，我们会写很多代码。我们如何确保我们的代码是正确的？一种方法是使用*类型*（稍后讨论），另一种方法是使用*自动化测试*。
- en: 'There are elaborate frameworks for writing and running tests, but in this book
    we’ll restrict ourselves to using `assert` statements, which will cause your code
    to raise an `AssertionError` if your specified condition is not truthy:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有复杂的框架用于编写和运行测试，但在本书中，我们将限制使用`assert`语句，如果指定的条件不为真，将导致你的代码引发`AssertionError`：
- en: '[PRE82]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: As you can see in the second case, you can optionally add a message to be printed
    if the assertion fails.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在第二种情况中看到的那样，你可以选择添加一条消息，如果断言失败，该消息将被打印。
- en: 'It’s not particularly interesting to assert that 1 + 1 = 2. What’s more interesting
    is to assert that functions you write are doing what you expect them to:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 断言1 + 1 = 2并不特别有趣。更有趣的是断言你编写的函数是否符合你的预期：
- en: '[PRE83]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Throughout the book we’ll be using `assert` in this way. It is a good practice,
    and I strongly encourage you to make liberal use of it in your own code. (If you
    look at the book’s code on GitHub, you will see that it contains many, many more
    `assert` statements than are printed in the book. This helps *me* be confident
    that the code I’ve written for you is correct.)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们会这样使用`assert`。这是一个良好的实践，我强烈鼓励你在自己的代码中大量使用它。（如果你在 GitHub 上查看书中的代码，你会发现它包含比书中打印出来的更多`assert`语句。这有助于*我*确信我为你编写的代码是正确的。）
- en: 'Another less common use is to assert things about inputs to functions:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不太常见的用法是对函数的输入进行断言：
- en: '[PRE84]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We’ll occasionally do this, but more often we’ll use `assert` to check that
    our code is correct.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们偶尔会这样做，但更常见的是我们会使用`assert`来检查我们的代码是否正确。
- en: Object-Oriented Programming
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: Like many languages, Python allows you to define *classes* that encapsulate
    data and the functions that operate on them. We’ll use them sometimes to make
    our code cleaner and simpler. It’s probably simplest to explain them by constructing
    a heavily annotated example.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多语言一样，Python 允许您定义*类*，封装数据和操作数据的函数。我们有时会使用它们来使我们的代码更清晰简单。最简单的方法可能是通过构造一个带有详细注释的示例来解释它们。
- en: Here we’ll construct a class representing a “counting clicker,” the sort that
    is used at the door to track how many people have shown up for the “advanced topics
    in data science” meetup.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将构造一个代表“计数点击器”的类，这种点击器用于跟踪参加“数据科学高级主题”聚会的人数。
- en: It maintains a `count`, can be `click`ed to increment the count, allows you
    to `read_count`, and can be `reset` back to zero. (In real life one of these rolls
    over from 9999 to 0000, but we won’t bother with that.)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 它维护一个`count`，可以通过`click`增加计数，允许您`read_count`，并可以通过`reset`重置为零。（在现实生活中，其中一个从9999滚动到0000，但我们不会费心去处理。）
- en: 'To define a class, you use the `class` keyword and a PascalCase name:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个类，您使用`class`关键字和PascalCase名称：
- en: '[PRE85]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: A class contains zero or more *member* functions. By convention, each takes
    a first parameter, `self`, that refers to the particular class instance.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 类包含零个或多个*成员*函数。按照惯例，每个函数都有一个名为`self`的第一个参数，它引用特定的类实例。
- en: 'Normally, a class has a constructor, named `__init__`. It takes whatever parameters
    you need to construct an instance of your class and does whatever setup you need:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，类具有一个名为`__init__`的构造函数。它接受构造类实例所需的任何参数，并执行你需要的任何设置：
- en: '[PRE86]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Although the constructor has a funny name, we construct instances of the clicker
    using just the class name:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管构造函数有一个有趣的名字，我们只使用类名来构造点击器的实例：
- en: '[PRE87]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Notice that the `__init__` method name starts and ends with double underscores.
    These “magic” methods are sometimes called “dunder” methods (double-UNDERscore,
    get it?) and represent “special” behaviors.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`__init__`方法名称以双下划线开头和结尾。这些“魔术”方法有时被称为“dunder”方法（double-UNDERscore，明白了吗？）并代表“特殊”行为。
- en: Note
  id: totrans-264
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Class methods whose names start with an underscore are—by convention—considered
    “private,” and users of the class are not supposed to directly call them. However,
    Python will not *stop* users from calling them.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名以下划线开头的类方法，按照惯例被认为是“私有”的，类的用户不应直接调用它们。然而，Python 不会*阻止*用户调用它们。
- en: 'Another such method is `__repr__`, which produces the string representation
    of a class instance:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个这样的方法是`__repr__`，它生成类实例的字符串表示：
- en: '[PRE88]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'And finally we need to implement the *public API* of our class:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要实现类的*公共 API*：
- en: '[PRE89]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Having defined it, let’s use `assert` to write some test cases for our clicker:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 定义好后，让我们使用`assert`为我们的点击器编写一些测试案例：
- en: '[PRE90]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Writing tests like these help us be confident that our code is working the way
    it’s designed to, and that it remains doing so whenever we make changes to it.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样编写测试有助于我们确信我们的代码按设计方式运行，并且在我们对其进行更改时仍然保持如此。
- en: 'We’ll also occasionally create *subclasses* that *inherit* some of their functionality
    from a parent class. For example, we could create a non-reset-able clicker by
    using `CountingClicker` as the base class and overriding the `reset` method to
    do nothing:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们偶尔会创建*子类*，从父类继承一些功能。例如，我们可以通过使用`CountingClicker`作为基类，并重写`reset`方法什么也不做，来创建一个不可重置的点击器：
- en: '[PRE91]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Iterables and Generators
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可迭代对象和生成器
- en: One nice thing about a list is that you can retrieve specific elements by their
    indices. But you don’t always need this! A list of a billion numbers takes up
    a lot of memory. If you only want the elements one at a time, there’s no good
    reason to keep them all around. If you only end up needing the first several elements,
    generating the entire billion is hugely wasteful.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的一个好处是你可以通过它们的索引检索特定元素。但你并不总是需要这样做！一个包含十亿个数字的列表会占用大量内存。如果你只想逐个获取元素，那么没有必要将它们全部保存下来。如果你最终只需要前几个元素，生成整个十亿个元素是极其浪费的。
- en: Often all we need is to iterate over the collection using `for` and `in`. In
    this case we can create *generators*, which can be iterated over just like lists
    but generate their values lazily on demand.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们只需要使用 `for` 和 `in` 迭代集合。在这种情况下，我们可以创建*生成器*，它们可以像列表一样被迭代，但是在需要时会惰性地生成它们的值。
- en: 'One way to create generators is with functions and the `yield` operator:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 创建生成器的一种方式是使用函数和 `yield` 运算符：
- en: '[PRE92]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The following loop will consume the `yield`ed values one at a time until none
    are left:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下循环将逐个消耗 `yield` 出的值，直到没有剩余值为止：
- en: '[PRE93]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: (In fact, `range` is itself lazy, so there’s no point in doing this.)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: （事实上，`range` 本身也是惰性的，所以这样做没有意义。）
- en: 'With a generator, you can even create an infinite sequence:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成器，甚至可以创建一个无限序列：
- en: '[PRE94]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: although you probably shouldn’t iterate over it without using some kind of `break`
    logic.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能不应该在没有使用某种 `break` 逻辑的情况下迭代它。
- en: Tip
  id: totrans-286
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The flip side of laziness is that you can only iterate through a generator once.
    If you need to iterate through something multiple times, you’ll need to either
    re-create the generator each time or use a list. If generating the values is expensive,
    that might be a good reason to use a list instead.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性的另一面是，你只能对生成器进行一次迭代。如果你需要多次迭代某个东西，你需要每次重新创建生成器，或者使用一个列表。如果生成值很昂贵，那么使用列表可能是个好理由。
- en: 'A second way to create generators is by using `for` comprehensions wrapped
    in parentheses:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 创建生成器的第二种方式是使用 `for` 推导式，用括号括起来：
- en: '[PRE95]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Such a “generator comprehension” doesn’t do any work until you iterate over
    it (using `for` or `next`). We can use this to build up elaborate data-processing
    pipelines:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的“生成器推导式”在你迭代它（使用`for`或`next`）之前不会执行任何操作。我们可以利用这一点构建复杂的数据处理流水线：
- en: '[PRE96]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Not infrequently, when we’re iterating over a list or a generator we’ll want
    not just the values but also their indices. For this common case Python provides
    an `enumerate` function, which turns values into pairs `(index, value)`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迭代列表或生成器时，经常会需要不仅值而且它们的索引。为了这种常见情况，Python 提供了一个 `enumerate` 函数，它将值转换为 `(index,
    value)` 对：
- en: '[PRE97]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: We’ll use this a lot.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会经常使用到这个。
- en: Randomness
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机性
- en: 'As we learn data science, we will frequently need to generate random numbers,
    which we can do with the `random` module:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们学习数据科学时，我们经常需要生成随机数，这可以通过 `random` 模块来实现：
- en: '[PRE98]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The `random` module actually produces *pseudorandom* (that is, deterministic)
    numbers based on an internal state that you can set with `random.seed` if you
    want to get reproducible results:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`random` 模块实际上产生*伪随机*（即确定性）数，其基于一个你可以用 `random.seed` 设置的内部状态，如果你想要可重复的结果：'
- en: '[PRE99]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We’ll sometimes use `random.randrange`, which takes either one or two arguments
    and returns an element chosen randomly from the corresponding `range`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时会使用 `random.randrange`，它接受一个或两个参数，并从相应的`range`中随机选择一个元素：
- en: '[PRE100]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'There are a few more methods that we’ll sometimes find convenient. For example,
    `random.shuffle` randomly reorders the elements of a list:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些方法，我们有时会发现很方便。例如，`random.shuffle` 随机重新排列列表的元素：
- en: '[PRE101]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'If you need to randomly pick one element from a list, you can use `random.choice`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从列表中随机选择一个元素，你可以使用 `random.choice`：
- en: '[PRE102]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'And if you need to randomly choose a sample of elements without replacement
    (i.e., with no duplicates), you can use `random.sample`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要无重复地随机选择一组元素（即，没有重复），你可以使用 `random.sample`：
- en: '[PRE103]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'To choose a sample of elements *with* replacement (i.e., allowing duplicates),
    you can just make multiple calls to `random.choice`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择一个带有*替换*（即允许重复）的元素样本，你可以多次调用 `random.choice`：
- en: '[PRE104]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Regular Expressions
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: 'Regular expressions provide a way of searching text. They are incredibly useful,
    but also fairly complicated—so much so that there are entire books written about
    them. We will get into their details the few times we encounter them; here are
    a few examples of how to use them in Python:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式提供了一种搜索文本的方式。它们非常有用，但也相当复杂——以至于整本书都可以写关于它们的详细内容。我们会在遇到它们的几次机会中深入了解它们的细节；以下是如何在
    Python 中使用它们的几个示例：
- en: '[PRE105]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: One important thing to note is that `re.match` checks whether the *beginning*
    of a string matches a regular expression, while `re.search` checks whether *any
    part* of a string matches a regular expression. At some point you will mix these
    two up and it will cause you grief.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，`re.match` 检查字符串的 *开头* 是否与正则表达式匹配，而 `re.search` 则检查字符串的 *任何部分* 是否与正则表达式匹配。你迟早会搞混它们，并因此而苦恼。
- en: The [official documentation](https://docs.python.org/3/library/re.html) goes
    into much more detail.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档提供了更详细的信息，可以参考 [official documentation](https://docs.python.org/3/library/re.html)。
- en: Functional Programming
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程
- en: Note
  id: totrans-316
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The first edition of this book introduced the Python functions `partial`, `map`,
    `reduce`, and `filter` at this point. On my journey toward enlightenment I have
    realized that these functions are best avoided, and their uses in the book have
    been replaced with list comprehensions, `for` loops, and other, more Pythonic
    constructs.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的第一版在此处介绍了 Python 函数 `partial`、`map`、`reduce` 和 `filter`。在我追求真理的过程中，我意识到最好避免使用这些函数，并且书中它们的用法已被列表推导式、`for`
    循环和其他更具 Python 风格的结构所取代。
- en: zip and Argument Unpacking
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: zip 和 参数解包
- en: 'Often we will need to *zip* two or more iterables together. The `zip` function
    transforms multiple iterables into a single iterable of tuples of corresponding
    function:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要将两个或更多的可迭代对象 *zip* 在一起。`zip` 函数将多个可迭代对象转换为一个由相应函数的元组组成的单一可迭代对象：
- en: '[PRE106]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: If the lists are different lengths, `zip` stops as soon as the first list ends.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表长度不同，`zip` 会在第一个列表结束时停止。
- en: 'You can also “unzip” a list using a strange trick:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用一个奇怪的技巧来“解压缩”列表：
- en: '[PRE107]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The asterisk (`*`) performs *argument unpacking*, which uses the elements of
    `pairs` as individual arguments to `zip`. It ends up the same as if you’d called:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 星号 (`*`) 执行 *参数解包*，它使用 `pairs` 的元素作为 `zip` 的单独参数。最终效果与你直接调用时一样：
- en: '[PRE108]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'You can use argument unpacking with any function:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将参数解包与任何函数一起使用：
- en: '[PRE109]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: It is rare that we’ll find this useful, but when we do it’s a neat trick.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 很少会发现这很有用，但当我们需要时，这是一个很好的技巧。
- en: args and kwargs
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: args 和 kwargs
- en: 'Let’s say we want to create a higher-order function that takes as input some
    function `f` and returns a new function that for any input returns twice the value
    of `f`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想创建一个接受某些函数 `f` 作为输入并返回一个新函数的高阶函数，对于任何输入，它返回 `f` 的值的两倍：
- en: '[PRE110]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This works in some cases:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这在某些情况下有效：
- en: '[PRE111]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'However, it doesn’t work with functions that take more than a single argument:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，它不能与接受多个参数的函数一起工作：
- en: '[PRE112]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'What we need is a way to specify a function that takes arbitrary arguments.
    We can do this with argument unpacking and a little bit of magic:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来指定一个接受任意参数的函数。我们可以通过参数解包和一点点魔法来实现这一点：
- en: '[PRE113]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'That is, when we define a function like this, `args` is a tuple of its unnamed
    arguments and `kwargs` is a `dict` of its named arguments. It works the other
    way too, if you want to use a `list` (or `tuple`) and `dict` to *supply* arguments
    to a function:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当我们像这样定义一个函数时，`args` 是它的未命名参数的元组，而 `kwargs` 是它的命名参数的字典。它也可以反过来使用，如果您想使用一个列表（或元组）和字典来
    *提供* 函数的参数：
- en: '[PRE114]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'You could do all sorts of strange tricks with this; we will only use it to
    produce higher-order functions whose inputs can accept arbitrary arguments:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，您可以做各种奇怪的技巧；我们只会用它来生成接受任意参数的高阶函数：
- en: '[PRE115]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: As a general rule, your code will be more correct and more readable if you are
    explicit about what sorts of arguments your functions require; accordingly, we
    will use `args` and `kwargs` only when we have no other option.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，如果你明确说明函数需要什么样的参数，你的代码将更加正确和可读；因此，只有在没有其他选择时我们才会使用 `args` 和 `kwargs`。
- en: Type Annotations
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型注解
- en: 'Python is a *dynamically typed* language. That means that it in general it
    doesn’t care about the types of objects we use, as long as we use them in valid
    ways:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种 *动态类型* 语言。这意味着它一般不关心我们使用的对象的类型，只要我们以有效的方式使用它们即可：
- en: '[PRE116]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'whereas in a *statically typed* language our functions and objects would have
    specific types:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 而在 *静态类型* 语言中，我们的函数和对象会有特定的类型：
- en: '[PRE117]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: In fact, recent versions of Python do (sort of) have this functionality. The
    preceding version of `add` with the `int` type annotations is valid Python 3.6!
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，最近的 Python 版本确实（某种程度上）具有这种功能。带有 `int` 类型注释的前一版本在 Python 3.6 中是有效的！
- en: However, these type annotations don’t actually *do* anything. You can still
    use the annotated `add` function to add strings, and the call to `add(10, "five")`
    will still raise the exact same `TypeError`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些类型注释实际上并不会*执行*任何操作。您仍然可以使用带有注释的 `add` 函数来添加字符串，调用 `add(10, "five")` 仍然会引发完全相同的
    `TypeError`。
- en: 'That said, there are still (at least) four good reasons to use type annotations
    in your Python code:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，在您的 Python 代码中仍然有（至少）四个好理由使用类型注释：
- en: 'Types are an important form of documentation. This is doubly true in a book
    that is using code to teach you theoretical and mathematical concepts. Compare
    the following two function stubs:'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型是重要的文档形式。在这本书中，代码用于教授您理论和数学概念，这一点尤为重要。比较以下两个函数桩代码：
- en: '[PRE118]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: I find the second one exceedingly more informative; hopefully you do too. (At
    this point I have gotten so used to type hinting that I now find untyped Python
    difficult to read.)
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我发现第二种方法更加信息丰富；希望您也这样认为。（到此为止，我已经习惯了类型提示，现在发现未经类型标注的 Python 代码难以阅读。）
- en: 'There are external tools (the most popular is `mypy`) that will read your code,
    inspect the type annotations, and let you know about type errors *before you ever
    run your code*. For example, if you ran `mypy` over a file containing `add("hi
    ", "there")`, it would warn you:'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一些外部工具（最流行的是 `mypy`）可以读取您的代码，检查类型注释，并在您运行代码之前通知您有关类型错误。例如，如果您运行 `mypy` 并包含
    `add("hi ", "there")` 的文件，它会警告您：
- en: '[PRE119]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Like `assert` testing, this is a good way to find mistakes in your code before
    you ever run it. The narrative in the book will not involve such a type checker;
    however, behind the scenes I will be running one, which will help ensure *that
    the book itself is correct*.
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似于 `assert` 测试，这是发现代码错误的好方法，而不需要运行它。本书的叙述不涉及这样的类型检查器；然而，在幕后，我将运行一个，这将有助于确保书本身是正确的。
- en: 'Having to think about the types in your code forces you to design cleaner functions
    and interfaces:'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不得不考虑代码中的类型强制您设计更清晰的函数和接口：
- en: '[PRE120]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Here we have a function whose `operation` parameter is allowed to be a `string`,
    or an `int`, or a `float`, or a `bool`. It is highly likely that this function
    is fragile and difficult to use, but it becomes far more clear when the types
    are made explicit. Doing so, then, will force us to design in a less clunky way,
    for which our users will thank us.
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里我们有一个函数，其 `operation` 参数可以是 `string`、`int`、`float` 或 `bool`。很可能这个函数很脆弱且难以使用，但是当类型明确时，它变得更加清晰。这样做将迫使我们以更少的笨拙方式进行设计，用户会因此受益。
- en: Using types allows your editor to help you with things like autocomplete ([Figure 2-1](#VScode))
    and to get angry at type errors.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型允许您的编辑器帮助您完成诸如自动完成（[图 2-1](#VScode)）之类的事情，并且可以在类型错误时发出警告。
- en: '![VSCode, but likely your editor does the same.](assets/dsf2_02in01.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![VSCode, but likely your editor does the same.](assets/dsf2_02in01.png)'
- en: Figure 2-1\. VSCode, but likely your editor does the same
  id: totrans-362
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. VSCode，但可能您的编辑器也是如此。
- en: Sometimes people insist that type hints may be valuable on large projects but
    are not worth the time for small ones. However, since type hints take almost no
    additional time to type and allow your editor to save you time, I maintain that
    they actually allow you to write code more quickly, even for small projects.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候人们坚持认为类型提示可能对大型项目有价值，但对于小型项目来说不值得花费时间。然而，由于类型提示几乎不需要额外的输入时间，并且允许您的编辑器节省时间，因此我认为它们实际上可以让您更快地编写代码，即使是对于小型项目也是如此。
- en: For all these reasons, all of the code in the remainder of the book will use
    type annotations. I expect that some readers will be put off by the use of type
    annotations; however, I suspect by the end of the book they will have changed
    their minds.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 出于所有这些原因，本书其余部分的所有代码都将使用类型注释。我预计一些读者可能对使用类型注释感到不满意；然而，我认为到本书结束时，他们的想法会改变。
- en: How to Write Type Annotations
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何编写类型注释
- en: As we’ve seen, for built-in types like `int` and `bool` and `float`, you just
    use the type itself as the annotation. What if you had (say) a `list`?
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，对于像 `int`、`bool` 和 `float` 这样的内置类型，您只需使用类型本身作为注释。如果您有（比如）一个 `list` 呢？
- en: '[PRE121]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This isn’t wrong, but the type is not specific enough. It’s clear we really
    want `xs` to be a `list` of `floats`, not (say) a `list` of strings.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是错误，但类型不够具体。显然我们真正想要的是 `xs` 是 `floats` 的 `list`，而不是（比如）字符串的 `list`。
- en: 'The `typing` module provides a number of parameterized types that we can use
    to do just this:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing` 模块提供了许多参数化类型，我们可以使用它们来做这件事：'
- en: '[PRE122]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Up until now we’ve only specified annotations for function parameters and return
    types. For variables themselves it’s usually obvious what the type is:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只为函数参数和返回类型指定了注解。对于变量本身来说，通常很明显它们的类型是什么：
- en: '[PRE123]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'However, sometimes it’s not obvious:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时候并不明显：
- en: '[PRE124]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'In such cases we will supply inline type hints:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将提供内联类型提示：
- en: '[PRE125]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The `typing` module contains many other types, only a few of which we’ll ever
    use:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing` 模块包含许多其他类型，我们可能只会用到其中的几种：'
- en: '[PRE126]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Finally, since Python has first-class functions, we need a type to represent
    those as well. Here’s a pretty contrived example:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于 Python 拥有头等函数，我们需要一个类型来表示这些。这里有一个相当牵强的例子：
- en: '[PRE127]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'As type annotations are just Python objects, we can assign them to variables
    to make them easier to refer to:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型注解只是 Python 对象，我们可以将它们分配给变量，以便更容易引用它们：
- en: '[PRE128]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: By the time you get to the end of the book, you’ll be quite familiar with reading
    and writing type annotations, and I hope you’ll use them in your code.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当你读完本书时，你将非常熟悉读写类型注解，希望你会在自己的代码中使用它们。
- en: Welcome to DataSciencester!
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 欢迎来到 DataSciencester！
- en: 'This concludes new employee orientation. Oh, and also: try not to embezzle
    anything.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了新员工的入职培训。哦，还有：尽量不要贪污任何东西。
- en: For Further Exploration
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步探索
- en: There is no shortage of Python tutorials in the world. The [official one](https://docs.python.org/3/tutorial/)
    is not a bad place to start.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 世界上没有缺少 Python 教程。[官方教程](https://docs.python.org/3/tutorial/) 不是一个坏的起点。
- en: The [official IPython tutorial](http://ipython.readthedocs.io/en/stable/interactive/index.html)
    will help you get started with IPython, if you decide to use it. Please use it.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[官方 IPython 教程](http://ipython.readthedocs.io/en/stable/interactive/index.html)
    将帮助您开始使用 IPython，如果您决定使用它。请使用它。'
- en: The [`mypy` documentation](https://mypy.readthedocs.io/en/stable/) will tell
    you more than you ever wanted to know about Python type annotations and type checking.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`mypy` 文档](https://mypy.readthedocs.io/en/stable/) 将告诉你关于 Python 类型注解和类型检查的一切，甚至超出了你想知道的范围。'
