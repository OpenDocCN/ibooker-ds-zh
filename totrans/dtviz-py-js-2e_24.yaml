- en: Chapter 18\. Visualizing Individual Prizes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 17](ch17.xhtml#chapter_d3_intro) you learned the basics of D3, how
    to select and change DOM elements, how to add new ones, and how to apply the data
    update pattern, which is the axis around which interactive D3 spins. In this chapter,
    I will expand on what you’ve learned so far and show you how to build a fairly
    novel visual element, showing all the individual Nobel Prizes by year ([Figure 18-1](#d3nobels_target)).
    This Nobel timeline will allow us to expand on the knowledge of the last chapter,
    demonstrating a number of new techniques including more advanced data manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1502](assets/dpj2_1502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18-1\. This chapter’s target chart, a timeline of Nobel Prizes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s start by showing how we build the HTML framework for our timeline chart.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our target chart’s construction is similar to that of our Nobel Prize bar chart,
    which we covered in detail in the last chapter. We first use D3 to select our
    `<div>` container with ID `nobel-time`, then use the width and height of the container,
    along with our specified margins, to create our `svg` chart group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With our `svg` chart group in place, let’s add the scales and axes.
  prefs: []
  type: TYPE_NORMAL
- en: Scales
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To place the circular indicators, we use two ordinal scales ([Example 18-1](#d3time_scales)).
    The x-scale uses the `rangeRoundBands` method to specify a 10% padding between
    the circles. Because we use the x-scale to set the circles’ diameters, the height
    of our y-scale’s range is manually adjusted to accommodate all the indicators,
    allowing a little padding between them. We use `rangeRoundPoints` to round to
    integer pixel coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-1\. The chart’s two ordinal band scales, for x and y axes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_individual_prizes_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We’re using a padding factor of 0.1, which is approximately 10% of an indicator’s
    diameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_individual_prizes_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The domain is [0, …​, 15] with 15 being the historical maximum number of prizes
    given in any one year.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike our bar chart from the last chapter, both ranges and domains of this
    chart are fixed. The domain of the `xScale` is the years over which the Nobel
    Prize has run, and that of the `yScale` is from zero to the maximum number of
    prizes in any given year (14 in the year 2000). Neither of these will change in
    response to user interaction, so we define them outside the `update` method.
  prefs: []
  type: TYPE_NORMAL
- en: Axes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a maximum of 14 prizes in any one year and with a circular indicator for
    each, it is easy to make a prize count by eye if necessary. Given this, the emphasis
    on providing a relative indicator of prize distribution (e.g., showing the spurt
    in post-WWII US science prizes), and the long length of the chart, a y-axis is
    redundant for our chart.
  prefs: []
  type: TYPE_NORMAL
- en: For the x-axis, labeling the decades’ starts seems about right. It reduces visual
    clutter and is also the standard human way of charting historical trends. [Example 18-2](#d3time_axis_code)
    shows the construction of our x-axis, using D3’s handy `axis` object. We override
    the tick values using the `tickValues` method, filtering the domain range (1900–2015)
    to return only those dates ending with zero.
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-2\. Making the x-axis, with tick labels per decade
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_individual_prizes_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We only want to tick every 10th year, so we create tick values by filtering
    the x-scale domain values and using their index to select only those that are
    divisible by 10\. These give 0 for modulus (`%`) 10, to which we apply the not
    Boolean operator (`!`) to produce `true`, which passes the filter.
  prefs: []
  type: TYPE_NORMAL
- en: This returns `true` for years ending in 0, giving a tick label at the start
    of every decade.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the scales, we don’t anticipate the axes changing,^([1](ch18.xhtml#idm45607743508496))
    so we can add them before receiving the dataset in the `updateTimeChart` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_individual_prizes_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Calls our D3 axis on the `svg` group, with the `axis` object taking care of
    building the axis elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_individual_prizes_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: As in [“Axes and Labels”](ch17.xhtml#sect_axes_labels), we rotate the axis tick
    labels to place them diagonally.
  prefs: []
  type: TYPE_NORMAL
- en: With axes and scales taken care of, we need only add a little legend with our
    colored category labels before moving on to the cool, interactive elements of
    the chart.
  prefs: []
  type: TYPE_NORMAL
- en: Category Labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last of our *static* components is a legend, containing the category labels
    shown in [Figure 18-2](#d3nobels_legend).
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1802](assets/dpj2_1802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18-2\. Categories legend
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To create the legend, we first create a group, class `labels`, to hold the
    labels. We bind our `nbviz.CATEGORIES` data to a `label` selection on this `labels`
    group, enter the bound data, and attach a group for each category, displaced on
    the y-axis by index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_individual_prizes_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We join our array of categories (`["Chemistry", "Economics", …​]`) to the `label`
    group using the standard `data` followed by `join` methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_individual_prizes_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a group for each category, spaced vertically 10 pixels apart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our `catLabels` selection, let’s add a circular indicator
    (matching those seen in the timeline) and text label to each of its groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_individual_prizes_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use our shared `categoryFill` method to return a color based on the bound
    category.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_individual_prizes_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The x scales `bandwidth` method returns the distance between two category labels.
    We will use half of this to get the radius for our circular label markers.
  prefs: []
  type: TYPE_NORMAL
- en: The `categoryFill` function ([Example 18-3](#d3time_colors)) is defined in *nbviz_core.js*
    and is used by the app to provide colors for the categories. D3 provides a number
    of color schemes in the form of arrays of color hex codes, which can be used as
    our SVG fill colors. You can see a demo of the color schemes on [Observable](https://oreil.ly/sblXu).
    We are dealing with categories, so we’ll use the Category10 set.
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-3\. Setting the category colors
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_individual_prizes_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: D3’s `schemeCategory10` is an array of 10 color hex codes (`['#1f77b4', '#ff7f0e',...]`)
    that we can apply using the prize category index.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered all the static elements of our time chart, let’s look
    at how we knock it into usable form with D3’s *nest* library.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting the Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to create this timeline component, we need to reorganize our flat array
    of winners objects into a form that will allow us to bind it to the individual
    Nobel Prizes in our timeline. What we need, to make binding this data with D3
    as smooth as possible, is an array of prize objects by year, with the year groups
    available as arrays. Let’s demonstrate the conversion process with our Nobel Prize
    dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the flat Nobel Prize dataset we begin with, ordered by year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to take this data and convert it to the following nested format, an
    array of objects with year keys and winners-by-year values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can iterate through this nested array and join the year groups in turn, each
    one represented by a column of indicators in our timeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make use of one D3 `group` utility method in order to group the Nobel
    prizes by year. `group` takes an array of data and returns an object grouped by
    the property specified in a callback function, in our case the year of the prize.
    So we group our entries by year like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_individual_prizes_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Here we use a modern JavaScript lambda shorthand function, equivalent to `function(d)
    { return d.year }`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This grouping returns the array of entries of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in order to convert this map to the required array of key-values objects,
    we’ll make use of JavaScript’s `Array` object and its `from` method. We pass in
    our `yearGroups` map and a converter function that takes the individual groups
    in the form of a [key, values] array and converts them to a {key: key, values:
    values} object. We are again using the [destructuring assignment syntax](https://oreil.ly/rREpC)
    to map our key and values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have the required function to group our filtered winning prize entries
    by year in the key-values form required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_individual_prizes_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the JavaScript array’s [`sort` method](https://oreil.ly/VA1ot) to sort
    the prizes alphabetically by category. This will make it easier to compare year
    with year. `sort` expects a positive or negative numerical value, which we produce
    using the Boolean alphanumeric string comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Winners with a Nested Data-Join
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [“Putting the Bar Chart Together”](ch17.xhtml#d3_putting_barchart_together)
    of the last chapter, we saw how D3’s newish `join` method makes it easy to synchronize
    changes in data, in that case number of prizes by country, with the visualization
    of that data, in that case bars in a bar chart. Our winners-by-year chart is essentially
    a bar chart where the individual bars are represented by prizes (circle markers).
    Now we’ll see how this can easily be accomplished by using two data-joins and
    the nested dataset produced in the last section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The nested data is first passed from `onDataChange` to our time chart’s `updateTimeChart`
    method. We then use our first data-join to create the year groups, positioning
    them using our ordinal x scale, which mapped years to pixel positions (see [Example 18-1](#d3time_scales))
    and naming them by year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_individual_prizes_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We want to join the year data to its respective column by its year key, not
    the default array index, which will change if there are year gaps in our nested
    array, as there often will be for the user-selected datasets.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_individual_prizes_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Our first data-join uses the key-values array to produce the circle-bar groups
    by year.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use Chrome’s Elements tab to see the changes we’ve made from this first
    data-join. [Figure 18-3](#d3nobels_first_enter) shows our year groups nestled
    nicely in their parent chart group.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1803](assets/dpj2_1803.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18-3\. The result of creating our year groups during the first data-join
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s check to make sure our nested data has been bound correctly to its respective
    year groups. In [Figure 18-4](#d3nobels_firstpass_data), we select a group element
    by its year name and inspect it. As required, the correct data has been bound
    by year, showing an array of data objects for the six Nobel Prize winners of 1901.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having joined our year group data to their respective groups, we can now join
    those values to the circular marker groups representing each year. The first thing
    we need to do is select all the year groups with the key-values data we just added
    and bind the values array (the prizes for that year) to some *winner* placeholders,
    which will soon be joined to some circle markers. This is achieved by the following
    D3 calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_individual_prizes_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be creating a circle marker for each prize in the values array.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_individual_prizes_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the values array to create the circles with D3’s join.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_visualizing_individual_prizes_CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We use an optional key to track the circles/winners by name—this will be useful
    for transition effects, as we’ll see later on.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1804](assets/dpj2_1804.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18-4\. Checking the results of our first data-join with Chrome’s console
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that we’ve created our *circle* placeholders with winning entry data, it
    only remains to join these to a circle using D3’s `join` method. This will keep
    track of any changes to the data and make sure circles are created and destroyed
    in sync. The rest of the impressively succinct code required is as follows in
    [Example 18-4](#d3nobels_second_data_join).
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-4\. A second data-join to produce the prizes’ circle indicators
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_individual_prizes_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: A custom `enter` method is used to append any new circles needed and give them
    a default y position at the bottom (y is down for SVG) of the chart.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_individual_prizes_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A little helper method returns a color given the prize’s category.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_visualizing_individual_prizes_CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The year group already has the correct x position, so we only need to use the
    bandwidth of the bars to set the radius and center the circle in the middle of
    the bar. The y-scale is used to set the height of the bar by index `i` in the
    winners array.
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Example 18-4](#d3nobels_second_data_join) does the job of building
    our prize time chart, creating new indicator circles if required and placing them,
    along with any existing ones, at their correct position, as designated by their
    array index (see [Figure 18-5](#timeline_second_pass)).
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1805](assets/dpj2_1805.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18-5\. The result of our successful second data-join
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Although we have produced a perfectly usable timeline, which will respond to
    user-driven changes in the data, the transition is a little stark and unengaging.^([2](ch18.xhtml#idm45607742041664))
    Let’s now see a great demonstration of D3’s power: how the addition of two lines
    of code can buy a rather cool visual effect as our timeline changes state.'
  prefs: []
  type: TYPE_NORMAL
- en: A Little Transitional Sparkle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As things stand, when the user selects a new dataset,^([3](ch18.xhtml#idm45607742034720))
    the update pattern in [Example 18-4](#d3nobels_second_data_join) instantly sets
    the position of the relevant circles. What we now want to do is to animate this
    repositioning, smoothing it out over a couple of seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Any user-driven filtering will either leave some existing indicators (e.g.,
    when we select only the Chemistry prizes from all categories), add some new ones
    (e.g., changing our category from Physics to Chemistry), or do both. An edge case
    is when the filtering leaves nothing (e.g., selecting female Economics winners).
    This means we need to decide what existing indicators should do and how to animate
    the positioning of new indicators.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-6](#d3nobels_transition_less) shows what we want to happen on selecting
    a subset of the existing data, in this case filtering all Nobel Prizes to include
    only those Physics winners. On the user’s selection of the Physics category, all
    indicators except the Physics ones are removed by the `exit` and `remove` methods.
    Meanwhile, the existing Physics indicators begin a two-second transition from
    their current position to an end position, dictated by their array index.'
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1806](assets/dpj2_1806.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18-6\. Transition on selecting a subset of the existing data
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It may surprise you to discover that both these visual effects, moving existing
    bars smoothly into their new place and growing any new bars from the bottom of
    the chart, can be achieved by the addition of only two lines to our existing code.
    This is a big testimony to the power of D3’s data-joining concept and its mature
    design.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve the required transitions, we add calls to `transition` and `duration`
    methods before setting the y position (*cy* attribute) of the circle marker. These
    smooth the repositioning of the circle, easing it in over two seconds (2000ms):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_individual_prizes_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Any new circles start at the bottom of the chart.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_individual_prizes_CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: All circles are eased into their y position over a duration of 2000ms.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, D3 makes it really easy to add cool visual effects to your data
    transitions. This is a testimony to its solid theoretical foundations. We now
    have our complete timeline chart, which transitions smoothly in response to data
    changes initiated by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Bar Chart
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the time chart module is imported, it appends a callback function to the
    callbacks array in the core module. When data is updated in response to user interaction,
    this callback function is called and the time chart updated with new country data,
    nested by year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_individual_prizes_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This anonymous function is called in the core module when data is updated.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following on from the bar chart in [Chapter 17](ch17.xhtml#chapter_d3_intro),
    this chapter extended the update pattern, showing how to use a second data-join
    on nested data to create a novel chart. It’s important to emphasize that this
    ability to create novel visualizations is D3’s great strength: you are not tied
    to the particular functionality of a conventional charting library but can achieve
    unique transformations of your data. As our Nobel Prize bar chart showed, it’s
    easy to build conventional dynamic charts, but D3 allows for so much more.'
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how easy it is to liven up your visualizations with engaging transformations
    once a solid update pattern is in place.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build the map component of our Nobel-viz using
    D3’s impressive topographic library.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch18.xhtml#idm45607743508496-marker)) D3 has some handy brushes that make
    selecting portions of the x- or y-axis easy. Combined with transitions, this can
    make for an engaging and intuitive way to increase the resolution of large datasets.
    See [this *bl.ocks.org* page](https://oreil.ly/2Q0j7) for a good example.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch18.xhtml#idm45607742041664-marker)) As discussed in [“Transitions”](ch17.xhtml#sect_transitions),
    the visual transition from one dataset to another can be both informative and
    lend a sense of continuity to the visualization, making it more appealing.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch18.xhtml#idm45607742034720-marker)) For example, filtering the prizes
    by category to show only the Physics winners.
  prefs: []
  type: TYPE_NORMAL
