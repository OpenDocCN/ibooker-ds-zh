<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>chapter-4</title>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
 </head>
 <body>
  <div class="readable-text " id="p1"> 
   <h1 class=" readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">4</span></span> Streamlit's execution model</h1>
  </div>
  <div class="introduction-summary"> 
   <h3>This chapter covers</h3>
   <ul> 
    <li class="readable-text" id="p2">Creating apps that require maintaining state between page updates</li>
    <li class="readable-text" id="p3">Troubleshooting your apps effectively</li>
    <li class="readable-text" id="p4">The all important <kbd>st.session_state</kbd> and <kbd>st.rerun</kbd></li>
    <li class="readable-text" id="p5">Streamlit's execution model</li>
   </ul>
  </div>
  <div class="readable-text " id="p6"> 
   <p>In the last two chapters, you've gotten your feet wet with Streamlit by building two fully-functional apps: a password checker and a unit converter. You've learned the basics of Streamlit's syntax and how to create interactive elements. But what happens behind the scenes when you run a Streamlit app? Understanding this is key to building more complex applications.</p>
  </div>
  <div class="readable-text  intended-text" id="p7"> 
   <p>This chapter delves into the heart of Streamlit's execution model, where we'll explore how to manage an app's state.</p>
  </div>
  <div class="readable-text  intended-text" id="p8"> 
   <p>This chapter also takes a slightly different approach than the previous ones. While we'll still build a practical application – a daily to-do list app – the primary focus is on equipping you with troubleshooting skills. We'll intentionally introduce some bugs into the app to simulate real-world situations where things might not go according to plan. By following along and fixing these issues, you'll gain a deeper understanding of Streamlit's inner workings and how to debug your own apps effectively.</p>
  </div>
  <div class="readable-text" id="p9"> 
   <h2 class=" readable-text-h2">4.1 A more complex app: Daily to-dos</h2>
  </div>
  <div class="readable-text " id="p10"> 
   <p>Ever juggled multiple deadlines at work while mentally planning a vacation for your family, while <em>also</em> trying to remember to buy bread on the way home? Regardless of your specific situation, the frenzy of modern life has a way of getting you in its grip, pulling you into a whirlwind of endless activity and demands. Hopefully this chapter's Streamlit app helps you manage the chaos even if it can't actually deliver the bread to your doorstep.</p>
  </div>
  <div class="readable-text  intended-text" id="p11"> 
   <p>We're going to be making a to-do list app that lets a user track the various things they have to get done in a day.</p>
  </div>
  <div class="readable-text  intended-text" id="p12"> 
   <p>Since the primary point of this chapter is to get you familiar with Streamlit's execution model, we won't go through the entire six-step development process in detail as we did in the last chapter.</p>
  </div>
  <div class="readable-text  intended-text" id="p13"> 
   <p>Instead, we'll breeze through the concept, the requirements and a mock design, and then jump straight to implementation.</p>
  </div>
  <div class="readable-text" id="p14"> 
   <h3 class=" readable-text-h3">4.1.1 Stating the concept</h3>
  </div>
  <div class="readable-text " id="p15"> 
   <p>As you hopefully remember from the last chapter, the concept is a succinct statement of what our app is. Here it is for our app:</p>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p16"> 
    <h5 class=" callout-container-h5 readable-text-h5">Concept</h5>
   </div>
   <div class="readable-text" id="p17"> 
    <p>A Streamlit app that lets users add tasks to a daily to-do list and track their status.</p>
   </div>
  </div>
  <div class="readable-text " id="p18"> 
   <p>That seems pretty crisp and clear, so let's dive into the detailed requirements.</p>
  </div>
  <div class="readable-text" id="p19"> 
   <h3 class=" readable-text-h3">4.1.2 Defining the requirements</h3>
  </div>
  <div class="readable-text " id="p20"> 
   <p>To recap from Chapter 3, while the concept provides a general idea of your app, it's your requirements that make it concrete, laying out what the user needs from it.</p>
  </div>
  <div class="readable-text  intended-text" id="p21"> 
   <p>The requirements for the to-do list app we're building are the following:</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p22"> 
   <h4 class=" readable-text-h4">Requirements:</h4>
  </div>
  <div class="readable-text " id="p23"> 
   <p>The user should be able to:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p24">view their daily to-do list, made up of tasks</li>
   <li class="readable-text" id="p25">add a task to their to-do list</li>
   <li class="readable-text" id="p26">remove a task from their list</li>
   <li class="readable-text" id="p27">mark a task in their list as done</li>
   <li class="readable-text" id="p28">undo marking a task as done</li>
   <li class="readable-text" id="p29">see their overall task completion status, i.e., their total number of tasks and the number they've completed</li>
  </ul>
  <div class="readable-text " id="p30"> 
   <p>It's just as important, if not even more so, to clarify what our app <em>won't</em> do, so let's specify that as well:</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p31"> 
   <h4 class=" readable-text-h4">What's out of scope</h4>
  </div>
  <ul> 
   <li class="readable-text" id="p32">Retrieving a to-do list when the user refreshes or reopens the page</li>
   <li class="readable-text" id="p33">Exporting a to-do list to an external file or format</li>
   <li class="readable-text" id="p34">Saving the history of added or completed to-dos</li>
  </ul>
  <div class="readable-text " id="p35"> 
   <p>The two lists above should give you a sense of what we're trying to build in this chapter: it's a fairly basic daily to-do list that lives entirely within a single browser session.</p>
  </div>
  <div class="readable-text  intended-text" id="p36"> 
   <p>Essentially, the way we expect the user to interact with our app is to open it in a browser window at the beginning of the day, add their tasks, and mark them as done/not done as their day progresses, <em>keeping the window open until the end of the day and never refreshing it</em>. Rinse and repeat the next day.</p>
  </div>
  <div class="readable-text  intended-text" id="p37"> 
   <p>We're not going to build the ability to <em>persist</em> (or save) any tasks outside of the browser session. If you refresh the page, you lose your data.</p>
  </div>
  <div class="readable-text  intended-text" id="p38"> 
   <p><em>"Doesn't that limit the usefulness of the app somewhat?"</em> you might ask. Absolutely. It's just that we don't want to introduce the complexity of external storage just yet. We'll explore that later on in the book, especially in Part 2.</p>
  </div>
  <div class="readable-text  intended-text" id="p39"> 
   <p>However, one might also argue that giving users a blank slate at the start of each day makes them <em>more</em> productive. So you see, not being able to save your tasks is a<em> feature</em>, not a bug!</p>
  </div>
  <div class="readable-text  intended-text" id="p40"> 
   <p>It's mostly the complexity thing. Still, you should know that spinning the limitations of your product into positives is practically a survival skill in the industry! I bet your other frontend tech manuals don't also give you free life advice.</p>
  </div>
  <div class="readable-text" id="p41"> 
   <h3 class=" readable-text-h3">4.1.3 Visualizing the user experience</h3>
  </div>
  <div class="readable-text " id="p42"> 
   <p>We now know with a fair amount of precision what our app needs to be able to do, so with that in mind and keeping with the principle we introduced in the last chapter of putting the user experience front and center, let's turn our attention to the mock UI design shown in figure 4.1.</p>
  </div>
  <div class="browsable-container figure-container" id="p43">  
   <img src="../Images/04__image001.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.1 The mock UI design for our daily to-do list app</h5>
  </div>
  <div class="readable-text " id="p44"> 
   <p>Our design has two sections: a sidebar where you can enter new tasks, and a "main" area where you can view the tasks you've added and update their status.</p>
  </div>
  <div class="readable-text  intended-text" id="p45"> 
   <p>Once you add a task by entering the task text and clicking the button on the left, it appears on the right. Each task is rendered as a checkbox. You mark a task as "done" by checking the box, which also satisfyingly strikes through the task. You can delete a task entirely by clicking the button to its right.</p>
  </div>
  <div class="readable-text  intended-text" id="p46"> 
   <p>There's also a tracker at the top which tells you how many tasks you've completed out of the total.</p>
  </div>
  <div class="readable-text" id="p47"> 
   <h3 class=" readable-text-h3">4.1.4 Brainstorming the implementation</h3>
  </div>
  <div class="readable-text " id="p48"> 
   <p>You may have realized that our to-do list app is somewhat more complex than the password checker we built in Chapter 2 or even the unit conversion app in Chapter 3. In both of those cases, there was ultimately a single primary action the user could take—to evaluate the entered password in the case of the former, and to perform the conversion in the case of the latter.</p>
  </div>
  <div class="readable-text  intended-text" id="p49"> 
   <p>Our to-do list has <em>four </em>different actions the user can take:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p50">add a task</li>
   <li class="readable-text" id="p51">mark it as done</li>
   <li class="readable-text" id="p52">mark it as not done</li>
   <li class="readable-text" id="p53">delete it</li>
  </ul>
  <div class="readable-text " id="p54"> 
   <p>Let's take a moment to brainstorm how we're going to make this happen.</p>
  </div>
  <div class="readable-text  intended-text" id="p55"> 
   <p>Central to our implementation is the notion of a <em>task</em>, and by extension a <em>task list</em>. For the purposes of our app, a task is an object with two properties: a name, and a status which can be "done" or "not done.” A task list is simply an ordered list of tasks.</p>
  </div>
  <div class="readable-text  intended-text" id="p56"> 
   <p>The four user actions mentioned above are simply different ways in which you can modify the task list; adding a task adds an item to the list, marking it as done/not done updates the status of an item in the list, and deleting a task removes it from the list.</p>
  </div>
  <div class="readable-text  intended-text" id="p57"> 
   <p>At every point, the app should show the latest state of the task list to the user.</p>
  </div>
  <div class="readable-text  intended-text" id="p58"> 
   <p>We can therefore divide our app into three parts:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p59">The task list</li>
   <li class="readable-text" id="p60">Actions, which are wired up to buttons and checkboxes, and modify the task list</li>
   <li class="readable-text" id="p61">Display logic, which renders the task list on the screen</li>
  </ul>
  <div class="readable-text " id="p62"> 
   <p>Whenever an action is performed, the task list is modified, and the display logic automatically updates what's shown on the screen.</p>
  </div>
  <div class="readable-text  intended-text" id="p63"> 
   <p>Figure 4.2 shows what happens when a new task is added; the task is appended to the task list, and the display logic loops through all the tasks again and renders them on the screen based on a number of rules such as "strikethrough if done.”</p>
  </div>
  <div class="browsable-container figure-container" id="p64">  
   <img src="../Images/04__image002.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.2 Adding a task appends an item to the task list and the display logic renders the updated task list</h5>
  </div>
  <div class="readable-text " id="p65"> 
   <p>Something very similar happens when a task is checked off, as shown in figure 4.3. This time, the status of the task is updated in the task list. Everything else goes the same way; the display logic once again loops through every task. The "checked if done" and "strikethrough if done" rule are picked up to give the completed "Buy bread" task the appearance we want.</p>
  </div>
  <div class="browsable-container figure-container" id="p66">  
   <img src="../Images/04__image003.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.3 Checking off a task updates the status of the item in the task list and the same display logic re-renders the updated task list</h5>
  </div>
  <div class="readable-text " id="p67"> 
   <p>Deleting a task or un-checking one works pretty much the same way; the task list stored in memory is updated and re-rendered by the display logic.</p>
  </div>
  <div class="readable-text  intended-text" id="p68"> 
   <p>At this point, we've identified how we'll represent the key entities in our app, and what effect each user action will have. It's now time to implement our logic.</p>
  </div>
  <div class="readable-text" id="p69"> 
   <h2 class=" readable-text-h2">4.2 Implementing and troubleshooting our app</h2>
  </div>
  <div class="readable-text " id="p70"> 
   <p>When we built the unit conversion app in Chapter 3, we took the scenic route, walking through each step of the app development process in detail. However, there's a part of the process we didn't really dwell on: what happens when things go wrong, and how to troubleshoot the problem. It was a fairly smooth ride.</p>
  </div>
  <div class="readable-text  intended-text" id="p71"> 
   <p>This time around, we'll take a bumpier path that you'll find to be more representative of the real world. We'll run into various issues and errors as we implement our to-do list app. Just as in the real world, these errors will prompt us to learn about Streamit in more depth. And we'll use our deeper understanding to power through and fix the problems.</p>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p72"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p73"> 
    <p>Since the focus of this chapter is to give you experience in troubleshooting problems with your apps, we'll eschew some of the best practices we learned in Chapter 3 ( such as maintaining a strict separation between backend and frontend, or defining a clear API), in favor of more concise code.</p>
   </div>
  </div>
  <div class="readable-text " id="p74"> 
   <p>To begin, spin up a new file in your code editor and name it <kbd>todo_list.py</kbd>.</p>
  </div>
  <div class="readable-text" id="p75"> 
   <h3 class=" readable-text-h3">4.2.1 Displaying the task list</h3>
  </div>
  <div class="readable-text " id="p76"> 
   <p>While we've done our planning up front in one shot, when it comes to writing the actual code, we're going to be building our app iteratively as we did in Chapter 3, going part-by-part and viewing the results in Streamlit along the way.</p>
  </div>
  <div class="readable-text  intended-text" id="p77"> 
   <p>So where do we start? What's the first iteration?</p>
  </div>
  <div class="readable-text  intended-text" id="p78"> 
   <p>As discussed in the previous section, the notion of a task list is central to our app's implementation. The display logic component of our app always needs to show the latest state of the task list.</p>
  </div>
  <div class="readable-text  intended-text" id="p79"> 
   <p>Our very first step can be as simple as creating the heading for the task list.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p80"> 
   <h4 class=" readable-text-h4">st.header</h4>
  </div>
  <div class="readable-text " id="p81"> 
   <p>Streamlit has several different text elements which simply display text in various sizes and formatting. We've used <kbd>st.title</kbd> before to render large titles.</p>
  </div>
  <div class="readable-text  intended-text" id="p82"> 
   <p><kbd>st.header</kbd> is pretty similar, but it displays text that's a bit smaller than <kbd>st.title</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p83"> 
   <p>Use it by putting the code in Listing 4.1 into <kbd>todo_list.py</kbd>.</p>
  </div>
  <div class="browsable-container listing-container" id="p84"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 4.1 todo_list.py with just a header</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
 
st.header("Today's to-dos:", divider="gray")
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p85"> 
   <p>Notice that we've included a divider argument, which simply displays a gray line beneath your header. Neat, huh?</p>
  </div>
  <div class="readable-text  intended-text" id="p86"> 
   <p>As always, to see your work in action, save your file and run <kbd>streamlit run todo_list.py</kbd> or <kbd>streamlit run &lt;path to frontend.py&gt;</kbd> if you're in a different working directory.</p>
  </div>
  <div class="readable-text  intended-text" id="p87"> 
   <p>When your browser window opens, you should see something like figure 4.4.</p>
  </div>
  <div class="browsable-container figure-container" id="p88">  
   <img src="../Images/04__image004.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.4 st.header with a divider</h5>
  </div>
  <div class="readable-text " id="p89"> 
   <p>If you happen to have multiple headers in your app, you can even cycle between divider colors by setting <kbd>divider</kbd> to <kbd>True</kbd> instead of a specific color.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p90"> 
   <h4 class=" readable-text-h4">Creating a task list</h4>
  </div>
  <div class="readable-text " id="p91"> 
   <p>Next, let's turn to our notion of a task. As mentioned earlier, a task has a name and a done/not-done status.</p>
  </div>
  <div class="readable-text  intended-text" id="p92"> 
   <p>We can therefore use a dataclass to represent a task with exactly those two fields: a string <kbd>name</kbd> and a boolean <kbd>is_done</kbd> to represent the task status. Listing 4.2 shows the <kbd>Task</kbd> class. Go ahead and save this into a new file called <kbd>task.py</kbd> in the same directory as <kbd>todo_list.py</kbd>.</p>
  </div>
  <div class="browsable-container listing-container" id="p93"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 4.2 task.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">from dataclasses import dataclass
 
@dataclass
class Task:
    name: str
    is_done: bool = False</pre>
   </div>
  </div>
  <div class="readable-text " id="p94"> 
   <p>Notice the line <kbd>is_done: bool = False</kbd>. Here, we're setting <kbd>is_done</kbd> to <kbd>False</kbd> by default, in case it's not specified while creating an instance of <kbd>Task</kbd>. This will come in handy momentarily.</p>
  </div>
  <div class="readable-text  intended-text" id="p95"> 
   <p>Now that we have a task, our task list is literally a Python list of <kbd>Task</kbd> objects. You can create this in <kbd>todo_list.py</kbd> with a couple of dummy tasks to test it out like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p96"> 
   <div class="code-area-container"> 
    <pre class="code-area">task_list = [Task("Buy milk"), Task("Walk the dog")]</pre>
   </div>
  </div>
  <div class="readable-text " id="p97"> 
   <p>Since we've specified a default value of <kbd>False</kbd> for <kbd>is_done</kbd>, there's no need to specify it for each instance of <kbd>Task</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p98"> 
   <p>Don't forget to import your <kbd>Task</kbd> class at the top of the file:</p>
  </div>
  <div class="browsable-container listing-container" id="p99"> 
   <div class="code-area-container"> 
    <pre class="code-area">from task import Task</pre>
   </div>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p100"> 
   <h4 class=" readable-text-h4">Checkboxes for tasks</h4>
  </div>
  <div class="readable-text " id="p101"> 
   <p>Starting out, our display logic can be simple: let's just display a checkbox for each task. We know how to create a static checkbox with a string label; recall that we used <kbd>st.checkbox</kbd> to make a checkbox that rounds the results of our unit conversion in Chapter 3.</p>
  </div>
  <div class="readable-text  intended-text" id="p102"> 
   <p>But here, we don't know the labels for each checkbox beforehand. Instead we have to infer them from <kbd>task_list</kbd>. How do we do that?</p>
  </div>
  <div class="readable-text  intended-text" id="p103"> 
   <p>The answer, of course, is a loop. When a Streamlit element is placed in a loop, a new element is rendered each time the loop runs. We've actually already encountered this in our initial password checker example in Chapter 2, where we used <kbd>st.success</kbd> and <kbd>st.error</kbd> in a loop to display the green and red boxes that indicated the pass/fail status of each condition.</p>
  </div>
  <div class="readable-text  intended-text" id="p104"> 
   <p>We can create checkboxes from our task list like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p105"> 
   <div class="code-area-container"> 
    <pre class="code-area">for task in task_list:
    st.checkbox(task.name, task.is_done)</pre>
   </div>
  </div>
  <div class="readable-text " id="p106"> 
   <p>Recall that the first argument passed to <kbd>st.checkbox</kbd> is the label (the task's name in this case) and the second is a boolean that indicates whether the checkbox should be rendered as checked or not. We want each checkbox to be checked if the task is done, so it makes sense to pass the task's <kbd>is_done</kbd> field here directly.</p>
  </div>
  <div class="readable-text  intended-text" id="p107"> 
   <p>Listing 4.3 shows what <kbd>todo_list.py</kbd> should look like at this point.</p>
  </div>
  <div class="browsable-container listing-container" id="p108"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 4.3 task.py with checkboxes for each task</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
from task import Task
 
task_list = [Task("Buy milk"), Task("Walk the dog")]
 
st.header("Today's to-dos:", divider="gray")
for task in task_list:
    st.checkbox(task.name, task.is_done)
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p109"> 
   <p>Save and run to get the output shown in figure 4.5</p>
  </div>
  <div class="browsable-container figure-container" id="p110">  
   <img src="../Images/04__image005.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.5 Using st.checkbox in a loop to display one for each task</h5>
  </div>
  <div class="readable-text " id="p111"> 
   <p>Our checkboxes don't actually do anything yet. We'll get to that in a minute, but first let's add a "delete" button to each task.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p112"> 
   <h4 class=" readable-text-h4">Adding delete buttons</h4>
  </div>
  <div class="readable-text " id="p113"> 
   <p>We want a button to delete each task in the list, situated to its right. Similar to how we did it for the checkboxes, we're going to be generating these buttons dynamically, so they should go into the loop we wrote earlier.</p>
  </div>
  <div class="readable-text  intended-text" id="p114"> 
   <p>But if we simply tack on the button inside the loop, Streamlit will put it <em>under</em> the checkbox for the task, not to the <em>right</em> of the task, because Streamlit renders elements vertically by default as we saw in Chapter 3.</p>
  </div>
  <div class="readable-text  intended-text" id="p115"> 
   <p>As before, we'll use <kbd>st.columns</kbd> to work around this. Here, we'll make two columns—one for the checkbox and task text and another for the button. Go ahead and replace your existing <kbd>for task in task_list</kbd> loop with this:</p>
  </div>
  <div class="browsable-container listing-container" id="p116"> 
   <div class="code-area-container"> 
    <pre class="code-area">for task in task_list:
    task_col, delete_col = st.columns([0.8, 0.2])
    task_col.checkbox(task.name, task.is_done)
    if delete_col.button("Delete"):
        pass</pre>
   </div>
  </div>
  <div class="readable-text " id="p117"> 
   <p>Notice that we're calling <kbd>st.columns</kbd> a little differently from how we did in the previous chapter: <kbd>st.columns([0.8, 0.2])</kbd>. Instead of passing the number of columns, we're passing a list of numbers. This list has the <em>relative widths</em> of each column. We're saying that the column with the task should take up 80% of the horizontal space and the column with the button should take 20%. If we had simply passed the number of columns, i.e., <kbd>st.columns(2)</kbd>, Streamlit would have made the two columns equally wide, which doesn't make sense because the task text can be arbitrarily long, while the button can't.</p>
  </div>
  <div class="readable-text  intended-text" id="p118"> 
   <p>We're not making the button do anything just yet, so we just wrote <kbd>pass</kbd>, which is a keyword in Python that means "do nothing.”</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p119"> 
   <h4 class=" readable-text-h4">Widget keys</h4>
  </div>
  <div class="readable-text " id="p120"> 
   <p>Let's go ahead and run our app again to see how it looks. Figure 4.6 depicts what you'll likely see.</p>
  </div>
  <div class="browsable-container figure-container" id="p121">  
   <img src="../Images/04__image006.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.6 Streamlit throws an error when there are multiple identical widgets</h5>
  </div>
  <div class="readable-text " id="p122"> 
   <p>There's a button to the right of the first task but not the second. Most importantly, there's an error message big red box underneath; Streamlit is complaining because we tried to create multiple <kbd>st.button</kbd> widgets with the same <em>key</em>.</p>
  </div>
  <div class="readable-text  intended-text" id="p123"> 
   <p>A key is a piece of text that Streamlit uses to identify a <em>widget</em>—essentially what we've been calling a Streamlit element, like <kbd>st.button</kbd>, <kbd>st.checkbox</kbd> etc. Widget keys need to be unique so that Streamlit can distinguish between any two widgets.</p>
  </div>
  <div class="readable-text  intended-text" id="p124"> 
   <p>You don't have to specify the key for a widget in your code manually most of the time because Streamlit specifies one internally based on its characteristics. For a button, Streamlit's internal key is based on the text in it. So when you have two buttons that say "Delete,” their keys are identical, which breaks the uniqueness constraint.</p>
  </div>
  <div class="readable-text  intended-text" id="p125"> 
   <p>The way around this, as the error suggests, is to manually specify a unique key for each button we create.</p>
  </div>
  <div class="readable-text  intended-text" id="p126"> 
   <p>Since we need a unique delete-button key for every task in our list, one way of ensuring a unique key might be to include the list index for the task within the key. For instance, the key for the first task's delete-button could be <kbd>delete_0</kbd>, the key for the second could be <kbd>delete_1,</kbd> and so on:</p>
  </div>
  <div class="browsable-container listing-container" id="p127"> 
   <div class="code-area-container"> 
    <pre class="code-area">for idx, task in enumerate(task_list):
    task_col, delete_col = st.columns([0.8, 0.2])
    task_col.checkbox(task.name, task.is_done)
    if delete_col.button("Delete", key=f"delete_{idx}"):
        pass</pre>
   </div>
  </div>
  <div class="readable-text " id="p128"> 
   <p>Since we need both the index of the task and the task itself, we've changed the for-loop's header to <kbd>for idx, task in enumerate(task_list)</kbd>.</p>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p129"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p130"> 
    <p><kbd>enumerate</kbd>, as you may know, is a handy little function in Python that lets you iterate through a list in an elegant way, obtaining both the index and the element in one shot. The less elegant alternative would have been to write:</p>
   </div>
  </div>
  <div class="browsable-container listing-container" id="p131"> 
   <div class="code-area-container"> 
    <pre class="code-area">for idx in range(len(task_list)):
    task = task_list[idx]
    ...
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p132"> 
   <p>As we discussed, we form each button's unique key using its index: <kbd>key=f"delete_{idx}"</kbd>. If you run your code now, you should see the error disappear, as shown in figure 4.7</p>
  </div>
  <div class="browsable-container figure-container" id="p133">  
   <img src="../Images/04__image007.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.7 Passing a unique key to each button allows Streamlit to distinguish between otherwise identical buttons</h5>
  </div>
  <div class="readable-text " id="p134"> 
   <p>You may now be wondering, "why didn't we need to pass a key to the checkboxes then?"</p>
  </div>
  <div class="readable-text  intended-text" id="p135"> 
   <p>Well, because the checkboxes already had unique internal keys since their labels (the task names) were different. We'll actually face the same issue if we try to put two identical tasks in our list. For instance, if we change our task list to <kbd>task_list = [Task("Buy milk"), Task("Buy milk")]</kbd>, we'll see an error similar to what we saw for the buttons.</p>
  </div>
  <div class="readable-text  intended-text" id="p136"> 
   <p>It's probably a good idea to let the user enter the same task twice if they want to, so let's fix the problem by passing a unique key to each checkbox as well:</p>
  </div>
  <div class="browsable-container listing-container" id="p137"> 
   <div class="code-area-container"> 
    <pre class="code-area">task_col.checkbox(task.name, task.is_done, key=f"task_{idx}")</pre>
   </div>
  </div>
  <div class="readable-text " id="p138"> 
   <p>This lets us have two tasks with the same name if we like without issues.</p>
  </div>
  <div class="readable-text" id="p139"> 
   <h3 class=" readable-text-h3">4.2.2 Enabling actions</h3>
  </div>
  <div class="readable-text " id="p140"> 
   <p>So far, we've set up our app to display our tasks in roughly the way we want them to appear, using dummy tasks to test it. We haven't actually provided a way for users to interact with or modify their tasks.</p>
  </div>
  <div class="readable-text  intended-text" id="p141"> 
   <p>That's what we'll do in this section. We'll start by defining functions that update our task list, and then hook them up to Streamlit UI elements.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p142"> 
   <h4 class=" readable-text-h4">Adding a task</h4>
  </div>
  <div class="readable-text " id="p143"> 
   <p>To add a task to our task list, we need a task name. Once we have that, adding it is as simple as creating a <kbd>Task</kbd> object and appending it to our list.</p>
  </div>
  <div class="readable-text  intended-text" id="p144"> 
   <p>We can write this out in a simple <kbd>add_task</kbd> function in <kbd>todo_list.py</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p145"> 
   <div class="code-area-container"> 
    <pre class="code-area">def add_task(task_name: str):
    task_list.append(Task(task_name))</pre>
   </div>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p146"> 
   <h4 class=" readable-text-h4">Marking a task done or not done</h4>
  </div>
  <div class="readable-text " id="p147"> 
   <p>A task's status is denoted by the <kbd>is_done</kbd> field of the <kbd>Task</kbd> instance. Therefore, marking it done or not done involves updating this field. Let's create two functions for this:</p>
  </div>
  <div class="browsable-container listing-container" id="p148"> 
   <div class="code-area-container"> 
    <pre class="code-area">def mark_done(task: Task):
    task.is_done = True
 
def mark_not_done(task: Task):
    task.is_done = False</pre>
   </div>
  </div>
  <div class="readable-text " id="p149"> 
   <p>Note that the argument to these functions is the <kbd>Task</kbd> instance itself, not the task name string.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p150"> 
   <h4 class=" readable-text-h4">Deleting a task</h4>
  </div>
  <div class="readable-text " id="p151"> 
   <p>Deleting a task is also straightforward. For this function, we need the index of the task in our list, so we can remove it.</p>
  </div>
  <div class="browsable-container listing-container" id="p152"> 
   <div class="code-area-container"> 
    <pre class="code-area">def delete_task(idx: int):
    del task_list[idx]</pre>
   </div>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p153"> 
   <h4 class=" readable-text-h4">Enabling users to add tasks</h4>
  </div>
  <div class="readable-text " id="p154"> 
   <p>As we now have an <kbd>add_task</kbd> function, we no longer have to seed our task list with dummy tasks. Let's replace the line <kbd>task_list = [Task("Buy milk"), Task("Walk the dog")]</kbd> with an empty list:</p>
  </div>
  <div class="browsable-container listing-container" id="p155"> 
   <div class="code-area-container"> 
    <pre class="code-area">task_list = []</pre>
   </div>
  </div>
  <div class="readable-text " id="p156"> 
   <p>Next, we'll add Streamlit elements to let the user call our <kbd>add_task </kbd>function. We'll need an <kbd>st.text_input </kbd>for the user to enter the task name, and an <kbd>st.button </kbd>to trigger the addition. We'll wrap both of these in <kbd>st.sidebar</kbd> so they appear in a left-hand-side panel in our app. Again, if any of this sounds unfamiliar, you should review Chapter 3.</p>
  </div>
  <div class="browsable-container listing-container" id="p157"> 
   <div class="code-area-container"> 
    <pre class="code-area">with st.sidebar:
    task = st.text_input("Enter a task")
    if st.button("Add task", type="primary"):
        add_task(task)</pre>
   </div>
  </div>
  <div class="readable-text " id="p158"> 
   <p>Note the <kbd>type="primary"</kbd> in <kbd>st.button</kbd>. The <kbd>type</kbd> parameter lets you add emphasis to a button (in the form of a different color) by denoting that it's linked to a "primary action.” In UI design, it's a good idea to have your user's eyes be drawn to the actions that they would commonly perform. Here, adding a task is something we'd expect the user to do all the time, so using a primary button makes sense. If you don't specify this parameter (which we've been doing all along until now), it defaults to "secondary,” which—at the time of writing—results in a white button.</p>
  </div>
  <div class="readable-text  intended-text" id="p159"> 
   <p>Note also that we didn't add a widget key to the button because we only have one "Add task" button and Streamlit doesn't need any extra help to distinguish it from other buttons.</p>
  </div>
  <div class="readable-text  intended-text" id="p160"> 
   <p>At this point, your <kbd>todo_list.py</kbd> file should like what's shown in listing 4.4.</p>
  </div>
  <div class="browsable-container listing-container" id="p161"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 4.4 todo_list.py so far</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
from task import Task
 
task_list = []
 
def add_task(task_name: str):
    task_list.append(Task(task_name))
 
def delete_task(idx: int):
    del task_list[idx]
 
def mark_done(task: Task):
    task.is_done = True
 
def mark_not_done(task: Task):
    task.is_done = False
 
with st.sidebar:
    task = st.text_input("Enter a task")
    if st.button("Add task", type="primary"):
        add_task(task)
 
st.header("Today's to-dos:", divider="gray")
for idx, task in enumerate(task_list):
    task_col, delete_col = st.columns([0.8, 0.2])
    task_col.checkbox(task.name, task.is_done, key=f"task_{idx}")
    if delete_col.button("Delete", key=f"delete_{idx}"):
        pass
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p162"> 
   <p>Save and run your code. To check the result (see figure 4.8), enter a new task called "Clean garage" and click "Add task.”</p>
  </div>
  <div class="browsable-container figure-container" id="p163">  
   <img src="../Images/04__image008.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.8 To-do list app with one to-do added</h5>
  </div>
  <div class="readable-text " id="p164"> 
   <p>So far so good, but when we try adding another task, say "Finalize project proposal,” we see the problematic output shown in figure 4.9.</p>
  </div>
  <div class="browsable-container figure-container" id="p165">  
   <img src="../Images/04__image009.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.9 When a new task is added, the old one disappears</h5>
  </div>
  <div class="readable-text " id="p166"> 
   <p>We see our new task alright but the old one, "Clean garage,” is gone. Something seems wrong, but we don't see an error as we did for the widget key issue.</p>
  </div>
  <div class="readable-text  intended-text" id="p167"> 
   <p>Oddly, clicking "Delete" removes the remaining task (see figure 4.10), even though we didn't actually wire it up to anything; recall that we used <kbd>pass</kbd> to make the button do nothing—something that's commonly referred to as a <em>no-op.</em></p>
  </div>
  <div class="browsable-container figure-container" id="p168">  
   <img src="../Images/04__image010.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.10 Clicking "Delete" removes the task even though we didn't hook it up to anything.</h5>
  </div>
  <div class="readable-text " id="p169"> 
   <p>The same thing happens if you add a task again and click the checkbox: the task just disappears. Feel free to try that out as well.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p170"> 
   <h4 class=" readable-text-h4">What's gone wrong?</h4>
  </div>
  <div class="readable-text " id="p171"> 
   <p>Clearly, our app isn't working as we intended. Streamlit doesn't show an error, so it's up to us to figure out what's happening. Is our display logic only showing the last task added? Or is there something wrong with the task list itself?</p>
  </div>
  <div class="readable-text  intended-text" id="p172"> 
   <p>Let's find out. One of the most important parts of troubleshooting code is inspecting the value of variables while a program is running. In a normal Python script (i.e., one that you would run from the command-line rather than using Streamlit), you might include <kbd>print</kbd> statements to display the value of a variable. You could also use your IDE's debugger or the <kbd>pdb</kbd> module, but let's keep things simple.</p>
  </div>
  <div class="readable-text  intended-text" id="p173"> 
   <p><kbd>print</kbd> statements don't show up on the browser window of your Streamlit app, however. Instead, let's use an appropriate Streamlit element. We're interested in the <kbd>task_list</kbd> variable, so go ahead and write the following right under the line <kbd>st.header("Today's to-dos:", divider="gray")</kbd>, before our display logic for-loop.</p>
  </div>
  <div class="browsable-container listing-container" id="p174"> 
   <div class="code-area-container"> 
    <pre class="code-area">st.info(f"task_list: {task_list}")</pre>
   </div>
  </div>
  <div class="readable-text " id="p175"> 
   <p><kbd>st.info</kbd> is an element that displays some text in a colored box. It's part of a family of elements we've seen already in Chapter 2: <kbd>st.success</kbd>, <kbd>st.error</kbd>, and <kbd>st.warning</kbd>, which also display text in colored boxes. For <kbd>st.info</kbd>, the box is blue.</p>
  </div>
  <div class="readable-text  intended-text" id="p176"> 
   <p>When you save and run (or refresh the page), you'll see a box with the text task_list: [], since there are no tasks yet. Add a task like before and you'll see the output in figure 4.11.</p>
  </div>
  <div class="browsable-container figure-container" id="p177">  
   <img src="../Images/04__image011.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.11 task_list contains a single Task instance</h5>
  </div>
  <div class="readable-text " id="p178"> 
   <p>As you can see, <kbd>task_list</kbd> now contains a single instance of <kbd>Task</kbd>, corresponding to "Clean garage.” When we add a second task, our <kbd>task_list</kbd> variable only has the new task. That shows that it's not our display logic that's faulty; the <kbd>task_list</kbd> variable itself has lost the "Clean garage" task. .</p>
  </div>
  <div class="readable-text  intended-text" id="p179"> 
   <p>When we try either checking the box next to the task or pressing "Delete” <kbd>task_list</kbd> is now empty again, which is why no tasks are displayed.</p>
  </div>
  <div class="readable-text  intended-text" id="p180"> 
   <p>Okay, so here's what we know: adding a task seems to add a task to <kbd>task_list</kbd> correctly, but whenever you do <em>anything</em> else afterwards, whether it's adding another task or clicking a checkbox or the "Delete" button, it removes the previously added task from <kbd>task_list</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p181"> 
   <p>Before we can fix this, we'll need to understand why this is happening. For this, let's review how a Streamlit app actually works.</p>
  </div>
  <div class="readable-text" id="p182"> 
   <h2 class=" readable-text-h2">4.3 How Streamlit executes an app</h2>
  </div>
  <div class="readable-text " id="p183"> 
   <p>In the last two chapters, we've learned how to use Streamlit and even developed a couple of non-trivial apps with it. However, we've mostly focused on syntax and a surface-level understanding of how apps work.</p>
  </div>
  <div class="readable-text  intended-text" id="p184"> 
   <p>To be successful in writing more complex Streamlit apps, we'll need to diver deeper than that. To go further, we need to talk about something quite fundamental to Streamlit: its execution model.</p>
  </div>
  <div class="readable-text" id="p185"> 
   <h3 class=" readable-text-h3">4.3.1 Frontend and server</h3>
  </div>
  <div class="readable-text " id="p186"> 
   <p>A Streamlit app actually has two parts: a backend <em>Streamlit server</em> and a <em>frontend</em>.</p>
  </div>
  <div class="readable-text  intended-text" id="p187"> 
   <p>A server, for our purposes, is a software program that runs on your computer, waiting for requests to be sent to it. In technical terms, we say that a server is <em>listening</em> at a <em>port</em>.</p>
  </div>
  <div class="readable-text  intended-text" id="p188"> 
   <p>A port is a virtual designation that identifies a particular kind of communication channel, kind of like an extension number in a large office. Just as an extension allows you to reach a specific person within a company, a port allows network communication to reach a specific program running on your computer.</p>
  </div>
  <div class="readable-text  intended-text" id="p189"> 
   <p>When you enter <kbd>streamlit run &lt;filename.py&gt;</kbd> in your terminal, you may have noticed output that looks something like the following:</p>
  </div>
  <div class="browsable-container listing-container" id="p190"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">Local URL: http://localhost:<b>8502</b></pre>
   </div>
  </div>
  <div class="readable-text " id="p191"> 
   <p>What's actually happening here is that a Streamlit server starts up and starts listening for requests on the port 8502 (the exact port number may differ for you).</p>
  </div>
  <div class="readable-text  intended-text" id="p192"> 
   <p>When you now open a browser and navigate to the given address (i.e., <kbd>http://localhost:8502</kbd>) or just wait until the server automatically does this for you, the browser sends a request to the Streamlit server on port 8502.</p>
  </div>
  <div class="readable-text  intended-text" id="p193"> 
   <p>In response, the Streamlit server executes your Python script from top to bottom and sends a message back to the browser, telling it what to display, i.e., the frontend.</p>
  </div>
  <div class="readable-text  intended-text" id="p194"> 
   <p>The frontend is thus the front-facing part of your app that users can see and interact with, and it runs on your web browser. It consists of HTML, CSS, and Javascript code that your browser understands.</p>
  </div>
  <div class="readable-text" id="p195"> 
   <h3 class=" readable-text-h3">4.3.2 App re-runs</h3>
  </div>
  <div class="readable-text " id="p196"> 
   <p>Now, here's the important part: the Streamlit server runs your Python script in its entirety <em>every</em> time the page needs to change. This includes each time the user interacts with a widget in your app.</p>
  </div>
  <div class="readable-text  intended-text" id="p197"> 
   <p>For example, figure 4.12 details what happens when a user clicks a button in your app.</p>
  </div>
  <div class="browsable-container figure-container" id="p198">  
   <img src="../Images/04__image012.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.12 Every time the user interacts with the app, the Python script is re-run</h5>
  </div>
  <div class="readable-text " id="p199"> 
   <p>Once the frontend detects the button-click, it sends a message to the server, informing it about the click. The server reacts to this information by re-running the Python code, setting the button to evaluate to <kbd>True</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p200"> 
   <p>When that's done, the server sends the frontend a message with the changes that need to be made to the display. The frontend then makes those changes and the user sees the updated display.</p>
  </div>
  <div class="readable-text  intended-text" id="p201"> 
   <p>Note that this isn't unique to button clicks; it applies for <em>any </em>interaction or <em>any</em> time Streamlit determines the display needs to change. This means that every single time the user clicks a button or selects a different item from a dropdown or moves a slider, the cycle repeats and the server re-runs your whole Python script.</p>
  </div>
  <div class="readable-text" id="p202"> 
   <h3 class=" readable-text-h3">4.3.3 Applying this to our app</h3>
  </div>
  <div class="readable-text " id="p203"> 
   <p>Let's see if we can figure out what's happening in our to-do list app with this knowledge of app re-runs.</p>
  </div>
  <div class="readable-text  intended-text" id="p204"> 
   <p>Listing 4.5 shows the code as it exists at the moment.</p>
  </div>
  <div class="browsable-container listing-container" id="p205"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 4.5 todo_list.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
from task import Task
 
task_list = []
 
def add_task(task_name: str):
    task_list.append(Task(task_name))
 
def delete_task(idx: int):
    del task_list[idx]
 
def mark_done(task: Task):
    task.is_done = True
 
def mark_not_done(task: Task):
    task.is_done = False
 
with st.sidebar:
    task = st.text_input("Enter a task")
    if st.button("Add task", type="primary"):
        add_task(task)
 
st.header("Today's to-dos:", divider="gray")
st.info(f"task_list: {task_list}")
for idx, task in enumerate(task_list):
    task_col, delete_col = st.columns([0.8, 0.2])
    task_col.checkbox(task.name, task.is_done, key=f"task_{idx}")
    if delete_col.button("Delete", key=f"delete_{idx}"):
        pass</pre>
   </div>
  </div>
  <div class="readable-text " id="p206"> 
   <p>We're now going to walk through how this code executes at various points in the app's usage.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p207"> 
   <h4 class=" readable-text-h4">First run</h4>
  </div>
  <div class="readable-text " id="p208"> 
   <p>The very first time our app runs, i.e., when the user first loads it, <kbd>task_list</kbd> is set to an empty list.</p>
  </div>
  <div class="readable-text  intended-text" id="p209"> 
   <p>Now consider this line within the<kbd> st.sidebar</kbd> context manager:</p>
  </div>
  <div class="browsable-container listing-container" id="p210"> 
   <div class="code-area-container"> 
    <pre class="code-area">if st.button("Add task", type="primary")</pre>
   </div>
  </div>
  <div class="readable-text " id="p211"> 
   <p>This is an <kbd>if</kbd> statement, so the line under it, i.e., <kbd>add_task(task)</kbd>, will only be executed if the <kbd>st.button</kbd> expression evaluates to <kbd>True</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p212"> 
   <p>So far the button hasn't been clicked, so it evaluates to <kbd>False</kbd> and <kbd>add_task</kbd> is not called. <kbd>task_list</kbd> is therefore still an empty list.</p>
  </div>
  <div class="readable-text  intended-text" id="p213"> 
   <p>The code then proceeds to the <kbd>st.info</kbd> box and display logic, but since there are no tasks, <kbd>st.info</kbd> shows an empty list, and the loop never executes, so there are no checkboxes.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p214"> 
   <h4 class=" readable-text-h4">User adds a task</h4>
  </div>
  <div class="readable-text " id="p215"> 
   <p>Let's now say the user has entered a task, "Clean garage,” and clicked the "Add task" button. As mentioned earlier, this triggers a re-run of the entire Python code.</p>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p216"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p217"> 
    <p>Technically, a re-run may already have occurred at this point even <em>before</em> the user clicks the button. When the user has finished entering "Clean garage,” if they shift focus outside of the textbox by clicking outside it, that would qualify as an interaction (since the value in the textbox has changed) and trigger a re-run of the code. This doesn't lead to any interesting changes though, so let's ignore it for now.</p>
   </div>
  </div>
  <div class="readable-text " id="p218"> 
   <p>Starting from the top of the script again, <kbd>task_list</kbd> is set to the empty list. Due to the line <kbd>task = st.text_input("Enter a task")</kbd>, the variable task now holds the string "Clean garage" as that's what's in the textbox.</p>
  </div>
  <div class="readable-text  intended-text" id="p219"> 
   <p>Since the button has just been clicked, <kbd>st.button</kbd> evaluates to <kbd>True</kbd>, so the <kbd>if</kbd> statement is triggered and <kbd>add_task</kbd> is called.</p>
  </div>
  <div class="readable-text  intended-text" id="p220"> 
   <p><kbd>add_task</kbd> creates a <kbd>Task</kbd> instance for "Clean garage" and appends it to <kbd>task_list</kbd> so it's no longer empty. This is what <kbd>st.info</kbd> shows.</p>
  </div>
  <div class="readable-text  intended-text" id="p221"> 
   <p>The display logic loop thus runs once, and proceeds to render a checkbox and delete-button. This concludes the re-run, producing the results shown in figure 4.13.</p>
  </div>
  <div class="browsable-container figure-container" id="p222">  
   <img src="../Images/04__image011.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.13 When the user clicks "Add task,” st.button evaluates to True and task_list has a task</h5>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p223"> 
   <h4 class=" readable-text-h4">User clicks the task checkbox</h4>
  </div>
  <div class="readable-text " id="p224"> 
   <p>So far so good. Everything seems like it's working. But when the user clicks the checkbox for "Clean garage,” it triggers another re-run.</p>
  </div>
  <div class="readable-text  intended-text" id="p225"> 
   <p>Once again, we start from the top, where we have the line <kbd>task_list = []</kbd>, which again sets it to the empty list, discarding the "Clean garage" task that was in there before!</p>
  </div>
  <div class="readable-text  intended-text" id="p226"> 
   <p>But let's assume that the <em>textbox</em> hasn't been cleared yet, and still says "Clean garage.” This means that once the line <kbd>task = st.text_input("Enter a task")</kbd> has been executed, the variable <kbd>task</kbd> still contains the string "Clean garage.”</p>
  </div>
  <div class="readable-text  intended-text" id="p227"> 
   <p>What happens when we get to the <kbd>st.button</kbd> line? The button has been clicked before, so does that mean it would evaluate to <kbd>True</kbd>? If it does, then <kbd>add_task</kbd> would be triggered again, appending "Clean garage" to <kbd>task_list</kbd>, restoring its earlier state, and everything would be fine.</p>
  </div>
  <div class="readable-text  intended-text" id="p228"> 
   <p>But that's not how <kbd>st.button</kbd> works. In reality, <kbd>st.button</kbd> evaluates to <kbd>True</kbd> only in the re-run that happens <em>immediately</em> after a click. In all later re-runs, it reverts to its original <kbd>False</kbd> value. In this case, clicking the checkbox triggered an all new re-run, so <kbd>st.button</kbd> now evaluates to <kbd>False</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p229"> 
   <p>This means that <kbd>add_task</kbd> is never called and <kbd>task_list</kbd> is never updated. It remains an empty list, so in turn, the for-loop is never executed and there are no displayed tasks.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p230"> 
   <h4 class=" readable-text-h4">User adds another task instead of clicking the task checkbox</h4>
  </div>
  <div class="readable-text " id="p231"> 
   <p>Just to close out this discussion, let's consider the scenario where, instead of clicking the task checkbox, the user tries to add another task (by entering "Finalize project proposal" in the task-entry textbox and clicking "Add task").</p>
  </div>
  <div class="readable-text  intended-text" id="p232"> 
   <p>The execution proceeds similarly in this case. <kbd>st_task</kbd> is set to the empty list at the top, so we lose the previous "Clean garage" task.</p>
  </div>
  <div class="readable-text  intended-text" id="p233"> 
   <p>Since we entered a new task, the textbox now holds "Finalize project proposal,” so that's what the <kbd>task</kbd> variable holds.</p>
  </div>
  <div class="readable-text  intended-text" id="p234"> 
   <p>This time, our <kbd>st.button</kbd> does evaluate to <kbd>True</kbd> by virtue of our latest button-click, and <kbd>add_task</kbd> is called with "Finalize project proposal" as the value of the passed argument. This adds the new <kbd>Task</kbd> to our otherwise empty list.</p>
  </div>
  <div class="readable-text  intended-text" id="p235"> 
   <p>At the end of this, <kbd>task_list</kbd> contains just one element: "Finalize project proposal,” which is what's displayed by <kbd>st.info</kbd> and our display logic loop, as seen in figure 4.14.</p>
  </div>
  <div class="browsable-container figure-container" id="p236">  
   <img src="../Images/04__image013.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.14 When the user adds a different task, st.button evaluates to True again, and "Finalize project proposal" is added to task_list which was empty at the start.</h5>
  </div>
  <div class="readable-text " id="p237"> 
   <p>We can finally explain the weird results we were seeing. The problem boils down to the fact that since our script re-runs each time, <kbd>task_list</kbd> keeps getting reset.</p>
  </div>
  <div class="readable-text" id="p238"> 
   <h2 class=" readable-text-h2">4.4 Persisting variables across re-runs</h2>
  </div>
  <div class="readable-text " id="p239"> 
   <p>In the last section, we were able to explain the unexpected output we were getting by reviewing Streamlit's execution model and stepping through our app's execution at various stages with our newfound understanding. In this section, we'll try and identify an approach to actually solve the issue.</p>
  </div>
  <div class="readable-text  intended-text" id="p240"> 
   <p>To recap, our dilemma is that the app we wrote is behaving like a goldfish: it has no memory of anything that happened in any previous run. And since Streamlit re-runs the entirety of our code every chance it gets, our app's memory gets wiped out repeatedly, resetting the <kbd>task_list</kbd> variable that we're using to hold the user's tasks.</p>
  </div>
  <div class="readable-text" id="p241"> 
   <h3 class=" readable-text-h3">4.4.1 st.session_state</h3>
  </div>
  <div class="readable-text " id="p242"> 
   <p>As it turns out, Streamlit has a solution for this, in the form of <kbd>st.session_state</kbd>. In a nutshell, <kbd>st.session_state</kbd> is a container for variables whose values will persist across re-runs.</p>
  </div>
  <div class="readable-text  intended-text" id="p243"> 
   <p><em>Session</em> here refers to an app session, which you can loosely think about as the time between when you open an app and either refresh the page or close it.</p>
  </div>
  <div class="readable-text  intended-text" id="p244"> 
   <p>When you need to remember a value, you can just save it into <kbd>st.session_state</kbd>, and retrieve that value in the next run, as shown in figure 4.15.</p>
  </div>
  <div class="browsable-container figure-container" id="p245">  
   <img src="../Images/04__image014.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.15 st.session_state can be used to save and retrieve values between re-runs</h5>
  </div>
  <div class="readable-text " id="p246"> 
   <p><kbd>st.session_state</kbd> is thus a rock of stability in an ocean of change. Or if you want a more technical metaphor, a store for the variables you want to persist across re-runs.</p>
  </div>
  <div class="readable-text  intended-text" id="p247"> 
   <p>So how do we actually make use of it? Well, <kbd>st.session_state</kbd> acts almost exactly like a Python dictionary though it technically isn't one. Just as in the case of a dictionary, you can add key-value pairs to it, check if a particular key exists, look up its value, or remove it altogether. Even the syntax used is identical to that of a dictionary for the most part.</p>
  </div>
  <div class="readable-text  intended-text" id="p248"> 
   <p>For instance, if you wanted to store a variable <kbd>x</kbd> with a value of 5 in<kbd> st.session_state</kbd>, you would write <kbd>st.session_state["x"] = 5</kbd>, and then retrieve the value using <kbd>st.session_state["x"]</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p249"> 
   <p>To check if <kbd>x</kbd> exists in the session state, you would write <kbd>if "x" in st.session_state</kbd>. You can even iterate through the items in <kbd>st.session_state</kbd> using <kbd>for key, value in st.session_state.items()</kbd>, and delete a key using <kbd>del st.session_state</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p250"> 
   <p>Unlike a dictionary though, you can also use dot-notation to refer to the value of a key <kbd>x</kbd> like this: <kbd>st.session_state.x.</kbd></p>
  </div>
  <div class="readable-text  intended-text" id="p251"> 
   <p>Listing 4.6 shows a toy Streamlit app using <kbd>st.session_state</kbd> whose job is to simply keep track of and increment a number:</p>
  </div>
  <div class="browsable-container listing-container" id="p252"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 4.6 A simple number-increment app</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
 
if "number" not in st.session_state:
    st.session_state.number = 0
 
if st.button("Increment"):
    st.session_state.number += 1
 
st.info(f"Number: {st.session_state.number}")
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p253"> 
   <p>We start by checking if the key <kbd>"number" </kbd>exists in the session state and adding it with a value of zero if it doesn't.</p>
  </div>
  <div class="readable-text  intended-text" id="p254"> 
   <p>Then we have a button that increments the value of "number" each time it's clicked, and an <kbd>st.info</kbd> box to retrieve and display the value of number.</p>
  </div>
  <div class="readable-text  intended-text" id="p255"> 
   <p>Figure 4.16 shows the output after pressing the "Increment" button five times.</p>
  </div>
  <div class="browsable-container figure-container" id="p256">  
   <img src="../Images/04__image015.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.16 A toy Streamlit app using st.session_state to keep track of and increment a number</h5>
  </div>
  <div class="readable-text " id="p257"> 
   <p>If we hadn't used <kbd>st.session_state</kbd> here and had simply stored <kbd>number</kbd> in its own variable (or in a regular dictionary), it wouldn't have worked because the value (or the dictionary itself) would have gotten reset each time the app re-ran. <kbd>st.session_state</kbd> is the only thing that retains its state across re-runs of an app.</p>
  </div>
  <div class="readable-text  intended-text" id="p258"> 
   <p>Why do we need the initial check to see if "number" already exists in the session state before adding it? Well, without this, we'd run into the same problem as before. Each time the app runs, it would set <kbd>st.session_state.number</kbd> to zero, overriding whatever value it had been incremented to in the earlier run, and we'd never see the number actually change.</p>
  </div>
  <div class="readable-text  intended-text" id="p259"> 
   <p>By checking to see if "number" exists, we're ensuring that the line <kbd>st.session_state.number = 0</kbd> is only executed once—in the very first run when <kbd>"number"</kbd> hasn't been added yet.</p>
  </div>
  <div class="readable-text" id="p260"> 
   <h2 class=" readable-text-h2">4.5 Completing our app</h2>
  </div>
  <div class="readable-text " id="p261"> 
   <p>We now know how to give our app a "memory.” When you start writing Streamlit apps for your own purposes, you'll quickly realize that this knowledge is absolutely crucial—to the point that you couldn't write anything but the simplest apps without it.</p>
  </div>
  <div class="readable-text  intended-text" id="p262"> 
   <p>Armed with the powerful <kbd>st.session_state</kbd>, we're ready to take another crack at getting our to-do list app to work!</p>
  </div>
  <div class="readable-text" id="p263"> 
   <h3 class=" readable-text-h3">4.5.1 Adding session state</h3>
  </div>
  <div class="readable-text " id="p264"> 
   <p>When we last ran our app, our main problem was the fact that the <kbd>task_list</kbd> variable, which holds all our tasks, was getting reset with every re-run.</p>
  </div>
  <div class="readable-text  intended-text" id="p265"> 
   <p>Let's fix this by adding <kbd>task_list</kbd> to <kbd>st.session_state</kbd>. Replace the line <kbd>task_list = []</kbd> in your earlier code with this:</p>
  </div>
  <div class="browsable-container listing-container" id="p266"> 
   <div class="code-area-container"> 
    <pre class="code-area">if "task_list" not in st.session_state:
    st.session_state.task_list = []</pre>
   </div>
  </div>
  <div class="readable-text " id="p267"> 
   <p>This mirrors the toy example we walked through in the last section. The only difference is that we're storing <kbd>task_list</kbd> in <kbd>st.session_state</kbd> rather than a single number.</p>
  </div>
  <div class="readable-text  intended-text" id="p268"> 
   <p>We could now modify the rest of our code to reference <kbd>st.session_state.task_list </kbd>everywhere it's currently referencing <kbd>task_list</kbd>, but that seems tedious and rather clunky. Instead, let's just point the variable <kbd>task_list</kbd> to the version in <kbd>st.session_state</kbd> like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p269"> 
   <div class="code-area-container"> 
    <pre class="code-area">task_list = st.session_state.task_list</pre>
   </div>
  </div>
  <div class="readable-text " id="p270"> 
   <p>Now the rest of our code should work fine since they're referring to <kbd>task_list</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p271"> 
   <p>Listing 4.7 shows what our code should contain now.</p>
  </div>
  <div class="browsable-container listing-container" id="p272"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 4.7 todo_list.py with st.session_state</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
from task import Task
 
if "task_list" not in st.session_state:
    st.session_state.task_list = []
task_list = st.session_state.task_list
 
def add_task(task_name: str):
    task_list.append(Task(task_name))
 
def delete_task(idx: int):
    del task_list[idx]
 
def mark_done(task: Task):
    task.is_done = True
 
def mark_not_done(task: Task):
    task.is_done = False
 
with st.sidebar:
    task = st.text_input("Enter a task")
    if st.button("Add task", type="primary"):
        add_task(task)
 
st.header("Today's to-dos:", divider="gray")
st.info(f"task_list: {task_list}")
for idx, task in enumerate(task_list):
    task_col, delete_col = st.columns([0.8, 0.2])
    task_col.checkbox(task.name, task.is_done, key=f"task_{idx}")
    if delete_col.button("Delete", key=f"delete_{idx}"):
        pass</pre>
   </div>
  </div>
  <div class="readable-text " id="p273"> 
   <p>Save, re-run, and try adding multiple tasks. Figure 4.17 shows what you get when you do this.</p>
  </div>
  <div class="browsable-container figure-container" id="p274">  
   <img src="../Images/04__image016.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.17 With st.session_state, Streamlit remembers our old tasks</h5>
  </div>
  <div class="readable-text " id="p275"> 
   <p>And voila! <kbd>task_list</kbd> can finally be updated with multiple tasks, and our display logic shows everything.</p>
  </div>
  <div class="readable-text" id="p276"> 
   <h3 class=" readable-text-h3">4.5.2 Wiring up the "Delete" buttons</h3>
  </div>
  <div class="readable-text " id="p277"> 
   <p>With that in place, let's get our "Delete" buttons working. Recall that we had previously set them up to do nothing by writing <kbd>pass</kbd> under the code for the buttons within the display loop.</p>
  </div>
  <div class="browsable-container listing-container" id="p278"> 
   <div class="code-area-container"> 
    <pre class="code-area">if delete_col.button("Delete", key=f"delete_{idx}"):
    pass</pre>
   </div>
  </div>
  <div class="readable-text " id="p279"> 
   <p>Since then, we've created a <kbd>delete_task</kbd> function, so let's call that here instead:</p>
  </div>
  <div class="browsable-container listing-container" id="p280"> 
   <div class="code-area-container"> 
    <pre class="code-area">if delete_col.button("Delete", key=f"delete_{idx}"):
    delete_task(idx)</pre>
   </div>
  </div>
  <div class="readable-text " id="p281"> 
   <p>If we now click “Delete” next to “Buy Bread” after saving and re-running (and adding the three tasks back in order if you refreshed the page), we see... no changes! If we click the button a second time, however, the task disappears. Something still isn’t right.</p>
  </div>
  <div class="readable-text  intended-text" id="p282"> 
   <p>I won't detail all of it with screenshots, but if you play around with the app at this point, you'll notice more odd behavior. The first time you click the "Delete" button against the last task in the list, it doesn't do anything. But if you then immediately click a checkbox (<em>any </em>checkbox), the task disappears.</p>
  </div>
  <div class="readable-text  intended-text" id="p283"> 
   <p>Or if you delete a task from the middle of the list, the <em>next</em> one disappears, not the one you deleted! But if you <em>then</em> do something else, like clicking a checkbox or adding another task, that task comes back and the one you actually deleted is correctly removed and everything is the way it should be.</p>
  </div>
  <div class="readable-text  intended-text" id="p284"> 
   <p>All in all, there seems to be a <em>lag</em> between when you actually click the "Delete" button and when the task is removed. You seem to need to do something else (anything else, like clicking one of the checkboxes, or editing the text in the task entry textbox and clicking outside) <em>after </em>clicking the button for the correct results to be displayed.</p>
  </div>
  <div class="readable-text" id="p285"> 
   <h3 class=" readable-text-h3">4.5.3 What's happening behind the scenes</h3>
  </div>
  <div class="readable-text " id="p286"> 
   <p>To understand what's going on, we need to do a deep-dive into our app's execution once again. Let's assume we're at the stage in the app where the user has entered three tasks in order: "Clean garage.” "Finalize project proposal.” and "Buy bread.”</p>
  </div>
  <div class="readable-text  intended-text" id="p287"> 
   <p>At this point, <kbd>task_list</kbd> has been populated with these three tasks.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p288"> 
   <h4 class=" readable-text-h4">Stepping through the app's execution</h4>
  </div>
  <div class="readable-text " id="p289"> 
   <p>Let's say the user tries to delete the third task. Figure 4.18 shows diagrammatically what happens in the app. The delete buttons are identified by the Streamlit widget keys assigned to them, i.e., <kbd>delete_0</kbd>, <kbd>delete_1</kbd>, etc.</p>
  </div>
  <div class="browsable-container figure-container" id="p290">  
   <img src="../Images/04__image017.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.18 Step-by-step app execution: the delete button evaluates to True in the second run, but the task and button are displayed <em>before</em> delete_task is called</h5>
  </div>
  <div class="readable-text " id="p291"> 
   <p>The first run is the one that happens before the button is clicked. Streamlit simply loops through our task list, displaying each task along with its checkbox and delete button. As we discussed earlier in the chapter, each <kbd>st.button</kbd> evaluates to <kbd>False</kbd>, since none of them have been pressed yet.</p>
  </div>
  <div class="readable-text  intended-text" id="p292"> 
   <p>When the user clicks the delete button for "Buy bread.” it triggers a re-run of the app. Everything remains the same until after we have displayed the third task's <kbd>st.button</kbd>. This time, this button evaluates to <kbd>True</kbd> since it was just clicked. As the condition is true, the app enters the code nested under <kbd>st.button</kbd>, <kbd>delete_task(idx)</kbd>. Since <kbd>idx</kbd> is 2 in this iteration of the loop, <kbd>delete_task(2)</kbd> is called, and "Buy bread" is removed from <kbd>task_list</kbd>. Execution stops at this point.</p>
  </div>
  <div class="readable-text  intended-text" id="p293"> 
   <p>See the problem? All three buttons had <em>already</em> been displayed <em>before</em> <kbd>delete_task</kbd> was executed, updating <kbd>task_list</kbd>. And since there are no other user actions, no more re-runs are triggered. So <kbd>task_list</kbd> is updated all right, but the display logic has already been executed on the old version of <kbd>task_list</kbd>. That's why we still see the three tasks after clicking "Delete.”</p>
  </div>
  <div class="readable-text  intended-text" id="p294"> 
   <p>But at this point, if the user does something else, like clicking a checkbox or even clicking the "Delete" button again, it triggers another re-run. This time, the display logic runs over the latest version of <kbd>task_list</kbd>, so we finally see the third task and its checkbox and delete button removed.</p>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p295"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p296"> 
    <p>Stepping through the execution like this can also explain the other odd behavior we noticed, such as when you click the delete button for a task in the middle of the list, and the <em>next</em> task disappears. This happens because when delete_task is called, the list indices all get moved up by one, and the next display loop iteration ends up skipping a task because its index changed.</p>
   </div>
  </div>
  <div class="readable-text" id="p297"> 
   <h3 class=" readable-text-h3">4.5.4 Triggering re-runs automatically</h3>
  </div>
  <div class="readable-text " id="p298"> 
   <p>As we've seen, though our delete button doesn't work correctly immediately, Streamlit does get the results right eventually, provided the user takes an extra action, triggering a re-run.</p>
  </div>
  <div class="readable-text  intended-text" id="p299"> 
   <p>We can use this knowledge to our advantage. All we need is a way to trigger a re-run of the app through code, rather than through a user action. Streamlit offers this functionality through <kbd>st.rerun</kbd>, and you can call it at any time without any arguments, like so:</p>
  </div>
  <div class="browsable-container listing-container" id="p300"> 
   <div class="code-area-container"> 
    <pre class="code-area">st.rerun()</pre>
   </div>
  </div>
  <div class="readable-text " id="p301"> 
   <p>When you call <kbd>st.rerun</kbd>, you're essentially telling Streamlit, "Quit the current run and start again from the top."</p>
  </div>
  <div class="readable-text  intended-text" id="p302"> 
   <p>In our case, we should trigger the re-run once a task has been deleted:</p>
  </div>
  <div class="browsable-container listing-container" id="p303"> 
   <div class="code-area-container"> 
    <pre class="code-area">if delete_col.button("Delete", key=f"delete_{idx}"):
    delete_task(idx)
    st.rerun()</pre>
   </div>
  </div>
  <div class="readable-text " id="p304"> 
   <p>If you make this change, re-run and recreate the tasks as before, and try deleting "Buy bread" again, you'll see the output in figure 4.19.</p>
  </div>
  <div class="browsable-container figure-container" id="p305">  
   <img src="../Images/04__image018.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.19 Pressing "Delete" works as expected with st.rerun</h5>
  </div>
  <div class="readable-text " id="p306"> 
   <p>It worked! "Buy bread" is no more, and it's also missing from <kbd>task_list</kbd> as you can see from the <kbd>st.info</kbd> box in the screenshot.</p>
  </div>
  <div class="readable-text" id="p307"> 
   <h3 class=" readable-text-h3">4.5.5 Wiring up the checkboxes</h3>
  </div>
  <div class="readable-text " id="p308"> 
   <p>Let's move on to the next part of our app: the checkboxes. We've added them in the display and you can check them, but they don't actually do anything. Our next step, then, is to hook them up to the functionality we've defined for changing the status of a task.</p>
  </div>
  <div class="readable-text  intended-text" id="p309"> 
   <p>Our current checkbox code is a single line:</p>
  </div>
  <div class="browsable-container listing-container" id="p310"> 
   <div class="code-area-container"> 
    <pre class="code-area">task_col.checkbox(task.name, task.is_done, key=f"task_{idx}")</pre>
   </div>
  </div>
  <div class="readable-text " id="p311"> 
   <p>When the user checks a task checkbox, we want to achieve two things:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p312">Mark the task as done, and</li>
   <li class="readable-text" id="p313">Strike it through</li>
  </ul>
  <div class="readable-text " id="p314"> 
   <p>We also want to reverse the above changes if the user unchecks a box.</p>
  </div>
  <div class="readable-text  intended-text" id="p315"> 
   <p>To change the task's status, we can use the functions we created earlier for the purpose, <kbd>mark_done</kbd> and <kbd>mark_not_done</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p316"> 
   <p>How do we achieve the strikethrough? For this formatting effect (and several others), Streamlit supports a language called <em>markdown</em>.</p>
  </div>
  <div class="readable-text  intended-text" id="p317"> 
   <p>Markdown is a special text-based notation to add various kinds of formatting. It has ways to display text in bold or italic, to create links, lists, headings, and much more. We'll encounter these in later chapters, but for now let's focus on the strikethrough effect.</p>
  </div>
  <div class="readable-text  intended-text" id="p318"> 
   <p>To strike a piece of text through in markdown, you surround it with two pairs of tildes, like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p319"> 
   <div class="code-area-container"> 
    <pre class="code-area">~~Text to be struck through~~</pre>
   </div>
  </div>
  <div class="readable-text " id="p320"> 
   <p>This plugs into our checkbox through the label parameter, which supports markdown. We'll define a variable that contains the name of a task by itself if the task has not been done, and the name with a markdown strikethrough if it does:</p>
  </div>
  <div class="browsable-container listing-container" id="p321"> 
   <div class="code-area-container"> 
    <pre class="code-area">label = f"~~{task.name}~~" if task.is_done else task.name</pre>
   </div>
  </div>
  <div class="readable-text " id="p322"> 
   <p>We can then feed it into our checkbox:</p>
  </div>
  <div class="browsable-container listing-container" id="p323"> 
   <div class="code-area-container"> 
    <pre class="code-area">task_col.checkbox(label, task.is_done, key=f"task_{idx}")</pre>
   </div>
  </div>
  <div class="readable-text " id="p324"> 
   <p>Finally, let's also wire up our checkboxes to our <kbd>mark_*</kbd> functions. We want to call <kbd>mark_done</kbd> if the checkbox is checked, or <kbd>mark_not_done</kbd> otherwise. Our overall code should now be as shown in listing 4.8.</p>
  </div>
  <div class="browsable-container listing-container" id="p325"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 4.8 todo_list.py after wiring up the task checkboxes</h5>
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">import streamlit as st
from task import Task
 
if "task_list" not in st.session_state:
    st.session_state.task_list = []
task_list = st.session_state.task_list
 
def add_task(task_name: str):
    task_list.append(Task(task_name))
 
def delete_task(idx: int):
    del task_list[idx]
 
def mark_done(task: Task):
    task.is_done = True
 
def mark_not_done(task: Task):
    task.is_done = False
 
with st.sidebar:
    task = st.text_input("Enter a task")
    if st.button("Add task", type="primary"):
        add_task(task)
 
st.header("Today's to-dos:", divider="gray")
st.info(f"task_list: {task_list}")
for idx, task in enumerate(task_list):
    task_col, delete_col = st.columns([0.8, 0.2])
    <b>label = f"~~{task.name}~~" if task.is_done else task.name    </b>#A<b></b>
<b>    if task_col.checkbox(label, task.is_done, key=f"task_{idx}"):</b>
<b>        mark_done(task)    </b>#B<b></b>
<b>    else:</b>
<b>        mark_not_done(task)    </b>#C<b></b>
    if delete_col.button("Delete", key=f"delete_{idx}"):
        delete_task(idx)
        st.rerun()</pre>
    <div class="code-annotations-overlay-container">
     #A Add a strikethrough effect to the label if the task is done
     <br/>#B Call mark_done if the checkbox happens to be checked and therefore evaluates to True
     <br/>#C Call mark_not_done if the checkbox is not checked
     <br/>
    </div>
   </div>
  </div>
  <div class="readable-text " id="p326"> 
   <p>Save, re-run, and add your tasks back, then check one of the tasks to get results similar to what's shown in figure 4.20.</p>
  </div>
  <div class="browsable-container figure-container" id="p327">  
   <img src="../Images/04__image019.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.20 Checking a task doesn't immediately work as expected</h5>
  </div>
  <div class="readable-text " id="p328"> 
   <p>Once again, we didn't get the results we expected. "Clean garage" remains unstruck, and our info box shows that <kbd>task_list</kbd> hasn't changed. Before you throw your computer out the window and dedicate the rest of your existence to sheep-farming, try checking off another task.</p>
  </div>
  <div class="readable-text  intended-text" id="p329"> 
   <p>You'll see that now the original task we checked has its strikethrough, and its <kbd>is_done</kbd> field is <kbd>True</kbd> as per our <kbd>st.info</kbd> box.</p>
  </div>
  <div class="readable-text  intended-text" id="p330"> 
   <p>Sound familiar? Looks like there's a lag of one user action between when we click a checkbox and when the result of that action shows up.</p>
  </div>
  <div class="readable-text  intended-text" id="p331"> 
   <p>What's going on here is very similar to what we saw in the case of the delete button. Clicking the checkbox does trigger our function and sets <kbd>is_done</kbd> to <kbd>True</kbd>, but by that point, the task and its label have already been displayed. Only in the <em>next</em> re-run is the <em>actual display</em> updated, and that re-run is only triggered when the user takes a further action.</p>
  </div>
  <div class="readable-text  intended-text" id="p332"> 
   <p>The solution to this is the same as before: we can trigger a manual re-run each time one of our <kbd>mark_*</kbd> functions runs:</p>
  </div>
  <div class="browsable-container listing-container" id="p333"> 
   <div class="code-area-container"> 
    <pre class="code-area">if task_col.checkbox(label, task.is_done, key=f"task_{idx}"):
    mark_done(task)
    st.rerun()
else:
    mark_not_done(task)
    st.rerun()</pre>
   </div>
  </div>
  <div class="readable-text " id="p334"> 
   <p>Save the output, refresh the page, and let's try again. Figure 4.21 shows the output.</p>
  </div>
  <div class="browsable-container figure-container" id="p335">  
   <img src="../Images/04__image020.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.21 Our app hangs and never stops loading</h5>
  </div>
  <div class="readable-text " id="p336"> 
   <p>Something's very wrong here. Our app seems to stop responding entirely once we add our first task. The screen's grayed out, and there's the "RUNNING…" indicator at the top.</p>
  </div>
  <div class="readable-text" id="p337"> 
   <h3 class=" readable-text-h3">4.5.6 An infinite re-run loop</h3>
  </div>
  <div class="readable-text " id="p338"> 
   <p>You've just encountered your first Streamlit infinite re-run loop. Let's try to understand what went wrong by stepping through the execution one more time. Figure 4.22 shows this in a diagram.</p>
  </div>
  <div class="browsable-container figure-container" id="p339">  
   <img src="../Images/04__image021.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.22 Step-by-step app execution: A chain of st.reruns leads to an infinite loop</h5>
  </div>
  <div class="readable-text " id="p340"> 
   <p>Once we've added our "Clean garage" task, <kbd>task_list</kbd> contains a single <kbd>Task</kbd> instance with its <kbd>is_done</kbd> field set to <kbd>False</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p341"> 
   <p>Since <kbd>task_list</kbd> is non-empty, we enter the display loop, and the checkbox for "Clean garage" is displayed.</p>
  </div>
  <div class="readable-text  intended-text" id="p342"> 
   <p>Now our task has branching logic:</p>
  </div>
  <div class="browsable-container listing-container" id="p343"> 
   <div class="code-area-container"> 
    <pre class="code-area">if task_col.checkbox(label, task.is_done, key=f"task_{idx}"):
    mark_done(task)
    st.rerun()
else:
    mark_not_done(task)
    st.rerun()</pre>
   </div>
  </div>
  <div class="readable-text " id="p344"> 
   <p>The checkbox evaluates to <kbd>False</kbd> since it's not checked, which means the app enters the <kbd>else</kbd> clause.</p>
  </div>
  <div class="readable-text  intended-text" id="p345"> 
   <p><kbd>mark_not_done</kbd> is called, which sets <kbd>is_done</kbd> to <kbd>False</kbd> (even though it's already <kbd>False</kbd>), and then <kbd>st.rerun()</kbd> forces Streamit to stop the current run and start again from the top.</p>
  </div>
  <div class="readable-text  intended-text" id="p346"> 
   <p>Once again, in the second run, we enter the loop. The checkbox is still not checked, so <kbd>mark_not_done</kbd> is called again, and <kbd>st.rerun()</kbd> after that, which begins a third run, and so on and on.</p>
  </div>
  <div class="readable-text  intended-text" id="p347"> 
   <p>Since this never stops, Streamlit chokes and stops responding.</p>
  </div>
  <div class="readable-text" id="p348"> 
   <h3 class=" readable-text-h3">4.5.7 Preventing the infinite re-run</h3>
  </div>
  <div class="readable-text " id="p349"> 
   <p>The trouble here is that <kbd>mark_done</kbd> is getting called even when there's no need for it. Reviewing the execution steps we saw just now, you'll notice that the "Clean garage" task's <kbd>is_done</kbd> field was already set to <kbd>False</kbd>, so there was no actual need to call <kbd>mark_not_done</kbd> again.</p>
  </div>
  <div class="readable-text  intended-text" id="p350"> 
   <p>The way our code is set up right now, once we enter our display for-loop, there's no exiting it. If our checkbox evaluates to <kbd>True</kbd>,<kbd> st.rerun()</kbd> is called after the <kbd>mark_done</kbd> function. If it evaluates to <kbd>False</kbd>, <kbd>st.rerun()</kbd> is called after the <kbd>mark_not_done</kbd> function.</p>
  </div>
  <div class="readable-text  intended-text" id="p351"> 
   <p>We need to make sure that this only happens when it absolutely needs to. <kbd>mark_done</kbd> (and the associated <kbd>st.rerun</kbd>) should only be called if the checkbox is checked <em>and </em>the task is not already marked as "done.” Similarly, <kbd>mark_not_done</kbd> and <em>its</em> <kbd>st.rerun</kbd> should only be called if the checkbox is not checked and the task is currently marked as "done.”</p>
  </div>
  <div class="readable-text  intended-text" id="p352"> 
   <p>We can make this happen by editing our code like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p353"> 
   <div class="code-area-container"> 
    <pre class="code-area">checked = task_col.checkbox(label, task.is_done, key=f"task_{idx}")    #A
if checked and not task.is_done:    #B
    mark_done(task)
    st.rerun()
elif not checked and task.is_done:    #C
    mark_not_done(task)
    st.rerun()</pre>
    <div class="code-annotations-overlay-container">
     #A Save the checkbox's value in a new variable called checked, for readability.
     <br/>#B Only call mark_done if the checkbox is checked AND the task is not yet marked as done.
     <br/>#C Only call mark_not_done if the checkbox is not checked AND the task is still marked as done.
     <br/>
    </div>
   </div>
  </div>
  <div class="readable-text " id="p354"> 
   <p>This way, when the checkbox is checked, the task's status is set to <kbd>is_done</kbd>, but in the next re-run, both the if and elif clauses evaluate to <kbd>False</kbd>, and <kbd>st.rerun</kbd> never executes.</p>
  </div>
  <div class="readable-text  intended-text" id="p355"> 
   <p>Go ahead and try it out. Our checkboxes should now be working correctly, as shown in figure 4.23.</p>
  </div>
  <div class="browsable-container figure-container" id="p356">  
   <img src="../Images/04__image022.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.23 Our checkboxes now work as expected</h5>
  </div>
  <div class="readable-text" id="p357"> 
   <h3 class=" readable-text-h3">4.5.8 Adding the completion progress indicator</h3>
  </div>
  <div class="readable-text " id="p358"> 
   <p>We're <em>almost</em> done with our app. The only thing that remains from our earlier mock design is to add a progress indicator to give the user that extra sense of accomplishment.</p>
  </div>
  <div class="readable-text  intended-text" id="p359"> 
   <p>This is quite straightforward. We want the indicator to be nice and large, so <kbd>st.metric</kbd>, which we encountered first in Chapter 3, seems ideal.</p>
  </div>
  <div class="readable-text  intended-text" id="p360"> 
   <p>We'll need to show two things: the total number of tasks, and the number of completed tasks, both of which we can get from <kbd>task_list</kbd>. Our code for <kbd>st.metric</kbd> could look like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p361"> 
   <div class="code-area-container"> 
    <pre class="code-area">total_tasks = len(task_list)
completed_tasks = sum(1 for task in task_list if task.is_done)
metric_display = f"{completed_tasks}/{total_tasks} done"
st.metric("Task completion", metric_display, delta=None)</pre>
   </div>
  </div>
  <div class="readable-text " id="p362"> 
   <p>To get <kbd>completed_tasks</kbd>, we use a list comprehension (you can skip the square brackets when it's wrapped in a function like sum) for conciseness.</p>
  </div>
  <div class="readable-text  intended-text" id="p363"> 
   <p>Oh, and we can probably get rid of our info box (<kbd>st.info</kbd>) since we're no longer in troubleshooting mode.</p>
  </div>
  <div class="readable-text  intended-text" id="p364"> 
   <p>Our final code should look like what's shown in Listing 4.9.</p>
  </div>
  <div class="browsable-container listing-container" id="p365"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 4.9 The final version of todo_list.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
from task import Task
 
if "task_list" not in st.session_state:
    st.session_state.task_list = []
task_list = st.session_state.task_list
 
def add_task(task_name: str):
    task_list.append(Task(task_name))
 
def delete_task(idx: int):
    del task_list[idx]
 
def mark_done(task: Task):
    task.is_done = True
 
def mark_not_done(task: Task):
    task.is_done = False
 
with st.sidebar:
    task = st.text_input("Enter a task")
    if st.button("Add task", type="primary"):
        add_task(task)
 
total_tasks = len(task_list)
completed_tasks = sum(1 for task in task_list if task.is_done)
metric_display = f"{completed_tasks}/{total_tasks} done"
st.metric("Task completion", metric_display, delta=None)
 
st.header("Today's to-dos:", divider="gray")
for idx, task in enumerate(task_list):
    task_col, delete_col = st.columns([0.8, 0.2])
    label = f"~~{task.name}~~" if task.is_done else task.name
    checked = task_col.checkbox(label, task.is_done, key=f"task_{idx}")
    if checked and not task.is_done:
        mark_done(task)
        st.rerun()
    elif not checked and task.is_done:
        mark_not_done(task)
        st.rerun()
    if delete_col.button("Delete", key=f"delete_{idx}"):
        delete_task(idx)
        st.rerun()
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p366"> 
   <p>Figure 4.24 provides a final glance at our app in all its glory.</p>
  </div>
  <div class="browsable-container figure-container" id="p367">  
   <img src="../Images/04__image023.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 4.24 The final to-do list app</h5>
  </div>
  <div class="readable-text " id="p368"> 
   <p>With that, you have another full app under your belt, and maybe even a tool you can use every day to stay productive! You're now already in a position to start using Streamlit in your own projects. In the next chapter, we'll see how to publish them for other people to use.</p>
  </div>
  <div class="readable-text" id="p369"> 
   <h2 class=" readable-text-h2">4.6 Summary</h2>
  </div>
  <ul> 
   <li class="readable-text" id="p370">In the real world, the development process is not smooth; much of your time will be spent troubleshooting things that don't work as expected.</li>
   <li class="readable-text" id="p371"><kbd>st.header</kbd> is used to display headings in large font.</li>
   <li class="readable-text" id="p372">Streamlit identifies UI widgets using a unique widget key based on its characteristics.</li>
   <li class="readable-text" id="p373">When two widgets are identical in every respect, you have to specify a widget key manually to enable Streamlit to tell them apart.</li>
   <li class="readable-text" id="p374">A good way to keep track of the values of variables as the app executes is to display them on the app's screen using <kbd>st.info</kbd>.</li>
   <li class="readable-text" id="p375">Whenever the page needs to change, the Streamlit server re-runs your Python code from top to bottom.</li>
   <li class="readable-text" id="p376">Re-runs reset all the regular variables in your app.</li>
   <li class="readable-text" id="p377"><kbd>st.session_state</kbd> is used to store variables that you want Streamlit to remember between re-runs.</li>
   <li class="readable-text" id="p378">It's a good idea to step through the app's execution when you see unexpected results.</li>
   <li class="readable-text" id="p379">You can trigger a re-run of your app using <kbd>st.rerun.</kbd></li>
   <li class="readable-text" id="p380">While using <kbd>st.rerun</kbd>, your app may end up in an infinite re-run loop if you don't provide a path for your script to exit.</li>
  </ul>
</body>
</html>