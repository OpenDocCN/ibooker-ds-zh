- en: Chapter 13\. Introducing Pandas Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At a very basic level, Pandas objects can be thought of as enhanced versions
    of NumPy structured arrays in which the rows and columns are identified with labels
    rather than simple integer indices. As we will see during the course of this chapter,
    Pandas provides a host of useful tools, methods, and functionality on top of the
    basic data structures, but nearly everything that follows will require an understanding
    of what these structures are. Thus, before we go any further, let’s take a look
    at these three fundamental Pandas data structures: the `Series`, `DataFrame`,
    and `Index`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start our code sessions with the standard NumPy and Pandas imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Pandas Series Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Pandas `Series` is a one-dimensional array of indexed data. It can be created
    from a list or array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Series` combines a sequence of values with an explicit sequence of indices,
    which we can access with the `values` and `index` attributes. The `values` are
    simply a familiar NumPy array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `index` is an array-like object of type `pd.Index`, which we’ll discuss
    in more detail momentarily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Like with a NumPy array, data can be accessed by the associated index via the
    familiar Python square-bracket notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we will see, though, the Pandas `Series` is much more general and flexible
    than the one-dimensional NumPy array that it emulates.
  prefs: []
  type: TYPE_NORMAL
- en: Series as Generalized NumPy Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From what we’ve seen so far, the `Series` object may appear to be basically
    interchangeable with a one-dimensional NumPy array. The essential difference is
    that while the NumPy array has an *implicitly defined* integer index used to access
    the values, the Pandas `Series` has an *explicitly defined* index associated with
    the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'This explicit index definition gives the `Series` object additional capabilities.
    For example, the index need not be an integer, but can consist of values of any
    desired type. So, if we wish, we can use strings as an index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And the item access works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even use noncontiguous or nonsequential indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Series as Specialized Dictionary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this way, you can think of a Pandas `Series` a bit like a specialization
    of a Python dictionary. A dictionary is a structure that maps arbitrary keys to
    a set of arbitrary values, and a `Series` is a structure that maps typed keys
    to a set of typed values. This typing is important: just as the type-specific
    compiled code behind a NumPy array makes it more efficient than a Python list
    for certain operations, the type information of a Pandas `Series` makes it more
    efficient than Python dictionaries for certain operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Series`-as-dictionary analogy can be made even more clear by constructing
    a `Series` object directly from a Python dictionary, here the five most populous
    US states according to the 2020 census:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, typical dictionary-style item access can be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike a dictionary, though, the `Series` also supports array-style operations
    such as slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We’ll discuss some of the quirks of Pandas indexing and slicing in [Chapter 14](ch14.xhtml#section-0302-data-indexing-and-selection).
  prefs: []
  type: TYPE_NORMAL
- en: Constructing Series Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve already seen a few ways of constructing a Pandas `Series` from scratch.
    All of them are some version of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: where `index` is an optional argument, and `data` can be one of many entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `data` can be a list or NumPy array, in which case `index` defaults
    to an integer sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Or `data` can be a scalar, which is repeated to fill the specified index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Or it can be a dictionary, in which case `index` defaults to the dictionary
    keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In each case, the index can be explicitly set to control the order or the subset
    of keys used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The Pandas DataFrame Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next fundamental structure in Pandas is the `DataFrame`. Like the `Series`
    object discussed in the previous section, the `DataFrame` can be thought of either
    as a generalization of a NumPy array, or as a specialization of a Python dictionary.
    We’ll now take a look at each of these perspectives.
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame as Generalized NumPy Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a `Series` is an analog of a one-dimensional array with explicit indices,
    a `DataFrame` is an analog of a two-dimensional array with explicit row and column
    indices. Just as you might think of a two-dimensional array as an ordered sequence
    of aligned one-dimensional columns, you can think of a `DataFrame` as a sequence
    of aligned `Series` objects. Here, by “aligned” we mean that they share the same
    index.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, let’s first construct a new `Series` listing the area
    of each of the five states discussed in the previous section (in square kilometers):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have this along with the `population` Series from before, we can
    use a dictionary to construct a single two-dimensional object containing this
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the `Series` object, the `DataFrame` has an `index` attribute that gives
    access to the index labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, the `DataFrame` has a `columns` attribute, which is an `Index`
    object holding the column labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Thus the `DataFrame` can be thought of as a generalization of a two-dimensional
    NumPy array, where both the rows and columns have a generalized index for accessing
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame as Specialized Dictionary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarly, we can also think of a `DataFrame` as a specialization of a dictionary.
    Where a dictionary maps a key to a value, a `DataFrame` maps a column name to
    a `Series` of column data. For example, asking for the `''area''` attribute returns
    the `Series` object containing the areas we saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the potential point of confusion here: in a two-dimensional NumPy array,
    `data[0]` will return the first *row*. For a `DataFrame`, `data[''col0'']` will
    return the first *column*. Because of this, it is probably better to think about
    `DataFrame`s as generalized dictionaries rather than generalized arrays, though
    both ways of looking at the situation can be useful. We’ll explore more flexible
    means of indexing `DataFrame`s in [Chapter 14](ch14.xhtml#section-0302-data-indexing-and-selection).'
  prefs: []
  type: TYPE_NORMAL
- en: Constructing DataFrame Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Pandas `DataFrame` can be constructed in a variety of ways. Here we’ll explore
    several examples.
  prefs: []
  type: TYPE_NORMAL
- en: From a single Series object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `DataFrame` is a collection of `Series` objects, and a single-column `DataFrame`
    can be constructed from a single `Series`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: From a list of dicts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Any list of dictionaries can be made into a `DataFrame`. We’ll use a simple
    list comprehension to create some data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if some keys in the dictionary are missing, Pandas will fill them in with
    `NaN` values (i.e., “Not a Number”; see [Chapter 16](ch16.xhtml#section-0304-missing-values)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: From a dictionary of Series objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we saw before, a `DataFrame` can be constructed from a dictionary of `Series`
    objects as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: From a two-dimensional NumPy array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Given a two-dimensional array of data, we can create a `DataFrame` with any
    specified column and index names. If omitted, an integer index will be used for
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: From a NumPy structured array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We covered structured arrays in [Chapter 12](ch12.xhtml#section-0209-structured-data-numpy).
    A Pandas `DataFrame` operates much like a structured array, and can be created
    directly from one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The Pandas Index Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you’ve seen, the `Series` and `DataFrame` objects both contain an explicit
    *index* that lets you reference and modify data. This `Index` object is an interesting
    structure in itself, and it can be thought of either as an *immutable array* or
    as an *ordered set* (technically a multiset, as `Index` objects may contain repeated
    values). Those views have some interesting consequences in terms of the operations
    available on `Index` objects. As a simple example, let’s construct an `Index`
    from a list of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Index as Immutable Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Index` in many ways operates like an array. For example, we can use standard
    Python indexing notation to retrieve values or slices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`Index` objects also have many of the attributes familiar from NumPy arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'One difference between `Index` objects and NumPy arrays is that the indices
    are immutable—that is, they cannot be modified via the normal means:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This immutability makes it safer to share indices between multiple `DataFrame`s
    and arrays, without the potential for side effects from inadvertent index modification.
  prefs: []
  type: TYPE_NORMAL
- en: Index as Ordered Set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pandas objects are designed to facilitate operations such as joins across datasets,
    which depend on many aspects of set arithmetic. The `Index` object follows many
    of the conventions used by Python’s built-in `set` data structure, so that unions,
    intersections, differences, and other combinations can be computed in a familiar
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
