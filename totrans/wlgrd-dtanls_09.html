<html><head></head><body>
<div id="sbo-rt-content"><div class="readable-text" id="p1">
<h1 class="readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">10</span></span> <span class="chapter-title-text">Rapid prototyping: Data analysis</span></h1>
</div>
<div class="introduction-summary">
<h3 class="introduction-header sigil_not_in_toc">This chapter covers</h3>
<ul>
<li class="readable-text" id="p2">Prototyping ideas quickly to support a business case</li>
<li class="readable-text" id="p3">Exploring a dataset to build a proof of concept</li>
</ul>
</div>
<div class="readable-text" id="p4">
<p>Sometimes, data analysis is about investigating whether an idea is viable. For example, is the available data good enough for the business to build a data-driven app? We can answer questions like this one by analyzing the data, but it would be even more powerful if we could build a working <em>proof of concept</em>. By doing this, we make the idea come to life for our stakeholders. Crucially, we also discover any obstacles to using the data for this purpose.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p5">
<h5 class="callout-container-h5 readable-text-h5 sigil_not_in_toc">Real business case: Building a proof of concept</h5>
</div>
<div class="readable-text" id="p6">
<p>This chapter was inspired by one of the first projects I delivered as a data scientist. The data team was tasked with creating a revenue-generating product. The idea was an app that lets someone enter a vehicle’s registration and display the current market conditions for that vehicle and vehicles similar to it. Defining what made a vehicle similar enough was the hard part, and that was the data-driven secret sauce behind the product. Once we’d established some rules, I built a quick proof of concept to show stakeholders that the idea worked. Building this proof of concept also meant I could communicate the specific challenges of building the product for real, which I knew because I had actually tried to make it work with the available data and systems.</p>
</div>
</div>
<div class="readable-text intended-text" id="p7">
<p>In this project, spanning this chapter and the next, we practice the skill of <em>rapid prototyping</em> by exploring a new dataset and building a proof of concept.</p>
</div>
<div class="readable-text" id="p8">
<h2 class="readable-text-h2" id="sigil_toc_id_122"><span class="num-string">10.1</span> The rapid prototyping process</h2>
</div>
<div class="readable-text" id="p9">
<p>Data teams often sit in an R&amp;D function or are expected to do R&amp;D as part of their job. This means they don’t just analyze data to answer questions but sometimes build things that don’t currently exist in the company. A valuable and often overlooked skill for an analyst is to be able to put something functional together to investigate the feasibility of an idea. This something is often called a <em>proof of concept</em> (POC), a <em>prototype</em>, or a <em>minimum viable product</em> (MVP), although an MVP is often even further along than a prototype.</p>
</div>
<div class="readable-text print-book-callout" id="p10">
<p><span class="print-book-callout-head">Note</span>  Terminology in this area tends to vary. In this chapter, I will be using specific definitions of “proof of concept” and “prototype.” The project task will be to build a proof of concept, but in the chapter title, the more general process of building something to test an idea is called “rapid prototyping.”</p>
</div>
<div class="readable-text" id="p11">
<p>Although these terms tend to be used interchangeably, they are subtly different:</p>
</div>
<ul>
<li class="readable-text" id="p12"> A proof of concept is something that tests an idea. It doesn’t have to be a polished product; it just needs to be complex enough to see whether an idea is feasible. </li>
<li class="readable-text" id="p13"> A prototype evolves from a proof of concept. Once an idea has been tested, we can build a small, usable product based on the proof of concept with real data. It won’t be finished, it can live in a development environment like someone’s laptop, and it won’t have the features of fully functioning software, but it is in a state that mimics a finished product. </li>
<li class="readable-text" id="p14"> Once a prototype exists and has been presented to stakeholders, there might be a step where an MVP is created. An MVP is a pilot launch to get the product out into the hands of real users as soon as possible. It might be missing some features, but it’s in a production environment, and rigor has been applied to ensure it works correctly. </li>
<li class="readable-text" id="p15"> Whether we are talking about an app, a website, or a machine learning model, there will be a notion of putting it into production. Production means it is working and people are using it, whether they are internal users or external customers. Reaching the MVP stage counts as putting something into production. </li>
</ul>
<div class="readable-text" id="p16">
<p>Figure 10.1 shows an example of this process, including the fact that an idea can be abandoned at any of the stages from initial ideation to after a working prototype is built.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p17">
<img alt="figure" height="199" src="../Images/10-1.png" width="907"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.1</span> The path from an idea to production and the steps in between</h5>
</div>
<div class="readable-text" id="p18">
<p>Let’s see a concrete example.</p>
</div>
<div class="readable-text" id="p19">
<h3 class="readable-text-h3" id="sigil_toc_id_123"><span class="num-string">10.1.1</span> Rapid prototyping example</h3>
</div>
<div class="readable-text" id="p20">
<p>Suppose your stakeholders want to know which customers are likely to churn from their e-commerce platform. In other words, which customers are likely to stop using the service? They want to see a list of at-risk customers in some kind of tool or dashboard, like an “early warning system,” so they can take action and prevent those users from churning.</p>
</div>
<div class="readable-text intended-text" id="p21">
<p>As an analyst, you might build a model to predict users who are at risk of churning and then incorporate that into such an interactive tool. Table 10.1 shows the three stages of this product’s lifecycle.</p>
</div>
<div class="browsable-container browsable-table-container framemaker-table-container" id="p22">
<h5 class="browsable-container-h5 sigil_not_in_toc"><span class="num-string">Table 10.1</span> An example walkthrough of the three stages</h5>
<table>
<thead>
<tr>
<th>
<div>
         Stage 
       </div></th>
<th>
<div>
         Task 
       </div></th>
<th>
<div>
         Success criteria 
       </div></th>
<th>
<div>
         Possible reasons to abandon at this stage 
       </div></th>
</tr>
</thead>
<tbody>
<tr>
<td>  1) Proof of concept <br/></td>
<td>  Build a basic predictive model. <br/></td>
<td>  • Basic model built to an acceptable level of accuracy. <br/>  • Available data is sufficient to build a model. <br/></td>
<td>  • Available data is insufficient for even a basic churn model. <br/></td>
</tr>
<tr>
<td>  2) Prototype <br/></td>
<td>  Build a working interactive tool. <br/></td>
<td>  • Users can use the tool to take preventative measures to keep at-risk customers. <br/>  • Predictions can be made in a timely manner. <br/></td>
<td>  • Data required for predictions not available at prediction time. <br/>  • No market for the product. <br/></td>
</tr>
<tr>
<td>  3) Production <br/></td>
<td>  Build the tool as fully functioning software with a working data pipeline. <br/></td>
<td>  • Preventative measures have a tangible financial effect. <br/></td>
<td>  • Insufficient return on investment. <br/>  • Low usage of the tool. <br/></td>
</tr>
</tbody>
</table>
</div>
<div class="readable-text" id="p23">
<p>Why is a proof of concept so important at the start? We want to understand the following as quickly as possible:</p>
</div>
<ul>
<li class="readable-text" id="p24"> Do we have the data to answer the question, build the predictive model, and create our app? </li>
<li class="readable-text" id="p25"> Will we have the data when we need it once the product goes live? Plenty of machine learning projects have failed because, while historical data was available to train the model, new data wasn’t available for the model to make a prediction at a useful time. </li>
<li class="readable-text" id="p26"> What are the challenges in building this product? These might be related to data availability, but they might be any number of other technical challenges. The key is that you don’t know all the challenges of building something until you actually try to build it. </li>
</ul>
<div class="readable-text" id="p27">
<p>What distinguishes the prototype phase from the proof of concept is that we have different questions now:</p>
</div>
<ul>
<li class="readable-text" id="p28"> <em>Is anyone interested in this product?</em> The product doesn’t have to exist to answer this question—a prototype is sufficient. Even a dashboard or a machine learning model deployed internally within a company needs to have product market fit. </li>
<li class="readable-text" id="p29"> <em>How would real users use this?</em> With a prototype, you can test your assumptions about how a real user of the product would use it without having to build the whole product. It is still early enough in the process that it shouldn’t be too costly to scrap the project at this phase. </li>
</ul>
<div class="readable-text" id="p30">
<p>These concepts are familiar to software developers and product managers, but they also have merit for analysts. The ability to put together a proof of concept and a subsequent prototype helps analysts identify what is valuable to work on and iterate ideas faster, which in turn means a more results-oriented way of working.</p>
</div>
<div class="readable-text intended-text" id="p31">
<p>Let’s now put these ideas into practice. The project brief is only partly about analyzing data to answer a question. It is also about building something to evaluate whether the data could support a paying product.</p>
</div>
<div class="readable-text" id="p32">
<h2 class="readable-text-h2" id="sigil_toc_id_124"><span class="num-string">10.2</span> Project 7: Build a proof of concept to investigate Welsh property prices</h2>
</div>
<div class="readable-text" id="p33">
<p>Let’s look at the project, in which we will not only analyze some data, but also build a proof-of-concept data product to show to stakeholders. We will start by looking at the problem statement, the data dictionary, the outputs we are aiming for, and what tools we need to tackle the problem. We will spend more time than usual thinking about the output since we’re going beyond analysis and into creating products. We can then formulate a results-oriented action plan and dive into the example solution.</p>
</div>
<div class="readable-text" id="p34">
<h3 class="readable-text-h3" id="sigil_toc_id_125"><span class="num-string">10.2.1</span> Problem statement</h3>
</div>
<div class="readable-text" id="p35">
<p>You’re working for CymruHomes Connect, a property company specializing in homes in Wales. They’re looking to expand their business with the help of data; they want to provide insights about the Welsh property market to customers in the form of a new app. This app would use historic property sales data to allow users to explore property prices in their area of interest.</p>
</div>
<div class="readable-text intended-text" id="p36">
<p>They have discovered that the UK government’s Land Registry has a dataset called “Price Paid,” which contains publicly available historical sales data. They have extracted and made available a few years’ worth of this data.</p>
</div>
<div class="readable-text print-book-callout" id="p37">
<p><span class="print-book-callout-head">NOTE</span>  Original data come from <a href="https://mng.bz/yWvB">https://mng.bz/yWvB</a>. It contains HM Land Registry data © Crown copyright and database right 2021. This data is licensed under the Open Government Licence v3.0. Thank you both to the Land Registry and Royal Mail for permission to use the house price and address data, respectively.</p>
</div>
<div class="readable-text" id="p38">
<p>They have asked you to look into whether this data is indeed suitable for powering their new app. This is quite vague, but they have some ideas they’d like to incorporate:</p>
</div>
<ul>
<li class="readable-text" id="p39"> They are particularly interested in the analysis of property types, for example, whether a house is terraced or detached, because they believe it strongly influences their customers when choosing a property, so they’d like the analysis to include breakdowns by this dimension. </li>
<li class="readable-text" id="p40"> They also believe users will be interested in comparing properties at the lowest level of granularity, so the ability to see street-level data is important. </li>
</ul>
<div class="readable-text" id="p41">
<p>They have only asked you to explore the data and see what questions can be answered with it, focusing on the angles they mentioned previously. However, we will go beyond their request and build a proof of concept to showcase what the final app might look like and do.</p>
</div>
<div class="readable-text intended-text" id="p42">
<p>An important lesson I’ve learned from working in data science is that stakeholders often cannot articulate exactly what they want because they lack understanding of what is possible. Creating proofs of concept is a way to help bridge this gap and provide additional value as a data professional.</p>
</div>
<div class="readable-text intended-text" id="p43">
<p>Before we discuss what our steps might be in the process, let’s review the available data, the desired outcomes, and the tools we will need.</p>
</div>
<div class="readable-text" id="p44">
<h3 class="readable-text-h3" id="sigil_toc_id_126"><span class="num-string">10.2.2</span> Data dictionary</h3>
</div>
<div class="readable-text" id="p45">
<p>As always, a key initial step is to take a look at the available data. Table 10.2 shows the data dictionary as provided by the Land Registry. Part of the data dictionary comes from Kaggle (<a href="https://mng.bz/QDWG">https://mng.bz/QDWG</a>), and the address columns are detailed here: <a href="https://mng.bz/XxWv">https://mng.bz/XxWv</a>. The definitions from the original data dictionaries are provided as is.</p>
</div>
<div class="browsable-container browsable-table-container framemaker-table-container" id="p46">
<h5 class="browsable-container-h5 sigil_not_in_toc"><span class="num-string">Table 10.2</span> Data dictionary of the Price Paid data</h5>
<table>
<thead>
<tr>
<th>
<div>
         Column 
       </div></th>
<th>
<div>
         Definition 
       </div></th>
</tr>
</thead>
<tbody>
<tr>
<td>  Transaction unique identifier <br/></td>
<td>  A reference number generated automatically, recording each published sale. The number is unique and will change each time a sale is recorded. <br/></td>
</tr>
<tr>
<td>  Price <br/></td>
<td>  Sale price stated on the transfer deed. <br/></td>
</tr>
<tr>
<td>  Date of transfer <br/></td>
<td>  Date when the sale was completed, as stated on the transfer deed. <br/></td>
</tr>
<tr>
<td>  Postcode <br/></td>
<td>  Postal code of the address. <br/></td>
</tr>
<tr>
<td>  Property type <br/></td>
<td>  D = Detached, S = Semi-detached, T = Terraced, F = Flats/Maisonettes, O = Other <br/></td>
</tr>
<tr>
<td>  Old/New <br/></td>
<td>  Indicates the age of the property and applies to all Price Paid transactions, residential and nonresidential. <br/>  Y = A newly built property, N = An established residential building <br/></td>
</tr>
<tr>
<td>  Duration <br/></td>
<td>  Relates to the tenure: F = Freehold, L= Leasehold <br/></td>
</tr>
<tr>
<td>  Primary addressable object name (PAON) <br/></td>
<td>  Typically house number/name (e.g., 42 or “Oak Cottage”). <br/></td>
</tr>
<tr>
<td>  Second addressable object name (SAON) <br/></td>
<td>  If there is a sub-building, for example, the building is divided into flats, there will be a SAON. <br/></td>
</tr>
<tr>
<td>  Street <br/></td>
<td>  The street part of the address. <br/></td>
</tr>
<tr>
<td>  Locality <br/></td>
<td>  Additional detail about the location (e.g., a district in a city). <br/></td>
</tr>
<tr>
<td>  Town/City <br/></td>
<td>  The town/city part of the address. <br/></td>
</tr>
<tr>
<td>  District <br/></td>
<td>  The district part of the address. <br/></td>
</tr>
<tr>
<td>  County <br/></td>
<td>  The county part of the address. <br/></td>
</tr>
<tr>
<td>  Category type <br/></td>
<td>  Indicates the type of Price Paid transaction. <br/>  A = Standard Price Paid entry; includes single residential property sold for full market value. <br/>  B = Additional Price Paid entry; includes transfers under a power of sale/repossessions, buy-to-lets (where they can be identified by a mortgage) and transfers to nonprivate individuals. <br/></td>
</tr>
<tr>
<td>  Record status <br/></td>
<td>  Relevant to monthly files only. Indicates additions, changes, and deletions to the records. Yearly files contain latest versions of all records. <br/></td>
</tr>
</tbody>
</table>
</div>
<div class="readable-text" id="p47">
<p>Now that we have seen what’s available, let’s look at the outcomes of this project.</p>
</div>
<div class="readable-text" id="p48">
<h3 class="readable-text-h3" id="sigil_toc_id_127"><span class="num-string">10.2.3</span> Desired outcomes</h3>
</div>
<div class="readable-text" id="p49">
<p>Our stakeholders initially want recommendations about what kind of analyses we could include in a potential app with the available data. Recommendations about additional data sources to incorporate would also be useful. Finally, we have decided to build a proof of concept, partly to show the stakeholders what their potential app might look like, but also to test whether the data is sufficient to build a useful product.</p>
</div>
<div class="readable-text" id="p50">
<h3 class="readable-text-h3" id="sigil_toc_id_128"><span class="num-string">10.2.4</span> Required tools</h3>
</div>
<div class="readable-text" id="p51">
<p>What constitutes a proof of concept will depend on your preferred tools. It might be a working web application, such as the one built with the Python library <code>streamlit</code> in the example solution. However, it could be a dashboard, such as one built with the R language’s package Shiny, or with a business intelligence tool such as Tableau or Power BI.</p>
</div>
<div class="readable-text intended-text" id="p52">
<p>In the example solution, I use Python and the <code>pandas</code> library for data exploration, and <code>matplotlib</code>, <code>seaborn</code>, and <code>ridgeplot</code> for visualization. I also introduce the <code>streamlit</code> library to build the interactive, web-based proof of concept. Your tools may differ, especially for the proof-of-concept stage. The checklist for this project is that your tool can</p>
</div>
<ul>
<li class="readable-text" id="p53"> Load and combine large datasets from CSV files containing millions of rows </li>
<li class="readable-text" id="p54"> Perform basic data manipulation tasks, such as filtering, sorting, grouping, and reshaping data </li>
<li class="readable-text" id="p55"> Create data visualizations </li>
<li class="readable-text" id="p56"> Create an interactive application, whether a dashboard or a web application, where different artifacts, such as charts or other visualizations, are displayed based on user input </li>
</ul>
<div class="readable-text print-book-callout" id="p57">
<p><span class="print-book-callout-head">Tip</span>  You might find it easier to use two different tools for this project: one for the data analysis and another for building a proof of concept. If you use a programming language that contains libraries or packages for building applications, such as Shiny for R or <code>streamlit</code> for Python, you may want to use this project to try them out.</p>
</div>
<div class="readable-text" id="p58">
<h2 class="readable-text-h2" id="sigil_toc_id_129"><span class="num-string">10.3</span> Applying the results-driven method to investigating Welsh property data </h2>
</div>
<div class="readable-text" id="p59">
<p>Let’s now address this problem with our results-driven framework and formulate our action plan.</p>
</div>
<div class="browsable-container figure-container" id="p60">
<img alt="figure" height="175" src="../Images/10-unnumb-1.png" width="529"/>
</div>
<div class="readable-text" id="p61">
<p><em><span class="aframe-location"/></em>We have an idea of what our stakeholders want to see. Their interest is in whether the data is suitable to support the app idea they have. They have stated that they are particularly interested in property types and whether street-level data can be incorporated into their app. We also understand that building a proof of concept will allow us to identify possible problems with using this data, which is why we will spend the time doing so.</p>
</div>
<div class="browsable-container figure-container" id="p62">
<img alt="figure" height="175" src="../Images/10-unnumb-2.png" width="529"/>
</div>
<div class="readable-text" id="p63">
<p><em><span class="aframe-location"/></em>Starting at the end means thinking about the app first and foremost. We cannot know exactly what will go in the app until we analyze the data, but keeping an eye on the app during the analysis phase will help us focus on getting results sooner. Whenever we create charts during the analysis phase, we should consider whether they would be useful in the proof of concept. Therefore, our analysis won’t just consider our stakeholders’ requests, but also the possible preferences of future users of the app. Our minimum viable answer in this project will look more like a minimum viable product would if we were designing software, which we are to an extent.</p>
</div>
<div class="browsable-container figure-container" id="p64">
<img alt="figure" height="175" src="../Images/10-unnumb-3.png" width="529"/>
</div>
<div class="readable-text" id="p65">
<p><em><span class="aframe-location"/></em>In this instance, the data has been identified for us. However, while building our proof of concept, we may identify gaps in the data or aspects of the property market that it doesn’t cover. We should consider additional data sources that would improve the quality of the app and recommend them when communicating our results to the stakeholders.</p>
</div>
<div class="browsable-container figure-container" id="p66">
<img alt="figure" height="175" src="../Images/10-unnumb-4.png" width="529"/>
</div>
<div class="readable-text" id="p67">
<p><em><span class="aframe-location"/></em>The data has been downloaded for us in its raw form from the Land Registry. However, we will need to combine the different yearly files before we start exploring the data. We may also wish to spend some time looking at the source of the data, that is, the Land Registry website, to learn more about how it was collected and what its possible limitations may be.</p>
</div>
<div class="browsable-container figure-container" id="p68">
<img alt="figure" height="104" src="../Images/10-unnumb-5.png" width="317"/>
</div>
<div class="readable-text" id="p69">
<p><em><span class="aframe-location"/></em>We will work on the project in two phases. The first phase is analyzing the available data, so our high-level steps might be</p>
</div>
<ul>
<li class="readable-text" id="p70"> Investigate the completeness of the data, such as identifying missing data. </li>
<li class="readable-text" id="p71"> Understand the geographic breakdown of the data, such as the different address levels, like locality and district. </li>
<li class="readable-text" id="p72"> Once we understand the geographic breakdown, we can extract Welsh properties to use in our app. </li>
<li class="readable-text" id="p73"> We also want to investigate property types as per our stakeholders’ request. Questions we may be interested in are the following: How does the sale price vary by property type? Which property types are more popular? Do these price and popularity patterns vary geographically? </li>
<li class="readable-text" id="p74"> Finally, we want to identify visualizations that can be recreated in our proof-of-concept app. </li>
</ul>
<div class="readable-text" id="p75">
<p>Once we have completed our initial analysis, we can look to building our proof of concept. Our considerations for this phase, and therefore requirements for our proof-of-concept app, are the following:</p>
</div>
<ul>
<li class="readable-text" id="p76"> Any data and visualizations displayed in the app should change based on user input. </li>
<li class="readable-text" id="p77"> The app should use all the real, available Welsh property data. </li>
<li class="readable-text" id="p78"> Options that users can change should come from the data (e.g., a list of counties they can select from). </li>
</ul>
<div class="readable-text" id="p79">
<p>The proof of concept does not need to be a web application; it just needs to contain interactive elements based on real data that you can show your stakeholders. A dashboard built in a BI tool would meet these criteria. If you’re a Python and Jupyter user, even having interactive widgets inside a Jupyter notebook would suffice.</p>
</div>
<div class="browsable-container figure-container" id="p80">
<img alt="figure" height="175" src="../Images/10-unnumb-6.png" width="529"/>
</div>
<div class="readable-text" id="p81">
<p><em><span class="aframe-location"/></em>The presentation of the output would consist of communicating the results of the analysis phase, as well as allowing stakeholders to see and even try the interactive proof of concept. The two complement each other because any limitations of the proof of concept will be discovered in the analysis phase and can be communicated while demonstrating the proof of concept itself.</p>
</div>
<div class="browsable-container figure-container" id="p82">
<img alt="figure" height="175" src="../Images/10-unnumb-7.png" width="529"/>
</div>
<div class="readable-text" id="p83">
<p><span class="aframe-location"/>Iteration is key when rapidly prototyping ideas. Whatever tool we use to build our proof of concept should make it easy to quickly make wholesale changes to its functionality. At this stage, we are not bound by production considerations such as user authentication, permissions, or managing servers and databases. We should be able to make changes quickly based on feedback both at the proof-of-concept and prototype stages.</p>
</div>
<div class="readable-text intended-text" id="p84">
<p>Now that we have an action plan outlined, it’s time to start working on the project. If you are reading this chapter from start to end, I suggest that this is the time to attempt the project yourself before reading the next section, which details an example solution.</p>
</div>
<div class="readable-text" id="p85">
<h2 class="readable-text-h2" id="sigil_toc_id_130"><span class="num-string">10.4</span> An example solution: Building a prototype to explore using house price data</h2>
</div>
<div class="readable-text" id="p86">
<p>Now, let’s walk through an example solution. As ever, I strongly recommend attempting the project yourself first, as our solutions will differ, particularly for this project.</p>
</div>
<div class="readable-text intended-text" id="p87">
<p>As for the action plan, we will combine the separate yearly files first. Then, we will explore the combined dataset, paying particular attention to property types and the geographical hierarchy of the data, as per our stakeholders’ request. We will decide which visualizations will go into our app before identifying an appropriate tool with which to build our proof of concept. Finally, we will build a proof of concept using the data, where the user can change the visualizations that are displayed based on their input.</p>
</div>
<div class="readable-text" id="p88">
<h3 class="readable-text-h3" id="sigil_toc_id_131"><span class="num-string">10.4.1</span> Analyzing data before prototyping</h3>
</div>
<div class="readable-text" id="p89">
<p>The first step in our process is to merge the different yearly files that our stakeholders provided. They cover the period from 2021 to 2023 inclusive. Initially, we will assume they have the same format, but we are prepared for this not to be the case.</p>
</div>
<div class="readable-text" id="p90">
<h4 class="readable-text-h4 sigil_not_in_toc">Merging datasets without headings</h4>
</div>
<div class="readable-text" id="p91">
<p>Let’s take a look at one of the files. The following code produces the output shown in figure 10.2:</p>
</div>
<div class="browsable-container listing-container" id="p92">
<div class="code-area-container">
<pre class="code-area">import pandas as pd

prices_2021 = pd.read_csv("./data/pp-2021.csv.gz", nrows=1000)
prices_2021.head()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p93">
<img alt="figure" height="592" src="../Images/10-2.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.2</span> A snapshot of the raw 2021 data</h5>
</div>
<div class="readable-text" id="p94">
<p>Upon inspection, the files contain no headers, so we need to provide column names based on the data dictionary. Apart from that, we will convert the date column to the correct type so we can verify that the data indeed covers the years it claims to. The following code reads in each of the yearly files in turn and combines them into a single <code>pandas</code> <code>DataFrame</code>. The output, a snapshot of the combined data, is shown in figure 10.3.</p>
</div>
<div class="browsable-container listing-container" id="p95">
<div class="code-area-container">
<pre class="code-area">annual_dfs = []

for year in [2021, 2022, 2023]:
    print(f"Parsing {year}")
    df = pd.read_csv(
        f"./data/pp-{year}.csv.gz",
        names=["transaction_id", "sale_price", "sale_date", "postcode",
               "property_type", "old_new", "duration", "house_number_name",
               "second_addressable_object_name", "street", "locality",
               "town_city", "district", "county",
               "category_type", "record_status"],
        parse_dates=["sale_date"])
    annual_dfs.append(df)

price_paid = pd.concat(annual_dfs, axis=0, ignore_index=True)
print(price_paid.shape)
price_paid.head()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p96">
<img alt="figure" height="438" src="../Images/10-3.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.3</span> A snapshot of the combined Price Paid data</h5>
</div>
<div class="readable-text" id="p97">
<p>Let’s verify that this combined dataset starts at the beginning of 2021 and ends in late 2023. We will look at the smallest and largest dates to do this, as shown in the following code, the output of which presented in figure 10.4:</p>
</div>
<div class="browsable-container listing-container" id="p98">
<div class="code-area-container">
<pre class="code-area">price_paid["sale_date"].agg(["min", "max"])<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p99">
<img alt="figure" height="85" src="../Images/10-4.png" width="484"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.4</span> Verification that the data does indeed cover the years 2021–2023</h5>
</div>
<div class="readable-text" id="p100">
<p>Now that we have combined our data and verified the date range, we will export it for later use. This means our analysis and proof of concept code can reference the combined data directly:</p>
</div>
<div class="browsable-container listing-container" id="p101">
<div class="code-area-container">
<pre class="code-area">price_paid.to_csv("./data/price_paid.csv.gz", index=False)</pre>
</div>
</div>
<div class="readable-text" id="p102">
<p>We are now ready to move on to the analysis phase.</p>
</div>
<div class="readable-text" id="p103">
<h4 class="readable-text-h4 sigil_not_in_toc">Investigating data quality</h4>
</div>
<div class="readable-text" id="p104">
<p>Let’s do some initial sanity checking of the combined data. We are interested in looking at missing data, outliers, especially in the sale price, and breakdowns of the various categories. We will start by reading the data again. If we continue from the previous code snippets, this is not strictly necessary, but because we decided it was good practice to split the merging and the analysis code, we will write the code that way. In the example code files, the merging and analysis phases happen in separate files, so we will be consistent here, too:</p>
</div>
<div class="browsable-container listing-container" id="p105">
<div class="code-area-container">
<pre class="code-area">import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

pd.options.display.float_format = '{:.2f}'.format

price_paid = pd.read_csv("./data/price_paid.csv.gz",
                         parse_dates=["sale_date"])
print(price_paid.shape)
price_paid.head()</pre>
</div>
</div>
<div class="readable-text" id="p106">
<p>Here, we also set something called the “float format.” This is a way to tell <code>pandas</code> how to display numbers. The reason we explicitly set it is that house prices will vary significantly, and it is likely that <code>pandas</code> will show the largest numbers using scientific notation. That is, one million would be shown as <code>1e6</code> or similar rather than displaying all the zeros. Setting the float format will avoid this problem, and as we will be working with prices that are monetary values, two decimal points makes sense.</p>
</div>
<div class="readable-text intended-text" id="p107">
<p>Let’s start by looking at missing data across our columns. The following code investigates this, and the output is shown in figure 10.5:</p>
</div>
<div class="browsable-container listing-container" id="p108">
<div class="code-area-container">
<pre class="code-area">price_paid.isnull().sum()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p109">
<img alt="figure" height="487" src="../Images/10-5.png" width="503"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.5</span> Number of missing values by column</h5>
</div>
<div class="readable-text" id="p110">
<p>This output tells us that all missing data is related to addresses. We have some missing postcodes, street names, and a lot of missing data for locality and the “second addressable object name” (SAON). These latter columns will be specific to different areas and properties, so they are unlikely to be a problem. The data dictionary even suggested that not all properties have a SAON.</p>
</div>
<div class="readable-text intended-text" id="p111">
<p>We should examine instances where there is no street name for a property, as this may be a problem, especially considering our stakeholders asked about street-level data. The following code investigates some missing street names, and the output is shown in figure 10.6:</p>
</div>
<div class="browsable-container listing-container" id="p112">
<div class="code-area-container">
<pre class="code-area">price_paid.loc[price_paid["street"].isnull(),
               ["house_number_name", "second_addressable_object_name",
                "street", "postcode", "locality", "town_city",
                "district", "county"]]<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p113">
<img alt="figure" height="626" src="../Images/10-6.png" width="953"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.6</span> A sample of properties with no street details</h5>
</div>
<div class="readable-text" id="p114">
<p>While this is only a small selection of the over 50,000 rows with missing street names, it does appear that a lot of these instances are properties that have names like “The Barn” or “The Old School.” This might explain why parts of the address are missing.</p>
</div>
<div class="readable-text intended-text" id="p115">
<p>We could leave these missing street names intact since, in many cases, they appear to be not applicable rather than missing. However, if we are to surface street names to users in our app, we need an option to filter on properties with no street name. We could handle this in the app itself or fill in the missing data with a placeholder value. Let’s opt to make the data as clean as possible and fill in the missing value. The following code achieves this:</p>
</div>
<div class="browsable-container listing-container" id="p116">
<div class="code-area-container">
<pre class="code-area">STREET_PLACEHOLDER = "-- NO STREET INFORMATION --"
price_paid["street"] = price_paid["street"].fillna(STREET_PLACEHOLDER)</pre>
</div>
</div>
<div class="readable-text" id="p117">
<p>Let’s take stock of what we have done so far and start building up our diagram to document our steps. Figure 10.7 shows what we have done so far, including the decision about what to do about missing street names.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p118">
<img alt="figure" height="489" src="../Images/10-7.png" width="927"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.7</span> The first steps of our analysis</h5>
</div>
<div class="readable-text" id="p119">
<h4 class="readable-text-h4 sigil_not_in_toc">Investigating missing geographic data</h4>
</div>
<div class="readable-text" id="p120">
<p>More worrying than missing street names is the fact that we have thousands of missing postcodes. Again, let’s look at a selection of these. The following code finds some examples, and the output is shown in figure 10.8:</p>
</div>
<div class="browsable-container listing-container" id="p121">
<div class="code-area-container">
<pre class="code-area">price_paid.loc[price_paid["postcode"].isnull(),
               ["house_number_name", "second_addressable_object_name",
                "street", "postcode", "locality", "town_city",
                "district", "county"]]<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p122">
<img alt="figure" height="623" src="../Images/10-8.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.8</span> A selection of records with missing postcode data</h5>
</div>
<div class="readable-text" id="p123">
<p>Looking at the house names, these also seem like properties with explicit names, as well as some references to garages. However, in this case, that does not explain why there is no postcode information since UK addresses generally have a postcode. We have a decision to make about this missing data. On the one hand, the missing records are a small percentage of the overall dataset, but on the other hand, these records still contribute to the housing market and, therefore, all contain relevant information.</p>
</div>
<div class="readable-text intended-text" id="p124">
<p>We will keep records that have no postcode information, but we will be mindful of their presence while continuing our analysis. As we have reached another decision point, let’s add this to our diagram in figure 10.9 to record the latest step in our analysis.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p125">
<img alt="figure" height="1050" src="../Images/10-9.png" width="1021"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.9</span> The latest diagram of our analytical steps</h5>
</div>
<div class="readable-text" id="p126">
<h4 class="readable-text-h4 sigil_not_in_toc">Investigating distribution and outliers in a price column</h4>
</div>
<div class="readable-text" id="p127">
<p>We are also interested in the distribution of the price column as it is the key variable on which our app will be based. The following code produces a high-level statistical summary of the data, which is shown in figure 10.10:</p>
</div>
<div class="browsable-container listing-container" id="p128">
<div class="code-area-container">
<pre class="code-area">price_paid["sale_price"].describe()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p129">
<img alt="figure" height="305" src="../Images/10-10.png" width="469"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.10</span> Statistical overview of the <code>sale_price</code> column</h5>
</div>
<div class="readable-text" id="p130">
<p>There are values ranging from £1 to over £500 million, so there will be outliers to handle. The mean is also significantly higher than the median, which <span class="aframe-location"/>is shown as 50% in the diagram, suggesting that the data is right-skewed. That in itself is not worrisome because price data tends to be in that shape, but we will investigate the outliers. To start with, let’s look at properties that sold for less than £1,000. The following code applies this filter, and the output is shown in figure 10.11:</p>
</div>
<div class="browsable-container listing-container" id="p131">
<div class="code-area-container">
<pre class="code-area">(
    price_paid.loc[price_paid["sale_price"] &lt; 1000,
    ["sale_price", "house_number_name",
     "street", "town_city", "postcode",
     "district", "county", "category_type"]
    ]
    .sample(10, random_state=42)
)<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p132">
<img alt="figure" height="638" src="../Images/10-11.png" width="993"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.11</span> A sample of 10 properties that sold for less than £1,000</h5>
</div>
<div class="readable-text" id="p133">
<p>Looking at the addresses of these transactions, there does not seem to be other data errors that could explain these low sale prices. However, all these transactions are in category B, according to the <code>category_type</code> column. Consulting the data dictionary in table 8.1, we can see that category B records are nonstandard transactions, including “transfers under a power of sale/repossessions.” It seems to be the case that properties categorized under B were sold for nominal amounts for reasons other than a standard property purchase. To verify this, let’s look at <span class="aframe-location"/>the proportion of category A versus B in the lower-valued properties. The following code does this and produces the output in figure 10.12:</p>
</div>
<div class="browsable-container listing-container" id="p134">
<div class="code-area-container">
<pre class="code-area">(
    price_paid.loc[price_paid["sale_price"] &lt; 10_000,
                   "category_type"]
    .value_counts()
)<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p135">
<img alt="figure" height="84" src="../Images/10-12.png" width="409"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.12</span> Distribution of <code>category_type</code> for low-valued properties</h5>
</div>
<div class="readable-text" id="p136">
<p>This offers an explanation for the lowest values in our data. There are also properties in the range of over £500M, as evidenced by the table in figure 10.10. Let’s inspect those to find out more. The following code identifies those high-value properties, and the output is shown in figure 10.13:</p>
</div>
<div class="browsable-container listing-container" id="p137">
<div class="code-area-container">
<pre class="code-area">price_paid[price_paid["sale_price"] &gt; 300_000_000]<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p138">
<img alt="figure" height="573" src="../Images/10-13.png" width="1073"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.13</span> Properties worth over £300M</h5>
</div>
<div class="readable-text" id="p139">
<p>Based on the names, one of these is an entire science park, and after doing some research, it appears the most expensive transaction might be something called Nine Elms Park, a large green space in a development in London, situated on Nine Elms Lane.</p>
</div>
<div class="readable-text intended-text" id="p140">
<p>To conclude our analysis of the price column, lower-valued transactions are due to being a special type, category B, and the highest-valued transactions are entire developments rather than individual properties. We don’t want to include those high-value transactions in our app, which is aimed at residential buyers, so we will drop the highest values. We could also consider dropping category B transactions, but perhaps users of the app might be interested if there were repossessions or other nonstandard transactions in the area they’re interested in, so we’ll leave that data intact. The following code keeps only the data under a high threshold, say £10M, which is a reasonable cutoff for most residential buyers. Anyone with a higher budget will be better served by more specialized real estate agencies:</p>
</div>
<div class="browsable-container listing-container" id="p141">
<div class="code-area-container">
<pre class="code-area">price_paid = price_paid[price_paid["sale_price"] &lt; 10_000_000]</pre>
</div>
</div>
<div class="readable-text" id="p142">
<p>Since we had to make a decision about outliers, let’s add another step to our diagram documenting the process so far, as shown in figure 10.14.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p143">
<img alt="figure" height="783" src="../Images/10-14.png" width="649"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.14</span> Latest diagram of the process, including the investigation of price outliers</h5>
</div>
<div class="readable-text" id="p144">
<p>Now, we are ready to look at other aspects of the data, namely, the various categorizations of our property transactions.</p>
</div>
<div class="readable-text" id="p145">
<h4 class="readable-text-h4 sigil_not_in_toc">Investigating categorizations in the data</h4>
</div>
<div class="readable-text" id="p146">
<p>There are several different ways that properties are categorized in our data. Judging by the data dictionary in table 8.1, we may want to update the names of these categories to be more descriptive. Let’s look at them in turn.</p>
</div>
<div class="readable-text intended-text" id="p147">
<p>Property type is of strong interest to our stakeholders. This data is labeled with individual letters (e.g., T for terraced houses). This is fine, but if we want to use the data in our app or even label charts correctly, the full names would be better. The following code remaps the property types to their full names and then creates the chart in figure 10.15, which shows the breakdown of property types in our data:</p>
</div>
<div class="browsable-container listing-container" id="p148">
<div class="code-area-container">
<pre class="code-area">property_type_map = {
    "D": "Detached",
    "S": "Semi-Detached",
    "T": "Terraced",
    "F": "Flats",
    "O": "Other"
}

price_paid["property_type"] = (
    price_paid["property_type"]
    .map(property_type_map)
)

fig, axis = plt.subplots()

(
    price_paid["property_type"]
    .value_counts()
    .sort_values()
    .plot
    .barh(ax=axis)
)

axis.set(
    title="Distribution of property type",
    xlabel="Count",
    ylabel="Property type"
)

plt.show()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p149">
<img alt="figure" height="609" src="../Images/10-15.png" width="898"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.15</span> Breakdown of property types in our data</h5>
</div>
<div class="readable-text" id="p150">
<p>If you have seen what houses in the United Kingdom are generally like, it won’t be a surprise to see that most properties are either terraced or semi-detached. Now, let’s remap the other categorizing columns, starting with whether a property is a new build or not, that is, newly built at the time of purchase. The following code recategorizes the data and produces the output in figure 10.16 to investigate the breakdown of this column:</p>
</div>
<div class="browsable-container listing-container" id="p151">
<div class="code-area-container">
<pre class="code-area">price_paid["old_new"] = (
    price_paid["old_new"]
    .map(
        {
            "Y": "New build",
            "N": "Existing property"
        }
    )
)
price_paid["old_new"].value_counts()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p152">
<img alt="figure" height="86" src="../Images/10-16.png" width="371"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.16</span> The breakdown of existing vs. newly built properties</h5>
</div>
<div class="readable-text" id="p153">
<p>The sanity check of this column should be that most properties were already built at the time of purchase, which is what we see in the data. Let’s now update the <code>duration</code> column, which differentiates freehold from leasehold properties. <span class="aframe-location"/>Leasehold means you don’t own the land your structure is on; you need to pay additional fees and renew your lease if it is expiring. The majority of properties in the United Kingdom should be freeholds. Let’s verify this while also recategorizing the data. The following code does this, and the output is shown in figure 10.17:</p>
</div>
<div class="browsable-container listing-container" id="p154">
<div class="code-area-container">
<pre class="code-area">price_paid["duration"] = (
    price_paid["duration"]
    .map(
        {
            "F": "Freehold",
            "L": "Leasehold"
        }
    )
)

price_paid["duration"].value_counts()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p155">
<img alt="figure" height="93" src="../Images/10-17.png" width="382"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.17</span> Breakdown of freehold vs. leasehold properties</h5>
</div>
<div class="readable-text" id="p156">
<p>Now that we have investigated most of our property data, we should turn our attention to the aspect we haven’t touched yet: geography.</p>
</div>
<div class="readable-text" id="p157">
<h3 class="readable-text-h3" id="sigil_toc_id_132"><span class="num-string">10.4.2</span> Investigating geographic aspects of a dataset</h3>
</div>
<div class="readable-text" id="p158">
<p>Our stakeholders are interested only in the Welsh property market, so we need to extract only the transactions that occurred in Wales before we can build our proof of concept. This will require extracting that information somehow as we do not have an obvious country column. For more practice extracting information from addresses, see a related project in chapter 2.</p>
</div>
<div class="readable-text intended-text" id="p159">
<p>Whenever we work with addresses, we have several options to extract additional information:</p>
</div>
<ul>
<li class="readable-text" id="p160"> Ideally, there is a column that stores the necessary information already. In this case, there isn’t. </li>
<li class="readable-text" id="p161"> If we have a combined address field, such as the project in chapter 2, we could extract the right address component. We also do not have that in this case. </li>
<li class="readable-text" id="p162"> We could use an existing column to cross-reference against official lists, similar to what we did in the example solution of chapter 2, where we cross-referenced address data with a definitive list of cities in the United Kingdom. In the case of this project, we could also cross-reference one of the address categorizations and find the ones corresponding to Wales.<span class="aframe-location"/> </li>
<li class="readable-text" id="p163"> A more complex, but possibly more accurate, method would be to use a third-party geocoding service to get a structured version of our address data. For the data in this project, we could send the service the combination of all the address columns we have and get back the same address in a standardized format, which would include the country column. </li>
</ul>
<div class="readable-text" id="p164">
<p>Out of these options, the third one seems to strike a balance between accuracy and effort. The last option is something to consider for a future iteration if we want to maximize accuracy, but only if we identify that the extra work is worth the effort. Let’s now investigate the different address categorizations in the data and see which one could be cross-referenced against a relevant, official list.</p>
</div>
<div class="readable-text intended-text" id="p165">
<p>One option is to look at the <code>town_city</code> column and cross-reference it against a list of Welsh cities. Running the following command reveals that we have 1,150 unique values for the town/city component. We will also uppercase the column just in case we have some inconsistent casing in the data:</p>
</div>
<div class="browsable-container listing-container" id="p166">
<div class="code-area-container">
<pre class="code-area">price_paid["town_city"] = price_paid["town_city"].str.upper()
price_paid["town_city"].nunique()</pre>
</div>
</div>
<div class="readable-text" id="p167">
<p>Having so many values increases the possibility of errors. There could be misspellings and other duplicate values, and there are town names that exist in both England and Wales, such as Newport. Let’s look at a higher level of geography instead: counties. The following code investigates the frequency of counties present in the data and also reveals the number of unique items, as shown in figure 10.18:</p>
</div>
<div class="browsable-container listing-container" id="p168">
<div class="code-area-container">
<pre class="code-area">price_paid["county"] = price_paid["county"].str.upper()
price_paid["county"].value_counts()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p169">
<img alt="figure" height="342" src="../Images/10-18.png" width="477"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.18</span> A breakdown of the number of records by county</h5>
</div>
<div class="readable-text" id="p170">
<p>From this output, we can tell there are 115 unique county values in the data, Greater London being the most common. The most frequent <span class="aframe-location"/>records tell us that the number of records per county is in the region of the tens of thousands, which makes some of the least common values suspicious. Northamptonshire is not a small county, so we would expect more than 707 records. Perhaps there are misspellings or overlapping county values. We will investigate these by looking for just the word NORTH and see what is returned. The following code does this, and the output is shown in figure 10.19:</p>
</div>
<div class="browsable-container listing-container" id="p171">
<div class="code-area-container">
<pre class="code-area">(
    price_paid
    .loc[price_paid["county"].str.contains("NORTH"), "county"]
    .unique()
)<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p172">
<img alt="figure" height="142" src="../Images/10-19.png" width="696"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.19</span> All counties containing the word NORTH</h5>
</div>
<div class="readable-text" id="p173">
<p>We find that there are also records for both North and West Northamptonshire. If we were interested in counties in England, we may consider combining these. It is possible this data doesn’t exactly match official lists, but it is easier to clean 115 county records than over 1,000 town names.</p>
</div>
<div class="readable-text" id="p174">
<h4 class="readable-text-h4 sigil_not_in_toc">Sanity checking our data from external sources</h4>
</div>
<div class="readable-text" id="p175">
<p>For now, we want an official list of counties in Wales to cross-reference against our data. The Welsh government has this list published on their website: <a href="https://law.gov.wales/local-government-bodies">https://law.gov.wales/local-government-bodies</a>.</p>
</div>
<div class="readable-text print-book-callout" id="p176">
<p><span class="print-book-callout-head">Note</span>  If the website is inaccessible, a copy of its relevant content is included in the supplementary materials for this chapter. The file is called <code>wales-local-government-bodies.htm</code>. It can be found in the <code>data</code> folder and is viewable in any web browser.</p>
</div>
<div class="readable-text" id="p177">
<p>The list is in bullet points about halfway down the page, as shown in figure 10.20.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p178">
<img alt="figure" height="904" src="../Images/10-20.png" width="1032"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.20</span> Official list of counties in Wales</h5>
</div>
<div class="readable-text intended-text" id="p179">
<p>From this page, we can extract the unique names of counties. Our data is in English, not Welsh, so we only need the English part of this list. We also don’t need the “County Borough Council” part, as those phrases are not contained in the <code>county</code> column of our data. We will take this list of counties and assume<span class="aframe-location"/> any record that contains one of these counties is a Welsh property, and everything else is in England. The following code categorizes the records into England or Wales based on their county. We’ll then look at the distribution of this new <code>country</code> column, which is shown in figure 10.21:</p>
</div>
<div class="browsable-container listing-container" id="p180">
<div class="code-area-container">
<pre class="code-area">welsh_councils = [
    c.upper() for c in ["Blaenau Gwent", "Bridgend", "Caerphilly",
                        "Cardiff", "Carmarthenshire", "Ceredigion",
                        "Conwy", "Denbighshire", "Flintshire",
                        "Gwynedd", "Isle of Anglesey", "Merthyr Tydfil",
                        "Monmouthshire", "Neath Port Talbot", "Newport",
                        "Pembrokeshire", "Powys", "Rhondda Cynon Taf",<span class="aframe-location"/>
                        "Swansea", "The Vale of Glamorgan", "Torfaen",
                        "Wrexham"]
]

price_paid["country"] = (
    np.where(
        price_paid["county"].isin(welsh_councils),
        "WALES",
        "ENGLAND"
    )
)

price_paid["country"].value_counts(dropna=False)<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p181">
<img alt="figure" height="88" src="../Images/10-21.png" width="365"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.21</span> The breakdown of England vs. Wales in our data</h5>
</div>
<div class="readable-text" id="p182">
<p>As we said earlier, it is possible that some of the values in the <code>county</code> column don’t match the list of Welsh counties exactly. We should look at all the counties categorized as England with our method and check if any are misspellings of the Welsh counties. The following code retrieves these counties, as shown in figure 10.22:</p>
</div>
<div class="browsable-container listing-container" id="p183">
<div class="code-area-container">
<pre class="code-area">print(
    sorted(
        price_paid
        .loc[price_paid["country"] == "ENGLAND", "county"]
        .unique()
    )
)<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p184">
<img alt="figure" height="669" src="../Images/10-22.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.22</span> A list of counties we categorized as belonging to England</h5>
</div>
<div class="readable-text" id="p185">
<p>We could employ more sophisticated methods to find county names in this list that are almost like one of the Welsh counties, but since there aren’t that many counties in total, we can do this manually. See the example solution in chapter 3 for ideas on how to do more sophisticated string matching.</p>
</div>
<div class="readable-text intended-text" id="p186">
<p>At a glance, the only county that seems miscategorized is Rhondda Cynon Taf, which appears in the data with a double f at the end. Let’s manually recategorize those instances as Wales to make the data more accurate:</p>
</div>
<div class="browsable-container listing-container" id="p187">
<div class="code-area-container code-area-with-html">
<pre class="code-area">price_paid.loc[price_paid["county"] == "RHONDDA CYNON TAFF", "country"]
<span class="">↪</span> = "WALES"<span class="aframe-location"/></pre>
</div>
</div>
<div class="readable-text" id="p188">
<p>As a final step in this part, we will extract only the Welsh properties into their own DataFrame so that all our analyses will be limited to Welsh properties:</p>
</div>
<div class="browsable-container listing-container" id="p189">
<div class="code-area-container">
<pre class="code-area">wales = price_paid[price_paid["country"] == "WALES"].copy()</pre>
</div>
</div>
<div class="readable-text" id="p190">
<p>The next step is to explore this subset of Welsh transactions to see what aspects of the data should be included in our proof-of-concept app. But before we move on, let’s review our progress so far in the form of a diagram, shown in figure 10.23. Then, we’ll be ready to explore the Welsh property data to identify visualizations we want to include in our proof-of-concept app.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p191">
<img alt="figure" height="1779" src="../Images/10-23.png" width="946"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.23</span> The process up until the point of identifying Welsh properties</h5>
</div>
<div class="readable-text" id="p192">
<h3 class="readable-text-h3" id="sigil_toc_id_133"><span class="num-string">10.4.3</span> Identifying how to present data in the prototype</h3>
</div>
<div class="readable-text" id="p193">
<p>Now that we have separated the data by country, let’s explore different aspects of the Welsh property market.</p>
</div>
<div class="readable-text" id="p194">
<h4 class="readable-text-h4 sigil_not_in_toc">Investigating variations in geography</h4>
</div>
<div class="readable-text" id="p195">
<p>First, let’s see the difference in sale price between counties. When a user wants to purchase a property, the app should help them identify what property prices look like in their desired area. The plot is shown in figure 10.24, and the code after the figure calculates and plots the median sale price by county for Welsh properties only. <span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p196">
<img alt="figure" height="1400" src="../Images/10-24.png" width="908"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.24</span> Median property price by county in Wales</h5>
</div>
<div class="browsable-container listing-container" id="p197">
<div class="code-area-container">
<pre class="code-area">fig, axis = plt.subplots(figsize=(6, 12))

(
    wales
    .groupby("county")
    ["sale_price"]
    .median()
    .sort_values()
    .plot
    .barh(ax=axis)
)

axis.set(
    title="Median sale price by county (Wales)",
    xlabel="Median sale price (£)",
    ylabel="County"
)

for label in axis.get_yticklabels():
    label.set_fontsize(8)

plt.show()</pre>
</div>
</div>
<div class="readable-text" id="p198">
<p>There is clear geographic disparity across counties. This data covers multiple years, so we should also investigate its temporal aspects. How has the number of transactions changed over time? The following code creates the plot in figure 10.25:</p>
</div>
<div class="browsable-container listing-container" id="p199">
<div class="code-area-container">
<pre class="code-area">wales["year"] = wales["sale_date"].dt.year

fig, axis = plt.subplots()

(
    wales
    .set_index("sale_date")
    .resample("YS")
    .size()
    .plot(ax=axis, color="gray")
)

axis.set(
    title="Transactions per year",
    xlabel="Year",
    ylabel="# of transactions",
    ylim=(0, 70_000)
)

plt.show()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p200">
<img alt="figure" height="569" src="../Images/10-25.png" width="757"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.25</span> Number of annual property transactions in Wales</h5>
</div>
<div class="readable-text" id="p201">
<p>There is a definite overall downward trend in the number of transactions. Does this pattern also affect prices? We can calculate the median sale price by county and year to investigate this. The following code calculates this and visualizes it with the heatmap shown in figure 10.26:</p>
</div>
<div class="browsable-container listing-container" id="p202">
<div class="code-area-container">
<pre class="code-area">by_county_and_year = (
    wales
    .pivot_table(
        values="sale_price",
        index="county",
        columns="year",
        aggfunc="median"
    )
)

fig, axis = plt.subplots(figsize=(10, 10))

sns.heatmap(
    by_county_and_year / 1000,
    annot=True,
    cmap="Greys",
    fmt=".1f",
    ax=axis
)

axis.set(
    title="Median price by county and year (£ thousands)",
    xlabel="Year",
    ylabel="County"
)

plt.show()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p203">
<img alt="figure" height="979" src="../Images/10-26.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.26</span> Heatmap showing property prices by county and year</h5>
</div>
<div class="readable-text" id="p204">
<p>In most counties, we observe an increase in the median sale price from 2021 to 2022 and then a decrease again in 2023. Although the number of transactions seems to be steadily dropping, it appears the prices have only been affected in the latest full year of data. We will want to include some aspects of this information in our final app.</p>
</div>
<div class="readable-text intended-text" id="p205">
<p>Another aspect of the difference across counties might be in property type, which is something our stakeholders are specifically interested in. The code following figure 10.27 calculates the median price by county and property type and plots the heatmap in the figure.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p206">
<img alt="figure" height="889" src="../Images/10-27.png" width="1009"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.27</span> A heatmap showing property prices across county and property type</h5>
</div>
<div class="browsable-container listing-container" id="p207">
<div class="code-area-container">
<pre class="code-area">fig, axis = plt.subplots(figsize=(10, 10))

sns.heatmap(
    wales.pivot_table(
        index="county",
        columns="property_type",
        values="sale_price",
        aggfunc="median"
    ) / 1000,
    annot=True,
    cmap="Greys",
    fmt=".1f",
    ax=axis,
    annot_kws={"size": 8}     <span class="aframe-location"/> #1
)
axis.set(
    title="Median sale price (£ thousands) by county and property type",
    xlabel="Property type",
    ylabel="County"
)

plt.show()</pre>
<div class="code-annotations-overlay-container">
     #1 Reduces the font size of the axis labels
     <br/>
</div>
</div>
</div>
<div class="readable-text" id="p208">
<p>This heatmap tells us that detached properties have the highest value in all counties, but there is high variability in the “Other” category. This matches what is typical for the UK property market: detached properties are more desirable than semi-detached ones, which are more desirable than terraced properties. This pattern seems to exist across counties.</p>
</div>
<div class="readable-text" id="p209">
<h4 class="readable-text-h4 sigil_not_in_toc">Using ridgeline plots to look at distribution across groups</h4>
</div>
<div class="readable-text" id="p210">
<p>What these heatmaps don’t tell us is the distribution of prices. We could use histograms or box plots to show this by county or by year. However, we might want to get a bit more adventurous to make the app stand out more visually. One option is something called a <em>ridgeline plots</em>, which looks like a smoothed histogram by category, but the histograms are stacked behind each other. To illustrate this better, the following code creates a ridgeline plot of the distribution of prices by year, as shown in figure 10.28. The data needs to be a list of prices, one list per year. Because the number of transactions is not constant for each year, we cannot use a tabular data structure, so we created three lists of prices that can be of different lengths:</p>
</div>
<div class="browsable-container listing-container" id="p211">
<div class="code-area-container">
<pre class="code-area">years = sorted(wales["year"].unique())
annual_sales = []

for year in years:     <span class="aframe-location"/> #1
    prices = (
        wales.loc[(wales["year"] == year)
                  &amp; (wales["sale_price"] &lt; 500_000),
        "sale_price"]
    )
    annual_sales.append([prices])    <span class="aframe-location"/> #2

from ridgeplot import ridgeplot     <span class="aframe-location"/> #3

fig = ridgeplot(annual_sales,
                labels=[str(y) for y in years],
                colorscale="gray_r")

fig.update_layout(
    title="Welsh property sale prices over time",
    xaxis_title="Price (£)",
    yaxis_title="Year",
    showlegend=False
)

fig.show()<span class="aframe-location"/></pre>
<div class="code-annotations-overlay-container">
     #1 Creates a list of prices per year and collects this list in another list
     <br/>#2 annual_sales will be a list of pandas Series objects.
     <br/>#3 The ridgeplot module is specialized for this kind of plot.
     <br/>
</div>
</div>
</div>
<div class="browsable-container figure-container" id="p212">
<img alt="figure" height="310" src="../Images/10-28.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.28</span> A ridgeline plot showing property prices over time</h5>
</div>
<div class="readable-text" id="p213">
<p>This plot shows the distribution of prices changing over time and conserves space by having the plots overlap in a 3D effect. Let’s do something similar with prices by county to better show the spread of prices rather than simple averages. The following code collects the data for prices by county and creates the associated ridgeline plot, which is shown in figure 10.29. This time, we will remove the temporal aspect and focus only on properties that were sold in 2023, so our plot is as up to date and relevant as possible:</p>
</div>
<div class="browsable-container listing-container" id="p214">
<div class="code-area-container">
<pre class="code-area">counties = sorted(wales["county"].unique())
sales_by_county = []

for county in counties:
    prices = (
        wales
        .loc[(wales["county"] == county)
             &amp; (wales["sale_price"] &lt; 500_000)
             &amp; (wales["year"] == 2023),
        "sale_price"]
    )
    sales_by_county.append([prices])

fig = ridgeplot(sales_by_county,
                labels=counties,
                colorscale="gray",
                coloralpha=0.9,
                colormode="mean-minmax",
                spacing=0.7)

fig.update_layout(
    title="Sale prices in Wales in 2023, by county",
    height=650,
    width=950,
    font_size=12,
    plot_bgcolor="rgb(245, 245, 245)",
    xaxis_gridcolor="white",
    yaxis_gridcolor="white",
    xaxis_gridwidth=2,
    yaxis_title="County",
    xaxis_title="Sale price (£)",
    showlegend=False
)

fig.show()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p215">
<img alt="figure" height="654" src="../Images/10-29.png" width="1012"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.29</span> A ridgeline plot of prices by county</h5>
</div>
<div class="readable-text" id="p216">
<p>This plot is more information dense than the one in figure 10.24, which shows only median prices. We’ll include this plot in the app as a reference, so users have an idea of property prices across the country. We will also include the number of transactions over time for the area a user is interested in, as well as a breakdown by property type, such as the chart in figure 10.15. These visualizations, coupled with the interactivity that we plan to add, will form our minimum viable answer for this project.</p>
</div>
<div class="readable-text intended-text" id="p217">
<p>Let’s revisit the entire process up until this point. Figure 10.30 shows what we have done so far, including the most recent step of deciding which visuals to include in the app.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p218">
<img alt="figure" height="1206" src="../Images/10-30.png" width="652"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.30</span> The process until the decision of which visualizations to include in the proof of concept</h5>
</div>
<div class="readable-text" id="p219">
<p>Beyond the visualizations we have chosen to include, we will want to add some interactivity to the app. We will do this in the form of filters so that the user can filter the data down to just the area they are interested in, which will update the charts accordingly. To do this, we need to understand what levels of granularity we will let users drill down to. Our stakeholders requested street-level information in the app if possible, so let’s investigate whether this is possible with the available data.</p>
</div>
<div class="readable-text" id="p220">
<h4 class="readable-text-h4 sigil_not_in_toc">Investigating geographic hierarchy</h4>
</div>
<div class="readable-text" id="p221">
<p>We have several columns in the data that refer to different address components. To devise our filters for the app, we need to understand their hierarchy. Based on knowledge of address hierarchies, we would assume that the hierarchy consists of counties, districts, towns, and streets. However, the words “county” and “district” may have different meanings in different datasets, so we will verify whether this hierarchy is correct. To do this, we will count the number of distinct records in each category. The smaller the number of distinct values, the higher the level that category is in the hierarchy. The following code calculates this and produces the result in figure 10.31.</p>
</div>
<div class="browsable-container listing-container" id="p222">
<div class="code-area-container">
<pre class="code-area">hierarchy = ["county", "district", "town_city", "street"]
level_counts = []

for col in hierarchy:
    num_values = wales[col].nunique()
    level_counts.append(num_values)

for z in zip(hierarchy, level_counts):
    print(z)<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p223">
<img alt="figure" height="132" src="../Images/10-31.png" width="262"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.31</span> Number of distinct records for each address component</h5>
</div>
<div class="readable-text" id="p224">
<p>Interestingly, there seems to be a one-to-one mapping between counties and districts. To verify this, we should see whether any county has more than one district mapped to it in the data or vice versa. We achieve this with the following code. Our assumption is that if both these lines of code return 0 results, then we have a perfect one-to-one mapping between counties and districts:</p>
</div>
<div class="browsable-container listing-container" id="p225">
<div class="code-area-container">
<pre class="code-area">wales.groupby("county")["district"].nunique().loc[lambda x: x &gt; 1]
wales.groupby("district")["county"].nunique().loc[lambda x: x &gt; 1]</pre>
</div>
</div>
<div class="readable-text" id="p226">
<p>Both results return nothing, meaning there are no districts attached to more than one county, and no counties attached to more than one district. Perhaps the district column is relevant for England, but it is redundant for Wales. We can, therefore, conclude that our address hierarchy is counties, then towns and cities, and, finally, streets. These are, therefore, the three filters we will include in the app. Before we start building the app, let’s export our Welsh properties as a dataset of their own, which the app can read. The app should read our cleaned and filtered data, and it should not have to manipulate it in any way. The following code exports the data to the optimized Parquet format:</p>
</div>
<div class="browsable-container listing-container" id="p227">
<div class="code-area-container">
<pre class="code-area">wales.to_parquet("./data/wales.parquet", index=False)</pre>
</div>
</div>
<div class="readable-text" id="p228">
<p>That concludes the first part of the project; we prepared our data and are ready to build the proof of concept. Let’s revisit what we have done so far before moving on to build the proof of concept in the next chapter.</p>
</div>
<div class="readable-text" id="p229">
<h3 class="readable-text-h3" id="sigil_toc_id_134"><span class="num-string">10.4.4</span> Project progress so far</h3>
</div>
<div class="readable-text" id="p230">
<p>So far in the project, we</p>
</div>
<ul>
<li class="readable-text" id="p231"> Merged multiple years of property sales data </li>
<li class="readable-text" id="p232"> Investigated the quality of the data, including missing values and outliers </li>
<li class="readable-text" id="p233"> Identified geographic data of interest </li>
<li class="readable-text" id="p234"> Investigated the distribution and outliers of the sale price column </li>
<li class="readable-text" id="p235"> Enhanced our geographic data with external government data to separate English property transactions from Welsh ones </li>
<li class="readable-text" id="p236"> Identified appropriate visualizations for our proof of concept, including a ridgeline plot </li>
<li class="readable-text" id="p237"> Exported the relevant, cleaned Welsh property transactions, which our proof of concept will use </li>
</ul>
<div class="readable-text" id="p238">
<p>Before we move on to the final part, figure 10.32 shows our progress so far. In the next chapter, we will move on to the final part of the project, which is to build the proof-of-concept tool itself.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p239">
<img alt="figure" height="1259" src="../Images/10-32.png" width="632"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 10.32</span> Part 1 of the project before building the proof of concept</h5>
</div>
<div class="readable-text" id="p240">
<h2 class="readable-text-h2" id="sigil_toc_id_135">Summary</h2>
</div>
<ul>
<li class="readable-text" id="p241"> Building a working proof of concept can be the best way to identify problems in the data that would prevent it from being used for a particular purpose. </li>
<li class="readable-text" id="p242"> Exploring data with a view to building a proof of concept includes assessing whether the data is appropriate for the task. </li>
<li class="readable-text" id="p243"> The output of the analysis should be a cleaned dataset that our proof of concept can use as is. </li>
</ul>
</div></body></html>