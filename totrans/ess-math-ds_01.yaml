- en: Chapter 1\. Basic Math and Calculus Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will kick off the first chapter covering what numbers are and how variables
    and functions work on a Cartesian system. We will then cover exponents and logarithms.
    After that, we will learn the two basic operations of calculus: derivatives and
    integrals.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into the applied areas of essential math such as probability,
    linear algebra, statistics, and machine learning, we should probably review a
    few basic math and calculus concepts. Before you drop this book and run screaming,
    do not worry! I will present how to calculate derivatives and integrals for a
    function in a way you were probably not taught in college. We have Python on our
    side, not a pencil and paper. Even if you are not familiar with derivatives and
    integrals, you still do not need to worry.
  prefs: []
  type: TYPE_NORMAL
- en: I will make these topics as tight and practical as possible, focusing only on
    what will help us in later chapters and what falls under the “essential math”
    umbrella.
  prefs: []
  type: TYPE_NORMAL
- en: This Is Not a Full Math Crash Course!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is by no means a comprehensive review of high school and college math.
    If you want that, a great book to check out is *No Bullshit Guide to Math and
    Physics* by Ivan Savov (pardon my French). The first few chapters contain the
    best crash course on high school and college math I have ever seen. The book *Mathematics
    1001* by Dr. Richard Elwes has some great content as well, and in bite-sized explanations.
  prefs: []
  type: TYPE_NORMAL
- en: Number Theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are numbers? I promise to not be too philosophical in this book, but are
    numbers not a construct we have defined? Why do we have the digits 0 through 9,
    and not have more digits than that? Why do we have fractions and decimals and
    not just whole numbers? This area of math where we muse about numbers and why
    we designed them a certain way is known as number theory.
  prefs: []
  type: TYPE_NORMAL
- en: '*Number theory* goes all the way back to ancient times, when mathematicians
    studied different number systems, and it explains why we have accepted them the
    way we do today. Here are different number systems that you may recognize:'
  prefs: []
  type: TYPE_NORMAL
- en: Natural numbers
  prefs: []
  type: TYPE_NORMAL
- en: These are the numbers 1, 2, 3, 4, 5…and so on. Only positive numbers are included
    here, and they are the earliest known system. Natural numbers are so ancient cavemen
    scratched tally marks on bones and cave walls to keep records.
  prefs: []
  type: TYPE_NORMAL
- en: Whole numbers
  prefs: []
  type: TYPE_NORMAL
- en: Adding to natural numbers, the concept of “0” was later accepted; we call these
    “whole numbers.” The Babylonians also developed the useful idea for place-holding
    notation for empty “columns” on numbers greater than 9, such as “10,” “1,000,”
    or “1,090.” Those zeros indicate no value occupying that column.
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  prefs: []
  type: TYPE_NORMAL
- en: Integers include positive and negative natural numbers as well as 0\. We may
    take them for granted, but ancient mathematicians deeply distrusted the idea of
    negative numbers. But when you subtract 5 from 3, you get –2\. This is useful
    especially when it comes to finances where we measure profits and losses. In 628
    AD, an Indian mathematician named Brahmagupta showed why negative numbers were
    necessary for arithmetic to progress with the quadratic formula, and therefore
    integers became accepted.
  prefs: []
  type: TYPE_NORMAL
- en: Rational numbers
  prefs: []
  type: TYPE_NORMAL
- en: Any number that you can express as a fraction, such as 2/3, is a rational number.
    This includes all finite decimals and integers since they can be expressed as
    fractions, too, such as 687/100 = 6.87 and 2/1 = 2, respectively. They are called
    *rational* because they are *ratios*. Rational numbers were quickly deemed necessary
    because time, resources, and other quantities could not always be measured in
    discrete units. Milk does not always come in gallons. We may have to measure it
    as parts of a gallon. If I run for 12 minutes, I cannot be forced to measure in
    whole miles when in actuality I ran 9/10 of a mile.
  prefs: []
  type: TYPE_NORMAL
- en: Irrational numbers
  prefs: []
  type: TYPE_NORMAL
- en: Irrational numbers cannot be expressed as a fraction. This includes the famous
    <math alttext="pi"><mi>π</mi></math> , square roots of certain numbers like <math
    alttext="StartRoot 2 EndRoot"><msqrt><mn>2</mn></msqrt></math> , and Euler’s number
    <math alttext="e"><mi>e</mi></math> , which we will learn about later. These numbers
    have an infinite number of decimal digits, such as 3.141592653589793238462…
  prefs: []
  type: TYPE_NORMAL
- en: There is an interesting history behind irrational numbers. The Greek mathematician
    Pythagoras believed all numbers are rational. He believed this so fervently, he
    made a religion that prayed to the number 10\. “Bless us, divine number, thou
    who generated gods and men!” he and his followers would pray (why “10” was so
    special, I do not know). There is a legend that one of his followers, Hippasus,
    proved not all numbers are rational simply by demonstrating the square root of
    2\. This severely messed with Pythagoras’s belief system, and he responded by
    drowning Hippasus at sea.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless, we now know not all numbers are rational.
  prefs: []
  type: TYPE_NORMAL
- en: Real numbers
  prefs: []
  type: TYPE_NORMAL
- en: Real numbers include rational as well as irrational numbers. In practicality,
    when you are doing any data science work you can treat any decimals you work with
    as real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Complex and imaginary numbers
  prefs: []
  type: TYPE_NORMAL
- en: You encounter this number type when you take the square root of a negative number.
    While imaginary and complex numbers have relevance in certain types of problems,
    we will mostly steer clear of them.
  prefs: []
  type: TYPE_NORMAL
- en: In data science, you will find most (if not all) of your work will be using
    whole numbers, natural numbers, integers, and real numbers. Imaginary numbers
    may be encountered in more advanced use cases such as matrix decomposition, which
    we will touch on in [Chapter 4](ch04.xhtml#ch04).
  prefs: []
  type: TYPE_NORMAL
- en: Complex and Imaginary Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you do want to learn about imaginary numbers, there is a great playlist *Imaginary
    Numbers are Real* on [YouTube](https://oreil.ly/bvyIq).
  prefs: []
  type: TYPE_NORMAL
- en: Order of Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hopefully, you are familiar with *order of operations*, which is the order you
    solve each part of a mathematical expression. As a brief refresher, recall that
    you evaluate components in parentheses, followed by exponents, then multiplication,
    division, addition, and subtraction. You can remember the order of operations
    by the mnemonic device PEMDAS (Please Excuse My Dear Aunt Sally), which corresponds
    to the ordering parentheses, exponents, multiplication, division, addition, and
    subtraction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take for example this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="2 times StartFraction left-parenthesis 3 plus 2 right-parenthesis
    squared Over 5 EndFraction minus 4" display="block"><mrow><mn>2</mn> <mo>×</mo>
    <mfrac><msup><mrow><mo>(</mo><mn>3</mn><mo>+</mo><mn>2</mn><mo>)</mo></mrow> <mn>2</mn></msup>
    <mn>5</mn></mfrac> <mo>-</mo> <mn>4</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'First we evaluate the parentheses (3 + 2), which equals 5:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="2 times StartFraction left-parenthesis bold 5 right-parenthesis
    squared Over 5 EndFraction minus 4" display="block"><mrow><mn>2</mn> <mo>×</mo>
    <mfrac><msup><mrow><mo>(</mo><mn mathvariant="bold">5</mn><mo>)</mo></mrow> <mn>2</mn></msup>
    <mn>5</mn></mfrac> <mo>-</mo> <mn>4</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we solve the exponent, which we can see is squaring that 5 we just summed.
    That is 25:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="2 times StartFraction bold 25 Over 5 EndFraction minus 4" display="block"><mrow><mn>2</mn>
    <mo>×</mo> <mfrac><mn mathvariant="bold">25</mn> <mn>5</mn></mfrac> <mo>-</mo>
    <mn>4</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up we have multiplication and division. The ordering of these two is swappable
    since division is also multiplication (using fractions). Let’s go ahead and multiply
    the 2 with the <math alttext="StartFraction 25 Over 5 EndFraction"><mfrac><mn>25</mn>
    <mn>5</mn></mfrac></math> , yielding <math alttext="StartFraction 50 Over 5 EndFraction"><mfrac><mn>50</mn>
    <mn>5</mn></mfrac></math> :'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction 50 Over 5 EndFraction minus 4" display="block"><mrow><mfrac><mn>50</mn>
    <mn>5</mn></mfrac> <mo>-</mo> <mn>4</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we will perform the division, dividing 50 by 5, which will yield 10:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="bold 10 negative 4" display="block"><mrow><mn mathvariant="bold">10</mn>
    <mo>-</mo> <mn>4</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, we perform any addition and subtraction. Of course, <math alttext="10
    minus 4"><mrow><mn>10</mn> <mo>-</mo> <mn>4</mn></mrow></math> is going to give
    us 6:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="10 minus 4 equals 6" display="block"><mrow><mn>10</mn> <mo>-</mo>
    <mn>4</mn> <mo>=</mo> <mn>6</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Sure enough, if we were to express this in Python we would print a value of
    `6.0` as shown in [Example 1-1](#ubDppIkBEj).
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-1\. Solving an expression in Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This may be elementary but it is still critical. In code, even if you get the
    correct result without them, it is a good practice to liberally use parentheses
    in complex expressions so you establish control of the evaluation order.
  prefs: []
  type: TYPE_NORMAL
- en: Here I group the fractional part of my expression in parentheses, helping to
    set it apart from the rest of the expression in [Example 1-2](#iNAKBikkOg).
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-2\. Making use of parentheses for clarity in Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: While both examples are technically correct, the latter is more clear to us
    easily confused humans. If you or someone else makes changes to your code, the
    parentheses provide an easy reference of operation order as you make changes.
    This provides a line of defense against code changes to prevent bugs as well.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have done some scripting with Python or another programming language,
    you have an idea what a variable is. In mathematics, a *variable* is a named placeholder
    for an unspecified or unknown number.
  prefs: []
  type: TYPE_NORMAL
- en: You may have a variable *x* representing any real number, and you can multiply
    that variable without declaring what it is. In [Example 1-3](#GEEDPGFQRQ) we take
    a variable input *x* from a user and multiply it by 3.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-3\. A variable in Python that is then multiplied
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There are some standard variable names for certain variable types. If these
    variable names and concepts are unfamiliar, no worries! But some readers might
    recognize we use theta <math alttext="theta"><mi>θ</mi></math> to denote angles
    and beta <math alttext="beta"><mi>β</mi></math> for a parameter in a linear regression.
    Greek symbols make awkward variable names in Python, so we would likely name these
    variables `theta` and `beta` in Python as shown in [Example 1-4](#orOowCWTNK).
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-4\. Greek variable names in Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note also that variable names can be subscripted so that several instances of
    a variable name can be used. For practical purposes, just treat these as separate
    variables. If you encounter variables *x*[1], *x*[2], and *x*[3], just treat them
    as three separate variables as shown in [Example 1-5](#nbsirNPfRU).
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-5\. Expressing subscripted variables in Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Functions* are expressions that define relationships between two or more variables.
    More specifically, a function takes *input variables* (also called *domain variables*
    or *independent variables*), plugs them into an expression, and then results in
    an *output variable* (also called *dependent variable*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take this simple linear function:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="y equals 2 x plus 1" display="block"><mrow><mi>y</mi> <mo>=</mo>
    <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: For any given x-value, we solve the expression with that *x* to find *y*. When
    *x* = 1, then *y* = 3\. When *x* = 2, *y* = 5\. When *x* = 3, *y* = 7 and so on,
    as shown in [Table 1-1](#lIoFQkJKWV).
  prefs: []
  type: TYPE_NORMAL
- en: Table 1-1\. Different values for y = 2x + 1
  prefs: []
  type: TYPE_NORMAL
- en: '| x | 2x + 1 | y |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 2(0) + 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2(1) + 1 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2(2) + 1 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 2(3) + 1 | 7 |'
  prefs: []
  type: TYPE_TB
- en: Functions are useful because they model a predictable relationship between variables,
    such as how many fires *y* can we expect at *x* temperature. We will use linear
    functions to perform linear regressions in [Chapter 5](ch05.xhtml#ch05).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another convention you may see for the dependent variable *y* is to explicitly
    label it a function of *x*, such as <math alttext="f left-parenthesis x right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math> . So rather than express a function
    as <math alttext="y equals 2 x plus 1"><mrow><mi>y</mi> <mo>=</mo> <mn>2</mn>
    <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math> , we can also express it as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals 2 x plus 1" display="block"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 1-6](#UQLcQVtkqn) shows how we can declare a mathematical function
    and iterate it in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-6\. Declaring a linear function in Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When dealing with real numbers, a subtle but important feature of functions
    is they often have an infinite number of x-values and resulting y-values. Ask
    yourself this: how many x-values can we put through the function <math alttext="y
    equals 2 x plus 1"><mrow><mi>y</mi> <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo>
    <mn>1</mn></mrow></math> ? Rather than just 0, 1, 2, 3…why not 0, 0.5, 1, 1.5,
    2, 2.5, 3 as shown in [Table 1-2](#aNGOvuFmpT)?'
  prefs: []
  type: TYPE_NORMAL
- en: Table 1-2\. Different values for y = 2x + 1
  prefs: []
  type: TYPE_NORMAL
- en: '| x | 2x + 1 | y |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0.0 | 2(0) + 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0.5 | 2(.5) + 1 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 1.0 | 2(1) + 1 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 1.5 | 2(1.5) + 1 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 2.0 | 2(2) + 1 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 2.5 | 2(2.5) + 1 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 3.0 | 2(3) + 1 | 7 |'
  prefs: []
  type: TYPE_TB
- en: Or why not do quarter steps for *x*? Or 1/10 of a step? We can make these steps
    infinitely small, effectively showing <math alttext="y equals 2 x plus 1"><mrow><mi>y</mi>
    <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math> is a *continuous
    function*, where for every possible value of *x* there is a value for *y*. This
    segues us nicely to visualize our function as a line as shown in [Figure 1-1](#GcTcreWOta).
  prefs: []
  type: TYPE_NORMAL
- en: '![emds 0101](Images/emds_0101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-1\. Graph for function y = 2x + 1
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When we plot on a two-dimensional plane with two number lines (one for each
    variable) it is known as a *Cartesian plane*, *x-y plane*, or *coordinate plane*.
    We trace a given x-value and then look up the corresponding y-value, and plot
    the intersections as a line. Notice that due to the nature of real numbers (or
    decimals, if you prefer), there are an infinite number of *x* values. This is
    why when we plot the function *f*(*x*) we get a continuous line with no breaks
    in it. There are an infinite number of points on that line, or any part of that
    line.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to plot this using Python, there are a number of charting libraries
    from Plotly to matplotlib. Throughout this book we will use SymPy to do many tasks,
    and the first we will use is plotting a function. SymPy uses matplotlib so make
    sure you have that package installed. Otherwise it will print an ugly text-based
    graph to your console. After that, just declare the *x* variable to SymPy using
    `symbols()`, declare your function, and then plot it as shown in [Example 1-7](#noaPuacjja)
    and [Figure 1-2](#bobqNTAwcH).
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-7\. Charting a linear function in Python using SymPy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![emds 0102](Images/emds_0102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-2\. Using SymPy to graph a linear function
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Example 1-8](#hdgJBGCdmR) and [Figure 1-3](#rPwcOSawNp) are another example
    showing the function <math alttext="f left-parenthesis x right-parenthesis equals
    x squared plus 1"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>1</mn></mrow></math>
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-8\. Charting an exponential function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note in [Figure 1-3](#rPwcOSawNp) we do not get a straight line but rather a
    smooth, symmetrical curve known as a parabola. It is continuous but not linear,
    as it does not produce values in a straight line. Curvy functions like this are
    mathematically harder to work with, but we will learn some tricks to make it not
    so bad.
  prefs: []
  type: TYPE_NORMAL
- en: Curvilinear Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a function is continuous but curvy, rather than linear and straight, we
    call it a *curvilinear function*.
  prefs: []
  type: TYPE_NORMAL
- en: '![emds 0103](Images/emds_0103.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-3\. Using SymPy to graph an exponential function
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that functions utilize multiple input variables, not just one. For example,
    we can have a function with independent variables *x* and *y*. Note that *y* is
    not dependent like in previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x comma y right-parenthesis equals 2 x plus
    3 y" display="block"><mrow><mi>f</mi> <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo> <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>3</mn> <mi>y</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Since we have two independent variables (*x* and *y*) and one dependent variable
    (the output of *f*(*x*,*y*)), we need to plot this graph on three dimensions to
    produce a plane of values rather than a line, as shown in [Example 1-9](#UwFfAJTOmU)
    and [Figure 1-4](#bqOScbvrNn).
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-9\. Declaring a function with two independent variables in Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![emds 0104](Images/emds_0104.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-4\. Using SymPy to graph a three-dimensional function
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: No matter how many independent variables you have, your function will typically
    output only one dependent variable. When you solve for multiple dependent variables,
    you will likely be using separate functions for each one.
  prefs: []
  type: TYPE_NORMAL
- en: Summations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I promised not to use equations full of Greek symbols in this book. However,
    there is one that is so common and useful that I would be remiss to not cover
    it. A *summation* is expressed as a sigma <math alttext="normal upper Sigma"><mi>Σ</mi></math>
    and adds elements together.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if I want to iterate the numbers 1 through 5, multiply each by
    2, and sum them, here is how I would express that using a summation. [Example 1-10](#qtpCbqbAdu)
    shows how to execute this in Python.
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="sigma-summation Underscript i equals 1 Overscript 5 Endscripts
    2 i equals left-parenthesis 2 right-parenthesis 1 plus left-parenthesis 2 right-parenthesis
    2 plus left-parenthesis 2 right-parenthesis 3 plus left-parenthesis 2 right-parenthesis
    4 plus left-parenthesis 2 right-parenthesis 5 equals 30" display="block"><mrow><munderover><mo>∑</mo>
    <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mn>5</mn></munderover> <mn>2</mn>
    <mi>i</mi> <mo>=</mo> <mrow><mo>(</mo> <mn>2</mn> <mo>)</mo></mrow> <mn>1</mn>
    <mo>+</mo> <mrow><mo>(</mo> <mn>2</mn> <mo>)</mo></mrow> <mn>2</mn> <mo>+</mo>
    <mrow><mo>(</mo> <mn>2</mn> <mo>)</mo></mrow> <mn>3</mn> <mo>+</mo> <mrow><mo>(</mo>
    <mn>2</mn> <mo>)</mo></mrow> <mn>4</mn> <mo>+</mo> <mrow><mo>(</mo> <mn>2</mn>
    <mo>)</mo></mrow> <mn>5</mn> <mo>=</mo> <mn>30</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-10\. Performing a summation in Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that *i* is a placeholder variable representing each consecutive index
    value we are iterating in the loop, which we multiply by 2 and then sum all together.
    When you are iterating data, you may see variables like <math alttext="x Subscript
    i"><msub><mi>x</mi> <mi>i</mi></msub></math> indicating an element in a collection
    at index *i*.
  prefs: []
  type: TYPE_NORMAL
- en: The range() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall that the `range()` function in Python is end exclusive, meaning if you
    invoke `range(1,4)` it will iterate the numbers 1, 2, and 3\. It excludes the
    4 as an upper boundary.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also common to see *n* represent the number of items in a collection,
    like the number of records in a dataset. Here is one such example where we iterate
    a collection of numbers of size *n*, multiply each one by 10, and sum them:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="sigma-summation Underscript i equals 1 Overscript n Endscripts
    10 x Subscript i" display="block"><mrow><munderover><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>n</mi></munderover> <mn>10</mn> <msub><mi>x</mi> <mi>i</mi></msub></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 1-11](#VFdLakbelW) we use Python to execute this expression on a
    collection of four numbers. Note that in Python (and most programming languages
    in general) we typically reference items starting at index 0, while in math we
    start at index 1\. Therefore, we shift accordingly in our iteration by starting
    at 0 in our `range()`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-11\. Summation of elements in Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: That is the gist of summation. In a nutshell, a summation <math alttext="normal
    upper Sigma"><mi>Σ</mi></math> says, “add a bunch of things together,” and uses
    an index *i* and a maximum value *n* to express each iteration feeding into the
    sum. We will see these throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Exponents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Exponents* multiply a number by itself a specified number of times. When you
    raise 2 to the third power (expressed as 2³ using 3 as a superscript), that is
    multiplying three 2s together:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="2 cubed equals 2 asterisk 2 asterisk 2 equals 8" display="block"><mrow><msup><mn>2</mn>
    <mn>3</mn></msup> <mo>=</mo> <mn>2</mn> <mo>*</mo> <mn>2</mn> <mo>*</mo> <mn>2</mn>
    <mo>=</mo> <mn>8</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: The *base* is the variable or value we are exponentiating, and the *exponent*
    is the number of times we multiply the base value. For the expression <math alttext="2
    cubed"><msup><mn>2</mn> <mn>3</mn></msup></math> , 2 is the base and 3 is the
    exponent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exponents have a few interesting properties. Say we multiplied <math alttext="x
    squared"><msup><mi>x</mi> <mn>2</mn></msup></math> and <math alttext="x cubed"><msup><mi>x</mi>
    <mn>3</mn></msup></math> together. Observe what happens next when I expand the
    exponents with simple multiplication and then consolidate into a single exponent:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x squared x cubed equals left-parenthesis x asterisk x right-parenthesis
    asterisk left-parenthesis x asterisk x asterisk x right-parenthesis equals x Superscript
    2 plus 3 Baseline equals x Superscript 5" display="block"><mrow><msup><mi>x</mi>
    <mn>2</mn></msup> <msup><mi>x</mi> <mn>3</mn></msup> <mo>=</mo> <mrow><mo>(</mo>
    <mi>x</mi> <mo>*</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>*</mo> <mrow><mo>(</mo>
    <mi>x</mi> <mo>*</mo> <mi>x</mi> <mo>*</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>x</mi> <mrow><mn>2</mn><mo>+</mo><mn>3</mn></mrow></msup> <mo>=</mo>
    <msup><mi>x</mi> <mn>5</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: When we multiply exponents together with the same base, we simply add the exponents,
    which is known as the *product rule*. Let me emphasize that the base of all multiplied
    exponents must be the same for the product rule to apply.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore division next. What happens when we divide <math alttext="x squared"><msup><mi>x</mi>
    <mn>2</mn></msup></math> by <math alttext="x Superscript 5"><msup><mi>x</mi> <mn>5</mn></msup></math>
    ?
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mfrac><msup><mi>x</mi>
    <mn>2</mn></msup> <msup><mi>x</mi> <mn>5</mn></msup></mfrac></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mfrac><mrow><mi>x</mi><mo>*</mo><mi>x</mi></mrow>
    <mrow><mi>x</mi><mo>*</mo><mi>x</mi><mo>*</mo><mi>x</mi><mo>*</mo><mi>x</mi><mo>*</mo><mi>x</mi></mrow></mfrac></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mfrac><mn>1</mn>
    <mrow><mi>x</mi><mo>*</mo><mi>x</mi><mo>*</mo><mi>x</mi></mrow></mfrac></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfrac><mn>1</mn>
    <msup><mi>x</mi> <mn>3</mn></msup></mfrac> <mo>=</mo> <msup><mi>x</mi> <mrow><mo>-</mo><mn>3</mn></mrow></msup></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, when we divide <math alttext="x squared"><msup><mi>x</mi> <mn>2</mn></msup></math>
    by <math alttext="x Superscript 5"><msup><mi>x</mi> <mn>5</mn></msup></math> we
    can cancel out two *x*’s in the numerator and denominator, leaving us with <math
    alttext="StartFraction 1 Over x cubed EndFraction"><mfrac><mn>1</mn> <msup><mi>x</mi>
    <mn>3</mn></msup></mfrac></math> . When a factor exists in both the numerator
    and denominator, we can cancel out that factor.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about the <math alttext="x Superscript negative 3"><msup><mi>x</mi> <mrow><mo>-</mo><mn>3</mn></mrow></msup></math>
    , you wonder? This is a good point to introduce negative exponents, which is another
    way of expressing an exponent operation in the denominator of a fraction. To demonstrate,
    <math alttext="StartFraction 1 Over x cubed EndFraction"><mfrac><mn>1</mn> <msup><mi>x</mi>
    <mn>3</mn></msup></mfrac></math> is the same as <math alttext="x Superscript negative
    3"><msup><mi>x</mi> <mrow><mo>-</mo><mn>3</mn></mrow></msup></math> :'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction 1 Over x cubed EndFraction equals x Superscript
    negative 3" display="block"><mrow><mfrac><mn>1</mn> <msup><mi>x</mi> <mn>3</mn></msup></mfrac>
    <mo>=</mo> <msup><mi>x</mi> <mrow><mo>-</mo><mn>3</mn></mrow></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Tying back the product rule, we can see it applies to negative exponents, too.
    To get intuition behind this, let’s approach this problem a different way. We
    can express this division of two exponents by making the “5” exponent of <math
    alttext="x Superscript 5"><msup><mi>x</mi> <mn>5</mn></msup></math> negative,
    and then multiplying it with <math alttext="x squared"><msup><mi>x</mi> <mn>2</mn></msup></math>
    . When you add a negative number, it is effectively performing subtraction. Therefore,
    the exponent product rule summing the multiplied exponents still holds up as shown
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mrow><mfrac><msup><mi>x</mi> <mn>2</mn></msup> <msup><mi>x</mi>
    <mn>5</mn></msup></mfrac> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup> <mfrac><mn>1</mn>
    <msup><mi>x</mi> <mn>5</mn></msup></mfrac> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup>
    <msup><mi>x</mi> <mrow><mo>-</mo><mn>5</mn></mrow></msup> <mo>=</mo> <msup><mi>x</mi>
    <mrow><mn>2</mn><mo>+</mo><mn>-5</mn></mrow></msup> <mo>=</mo> <msup><mi>x</mi>
    <mrow><mo>-</mo><mn>3</mn></mrow></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, can you figure out why any base with an exponent of 0 is
    1?
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x Superscript 0 Baseline equals 1" display="block"><mrow><msup><mi>x</mi>
    <mn>0</mn></msup> <mo>=</mo> <mn>1</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to get this intuition is to reason that any number divided by
    itself is 1\. If you have <math alttext="StartFraction x cubed Over x cubed EndFraction"><mfrac><msup><mi>x</mi>
    <mn>3</mn></msup> <msup><mi>x</mi> <mn>3</mn></msup></mfrac></math> it is algebraically
    obvious that reduces to 1\. But that expression also evaluates to <math alttext="x
    Superscript 0"><msup><mi>x</mi> <mn>0</mn></msup></math> :'
  prefs: []
  type: TYPE_NORMAL
- en: <math><mrow><mn>1</mn> <mo>=</mo> <mfrac><msup><mi>x</mi> <mn>3</mn></msup>
    <msup><mi>x</mi> <mn>3</mn></msup></mfrac> <mo>=</mo> <msup><mi>x</mi> <mn>3</mn></msup>
    <msup><mi>x</mi> <mrow><mo>-</mo><mn>3</mn></mrow></msup> <mo>=</mo> <msup><mi>x</mi>
    <mrow><mn>3</mn><mo>+</mo><mn>-3</mn></mrow></msup> <mo>=</mo> <msup><mi>x</mi>
    <mn>0</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: By the transitive property, which states that if *a* = *b* and *b* = *c*, then
    *a* = *c*, we know that <math alttext="x Superscript 0 Baseline equals 1"><mrow><msup><mi>x</mi>
    <mn>0</mn></msup> <mo>=</mo> <mn>1</mn></mrow></math> .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now what about fractional exponents? They are an alternative way to represent
    roots, such as the square root. As a brief refresher, a <math alttext="StartRoot
    4 EndRoot"><msqrt><mn>4</mn></msqrt></math> asks “What number multiplied by itself
    will give me 4?” which of course is 2\. Note here that <math alttext="4 Superscript
    1 slash 2"><msup><mn>4</mn> <mrow><mn>1</mn><mo>/</mo><mn>2</mn></mrow></msup></math>
    is the same as <math alttext="StartRoot 4 EndRoot"><msqrt><mn>4</mn></msqrt></math>
    :'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="4 Superscript 1 slash 2 Baseline equals StartRoot 4 EndRoot equals
    2" display="block"><mrow><msup><mn>4</mn> <mrow><mn>1</mn><mo>/</mo><mn>2</mn></mrow></msup>
    <mo>=</mo> <msqrt><mn>4</mn></msqrt> <mo>=</mo> <mn>2</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Cubed roots are similar to square roots, but they seek a number multiplied
    by itself three times to give a result. A cubed root of 8 is expressed as <math
    alttext="RootIndex 3 StartRoot 8 EndRoot"><mroot><mn>8</mn> <mn>3</mn></mroot></math>
    and asks “What number multiplied by itself three times gives me 8?” This number
    would be 2 because <math alttext="2 asterisk 2 asterisk 2 equals 8"><mrow><mn>2</mn>
    <mo>*</mo> <mn>2</mn> <mo>*</mo> <mn>2</mn> <mo>=</mo> <mn>8</mn></mrow></math>
    . In exponents a cubed root is expressed as a fractional exponent, and <math alttext="RootIndex
    3 StartRoot 8 EndRoot"><mroot><mn>8</mn> <mn>3</mn></mroot></math> can be reexpressed
    as <math alttext="8 Superscript 1 slash 3"><msup><mn>8</mn> <mrow><mn>1</mn><mo>/</mo><mn>3</mn></mrow></msup></math>
    :'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="8 Superscript 1 slash 3 Baseline equals RootIndex 3 StartRoot
    8 EndRoot equals 2" display="block"><mrow><msup><mn>8</mn> <mrow><mn>1</mn><mo>/</mo><mn>3</mn></mrow></msup>
    <mo>=</mo> <mroot><mn>8</mn> <mn>3</mn></mroot> <mo>=</mo> <mn>2</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'To bring it back full circle, what happens when you multiply the cubed root
    of 8 three times? This will undo the cubed root and yield 8\. Alternatively, if
    we express the cubed root as fractional exponents <math alttext="8 Superscript
    1 slash 3"><msup><mn>8</mn> <mrow><mn>1</mn><mo>/</mo><mn>3</mn></mrow></msup></math>
    , it becomes clear we add the exponents together to get an exponent of 1\. That
    also undoes the cubed root:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="RootIndex 3 StartRoot 8 EndRoot asterisk RootIndex 3 StartRoot
    8 EndRoot asterisk RootIndex 3 StartRoot 8 EndRoot equals 8 Superscript one-third
    Baseline times 8 Superscript one-third Baseline times 8 Superscript one-third
    Baseline equals 8 Superscript one-third plus one-third plus one-third Baseline
    equals 8 Superscript 1 Baseline equals 8" display="block"><mrow><mroot><mn>8</mn>
    <mn>3</mn></mroot> <mo>*</mo> <mroot><mn>8</mn> <mn>3</mn></mroot> <mo>*</mo>
    <mroot><mn>8</mn> <mn>3</mn></mroot> <mo>=</mo> <msup><mn>8</mn> <mfrac><mn>1</mn>
    <mn>3</mn></mfrac></msup> <mo>×</mo> <msup><mn>8</mn> <mfrac><mn>1</mn> <mn>3</mn></mfrac></msup>
    <mo>×</mo> <msup><mn>8</mn> <mfrac><mn>1</mn> <mn>3</mn></mfrac></msup> <mo>=</mo>
    <msup><mn>8</mn> <mrow><mfrac><mn>1</mn> <mn>3</mn></mfrac><mo>+</mo><mfrac><mn>1</mn>
    <mn>3</mn></mfrac><mo>+</mo><mfrac><mn>1</mn> <mn>3</mn></mfrac></mrow></msup>
    <mo>=</mo> <msup><mn>8</mn> <mn>1</mn></msup> <mo>=</mo> <mn>8</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'And one last property: an exponent of an exponent will multiply the exponents
    together. This is known as the *power rule*. So <math alttext="left-parenthesis
    8 cubed right-parenthesis squared"><msup><mrow><mo>(</mo><msup><mn>8</mn> <mn>3</mn></msup>
    <mo>)</mo></mrow> <mn>2</mn></msup></math> would simplify to <math alttext="8
    Superscript 6"><msup><mn>8</mn> <mn>6</mn></msup></math> :'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="left-parenthesis 8 cubed right-parenthesis squared equals 8 Superscript
    3 times 2 Baseline equals 8 Superscript 6" display="block"><mrow><msup><mrow><mo>(</mo><msup><mn>8</mn>
    <mn>3</mn></msup> <mo>)</mo></mrow> <mn>2</mn></msup> <mo>=</mo> <msup><mn>8</mn>
    <mrow><mn>3</mn><mo>×</mo><mn>2</mn></mrow></msup> <mo>=</mo> <msup><mn>8</mn>
    <mn>6</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are skeptical why this is, try expanding it and you will see the sum
    rule makes it clear:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="left-parenthesis 8 cubed right-parenthesis squared equals 8 cubed
    8 cubed equals 8 Superscript 3 plus 3 Baseline equals 8 Superscript 6" display="block"><mrow><msup><mrow><mo>(</mo><msup><mn>8</mn>
    <mn>3</mn></msup> <mo>)</mo></mrow> <mn>2</mn></msup> <mo>=</mo> <msup><mn>8</mn>
    <mn>3</mn></msup> <msup><mn>8</mn> <mn>3</mn></msup> <mo>=</mo> <msup><mn>8</mn>
    <mrow><mn>3</mn><mo>+</mo><mn>3</mn></mrow></msup> <mo>=</mo> <msup><mn>8</mn>
    <mn>6</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, what does it mean when we have a fractional exponent with a numerator
    other than 1, such as <math alttext="8 Superscript two-thirds"><msup><mn>8</mn>
    <mfrac><mn>2</mn> <mn>3</mn></mfrac></msup></math> ? Well, that is taking the
    cube root of 8 and then squaring it. Take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="8 Superscript two-thirds Baseline equals left-parenthesis 8 Superscript
    one-third Baseline right-parenthesis squared equals 2 squared equals 4" display="block"><mrow><msup><mn>8</mn>
    <mfrac><mn>2</mn> <mn>3</mn></mfrac></msup> <mo>=</mo> <msup><mrow><mo>(</mo><msup><mn>8</mn>
    <mfrac><mn>1</mn> <mn>3</mn></mfrac></msup> <mo>)</mo></mrow> <mn>2</mn></msup>
    <mo>=</mo> <msup><mn>2</mn> <mn>2</mn></msup> <mo>=</mo> <mn>4</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: And yes, irrational numbers can serve as exponents like <math alttext="8 Superscript
    pi"><msup><mn>8</mn> <mi>π</mi></msup></math> , which is 687.2913\. This may feel
    unintuitive, and understandably so! In the interest of time, we will not dive
    deep into this as it requires some calculus. But essentially, we can calculate
    irrational exponents by approximating with a rational number. This is effectively
    what computers do since they can compute to only so many decimal places anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example <math alttext="pi"><mi>π</mi></math> has an infinite number of
    decimal places. But if we take the first 11 digits, 3.1415926535, we can approximate
    <math alttext="pi"><mi>π</mi></math> as a rational number 31415926535 / 10000000000\.
    Sure enough, this gives us approximately 687.2913, which should approximately
    match any calculator:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mrow><msup><mn>8</mn> <mi>π</mi></msup> <mo>≈</mo> <msup><mn>8</mn>
    <mfrac><mn>31415926535</mn> <mn>10000000000</mn></mfrac></msup> <mo>≈</mo> <mn>687.</mn>
    <mn>2913</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Logarithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *logarithm* is a math function that finds a power for a specific number and
    base. It may not sound interesting at first, but it actually has many applications.
    From measuring earthquakes to managing volume on your stereo, the logarithm is
    found everywhere. It also finds its way into machine learning and data science
    a lot. As a matter of fact, logarithms will be a key part of logistic regressions
    in [Chapter 6](ch06.xhtml#ch06).
  prefs: []
  type: TYPE_NORMAL
- en: 'Start your thinking by asking “2 raised to *what power* gives me 8?” One way
    to express this mathematically is to use an *x* for the exponent:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="2 Superscript x Baseline equals 8" display="block"><mrow><msup><mn>2</mn>
    <mi>x</mi></msup> <mo>=</mo> <mn>8</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: We intuitively know the answer, <math alttext="x equals 3"><mrow><mi>x</mi>
    <mo>=</mo> <mn>3</mn></mrow></math> , but we need a more elegant way to express
    this common math operation. This is what the <math alttext="l o g left-parenthesis
    right-parenthesis"><mrow><mi>l</mi> <mi>o</mi> <mi>g</mi> <mo>(</mo> <mo>)</mo></mrow></math>
    function is for.
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="l o g 2 Baseline 8 equals x" display="block"><mrow><mi>l</mi>
    <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub> <mn>8</mn> <mo>=</mo> <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding logarithm expression, we have a base 2 and
    are finding a power to give us 8\. More generally, we can reexpress a variable
    exponent as a logarithm:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><msup><mi>a</mi>
    <mi>x</mi></msup> <mo>=</mo> <mi>b</mi></mrow></mtd></mtr></mtable></math> <math
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>l</mi>
    <mi>o</mi> <msub><mi>g</mi> <mi>a</mi></msub> <mi>b</mi> <mo>=</mo> <mi>x</mi></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: Algebraically speaking, this is a way of isolating the *x*, which is important
    to solve for *x*. [Example 1-12](#vOUfdcffqO) shows how we calculate this logarithm
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-12\. Using the log function in Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When you do not supply a base argument to a `log()` function on a platform like
    Python, it will typically have a default base. In some fields, like earthquake
    measurements, the default base for the log is 10\. But in data science the default
    base for the log is Euler’s number <math alttext="e"><mi>e</mi></math> . Python
    uses the latter, and we will talk about <math alttext="e"><mi>e</mi></math> shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Just like exponents, logarithms have several properties when it comes to multiplication,
    division, exponentiation, and so on. In the interest of time and focus, I will
    just present this in [Table 1-3](#daVvodFTeO). The key idea to focus on is a logarithm
    finds an exponent for a given base to result in a certain number.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to dive into logarithmic properties, [Table 1-3](#daVvodFTeO) displays
    exponent and logarithm behaviors side-by-side that you can use for reference.
  prefs: []
  type: TYPE_NORMAL
- en: Table 1-3\. Properties for exponents and logarithms
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Exponent property | Logarithm property |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Multiplication | <math alttext="x Superscript m Baseline times x Superscript
    n Baseline equals x Superscript m plus n"><mrow><msup><mi>x</mi> <mi>m</mi></msup>
    <mo>×</mo> <msup><mi>x</mi> <mi>n</mi></msup> <mo>=</mo> <msup><mi>x</mi> <mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow></msup></mrow></math>
    | <math alttext="l o g left-parenthesis a times b right-parenthesis equals l o
    g left-parenthesis a right-parenthesis plus l o g left-parenthesis b right-parenthesis"><mrow><mi>l</mi>
    <mi>o</mi> <mi>g</mi> <mo>(</mo> <mi>a</mi> <mo>×</mo> <mi>b</mi> <mo>)</mo> <mo>=</mo>
    <mi>l</mi> <mi>o</mi> <mi>g</mi> <mo>(</mo> <mi>a</mi> <mo>)</mo> <mo>+</mo> <mi>l</mi>
    <mi>o</mi> <mi>g</mi> <mo>(</mo> <mi>b</mi> <mo>)</mo></mrow></math> |'
  prefs: []
  type: TYPE_TB
- en: '| Division | <math alttext="StartFraction x Superscript m Baseline Over x Superscript
    n Baseline EndFraction equals x Superscript m minus n"><mrow><mfrac><msup><mi>x</mi>
    <mi>m</mi></msup> <msup><mi>x</mi> <mi>n</mi></msup></mfrac> <mo>=</mo> <msup><mi>x</mi>
    <mrow><mi>m</mi><mo>-</mo><mi>n</mi></mrow></msup></mrow></math> | <math alttext="l
    o g left-parenthesis StartFraction a Over b EndFraction right-parenthesis equals
    l o g left-parenthesis a right-parenthesis minus l o g left-parenthesis b right-parenthesis"><mrow><mi>l</mi>
    <mi>o</mi> <mi>g</mi> <mrow><mo>(</mo> <mfrac><mi>a</mi> <mi>b</mi></mfrac> <mo>)</mo></mrow>
    <mo>=</mo> <mi>l</mi> <mi>o</mi> <mi>g</mi> <mrow><mo>(</mo> <mi>a</mi> <mo>)</mo></mrow>
    <mo>-</mo> <mi>l</mi> <mi>o</mi> <mi>g</mi> <mrow><mo>(</mo> <mi>b</mi> <mo>)</mo></mrow></mrow></math>
    |'
  prefs: []
  type: TYPE_TB
- en: '| Exponentiation | <math alttext="left-parenthesis x Superscript m Baseline
    right-parenthesis Superscript n Baseline equals x Superscript m n"><mrow><msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mi>m</mi></msup> <mo>)</mo></mrow> <mi>n</mi></msup> <mo>=</mo> <msup><mi>x</mi>
    <mrow><mi>m</mi><mi>n</mi></mrow></msup></mrow></math> | <math alttext="l o g
    left-parenthesis a Superscript n Baseline right-parenthesis equals n times l o
    g left-parenthesis a right-parenthesis"><mrow><mi>l</mi> <mi>o</mi> <mi>g</mi>
    <mrow><mo>(</mo> <msup><mi>a</mi> <mi>n</mi></msup> <mo>)</mo></mrow> <mo>=</mo>
    <mi>n</mi> <mo>×</mo> <mi>l</mi> <mi>o</mi> <mi>g</mi> <mrow><mo>(</mo> <mi>a</mi>
    <mo>)</mo></mrow></mrow></math> |'
  prefs: []
  type: TYPE_TB
- en: '| Zero Exponent | <math alttext="x Superscript 0 Baseline equals 1"><mrow><msup><mi>x</mi>
    <mn>0</mn></msup> <mo>=</mo> <mn>1</mn></mrow></math> | <math alttext="l o g left-parenthesis
    1 right-parenthesis equals 0"><mrow><mi>l</mi> <mi>o</mi> <mi>g</mi> <mo>(</mo>
    <mn>1</mn> <mo>)</mo> <mo>=</mo> <mn>0</mn></mrow></math> |'
  prefs: []
  type: TYPE_TB
- en: '| Inverse | <math alttext="x Superscript negative 1 Baseline equals StartFraction
    1 Over x EndFraction"><mrow><msup><mi>x</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <mfrac><mn>1</mn> <mi>x</mi></mfrac></mrow></math> | <math alttext="l
    o g left-parenthesis x Superscript negative 1 Baseline right-parenthesis equals
    l o g left-parenthesis StartFraction 1 Over x EndFraction right-parenthesis equals
    minus l o g left-parenthesis x right-parenthesis"><mrow><mi>l</mi> <mi>o</mi>
    <mi>g</mi> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>)</mo></mrow> <mo>=</mo> <mi>l</mi> <mi>o</mi> <mi>g</mi> <mrow><mo>(</mo>
    <mfrac><mn>1</mn> <mi>x</mi></mfrac> <mo>)</mo></mrow> <mo>=</mo> <mo>-</mo> <mi>l</mi>
    <mi>o</mi> <mi>g</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    |'
  prefs: []
  type: TYPE_TB
- en: Euler’s Number and Natural Logarithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a special number that shows up quite a bit in math called Euler’s number
    <math alttext="e"><mi>e</mi></math> . It is a special number much like Pi <math
    alttext="pi"><mi>π</mi></math> and is approximately 2.71828\. <math alttext="e"><mi>e</mi></math>
    is used a lot because it mathematically simplifies a lot of problems. We will
    cover <math alttext="e"><mi>e</mi></math> in the context of exponents and logarithms.
  prefs: []
  type: TYPE_NORMAL
- en: Euler’s Number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back in high school, my calculus teacher demonstrated Euler’s number in several
    exponential problems. Finally I asked, “Mr. Nowe, what is <math alttext="e"><mi>e</mi></math>
    anyway? Where does it come from?” I remember never being fully satisfied with
    the explanations involving rabbit populations and other natural phenomena. I hope
    to give a more satisfying explanation here.
  prefs: []
  type: TYPE_NORMAL
- en: Here is how I like to discover Euler’s number. Let’s say you loan $100 to somebody
    with 20% interest annually. Typically, interest will be compounded monthly, so
    the interest each month would be <math alttext=".20 slash 12 equals .01666"><mrow><mo>.</mo>
    <mn>20</mn> <mo>/</mo> <mn>12</mn> <mo>=</mo> <mo>.</mo> <mn>01666</mn></mrow></math>
    . How much will the loan balance be after two years? To keep it simple, let’s
    assume the loan does not require payments (and no payments are made) until the
    end of those two years.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting together the exponent concepts we learned so far (or perhaps pulling
    out a finance textbook), we can come up with a formula to calculate interest.
    It consists of a balance *A* for a starting investment *P*, interest rate *r*,
    time span *t* (number of years), and periods *n* (number of months in each year).
    Here is the formula:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper A equals upper P times left-parenthesis 1 plus StartFraction
    r Over n EndFraction right-parenthesis Superscript n t" display="block"><mrow><mi>A</mi>
    <mo>=</mo> <mi>P</mi> <mo>×</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mi>r</mi>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mrow><mi>n</mi><mi>t</mi></mrow></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'So if we were to compound interest every month, the loan would grow to $148.69
    as calculated here:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block" class="mathml_bottom_space"><mrow><mi>A</mi> <mo>=</mo>
    <mi>P</mi> <mo>×</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mi>r</mi>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mrow><mi>n</mi><mi>t</mi></mrow></msup></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><mn>100</mn> <mo>×</mo>
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mn>.20</mn></mrow> <mn>12</mn></mfrac><mo>)</mo></mrow>
    <mrow><mn>12</mn><mo>×</mo><mn>2</mn></mrow></msup> <mo>=</mo> <mn>148.6914618</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: If you want to do this in Python, try it out with the code in [Example 1-13](#itQmQTaEjf).
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-13\. Calculating compound interest in Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'But what if we compounded interest daily? What happens then? Change *n* to
    365:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block" class="mathml_bottom_space"><mrow><mi>A</mi> <mo>=</mo>
    <mi>P</mi> <mo>×</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mi>r</mi>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mrow><mi>n</mi><mi>t</mi></mrow></msup></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><mn>100</mn> <mo>×</mo>
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mn>.20</mn></mrow> <mn>365</mn></mfrac><mo>)</mo></mrow>
    <mrow><mn>365</mn><mo>×</mo><mn>2</mn></mrow></msup> <mo>=</mo> <mn>149.</mn>
    <mn>1661279</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Huh! If we compound our interest daily instead of monthly, we would earn 47.4666
    cents more at the end of two years. If we got greedy why not compound every hour
    as shown next? Will that give us even more? There are 8,760 hours in a year, so
    set *n* to that value:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block" class="mathml_bottom_space"><mrow><mi>A</mi> <mo>=</mo>
    <mi>P</mi> <mo>×</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mi>r</mi>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mrow><mi>n</mi><mi>t</mi></mrow></msup></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><mn>100</mn> <mo>×</mo>
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mn>.20</mn></mrow> <mn>8760</mn></mfrac><mo>)</mo></mrow>
    <mrow><mn>8760</mn><mo>×</mo><mn>2</mn></mrow></msup> <mo>=</mo> <mn>149.</mn>
    <mn>1817886</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Ah, we squeezed out roughly 2 cents more in interest! But are we experiencing
    a diminishing return? Let’s try to compound every minute! Note that there are
    525,600 minutes in a year, so let’s set that value to *n*:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block" class="mathml_bottom_space"><mrow><mi>A</mi> <mo>=</mo>
    <mi>P</mi> <mo>×</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mi>r</mi>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mrow><mi>n</mi><mi>t</mi></mrow></msup></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><mn>100</mn> <mo>×</mo>
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mn>.20</mn></mrow> <mn>525600</mn></mfrac><mo>)</mo></mrow>
    <mrow><mn>525600</mn><mo>×</mo><mn>2</mn></mrow></msup> <mo>=</mo> <mn>149.</mn>
    <mn>1824584</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: OK, we are only gaining smaller and smaller fractions of a cent the more frequently
    we compound. So if I keep making these periods infinitely smaller to the point
    of compounding continuously, where does this lead?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me introduce you to Euler’s number <math alttext="e"><mi>e</mi></math>
    , which is approximately 2.71828\. Here is the formula to compound “continuously,”
    meaning we are compounding nonstop:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper A equals upper P times e Superscript r t" display="block"><mrow><mi>A</mi>
    <mo>=</mo> <mi>P</mi> <mo>×</mo> <msup><mi>e</mi> <mrow><mi>r</mi><mi>t</mi></mrow></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to our example, let’s calculate the balance of our loan after two
    years if we compounded continuously:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mrow><mi>A</mi> <mo>=</mo> <mi>P</mi> <mo>×</mo> <msup><mi>e</mi>
    <mrow><mi>r</mi><mi>t</mi></mrow></msup></mrow></math> <math display="block"><mrow><mi>A</mi>
    <mo>=</mo> <mn>100</mn> <mo>×</mo> <msup><mi>e</mi> <mrow><mo>.</mo><mn>20</mn><mo>×</mo><mn>2</mn></mrow></msup>
    <mo>=</mo> <mn>149.</mn> <mn>1824698</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: This is not too surprising considering compounding every minute got us a balance
    of 149.1824584\. That got us really close to our value of 149.1824698 when compounding
    continuously.
  prefs: []
  type: TYPE_NORMAL
- en: Typically you use <math alttext="e"><mi>e</mi></math> as an exponent base in
    Python, Excel, and other platforms using the `exp()` function. You will find that
    <math alttext="e"><mi>e</mi></math> is so commonly used, it is the default base
    for both exponent and logarithm functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 1-14](#lLjrCcMcPg) calculates continuous interest in Python using
    the `exp()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-14\. Calculating continuous interest in Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'So where do we derive this constant <math alttext="e"><mi>e</mi></math> ? Compare
    the compounding interest formula and the continuous interest formula. They structurally
    look similar but have some differences:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>A</mi>
    <mo>=</mo> <mi>P</mi> <mo>×</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mi>r</mi>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mrow><mi>n</mi><mi>t</mi></mrow></msup></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>A</mi>
    <mo>=</mo> <mi>P</mi> <mo>×</mo> <msup><mi>e</mi> <mrow><mi>r</mi><mi>t</mi></mrow></msup></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'More technically speaking, <math alttext="e"><mi>e</mi></math> is the resulting
    value of the expression <math alttext="left-parenthesis 1 plus StartFraction 1
    Over n EndFraction right-parenthesis Superscript n"><msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mi>n</mi></msup></math> as *n* forever gets
    bigger and bigger, thus approaching infinity. Try experimenting with increasingly
    large values for *n*. By making it larger and larger you will notice something:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block" class="mathml_bottom_space"><msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mi>n</mi></msup></math> <math display="block"
    class="mathml_bottom_space"><mrow><msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mn>100</mn></mfrac><mo>)</mo></mrow> <mn>100</mn></msup> <mo>=</mo> <mn>2.70481382942</mn></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mn>1000</mn></mfrac><mo>)</mo></mrow> <mn>1000</mn></msup> <mo>=</mo> <mn>2.71692393224</mn></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mn>10000</mn></mfrac><mo>)</mo></mrow> <mn>10000</mn></msup> <mo>=</mo> <mn>2.71814592682</mn></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mn>10000000</mn></mfrac><mo>)</mo></mrow> <mn>10000000</mn></msup> <mo>=</mo>
    <mn>2.71828169413</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: As you make *n* larger, there is a diminishing return and it converges approximately
    on the value 2.71828, which is our value <math alttext="e"><mi>e</mi></math> .
    You will find this <math alttext="e"><mi>e</mi></math> used not just in studying
    populations and their growth. It plays a key role in many areas of mathematics.
  prefs: []
  type: TYPE_NORMAL
- en: Later in the book, we will use Euler’s number to build normal distributions
    in [Chapter 3](ch03.xhtml#ch03) and logistic regressions in [Chapter 6](ch06.xhtml#ch06).
  prefs: []
  type: TYPE_NORMAL
- en: Natural Logarithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we use <math alttext="e"><mi>e</mi></math> as our base for a logarithm,
    we call it a *natural logarithm*. Depending on the platform, we may use `ln()`
    instead of `log()` to specify a natural logarithm. So rather than express a natural
    logarithm expressed as <math alttext="l o g Subscript e Baseline Baseline 10"><mrow><mi>l</mi>
    <mi>o</mi> <msub><mi>g</mi> <mi>e</mi></msub> <mn>10</mn></mrow></math> to find
    the power raised on <math alttext="e"><mi>e</mi></math> to get 10, we would shorthand
    it as <math alttext="l n left-parenthesis 10 right-parenthesis"><mrow><mi>l</mi>
    <mi>n</mi> <mo>(</mo> <mn>10</mn> <mo>)</mo></mrow></math> :'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="l o g Subscript e Baseline Baseline 10 equals l n left-parenthesis
    10 right-parenthesis" display="block"><mrow><mi>l</mi> <mi>o</mi> <msub><mi>g</mi>
    <mi>e</mi></msub> <mn>10</mn> <mo>=</mo> <mi>l</mi> <mi>n</mi> <mrow><mo>(</mo>
    <mn>10</mn> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: However, in Python, a natural logarithm is specified by the `log()` function.
    As discussed earlier, the default base for the `log()` function is <math alttext="e"><mi>e</mi></math>
    . Just leave the second argument for the base empty and it will default to using
    <math alttext="e"><mi>e</mi></math> as the base shown in [Example 1-15](#OmWoPUVAot).
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-15\. Calculating the natural logarithm of 10 in Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We will use <math alttext="e"><mi>e</mi></math> in a number of places throughout
    this book. Feel free to experiment with exponents and logarithms using Excel,
    Python, Desmos.com, or any other calculation platform of your choice. Make graphs
    and get comfortable with what these functions look like.
  prefs: []
  type: TYPE_NORMAL
- en: Limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen with Euler’s number, some interesting ideas emerge when we forever
    increase or decrease an input variable and the output variable keeps approaching
    a value but never reaching it. Let’s formally explore this idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take this function, which is plotted in [Figure 1-5](#HvAcMVmcpE):'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f left-parenthesis x right-parenthesis equals StartFraction 1
    Over x EndFraction" display="block"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <mi>x</mi></mfrac></mrow></math>![emds
    0105](Images/emds_0105.png)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1-5\. A function that forever approaches 0 but never reaches 0
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We are looking only at positive *x* values. Notice that as *x* forever increases,
    *f(x)* gets closer to 0. Fascinatingly, *f(x)* never actually reaches 0\. It just
    forever keeps getting closer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore the fate of this function is, as <math alttext="x"><mi>x</mi></math>
    forever extends into infinity, it will keep getting closer to 0 but never reach
    0\. The way we express a value that is forever being approached, but never reached,
    is through a limit:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="limit Underscript x right-arrow normal infinity Endscripts StartFraction
    1 Over x EndFraction equals 0" display="block"><mrow><munder><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mi>∞</mi></mrow></munder> <mfrac><mn>1</mn>
    <mi>x</mi></mfrac> <mo>=</mo> <mn>0</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: The way we read this is “as x approaches infinity, the function 1/x approaches
    0 (but never reaches 0).” You will see this kind of “approach but never touch”
    behavior a lot, especially when we dive into derivatives and integrals.
  prefs: []
  type: TYPE_NORMAL
- en: Using SymPy, we can calculate what value we approach for <math alttext="f left-parenthesis
    x right-parenthesis equals StartFraction 1 Over x EndFraction"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <mi>x</mi></mfrac></mrow></math>
    as *x* approaches infinity <math alttext="normal infinity"><mi>∞</mi></math> ([Example 1-16](#PklTKwuIQJ)).
    Note that <math alttext="normal infinity"><mi>∞</mi></math> is cleverly expressed
    in SymPy with `oo`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-16\. Using SymPy to calculate limits
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you have seen, we discovered Euler’s number <math alttext="e"><mi>e</mi></math>
    this way too. It is the result of forever extending *n* into infinity for this
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block" class="mathml_bottom_space"><mrow><munder><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>n</mi><mo>→</mo><mi>∞</mi></mrow></munder> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mi>n</mi></msup> <mo>=</mo> <mi>e</mi> <mo>=</mo>
    <mn>2.</mn> <mn>71828169413</mn> <mo>...</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Funnily enough, when we calculate Euler’s number with limits in SymPy (shown
    in the following code), SymPy immediately recognizes it as Euler’s number. We
    can call `evalf()` so we can actually display it as a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Derivatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s go back to talking about functions and look at them from a calculus perspective,
    starting with derivatives. A *derivative* tells the slope of a function, and it
    is useful to measure the rate of change at any point in a function.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we care about derivatives? They are often used in machine learning and
    other mathematical algorithms, especially with gradient descent. When the slope
    is 0, that means we are at the minimum or maximum of an output variable. This
    concept will be useful later when we do linear regression ([Chapter 5](ch05.xhtml#ch05)),
    logistic regression ([Chapter 6](ch06.xhtml#ch06)), and neural networks ([Chapter 7](ch07.xhtml#ch07)).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a simple example. Let’s take a look at the function <math alttext="f
    left-parenthesis x right-parenthesis equals x squared"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
    in [Figure 1-6](#rLSwvtqPRa). How “steep” is the curve at *x = 2*?
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we can measure “steepness” at any point in the curve, and we can
    visualize this with a tangent line. Think of a *tangent line* as a straight line
    that “just touches” the curve at a given point. It also provides the slope at
    a given point. You can crudely estimate a tangent line at a given x-value by creating
    a line intersecting that x-value and a *really close* neighboring x-value on the
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Take *x* = 2 and a nearby value *x* = 2.1, which when passed to the function
    <math alttext="f left-parenthesis x right-parenthesis equals x squared"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
    will yield *f*(2) = 4 and *f*(2.1) = 4.41 as shown in [Figure 1-7](#pptiNCfVKL).
    The resulting line that passes through these two points has a slope of 4.1.
  prefs: []
  type: TYPE_NORMAL
- en: '![emds 0106](Images/emds_0106.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-6\. Observing steepness at a given part of the function
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![emds 0107](Images/emds_0107.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-7\. A crude way of calculating slope
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can quickly calculate the slope <math alttext="m"><mi>m</mi></math> between
    two points using the simple rise-over-run formula:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block" class="mathml_bottom_space"><mrow><mi>m</mi> <mo>=</mo>
    <mfrac><mrow><msub><mi>y</mi> <mn>2</mn></msub> <mo>-</mo><msub><mi>y</mi> <mn>1</mn></msub></mrow>
    <mrow><msub><mi>x</mi> <mn>2</mn></msub> <mo>-</mo><msub><mi>x</mi> <mn>1</mn></msub></mrow></mfrac></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><mi>m</mi> <mo>=</mo>
    <mfrac><mrow><mn>4.</mn><mn>41</mn><mo>-</mo><mn>4.</mn><mn>0</mn></mrow> <mrow><mn>2.</mn><mn>1</mn><mo>-</mo><mn>2.</mn><mn>0</mn></mrow></mfrac></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><mi>m</mi> <mo>=</mo>
    <mn>4.1</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: If I made the *x* step between the two points even smaller, like *x* = 2 and
    *x* = 2.00001, which would result in *f*(2) = 4 and *f*(2.00001) = 4.00004, that
    would get *really* close to the actual slope of 4\. So the smaller the step is
    to the neighboring value, the closer we get to the slope value at a given point
    in the curve. Like so many important concepts in math, we find something meaningful
    as we approach infinitely large or infinitely small values.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 1-17](#MHkbJbUrcu) shows a derivative calculator implemented in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-17\. A derivative calculator in Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now the good news is there is a cleaner way to calculate the slope anywhere
    on a function. We have already been using SymPy to plot graphs, but I will show
    you how it can also do tasks like derivatives using the magic of symbolic computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you encounter an exponential function like <math alttext="f left-parenthesis
    x right-parenthesis equals x squared"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
    the derivative function will make the exponent a multiplier and then decrement
    the exponent by 1, leaving us with the derivative <math alttext="StartFraction
    d Over d x EndFraction x squared equals 2 x"><mrow><mfrac><mi>d</mi> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>=</mo> <mn>2</mn> <mi>x</mi></mrow></math>
    . The <math alttext="StartFraction d Over d x EndFraction"><mfrac><mi>d</mi> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></math>
    indicates a *derivative with respect to x*, which says we are building a derivative
    targeting the x-value to get its slope. So if we want to find the slope at *x*
    = 2, and we have the derivative function, we just plug in that x-value to get
    the slope:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfrac><mi>d</mi>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mfrac><mi>d</mi> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>=</mo> <mn>2</mn> <mi>x</mi></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfrac><mi>d</mi>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mi>f</mi> <mrow><mo>(</mo> <mn>2</mn>
    <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <mrow><mo>(</mo> <mn>2</mn> <mo>)</mo></mrow>
    <mo>=</mo> <mn>4</mn></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: If you intend to learn these rules to hand-calculate derivatives, there are
    plenty of calculus books for that. But there are some nice tools to calculate
    derivatives symbolically for you. The Python library SymPy is free and open source,
    and it nicely adapts to using the Python syntax. [Example 1-18](#UGrqvRRRqf) shows
    how to calculate the derivative for <math alttext="f left-parenthesis x right-parenthesis
    equals x squared"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math> on SymPy.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-18\. Calculating a derivative in SymPy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Wow! So by declaring variables using the `symbols()` function in SymPy, I can
    then proceed to use normal Python syntax to declare my function. After that I
    can use `diff()` to calculate the derivative function. In [Example 1-19](#PocSKudWut)
    we can then take our derivative function back to plain Python and simply declare
    it as another function.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-19\. A derivative calculator in Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you want to keep using SymPy, you can call the `subs()` function to swap
    the *x* variable with the value `2` as shown in [Example 1-20](#tpcTiPrmOA).
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-20\. Using the substitution feature in SymPy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Partial Derivatives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another concept we will encounter in this book is *partial derivatives*, which
    we will use in Chapters [5](ch05.xhtml#ch05), [6](ch06.xhtml#ch06), and [7](ch07.xhtml#ch07).
    These are derivatives of functions that have multiple input variables.
  prefs: []
  type: TYPE_NORMAL
- en: Think of it this way. Rather than finding the slope on a one-dimensional function,
    we have slopes with respect to multiple variables in several directions. For each
    given variable derivative, we assume the other variables are held constant. Take
    a look at the 3D graph of <math alttext="f left-parenthesis x comma y right-parenthesis
    equals 2 x cubed plus 3 y cubed"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <msup><mi>x</mi>
    <mn>3</mn></msup> <mo>+</mo> <mn>3</mn> <msup><mi>y</mi> <mn>3</mn></msup></mrow></math>
    in [Figure 1-8](#tMGIGsWCjE), and you will see we have slopes in two directions
    for two variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take the function <math alttext="f left-parenthesis x comma y right-parenthesis
    equals 2 x cubed plus 3 y cubed"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <msup><mi>x</mi>
    <mn>3</mn></msup> <mo>+</mo> <mn>3</mn> <msup><mi>y</mi> <mn>3</mn></msup></mrow></math>
    . The *x* and *y* variable each get their own derivatives <math alttext="StartFraction
    d Over d x EndFraction"><mfrac><mi>d</mi> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></math>
    and <math alttext="StartFraction d Over d y EndFraction"><mfrac><mi>d</mi> <mrow><mi>d</mi><mi>y</mi></mrow></mfrac></math>
    . These represent the slope values with respect to each variable on a multidimensional
    surface. We technically call these “slopes” *gradients* when dealing with multiple
    dimensions. These are the derivatives for *x* and *y*, followed by the SymPy code
    to calculate those derivatives:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mn>2</mn> <msup><mi>x</mi> <mn>3</mn></msup> <mo>+</mo> <mn>3</mn> <msup><mi>y</mi>
    <mn>3</mn></msup></mrow></mtd></mtr></mtable></math> <math display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfrac><mi>d</mi> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <mn>2</mn> <msup><mi>x</mi> <mn>3</mn></msup> <mo>+</mo> <mn>3</mn> <msup><mi>y</mi>
    <mn>3</mn></msup> <mo>=</mo> <mn>6</mn> <msup><mi>x</mi> <mn>2</mn></msup></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfrac><mi>d</mi>
    <mrow><mi>d</mi><mi>y</mi></mrow></mfrac> <mn>2</mn> <msup><mi>x</mi> <mn>3</mn></msup>
    <mo>+</mo> <mn>3</mn> <msup><mi>y</mi> <mn>3</mn></msup> <mo>=</mo> <mn>9</mn>
    <msup><mi>y</mi> <mn>2</mn></msup></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 1-21](#peFJLntrPK) and [Figure 1-8](#tMGIGsWCjE) show how we calculate
    the partial derivatives for *x* and *y*, respectively, with SymPy.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-21\. Calculating partial derivatives with SymPy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![emds 0108](Images/emds_0108.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-8\. Plotting a three-dimensional exponential function
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: So for (*x*,*y*) values (1,2), the slope with respect to *x* is <math alttext="6
    left-parenthesis 1 right-parenthesis equals 6"><mrow><mn>6</mn> <mo>(</mo> <mn>1</mn>
    <mo>)</mo> <mo>=</mo> <mn>6</mn></mrow></math> and the slope with respect to *y*
    is <math alttext="9 left-parenthesis 2 right-parenthesis squared equals 36"><mrow><mn>9</mn>
    <msup><mrow><mo>(</mo><mn>2</mn><mo>)</mo></mrow> <mn>2</mn></msup> <mo>=</mo>
    <mn>36</mn></mrow></math> .
  prefs: []
  type: TYPE_NORMAL
- en: The Chain Rule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 7](ch07.xhtml#ch07) when we build a neural network, we are going
    to need a special math trick called the chain rule. When we compose the neural
    network layers, we will have to untangle the derivatives from each layer. But
    for now let’s learn the chain rule with a simple algebraic example. Let’s say
    you are given two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>y</mi>
    <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>1</mn></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>z</mi>
    <mo>=</mo> <msup><mi>y</mi> <mn>3</mn></msup> <mo>-</mo> <mn>2</mn></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that these two functions are linked, because the *y* is the output variable
    in the first function but is the input variable in the second. This means we can
    substitute the first function *y* into the second function *z* like this:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="z equals left-parenthesis x squared plus 1 right-parenthesis
    cubed minus 2" display="block"><mrow><mi>z</mi> <mo>=</mo> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>3</mn></msup> <mo>-</mo>
    <mn>2</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: So what is the derivative for *z* with respect to *x*? We already have the substitution
    expressing *z* in terms of *x*. Let’s use SymPy to calculate that in [Example 1-24](#OKUFmnIPKM).
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-24\. Finding the derivative of *z* with respect to *x*
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'So our derivative for *z* with respect to *x* is <math alttext="6 x left-parenthesis
    x squared plus 1 right-parenthesis squared"><mrow><mn>6</mn> <mi>x</mi> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>2</mn></msup></mrow></math>
    :'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfrac><mrow><mi>d</mi><mi>z</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mrow><mo>(</mo> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>3</mn></msup> <mo>-</mo>
    <mn>2</mn> <mo>)</mo></mrow></mrow></mtd></mtr></mtable></math> <math display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mo>=</mo> <mn>6</mn>
    <mi>x</mi> <msup><mrow><mo>(</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'But look at this. Let’s start over and take a different approach. If we take
    the derivatives of the *y* and *z* functions separately, and then multiply them
    together, this also produces the derivative of *z* with respect to *x*! Let’s
    try it:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d y Over d x EndFraction left-parenthesis x squared
    plus 1 right-parenthesis equals 2 x" display="block"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mrow><mo>(</mo> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <mi>x</mi></mrow></math><math
    alttext="StartFraction d z Over d y EndFraction left-parenthesis y cubed minus
    2 right-parenthesis equals 3 y squared" display="block"><mrow><mfrac><mrow><mi>d</mi><mi>z</mi></mrow>
    <mrow><mi>d</mi><mi>y</mi></mrow></mfrac> <mrow><mo>(</mo> <msup><mi>y</mi> <mn>3</mn></msup>
    <mo>-</mo> <mn>2</mn> <mo>)</mo></mrow> <mo>=</mo> <mn>3</mn> <msup><mi>y</mi>
    <mn>2</mn></msup></mrow></math><math alttext="StartFraction d z Over d x EndFraction
    equals left-parenthesis 2 x right-parenthesis left-parenthesis 3 y squared right-parenthesis
    equals 6 x y squared" display="block"><mrow><mfrac><mrow><mi>d</mi><mi>z</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mo>=</mo> <mrow><mo>(</mo> <mn>2</mn>
    <mi>x</mi> <mo>)</mo></mrow> <mrow><mo>(</mo> <mn>3</mn> <msup><mi>y</mi> <mn>2</mn></msup>
    <mo>)</mo></mrow> <mo>=</mo> <mn>6</mn> <mi>x</mi> <msup><mi>y</mi> <mn>2</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: All right, <math alttext="6 x y squared"><mrow><mn>6</mn> <mi>x</mi> <msup><mi>y</mi>
    <mn>2</mn></msup></mrow></math> may not look like <math alttext="6 x left-parenthesis
    x squared plus 1 right-parenthesis squared"><mrow><mn>6</mn> <mi>x</mi> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>2</mn></msup></mrow></math>
    , but that’s only because we have not substituted the *y* function yet. Do that
    so the entire <math alttext="StartFraction d z Over d x EndFraction"><mfrac><mrow><mi>d</mi><mi>z</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></math> derivative is expressed in terms
    of *x* without *y*.
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d z Over d x EndFraction equals 6 x y squared equals
    6 x left-parenthesis x squared plus 1 right-parenthesis squared" display="block"><mrow><mfrac><mrow><mi>d</mi><mi>z</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mo>=</mo> <mn>6</mn> <mi>x</mi> <msup><mi>y</mi>
    <mn>2</mn></msup> <mo>=</mo> <mn>6</mn> <mi>x</mi> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>2</mn></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Now we see we got the same derivative function <math alttext="6 x left-parenthesis
    x squared plus 1 right-parenthesis squared"><mrow><mn>6</mn> <mi>x</mi> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>2</mn></msup></mrow></math>
    !
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the *chain rule*, which says that for a given function *y* (with input
    variable *x*) composed into another function *z* (with input variable *y*), we
    can find the derivative of *z* with respect to *x* by multiplying the two respective
    derivatives together:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction d z Over d x EndFraction equals StartFraction d
    z Over d y EndFraction times StartFraction d y Over d x EndFraction" display="block"><mrow><mfrac><mrow><mi>d</mi><mi>z</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mo>=</mo> <mfrac><mrow><mi>d</mi><mi>z</mi></mrow>
    <mrow><mi>d</mi><mi>y</mi></mrow></mfrac> <mo>×</mo> <mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 1-25](#qOhQAptgSn) shows the SymPy code that makes this comparison,
    showing the derivative from the chain rule is equal to the derivative of the substituted
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-25\. Calculating the derivative dz/dx with and without the chain rule,
    but still getting the same answer
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The chain rule is a key part of training a neural network with the proper weights
    and biases. Rather than untangle the derivative of each node in a nested onion
    fashion, we can multiply the derivatives across each node instead, which is mathematically
    a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: Integrals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The opposite of a derivative is an *integral*, which finds the area under the
    curve for a given range. In Chapters [2](ch02.xhtml#ch02) and [3](ch03.xhtml#ch03),
    we will be finding the areas under probability distributions. Although we will
    not use integrals directly, and instead will use cumulative density functions
    that are already integrated, it is good to be aware of how integrals find areas
    under curves. [Appendix A](app01.xhtml#appendix) contains examples of using this
    approach on probability distributions.
  prefs: []
  type: TYPE_NORMAL
- en: I want to take an intuitive approach for learning integrals called the Reimann
    Sums, one that flexibly adapts to any continuous function. First, let’s point
    out that finding the area for a range under a straight line is easy. Let’s say
    I have a function <math alttext="f left-parenthesis x right-parenthesis equals
    2 x"><mrow><mi>f</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mn>2</mn> <mi>x</mi></mrow></math>
    and I want to find the area under the line between 0 and 1, as shaded in [Figure 1-9](#NmOJtvwvfq).
  prefs: []
  type: TYPE_NORMAL
- en: '![emds 0109](Images/emds_0109.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-9\. Calculating an area under a linear function
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Notice that I am finding the area bounded between the line and the x-axis,
    and in the *x* range 0.0 to 1.0\. If you recall basic geometry formulas, the area
    *A* for a triangle is <math alttext="upper A equals one-half b h"><mrow><mi>A</mi>
    <mo>=</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mi>b</mi> <mi>h</mi></mrow></math>
    where *b* is the length of the base and *h* is the height. We can visually spot
    that <math alttext="b equals 1"><mrow><mi>b</mi> <mo>=</mo> <mn>1</mn></mrow></math>
    and <math alttext="h equals 2"><mrow><mi>h</mi> <mo>=</mo> <mn>2</mn></mrow></math>
    . So plugging into the formula, we get for our area 1.0 as calculated here:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>A</mi>
    <mo>=</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mi>b</mi> <mi>h</mi></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>A</mi>
    <mo>=</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mo>*</mo> <mn>1</mn> <mo>*</mo>
    <mn>2</mn></mrow></mtd></mtr></mtable></math> <math display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><mi>A</mi> <mo>=</mo> <mn>1</mn></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'That was not bad, right? But let’s look at a function that is difficult to
    find the area under: <math alttext="f left-parenthesis x right-parenthesis equals
    x squared plus 1"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>1</mn></mrow></math>
    . What is the area between 0 and 1 as shaded in [Figure 1-10](#JMHNlAJoKM)?'
  prefs: []
  type: TYPE_NORMAL
- en: '![emds 0110](Images/emds_0110.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-10\. Calculating area under nonlinear functions is less straightforward
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Again we are interested in the area below the curve and above the x-axis, only
    within the *x* range between 0 and 1\. The curviness here does not give us a clean
    geometric formula to find the area, but here is a clever little hack you can do.
  prefs: []
  type: TYPE_NORMAL
- en: What if we packed five rectangles of equal length under the curve as shown in
    [Figure 1-11](#SSqkIgwVUt), where the height of each one extends from the x-axis
    to where the midpoint touches the curve?
  prefs: []
  type: TYPE_NORMAL
- en: The area of a rectangle is <math alttext="upper A equals length times width"><mrow><mi>A</mi>
    <mo>=</mo> <mtext>length</mtext> <mo>×</mo> <mtext>width</mtext></mrow></math>
    , so we could easily sum the areas of the rectangles. Would that give us a good
    approximation of the area under the curve? What if we packed 100 rectangles? 1,000?
    100,000? As we increase the number of rectangles while decreasing their width,
    would we not get closer to the area under the curve? Yes we would, and it is yet
    another case where we increase/decrease something toward infinity to approach
    an actual value.
  prefs: []
  type: TYPE_NORMAL
- en: '![emds 0111](Images/emds_0111.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-11\. Packing rectangles under a curve to approximate area
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s try it out in Python. First we need a function that approximates an integral
    that we will call `approximate_integral()`. The arguments `a` and `b` will specify
    the min and max of the *x* range, respectively. `n` will be the number of rectangles
    to pack, and `f` will be the function we are integrating. We implement the function
    in [Example 1-26](#RnPCPGGrPc), and then use it to integrate our function <math
    alttext="f left-parenthesis x right-parenthesis equals x squared plus 1"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>1</mn></mrow></math> with five rectangles, between 0.0 and 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-26\. An integral approximation in Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So we get an area of 1.33\. What happens if we use 1,000 rectangles? Let’s try
    it out in [Example 1-27](#IUSbAgIHSL).
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-27\. Another integral approximation in Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: OK, we are getting some more precision here, and getting some more decimal places.
    What about one million rectangles as shown in [Example 1-28](#VUJaeUBsNO)?
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-28\. Yet another integral approximation in Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: OK, I think we are getting a diminishing return here and converging on the value
    <math display="inline"><mrow><mn>1.</mn> <mover><mn>333</mn> <mo>¯</mo></mover></mrow></math>
    where the “.333” part is forever recurring. If this were a rational number, it
    is likely 4/3 = <math display="inline"><mrow><mn>1.</mn> <mover><mn>333</mn> <mo>¯</mo></mover></mrow></math>
    . As we increase the number of rectangles, the approximation starts to reach its
    limit at smaller and smaller decimals.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some intuition on what we are trying to achieve and why, let’s
    do a more exact approach with SymPy, which happens to support rational numbers,
    in [Example 1-29](#dLhjbaolNV).
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-29\. Using SymPy to perform integration
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Cool! So the area actually is 4/3, which is what our previous method converged
    on. Unfortunately, plain Python (and many programming languages) only support
    decimals, but computer algebra systems like SymPy give us exact rational numbers.
    We will be using integrals to find areas under curves in Chapters [2](ch02.xhtml#ch02)
    and [3](ch03.xhtml#ch03), although we will have scikit-learn do the work for us.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we covered some foundations we will use for the rest of this
    book. From number theory to logarithms and calculus integrals, we highlighted
    some important mathematical concepts relevant to data science, machine learning,
    and analytics. You may have questions about why these concepts are useful. That
    will come next!
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to discuss probability, take a little time to skim these concepts
    one more time and then do the following exercises. You can always revisit this
    chapter as you progress through this book and refresh as necessary when you start
    applying these mathematical ideas.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is the value 62.6738 rational or irrational? Why or why not?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Evaluate the expression: <math alttext="10 Superscript 7 Baseline 10 Superscript
    negative 5"><mrow><msup><mn>10</mn> <mn>7</mn></msup> <msup><mn>10</mn> <mrow><mo>-</mo><mn>5</mn></mrow></msup></mrow></math>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Evaluate the expression: <math alttext="81 Superscript one-half"><msup><mn>81</mn>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac></msup></math>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Evaluate the expression: <math alttext="25 Superscript three-halves"><msup><mn>25</mn>
    <mfrac><mn>3</mn> <mn>2</mn></mfrac></msup></math>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assuming no payments are made, how much would a $1,000 loan be worth at 5% interest
    compounded monthly after 3 years?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assuming no payments are made, how much would a $1,000 loan be worth at 5% interest
    compounded continuously after 3 years?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the function <math alttext="f left-parenthesis x right-parenthesis equals
    3 x squared plus 1"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>3</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>1</mn></mrow></math>
    what is the slope at *x* = 3?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the function <math alttext="f left-parenthesis x right-parenthesis equals
    3 x squared plus 1"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>3</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>1</mn></mrow></math>
    what is the area under the curve for *x* between 0 and 2?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers are in [Appendix B](app02.xhtml#exercise_answers).
  prefs: []
  type: TYPE_NORMAL
