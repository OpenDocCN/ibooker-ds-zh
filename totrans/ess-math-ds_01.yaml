- en: Chapter 1\. Basic Math and Calculus Review
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 基础数学和微积分复习
- en: 'We will kick off the first chapter covering what numbers are and how variables
    and functions work on a Cartesian system. We will then cover exponents and logarithms.
    After that, we will learn the two basic operations of calculus: derivatives and
    integrals.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始第一章，介绍数字是什么，以及变量和函数在笛卡尔坐标系上是如何运作的。然后我们将讨论指数和对数。之后，我们将学习微积分的两个基本运算：导数和积分。
- en: Before we dive into the applied areas of essential math such as probability,
    linear algebra, statistics, and machine learning, we should probably review a
    few basic math and calculus concepts. Before you drop this book and run screaming,
    do not worry! I will present how to calculate derivatives and integrals for a
    function in a way you were probably not taught in college. We have Python on our
    side, not a pencil and paper. Even if you are not familiar with derivatives and
    integrals, you still do not need to worry.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨基本数学的应用领域，如概率、线性代数、统计学和机器学习之前，我们可能需要复习一些基本数学和微积分概念。在您放下这本书并尖叫逃跑之前，请不要担心！我将以一种您可能在大学里没有学到的方式呈现如何计算函数的导数和积分。我们有Python在我们这边，而不是铅笔和纸。即使您对导数和积分不熟悉，您也不需要担心。
- en: I will make these topics as tight and practical as possible, focusing only on
    what will help us in later chapters and what falls under the “essential math”
    umbrella.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我将尽可能紧凑和实用地讨论这些主题，只关注对我们以后章节有帮助的内容和属于“基本数学”范畴的内容。
- en: This Is Not a Full Math Crash Course!
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这不是一个完整的数学速成课程！
- en: This is by no means a comprehensive review of high school and college math.
    If you want that, a great book to check out is *No Bullshit Guide to Math and
    Physics* by Ivan Savov (pardon my French). The first few chapters contain the
    best crash course on high school and college math I have ever seen. The book *Mathematics
    1001* by Dr. Richard Elwes has some great content as well, and in bite-sized explanations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝不是高中和大学数学的全面复习。如果您想要这样的内容，可以查看伊万·萨沃夫（请原谅我的法语）的《数学和物理无废话指南》。前几章包含了我见过的最好的高中和大学数学速成课程。理查德·埃尔韦斯博士的《数学1001》也有一些很棒的内容，并且解释得很简洁。
- en: Number Theory
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数论
- en: What are numbers? I promise to not be too philosophical in this book, but are
    numbers not a construct we have defined? Why do we have the digits 0 through 9,
    and not have more digits than that? Why do we have fractions and decimals and
    not just whole numbers? This area of math where we muse about numbers and why
    we designed them a certain way is known as number theory.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 数字是什么？我承诺在这本书中不会太过哲学，但数字不是我们定义的构造吗？为什么我们有0到9这些数字，而不是更多的数字？为什么我们有分数和小数，而不只是整数？我们思考数字以及为什么以某种方式设计它们的数学领域被称为数论。
- en: '*Number theory* goes all the way back to ancient times, when mathematicians
    studied different number systems, and it explains why we have accepted them the
    way we do today. Here are different number systems that you may recognize:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*数论*可以追溯到古代，当时数学家研究不同的数字系统，它解释了为什么我们今天接受它们的方式。以下是您可能认识的不同数字系统：'
- en: Natural numbers
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 自然数
- en: These are the numbers 1, 2, 3, 4, 5…and so on. Only positive numbers are included
    here, and they are the earliest known system. Natural numbers are so ancient cavemen
    scratched tally marks on bones and cave walls to keep records.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是数字1、2、3、4、5……等等。这里只包括正数，它们是已知最早的系统。自然数如此古老，以至于原始人在骨头和洞穴墙壁上刻划记号来记录。
- en: Whole numbers
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 整数
- en: Adding to natural numbers, the concept of “0” was later accepted; we call these
    “whole numbers.” The Babylonians also developed the useful idea for place-holding
    notation for empty “columns” on numbers greater than 9, such as “10,” “1,000,”
    or “1,090.” Those zeros indicate no value occupying that column.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自然数，后来还接受了“0”的概念；我们称这些为“整数”。巴比伦人还开发了有用的空“列”占位符的概念，用于大于9的数字，比如“10”、“1,000”或“1,090”。这些零表示该列没有值。
- en: Integers
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 整数
- en: Integers include positive and negative natural numbers as well as 0\. We may
    take them for granted, but ancient mathematicians deeply distrusted the idea of
    negative numbers. But when you subtract 5 from 3, you get –2\. This is useful
    especially when it comes to finances where we measure profits and losses. In 628
    AD, an Indian mathematician named Brahmagupta showed why negative numbers were
    necessary for arithmetic to progress with the quadratic formula, and therefore
    integers became accepted.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 整数包括正整数、负整数以及0。我们可能认为它们理所当然，但古代数学家深深不信任负数的概念。但是当你从3中减去5时，你得到-2。这在财务方面特别有用，我们在衡量利润和损失时使用。公元628年，一位名叫布拉马古普塔的印度数学家展示了为什么负数对于算术的进展是必要的，因此整数得到了认可。
- en: Rational numbers
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有理数
- en: Any number that you can express as a fraction, such as 2/3, is a rational number.
    This includes all finite decimals and integers since they can be expressed as
    fractions, too, such as 687/100 = 6.87 and 2/1 = 2, respectively. They are called
    *rational* because they are *ratios*. Rational numbers were quickly deemed necessary
    because time, resources, and other quantities could not always be measured in
    discrete units. Milk does not always come in gallons. We may have to measure it
    as parts of a gallon. If I run for 12 minutes, I cannot be forced to measure in
    whole miles when in actuality I ran 9/10 of a mile.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可以表示为分数的数字，比如2/3，都是有理数。这包括所有有限小数和整数，因为它们也可以表示为分数，比如687/100 = 6.87和2/1 = 2。它们被称为*有理数*，因为它们是*比率*。有理数很快被认为是必要的，因为时间、资源和其他数量并非总是可以用离散单位来衡量。牛奶并非总是以加仑为单位。我们可能需要将其测量为加仑的部分。如果我跑了12分钟，实际上跑了9/10英里，我就不能被迫以整英里为单位来衡量。
- en: Irrational numbers
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 无理数
- en: Irrational numbers cannot be expressed as a fraction. This includes the famous
    <math alttext="pi"><mi>π</mi></math> , square roots of certain numbers like <math
    alttext="StartRoot 2 EndRoot"><msqrt><mn>2</mn></msqrt></math> , and Euler’s number
    <math alttext="e"><mi>e</mi></math> , which we will learn about later. These numbers
    have an infinite number of decimal digits, such as 3.141592653589793238462…
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 无理数不能表示为分数。这包括著名的<math alttext="pi"><mi>π</mi></math>，某些数字的平方根，如<math alttext="StartRoot
    2 EndRoot"><msqrt><mn>2</mn></msqrt></math>，以及欧拉数<math alttext="e"><mi>e</mi></math>，我们稍后会学习到。这些数字有无限多的小数位，比如3.141592653589793238462…
- en: There is an interesting history behind irrational numbers. The Greek mathematician
    Pythagoras believed all numbers are rational. He believed this so fervently, he
    made a religion that prayed to the number 10\. “Bless us, divine number, thou
    who generated gods and men!” he and his followers would pray (why “10” was so
    special, I do not know). There is a legend that one of his followers, Hippasus,
    proved not all numbers are rational simply by demonstrating the square root of
    2\. This severely messed with Pythagoras’s belief system, and he responded by
    drowning Hippasus at sea.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 无理数背后有一个有趣的历史。希腊数学家毕达哥拉斯相信所有数字都是有理数。他如此坚信这一点，以至于他创立了一个崇拜数字10的宗教。“祝福我们，神圣的数字，你生成了神和人！”他和他的追随者会这样祈祷（为什么“10”如此特别，我不知道）。有一个传说，他的一个追随者希帕索斯通过演示根号2证明了并非所有数字都是有理数。这严重干扰了毕达哥拉斯的信仰体系，他回应是将希帕索斯溺死在海中。
- en: Regardless, we now know not all numbers are rational.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们现在知道并非所有数字都是有理数。
- en: Real numbers
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 实数
- en: Real numbers include rational as well as irrational numbers. In practicality,
    when you are doing any data science work you can treat any decimals you work with
    as real numbers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 实数包括有理数和无理数。在实际操作中，当你进行任何数据科学工作时，你可以将你处理的任何小数视为实数。
- en: Complex and imaginary numbers
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 复数和虚数
- en: You encounter this number type when you take the square root of a negative number.
    While imaginary and complex numbers have relevance in certain types of problems,
    we will mostly steer clear of them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对负数取平方根时，就会遇到这种数字类型。虽然虚数和复数在某些类型的问题中具有相关性，但我们大多数时候会避开它们。
- en: In data science, you will find most (if not all) of your work will be using
    whole numbers, natural numbers, integers, and real numbers. Imaginary numbers
    may be encountered in more advanced use cases such as matrix decomposition, which
    we will touch on in [Chapter 4](ch04.xhtml#ch04).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据科学中，你会发现你的大部分（如果不是全部）工作将使用整数、自然数、整数和实数。虚数可能会在更高级的用例中遇到，比如矩阵分解，我们将在[第4章](ch04.xhtml#ch04)中涉及。
- en: Complex and Imaginary Numbers
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复数和虚数
- en: If you do want to learn about imaginary numbers, there is a great playlist *Imaginary
    Numbers are Real* on [YouTube](https://oreil.ly/bvyIq).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解虚数，YouTube上有一个很棒的播放列表*虚数是真实的*，链接在[YouTube](https://oreil.ly/bvyIq)。
- en: Order of Operations
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算顺序
- en: Hopefully, you are familiar with *order of operations*, which is the order you
    solve each part of a mathematical expression. As a brief refresher, recall that
    you evaluate components in parentheses, followed by exponents, then multiplication,
    division, addition, and subtraction. You can remember the order of operations
    by the mnemonic device PEMDAS (Please Excuse My Dear Aunt Sally), which corresponds
    to the ordering parentheses, exponents, multiplication, division, addition, and
    subtraction.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你熟悉*运算顺序*，这是你解决数学表达式中每个部分的顺序。简要回顾一下，记住你要先计算括号中的部分，然后是指数，接着是乘法、除法、加法和减法。你可以通过PEMDAS（请原谅我亲爱的阿姨莎莉）这个记忆法来记住运算顺序，对应的是括号、指数、乘法、除法、加法和减法的顺序。
- en: 'Take for example this expression:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，考虑这个表达式：
- en: <math alttext="2 times StartFraction left-parenthesis 3 plus 2 right-parenthesis
    squared Over 5 EndFraction minus 4" display="block"><mrow><mn>2</mn> <mo>×</mo>
    <mfrac><msup><mrow><mo>(</mo><mn>3</mn><mo>+</mo><mn>2</mn><mo>)</mo></mrow> <mn>2</mn></msup>
    <mn>5</mn></mfrac> <mo>-</mo> <mn>4</mn></mrow></math>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="2 times StartFraction left-parenthesis 3 plus 2 right-parenthesis
    squared Over 5 EndFraction minus 4" display="block"><mrow><mn>2</mn> <mo>×</mo>
    <mfrac><msup><mrow><mo>(</mo><mn>3</mn><mo>+</mo><mn>2</mn><mo>)</mo></mrow> <mn>2</mn></msup>
    <mn>5</mn></mfrac> <mo>-</mo> <mn>4</mn></mrow></math>
- en: 'First we evaluate the parentheses (3 + 2), which equals 5:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们计算括号中的部分（3 + 2），结果为5：
- en: <math alttext="2 times StartFraction left-parenthesis bold 5 right-parenthesis
    squared Over 5 EndFraction minus 4" display="block"><mrow><mn>2</mn> <mo>×</mo>
    <mfrac><msup><mrow><mo>(</mo><mn mathvariant="bold">5</mn><mo>)</mo></mrow> <mn>2</mn></msup>
    <mn>5</mn></mfrac> <mo>-</mo> <mn>4</mn></mrow></math>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="2 times StartFraction left-parenthesis bold 5 right-parenthesis
    squared Over 5 EndFraction minus 4" display="block"><mrow><mn>2</mn> <mo>×</mo>
    <mfrac><msup><mrow><mo>(</mo><mn mathvariant="bold">5</mn><mo>)</mo></mrow> <mn>2</mn></msup>
    <mn>5</mn></mfrac> <mo>-</mo> <mn>4</mn></mrow></math>
- en: 'Next we solve the exponent, which we can see is squaring that 5 we just summed.
    That is 25:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们解决指数，我们可以看到是对刚刚求和的5进行平方。结果是25：
- en: <math alttext="2 times StartFraction bold 25 Over 5 EndFraction minus 4" display="block"><mrow><mn>2</mn>
    <mo>×</mo> <mfrac><mn mathvariant="bold">25</mn> <mn>5</mn></mfrac> <mo>-</mo>
    <mn>4</mn></mrow></math>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="2 times StartFraction bold 25 Over 5 EndFraction minus 4" display="block"><mrow><mn>2</mn>
    <mo>×</mo> <mfrac><mn mathvariant="bold">25</mn> <mn>5</mn></mfrac> <mo>-</mo>
    <mn>4</mn></mrow></math>
- en: 'Next up we have multiplication and division. The ordering of these two is swappable
    since division is also multiplication (using fractions). Let’s go ahead and multiply
    the 2 with the <math alttext="StartFraction 25 Over 5 EndFraction"><mfrac><mn>25</mn>
    <mn>5</mn></mfrac></math> , yielding <math alttext="StartFraction 50 Over 5 EndFraction"><mfrac><mn>50</mn>
    <mn>5</mn></mfrac></math> :'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是乘法和除法。这两者的顺序可以交换，因为除法也是乘法（使用分数）。让我们继续将2乘以<math alttext="分数25除以5"><mfrac><mn>25</mn>
    <mn>5</mn></mfrac></math>，得到<math alttext="分数50除以5"><mfrac><mn>50</mn> <mn>5</mn></mfrac></math>：
- en: <math alttext="StartFraction 50 Over 5 EndFraction minus 4" display="block"><mrow><mfrac><mn>50</mn>
    <mn>5</mn></mfrac> <mo>-</mo> <mn>4</mn></mrow></math>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction 50 Over 5 EndFraction minus 4" display="block"><mrow><mfrac><mn>50</mn>
    <mn>5</mn></mfrac> <mo>-</mo> <mn>4</mn></mrow></math>
- en: 'Next we will perform the division, dividing 50 by 5, which will yield 10:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将进行除法运算，将50除以5，得到10：
- en: <math alttext="bold 10 negative 4" display="block"><mrow><mn mathvariant="bold">10</mn>
    <mo>-</mo> <mn>4</mn></mrow></math>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold 10 negative 4" display="block"><mrow><mn mathvariant="bold">10</mn>
    <mo>-</mo> <mn>4</mn></mrow></math>
- en: 'And finally, we perform any addition and subtraction. Of course, <math alttext="10
    minus 4"><mrow><mn>10</mn> <mo>-</mo> <mn>4</mn></mrow></math> is going to give
    us 6:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们进行任何加法和减法。当然，<math alttext="10减4"><mrow><mn>10</mn> <mo>-</mo> <mn>4</mn></mrow></math>
    将给我们6：
- en: <math alttext="10 minus 4 equals 6" display="block"><mrow><mn>10</mn> <mo>-</mo>
    <mn>4</mn> <mo>=</mo> <mn>6</mn></mrow></math>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="10 minus 4 equals 6" display="block"><mrow><mn>10</mn> <mo>-</mo>
    <mn>4</mn> <mo>=</mo> <mn>6</mn></mrow></math>
- en: Sure enough, if we were to express this in Python we would print a value of
    `6.0` as shown in [Example 1-1](#ubDppIkBEj).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，如果我们要在Python中表示这个，我们将打印一个值`6.0`，如[示例1-1](#ubDppIkBEj)所示。
- en: Example 1-1\. Solving an expression in Python
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-1\. 在Python中解决一个表达式
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This may be elementary but it is still critical. In code, even if you get the
    correct result without them, it is a good practice to liberally use parentheses
    in complex expressions so you establish control of the evaluation order.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能很基础，但仍然至关重要。在代码中，即使在没有它们的情况下得到正确的结果，也是一个很好的实践，在复杂表达式中大量使用括号，这样你就能控制评估顺序。
- en: Here I group the fractional part of my expression in parentheses, helping to
    set it apart from the rest of the expression in [Example 1-2](#iNAKBikkOg).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我将表达式的分数部分用括号括起来，有助于将其与[示例1-2](#iNAKBikkOg)中的其余部分区分开。
- en: Example 1-2\. Making use of parentheses for clarity in Python
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-2\. 在Python中利用括号来提高清晰度
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While both examples are technically correct, the latter is more clear to us
    easily confused humans. If you or someone else makes changes to your code, the
    parentheses provide an easy reference of operation order as you make changes.
    This provides a line of defense against code changes to prevent bugs as well.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个示例在技术上都是正确的，但后者对于我们这些容易混淆的人来说更清晰。如果你或其他人对你的代码进行更改，括号提供了一个易于参考的操作顺序，以防止更改引起错误。
- en: Variables
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: If you have done some scripting with Python or another programming language,
    you have an idea what a variable is. In mathematics, a *variable* is a named placeholder
    for an unspecified or unknown number.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用Python或其他编程语言做过一些脚本编写，你就知道什么是变量。在数学中，*变量*是一个未指定或未知数字的命名占位符。
- en: You may have a variable *x* representing any real number, and you can multiply
    that variable without declaring what it is. In [Example 1-3](#GEEDPGFQRQ) we take
    a variable input *x* from a user and multiply it by 3.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能有一个表示任意实数的变量*x*，你可以将该变量乘以3而不声明它是什么。在[示例1-3](#GEEDPGFQRQ)中，我们从用户那里获取一个变量输入*x*，并将其乘以3。
- en: Example 1-3\. A variable in Python that is then multiplied
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例1-3\. 在Python中一个变量，然后进行乘法
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are some standard variable names for certain variable types. If these
    variable names and concepts are unfamiliar, no worries! But some readers might
    recognize we use theta <math alttext="theta"><mi>θ</mi></math> to denote angles
    and beta <math alttext="beta"><mi>β</mi></math> for a parameter in a linear regression.
    Greek symbols make awkward variable names in Python, so we would likely name these
    variables `theta` and `beta` in Python as shown in [Example 1-4](#orOowCWTNK).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些变量类型，有一些标准变量名。 如果这些变量名和概念对您不熟悉，不用担心！ 但是一些读者可能会认识到我们使用theta <math alttext="theta"><mi>θ</mi></math>表示角度，beta
    <math alttext="beta"><mi>β</mi></math>表示线性回归中的参数。 希腊符号在Python中会使变量名尴尬，所以我们可能会在Python中将这些变量命名为`theta`和`beta`，如[示例1-4](#orOowCWTNK)所示。
- en: Example 1-4\. Greek variable names in Python
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例1-4\. Python中的希腊变量名
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note also that variable names can be subscripted so that several instances of
    a variable name can be used. For practical purposes, just treat these as separate
    variables. If you encounter variables *x*[1], *x*[2], and *x*[3], just treat them
    as three separate variables as shown in [Example 1-5](#nbsirNPfRU).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，变量名可以被标为下标，以便可以使用多个变量名的实例。 对于实际目的，只需将这些视为单独的变量。 如果你遇到变量*x*[1]，*x*[2]和*x*[3]，只需将它们视为[示例1-5](#nbsirNPfRU)中所示的三个单独的变量。
- en: Example 1-5\. Expressing subscripted variables in Python
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例1-5\. 在Python中表示带下标的变量
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Functions
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: '*Functions* are expressions that define relationships between two or more variables.
    More specifically, a function takes *input variables* (also called *domain variables*
    or *independent variables*), plugs them into an expression, and then results in
    an *output variable* (also called *dependent variable*).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*是定义两个或更多变量之间关系的表达式。 更具体地说，函数接受*输入变量*（也称为*定义域变量*或*自变量*），将它们插入表达式中，然后产生一个*输出变量*（也称为*因变量*）。'
- en: 'Take this simple linear function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个简单的线性函数：
- en: <math alttext="y equals 2 x plus 1" display="block"><mrow><mi>y</mi> <mo>=</mo>
    <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="y equals 2 x plus 1" display="block"><mrow><mi>y</mi> <mo>=</mo>
    <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math>
- en: For any given x-value, we solve the expression with that *x* to find *y*. When
    *x* = 1, then *y* = 3\. When *x* = 2, *y* = 5\. When *x* = 3, *y* = 7 and so on,
    as shown in [Table 1-1](#lIoFQkJKWV).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何给定的x值，我们使用该*x*解决表达式以找到*y*。 当*x* = 1时，*y* = 3。 当*x* = 2时，*y* = 5。 当*x* =
    3时，*y* = 7等等，如[表1-1](#lIoFQkJKWV)所示。
- en: Table 1-1\. Different values for y = 2x + 1
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-1\. y = 2x + 1 的不同值
- en: '| x | 2x + 1 | y |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| x | 2x + 1 | y |'
- en: '| --- | --- | --- |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 2(0) + 1 | 1 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 2(0) + 1 | 1 |'
- en: '| 1 | 2(1) + 1 | 3 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2(1) + 1 | 3 |'
- en: '| 2 | 2(2) + 1 | 5 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2(2) + 1 | 5 |'
- en: '| 3 | 2(3) + 1 | 7 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 2(3) + 1 | 7 |'
- en: Functions are useful because they model a predictable relationship between variables,
    such as how many fires *y* can we expect at *x* temperature. We will use linear
    functions to perform linear regressions in [Chapter 5](ch05.xhtml#ch05).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 函数很有用，因为它们模拟了变量之间的可预测关系，比如在*x*温度下我们可以期待多少火灾*y*。 我们将使用线性函数在[第5章](ch05.xhtml#ch05)中执行线性回归。
- en: 'Another convention you may see for the dependent variable *y* is to explicitly
    label it a function of *x*, such as <math alttext="f left-parenthesis x right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math> . So rather than express a function
    as <math alttext="y equals 2 x plus 1"><mrow><mi>y</mi> <mo>=</mo> <mn>2</mn>
    <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math> , we can also express it as:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到的另一个约定是将因变量*y*明确标记为*x*的函数，例如<math alttext="f left-parenthesis x right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>。 因此，我们可以将一个函数表达为<math alttext="y
    equals 2 x plus 1"><mrow><mi>y</mi> <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo>
    <mn>1</mn></mrow></math>，也可以表达为：
- en: <math alttext="f left-parenthesis x right-parenthesis equals 2 x plus 1" display="block"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals 2 x plus 1" display="block"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math>
- en: '[Example 1-6](#UQLcQVtkqn) shows how we can declare a mathematical function
    and iterate it in Python.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例1-6](#UQLcQVtkqn)展示了我们如何在Python中声明一个数学函数并进行迭代。'
- en: Example 1-6\. Declaring a linear function in Python
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-6\. 在Python中声明线性函数
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When dealing with real numbers, a subtle but important feature of functions
    is they often have an infinite number of x-values and resulting y-values. Ask
    yourself this: how many x-values can we put through the function <math alttext="y
    equals 2 x plus 1"><mrow><mi>y</mi> <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo>
    <mn>1</mn></mrow></math> ? Rather than just 0, 1, 2, 3…why not 0, 0.5, 1, 1.5,
    2, 2.5, 3 as shown in [Table 1-2](#aNGOvuFmpT)?'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理实数时，函数的一个微妙但重要的特征是它们通常具有无限多个x值和相应的y值。 问问自己：我们可以通过函数<math alttext="y equals
    2 x plus 1"><mrow><mi>y</mi> <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math>放入多少个x值？
    不仅仅是0、1、2、3…为什么不是0、0.5、1、1.5、2、2.5、3，如[表1-2](#aNGOvuFmpT)所示？
- en: Table 1-2\. Different values for y = 2x + 1
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-2\. y = 2x + 1 的不同值
- en: '| x | 2x + 1 | y |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| x | 2x + 1 | y |'
- en: '| --- | --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0.0 | 2(0) + 1 | 1 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 0.0 | 2(0) + 1 | 1 |'
- en: '| 0.5 | 2(.5) + 1 | 2 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 0.5 | 2(.5) + 1 | 2 |'
- en: '| 1.0 | 2(1) + 1 | 3 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 1.0 | 2(1) + 1 | 3 |'
- en: '| 1.5 | 2(1.5) + 1 | 4 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 1.5 | 2(1.5) + 1 | 4 |'
- en: '| 2.0 | 2(2) + 1 | 5 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 2.0 | 2(2) + 1 | 5 |'
- en: '| 2.5 | 2(2.5) + 1 | 6 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 2.5 | 2(2.5) + 1 | 6 |'
- en: '| 3.0 | 2(3) + 1 | 7 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 3.0 | 2(3) + 1 | 7 |'
- en: Or why not do quarter steps for *x*? Or 1/10 of a step? We can make these steps
    infinitely small, effectively showing <math alttext="y equals 2 x plus 1"><mrow><mi>y</mi>
    <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math> is a *continuous
    function*, where for every possible value of *x* there is a value for *y*. This
    segues us nicely to visualize our function as a line as shown in [Figure 1-1](#GcTcreWOta).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 或者为什么不对*x*进行四分之一步？或者十分之一的步长？我们可以使这些步长无限小，有效地显示<math alttext="y equals 2 x plus
    1"><mrow><mi>y</mi> <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn></mrow></math>是一个*连续函数*，对于每个可能的*x*值，都有一个*y*值。这使我们可以很好地将我们的函数可视化为一条线，如[图1-1](#GcTcreWOta)所示。
- en: '![emds 0101](Images/emds_0101.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0101](Images/emds_0101.png)'
- en: Figure 1-1\. Graph for function y = 2x + 1
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-1\. 函数y = 2x + 1的图形
- en: When we plot on a two-dimensional plane with two number lines (one for each
    variable) it is known as a *Cartesian plane*, *x-y plane*, or *coordinate plane*.
    We trace a given x-value and then look up the corresponding y-value, and plot
    the intersections as a line. Notice that due to the nature of real numbers (or
    decimals, if you prefer), there are an infinite number of *x* values. This is
    why when we plot the function *f*(*x*) we get a continuous line with no breaks
    in it. There are an infinite number of points on that line, or any part of that
    line.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在二维平面上绘制两个数轴（每个变量一个）时，这被称为*笛卡尔平面*、*x-y平面*或*坐标平面*。我们追踪给定的x值，然后查找相应的y值，并将交点绘制为一条线。请注意，由于实数（或小数，如果您喜欢）的性质，存在无限多个*x*值。这就是为什么当我们绘制函数*f*(*x*)时，我们得到一条没有中断的连续线。这条线上有无限多个点，或者该线的任何部分上都有无限多个点。
- en: If you want to plot this using Python, there are a number of charting libraries
    from Plotly to matplotlib. Throughout this book we will use SymPy to do many tasks,
    and the first we will use is plotting a function. SymPy uses matplotlib so make
    sure you have that package installed. Otherwise it will print an ugly text-based
    graph to your console. After that, just declare the *x* variable to SymPy using
    `symbols()`, declare your function, and then plot it as shown in [Example 1-7](#noaPuacjja)
    and [Figure 1-2](#bobqNTAwcH).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用Python绘制这个函数，有许多绘图库可供选择，从Plotly到matplotlib。在本书中，我们将使用SymPy来执行许多任务，而我们将首先使用它来绘制函数。SymPy使用matplotlib，因此请确保您已安装该软件包。否则，它将在控制台上打印一个丑陋的基于文本的图形。之后，只需使用`symbols()`将*x*变量声明给SymPy，声明您的函数，然后像[示例1-7](#noaPuacjja)和[图1-2](#bobqNTAwcH)中所示那样绘制它。
- en: Example 1-7\. Charting a linear function in Python using SymPy
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例1-7\. 使用SymPy在Python中绘制线性函数
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![emds 0102](Images/emds_0102.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0102](Images/emds_0102.png)'
- en: Figure 1-2\. Using SymPy to graph a linear function
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-2\. 使用SymPy绘制线性函数
- en: '[Example 1-8](#hdgJBGCdmR) and [Figure 1-3](#rPwcOSawNp) are another example
    showing the function <math alttext="f left-parenthesis x right-parenthesis equals
    x squared plus 1"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>1</mn></mrow></math>
    .'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例1-8](#hdgJBGCdmR)和[图1-3](#rPwcOSawNp)是另一个示例，展示了函数<math alttext="f left-parenthesis
    x right-parenthesis equals x squared plus 1"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo>
    <mn>1</mn></mrow></math>。'
- en: Example 1-8\. Charting an exponential function
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例1-8\. 绘制指数函数
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note in [Figure 1-3](#rPwcOSawNp) we do not get a straight line but rather a
    smooth, symmetrical curve known as a parabola. It is continuous but not linear,
    as it does not produce values in a straight line. Curvy functions like this are
    mathematically harder to work with, but we will learn some tricks to make it not
    so bad.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在[图1-3](#rPwcOSawNp)中，我们得到的不是一条直线，而是一个光滑、对称的曲线，称为抛物线。它是连续的，但不是线性的，因为它不会产生直线上的数值。像这样的曲线函数在数学上更难处理，但我们将学习一些技巧，使其变得不那么糟糕。
- en: Curvilinear Functions
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 曲线函数
- en: When a function is continuous but curvy, rather than linear and straight, we
    call it a *curvilinear function*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数是连续的但是曲线的，而不是线性的和直的时，我们称之为*曲线函数*。
- en: '![emds 0103](Images/emds_0103.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0103](Images/emds_0103.png)'
- en: Figure 1-3\. Using SymPy to graph an exponential function
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-3\. 使用SymPy绘制指数函数
- en: Note that functions utilize multiple input variables, not just one. For example,
    we can have a function with independent variables *x* and *y*. Note that *y* is
    not dependent like in previous examples.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数利用多个输入变量，而不仅仅是一个。例如，我们可以有一个具有独立变量*x*和*y*的函数。注意*y*不像之前的例子中那样是依赖的。
- en: <math alttext="f left-parenthesis x comma y right-parenthesis equals 2 x plus
    3 y" display="block"><mrow><mi>f</mi> <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo> <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>3</mn> <mi>y</mi></mrow></math>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x comma y right-parenthesis equals 2 x plus
    3 y" display="block"><mrow><mi>f</mi> <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo> <mo>=</mo> <mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>3</mn> <mi>y</mi></mrow></math>
- en: Since we have two independent variables (*x* and *y*) and one dependent variable
    (the output of *f*(*x*,*y*)), we need to plot this graph on three dimensions to
    produce a plane of values rather than a line, as shown in [Example 1-9](#UwFfAJTOmU)
    and [Figure 1-4](#bqOScbvrNn).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有两个独立变量（*x*和*y*）和一个因变量（*f*(*x*,*y*)的输出），我们需要在三维上绘制这个图形，以产生一组值的平面，而不是一条线，如[示例 1-9](#UwFfAJTOmU)和[图 1-4](#bqOScbvrNn)所示。
- en: Example 1-9\. Declaring a function with two independent variables in Python
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-9。在Python中声明具有两个独立变量的函数
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![emds 0104](Images/emds_0104.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0104](Images/emds_0104.png)'
- en: Figure 1-4\. Using SymPy to graph a three-dimensional function
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-4。使用SymPy绘制三维函数
- en: No matter how many independent variables you have, your function will typically
    output only one dependent variable. When you solve for multiple dependent variables,
    you will likely be using separate functions for each one.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你有多少个独立变量，你的函数通常只会输出一个因变量。当你解决多个因变量时，你可能会为每个因变量使用单独的函数。
- en: Summations
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 求和
- en: I promised not to use equations full of Greek symbols in this book. However,
    there is one that is so common and useful that I would be remiss to not cover
    it. A *summation* is expressed as a sigma <math alttext="normal upper Sigma"><mi>Σ</mi></math>
    and adds elements together.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我承诺在这本书中不使用充满希腊符号的方程。然而，有一个是如此常见和有用，我不涵盖它会疏忽大意。一个*求和*被表示为一个sigma<math alttext="normal
    upper Sigma"><mi>Σ</mi></math>，并将元素相加。
- en: For example, if I want to iterate the numbers 1 through 5, multiply each by
    2, and sum them, here is how I would express that using a summation. [Example 1-10](#qtpCbqbAdu)
    shows how to execute this in Python.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我想迭代数字1到5，将每个数字乘以2，然后求和，这里是我如何使用求和表达这个过程。[示例 1-10](#qtpCbqbAdu)展示了如何在Python中执行这个过程。
- en: <math alttext="sigma-summation Underscript i equals 1 Overscript 5 Endscripts
    2 i equals left-parenthesis 2 right-parenthesis 1 plus left-parenthesis 2 right-parenthesis
    2 plus left-parenthesis 2 right-parenthesis 3 plus left-parenthesis 2 right-parenthesis
    4 plus left-parenthesis 2 right-parenthesis 5 equals 30" display="block"><mrow><munderover><mo>∑</mo>
    <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mn>5</mn></munderover> <mn>2</mn>
    <mi>i</mi> <mo>=</mo> <mrow><mo>(</mo> <mn>2</mn> <mo>)</mo></mrow> <mn>1</mn>
    <mo>+</mo> <mrow><mo>(</mo> <mn>2</mn> <mo>)</mo></mrow> <mn>2</mn> <mo>+</mo>
    <mrow><mo>(</mo> <mn>2</mn> <mo>)</mo></mrow> <mn>3</mn> <mo>+</mo> <mrow><mo>(</mo>
    <mn>2</mn> <mo>)</mo></mrow> <mn>4</mn> <mo>+</mo> <mrow><mo>(</mo> <mn>2</mn>
    <mo>)</mo></mrow> <mn>5</mn> <mo>=</mo> <mn>30</mn></mrow></math>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="sigma-summation Underscript i equals 1 Overscript 5 Endscripts
    2 i equals left-parenthesis 2 right-parenthesis 1 plus left-parenthesis 2 right-parenthesis
    2 plus left-parenthesis 2 right-parenthesis 3 plus left-parenthesis 2 right-parenthesis
    4 plus left-parenthesis 2 right-parenthesis 5 equals 30" display="block"><mrow><munderover><mo>∑</mo>
    <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mn>5</mn></munderover> <mn>2</mn>
    <mi>i</mi> <mo>=</mo> <mrow><mo>(</mo> <mn>2</mn> <mo>)</mo></mrow> <mn>1</mn>
    <mo>+</mo> <mrow><mo>(</mo> <mn>2</mn> <mo>)</mo></mrow> <mn>2</mn> <mo>+</mo>
    <mrow><mo>(</mo> <mn>2</mn> <mo>)</mo></mrow> <mn>3</mn> <mo>+</mo> <mrow><mo>(</mo>
    <mn>2</mn> <mo>)</mo></mrow> <mn>4</mn> <mo>+</mo> <mrow><mo>(</mo> <mn>2</mn>
    <mo>)</mo></mrow> <mn>5</mn> <mo>=</mo> <mn>30</mn></mrow></math>
- en: Example 1-10\. Performing a summation in Python
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-10。在Python中执行求和
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that *i* is a placeholder variable representing each consecutive index
    value we are iterating in the loop, which we multiply by 2 and then sum all together.
    When you are iterating data, you may see variables like <math alttext="x Subscript
    i"><msub><mi>x</mi> <mi>i</mi></msub></math> indicating an element in a collection
    at index *i*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*i*是一个占位符变量，代表我们在循环中迭代的每个连续索引值，我们将其乘以2，然后全部求和。当你迭代数据时，你可能会看到像<math alttext="x
    Subscript i"><msub><mi>x</mi> <mi>i</mi></msub></math>这样的变量，表示在索引*i*处的集合中的元素。
- en: The range() function
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: range()函数
- en: Recall that the `range()` function in Python is end exclusive, meaning if you
    invoke `range(1,4)` it will iterate the numbers 1, 2, and 3\. It excludes the
    4 as an upper boundary.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在Python中，`range()`函数是以结束为准的，也就是说，如果你调用`range(1,4)`，它将迭代数字1、2和3。它排除4作为上限。
- en: 'It is also common to see *n* represent the number of items in a collection,
    like the number of records in a dataset. Here is one such example where we iterate
    a collection of numbers of size *n*, multiply each one by 10, and sum them:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*也常用来表示集合中的项数，比如数据集中的记录数。这里有一个例子，我们迭代一个大小为*n*的数字集合，将每个数字乘以10，然后求和：'
- en: <math alttext="sigma-summation Underscript i equals 1 Overscript n Endscripts
    10 x Subscript i" display="block"><mrow><munderover><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>n</mi></munderover> <mn>10</mn> <msub><mi>x</mi> <mi>i</mi></msub></mrow></math>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="sigma-summation Underscript i equals 1 Overscript n Endscripts
    10 x Subscript i" display="block"><mrow><munderover><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>n</mi></munderover> <mn>10</mn> <msub><mi>x</mi> <mi>i</mi></msub></mrow></math>
- en: In [Example 1-11](#VFdLakbelW) we use Python to execute this expression on a
    collection of four numbers. Note that in Python (and most programming languages
    in general) we typically reference items starting at index 0, while in math we
    start at index 1\. Therefore, we shift accordingly in our iteration by starting
    at 0 in our `range()`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 1-11](#VFdLakbelW)中，我们使用Python在四个数字的集合上执行这个表达式。请注意，在Python（以及大多数编程语言）中，我们通常从索引0开始引用项目，而在数学中我们从索引1开始。因此，在我们的`range()`中通过从0开始迭代来相应地进行移位。
- en: Example 1-11\. Summation of elements in Python
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-11。在Python中对元素求和
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That is the gist of summation. In a nutshell, a summation <math alttext="normal
    upper Sigma"><mi>Σ</mi></math> says, “add a bunch of things together,” and uses
    an index *i* and a maximum value *n* to express each iteration feeding into the
    sum. We will see these throughout this book.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是求和的要点。简而言之，求和<math alttext="normal upper Sigma"><mi>Σ</mi></math>表示“将一堆东西加在一起”，并使用索引*i*和最大值*n*来表达每次迭代输入到总和中。我们将在本书中看到这些。
- en: Exponents
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指数
- en: '*Exponents* multiply a number by itself a specified number of times. When you
    raise 2 to the third power (expressed as 2³ using 3 as a superscript), that is
    multiplying three 2s together:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*指数*将一个数字乘以自身指定次数。当你将2提升到三次方（用3作为上标表示为2³），这就是将三个2相乘：'
- en: <math alttext="2 cubed equals 2 asterisk 2 asterisk 2 equals 8" display="block"><mrow><msup><mn>2</mn>
    <mn>3</mn></msup> <mo>=</mo> <mn>2</mn> <mo>*</mo> <mn>2</mn> <mo>*</mo> <mn>2</mn>
    <mo>=</mo> <mn>8</mn></mrow></math>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="2 cubed equals 2 asterisk 2 asterisk 2 equals 8" display="block"><mrow><msup><mn>2</mn>
    <mn>3</mn></msup> <mo>=</mo> <mn>2</mn> <mo>*</mo> <mn>2</mn> <mo>*</mo> <mn>2</mn>
    <mo>=</mo> <mn>8</mn></mrow></math>
- en: The *base* is the variable or value we are exponentiating, and the *exponent*
    is the number of times we multiply the base value. For the expression <math alttext="2
    cubed"><msup><mn>2</mn> <mn>3</mn></msup></math> , 2 is the base and 3 is the
    exponent.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*底数*是我们正在进行指数运算的变量或值，*指数*是我们将基值相乘的次数。对于表达式<math alttext="2 cubed"><msup><mn>2</mn>
    <mn>3</mn></msup></math>，2是底数，3是指数。'
- en: 'Exponents have a few interesting properties. Say we multiplied <math alttext="x
    squared"><msup><mi>x</mi> <mn>2</mn></msup></math> and <math alttext="x cubed"><msup><mi>x</mi>
    <mn>3</mn></msup></math> together. Observe what happens next when I expand the
    exponents with simple multiplication and then consolidate into a single exponent:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 指数具有一些有趣的性质。假设我们将<math alttext="x squared"><msup><mi>x</mi> <mn>2</mn></msup></math>和<math
    alttext="x cubed"><msup><mi>x</mi> <mn>3</mn></msup></math>相乘。观察当我用简单的乘法展开指数然后合并为单个指数时会发生什么：
- en: <math alttext="x squared x cubed equals left-parenthesis x asterisk x right-parenthesis
    asterisk left-parenthesis x asterisk x asterisk x right-parenthesis equals x Superscript
    2 plus 3 Baseline equals x Superscript 5" display="block"><mrow><msup><mi>x</mi>
    <mn>2</mn></msup> <msup><mi>x</mi> <mn>3</mn></msup> <mo>=</mo> <mrow><mo>(</mo>
    <mi>x</mi> <mo>*</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>*</mo> <mrow><mo>(</mo>
    <mi>x</mi> <mo>*</mo> <mi>x</mi> <mo>*</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>x</mi> <mrow><mn>2</mn><mo>+</mo><mn>3</mn></mrow></msup> <mo>=</mo>
    <msup><mi>x</mi> <mn>5</mn></msup></mrow></math>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x squared x cubed equals left-parenthesis x asterisk x right-parenthesis
    asterisk left-parenthesis x asterisk x asterisk x right-parenthesis equals x Superscript
    2 plus 3 Baseline equals x Superscript 5" display="block"><mrow><msup><mi>x</mi>
    <mn>2</mn></msup> <msup><mi>x</mi> <mn>3</mn></msup> <mo>=</mo> <mrow><mo>(</mo>
    <mi>x</mi> <mo>*</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>*</mo> <mrow><mo>(</mo>
    <mi>x</mi> <mo>*</mo> <mi>x</mi> <mo>*</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>x</mi> <mrow><mn>2</mn><mo>+</mo><mn>3</mn></mrow></msup> <mo>=</mo>
    <msup><mi>x</mi> <mn>5</mn></msup></mrow></math>
- en: When we multiply exponents together with the same base, we simply add the exponents,
    which is known as the *product rule*. Let me emphasize that the base of all multiplied
    exponents must be the same for the product rule to apply.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将具有相同底数的指数相乘在一起时，我们简单地将指数相加，这被称为*乘法法则*。请注意，所有相乘指数的底数必须相同才能应用乘法法则。
- en: Let’s explore division next. What happens when we divide <math alttext="x squared"><msup><mi>x</mi>
    <mn>2</mn></msup></math> by <math alttext="x Superscript 5"><msup><mi>x</mi> <mn>5</mn></msup></math>
    ?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们探讨除法。当我们将<math alttext="x squared"><msup><mi>x</mi> <mn>2</mn></msup></math>除以<math
    alttext="x Superscript 5"><msup><mi>x</mi> <mn>5</mn></msup></math>时会发生什么？
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mfrac><msup><mi>x</mi>
    <mn>2</mn></msup> <msup><mi>x</mi> <mn>5</mn></msup></mfrac></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mfrac><mrow><mi>x</mi><mo>*</mo><mi>x</mi></mrow>
    <mrow><mi>x</mi><mo>*</mo><mi>x</mi><mo>*</mo><mi>x</mi><mo>*</mo><mi>x</mi><mo>*</mo><mi>x</mi></mrow></mfrac></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mfrac><mn>1</mn>
    <mrow><mi>x</mi><mo>*</mo><mi>x</mi><mo>*</mo><mi>x</mi></mrow></mfrac></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfrac><mn>1</mn>
    <msup><mi>x</mi> <mn>3</mn></msup></mfrac> <mo>=</mo> <msup><mi>x</mi> <mrow><mo>-</mo><mn>3</mn></mrow></msup></mrow></mtd></mtr></mtable></math>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mfrac><msup><mi>x</mi>
    <mn>2</mn></msup> <msup><mi>x</mi> <mn>5</mn></msup></mfrac></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mfrac><mrow><mi>x</mi><mo>*</mo><mi>x</mi></mrow>
    <mrow><mi>x</mi><mo>*</mo><mi>x</mi><mo>*</mo><mi>x</mi><mo>*</mo><mi>x</mi><mo>*</mo><mi>x</mi></mrow></mfrac></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mfrac><mn>1</mn>
    <mrow><mi>x</mi><mo>*</mo><mi>x</mi><mo>*</mo><mi>x</mi></mrow></mfrac></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfrac><mn>1</mn>
    <msup><mi>x</mi> <mn>3</mn></msup></mfrac> <mo>=</mo> <msup><mi>x</mi> <mrow><mo>-</mo><mn>3</mn></mrow></msup></mrow></mtd></mtr></mtable></math>
- en: As you can see, when we divide <math alttext="x squared"><msup><mi>x</mi> <mn>2</mn></msup></math>
    by <math alttext="x Superscript 5"><msup><mi>x</mi> <mn>5</mn></msup></math> we
    can cancel out two *x*’s in the numerator and denominator, leaving us with <math
    alttext="StartFraction 1 Over x cubed EndFraction"><mfrac><mn>1</mn> <msup><mi>x</mi>
    <mn>3</mn></msup></mfrac></math> . When a factor exists in both the numerator
    and denominator, we can cancel out that factor.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当我们将<math alttext="x squared"><msup><mi>x</mi> <mn>2</mn></msup></math>除以<math
    alttext="x Superscript 5"><msup><mi>x</mi> <mn>5</mn></msup></math>时，我们可以在分子和分母中消去两个*x*，留下<math
    alttext="StartFraction 1 Over x cubed EndFraction"><mfrac><mn>1</mn> <msup><mi>x</mi>
    <mn>3</mn></msup></mfrac></math>。当一个因子同时存在于分子和分母中时，我们可以消去该因子。
- en: 'What about the <math alttext="x Superscript negative 3"><msup><mi>x</mi> <mrow><mo>-</mo><mn>3</mn></mrow></msup></math>
    , you wonder? This is a good point to introduce negative exponents, which is another
    way of expressing an exponent operation in the denominator of a fraction. To demonstrate,
    <math alttext="StartFraction 1 Over x cubed EndFraction"><mfrac><mn>1</mn> <msup><mi>x</mi>
    <mn>3</mn></msup></mfrac></math> is the same as <math alttext="x Superscript negative
    3"><msup><mi>x</mi> <mrow><mo>-</mo><mn>3</mn></mrow></msup></math> :'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 那么<math alttext="x Superscript negative 3"><msup><mi>x</mi> <mrow><mo>-</mo><mn>3</mn></mrow></msup></math>呢？这是一个引入负指数的好时机，这是在分数的分母中表示指数运算的另一种方式。举例来说，<math
    alttext="StartFraction 1 Over x cubed EndFraction"><mfrac><mn>1</mn> <msup><mi>x</mi>
    <mn>3</mn></msup></mfrac></math> 就等同于<math alttext="x Superscript negative 3"><msup><mi>x</mi>
    <mrow><mo>-</mo><mn>3</mn></mrow></msup></math>：
- en: <math alttext="StartFraction 1 Over x cubed EndFraction equals x Superscript
    negative 3" display="block"><mrow><mfrac><mn>1</mn> <msup><mi>x</mi> <mn>3</mn></msup></mfrac>
    <mo>=</mo> <msup><mi>x</mi> <mrow><mo>-</mo><mn>3</mn></mrow></msup></mrow></math>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction 1 Over x cubed EndFraction equals x Superscript
    negative 3" display="block"><mrow><mfrac><mn>1</mn> <msup><mi>x</mi> <mn>3</mn></msup></mfrac>
    <mo>=</mo> <msup><mi>x</mi> <mrow><mo>-</mo><mn>3</mn></mrow></msup></mrow></math>
- en: 'Tying back the product rule, we can see it applies to negative exponents, too.
    To get intuition behind this, let’s approach this problem a different way. We
    can express this division of two exponents by making the “5” exponent of <math
    alttext="x Superscript 5"><msup><mi>x</mi> <mn>5</mn></msup></math> negative,
    and then multiplying it with <math alttext="x squared"><msup><mi>x</mi> <mn>2</mn></msup></math>
    . When you add a negative number, it is effectively performing subtraction. Therefore,
    the exponent product rule summing the multiplied exponents still holds up as shown
    next:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将乘法法则联系起来，我们可以看到它也适用于负指数。为了理解这一点，让我们用另一种方式来解决这个问题。我们可以通过将<math alttext="x Superscript
    5"><msup><mi>x</mi> <mn>5</mn></msup></math> 的“5”指数变为负数，然后与<math alttext="x squared"><msup><mi>x</mi>
    <mn>2</mn></msup></math> 相乘来表示这两个指数的除法。当你加上一个负数时，实际上是在执行减法。因此，指数乘法法则将这些相乘的指数相加仍然成立，如下所示：
- en: <math display="block"><mrow><mfrac><msup><mi>x</mi> <mn>2</mn></msup> <msup><mi>x</mi>
    <mn>5</mn></msup></mfrac> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup> <mfrac><mn>1</mn>
    <msup><mi>x</mi> <mn>5</mn></msup></mfrac> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup>
    <msup><mi>x</mi> <mrow><mo>-</mo><mn>5</mn></mrow></msup> <mo>=</mo> <msup><mi>x</mi>
    <mrow><mn>2</mn><mo>+</mo><mn>-5</mn></mrow></msup> <mo>=</mo> <msup><mi>x</mi>
    <mrow><mo>-</mo><mn>3</mn></mrow></msup></mrow></math>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><mfrac><msup><mi>x</mi> <mn>2</mn></msup> <msup><mi>x</mi>
    <mn>5</mn></msup></mfrac> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup> <mfrac><mn>1</mn>
    <msup><mi>x</mi> <mn>5</mn></msup></mfrac> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup>
    <msup><mi>x</mi> <mrow><mo>-</mo><mn>5</mn></mrow></msup> <mo>=</mo> <msup><mi>x</mi>
    <mrow><mn>2</mn><mo>+</mo><mn>-5</mn></mrow></msup> <mo>=</mo> <msup><mi>x</mi>
    <mrow><mo>-</mo><mn>3</mn></mrow></msup></mrow></math>
- en: Last but not least, can you figure out why any base with an exponent of 0 is
    1?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，你能想明白为什么任何底数的指数为0时结果是1吗？
- en: <math alttext="x Superscript 0 Baseline equals 1" display="block"><mrow><msup><mi>x</mi>
    <mn>0</mn></msup> <mo>=</mo> <mn>1</mn></mrow></math>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x Superscript 0 Baseline equals 1" display="block"><mrow><msup><mi>x</mi>
    <mn>0</mn></msup> <mo>=</mo> <mn>1</mn></mrow></math>
- en: 'The best way to get this intuition is to reason that any number divided by
    itself is 1\. If you have <math alttext="StartFraction x cubed Over x cubed EndFraction"><mfrac><msup><mi>x</mi>
    <mn>3</mn></msup> <msup><mi>x</mi> <mn>3</mn></msup></mfrac></math> it is algebraically
    obvious that reduces to 1\. But that expression also evaluates to <math alttext="x
    Superscript 0"><msup><mi>x</mi> <mn>0</mn></msup></math> :'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 获得这种直觉的最好方法是推理任何数除以自己都是1。如果你有<math alttext="StartFraction x cubed Over x cubed
    EndFraction"><mfrac><msup><mi>x</mi> <mn>3</mn></msup> <msup><mi>x</mi> <mn>3</mn></msup></mfrac></math>，代数上显然可以简化为1。但是这个表达式也等于<math
    alttext="x Superscript 0"><msup><mi>x</mi> <mn>0</mn></msup></math>：
- en: <math><mrow><mn>1</mn> <mo>=</mo> <mfrac><msup><mi>x</mi> <mn>3</mn></msup>
    <msup><mi>x</mi> <mn>3</mn></msup></mfrac> <mo>=</mo> <msup><mi>x</mi> <mn>3</mn></msup>
    <msup><mi>x</mi> <mrow><mo>-</mo><mn>3</mn></mrow></msup> <mo>=</mo> <msup><mi>x</mi>
    <mrow><mn>3</mn><mo>+</mo><mn>-3</mn></mrow></msup> <mo>=</mo> <msup><mi>x</mi>
    <mn>0</mn></msup></mrow></math>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mrow><mn>1</mn> <mo>=</mo> <mfrac><msup><mi>x</mi> <mn>3</mn></msup>
    <msup><mi>x</mi> <mn>3</mn></msup></mfrac> <mo>=</mo> <msup><mi>x</mi> <mn>3</mn></msup>
    <msup><mi>x</mi> <mrow><mo>-</mo><mn>3</mn></mrow></msup> <mo>=</mo> <msup><mi>x</mi>
    <mrow><mn>3</mn><mo>+</mo><mn>-3</mn></mrow></msup> <mo>=</mo> <msup><mi>x</mi>
    <mn>0</mn></msup></mrow></math>
- en: By the transitive property, which states that if *a* = *b* and *b* = *c*, then
    *a* = *c*, we know that <math alttext="x Superscript 0 Baseline equals 1"><mrow><msup><mi>x</mi>
    <mn>0</mn></msup> <mo>=</mo> <mn>1</mn></mrow></math> .
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 根据传递性质，即如果*a* = *b*且*b* = *c*，则*a* = *c*，我们知道<math alttext="x Superscript 0
    Baseline equals 1"><mrow><msup><mi>x</mi> <mn>0</mn></msup> <mo>=</mo> <mn>1</mn></mrow></math>。
- en: 'Now what about fractional exponents? They are an alternative way to represent
    roots, such as the square root. As a brief refresher, a <math alttext="StartRoot
    4 EndRoot"><msqrt><mn>4</mn></msqrt></math> asks “What number multiplied by itself
    will give me 4?” which of course is 2\. Note here that <math alttext="4 Superscript
    1 slash 2"><msup><mn>4</mn> <mrow><mn>1</mn><mo>/</mo><mn>2</mn></mrow></msup></math>
    is the same as <math alttext="StartRoot 4 EndRoot"><msqrt><mn>4</mn></msqrt></math>
    :'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于分数指数怎么办？它们是表示根的另一种方式，比如平方根。简要回顾一下，<math alttext="StartRoot 4 EndRoot"><msqrt><mn>4</mn></msqrt></math>
    问“什么数乘以自己会得到4？”当然是2。请注意，<math alttext="4 Superscript 1 slash 2"><msup><mn>4</mn>
    <mrow><mn>1</mn><mo>/</mo><mn>2</mn></mrow></msup></math> 和<math alttext="StartRoot
    4 EndRoot"><msqrt><mn>4</mn></msqrt></math> 是相同的：
- en: <math alttext="4 Superscript 1 slash 2 Baseline equals StartRoot 4 EndRoot equals
    2" display="block"><mrow><msup><mn>4</mn> <mrow><mn>1</mn><mo>/</mo><mn>2</mn></mrow></msup>
    <mo>=</mo> <msqrt><mn>4</mn></msqrt> <mo>=</mo> <mn>2</mn></mrow></math>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="4 Superscript 1 slash 2 Baseline equals StartRoot 4 EndRoot equals
    2" display="block"><mrow><msup><mn>4</mn> <mrow><mn>1</mn><mo>/</mo><mn>2</mn></mrow></msup>
    <mo>=</mo> <msqrt><mn>4</mn></msqrt> <mo>=</mo> <mn>2</mn></mrow></math>
- en: 'Cubed roots are similar to square roots, but they seek a number multiplied
    by itself three times to give a result. A cubed root of 8 is expressed as <math
    alttext="RootIndex 3 StartRoot 8 EndRoot"><mroot><mn>8</mn> <mn>3</mn></mroot></math>
    and asks “What number multiplied by itself three times gives me 8?” This number
    would be 2 because <math alttext="2 asterisk 2 asterisk 2 equals 8"><mrow><mn>2</mn>
    <mo>*</mo> <mn>2</mn> <mo>*</mo> <mn>2</mn> <mo>=</mo> <mn>8</mn></mrow></math>
    . In exponents a cubed root is expressed as a fractional exponent, and <math alttext="RootIndex
    3 StartRoot 8 EndRoot"><mroot><mn>8</mn> <mn>3</mn></mroot></math> can be reexpressed
    as <math alttext="8 Superscript 1 slash 3"><msup><mn>8</mn> <mrow><mn>1</mn><mo>/</mo><mn>3</mn></mrow></msup></math>
    :'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 立方根类似于平方根，但它们寻找一个数，使其乘以自身三次得到一个结果。8的立方根表示为 <math alttext="RootIndex 3 StartRoot
    8 EndRoot"><mroot><mn>8</mn> <mn>3</mn></mroot></math> ，问“什么数乘以自身三次得到8？” 这个数将是2，因为
    <math alttext="2 asterisk 2 asterisk 2 equals 8"><mrow><mn>2</mn> <mo>*</mo> <mn>2</mn>
    <mo>*</mo> <mn>2</mn> <mo>=</mo> <mn>8</mn></mrow></math> 。在指数中，立方根表示为一个分数指数，<math
    alttext="RootIndex 3 StartRoot 8 EndRoot"><mroot><mn>8</mn> <mn>3</mn></mroot></math>
    可以重新表示为 <math alttext="8 Superscript 1 slash 3"><msup><mn>8</mn> <mrow><mn>1</mn><mo>/</mo><mn>3</mn></mrow></msup></math>
    ：
- en: <math alttext="8 Superscript 1 slash 3 Baseline equals RootIndex 3 StartRoot
    8 EndRoot equals 2" display="block"><mrow><msup><mn>8</mn> <mrow><mn>1</mn><mo>/</mo><mn>3</mn></mrow></msup>
    <mo>=</mo> <mroot><mn>8</mn> <mn>3</mn></mroot> <mo>=</mo> <mn>2</mn></mrow></math>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="8 Superscript 1 slash 3 Baseline equals RootIndex 3 StartRoot
    8 EndRoot equals 2" display="block"><mrow><msup><mn>8</mn> <mrow><mn>1</mn><mo>/</mo><mn>3</mn></mrow></msup>
    <mo>=</mo> <mroot><mn>8</mn> <mn>3</mn></mroot> <mo>=</mo> <mn>2</mn></mrow></math>
- en: 'To bring it back full circle, what happens when you multiply the cubed root
    of 8 three times? This will undo the cubed root and yield 8\. Alternatively, if
    we express the cubed root as fractional exponents <math alttext="8 Superscript
    1 slash 3"><msup><mn>8</mn> <mrow><mn>1</mn><mo>/</mo><mn>3</mn></mrow></msup></math>
    , it becomes clear we add the exponents together to get an exponent of 1\. That
    also undoes the cubed root:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将其完整地回到原点，当你将8的立方根乘三次时会发生什么？这将撤销立方根并产生8\. 或者，如果我们将立方根表示为分数指数 <math alttext="8
    Superscript 1 slash 3"><msup><mn>8</mn> <mrow><mn>1</mn><mo>/</mo><mn>3</mn></mrow></msup></math>
    ，清楚地表明我们将指数相加以获得指数1\. 这也撤销了立方根：
- en: <math alttext="RootIndex 3 StartRoot 8 EndRoot asterisk RootIndex 3 StartRoot
    8 EndRoot asterisk RootIndex 3 StartRoot 8 EndRoot equals 8 Superscript one-third
    Baseline times 8 Superscript one-third Baseline times 8 Superscript one-third
    Baseline equals 8 Superscript one-third plus one-third plus one-third Baseline
    equals 8 Superscript 1 Baseline equals 8" display="block"><mrow><mroot><mn>8</mn>
    <mn>3</mn></mroot> <mo>*</mo> <mroot><mn>8</mn> <mn>3</mn></mroot> <mo>*</mo>
    <mroot><mn>8</mn> <mn>3</mn></mroot> <mo>=</mo> <msup><mn>8</mn> <mfrac><mn>1</mn>
    <mn>3</mn></mfrac></msup> <mo>×</mo> <msup><mn>8</mn> <mfrac><mn>1</mn> <mn>3</mn></mfrac></msup>
    <mo>×</mo> <msup><mn>8</mn> <mfrac><mn>1</mn> <mn>3</mn></mfrac></msup> <mo>=</mo>
    <msup><mn>8</mn> <mrow><mfrac><mn>1</mn> <mn>3</mn></mfrac><mo>+</mo><mfrac><mn>1</mn>
    <mn>3</mn></mfrac><mo>+</mo><mfrac><mn>1</mn> <mn>3</mn></mfrac></mrow></msup>
    <mo>=</mo> <msup><mn>8</mn> <mn>1</mn></msup> <mo>=</mo> <mn>8</mn></mrow></math>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="RootIndex 3 StartRoot 8 EndRoot asterisk RootIndex 3 StartRoot
    8 EndRoot asterisk RootIndex 3 StartRoot 8 EndRoot equals 8 Superscript one-third
    Baseline times 8 Superscript one-third Baseline times 8 Superscript one-third
    Baseline equals 8 Superscript one-third plus one-third plus one-third Baseline
    equals 8 Superscript 1 Baseline equals 8" display="block"><mrow><mroot><mn>8</mn>
    <mn>3</mn></mroot> <mo>*</mo> <mroot><mn>8</mn> <mn>3</mn></mroot> <mo>*</mo>
    <mroot><mn>8</mn> <mn>3</mn></mroot> <mo>=</mo> <msup><mn>8</mn> <mfrac><mn>1</mn>
    <mn>3</mn></mfrac></msup> <mo>×</mo> <msup><mn>8</mn> <mfrac><mn>1</mn> <mn>3</mn></mfrac></msup>
    <mo>×</mo> <msup><mn>8</mn> <mfrac><mn>1</mn> <mn>3</mn></mfrac></msup> <mo>=</mo>
    <msup><mn>8</mn> <mrow><mfrac><mn>1</mn> <mn>3</mn></mfrac><mo>+</mo><mfrac><mn>1</mn>
    <mn>3</mn></mfrac><mo>+</mo><mfrac><mn>1</mn> <mn>3</mn></mfrac></mrow></msup>
    <mo>=</mo> <msup><mn>8</mn> <mn>1</mn></msup> <mo>=</mo> <mn>8</mn></mrow></math>
- en: 'And one last property: an exponent of an exponent will multiply the exponents
    together. This is known as the *power rule*. So <math alttext="left-parenthesis
    8 cubed right-parenthesis squared"><msup><mrow><mo>(</mo><msup><mn>8</mn> <mn>3</mn></msup>
    <mo>)</mo></mrow> <mn>2</mn></msup></math> would simplify to <math alttext="8
    Superscript 6"><msup><mn>8</mn> <mn>6</mn></msup></math> :'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个性质：一个指数的指数将把指数相乘。这被称为*幂规则*。因此 <math alttext="left-parenthesis 8 cubed right-parenthesis
    squared"><msup><mrow><mo>(</mo><msup><mn>8</mn> <mn>3</mn></msup> <mo>)</mo></mrow>
    <mn>2</mn></msup></math> 将简化为 <math alttext="8 Superscript 6"><msup><mn>8</mn>
    <mn>6</mn></msup></math> ：
- en: <math alttext="left-parenthesis 8 cubed right-parenthesis squared equals 8 Superscript
    3 times 2 Baseline equals 8 Superscript 6" display="block"><mrow><msup><mrow><mo>(</mo><msup><mn>8</mn>
    <mn>3</mn></msup> <mo>)</mo></mrow> <mn>2</mn></msup> <mo>=</mo> <msup><mn>8</mn>
    <mrow><mn>3</mn><mo>×</mo><mn>2</mn></mrow></msup> <mo>=</mo> <msup><mn>8</mn>
    <mn>6</mn></msup></mrow></math>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="left-parenthesis 8 cubed right-parenthesis squared equals 8 Superscript
    3 times 2 Baseline equals 8 Superscript 6" display="block"><mrow><msup><mrow><mo>(</mo><msup><mn>8</mn>
    <mn>3</mn></msup> <mo>)</mo></mrow> <mn>2</mn></msup> <mo>=</mo> <msup><mn>8</mn>
    <mrow><mn>3</mn><mo>×</mo><mn>2</mn></mrow></msup> <mo>=</mo> <msup><mn>8</mn>
    <mn>6</mn></msup></mrow></math>
- en: 'If you are skeptical why this is, try expanding it and you will see the sum
    rule makes it clear:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个为什么持怀疑态度，尝试展开它，你会发现总和规则变得清晰：
- en: <math alttext="left-parenthesis 8 cubed right-parenthesis squared equals 8 cubed
    8 cubed equals 8 Superscript 3 plus 3 Baseline equals 8 Superscript 6" display="block"><mrow><msup><mrow><mo>(</mo><msup><mn>8</mn>
    <mn>3</mn></msup> <mo>)</mo></mrow> <mn>2</mn></msup> <mo>=</mo> <msup><mn>8</mn>
    <mn>3</mn></msup> <msup><mn>8</mn> <mn>3</mn></msup> <mo>=</mo> <msup><mn>8</mn>
    <mrow><mn>3</mn><mo>+</mo><mn>3</mn></mrow></msup> <mo>=</mo> <msup><mn>8</mn>
    <mn>6</mn></msup></mrow></math>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="left-parenthesis 8 cubed right-parenthesis squared equals 8 cubed
    8 cubed equals 8 Superscript 3 plus 3 Baseline equals 8 Superscript 6" display="block"><mrow><msup><mrow><mo>(</mo><msup><mn>8</mn>
    <mn>3</mn></msup> <mo>)</mo></mrow> <mn>2</mn></msup> <mo>=</mo> <msup><mn>8</mn>
    <mn>3</mn></msup> <msup><mn>8</mn> <mn>3</mn></msup> <mo>=</mo> <msup><mn>8</mn>
    <mrow><mn>3</mn><mo>+</mo><mn>3</mn></mrow></msup> <mo>=</mo> <msup><mn>8</mn>
    <mn>6</mn></msup></mrow></math>
- en: 'Lastly, what does it mean when we have a fractional exponent with a numerator
    other than 1, such as <math alttext="8 Superscript two-thirds"><msup><mn>8</mn>
    <mfrac><mn>2</mn> <mn>3</mn></mfrac></msup></math> ? Well, that is taking the
    cube root of 8 and then squaring it. Take a look:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们有一个分数指数的分子不是1时，比如 <math alttext="8 Superscript two-thirds"><msup><mn>8</mn>
    <mfrac><mn>2</mn> <mn>3</mn></mfrac></msup></math> ，那意味着什么？那是取8的立方根然后平方。看一下：
- en: <math alttext="8 Superscript two-thirds Baseline equals left-parenthesis 8 Superscript
    one-third Baseline right-parenthesis squared equals 2 squared equals 4" display="block"><mrow><msup><mn>8</mn>
    <mfrac><mn>2</mn> <mn>3</mn></mfrac></msup> <mo>=</mo> <msup><mrow><mo>(</mo><msup><mn>8</mn>
    <mfrac><mn>1</mn> <mn>3</mn></mfrac></msup> <mo>)</mo></mrow> <mn>2</mn></msup>
    <mo>=</mo> <msup><mn>2</mn> <mn>2</mn></msup> <mo>=</mo> <mn>4</mn></mrow></math>
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="8 Superscript two-thirds Baseline equals left-parenthesis 8 Superscript
    one-third Baseline right-parenthesis squared equals 2 squared equals 4" display="block"><mrow><msup><mn>8</mn>
    <mfrac><mn>2</mn> <mn>3</mn></mfrac></msup> <mo>=</mo> <msup><mrow><mo>(</mo><msup><mn>8</mn>
    <mfrac><mn>1</mn> <mn>3</mn></mfrac></msup> <mo>)</mo></mrow> <mn>2</mn></msup>
    <mo>=</mo> <msup><mn>2</mn> <mn>2</mn></msup> <mo>=</mo> <mn>4</mn></mrow></math>
- en: And yes, irrational numbers can serve as exponents like <math alttext="8 Superscript
    pi"><msup><mn>8</mn> <mi>π</mi></msup></math> , which is 687.2913\. This may feel
    unintuitive, and understandably so! In the interest of time, we will not dive
    deep into this as it requires some calculus. But essentially, we can calculate
    irrational exponents by approximating with a rational number. This is effectively
    what computers do since they can compute to only so many decimal places anyway.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，无理数可以作为指数，如 <math alttext="8 Superscript pi"><msup><mn>8</mn> <mi>π</mi></msup></math>
    ，这是687.2913\. 这可能感觉不直观，这是可以理解的！为了节约时间，我们不会深入探讨这一点，因为这需要一些微积分。但基本上，我们可以通过用有理数近似来计算无理指数。这实际上是计算机所做的，因为它们只能计算到有限的小数位数。
- en: 'For example <math alttext="pi"><mi>π</mi></math> has an infinite number of
    decimal places. But if we take the first 11 digits, 3.1415926535, we can approximate
    <math alttext="pi"><mi>π</mi></math> as a rational number 31415926535 / 10000000000\.
    Sure enough, this gives us approximately 687.2913, which should approximately
    match any calculator:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如 <math alttext="pi"><mi>π</mi></math> 有无限多位小数。但如果我们取前11位数字，3.1415926535，我们可以将
    <math alttext="pi"><mi>π</mi></math> 近似为一个有理数 31415926535 / 10000000000\. 确实，这给出了大约687.2913，这应该与任何计算器大致匹配：
- en: <math display="block"><mrow><msup><mn>8</mn> <mi>π</mi></msup> <mo>≈</mo> <msup><mn>8</mn>
    <mfrac><mn>31415926535</mn> <mn>10000000000</mn></mfrac></msup> <mo>≈</mo> <mn>687.</mn>
    <mn>2913</mn></mrow></math>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><msup><mn>8</mn> <mi>π</mi></msup> <mo>≈</mo> <msup><mn>8</mn>
    <mfrac><mn>31415926535</mn> <mn>10000000000</mn></mfrac></msup> <mo>≈</mo> <mn>687.</mn>
    <mn>2913</mn></mrow></math>
- en: Logarithms
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对数
- en: A *logarithm* is a math function that finds a power for a specific number and
    base. It may not sound interesting at first, but it actually has many applications.
    From measuring earthquakes to managing volume on your stereo, the logarithm is
    found everywhere. It also finds its way into machine learning and data science
    a lot. As a matter of fact, logarithms will be a key part of logistic regressions
    in [Chapter 6](ch06.xhtml#ch06).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*对数*是一个数学函数，它找到一个特定数字和底数的幂。起初听起来可能不那么有趣，但实际上它有许多应用。从测量地震到调节立体声音量，对数随处可见。它也经常出现在机器学习和数据科学中。事实上，对数将成为[第6章](ch06.xhtml#ch06)中逻辑回归的关键部分。'
- en: 'Start your thinking by asking “2 raised to *what power* gives me 8?” One way
    to express this mathematically is to use an *x* for the exponent:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过问“2的*多少次方*等于8？”来开始你的思考。数学上表达这个问题的一种方式是使用*x*作为指数：
- en: <math alttext="2 Superscript x Baseline equals 8" display="block"><mrow><msup><mn>2</mn>
    <mi>x</mi></msup> <mo>=</mo> <mn>8</mn></mrow></math>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="2 Superscript x Baseline equals 8" display="block"><mrow><msup><mn>2</mn>
    <mi>x</mi></msup> <mo>=</mo> <mn>8</mn></mrow></math>
- en: We intuitively know the answer, <math alttext="x equals 3"><mrow><mi>x</mi>
    <mo>=</mo> <mn>3</mn></mrow></math> , but we need a more elegant way to express
    this common math operation. This is what the <math alttext="l o g left-parenthesis
    right-parenthesis"><mrow><mi>l</mi> <mi>o</mi> <mi>g</mi> <mo>(</mo> <mo>)</mo></mrow></math>
    function is for.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直观地知道答案，<math alttext="x等于3"><mrow><mi>x</mi> <mo>=</mo> <mn>3</mn></mrow></math>，但我们需要一种更优雅的方式来表达这个常见的数学运算。这就是<math
    alttext="l o g 左括号 右括号"><mrow><mi>l</mi> <mi>o</mi> <mi>g</mi> <mo>(</mo> <mo>)</mo></mrow></math>函数的作用。
- en: <math alttext="l o g 2 Baseline 8 equals x" display="block"><mrow><mi>l</mi>
    <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub> <mn>8</mn> <mo>=</mo> <mi>x</mi></mrow></math>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="l o g 2 Baseline 8 equals x" display="block"><mrow><mi>l</mi>
    <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub> <mn>8</mn> <mo>=</mo> <mi>x</mi></mrow></math>
- en: 'As you can see in the preceding logarithm expression, we have a base 2 and
    are finding a power to give us 8\. More generally, we can reexpress a variable
    exponent as a logarithm:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在前面的对数表达式中所看到的，我们有一个底数为2，正在寻找一个幂以给出8。更一般地，我们可以将一个变量指数重新表达为一个对数：
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><msup><mi>a</mi>
    <mi>x</mi></msup> <mo>=</mo> <mi>b</mi></mrow></mtd></mtr></mtable></math> <math
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>l</mi>
    <mi>o</mi> <msub><mi>g</mi> <mi>a</mi></msub> <mi>b</mi> <mo>=</mo> <mi>x</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><msup><mi>a</mi>
    <mi>x</mi></msup> <mo>=</mo> <mi>b</mi></mrow></mtd></mtr></mtable></math> <math
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>l</mi>
    <mi>o</mi> <msub><mi>g</mi> <mi>a</mi></msub> <mi>b</mi> <mo>=</mo> <mi>x</mi></mrow></mtd></mtr></mtable></math>
- en: Algebraically speaking, this is a way of isolating the *x*, which is important
    to solve for *x*. [Example 1-12](#vOUfdcffqO) shows how we calculate this logarithm
    in Python.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 代数上讲，这是一种隔离*x*的方法，这对于解出*x*很重要。[示例 1-12](#vOUfdcffqO)展示了我们如何在Python中计算这个对数。
- en: Example 1-12\. Using the log function in Python
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例1-12\. 在Python中使用对数函数
- en: '[PRE11]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When you do not supply a base argument to a `log()` function on a platform like
    Python, it will typically have a default base. In some fields, like earthquake
    measurements, the default base for the log is 10\. But in data science the default
    base for the log is Euler’s number <math alttext="e"><mi>e</mi></math> . Python
    uses the latter, and we will talk about <math alttext="e"><mi>e</mi></math> shortly.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在像Python这样的平台上的`log()`函数中不提供一个底数参数时，它通常会有一个默认的底数。在一些领域，比如地震测量中，对数的默认底数是10。但在数据科学中，对数的默认底数是自然常数<math
    alttext="e"><mi>e</mi></math>。Python使用后者，我们很快会谈到<math alttext="e"><mi>e</mi></math>。
- en: Just like exponents, logarithms have several properties when it comes to multiplication,
    division, exponentiation, and so on. In the interest of time and focus, I will
    just present this in [Table 1-3](#daVvodFTeO). The key idea to focus on is a logarithm
    finds an exponent for a given base to result in a certain number.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 就像指数一样，对数在乘法、除法、指数运算等方面有几个性质。为了节省时间和专注力，我将在[表 1-3](#daVvodFTeO)中简要介绍这一点。关键的思想是对数找到一个给定底数的指数，使其结果为某个特定数字。
- en: If you need to dive into logarithmic properties, [Table 1-3](#daVvodFTeO) displays
    exponent and logarithm behaviors side-by-side that you can use for reference.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要深入了解对数的性质，[表 1-3](#daVvodFTeO) 显示了指数和对数的行为，你可以用作参考。
- en: Table 1-3\. Properties for exponents and logarithms
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-3\. 指数和对数的性质
- en: '| Operator | Exponent property | Logarithm property |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 指数性质 | 对数性质 |'
- en: '| --- | --- | --- |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Multiplication | <math alttext="x Superscript m Baseline times x Superscript
    n Baseline equals x Superscript m plus n"><mrow><msup><mi>x</mi> <mi>m</mi></msup>
    <mo>×</mo> <msup><mi>x</mi> <mi>n</mi></msup> <mo>=</mo> <msup><mi>x</mi> <mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow></msup></mrow></math>
    | <math alttext="l o g left-parenthesis a times b right-parenthesis equals l o
    g left-parenthesis a right-parenthesis plus l o g left-parenthesis b right-parenthesis"><mrow><mi>l</mi>
    <mi>o</mi> <mi>g</mi> <mo>(</mo> <mi>a</mi> <mo>×</mo> <mi>b</mi> <mo>)</mo> <mo>=</mo>
    <mi>l</mi> <mi>o</mi> <mi>g</mi> <mo>(</mo> <mi>a</mi> <mo>)</mo> <mo>+</mo> <mi>l</mi>
    <mi>o</mi> <mi>g</mi> <mo>(</mo> <mi>b</mi> <mo>)</mo></mrow></math> |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 乘法 | <math alttext="x Superscript m Baseline times x Superscript n Baseline
    equals x Superscript m plus n"><mrow><msup><mi>x</mi> <mi>m</mi></msup> <mo>×</mo>
    <msup><mi>x</mi> <mi>n</mi></msup> <mo>=</mo> <msup><mi>x</mi> <mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow></msup></mrow></math>
    | <math alttext="l o g left-parenthesis a times b right-parenthesis equals l o
    g left-parenthesis a right-parenthesis plus l o g left-parenthesis b right-parenthesis"><mrow><mi>l</mi>
    <mi>o</mi> <mi>g</mi> <mo>(</mo> <mi>a</mi> <mo>×</mo> <mi>b</mi> <mo>)</mo> <mo>=</mo>
    <mi>l</mi> <mi>o</mi> <mi>g</mi> <mo>(</mo> <mi>a</mi> <mo>)</mo> <mo>+</mo> <mi>l</mi>
    <mi>o</mi> <mi>g</mi> <mo>(</mo> <mi>b</mi> <mo>)</mo></mrow></math> |'
- en: '| Division | <math alttext="StartFraction x Superscript m Baseline Over x Superscript
    n Baseline EndFraction equals x Superscript m minus n"><mrow><mfrac><msup><mi>x</mi>
    <mi>m</mi></msup> <msup><mi>x</mi> <mi>n</mi></msup></mfrac> <mo>=</mo> <msup><mi>x</mi>
    <mrow><mi>m</mi><mo>-</mo><mi>n</mi></mrow></msup></mrow></math> | <math alttext="l
    o g left-parenthesis StartFraction a Over b EndFraction right-parenthesis equals
    l o g left-parenthesis a right-parenthesis minus l o g left-parenthesis b right-parenthesis"><mrow><mi>l</mi>
    <mi>o</mi> <mi>g</mi> <mrow><mo>(</mo> <mfrac><mi>a</mi> <mi>b</mi></mfrac> <mo>)</mo></mrow>
    <mo>=</mo> <mi>l</mi> <mi>o</mi> <mi>g</mi> <mrow><mo>(</mo> <mi>a</mi> <mo>)</mo></mrow>
    <mo>-</mo> <mi>l</mi> <mi>o</mi> <mi>g</mi> <mrow><mo>(</mo> <mi>b</mi> <mo>)</mo></mrow></mrow></math>
    |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 除法 | <math alttext="StartFraction x Superscript m Baseline Over x Superscript
    n Baseline EndFraction equals x Superscript m minus n"><mrow><mfrac><msup><mi>x</mi>
    <mi>m</mi></msup> <msup><mi>x</mi> <mi>n</mi></msup></mfrac> <mo>=</mo> <msup><mi>x</mi>
    <mrow><mi>m</mi><mo>-</mo><mi>n</mi></mrow></msup></mrow></math> | <math alttext="l
    o g left-parenthesis StartFraction a Over b EndFraction right-parenthesis equals
    l o g left-parenthesis a right-parenthesis minus l o g left-parenthesis b right-parenthesis"><mrow><mi>l</mi>
    <mi>o</mi> <mi>g</mi> <mrow><mo>(</mo> <mfrac><mi>a</mi> <mi>b</mi></mfrac> <mo>)</mo></mrow>
    <mo>=</mo> <mi>l</mi> <mi>o</mi> <mi>g</mi> <mrow><mo>(</mo> <mi>a</mi> <mo>)</mo></mrow>
    <mo>-</mo> <mi>l</mi> <mi>o</mi> <mi>g</mi> <mrow><mo>(</mo> <mi>b</mi> <mo>)</mo></mrow></mrow></math>
    |'
- en: '| Exponentiation | <math alttext="left-parenthesis x Superscript m Baseline
    right-parenthesis Superscript n Baseline equals x Superscript m n"><mrow><msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mi>m</mi></msup> <mo>)</mo></mrow> <mi>n</mi></msup> <mo>=</mo> <msup><mi>x</mi>
    <mrow><mi>m</mi><mi>n</mi></mrow></msup></mrow></math> | <math alttext="l o g
    left-parenthesis a Superscript n Baseline right-parenthesis equals n times l o
    g left-parenthesis a right-parenthesis"><mrow><mi>l</mi> <mi>o</mi> <mi>g</mi>
    <mrow><mo>(</mo> <msup><mi>a</mi> <mi>n</mi></msup> <mo>)</mo></mrow> <mo>=</mo>
    <mi>n</mi> <mo>×</mo> <mi>l</mi> <mi>o</mi> <mi>g</mi> <mrow><mo>(</mo> <mi>a</mi>
    <mo>)</mo></mrow></mrow></math> |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 指数运算 | <math alttext="left-parenthesis x Superscript m Baseline right-parenthesis
    Superscript n Baseline equals x Superscript m n"><mrow><msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mi>m</mi></msup> <mo>)</mo></mrow> <mi>n</mi></msup> <mo>=</mo> <msup><mi>x</mi>
    <mrow><mi>m</mi><mi>n</mi></mrow></msup></mrow></math> | <math alttext="l o g
    left-parenthesis a Superscript n Baseline right-parenthesis equals n times l o
    g left-parenthesis a right-parenthesis"><mrow><mi>l</mi> <mi>o</mi> <mi>g</mi>
    <mrow><mo>(</mo> <msup><mi>a</mi> <mi>n</mi></msup> <mo>)</mo></mrow> <mo>=</mo>
    <mi>n</mi> <mo>×</mo> <mi>l</mi> <mi>o</mi> <mi>g</mi> <mrow><mo>(</mo> <mi>a</mi>
    <mo>)</mo></mrow></mrow></math> |'
- en: '| Zero Exponent | <math alttext="x Superscript 0 Baseline equals 1"><mrow><msup><mi>x</mi>
    <mn>0</mn></msup> <mo>=</mo> <mn>1</mn></mrow></math> | <math alttext="l o g left-parenthesis
    1 right-parenthesis equals 0"><mrow><mi>l</mi> <mi>o</mi> <mi>g</mi> <mo>(</mo>
    <mn>1</mn> <mo>)</mo> <mo>=</mo> <mn>0</mn></mrow></math> |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 零指数 | <math alttext="x Superscript 0 Baseline equals 1"><mrow><msup><mi>x</mi>
    <mn>0</mn></msup> <mo>=</mo> <mn>1</mn></mrow></math> | <math alttext="l o g left-parenthesis
    1 right-parenthesis equals 0"><mrow><mi>l</mi> <mi>o</mi> <mi>g</mi> <mo>(</mo>
    <mn>1</mn> <mo>)</mo> <mo>=</mo> <mn>0</mn></mrow></math> |'
- en: '| Inverse | <math alttext="x Superscript negative 1 Baseline equals StartFraction
    1 Over x EndFraction"><mrow><msup><mi>x</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <mfrac><mn>1</mn> <mi>x</mi></mfrac></mrow></math> | <math alttext="l
    o g left-parenthesis x Superscript negative 1 Baseline right-parenthesis equals
    l o g left-parenthesis StartFraction 1 Over x EndFraction right-parenthesis equals
    minus l o g left-parenthesis x right-parenthesis"><mrow><mi>l</mi> <mi>o</mi>
    <mi>g</mi> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>)</mo></mrow> <mo>=</mo> <mi>l</mi> <mi>o</mi> <mi>g</mi> <mrow><mo>(</mo>
    <mfrac><mn>1</mn> <mi>x</mi></mfrac> <mo>)</mo></mrow> <mo>=</mo> <mo>-</mo> <mi>l</mi>
    <mi>o</mi> <mi>g</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 倒数 | <math alttext="x Superscript negative 1 Baseline equals StartFraction
    1 Over x EndFraction"><mrow><msup><mi>x</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <mfrac><mn>1</mn> <mi>x</mi></mfrac></mrow></math> | <math alttext="l
    o g left-parenthesis x Superscript negative 1 Baseline right-parenthesis equals
    l o g left-parenthesis StartFraction 1 Over x EndFraction right-parenthesis equals
    minus l o g left-parenthesis x right-parenthesis"><mrow><mi>l</mi> <mi>o</mi>
    <mi>g</mi> <mrow><mo>(</mo> <msup><mi>x</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>)</mo></mrow> <mo>=</mo> <mi>l</mi> <mi>o</mi> <mi>g</mi> <mrow><mo>(</mo>
    <mfrac><mn>1</mn> <mi>x</mi></mfrac> <mo>)</mo></mrow> <mo>=</mo> <mo>-</mo> <mi>l</mi>
    <mi>o</mi> <mi>g</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    |'
- en: Euler’s Number and Natural Logarithms
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 欧拉数和自然对数
- en: There is a special number that shows up quite a bit in math called Euler’s number
    <math alttext="e"><mi>e</mi></math> . It is a special number much like Pi <math
    alttext="pi"><mi>π</mi></math> and is approximately 2.71828\. <math alttext="e"><mi>e</mi></math>
    is used a lot because it mathematically simplifies a lot of problems. We will
    cover <math alttext="e"><mi>e</mi></math> in the context of exponents and logarithms.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中经常出现的一个特殊数字叫做欧拉数<math alttext="e"><mi>e</mi></math>。它类似于圆周率<math alttext="pi"><mi>π</mi></math>，约为2.71828。<math
    alttext="e"><mi>e</mi></math>被广泛使用，因为它在数学上简化了许多问题。我们将在指数和对数的背景下讨论<math alttext="e"><mi>e</mi></math>。
- en: Euler’s Number
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欧拉数
- en: Back in high school, my calculus teacher demonstrated Euler’s number in several
    exponential problems. Finally I asked, “Mr. Nowe, what is <math alttext="e"><mi>e</mi></math>
    anyway? Where does it come from?” I remember never being fully satisfied with
    the explanations involving rabbit populations and other natural phenomena. I hope
    to give a more satisfying explanation here.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在高中时，我的微积分老师在几个指数问题中展示了欧拉数。最后我问道，“Nowe先生，<math alttext="e"><mi>e</mi></math>到底是什么？它从哪里来？”我记得对涉及兔子种群和其他自然现象的解释从未完全满足过我。我希望在这里给出一个更令人满意的解释。
- en: Here is how I like to discover Euler’s number. Let’s say you loan $100 to somebody
    with 20% interest annually. Typically, interest will be compounded monthly, so
    the interest each month would be <math alttext=".20 slash 12 equals .01666"><mrow><mo>.</mo>
    <mn>20</mn> <mo>/</mo> <mn>12</mn> <mo>=</mo> <mo>.</mo> <mn>01666</mn></mrow></math>
    . How much will the loan balance be after two years? To keep it simple, let’s
    assume the loan does not require payments (and no payments are made) until the
    end of those two years.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我喜欢发现欧拉数的方式。假设你向某人借出$100，年利率为20%。通常，利息将每月复利，因此每月的利息将为<math alttext=".20 slash
    12 equals .01666"><mrow><mo>.</mo> <mn>20</mn> <mo>/</mo> <mn>12</mn> <mo>=</mo>
    <mo>.</mo> <mn>01666</mn></mrow></math>。两年后贷款余额将是多少？为了简单起见，假设贷款在这两年内不需要还款（也没有还款）。
- en: 'Putting together the exponent concepts we learned so far (or perhaps pulling
    out a finance textbook), we can come up with a formula to calculate interest.
    It consists of a balance *A* for a starting investment *P*, interest rate *r*,
    time span *t* (number of years), and periods *n* (number of months in each year).
    Here is the formula:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们迄今学到的指数概念汇总（或者可能翻出一本金融教科书），我们可以得出一个计算利息的公式。它包括了起始投资*P*的余额*A*，利率*r*，时间跨度*t*（年数），以及期数*n*（每年的月数）。以下是公式：
- en: <math alttext="upper A equals upper P times left-parenthesis 1 plus StartFraction
    r Over n EndFraction right-parenthesis Superscript n t" display="block"><mrow><mi>A</mi>
    <mo>=</mo> <mi>P</mi> <mo>×</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mi>r</mi>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mrow><mi>n</mi><mi>t</mi></mrow></msup></mrow></math>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper A equals upper P times left-parenthesis 1 plus StartFraction
    r Over n EndFraction right-parenthesis Superscript n t" display="block"><mrow><mi>A</mi>
    <mo>=</mo> <mi>P</mi> <mo>×</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mi>r</mi>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mrow><mi>n</mi><mi>t</mi></mrow></msup></mrow></math>
- en: 'So if we were to compound interest every month, the loan would grow to $148.69
    as calculated here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们每个月复利，贷款将增长到$148.69，如下所计算：
- en: <math display="block" class="mathml_bottom_space"><mrow><mi>A</mi> <mo>=</mo>
    <mi>P</mi> <mo>×</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mi>r</mi>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mrow><mi>n</mi><mi>t</mi></mrow></msup></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><mn>100</mn> <mo>×</mo>
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mn>.20</mn></mrow> <mn>12</mn></mfrac><mo>)</mo></mrow>
    <mrow><mn>12</mn><mo>×</mo><mn>2</mn></mrow></msup> <mo>=</mo> <mn>148.6914618</mn></mrow></math>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block" class="mathml_bottom_space"><mrow><mi>A</mi> <mo>=</mo>
    <mi>P</mi> <mo>×</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mi>r</mi>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mrow><mi>n</mi><mi>t</mi></mrow></msup></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><mn>100</mn> <mo>×</mo>
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mn>.20</mn></mrow> <mn>12</mn></mfrac><mo>)</mo></mrow>
    <mrow><mn>12</mn><mo>×</mo><mn>2</mn></mrow></msup> <mo>=</mo> <mn>148.6914618</mn></mrow></math>
- en: If you want to do this in Python, try it out with the code in [Example 1-13](#itQmQTaEjf).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在Python中尝试这个，请使用[示例1-13](#itQmQTaEjf)中的代码。
- en: Example 1-13\. Calculating compound interest in Python
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例1-13。在Python中计算复利
- en: '[PRE12]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But what if we compounded interest daily? What happens then? Change *n* to
    365:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们每天复利呢？那时会发生什么？将*n*更改为365：
- en: <math display="block" class="mathml_bottom_space"><mrow><mi>A</mi> <mo>=</mo>
    <mi>P</mi> <mo>×</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mi>r</mi>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mrow><mi>n</mi><mi>t</mi></mrow></msup></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><mn>100</mn> <mo>×</mo>
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mn>.20</mn></mrow> <mn>365</mn></mfrac><mo>)</mo></mrow>
    <mrow><mn>365</mn><mo>×</mo><mn>2</mn></mrow></msup> <mo>=</mo> <mn>149.</mn>
    <mn>1661279</mn></mrow></math>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block" class="mathml_bottom_space"><mrow><mi>A</mi> <mo>=</mo>
    <mi>P</mi> <mo>×</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mi>r</mi>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mrow><mi>n</mi><mi>t</mi></mrow></msup></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><mn>100</mn> <mo>×</mo>
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mn>.20</mn></mrow> <mn>365</mn></mfrac><mo>)</mo></mrow>
    <mrow><mn>365</mn><mo>×</mo><mn>2</mn></mrow></msup> <mo>=</mo> <mn>149.</mn>
    <mn>1661279</mn></mrow></math>
- en: 'Huh! If we compound our interest daily instead of monthly, we would earn 47.4666
    cents more at the end of two years. If we got greedy why not compound every hour
    as shown next? Will that give us even more? There are 8,760 hours in a year, so
    set *n* to that value:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！如果我们每天复利而不是每月，我们将在两年后多赚47.4666美分。如果我们贪心，为什么不每小时复利呢？下面将显示这样做是否会给我们更多？一年有8,760小时，所以将*n*设为该值：
- en: <math display="block" class="mathml_bottom_space"><mrow><mi>A</mi> <mo>=</mo>
    <mi>P</mi> <mo>×</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mi>r</mi>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mrow><mi>n</mi><mi>t</mi></mrow></msup></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><mn>100</mn> <mo>×</mo>
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mn>.20</mn></mrow> <mn>8760</mn></mfrac><mo>)</mo></mrow>
    <mrow><mn>8760</mn><mo>×</mo><mn>2</mn></mrow></msup> <mo>=</mo> <mn>149.</mn>
    <mn>1817886</mn></mrow></math>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block" class="mathml_bottom_space"><mrow><mi>A</mi> <mo>=</mo>
    <mi>P</mi> <mo>×</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mi>r</mi>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mrow><mi>n</mi><mi>t</mi></mrow></msup></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><mn>100</mn> <mo>×</mo>
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mn>.20</mn></mrow> <mn>8760</mn></mfrac><mo>)</mo></mrow>
    <mrow><mn>8760</mn><mo>×</mo><mn>2</mn></mrow></msup> <mo>=</mo> <mn>149.</mn>
    <mn>1817886</mn></row></math>
- en: 'Ah, we squeezed out roughly 2 cents more in interest! But are we experiencing
    a diminishing return? Let’s try to compound every minute! Note that there are
    525,600 minutes in a year, so let’s set that value to *n*:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，我们多挤出了大约2美分的利息！但我们是否正在经历收益递减？让我们尝试每分钟复利一次！请注意，一年有525,600分钟，所以让我们将该值设为*n*：
- en: <math display="block" class="mathml_bottom_space"><mrow><mi>A</mi> <mo>=</mo>
    <mi>P</mi> <mo>×</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mi>r</mi>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mrow><mi>n</mi><mi>t</mi></mrow></msup></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><mn>100</mn> <mo>×</mo>
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mn>.20</mn></mrow> <mn>525600</mn></mfrac><mo>)</mo></mrow>
    <mrow><mn>525600</mn><mo>×</mo><mn>2</mn></mrow></msup> <mo>=</mo> <mn>149.</mn>
    <mn>1824584</mn></mrow></math>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block" class="mathml_bottom_space"><mrow><mi>A</mi> <mo>=</mo>
    <mi>P</mi> <mo>×</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mi>r</mi>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mrow><mi>n</mi><mi>t</mi></mrow></msup></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><mn>100</mn> <mo>×</mo>
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mn>.20</mn></mrow> <mn>525600</mn></mfrac><mo>)</mo></mrow>
    <mrow><mn>525600</mn><mo>×</mo><mn>2</mn></mrow></msup> <mo>=</mo> <mn>149.</mn>
    <mn>1824584</mn></mrow></math>
- en: OK, we are only gaining smaller and smaller fractions of a cent the more frequently
    we compound. So if I keep making these periods infinitely smaller to the point
    of compounding continuously, where does this lead?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们只是在越来越频繁地复利时获得了越来越小的一分钱。所以，如果我继续使这些周期无限小，直到连续复利，这会导致什么？
- en: 'Let me introduce you to Euler’s number <math alttext="e"><mi>e</mi></math>
    , which is approximately 2.71828\. Here is the formula to compound “continuously,”
    meaning we are compounding nonstop:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我向你介绍欧拉数 <math alttext="e"><mi>e</mi></math> ，约为 2.71828。这是连续复利的公式，“连续”意味着我们不停地复利：
- en: <math alttext="upper A equals upper P times e Superscript r t" display="block"><mrow><mi>A</mi>
    <mo>=</mo> <mi>P</mi> <mo>×</mo> <msup><mi>e</mi> <mrow><mi>r</mi><mi>t</mi></mrow></msup></mrow></math>
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper A equals upper P times e Superscript r t" display="block"><mrow><mi>A</mi>
    <mo>=</mo> <mi>P</mi> <mo>×</mo> <msup><mi>e</mi> <mrow><mi>r</mi><mi>t</mi></mrow></msup></mrow></math>
- en: 'Returning to our example, let’s calculate the balance of our loan after two
    years if we compounded continuously:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子，让我们计算在连续复利两年后我们贷款的余额：
- en: <math display="block"><mrow><mi>A</mi> <mo>=</mo> <mi>P</mi> <mo>×</mo> <msup><mi>e</mi>
    <mrow><mi>r</mi><mi>t</mi></mrow></msup></mrow></math> <math display="block"><mrow><mi>A</mi>
    <mo>=</mo> <mn>100</mn> <mo>×</mo> <msup><mi>e</mi> <mrow><mo>.</mo><mn>20</mn><mo>×</mo><mn>2</mn></mrow></msup>
    <mo>=</mo> <mn>149.</mn> <mn>1824698</mn></mrow></math>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><mi>A</mi> <mo>=</mo> <mi>P</mi> <mo>×</mo> <msup><mi>e</mi>
    <mrow><mi>r</mi><mi>t</mi></mrow></msup></mrow></math> <math display="block"><mrow><mi>A</mi>
    <mo>=</mo> <mn>100</mn> <mo>×</mo> <msup><mi>e</mi> <mrow><mo>.</mo><mn>20</mn><mo>×</mo><mn>2</mn></mrow></msup>
    <mo>=</mo> <mn>149.</mn> <mn>1824698</mn></mrow></math>
- en: This is not too surprising considering compounding every minute got us a balance
    of 149.1824584\. That got us really close to our value of 149.1824698 when compounding
    continuously.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到每分钟复利使我们得到了 149.1824584 的余额，这并不太令人惊讶。当我们连续复利时，这使我们非常接近 149.1824698 的值。
- en: Typically you use <math alttext="e"><mi>e</mi></math> as an exponent base in
    Python, Excel, and other platforms using the `exp()` function. You will find that
    <math alttext="e"><mi>e</mi></math> is so commonly used, it is the default base
    for both exponent and logarithm functions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在 Python、Excel 和其他平台中使用 `exp()` 函数时，你会将 <math alttext="e"><mi>e</mi></math>
    作为指数的底数。你会发现 <math alttext="e"><mi>e</mi></math> 如此常用，它是指数和对数函数的默认底数。
- en: '[Example 1-14](#lLjrCcMcPg) calculates continuous interest in Python using
    the `exp()` function.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1-14](#lLjrCcMcPg) 使用 `exp()` 函数在 Python 中计算连续利息。'
- en: Example 1-14\. Calculating continuous interest in Python
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-14\. 在 Python 中计算连续利息
- en: '[PRE13]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So where do we derive this constant <math alttext="e"><mi>e</mi></math> ? Compare
    the compounding interest formula and the continuous interest formula. They structurally
    look similar but have some differences:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们从哪里得到这个常数 <math alttext="e"><mi>e</mi></math>？比较复利利息公式和连续利息公式。它们在结构上看起来相似，但有一些差异：
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>A</mi>
    <mo>=</mo> <mi>P</mi> <mo>×</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mi>r</mi>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mrow><mi>n</mi><mi>t</mi></mrow></msup></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>A</mi>
    <mo>=</mo> <mi>P</mi> <mo>×</mo> <msup><mi>e</mi> <mrow><mi>r</mi><mi>t</mi></mrow></msup></mrow></mtd></mtr></mtable></math>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>A</mi>
    <mo>=</mo> <mi>P</mi> <mo>×</mo> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mi>r</mi>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mrow><mi>n</mi><mi>t</mi></mrow></msup></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>A</mi>
    <mo>=</mo> <mi>P</mi> <mo>×</mo> <msup><mi>e</mi> <mrow><mi>r</mi><mi>t</mi></mrow></msup></mrow></mtd></mtr></mtable></math>
- en: 'More technically speaking, <math alttext="e"><mi>e</mi></math> is the resulting
    value of the expression <math alttext="left-parenthesis 1 plus StartFraction 1
    Over n EndFraction right-parenthesis Superscript n"><msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mi>n</mi></msup></math> as *n* forever gets
    bigger and bigger, thus approaching infinity. Try experimenting with increasingly
    large values for *n*. By making it larger and larger you will notice something:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，<math alttext="e"><mi>e</mi></math> 是表达式 <math alttext="left-parenthesis
    1 plus StartFraction 1 Over n EndFraction right-parenthesis Superscript n"><msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mi>n</mi></msup></math> 随着 *n* 不断增大而趋近于无穷大的结果。尝试使用越来越大的
    *n* 值进行实验。通过使其变得越来越大，你会注意到一些事情：
- en: <math display="block" class="mathml_bottom_space"><msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mi>n</mi></msup></math> <math display="block"
    class="mathml_bottom_space"><mrow><msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mn>100</mn></mfrac><mo>)</mo></mrow> <mn>100</mn></msup> <mo>=</mo> <mn>2.70481382942</mn></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mn>1000</mn></mfrac><mo>)</mo></mrow> <mn>1000</mn></msup> <mo>=</mo> <mn>2.71692393224</mn></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mn>10000</mn></mfrac><mo>)</mo></mrow> <mn>10000</mn></msup> <mo>=</mo> <mn>2.71814592682</mn></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mn>10000000</mn></mfrac><mo>)</mo></mrow> <mn>10000000</mn></msup> <mo>=</mo>
    <mn>2.71828169413</mn></mrow></math>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block" class="mathml_bottom_space"><msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mi>n</mi></msup></math> <math display="block"
    class="mathml_bottom_space"><mrow><msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mn>100</mn></mfrac><mo>)</mo></mrow> <mn>100</mn></msup> <mo>=</mo> <mn>2.70481382942</mn></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mn>1000</mn></mfrac><mo>)</mo></mrow> <mn>1000</mn></msup> <mo>=</mo> <mn>2.71692393224</mn></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mn>10000</mn></mfrac><mo>)</mo></mrow> <mn>10000</mn></msup> <mo>=</mo> <mn>2.71814592682</mn></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mn>10000000</mn></mfrac><mo>)</mo></mrow> <mn>10000000</mn></msup> <mo>=</mo>
    <mn>2.71828169413</mn></mrow></math>
- en: As you make *n* larger, there is a diminishing return and it converges approximately
    on the value 2.71828, which is our value <math alttext="e"><mi>e</mi></math> .
    You will find this <math alttext="e"><mi>e</mi></math> used not just in studying
    populations and their growth. It plays a key role in many areas of mathematics.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 随着*n*的增大，收益递减，最终收敛到约为2.71828的值，这就是我们的值<math alttext="e"><mi>e</mi></math>。您会发现这个<math
    alttext="e"><mi>e</mi></math>不仅用于研究人口及其增长，还在数学的许多领域中发挥着关键作用。
- en: Later in the book, we will use Euler’s number to build normal distributions
    in [Chapter 3](ch03.xhtml#ch03) and logistic regressions in [Chapter 6](ch06.xhtml#ch06).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 本书后面将使用欧拉数来构建[第3章](ch03.xhtml#ch03)中的正态分布和[第6章](ch06.xhtml#ch06)中的逻辑回归。
- en: Natural Logarithms
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自然对数
- en: 'When we use <math alttext="e"><mi>e</mi></math> as our base for a logarithm,
    we call it a *natural logarithm*. Depending on the platform, we may use `ln()`
    instead of `log()` to specify a natural logarithm. So rather than express a natural
    logarithm expressed as <math alttext="l o g Subscript e Baseline Baseline 10"><mrow><mi>l</mi>
    <mi>o</mi> <msub><mi>g</mi> <mi>e</mi></msub> <mn>10</mn></mrow></math> to find
    the power raised on <math alttext="e"><mi>e</mi></math> to get 10, we would shorthand
    it as <math alttext="l n left-parenthesis 10 right-parenthesis"><mrow><mi>l</mi>
    <mi>n</mi> <mo>(</mo> <mn>10</mn> <mo>)</mo></mrow></math> :'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以<math alttext="e"><mi>e</mi></math>作为对数的底数时，我们称之为*自然对数*。根据平台的不同，我们可能会使用`ln()`来表示自然对数，而不是`log()`。因此，为了找到幂次为<math
    alttext="e"><mi>e</mi></math>的10，我们不再表达自然对数为<math alttext="l o g Subscript e Baseline
    Baseline 10"><mrow><mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mi>e</mi></msub> <mn>10</mn></mrow></math>，而是简写为<math
    alttext="l n left-parenthesis 10 right-parenthesis"><mrow><mi>l</mi> <mi>n</mi>
    <mo>(</mo> <mn>10</mn> <mo>)</mo></mrow></math>：
- en: <math alttext="l o g Subscript e Baseline Baseline 10 equals l n left-parenthesis
    10 right-parenthesis" display="block"><mrow><mi>l</mi> <mi>o</mi> <msub><mi>g</mi>
    <mi>e</mi></msub> <mn>10</mn> <mo>=</mo> <mi>l</mi> <mi>n</mi> <mrow><mo>(</mo>
    <mn>10</mn> <mo>)</mo></mrow></mrow></math>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="l o g Subscript e Baseline Baseline 10 equals l n left-parenthesis
    10 right-parenthesis" display="block"><mrow><mi>l</mi> <mi>o</mi> <msub><mi>g</mi>
    <mi>e</mi></msub> <mn>10</mn> <mo>=</mo> <mi>l</mi> <mi>n</mi> <mrow><mo>(</mo>
    <mn>10</mn> <mo>)</mo></mrow></mrow></math>
- en: However, in Python, a natural logarithm is specified by the `log()` function.
    As discussed earlier, the default base for the `log()` function is <math alttext="e"><mi>e</mi></math>
    . Just leave the second argument for the base empty and it will default to using
    <math alttext="e"><mi>e</mi></math> as the base shown in [Example 1-15](#OmWoPUVAot).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Python中，自然对数由`log()`函数指定。正如前面讨论的，`log()`函数的默认底数是<math alttext="e"><mi>e</mi></math>。只需将底数的第二个参数留空，它将默认使用<math
    alttext="e"><mi>e</mi></math>作为底数，如[示例1-15](#OmWoPUVAot)所示。
- en: Example 1-15\. Calculating the natural logarithm of 10 in Python
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例1-15。在Python中计算10的自然对数
- en: '[PRE14]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We will use <math alttext="e"><mi>e</mi></math> in a number of places throughout
    this book. Feel free to experiment with exponents and logarithms using Excel,
    Python, Desmos.com, or any other calculation platform of your choice. Make graphs
    and get comfortable with what these functions look like.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中的许多地方使用<math alttext="e"><mi>e</mi></math>。请随意使用Excel、Python、Desmos.com或您选择的任何其他计算平台进行指数和对数的实验。制作图表，熟悉这些函数的外观。
- en: Limits
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 极限
- en: As we have seen with Euler’s number, some interesting ideas emerge when we forever
    increase or decrease an input variable and the output variable keeps approaching
    a value but never reaching it. Let’s formally explore this idea.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在欧拉数中看到的，当我们永远增加或减少一个输入变量时，输出变量不断接近一个值但永远不会达到它时，一些有趣的想法会出现。让我们正式探索这个想法。
- en: 'Take this function, which is plotted in [Figure 1-5](#HvAcMVmcpE):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个函数，在[图 1-5](#HvAcMVmcpE)中绘制：
- en: <math alttext="f left-parenthesis x right-parenthesis equals StartFraction 1
    Over x EndFraction" display="block"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <mi>x</mi></mfrac></mrow></math>![emds
    0105](Images/emds_0105.png)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x right-parenthesis equals StartFraction 1
    Over x EndFraction" display="block"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <mi>x</mi></mfrac></mrow></math>![emds
    0105](Images/emds_0105.png)
- en: Figure 1-5\. A function that forever approaches 0 but never reaches 0
  id: totrans-231
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-5。一个永远接近0但永远不会达到0的函数
- en: We are looking only at positive *x* values. Notice that as *x* forever increases,
    *f(x)* gets closer to 0. Fascinatingly, *f(x)* never actually reaches 0\. It just
    forever keeps getting closer.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只考虑正*x*值。注意随着*x*不断增加，*f(x)*越来越接近0。有趣的是，*f(x)*实际上永远不会达到0。它只是永远不断地接近。
- en: 'Therefore the fate of this function is, as <math alttext="x"><mi>x</mi></math>
    forever extends into infinity, it will keep getting closer to 0 but never reach
    0\. The way we express a value that is forever being approached, but never reached,
    is through a limit:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个函数的命运是，当*x*永远延伸到无穷大时，它将不断接近0但永远不会达到0。我们表达一个永远被接近但永远不被达到的值的方式是通过一个极限：
- en: <math alttext="limit Underscript x right-arrow normal infinity Endscripts StartFraction
    1 Over x EndFraction equals 0" display="block"><mrow><munder><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mi>∞</mi></mrow></munder> <mfrac><mn>1</mn>
    <mi>x</mi></mfrac> <mo>=</mo> <mn>0</mn></mrow></math>
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="limit Underscript x right-arrow normal infinity Endscripts StartFraction
    1 Over x EndFraction equals 0" display="block"><mrow><munder><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>x</mi><mo>→</mo><mi>∞</mi></mrow></munder> <mfrac><mn>1</mn>
    <mi>x</mi></mfrac> <mo>=</mo> <mn>0</mn></mrow></math>
- en: The way we read this is “as x approaches infinity, the function 1/x approaches
    0 (but never reaches 0).” You will see this kind of “approach but never touch”
    behavior a lot, especially when we dive into derivatives and integrals.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们读这个的方式是“当x趋近于无穷大时，函数1/x趋近于0（但永远不会达到0）。”你会经常看到这种“趋近但永远不触及”的行为，特别是当我们深入研究导数和积分时。
- en: Using SymPy, we can calculate what value we approach for <math alttext="f left-parenthesis
    x right-parenthesis equals StartFraction 1 Over x EndFraction"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <mi>x</mi></mfrac></mrow></math>
    as *x* approaches infinity <math alttext="normal infinity"><mi>∞</mi></math> ([Example 1-16](#PklTKwuIQJ)).
    Note that <math alttext="normal infinity"><mi>∞</mi></math> is cleverly expressed
    in SymPy with `oo`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SymPy，我们可以计算当*x*趋近于无穷大时，<math alttext="f left-parenthesis x right-parenthesis
    equals StartFraction 1 Over x EndFraction"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <mi>x</mi></mfrac></mrow></math>会趋近于什么值（[示例 1-16](#PklTKwuIQJ)）。注意，<math
    alttext="normal infinity"><mi>∞</mi></math>在SymPy中用`oo`巧妙表示。
- en: Example 1-16\. Using SymPy to calculate limits
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例1-16。使用SymPy计算极限
- en: '[PRE15]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you have seen, we discovered Euler’s number <math alttext="e"><mi>e</mi></math>
    this way too. It is the result of forever extending *n* into infinity for this
    function:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们也是通过这种方式发现了欧拉数<math alttext="e"><mi>e</mi></math>。这是将*n*永远延伸到无穷大的函数的结果：
- en: <math display="block" class="mathml_bottom_space"><mrow><munder><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>n</mi><mo>→</mo><mi>∞</mi></mrow></munder> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mi>n</mi></msup> <mo>=</mo> <mi>e</mi> <mo>=</mo>
    <mn>2.</mn> <mn>71828169413</mn> <mo>...</mo></mrow></math>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block" class="mathml_bottom_space"><mrow><munder><mo movablelimits="true"
    form="prefix">lim</mo> <mrow><mi>n</mi><mo>→</mo><mi>∞</mi></mrow></munder> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn>
    <mi>n</mi></mfrac><mo>)</mo></mrow> <mi>n</mi></msup> <mo>=</mo> <mi>e</mi> <mo>=</mo>
    <mn>2.</mn> <mn>71828169413</mn> <mo>...</mo></mrow></math>
- en: 'Funnily enough, when we calculate Euler’s number with limits in SymPy (shown
    in the following code), SymPy immediately recognizes it as Euler’s number. We
    can call `evalf()` so we can actually display it as a number:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，当我们在SymPy中使用极限计算欧拉数（如下面的代码所示）时，SymPy立即将其识别为欧拉数。我们可以调用`evalf()`以便实际显示它作为一个数字：
- en: '[PRE16]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Derivatives
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导数
- en: Let’s go back to talking about functions and look at them from a calculus perspective,
    starting with derivatives. A *derivative* tells the slope of a function, and it
    is useful to measure the rate of change at any point in a function.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到谈论函数，并从微积分的角度来看待它们，首先是导数。*导数*告诉我们函数的斜率，它有助于衡量函数在任意点的变化率。
- en: Why do we care about derivatives? They are often used in machine learning and
    other mathematical algorithms, especially with gradient descent. When the slope
    is 0, that means we are at the minimum or maximum of an output variable. This
    concept will be useful later when we do linear regression ([Chapter 5](ch05.xhtml#ch05)),
    logistic regression ([Chapter 6](ch06.xhtml#ch06)), and neural networks ([Chapter 7](ch07.xhtml#ch07)).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么关心导数？它们经常在机器学习和其他数学算法中使用，特别是在梯度下降中。当斜率为0时，这意味着我们处于输出变量的最小值或最大值。当我们进行线性回归（[第5章](ch05.xhtml#ch05)）、逻辑回归（[第6章](ch06.xhtml#ch06)）和神经网络（[第7章](ch07.xhtml#ch07)）时，这个概念将会很有用。
- en: Let’s start with a simple example. Let’s take a look at the function <math alttext="f
    left-parenthesis x right-parenthesis equals x squared"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
    in [Figure 1-6](#rLSwvtqPRa). How “steep” is the curve at *x = 2*?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始。让我们看看[图1-6](#rLSwvtqPRa)中的函数<math alttext="f left-parenthesis
    x right-parenthesis equals x squared"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>。在*x
    = 2*处曲线有多“陡峭”？
- en: Notice that we can measure “steepness” at any point in the curve, and we can
    visualize this with a tangent line. Think of a *tangent line* as a straight line
    that “just touches” the curve at a given point. It also provides the slope at
    a given point. You can crudely estimate a tangent line at a given x-value by creating
    a line intersecting that x-value and a *really close* neighboring x-value on the
    function.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以在曲线的任意点测量“陡峭度”，并且可以用切线来可视化这一点。将*tangent line*想象成“刚好触及”曲线的直线在给定点。它还提供了给定点的斜率。您可以通过创建一条与该x值和函数上的一个*非常接近*的相邻x值相交的线来粗略估计给定x值处的切线。
- en: Take *x* = 2 and a nearby value *x* = 2.1, which when passed to the function
    <math alttext="f left-parenthesis x right-parenthesis equals x squared"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
    will yield *f*(2) = 4 and *f*(2.1) = 4.41 as shown in [Figure 1-7](#pptiNCfVKL).
    The resulting line that passes through these two points has a slope of 4.1.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 取*x* = 2和附近值*x* = 2.1，当传递给函数<math alttext="f left-parenthesis x right-parenthesis
    equals x squared"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>时，将得到*f*(2) = 4和*f*(2.1)
    = 4.41，如[图1-7](#pptiNCfVKL)所示。通过这两点的结果线的斜率为4.1。
- en: '![emds 0106](Images/emds_0106.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0106](Images/emds_0106.png)'
- en: Figure 1-6\. Observing steepness at a given part of the function
  id: totrans-250
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-6\. 观察函数某一部分的陡峭程度
- en: '![emds 0107](Images/emds_0107.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0107](Images/emds_0107.png)'
- en: Figure 1-7\. A crude way of calculating slope
  id: totrans-252
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-7\. 计算斜率的粗略方法
- en: 'You can quickly calculate the slope <math alttext="m"><mi>m</mi></math> between
    two points using the simple rise-over-run formula:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单的上升-下降公式，您可以快速计算两点之间的斜率<math alttext="m"><mi>m</mi></math>：
- en: <math display="block" class="mathml_bottom_space"><mrow><mi>m</mi> <mo>=</mo>
    <mfrac><mrow><msub><mi>y</mi> <mn>2</mn></msub> <mo>-</mo><msub><mi>y</mi> <mn>1</mn></msub></mrow>
    <mrow><msub><mi>x</mi> <mn>2</mn></msub> <mo>-</mo><msub><mi>x</mi> <mn>1</mn></msub></mrow></mfrac></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><mi>m</mi> <mo>=</mo>
    <mfrac><mrow><mn>4.</mn><mn>41</mn><mo>-</mo><mn>4.</mn><mn>0</mn></mrow> <mrow><mn>2.</mn><mn>1</mn><mo>-</mo><mn>2.</mn><mn>0</mn></mrow></mfrac></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><mi>m</mi> <mo>=</mo>
    <mn>4.1</mn></mrow></math>
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block" class="mathml_bottom_space"><mrow><mi>m</mi> <mo>=</mo>
    <mfrac><mrow><msub><mi>y</mi> <mn>2</mn></msub> <mo>-</mo><msub><mi>y</mi> <mn>1</mn></msub></mrow>
    <mrow><msub><mi>x</mi> <mn>2</mn></msub> <mo>-</mo><msub><mi>x</mi> <mn>1</mn></msub></mrow></mfrac></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><mi>m</mi> <mo>=</mo>
    <mfrac><mrow><mn>4.</mn><mn>41</mn><mo>-</mo><mn>4.</mn><mn>0</mn></mrow> <mrow><mn>2.</mn><mn>1</mn><mo>-</mo><mn>2.</mn><mn>0</mn></mrow></mfrac></mrow></math>
    <math display="block" class="mathml_bottom_space"><mrow><mi>m</mi> <mo>=</mo>
    <mn>4.1</mn></mrow></math>
- en: If I made the *x* step between the two points even smaller, like *x* = 2 and
    *x* = 2.00001, which would result in *f*(2) = 4 and *f*(2.00001) = 4.00004, that
    would get *really* close to the actual slope of 4\. So the smaller the step is
    to the neighboring value, the closer we get to the slope value at a given point
    in the curve. Like so many important concepts in math, we find something meaningful
    as we approach infinitely large or infinitely small values.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将两点之间的*x*步长变得更小，比如*x* = 2和*x* = 2.00001，这将导致*f*(2) = 4和*f*(2.00001) = 4.00004，这将非常接近实际斜率4。因此，步长越小，接近函数中给定点的斜率值就越接近。就像数学中许多重要概念一样，当我们接近无限大或无限小的值时，我们会发现一些有意义的东西。
- en: '[Example 1-17](#MHkbJbUrcu) shows a derivative calculator implemented in Python.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例1-17](#MHkbJbUrcu)展示了Python中实现的导数计算器。'
- en: Example 1-17\. A derivative calculator in Python
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-17\. Python中的导数计算器
- en: '[PRE17]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now the good news is there is a cleaner way to calculate the slope anywhere
    on a function. We have already been using SymPy to plot graphs, but I will show
    you how it can also do tasks like derivatives using the magic of symbolic computation.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在好消息是有一种更干净的方法可以计算函数上任何位置的斜率。我们已经在使用SymPy绘制图形，但我将向您展示它如何使用符号计算的魔力来执行导数等任务。
- en: 'When you encounter an exponential function like <math alttext="f left-parenthesis
    x right-parenthesis equals x squared"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
    the derivative function will make the exponent a multiplier and then decrement
    the exponent by 1, leaving us with the derivative <math alttext="StartFraction
    d Over d x EndFraction x squared equals 2 x"><mrow><mfrac><mi>d</mi> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>=</mo> <mn>2</mn> <mi>x</mi></mrow></math>
    . The <math alttext="StartFraction d Over d x EndFraction"><mfrac><mi>d</mi> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></math>
    indicates a *derivative with respect to x*, which says we are building a derivative
    targeting the x-value to get its slope. So if we want to find the slope at *x*
    = 2, and we have the derivative function, we just plug in that x-value to get
    the slope:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到类似<math alttext="f left-parenthesis x right-parenthesis equals x squared"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>的指数函数时，导数函数将使指数成为乘数，然后将指数减1，留下导数<math
    alttext="StartFraction d Over d x EndFraction x squared equals 2 x"><mrow><mfrac><mi>d</mi>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <msup><mi>x</mi> <mn>2</mn></msup> <mo>=</mo>
    <mn>2</mn> <mi>x</mi></mrow></math>。 <math alttext="StartFraction d Over d x EndFraction"><mfrac><mi>d</mi>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></math>表示*关于x的导数*，这意味着我们正在构建一个以x值为目标的导数，以获得其斜率。因此，如果我们想要在*x*
    = 2处找到斜率，并且我们有导数函数，我们只需将该x值代入即可获得斜率：
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfrac><mi>d</mi>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mfrac><mi>d</mi> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>=</mo> <mn>2</mn> <mi>x</mi></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfrac><mi>d</mi>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mi>f</mi> <mrow><mo>(</mo> <mn>2</mn>
    <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <mrow><mo>(</mo> <mn>2</mn> <mo>)</mo></mrow>
    <mo>=</mo> <mn>4</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfrac><mi>d</mi>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mfrac><mi>d</mi> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>=</mo> <mn>2</mn> <mi>x</mi></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfrac><mi>d</mi>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mi>f</mi> <mrow><mo>(</mo> <mn>2</mn>
    <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <mrow><mo>(</mo> <mn>2</mn> <mo>)</mo></mrow>
    <mo>=</mo> <mn>4</mn></mrow></mtd></mtr></mtable></math>
- en: If you intend to learn these rules to hand-calculate derivatives, there are
    plenty of calculus books for that. But there are some nice tools to calculate
    derivatives symbolically for you. The Python library SymPy is free and open source,
    and it nicely adapts to using the Python syntax. [Example 1-18](#UGrqvRRRqf) shows
    how to calculate the derivative for <math alttext="f left-parenthesis x right-parenthesis
    equals x squared"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math> on SymPy.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算学习这些规则来手动计算导数，那么有很多关于微积分的书籍可供参考。但也有一些很好的工具可以为您符号性地计算导数。Python库SymPy是免费且开源的，很好地适应了Python语法。[示例1-18](#UGrqvRRRqf)展示了如何在SymPy中计算<math
    alttext="f left-parenthesis x right-parenthesis equals x squared"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></row> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>的导数。
- en: Example 1-18\. Calculating a derivative in SymPy
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例1-18. 在SymPy中计算导数
- en: '[PRE18]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Wow! So by declaring variables using the `symbols()` function in SymPy, I can
    then proceed to use normal Python syntax to declare my function. After that I
    can use `diff()` to calculate the derivative function. In [Example 1-19](#PocSKudWut)
    we can then take our derivative function back to plain Python and simply declare
    it as another function.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！通过在SymPy中使用`symbols()`函数声明变量，然后可以继续使用普通的Python语法声明函数。之后可以使用`diff()`来计算导数函数。在[示例1-19](#PocSKudWut)中，我们可以将导数函数转换回普通的Python，简单地将其声明为另一个函数。
- en: Example 1-19\. A derivative calculator in Python
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例1-19. Python中的导数计算器
- en: '[PRE19]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you want to keep using SymPy, you can call the `subs()` function to swap
    the *x* variable with the value `2` as shown in [Example 1-20](#tpcTiPrmOA).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想继续使用 SymPy，你可以调用`subs()`函数，将*x*变量与值`2`交换，如[示例 1-20](#tpcTiPrmOA)所示。
- en: Example 1-20\. Using the substitution feature in SymPy
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-20\. 使用 SymPy 中的替换功能
- en: '[PRE20]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Partial Derivatives
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 偏导数
- en: Another concept we will encounter in this book is *partial derivatives*, which
    we will use in Chapters [5](ch05.xhtml#ch05), [6](ch06.xhtml#ch06), and [7](ch07.xhtml#ch07).
    These are derivatives of functions that have multiple input variables.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将遇到另一个概念*偏导数*，我们将在第[5](ch05.xhtml#ch05)、[6](ch06.xhtml#ch06)和[7](ch07.xhtml#ch07)章中使用它们。这些是对具有多个输入变量的函数的导数。
- en: Think of it this way. Rather than finding the slope on a one-dimensional function,
    we have slopes with respect to multiple variables in several directions. For each
    given variable derivative, we assume the other variables are held constant. Take
    a look at the 3D graph of <math alttext="f left-parenthesis x comma y right-parenthesis
    equals 2 x cubed plus 3 y cubed"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <msup><mi>x</mi>
    <mn>3</mn></msup> <mo>+</mo> <mn>3</mn> <msup><mi>y</mi> <mn>3</mn></msup></mrow></math>
    in [Figure 1-8](#tMGIGsWCjE), and you will see we have slopes in two directions
    for two variables.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这样想吧。与其在一维函数上找到斜率，我们有多个方向上关于多个变量的斜率。对于每个给定变量的导数，我们假设其他变量保持不变。看一下<math alttext="f
    left-parenthesis x comma y right-parenthesis equals 2 x cubed plus 3 y cubed"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mn>2</mn> <msup><mi>x</mi> <mn>3</mn></msup> <mo>+</mo> <mn>3</mn> <msup><mi>y</mi>
    <mn>3</mn></msup></mrow></math> 的三维图，你会看到我们有两个变量的两个方向上的斜率。
- en: 'Let’s take the function <math alttext="f left-parenthesis x comma y right-parenthesis
    equals 2 x cubed plus 3 y cubed"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <msup><mi>x</mi>
    <mn>3</mn></msup> <mo>+</mo> <mn>3</mn> <msup><mi>y</mi> <mn>3</mn></msup></mrow></math>
    . The *x* and *y* variable each get their own derivatives <math alttext="StartFraction
    d Over d x EndFraction"><mfrac><mi>d</mi> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></math>
    and <math alttext="StartFraction d Over d y EndFraction"><mfrac><mi>d</mi> <mrow><mi>d</mi><mi>y</mi></mrow></mfrac></math>
    . These represent the slope values with respect to each variable on a multidimensional
    surface. We technically call these “slopes” *gradients* when dealing with multiple
    dimensions. These are the derivatives for *x* and *y*, followed by the SymPy code
    to calculate those derivatives:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看函数<math alttext="f left-parenthesis x comma y right-parenthesis equals
    2 x cubed plus 3 y cubed"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <msup><mi>x</mi> <mn>3</mn></msup>
    <mo>+</mo> <mn>3</mn> <msup><mi>y</mi> <mn>3</mn></msup></mrow></math> 。*x*和*y*变量分别得到它们自己的导数<math
    alttext="StartFraction d Over d x EndFraction"><mfrac><mi>d</mi> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></math>
    和 <math alttext="StartFraction d Over d y EndFraction"><mfrac><mi>d</mi> <mrow><mi>d</mi><mi>y</mi></mrow></mfrac></math>
    。这些代表在多维表面上关于每个变量的斜率值。在处理多个维度时，我们在技术上将这些称为“斜率”*梯度*。这些是*x*和*y*的导数，接着是用 SymPy 计算这些导数的代码：
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mn>2</mn> <msup><mi>x</mi> <mn>3</mn></msup> <mo>+</mo> <mn>3</mn> <msup><mi>y</mi>
    <mn>3</mn></msup></mrow></mtd></mtr></mtable></math> <math display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfrac><mi>d</mi> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <mn>2</mn> <msup><mi>x</mi> <mn>3</mn></msup> <mo>+</mo> <mn>3</mn> <msup><mi>y</mi>
    <mn>3</mn></msup> <mo>=</mo> <mn>6</mn> <msup><mi>x</mi> <mn>2</mn></msup></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfrac><mi>d</mi>
    <mrow><mi>d</mi><mi>y</mi></mrow></mfrac> <mn>2</mn> <msup><mi>x</mi> <mn>3</mn></msup>
    <mo>+</mo> <mn>3</mn> <msup><mi>y</mi> <mn>3</mn></msup> <mo>=</mo> <mn>9</mn>
    <msup><mi>y</mi> <mn>2</mn></msup></mrow></mtd></mtr></mtable></math>
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mn>2</mn> <msup><mi>x</mi> <mn>3</mn></msup> <mo>+</mo> <mn>3</mn> <msup><mi>y</mi>
    <mn>3</mn></msup></mrow></mtd></mtr></mtable></math> <math display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfrac><mi>d</mi> <mrow><mi>d</mi><mi>x</mi></mrow></mfrac>
    <mn>2</mn> <msup><mi>x</mi> <mn>3</mn></msup> <mo>+</mo> <mn>3</mn> <msup><mi>y</mi>
    <mn>3</mn></msup> <mo>=</mo> <mn>6</mn> <msup><mi>x</mi> <mn>2</mn></msup></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfrac><mi>d</mi>
    <mrow><mi>d</mi><mi>y</mi></mrow></mfrac> <mn>2</mn> <msup><mi>x</mi> <mn>3</mn></msup>
    <mo>+</mo> <mn>3</mn> <msup><mi>y</mi> <mn>3</mn></msup> <mo>=</mo> <mn>9</mn>
    <msup><mi>y</mi> <mn>2</mn></msup></mrow></mtd></mtr></mtable></math>
- en: '[Example 1-21](#peFJLntrPK) and [Figure 1-8](#tMGIGsWCjE) show how we calculate
    the partial derivatives for *x* and *y*, respectively, with SymPy.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1-21](#peFJLntrPK) 和 [图 1-8](#tMGIGsWCjE) 展示了我们如何分别使用 SymPy 计算 *x* 和 *y*
    的偏导数。'
- en: Example 1-21\. Calculating partial derivatives with SymPy
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-21\. 使用 SymPy 计算偏导数
- en: '[PRE21]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![emds 0108](Images/emds_0108.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0108](Images/emds_0108.png)'
- en: Figure 1-8\. Plotting a three-dimensional exponential function
  id: totrans-280
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-8\. 绘制三维指数函数
- en: So for (*x*,*y*) values (1,2), the slope with respect to *x* is <math alttext="6
    left-parenthesis 1 right-parenthesis equals 6"><mrow><mn>6</mn> <mo>(</mo> <mn>1</mn>
    <mo>)</mo> <mo>=</mo> <mn>6</mn></mrow></math> and the slope with respect to *y*
    is <math alttext="9 left-parenthesis 2 right-parenthesis squared equals 36"><mrow><mn>9</mn>
    <msup><mrow><mo>(</mo><mn>2</mn><mo>)</mo></mrow> <mn>2</mn></msup> <mo>=</mo>
    <mn>36</mn></mrow></math> .
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 因此对于 (*x*,*y*) 值（1,2），相对于 *x* 的斜率为 <math alttext="6 left-parenthesis 1 right-parenthesis
    equals 6"><mrow><mn>6</mn> <mo>(</mo> <mn>1</mn> <mo>)</mo> <mo>=</mo> <mn>6</mn></mrow></math>，相对于
    *y* 的斜率为 <math alttext="9 left-parenthesis 2 right-parenthesis squared equals
    36"><mrow><mn>9</mn> <msup><mrow><mo>(</mo><mn>2</mn><mo>)</mo></mrow> <mn>2</mn></msup>
    <mo>=</mo> <mn>36</mn></mrow></math>。
- en: The Chain Rule
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链式法则
- en: 'In [Chapter 7](ch07.xhtml#ch07) when we build a neural network, we are going
    to need a special math trick called the chain rule. When we compose the neural
    network layers, we will have to untangle the derivatives from each layer. But
    for now let’s learn the chain rule with a simple algebraic example. Let’s say
    you are given two functions:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第7章](ch07.xhtml#ch07) 中，当我们构建神经网络时，我们将需要一种特殊的数学技巧，称为链式法则。当我们组合神经网络层时，我们将不得不解开每一层的导数。但现在让我们通过一个简单的代数示例来学习链式法则。假设你有两个函数：
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>y</mi>
    <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>1</mn></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>z</mi>
    <mo>=</mo> <msup><mi>y</mi> <mn>3</mn></msup> <mo>-</mo> <mn>2</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>y</mi>
    <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>1</mn></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>z</mi>
    <mo>=</mo> <msup><mi>y</mi> <mn>3</mn></msup> <mo>-</mo> <mn>2</mn></mrow></mtd></mtr></mtable></math>
- en: 'Notice that these two functions are linked, because the *y* is the output variable
    in the first function but is the input variable in the second. This means we can
    substitute the first function *y* into the second function *z* like this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这两个函数是相互关联的，因为第一个函数中的 *y* 是输出变量，但在第二个函数中是输入变量。这意味着我们可以将第一个函数的 *y* 替换为第二个函数的
    *z*，如下所示：
- en: <math alttext="z equals left-parenthesis x squared plus 1 right-parenthesis
    cubed minus 2" display="block"><mrow><mi>z</mi> <mo>=</mo> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>3</mn></msup> <mo>-</mo>
    <mn>2</mn></mrow></math>
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="z equals left-parenthesis x squared plus 1 right-parenthesis
    cubed minus 2" display="block"><mrow><mi>z</mi> <mo>=</mo> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>3</mn></msup> <mo>-</mo>
    <mn>2</mn></mrow></math>
- en: So what is the derivative for *z* with respect to *x*? We already have the substitution
    expressing *z* in terms of *x*. Let’s use SymPy to calculate that in [Example 1-24](#OKUFmnIPKM).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 *z* 对 *x* 的导数是多少呢？我们已经有了用 *x* 表示 *z* 的替换。让我们使用 SymPy 在 [示例 1-24](#OKUFmnIPKM)
    中计算出来。
- en: Example 1-24\. Finding the derivative of *z* with respect to *x*
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-24\. 求 *z* 对 *x* 的导数
- en: '[PRE22]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So our derivative for *z* with respect to *x* is <math alttext="6 x left-parenthesis
    x squared plus 1 right-parenthesis squared"><mrow><mn>6</mn> <mi>x</mi> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>2</mn></msup></mrow></math>
    :'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们对*z*关于*x*的导数是<math alttext="6 x left-parenthesis x squared plus 1 right-parenthesis
    squared"><mrow><mn>6</mn> <mi>x</mi> <msup><mrow><mo>(</mo><msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>2</mn></msup></mrow></math>：
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfrac><mrow><mi>d</mi><mi>z</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mrow><mo>(</mo> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>3</mn></msup> <mo>-</mo>
    <mn>2</mn> <mo>)</mo></mrow></mrow></mtd></mtr></mtable></math> <math display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mo>=</mo> <mn>6</mn>
    <mi>x</mi> <msup><mrow><mo>(</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup></mrow></mtd></mtr></mtable></math>
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfrac><mrow><mi>d</mi><mi>z</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mrow><mo>(</mo> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>3</mn></msup> <mo>-</mo>
    <mn>2</mn> <mo>)</mo></mrow></mrow></mtd></mtr></mtable></math> <math display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mo>=</mo> <mn>6</mn>
    <mi>x</mi> <msup><mrow><mo>(</mo><msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup></mrow></mtd></mtr></mtable></math>
- en: 'But look at this. Let’s start over and take a different approach. If we take
    the derivatives of the *y* and *z* functions separately, and then multiply them
    together, this also produces the derivative of *z* with respect to *x*! Let’s
    try it:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 但是看这个。让我们重新开始，采用不同的方法。如果我们分别对*y*和*z*函数求导，然后将它们相乘，也会得到*z*关于*x*的导数！让我们试试：
- en: <math alttext="StartFraction d y Over d x EndFraction left-parenthesis x squared
    plus 1 right-parenthesis equals 2 x" display="block"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mrow><mo>(</mo> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <mi>x</mi></mrow></math><math
    alttext="StartFraction d z Over d y EndFraction left-parenthesis y cubed minus
    2 right-parenthesis equals 3 y squared" display="block"><mrow><mfrac><mrow><mi>d</mi><mi>z</mi></mrow>
    <mrow><mi>d</mi><mi>y</mi></mrow></mfrac> <mrow><mo>(</mo> <msup><mi>y</mi> <mn>3</mn></msup>
    <mo>-</mo> <mn>2</mn> <mo>)</mo></mrow> <mo>=</mo> <mn>3</mn> <msup><mi>y</mi>
    <mn>2</mn></msup></mrow></math><math alttext="StartFraction d z Over d x EndFraction
    equals left-parenthesis 2 x right-parenthesis left-parenthesis 3 y squared right-parenthesis
    equals 6 x y squared" display="block"><mrow><mfrac><mrow><mi>d</mi><mi>z</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mo>=</mo> <mrow><mo>(</mo> <mn>2</mn>
    <mi>x</mi> <mo>)</mo></mrow> <mrow><mo>(</mo> <mn>3</mn> <msup><mi>y</mi> <mn>2</mn></msup>
    <mo>)</mo></mrow> <mo>=</mo> <mn>6</mn> <mi>x</mi> <msup><mi>y</mi> <mn>2</mn></msup></mrow></math>
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d y Over d x EndFraction left-parenthesis x squared
    plus 1 right-parenthesis equals 2 x" display="block"><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mrow><mo>(</mo> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>1</mn> <mo>)</mo></mrow> <mo>=</mo> <mn>2</mn> <mi>x</mi></mrow></math><math
    alttext="StartFraction d z Over d y EndFraction left-parenthesis y cubed minus
    2 right-parenthesis equals 3 y squared" display="block"><mrow><mfrac><mrow><mi>d</mi><mi>z</mi></mrow>
    <mrow><mi>d</mi><mi>y</mi></mrow></mfrac> <mrow><mo>(</mo> <msup><mi>y</mi> <mn>3</mn></msup>
    <mo>-</mo> <mn>2</mn> <mo>)</mo></mrow> <mo>=</mo> <mn>3</mn> <msup><mi>y</mi>
    <mn>2</mn></msup></mrow></math><math alttext="StartFraction d z Over d x EndFraction
    equals left-parenthesis 2 x right-parenthesis left-parenthesis 3 y squared right-parenthesis
    equals 6 x y squared" display="block"><mrow><mfrac><mrow><mi>d</mi><mi>z</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mo>=</mo> <mrow><mo>(</mo> <mn>2</mn>
    <mi>x</mi> <mo>)</mo></mrow> <mrow><mo>(</mo> <mn>3</mn> <msup><mi>y</mi> <mn>2</mn></msup>
    <mo>)</mo></mrow> <mo>=</mo> <mn>6</mn> <mi>x</mi> <msup><mi>y</mi> <mn>2</mn></msup></mrow></math>
- en: All right, <math alttext="6 x y squared"><mrow><mn>6</mn> <mi>x</mi> <msup><mi>y</mi>
    <mn>2</mn></msup></mrow></math> may not look like <math alttext="6 x left-parenthesis
    x squared plus 1 right-parenthesis squared"><mrow><mn>6</mn> <mi>x</mi> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>2</mn></msup></mrow></math>
    , but that’s only because we have not substituted the *y* function yet. Do that
    so the entire <math alttext="StartFraction d z Over d x EndFraction"><mfrac><mrow><mi>d</mi><mi>z</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></math> derivative is expressed in terms
    of *x* without *y*.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，<math alttext="6 x y squared"><mrow><mn>6</mn> <mi>x</mi> <msup><mi>y</mi>
    <mn>2</mn></msup></mrow></math>看起来可能不像<math alttext="6 x left-parenthesis x squared
    plus 1 right-parenthesis squared"><mrow><mn>6</mn> <mi>x</mi> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>2</mn></msup></mrow></math>，但那只是因为我们还没有替换*y*函数。这样做，整个<math
    alttext="StartFraction d z Over d x EndFraction"><mfrac><mrow><mi>d</mi><mi>z</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></math>导数将用*x*而不用*y*来表示。
- en: <math alttext="StartFraction d z Over d x EndFraction equals 6 x y squared equals
    6 x left-parenthesis x squared plus 1 right-parenthesis squared" display="block"><mrow><mfrac><mrow><mi>d</mi><mi>z</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mo>=</mo> <mn>6</mn> <mi>x</mi> <msup><mi>y</mi>
    <mn>2</mn></msup> <mo>=</mo> <mn>6</mn> <mi>x</mi> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>2</mn></msup></mrow></math>
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d z Over d x EndFraction equals 6 x y squared equals
    6 x left-parenthesis x squared plus 1 right-parenthesis squared" display="block"><mrow><mfrac><mrow><mi>d</mi><mi>z</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mo>=</mo> <mn>6</mn> <mi>x</mi> <msup><mi>y</mi>
    <mn>2</mn></msup> <mo>=</mo> <mn>6</mn> <mi>x</mi> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>2</mn></msup></mrow></math>
- en: Now we see we got the same derivative function <math alttext="6 x left-parenthesis
    x squared plus 1 right-parenthesis squared"><mrow><mn>6</mn> <mi>x</mi> <msup><mrow><mo>(</mo><msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>2</mn></msup></mrow></math>
    !
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到我们得到了相同的导数函数<math alttext="6 x left-parenthesis x squared plus 1 right-parenthesis
    squared"><mrow><mn>6</mn> <mi>x</mi> <msup><mrow><mo>(</mo><msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mn>2</mn></msup></mrow></math>！
- en: 'This is the *chain rule*, which says that for a given function *y* (with input
    variable *x*) composed into another function *z* (with input variable *y*), we
    can find the derivative of *z* with respect to *x* by multiplying the two respective
    derivatives together:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是*链式法则*，它表示对于给定的函数*y*（具有输入变量*x*）组合到另一个函数*z*（具有输入变量*y*）中，我们可以通过将两个相应的导数相乘来找到*z*关于*x*的导数：
- en: <math alttext="StartFraction d z Over d x EndFraction equals StartFraction d
    z Over d y EndFraction times StartFraction d y Over d x EndFraction" display="block"><mrow><mfrac><mrow><mi>d</mi><mi>z</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mo>=</mo> <mfrac><mrow><mi>d</mi><mi>z</mi></mrow>
    <mrow><mi>d</mi><mi>y</mi></mrow></mfrac> <mo>×</mo> <mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mrow></math>
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction d z Over d x EndFraction equals StartFraction d
    z Over d y EndFraction times StartFraction d y Over d x EndFraction" display="block"><mrow><mfrac><mrow><mi>d</mi><mi>z</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac> <mo>=</mo> <mfrac><mrow><mi>d</mi><mi>z</mi></mrow>
    <mrow><mi>d</mi><mi>y</mi></mrow></mfrac> <mo>×</mo> <mfrac><mrow><mi>d</mi><mi>y</mi></mrow>
    <mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mrow></math>
- en: '[Example 1-25](#qOhQAptgSn) shows the SymPy code that makes this comparison,
    showing the derivative from the chain rule is equal to the derivative of the substituted
    function.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例1-25](#qOhQAptgSn)展示了SymPy代码，进行了这种比较，显示链式法则的导数等于替换函数的导数。'
- en: Example 1-25\. Calculating the derivative dz/dx with and without the chain rule,
    but still getting the same answer
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-25\. 使用链式法则计算导数 dz/dx，但仍然得到相同的答案
- en: '[PRE23]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The chain rule is a key part of training a neural network with the proper weights
    and biases. Rather than untangle the derivative of each node in a nested onion
    fashion, we can multiply the derivatives across each node instead, which is mathematically
    a lot easier.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 链式法则是训练神经网络的关键部分，通过适当的权重和偏差。我们可以跨越每个节点乘以导数，而不是以嵌套的洋葱方式解开每个节点的导数，这在数学上要容易得多。
- en: Integrals
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 积分
- en: The opposite of a derivative is an *integral*, which finds the area under the
    curve for a given range. In Chapters [2](ch02.xhtml#ch02) and [3](ch03.xhtml#ch03),
    we will be finding the areas under probability distributions. Although we will
    not use integrals directly, and instead will use cumulative density functions
    that are already integrated, it is good to be aware of how integrals find areas
    under curves. [Appendix A](app01.xhtml#appendix) contains examples of using this
    approach on probability distributions.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 导数的相反是*积分*，它找到给定范围下曲线下的面积。在第[2](ch02.xhtml#ch02)章和第[3](ch03.xhtml#ch03)章，我们将找到概率分布下的面积。虽然我们不会直接使用积分，而是使用已经被积分的累积密度函数，但了解积分如何找到曲线下的面积是很好的。[附录A](app01.xhtml#appendix)包含了在概率分布上使用这种方法的示例。
- en: I want to take an intuitive approach for learning integrals called the Reimann
    Sums, one that flexibly adapts to any continuous function. First, let’s point
    out that finding the area for a range under a straight line is easy. Let’s say
    I have a function <math alttext="f left-parenthesis x right-parenthesis equals
    2 x"><mrow><mi>f</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>=</mo> <mn>2</mn> <mi>x</mi></mrow></math>
    and I want to find the area under the line between 0 and 1, as shaded in [Figure 1-9](#NmOJtvwvfq).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我想采用一种直观的方法来学习积分，称为黎曼和，这种方法可以灵活适应任何连续函数。首先，让我们指出，在一条直线下的范围内找到面积是很容易的。假设我有一个函数<math
    alttext="f left-parenthesis x right-parenthesis equals 2 x"><mrow><mi>f</mi> <mo>(</mo>
    <mi>x</mi> <mo>)</mo> <mo>=</mo> <mn>2</mn> <mi>x</mi></mrow></math>，我想找到在0和1之间线下的面积，如[图1-9](#NmOJtvwvfq)中所阴影部分所示。
- en: '![emds 0109](Images/emds_0109.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0109](Images/emds_0109.png)'
- en: Figure 1-9\. Calculating an area under a linear function
  id: totrans-307
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-9\. 计算线性函数下的面积
- en: 'Notice that I am finding the area bounded between the line and the x-axis,
    and in the *x* range 0.0 to 1.0\. If you recall basic geometry formulas, the area
    *A* for a triangle is <math alttext="upper A equals one-half b h"><mrow><mi>A</mi>
    <mo>=</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mi>b</mi> <mi>h</mi></mrow></math>
    where *b* is the length of the base and *h* is the height. We can visually spot
    that <math alttext="b equals 1"><mrow><mi>b</mi> <mo>=</mo> <mn>1</mn></mrow></math>
    and <math alttext="h equals 2"><mrow><mi>h</mi> <mo>=</mo> <mn>2</mn></mrow></math>
    . So plugging into the formula, we get for our area 1.0 as calculated here:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我正在计算线和x轴之间的面积，在x范围为0.0到1.0。如果你记得基本几何公式，一个三角形的面积*A*是<math alttext="upper
    A equals one-half b h"><mrow><mi>A</mi> <mo>=</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac>
    <mi>b</mi> <mi>h</mi></mrow></math>，其中*b*是底边的长度，*h*是高度。我们可以直观地看到<math alttext="b
    equals 1"><mrow><mi>b</mi> <mo>=</mo> <mn>1</mn></mrow></math>和<math alttext="h
    equals 2"><mrow><mi>h</mi> <mo>=</mo> <mn>2</mn></mrow></math>。因此，根据公式计算，我们得到了我们的面积为1.0：
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>A</mi>
    <mo>=</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mi>b</mi> <mi>h</mi></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>A</mi>
    <mo>=</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mo>*</mo> <mn>1</mn> <mo>*</mo>
    <mn>2</mn></mrow></mtd></mtr></mtable></math> <math display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><mi>A</mi> <mo>=</mo> <mn>1</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>A</mi>
    <mo>=</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mi>b</mi> <mi>h</mi></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>A</mi>
    <mo>=</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mo>*</mo> <mn>1</mn> <mo>*</mo>
    <mn>2</mn></mrow></mtd></mtr></mtable></math> <math display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><mi>A</mi> <mo>=</mo> <mn>1</mn></mrow></mtd></mtr></mtable></math>
- en: 'That was not bad, right? But let’s look at a function that is difficult to
    find the area under: <math alttext="f left-parenthesis x right-parenthesis equals
    x squared plus 1"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>1</mn></mrow></math>
    . What is the area between 0 and 1 as shaded in [Figure 1-10](#JMHNlAJoKM)?'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 那还不错，对吧？但是让我们看一个难以计算面积的函数：<math alttext="f left-parenthesis x right-parenthesis
    equals x squared plus 1"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>1</mn></mrow></math>。在0到1之间的阴影部分的面积是多少？参见[图1-10](#JMHNlAJoKM)。
- en: '![emds 0110](Images/emds_0110.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0110](Images/emds_0110.png)'
- en: Figure 1-10\. Calculating area under nonlinear functions is less straightforward
  id: totrans-312
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-10。计算非线性函数下的面积并不那么直接
- en: Again we are interested in the area below the curve and above the x-axis, only
    within the *x* range between 0 and 1\. The curviness here does not give us a clean
    geometric formula to find the area, but here is a clever little hack you can do.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们只对x范围在0到1之间的曲线下方和x轴上方的面积感兴趣。这里的曲线不给我们一个清晰的几何公式来计算面积，但是这里有一个聪明的小技巧可以做。
- en: What if we packed five rectangles of equal length under the curve as shown in
    [Figure 1-11](#SSqkIgwVUt), where the height of each one extends from the x-axis
    to where the midpoint touches the curve?
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在曲线下方放置五个相等长度的长方形，如[图1-11](#SSqkIgwVUt)所示，其中每个长方形的高度从x轴延伸到中点触及曲线的位置，会发生什么？
- en: The area of a rectangle is <math alttext="upper A equals length times width"><mrow><mi>A</mi>
    <mo>=</mo> <mtext>length</mtext> <mo>×</mo> <mtext>width</mtext></mrow></math>
    , so we could easily sum the areas of the rectangles. Would that give us a good
    approximation of the area under the curve? What if we packed 100 rectangles? 1,000?
    100,000? As we increase the number of rectangles while decreasing their width,
    would we not get closer to the area under the curve? Yes we would, and it is yet
    another case where we increase/decrease something toward infinity to approach
    an actual value.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 长方形的面积是<math alttext="upper A equals length times width"><mrow><mi>A</mi> <mo>=</mo>
    <mtext>length</mtext> <mo>×</mo> <mtext>width</mtext></mrow></math>，因此我们可以轻松地计算长方形的面积。这样做会给我们一个好的曲线下面积的近似值吗？如果我们放置100个长方形呢？1,000个？100,000个？随着长方形数量的增加和宽度的减小，我们是否会越来越接近曲线下的面积？是的，我们会，这又是一个我们将某物增加/减少至无穷以接近实际值的情况。
- en: '![emds 0111](Images/emds_0111.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0111](Images/emds_0111.png)'
- en: Figure 1-11\. Packing rectangles under a curve to approximate area
  id: totrans-317
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-11。放置长方形以近似曲线下的面积
- en: Let’s try it out in Python. First we need a function that approximates an integral
    that we will call `approximate_integral()`. The arguments `a` and `b` will specify
    the min and max of the *x* range, respectively. `n` will be the number of rectangles
    to pack, and `f` will be the function we are integrating. We implement the function
    in [Example 1-26](#RnPCPGGrPc), and then use it to integrate our function <math
    alttext="f left-parenthesis x right-parenthesis equals x squared plus 1"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>1</mn></mrow></math> with five rectangles, between 0.0 and 1.0.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Python中试一试。首先，我们需要一个近似积分的函数，我们将其称为`approximate_integral()`。参数`a`和`b`将分别指定*x*范围的最小值和最大值。`n`将是要包含的矩形数，`f`将是我们要积分的函数。我们在[示例1-26](#RnPCPGGrPc)中实现该函数，然后使用它来积分我们的函数<math
    alttext="f left-parenthesis x right-parenthesis equals x squared plus 1"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>1</mn></mrow></math>，使用五个矩形，在0.0和1.0之间。
- en: Example 1-26\. An integral approximation in Python
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例1-26。Python中的积分近似
- en: '[PRE24]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So we get an area of 1.33\. What happens if we use 1,000 rectangles? Let’s try
    it out in [Example 1-27](#IUSbAgIHSL).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们得到了一个面积为1.33。如果我们使用1,000个矩形会发生什么？让我们在[示例1-27](#IUSbAgIHSL)中试一试。
- en: Example 1-27\. Another integral approximation in Python
  id: totrans-322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例1-27。Python中的另一个积分近似
- en: '[PRE25]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: OK, we are getting some more precision here, and getting some more decimal places.
    What about one million rectangles as shown in [Example 1-28](#VUJaeUBsNO)?
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们在这里得到了更多的精度，并获得了更多的小数位数。在[示例1-28](#VUJaeUBsNO)中展示了一百万个矩形的情况？
- en: Example 1-28\. Yet another integral approximation in Python
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例1-28。Python中的另一个积分近似
- en: '[PRE26]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: OK, I think we are getting a diminishing return here and converging on the value
    <math display="inline"><mrow><mn>1.</mn> <mover><mn>333</mn> <mo>¯</mo></mover></mrow></math>
    where the “.333” part is forever recurring. If this were a rational number, it
    is likely 4/3 = <math display="inline"><mrow><mn>1.</mn> <mover><mn>333</mn> <mo>¯</mo></mover></mrow></math>
    . As we increase the number of rectangles, the approximation starts to reach its
    limit at smaller and smaller decimals.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我认为我们在这里得到了一个递减的回报，并收敛于值<math display="inline"><mrow><mn>1.</mn> <mover><mn>333</mn>
    <mo>¯</mo></mover></mrow></math>，其中“.333”部分是永远重复的。如果这是一个有理数，很可能是4/3 = <math display="inline"><mrow><mn>1.</mn>
    <mover><mn>333</mn> <mo>¯</mo></mover></mrow></math>。随着矩形数量的增加，近似值开始在越来越小的小数处达到其极限。
- en: Now that we have some intuition on what we are trying to achieve and why, let’s
    do a more exact approach with SymPy, which happens to support rational numbers,
    in [Example 1-29](#dLhjbaolNV).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对我们试图实现的目标和原因有了一些直觉，让我们用SymPy做一个更精确的方法，它恰好支持有理数，在[示例1-29](#dLhjbaolNV)中进行。
- en: Example 1-29\. Using SymPy to perform integration
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例1-29。使用SymPy执行积分
- en: '[PRE27]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Cool! So the area actually is 4/3, which is what our previous method converged
    on. Unfortunately, plain Python (and many programming languages) only support
    decimals, but computer algebra systems like SymPy give us exact rational numbers.
    We will be using integrals to find areas under curves in Chapters [2](ch02.xhtml#ch02)
    and [3](ch03.xhtml#ch03), although we will have scikit-learn do the work for us.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！所以实际面积是4/3，这正是我们之前的方法收敛的地方。不幸的是，普通的Python（以及许多编程语言）只支持小数，但像SymPy这样的计算代数系统给我们提供了精确的有理数。我们将在第[2](ch02.xhtml#ch02)章和第[3](ch03.xhtml#ch03)章中使用积分来找到曲线下的面积，尽管我们将让scikit-learn来为我们完成这项工作。
- en: Conclusion
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter we covered some foundations we will use for the rest of this
    book. From number theory to logarithms and calculus integrals, we highlighted
    some important mathematical concepts relevant to data science, machine learning,
    and analytics. You may have questions about why these concepts are useful. That
    will come next!
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些我们将在本书中其余部分中使用的基础知识。从数论到对数和微积分积分，我们强调了一些与数据科学、机器学习和分析相关的重要数学概念。您可能会对为什么这些概念有用有疑问。接下来会解释！
- en: Before we move on to discuss probability, take a little time to skim these concepts
    one more time and then do the following exercises. You can always revisit this
    chapter as you progress through this book and refresh as necessary when you start
    applying these mathematical ideas.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论概率之前，花点时间再浏览一下这些概念，然后做以下练习。当您在阅读本书的过程中逐步应用这些数学思想时，您可以随时回顾本章并根据需要进行刷新。
- en: Exercises
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Is the value 62.6738 rational or irrational? Why or why not?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值62.6738是有理数还是无理数？为什么？
- en: 'Evaluate the expression: <math alttext="10 Superscript 7 Baseline 10 Superscript
    negative 5"><mrow><msup><mn>10</mn> <mn>7</mn></msup> <msup><mn>10</mn> <mrow><mo>-</mo><mn>5</mn></mrow></msup></mrow></math>'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算表达式：<math alttext="10 Superscript 7 Baseline 10 Superscript negative 5"><mrow><msup><mn>10</mn>
    <mn>7</mn></msup> <msup><mn>10</mn> <mrow><mo>-</mo><mn>5</mn></mrow></msup></mrow></math>
- en: 'Evaluate the expression: <math alttext="81 Superscript one-half"><msup><mn>81</mn>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac></msup></math>'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算表达式：<math alttext="81 Superscript one-half"><msup><mn>81</mn> <mfrac><mn>1</mn>
    <mn>2</mn></mfrac></msup></math>
- en: 'Evaluate the expression: <math alttext="25 Superscript three-halves"><msup><mn>25</mn>
    <mfrac><mn>3</mn> <mn>2</mn></mfrac></msup></math>'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算表达式：<math alttext="25 Superscript three-halves"><msup><mn>25</mn> <mfrac><mn>3</mn>
    <mn>2</mn></mfrac></msup></math>
- en: Assuming no payments are made, how much would a $1,000 loan be worth at 5% interest
    compounded monthly after 3 years?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设没有还款，一个$1,000的贷款在5%的利率下每月复利3年后价值多少？
- en: Assuming no payments are made, how much would a $1,000 loan be worth at 5% interest
    compounded continuously after 3 years?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设没有还款，一个$1,000的贷款在5%的利率下连续复利3年后价值多少？
- en: For the function <math alttext="f left-parenthesis x right-parenthesis equals
    3 x squared plus 1"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>3</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>1</mn></mrow></math>
    what is the slope at *x* = 3?
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于函数<math alttext="f left-parenthesis x right-parenthesis equals 3 x squared
    plus 1"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mn>3</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>1</mn></mrow></math>在*x*
    = 3处的斜率是多少？
- en: For the function <math alttext="f left-parenthesis x right-parenthesis equals
    3 x squared plus 1"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>3</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>1</mn></mrow></math>
    what is the area under the curve for *x* between 0 and 2?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于函数<math alttext="f left-parenthesis x right-parenthesis equals 3 x squared
    plus 1"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mn>3</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>+</mo> <mn>1</mn></mrow></math>在*x*在0和2之间的曲线下的面积是多少？
- en: Answers are in [Appendix B](app02.xhtml#exercise_answers).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在[附录B](app02.xhtml#exercise_answers)中。
