<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 9. Comparisons, Masks, and Boolean Logic" data-type="chapter" epub:type="chapter"><div class="chapter" id="section-0206-boolean-arrays-and-masks">
<h1><span class="label">Chapter 9. </span>Comparisons, Masks, and Boolean Logic</h1>
<p><a data-primary="Boolean masks" data-type="indexterm" id="ix_ch09-asciidoc0"/><a data-primary="masking" data-secondary="Boolean masks" data-type="indexterm" id="ix_ch09-asciidoc1"/><a data-primary="NumPy" data-secondary="Boolean masks" data-type="indexterm" id="ix_ch09-asciidoc2"/>This chapter covers the use of Boolean masks to examine and manipulate
values within NumPy arrays. Masking comes up when you want to extract,
modify, count, or otherwise manipulate values in an array based on some
criterion: for example, you might wish to count all values greater than
a certain value, or remove all outliers that are above some threshold.
In NumPy, Boolean masking is often the most efficient way to accomplish
these types of tasks.</p>
<section data-pdf-bookmark="Example: Counting Rainy Days" data-type="sect1"><div class="sect1" id="ch_0206-boolean-arrays-and-masks_example-counting-rainy-days">
<h1>Example: Counting Rainy Days</h1>
<p><a data-primary="Boolean masks" data-secondary="rainfall statistics" data-type="indexterm" id="idm45858800168128"/><a data-primary="rainfall statistics" data-type="indexterm" id="idm45858800167152"/><a data-primary="Seattle, rainfall statistics in" data-type="indexterm" id="idm45858800166480"/>Imagine you have a series of data that represents the amount of
precipitation each day for a year in a given city. For example, here
we’ll load the daily rainfall statistics for the city of
Seattle in 2015, using Pandas (see
<a data-type="xref" href="part03.xhtml#section-0300-introduction-to-pandas">Part III</a>):</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>
        <code class="kn">from</code> <code class="nn">vega_datasets</code> <code class="kn">import</code> <code class="n">data</code>

        <code class="c1"># Use DataFrame operations to extract rainfall as a NumPy array</code>
        <code class="n">rainfall_mm</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">(</code>
            <code class="n">data</code><code class="o">.</code><code class="n">seattle_weather</code><code class="p">()</code><code class="o">.</code><code class="n">set_index</code><code class="p">(</code><code class="s1">'date'</code><code class="p">)[</code><code class="s1">'precipitation'</code><code class="p">][</code><code class="s1">'2015'</code><code class="p">])</code>
        <code class="nb">len</code><code class="p">(</code><code class="n">rainfall_mm</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="mi">365</code></pre>
<p>The array contains 365 values, giving daily rainfall in millimeters from
January 1 to December 31, 2015.</p>
<p>As a first quick visualization, let’s look at the histogram
of rainy days in <a data-type="xref" href="#fig_0206-boolean-arrays-and-masks_files_in_output_6_0">Figure 9-1</a>, which was generated using
Matplotlib (we will explore this tool more fully in
<a data-type="xref" href="part04.xhtml#section-0400-introduction-to-matplotlib">Part IV</a>):</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="o">%</code><code class="k">matplotlib</code> inline
        <code class="kn">import</code> <code class="nn">matplotlib.pyplot</code> <code class="k">as</code> <code class="nn">plt</code>
        <code class="n">plt</code><code class="o">.</code><code class="n">style</code><code class="o">.</code><code class="n">use</code><code class="p">(</code><code class="s1">'seaborn-whitegrid'</code><code class="p">)</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="n">plt</code><code class="o">.</code><code class="n">hist</code><code class="p">(</code><code class="n">rainfall_mm</code><code class="p">,</code> <code class="mi">40</code><code class="p">);</code></pre>
<figure><div class="figure" id="fig_0206-boolean-arrays-and-masks_files_in_output_6_0">
<img alt="output 6 0" height="383" src="assets/output_6_0.png" width="600"/>
<h6><span class="label">Figure 9-1. </span>Histogram of 2015 rainfall in Seattle</h6>
</div></figure>
<p>This histogram gives us a general idea of what the data looks like:
despite the city’s rainy reputation, the vast majority of
days in Seattle saw near zero measured rainfall in 2015. But this
doesn’t do a good job of conveying some information
we’d like to see: for example, how many rainy days were
there in the year? What was the average precipitation on those rainy
days? How many days were there with more than 10 mm of rainfall?</p>
<p>One approach to this would be to answer these questions by hand: we
could loop through the data, incrementing a counter each time we see
values in some desired range. But for reasons discussed throughout this
chapter, such an approach is very inefficient from the standpoint of
both time writing code and time computing the result. We saw in
<a data-type="xref" href="ch06.xhtml#section-0203-computation-on-arrays-ufuncs">Chapter 6</a> that NumPy’s ufuncs can be used
in place of loops to do fast element-wise arithmetic operations on
arrays; in the same way, we can use other ufuncs to do element-wise
<em>comparisons</em> over arrays, and we can then manipulate the results to
answer the questions we have. We’ll leave the data aside for
now, and discuss some general tools in NumPy to use <em>masking</em> to quickly
answer these types of questions.</p>
</div></section>
<section data-pdf-bookmark="Comparison Operators as Ufuncs" data-type="sect1"><div class="sect1" id="ch_0206-boolean-arrays-and-masks_comparison-operators-as-ufuncs">
<h1>Comparison Operators as Ufuncs</h1>
<p><a data-primary="comparison operators" data-type="indexterm" id="ix_ch09-asciidoc3"/><a data-primary="NumPy" data-secondary="comparison operators as ufuncs" data-type="indexterm" id="ix_ch09-asciidoc4"/><a data-primary="universal functions (ufuncs)" data-secondary="comparison operators as" data-type="indexterm" id="ix_ch09-asciidoc5"/><a data-type="xref" href="ch06.xhtml#section-0203-computation-on-arrays-ufuncs">Chapter 6</a> introduced ufuncs, and focused in
particular on arithmetic operators. We saw that using <code>+</code>, <code>-</code>, <code>*</code>,
<code>/</code>, and other operators on arrays leads to element-wise operations.
NumPy also implements comparison operators such as <code>&lt;</code> (less than) and
<code>&gt;</code> (greater than) as element-wise ufuncs. The result of these
comparison operators is always an array with a Boolean data type. All
six of the standard comparison operations are available:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">x</code> <code class="o">&lt;</code> <code class="mi">3</code>  <code class="c1"># less than</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code> <code class="kc">True</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code> <code class="kc">False</code><code class="p">])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">x</code> <code class="o">&gt;</code> <code class="mi">3</code>  <code class="c1"># greater than</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="kc">False</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code>  <code class="kc">True</code><code class="p">])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">x</code> <code class="o">&lt;=</code> <code class="mi">3</code>  <code class="c1"># less than or equal</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code> <code class="kc">True</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code> <code class="kc">False</code><code class="p">])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">x</code> <code class="o">&gt;=</code> <code class="mi">3</code>  <code class="c1"># greater than or equal</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="kc">False</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code>  <code class="kc">True</code><code class="p">])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">x</code> <code class="o">!=</code> <code class="mi">3</code>  <code class="c1"># not equal</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code> <code class="kc">True</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code>  <code class="kc">True</code><code class="p">])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">x</code> <code class="o">==</code> <code class="mi">3</code>  <code class="c1"># equal</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="kc">False</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code> <code class="kc">False</code><code class="p">])</code></pre>
<p>It is also possible to do an element-wise comparison of two arrays, and
to include compound expressions:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="p">(</code><code class="mi">2</code> <code class="o">*</code> <code class="n">x</code><code class="p">)</code> <code class="o">==</code> <code class="p">(</code><code class="n">x</code> <code class="o">**</code> <code class="mi">2</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="kc">False</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code> <code class="kc">False</code><code class="p">])</code></pre>
<p>As in the case of arithmetic operators, the comparison operators are
implemented as ufuncs in NumPy; for example, when you write <code>x &lt; 3</code>,
internally NumPy uses <code>np.less(x, 3)</code>. A summary of the comparison
operators and their equivalent ufuncs is shown here:</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Equivalent ufunc</th>
<th>Operator</th>
<th>Equivalent ufunc</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>==</code></p></td>
<td><p><code>np.equal</code></p></td>
<td><p><code>!=</code></p></td>
<td><p><code>np.not_equal</code></p></td>
</tr>
<tr>
<td><p><code>&lt;</code></p></td>
<td><p><code>np.less</code></p></td>
<td><p><code>&lt;=</code></p></td>
<td><p><code>np.less_equal</code></p></td>
</tr>
<tr>
<td><p><code>&gt;</code></p></td>
<td><p><code>np.greater</code></p></td>
<td><p><code>&gt;=</code></p></td>
<td><p><code>np.greater_equal</code></p></td>
</tr>
</tbody>
</table>
<p>Just as in the case of arithmetic ufuncs, these will work on arrays of
any size and shape. Here is a two-dimensional example:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="n">rng</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">default_rng</code><code class="p">(</code><code class="n">seed</code><code class="o">=</code><code class="mi">1701</code><code class="p">)</code>
         <code class="n">x</code> <code class="o">=</code> <code class="n">rng</code><code class="o">.</code><code class="n">integers</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code> <code class="n">size</code><code class="o">=</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">))</code>
         <code class="n">x</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mi">9</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code>
                <code class="p">[</code><code class="mi">8</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">1</code><code class="p">],</code>
                <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">0</code><code class="p">]])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="n">x</code> <code class="o">&lt;</code> <code class="mi">6</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="kc">False</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code>  <code class="kc">True</code><code class="p">],</code>
                <code class="p">[</code><code class="kc">False</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code>  <code class="kc">True</code><code class="p">],</code>
                <code class="p">[</code> <code class="kc">True</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code>  <code class="kc">True</code><code class="p">]])</code></pre>
<p>In each case, the result is a Boolean array, and NumPy provides a number
of straightforward patterns for working with these Boolean results.<a data-startref="ix_ch09-asciidoc5" data-type="indexterm" id="idm45858799391552"/><a data-startref="ix_ch09-asciidoc4" data-type="indexterm" id="idm45858799402048"/><a data-startref="ix_ch09-asciidoc3" data-type="indexterm" id="idm45858799401440"/></p>
</div></section>
<section data-pdf-bookmark="Working with Boolean Arrays" data-type="sect1"><div class="sect1" id="ch_0206-boolean-arrays-and-masks_working-with-boolean-arrays">
<h1>Working with Boolean Arrays</h1>
<p><a data-primary="arrays" data-secondary="Boolean" data-type="indexterm" id="ix_ch09-asciidoc6"/>Given a Boolean array, there are a host of useful operations you can do.
We’ll work with <code>x</code>, the two-dimensional array we created
earlier:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="nb">print</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="p">[[</code><code class="mi">9</code> <code class="mi">4</code> <code class="mi">0</code> <code class="mi">3</code><code class="p">]</code>
          <code class="p">[</code><code class="mi">8</code> <code class="mi">6</code> <code class="mi">3</code> <code class="mi">1</code><code class="p">]</code>
          <code class="p">[</code><code class="mi">3</code> <code class="mi">7</code> <code class="mi">4</code> <code class="mi">0</code><code class="p">]]</code></pre>
<section data-pdf-bookmark="Counting Entries" data-type="sect2"><div class="sect2" id="ch_0206-boolean-arrays-and-masks_counting-entries">
<h2>Counting Entries</h2>
<p><a data-primary="Boolean arrays" data-secondary="counting entries in" data-type="indexterm" id="idm45858799351360"/>To count the number of <code>True</code> entries in a Boolean array,
<code>np.count_nonzero</code> is useful:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="c1"># how many values less than 6?</code>
         <code class="n">np</code><code class="o">.</code><code class="n">count_nonzero</code><code class="p">(</code><code class="n">x</code> <code class="o">&lt;</code> <code class="mi">6</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="mi">8</code></pre>
<p>We see that there are eight array entries that are less than 6. Another
way to get at this information is to use <code>np.sum</code>; in this case, <code>False</code>
is interpreted as <code>0</code>, and <code>True</code> is interpreted as <code>1</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">sum</code><code class="p">(</code><code class="n">x</code> <code class="o">&lt;</code> <code class="mi">6</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="mi">8</code></pre>
<p>The benefit of <code>np.sum</code> is that, like with other NumPy aggregation
functions, this summation can be done along rows or columns as well:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="c1"># how many values less than 6 in each row?</code>
         <code class="n">np</code><code class="o">.</code><code class="n">sum</code><code class="p">(</code><code class="n">x</code> <code class="o">&lt;</code> <code class="mi">6</code><code class="p">,</code> <code class="n">axis</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mi">3</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code></pre>
<p>This counts the number of values less than 6 in each row of the matrix.</p>
<p>If we’re interested in quickly checking whether any or all
the values are <code>True</code>, we can use (you guessed it) <code>np.any</code> or <code>np.all</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">18</code><code class="p">]:</code> <code class="c1"># are there any values greater than 8?</code>
         <code class="n">np</code><code class="o">.</code><code class="n">any</code><code class="p">(</code><code class="n">x</code> <code class="o">&gt;</code> <code class="mi">8</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">18</code><code class="p">]:</code> <code class="kc">True</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">19</code><code class="p">]:</code> <code class="c1"># are there any values less than zero?</code>
         <code class="n">np</code><code class="o">.</code><code class="n">any</code><code class="p">(</code><code class="n">x</code> <code class="o">&lt;</code> <code class="mi">0</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">19</code><code class="p">]:</code> <code class="kc">False</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">20</code><code class="p">]:</code> <code class="c1"># are all values less than 10?</code>
         <code class="n">np</code><code class="o">.</code><code class="n">all</code><code class="p">(</code><code class="n">x</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">20</code><code class="p">]:</code> <code class="kc">True</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">21</code><code class="p">]:</code> <code class="c1"># are all values equal to 6?</code>
         <code class="n">np</code><code class="o">.</code><code class="n">all</code><code class="p">(</code><code class="n">x</code> <code class="o">==</code> <code class="mi">6</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">21</code><code class="p">]:</code> <code class="kc">False</code></pre>
<p><code>np.all</code> and <code>np.any</code> can be used along particular axes as well. For
example:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">22</code><code class="p">]:</code> <code class="c1"># are all values in each row less than 8?</code>
         <code class="n">np</code><code class="o">.</code><code class="n">all</code><code class="p">(</code><code class="n">x</code> <code class="o">&lt;</code> <code class="mi">8</code><code class="p">,</code> <code class="n">axis</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">22</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="kc">False</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code>  <code class="kc">True</code><code class="p">])</code></pre>
<p>Here all the elements in the third row are less than 8, while this is
not the case for others.</p>
<p>Finally, a quick warning: as mentioned in
<a data-type="xref" href="ch07.xhtml#section-0204-computation-on-arrays-aggregates">Chapter 7</a>, Python has built-in <code>sum</code>, <code>any</code>, and
<code>all</code> functions. These have a different syntax than the NumPy versions,
and in particular will fail or produce unintended results when used on
multidimensional arrays. Be sure that you are using <code>np.sum</code>, <code>np.any</code>,
and <code>np.all</code> for these examples!</p>
</div></section>
<section data-pdf-bookmark="Boolean Operators" data-type="sect2"><div class="sect2" id="ch_0206-boolean-arrays-and-masks_boolean-operators">
<h2>Boolean Operators</h2>
<p><a data-primary="Boolean arrays" data-secondary="Boolean operators and" data-type="indexterm" id="idm45858798982160"/><a data-primary="Boolean operators" data-type="indexterm" id="idm45858798951344"/>We’ve already seen how we might count, say, all days with
less than 20 mm of rain, or all days with more than 10 mm of rain. But
what if we want to know how many days there were with more than 10 mm
and less than 20 mm of rain? We can accomplish this with
Python’s <em>bitwise logic operators</em>, <code>&amp;</code>, <code>|</code>, <code>^</code>, and <code>~</code>.
Like with the standard arithmetic operators, NumPy overloads these as
ufuncs that work element-wise on (usually Boolean) arrays.</p>
<p>For example, we can address this sort of compound question as follows:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">23</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">sum</code><code class="p">((</code><code class="n">rainfall_mm</code> <code class="o">&gt;</code> <code class="mi">10</code><code class="p">)</code> <code class="o">&amp;</code> <code class="p">(</code><code class="n">rainfall_mm</code> <code class="o">&lt;</code> <code class="mi">20</code><code class="p">))</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">23</code><code class="p">]:</code> <code class="mi">16</code></pre>
<p>This tells us that there were 16 days with rainfall of between 10 and 20
millimeters.</p>
<p>The parentheses here are important. Because of operator precedence
rules, with the parentheses removed this expression would be evaluated
as follows, which results in an error:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">rainfall_mm</code> <code class="o">&gt;</code> <code class="p">(</code><code class="mi">10</code> <code class="o">&amp;</code> <code class="n">rainfall_mm</code><code class="p">)</code> <code class="o">&lt;</code> <code class="mi">20</code></pre>
<p>Let’s demonstrate a more complicated expression. Using De
Morgan’s laws, we can compute the same result in a different
manner:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">24</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">sum</code><code class="p">(</code><code class="o">~</code><code class="p">(</code> <code class="p">(</code><code class="n">rainfall_mm</code> <code class="o">&lt;=</code> <code class="mi">10</code><code class="p">)</code> <code class="o">|</code> <code class="p">(</code><code class="n">rainfall_mm</code> <code class="o">&gt;=</code> <code class="mi">20</code><code class="p">)</code> <code class="p">))</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">24</code><code class="p">]:</code> <code class="mi">16</code></pre>
<p>Combining comparison operators and Boolean operators on arrays can lead
to a wide range of efficient logical operations.</p>
<p><a data-primary="bitwise logic operators" data-type="indexterm" id="idm45858798837840"/>The following table summarizes the bitwise Boolean operators and their
equivalent ufuncs:</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Equivalent ufunc</th>
<th>Operator</th>
<th>Equivalent ufunc</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>&amp;</code></p></td>
<td><p><code>np.bitwise_and</code></p></td>
<td/>
<td><p><code>np.bitwise_or</code></p></td>
</tr>
<tr>
<td><p><code>^</code></p></td>
<td><p><code>np.bitwise_xor</code></p></td>
<td><p><code>~</code></p></td>
<td><p><code>np.bitwise_not</code></p></td>
</tr>
</tbody>
</table>
<p>Using these tools, we can start to answer many of the questions we might
have about our weather data. Here are some examples of results we can
compute when combining Boolean operations with aggregations:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">25</code><code class="p">]:</code> <code class="nb">print</code><code class="p">(</code><code class="s2">"Number days without rain:  "</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">sum</code><code class="p">(</code><code class="n">rainfall_mm</code> <code class="o">==</code> <code class="mi">0</code><code class="p">))</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"Number days with rain:     "</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">sum</code><code class="p">(</code><code class="n">rainfall_mm</code> <code class="o">!=</code> <code class="mi">0</code><code class="p">))</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"Days with more than 10 mm: "</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">sum</code><code class="p">(</code><code class="n">rainfall_mm</code> <code class="o">&gt;</code> <code class="mi">10</code><code class="p">))</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"Rainy days with &lt; 5 mm:    "</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">sum</code><code class="p">((</code><code class="n">rainfall_mm</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code> <code class="o">&amp;</code>
                                                     <code class="p">(</code><code class="n">rainfall_mm</code> <code class="o">&lt;</code> <code class="mi">5</code><code class="p">)))</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">25</code><code class="p">]:</code> <code class="n">Number</code> <code class="n">days</code> <code class="n">without</code> <code class="n">rain</code><code class="p">:</code>   <code class="mi">221</code>
         <code class="n">Number</code> <code class="n">days</code> <code class="k">with</code> <code class="n">rain</code><code class="p">:</code>      <code class="mi">144</code>
         <code class="n">Days</code> <code class="k">with</code> <code class="n">more</code> <code class="n">than</code> <code class="mi">10</code> <code class="n">mm</code><code class="p">:</code>  <code class="mi">34</code>
         <code class="n">Rainy</code> <code class="n">days</code> <code class="k">with</code> <code class="o">&lt;</code> <code class="mi">5</code> <code class="n">mm</code><code class="p">:</code>     <code class="mi">83</code></pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Boolean Arrays as Masks" data-type="sect1"><div class="sect1" id="ch_0206-boolean-arrays-and-masks_boolean-arrays-as-masks">
<h1>Boolean Arrays as Masks</h1>
<p><a data-primary="Boolean masks" data-secondary="Boolean arrays as" data-type="indexterm" id="idm45858798733984"/><a data-primary="Boolean masks" data-secondary="working with Boolean arrays" data-type="indexterm" id="idm45858798733008"/><a data-primary="masking" data-secondary="Boolean arrays" data-type="indexterm" id="idm45858798732096"/>In the preceding section we looked at aggregates computed directly on
Boolean arrays. A more powerful pattern is to use Boolean arrays as
masks, to select particular subsets of the data themselves.
Let’s return to our <code>x</code> array from before:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">26</code><code class="p">]:</code> <code class="n">x</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">26</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mi">9</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code>
                <code class="p">[</code><code class="mi">8</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">1</code><code class="p">],</code>
                <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">0</code><code class="p">]])</code></pre>
<p>Suppose we want an array of all values in the array that are less than,
say, 5. We can obtain a Boolean array for this condition easily, as
we’ve already seen:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">27</code><code class="p">]:</code> <code class="n">x</code> <code class="o">&lt;</code> <code class="mi">5</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">27</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="kc">False</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code>  <code class="kc">True</code><code class="p">],</code>
                <code class="p">[</code><code class="kc">False</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code>  <code class="kc">True</code><code class="p">],</code>
                <code class="p">[</code> <code class="kc">True</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code>  <code class="kc">True</code><code class="p">]])</code></pre>
<p>Now, to <em>select</em> these values from the array, we can simply index on
this Boolean array; this is known as a <em>masking</em> operation:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">28</code><code class="p">]:</code> <code class="n">x</code><code class="p">[</code><code class="n">x</code> <code class="o">&lt;</code> <code class="mi">5</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">28</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mi">4</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">0</code><code class="p">])</code></pre>
<p>What is returned is a one-dimensional array filled with all the values
that meet this condition; in other words, all the values in positions at
which the mask array is <code>True</code>.</p>
<p>We are then free to operate on these values as we wish. For example, we
can compute some relevant statistics on our Seattle rain data:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">29</code><code class="p">]:</code> <code class="c1"># construct a mask of all rainy days</code>
         <code class="n">rainy</code> <code class="o">=</code> <code class="p">(</code><code class="n">rainfall_mm</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code>

         <code class="c1"># construct a mask of all summer days (June 21st is the 172nd day)</code>
         <code class="n">days</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">365</code><code class="p">)</code>
         <code class="n">summer</code> <code class="o">=</code> <code class="p">(</code><code class="n">days</code> <code class="o">&gt;</code> <code class="mi">172</code><code class="p">)</code> <code class="o">&amp;</code> <code class="p">(</code><code class="n">days</code> <code class="o">&lt;</code> <code class="mi">262</code><code class="p">)</code>

         <code class="nb">print</code><code class="p">(</code><code class="s2">"Median precip on rainy days in 2015 (mm):   "</code><code class="p">,</code>
               <code class="n">np</code><code class="o">.</code><code class="n">median</code><code class="p">(</code><code class="n">rainfall_mm</code><code class="p">[</code><code class="n">rainy</code><code class="p">]))</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"Median precip on summer days in 2015 (mm):  "</code><code class="p">,</code>
               <code class="n">np</code><code class="o">.</code><code class="n">median</code><code class="p">(</code><code class="n">rainfall_mm</code><code class="p">[</code><code class="n">summer</code><code class="p">]))</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"Maximum precip on summer days in 2015 (mm): "</code><code class="p">,</code>
               <code class="n">np</code><code class="o">.</code><code class="n">max</code><code class="p">(</code><code class="n">rainfall_mm</code><code class="p">[</code><code class="n">summer</code><code class="p">]))</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"Median precip on non-summer rainy days (mm):"</code><code class="p">,</code>
               <code class="n">np</code><code class="o">.</code><code class="n">median</code><code class="p">(</code><code class="n">rainfall_mm</code><code class="p">[</code><code class="n">rainy</code> <code class="o">&amp;</code> <code class="o">~</code><code class="n">summer</code><code class="p">]))</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">29</code><code class="p">]:</code> <code class="n">Median</code> <code class="n">precip</code> <code class="n">on</code> <code class="n">rainy</code> <code class="n">days</code> <code class="ow">in</code> <code class="mi">2015</code> <code class="p">(</code><code class="n">mm</code><code class="p">):</code>    <code class="mf">3.8</code>
         <code class="n">Median</code> <code class="n">precip</code> <code class="n">on</code> <code class="n">summer</code> <code class="n">days</code> <code class="ow">in</code> <code class="mi">2015</code> <code class="p">(</code><code class="n">mm</code><code class="p">):</code>   <code class="mf">0.0</code>
         <code class="n">Maximum</code> <code class="n">precip</code> <code class="n">on</code> <code class="n">summer</code> <code class="n">days</code> <code class="ow">in</code> <code class="mi">2015</code> <code class="p">(</code><code class="n">mm</code><code class="p">):</code>  <code class="mf">32.5</code>
         <code class="n">Median</code> <code class="n">precip</code> <code class="n">on</code> <code class="n">non</code><code class="o">-</code><code class="n">summer</code> <code class="n">rainy</code> <code class="n">days</code> <code class="p">(</code><code class="n">mm</code><code class="p">):</code> <code class="mf">4.1</code></pre>
<p>By combining Boolean operations, masking operations, and aggregates, we
can very quickly answer these sorts of questions about our dataset.<a data-startref="ix_ch09-asciidoc6" data-type="indexterm" id="idm45858798301888"/></p>
</div></section>
<section data-pdf-bookmark="Using the Keywords and/or Versus the Operators &amp;/|" data-type="sect1"><div class="sect1" id="ch_0206-boolean-arrays-and-masks_using-the-keywords-and-or-versus-the-operators">
<h1>Using the Keywords and/or Versus the Operators &amp;/|</h1>
<p><a data-primary="&amp; (ampersand)" data-type="indexterm" id="idm45858798264848"/><a data-primary="| (operator)" data-type="indexterm" id="idm45858798263984"/><a data-primary="ampersand (&amp;)" data-type="indexterm" id="idm45858798263312"/><a data-primary="and keyword" data-type="indexterm" id="idm45858798262640"/><a data-primary="bar (|) operator" data-type="indexterm" id="idm45858798261968"/><a data-primary="NumPy" data-secondary="keywords and/or versus operators &amp;/|" data-type="indexterm" id="idm45858798261296"/><a data-primary="or keyword" data-type="indexterm" id="idm45858798260384"/>One common point of confusion is the difference between the keywords
<code>and</code> and <code>or</code> on the one hand, and the operators <code>&amp;</code> and <code>|</code> on the
other. When would you use one versus the other?</p>
<p>The difference is this: <code>and</code> and <code>or</code> operate on the object as a whole,
while <code>&amp;</code> and <code>|</code> operate on the elements within the object.</p>
<p>When you use <code>and</code> or <code>or</code>, it is equivalent to asking Python to treat
the object as a single Boolean entity. In Python, all nonzero integers
will evaluate as <code>True</code>. Thus:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">30</code><code class="p">]:</code> <code class="nb">bool</code><code class="p">(</code><code class="mi">42</code><code class="p">),</code> <code class="nb">bool</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">30</code><code class="p">]:</code> <code class="p">(</code><code class="kc">True</code><code class="p">,</code> <code class="kc">False</code><code class="p">)</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">31</code><code class="p">]:</code> <code class="nb">bool</code><code class="p">(</code><code class="mi">42</code> <code class="ow">and</code> <code class="mi">0</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">31</code><code class="p">]:</code> <code class="kc">False</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">32</code><code class="p">]:</code> <code class="nb">bool</code><code class="p">(</code><code class="mi">42</code> <code class="ow">or</code> <code class="mi">0</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">32</code><code class="p">]:</code> <code class="kc">True</code></pre>
<p>When you use <code>&amp;</code> and <code>|</code> on integers, the expression operates on the
bitwise representation of the element, applying the <em>and</em> or the <em>or</em> to
the individual bits making up the number:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">33</code><code class="p">]:</code> <code class="nb">bin</code><code class="p">(</code><code class="mi">42</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">33</code><code class="p">]:</code> <code class="s1">'0b101010'</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">34</code><code class="p">]:</code> <code class="nb">bin</code><code class="p">(</code><code class="mi">59</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">34</code><code class="p">]:</code> <code class="s1">'0b111011'</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">35</code><code class="p">]:</code> <code class="nb">bin</code><code class="p">(</code><code class="mi">42</code> <code class="o">&amp;</code> <code class="mi">59</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">35</code><code class="p">]:</code> <code class="s1">'0b101010'</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">36</code><code class="p">]:</code> <code class="nb">bin</code><code class="p">(</code><code class="mi">42</code> <code class="o">|</code> <code class="mi">59</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">36</code><code class="p">]:</code> <code class="s1">'0b111011'</code></pre>
<p>Notice that the corresponding bits of the binary representation are
compared in order to yield the result.</p>
<p>When you have an array of Boolean values in NumPy, this can be thought
of as a string of bits where <code>1 = True</code> and <code>0 = False</code>, and <code>&amp;</code> and <code>|</code>
will operate similarly to in the preceding examples:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">37</code><code class="p">]:</code> <code class="n">A</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">],</code> <code class="n">dtype</code><code class="o">=</code><code class="nb">bool</code><code class="p">)</code>
         <code class="n">B</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">],</code> <code class="n">dtype</code><code class="o">=</code><code class="nb">bool</code><code class="p">)</code>
         <code class="n">A</code> <code class="o">|</code> <code class="n">B</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">37</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code> <code class="kc">True</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code>  <code class="kc">True</code><code class="p">])</code></pre>
<p>But if you use <code>or</code> on these arrays it will try to evaluate the truth or
falsehood of the entire array object, which is not a well-defined value:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">38</code><code class="p">]:</code> <code class="n">A</code> <code class="ow">or</code> <code class="n">B</code>
<code class="ne">ValueError</code><code class="p">:</code> <code class="n">The</code> <code class="n">truth</code> <code class="n">value</code> <code class="n">of</code> <code class="n">an</code> <code class="n">array</code> <code class="k">with</code> <code class="n">more</code> <code class="n">than</code> <code class="n">one</code> <code class="n">element</code> <code class="ow">is</code>
          <code class="o">&gt;</code> <code class="n">ambiguous</code><code class="o">.</code>
          <code class="n">a</code><code class="o">.</code><code class="n">any</code><code class="p">()</code> <code class="ow">or</code> <code class="n">a</code><code class="o">.</code><code class="n">all</code><code class="p">()</code></pre>
<p>Similarly, when evaluating a Boolean expression on a given array, you
should use <code>|</code> or <code>&amp;</code> rather than <code>or</code> or <code>and</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">39</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code>
         <code class="p">(</code><code class="n">x</code> <code class="o">&gt;</code> <code class="mi">4</code><code class="p">)</code> <code class="o">&amp;</code> <code class="p">(</code><code class="n">x</code> <code class="o">&lt;</code> <code class="mi">8</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">39</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="kc">False</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code>
                <code class="kc">False</code><code class="p">])</code></pre>
<p>Trying to evaluate the truth or falsehood of the entire array will give
the same <span class="keep-together"><code>ValueError</code></span> we saw previously:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">40</code><code class="p">]:</code> <code class="p">(</code><code class="n">x</code> <code class="o">&gt;</code> <code class="mi">4</code><code class="p">)</code> <code class="ow">and</code> <code class="p">(</code><code class="n">x</code> <code class="o">&lt;</code> <code class="mi">8</code><code class="p">)</code>
<code class="ne">ValueError</code><code class="p">:</code> <code class="n">The</code> <code class="n">truth</code> <code class="n">value</code> <code class="n">of</code> <code class="n">an</code> <code class="n">array</code> <code class="k">with</code> <code class="n">more</code> <code class="n">than</code> <code class="n">one</code> <code class="n">element</code> <code class="ow">is</code>
          <code class="o">&gt;</code> <code class="n">ambiguous</code><code class="o">.</code>
          <code class="n">a</code><code class="o">.</code><code class="n">any</code><code class="p">()</code> <code class="ow">or</code> <code class="n">a</code><code class="o">.</code><code class="n">all</code><code class="p">()</code></pre>
<p>So, remember this: <code>and</code> and <code>or</code> perform a single Boolean evaluation on
an entire object, while <code>&amp;</code> and <code>|</code> perform multiple Boolean evaluations
on the content (the individual bits or bytes) of an object. For Boolean
NumPy arrays, the latter is nearly always the desired operation.<a data-startref="ix_ch09-asciidoc2" data-type="indexterm" id="idm45858797676672"/><a data-startref="ix_ch09-asciidoc1" data-type="indexterm" id="idm45858797675968"/><a data-startref="ix_ch09-asciidoc0" data-type="indexterm" id="idm45858797675296"/></p>
</div></section>
</div></section></div></body></html>