- en: 'Chapter 5\. Computing GC Content: Parsing FASTA and Analyzing Sequences'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章。计算GC含量：解析FASTA和分析序列
- en: In [Chapter 1](ch01.html#ch01), you counted all the bases in a string of DNA.
    In this exercise, you need to count the *G*s and *C*s in a sequence and divide
    by the length of the sequence to determine the GC content as described on [the
    Rosalind GC page](https://oreil.ly/gv8V7). GC content is informative in several
    ways. A higher GC content level indicates a relatively higher melting temperature
    in molecular biology, and DNA sequences that encode proteins tend to be found
    in GC-rich regions. There are many ways to solve this problem, and they all start
    with using Biopython to parse a FASTA file, a key file format in bioinformatics.
    I’ll show you how to use the `Bio.SeqIO` module to iterate over the sequences
    in the file to identify the sequence with the highest GC content.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](ch01.html#ch01)中，你统计了DNA字符串中的所有碱基。在这个练习中，你需要计算序列中的*G*和*C*的数量，并除以序列的长度，以确定GC含量，如[Rosalind
    GC页面](https://oreil.ly/gv8V7)所述。GC含量在几个方面具有信息性。较高的GC含量水平表明在分子生物学中相对较高的熔解温度，并且编码蛋白质的DNA序列倾向于在富含GC的区域中找到。解决此问题的方法有很多种，它们都始于使用Biopython解析FASTA文件，这是生物信息学中的一个关键文件格式。我将向你展示如何使用`Bio.SeqIO`模块迭代文件中的序列，以识别具有最高GC含量的序列。
- en: 'You will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学到：
- en: How to parse FASTA format using `Bio.SeqIO`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`Bio.SeqIO`解析FASTA格式
- en: How to read `STDIN` (pronounced *standard in*)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何读取`STDIN`（读音为*standard in*）
- en: Several ways to express the notion of a `for` loop using list comprehensions,
    `filter()`, and `map()`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用列表理解、`filter()`和`map()`表达`for`循环的几种方法
- en: How to address runtime challenges such as memory allocation when parsing large
    files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何解决运行时挑战，如解析大文件时的内存分配。
- en: More about the `sorted()` function
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`sorted()`函数的更多信息
- en: How to include formatting instructions in format strings
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在格式字符串中包含格式化指令
- en: How to use the `sum()` function to add a list of numbers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`sum()`函数将一组数字相加
- en: How to use regular expressions to count the occurrences of a pattern in a string
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用正则表达式在字符串中计算模式的出现次数
- en: Getting Started
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门指南
- en: All the code and tests for this program are in the *05_gc* directory. While
    I’d like to name this program `gc.py`, it turns out that this conflicts with a
    very important Python module called [`gc.py`](https://oreil.ly/7eNBw) which is
    used for garbage collection, such as freeing memory. Instead, I’ll use `cgc.py`
    for *calculate GC*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序的所有代码和测试位于*05_gc*目录中。虽然我想将此程序命名为`gc.py`，但事实证明这与一个非常重要的名为[`gc.py`](https://oreil.ly/7eNBw)的Python模块发生了冲突，该模块用于垃圾回收，例如释放内存。相反，我将使用`cgc.py`代替*calculate
    GC*。
- en: If I called my program `gc.py`, my code would *shadow* the built-in `gc` module,
    making it unavailable. Likewise, I can create variables and functions with names
    like `len` or `dict` which would shadow those built-in functions. This will cause
    many bad things to happen, so it’s best to avoid these names. Programs like `pylint`
    and `flake8` can find problems like this.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将我的程序命名为`gc.py`，我的代码将会*遮蔽*内置的`gc`模块，使其不可用。同样，我可以创建具有名称`len`或`dict`的变量和函数，这将遮蔽那些内置函数。这将导致许多不良情况发生，因此最好避免使用这些名称。诸如`pylint`和`flake8`之类的程序可以发现这样的问题。
- en: 'Start by copying the first solution and asking for the usage:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先复制第一个解决方案并要求用法：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO1-1)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO1-1)'
- en: Note that the positional `[FILE]` is in square brackets to indicate that it
    is optional.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，位置参数`[FILE]`位于方括号中，表示它是可选的。
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO1-2)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO1-2)'
- en: This is a rather ugly message that is trying to explain that the default input
    is `STDIN`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当丑陋的消息，试图解释默认输入是`STDIN`。
- en: 'As in [Chapter 2](ch02.html#ch02), this program expects a file as input and
    will reject invalid or unreadable files. To illustrate this second point, create
    an empty file using `touch` and then use `chmod` (change mode) to set the permissions
    to `000` (all read/write/execute bits off):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第二章](ch02.html#ch02)所述，该程序期望一个文件作为输入，并将拒绝无效或无法读取的文件。为了说明第二点，使用`touch`创建一个空文件，然后使用`chmod`（改变模式）将权限设置为`000`（所有读/写/执行位关闭）：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice that the error message specifically tells me that I lack permission
    to read the file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，错误消息明确告诉我我缺少读取文件的权限：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now run the program with valid input and observe that the program prints the
    ID of the record having the highest percentage of GC:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用有效的输入运行程序，并观察程序打印具有最高GC百分比的记录的ID：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This program can also read from `STDIN`. Simply because I think it’s fun, I’ll
    show you how, in the `bash` shell, I can use the pipe operator (`|`) to route
    the `STDOUT` from one program to the `STDIN` of another program. For instance,
    the `cat` program will print the contents of a file to `STDOUT`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序还可以从`STDIN`中读取。仅仅因为我觉得有趣，我会向你展示如何在`bash` shell中使用管道操作符（`|`）将一个程序的`STDOUT`输出路由到另一个程序的`STDIN`中。例如，`cat`程序会将文件的内容打印到`STDOUT`：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Using the pipe, I can feed this to my program:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用管道，我可以将其提供给我的程序：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'I can also use the `<` operator to redirect input from a file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我也可以使用`<`操作符从文件中重定向输入：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To get started, remove this program and start over:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请删除此程序并重新开始：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following shows how to modify the first part of the program to accept a
    single positional argument that is a valid, readable file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示如何修改程序的第一部分以接受一个单一的位置参数，该参数是一个有效的可读文件：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO2-1)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO2-1)'
- en: The only attribute of the `Args` class is a filehandle.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Args`类的唯一属性是一个文件句柄。'
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO2-2)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO2-2)'
- en: Create a positional file argument that, if provided, must be a readable text
    file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个位置参数文件，如果提供，必须是可读的文本文件。
- en: It’s rare to make a positional argument optional, but in this case, I want to
    either handle a single file input or read from `STDIN`. To do this, I use `nargs='?'`
    to indicate that the parameter should accept zero or one argument (see [Table 2-2](ch02.html#table_2.2)
    in [“Opening the Output Files”](ch02.html#openingOutputFiles)) and set `default=sys.stdin`.
    In [Chapter 2](ch02.html#ch02), I mentioned that `sys.stdout` is a filehandle
    that is always open for writing. Similarly, `sys.stdin` is an open filehandle
    from which you can always read `STDIN`. This is all the code that is required
    to make your program read either from a file or from `STDIN`, and I think that’s
    rather neat and tidy.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 很少将位置参数设为可选，但在这种情况下，我想要处理一个单个文件输入或者从`STDIN`读取。为此，我使用`nargs='?'`指示该参数应接受零个或一个参数（见[表 2-2](ch02.html#table_2.2)中的[“打开输出文件”](ch02.html#openingOutputFiles)）并设置`default=sys.stdin`。在第二章中，我提到`sys.stdout`是一个始终打开写入的文件句柄。类似地，`sys.stdin`是一个始终打开读取`STDIN`的文件句柄。这是使你的程序能够从文件或`STDIN`中读取的所有所需代码，我觉得这相当整洁和清晰。
- en: 'Modify your `main()` to print the name of the file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 修改你的`main()`函数以打印文件的名称：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Verify that it works:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 确保它能正常工作：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run **`pytest`** to see how you’re faring. You should pass the first three
    tests and fail on the fourth:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行**`pytest`**来查看你的进展。你应该通过前三个测试，但在第四个测试上失败：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-1)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-1)'
- en: The test is running the program using the first input file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 测试正在使用第一个输入文件运行程序。
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-2)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-2)'
- en: The output is expected to be the given string.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出是给定的字符串。
- en: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-3)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-3)'
- en: This is the expected string.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的字符串。
- en: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-4)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-4)'
- en: This is the string that was printed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是打印出的字符串。
- en: So far you have created a syntactically correct, well-structured, and documented
    program that validates a file input, all by doing relatively little work. Next,
    you need to figure out how to find the sequence with the highest GC content.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经通过相对较少的工作创建了一个语法正确、结构良好并且有文档的程序来验证文件输入。接下来，你需要找出如何找到GC含量最高的序列。
- en: Get Parsing FASTA Using Biopython
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Biopython解析FASTA文件
- en: 'The data from the incoming file or `STDIN` should be sequence data in FASTA
    format, which is a common way to represent biological sequences. Let’s look at
    the first file to understand the format:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 来自传入文件或`STDIN`的数据应该是以FASTA格式表示的序列数据，这是表示生物序列的常见方式。让我们看看第一个文件，以了解格式：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO4-1)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO4-1)'
- en: A FASTA record starts with a `>` at the beginning of a line. The sequence ID
    is any following text up to the first space.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: FASTA记录以行首的`>`开始。序列ID是直到第一个空格的任何后续文本。
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO4-2)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO4-2)'
- en: A sequence can be any length and can span multiple lines or be placed on a single
    line.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 序列可以是任意长度，可以跨多行或放在单行上。
- en: The header of a FASTA file can get very ugly, very quickly. I would encourage
    you to download real sequences from the National Center for Biotechnology Information
    (NCBI) or look at the files in the *17_synth/tests/inputs* directory for more
    examples.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: FASTA文件的头部可能会非常混乱，非常快速。我鼓励您从国家生物技术信息中心（NCBI）下载真实序列或查看*17_synth/tests/inputs*目录中的文件以获取更多示例。
- en: 'While it would be fun (for certain values of fun) to teach you how to manually
    parse this file, I’ll go straight to using Biopython’s `Bio.SeqIO` module:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然教您如何手动解析此文件可能很有趣（对于某些有趣的价值观来说），但我将直接使用Biopython的`Bio.SeqIO`模块：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO5-1)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO5-1)'
- en: The first argument is the name of the input file. As this function can parse
    many different record formats, the second argument is the format of the data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是输入文件的名称。由于此函数可以解析许多不同的记录格式，因此第二个参数是数据的格式。
- en: 'I can check the type of `recs` using `type()`, as usual:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以像往常一样使用`type()`来检查`recs`的类型：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'I’ve shown iterators a couple of times now, even creating one in [Chapter 4](ch04.html#ch04).
    In that exercise, I used the `next()` function to retrieve the next value from
    the Fibonacci sequence generator. I’ll do the same here to retrieve the first
    record and inspect its type:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经几次展示了迭代器，甚至在[第4章](ch04.html#ch04)中创建了一个。在那个练习中，我使用`next()`函数从斐波那契数列生成器中获取下一个值。我将在这里做同样的事情，以获取第一个记录并检查其类型：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To learn more about a sequence record, I highly recommend you read [the `SeqRecord`
    documentation](https://biopython.org/wiki/SeqRecord) in addition to the documentation
    in the REPL, which you can view using **`help(rec)`**. The data from the FASTA
    record must be *parsed*, which means discerning the meaning of the data from its
    syntax and structure. If you look at `rec` in the REPL, you’ll see something that
    looks like a dictionary. This output is the same as that from `repr(seq)`, which
    is used to “return the canonical string representation of the object”:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关序列记录的更多信息，我强烈建议您阅读[SeqRecord文档](https://biopython.org/wiki/SeqRecord)，此外还可以在REPL中查看文档，您可以使用**`help(rec)`**查看。必须*解析*FASTA记录的数据，这意味着从其语法和结构中辨别数据的含义。如果您在REPL中查看`rec`，您将看到类似于字典的输出。此输出与`repr(seq)`的输出相同，后者用于“返回对象的规范字符串表示”：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO6-1)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO6-1)'
- en: The multiple lines of the sequence are concatenated into a single sequence represented
    by a `Seq` object.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 序列的多行被连接成一个由`Seq`对象表示的单个序列。
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO6-2)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO6-2)'
- en: The `ID` of a FASTA record is all the characters in the header starting *after*
    the `>` and continuing up to the first space.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: FASTA记录的`ID`是从`>`之后开始的标题中的所有字符，直到第一个空格。
- en: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO6-3)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO6-3)'
- en: The `SeqRecord` object is meant to also handle data with more fields, such as
    `name`, `description`, and database cross-references (`dbxrefs`). Since those
    fields are not present in FASTA records, the ID is duplicated for `name` and `description`,
    and the `dbxrefs` value is the empty list.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`SeqRecord`对象还可以处理具有更多字段的数据，例如`name`、`description`和数据库交叉引用(`dbxrefs`)。由于这些字段在FASTA记录中不存在，ID会被复制为`name`和`description`，而`dbxrefs`的值则为空列表。'
- en: 'If you print the sequence, this information will be *stringified* so it’s a
    little easier to read. This output is the same as that for `str(rec)`, which is
    meant to provide a useful string representation of an object:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果打印序列，这些信息将被*字符串化*，因此更容易阅读。这个输出与`str(rec)`的输出相同，后者旨在提供对象的有用字符串表示：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The most salient feature for this program is the record’s sequence. You might
    expect this would be a `str`, but it’s actually another object:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个程序来说，最突出的特性是记录的序列。你可能期望这是一个`str`，但实际上它是另一个对象：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Use **`help(rec.seq)`** to see what attributes and methods the `Seq` object
    offers. I only want the DNA sequence itself, which I can get by coercing the sequence
    to a string using the `str()` function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**`help(rec.seq)`**查看`Seq`对象提供的属性和方法。我只想要DNA序列本身，可以通过`str()`函数将序列强制转换为字符串来获取：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note this is the same class I used in the last solution of [Chapter 3](ch03.html#ch03)
    to create a reverse complement. I can use it here like so:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是我在上一章的最后一个解决方案中使用的相同类，用于创建反向互补序列。我可以在这里这样使用它：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `Seq` object has many other useful methods, and I encourage you to explore
    the documentation as these can save you a lot of time.^([1](ch05.html#idm45963634979240))
    At this point, you may feel you have enough information to finish the challenge.
    You need to iterate through all the sequences, determine what percentage of the
    bases are *G* or *C*, and return the ID and GC content of the record with the
    maximum value. I would challenge you to write a solution on your own. If you need
    more help, I’ll show you one approach, and then I’ll cover several variations
    in the solutions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Seq`对象还有许多其他有用的方法，我鼓励你探索文档，因为这些方法可以节省大量时间。^([1](ch05.html#idm45963634979240))
    现在，你可能已经有足够的信息来完成挑战了。你需要遍历所有序列，确定*G*或*C*碱基的百分比，并返回具有最大值的记录的ID和GC含量。我建议你自己编写一个解决方案。如果需要更多帮助，我会展示一种方法，并介绍几种解决方案的变体。'
- en: Iterating the Sequences Using a for Loop
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`for`循环迭代序列
- en: 'So far I’ve shown that `SeqIO.parse()` accepts a filename as the first argument,
    but the `args.file` argument will be an open filehandle. Luckily, the function
    will also accept this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经展示了`SeqIO.parse()`接受文件名作为第一个参数，但`args.file`参数将是一个打开的文件句柄。幸运的是，该函数也接受这种形式：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'I can use a `for` loop to iterate through each record to print the ID and the
    first 10 bases of each sequence:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用`for`循环来遍历每个记录，打印出ID和每个序列的前10个碱基：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Take a moment to run those lines again and notice that nothing will be printed:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请花一点时间再次运行这些代码，并注意什么也不会被打印出来：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Earlier I showed that `recs` is a `Bio.SeqIO.FastaIO.FastaIterator`, and, like
    all iterators, it will produce values until exhausted. If you want to loop through
    the records again, you will need to recreate the `recs` object using the `SeqIO.parse()`
    function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前展示了`recs`是一个`Bio.SeqIO.FastaIO.FastaIterator`，像所有迭代器一样，它会产生值直到耗尽。如果想要再次循环遍历记录，需要重新使用`SeqIO.parse()`函数创建`recs`对象。
- en: 'For the moment, assume the sequence is this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时假设序列如下：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'I need to find how many *C*s and *G*s occur in that string. I can use another
    `for` loop to iterate each base of the sequence and increment a counter whenever
    the base is a *G* or a *C*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要找出字符串中有多少个*C*和*G*。我可以使用另一个`for`循环来迭代序列的每个碱基，并在碱基为*G*或*C*时增加一个计数器：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-1)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-1)'
- en: Initialize a variable for the counts of the *G/C* bases.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化一个变量用于计算*G/C*碱基的计数。
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-2)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-2)'
- en: Iterate each base (character) in the sequence.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代每个序列中的每个碱基（字符）。
- en: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-3)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-3)'
- en: See if the base is in the tuple containing `G` or `C`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 看看元组中是否包含`G`或`C`的碱基。
- en: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-4)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-4)'
- en: Increment the GC counter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 增加 GC 计数器。
- en: 'To find the percentage of GC content, divide the GC count by the length of
    the sequence:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出 GC 含量的百分比，将 GC 计数除以序列的长度：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The output from the program should be the ID of the sequence with the highest
    `GC` count, a single space, and the GC content truncated to six significant digits.
    The easiest way to format the number is to learn more about `str.format()`. The
    `help` doesn’t have much in the way of documentation, so I recommend you read
    [PEP 3101](https://oreil.ly/OIpEq) on advanced string formatting.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 程序输出应为具有最高`GC`计数的序列的 ID，一个空格，并截断为六个有效数字的 GC 含量。格式化数字的最简单方法是了解更多关于`str.format()`的信息。`help`中没有太多文档，因此建议您阅读[PEP
    3101](https://oreil.ly/OIpEq)以了解高级字符串格式化。
- en: 'In [Chapter 1](ch01.html#ch01), I showed how I can use `{}` as placeholders
    for interpolating variables either using `str.format()` or f-strings. I can add
    formatting instructions after a colon (`:`) in the curly brackets. The syntax
    looks like that used with the `printf()` function in C-like languages, so `{:0.6f}`
    is a floating-point number to six places:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](ch01.html#ch01)中，我展示了如何使用`{}`作为占位符来插入变量，无论是使用`str.format()`还是 f-string。您可以在花括号中的冒号（`:`）后添加格式化指令。这种语法看起来像类C语言中的`printf()`函数使用的语法，因此`{:0.6f}`是一个六位数的浮点数：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Or, to execute the code directly inside an f-string:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，直接在 f-string 内执行代码：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To figure out the sequence with the maximum `GC` count, you have a couple of
    options, both of which I’ll demonstrate in the solutions:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出具有最大`GC`计数的序列，您有几个选项，我将在解决方案中都展示：
- en: Make a list of all the IDs and their GC content (a list of tuples would serve
    well). Sort the list by GC content and take the maximum value.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作所有 ID 及其 GC 含量的列表（元组列表会很好用）。按照 GC 含量排序并取最大值。
- en: Keep track of the ID and GC content of the maximum value. Overwrite this when
    a new maximum is found.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录最大值的 ID 和 GC 含量。在发现新的最大值时覆盖它。
- en: 'I think that should be enough for you to finish a solution. You can do this.
    Fear is the mind killer. Keep going until you pass *all* the tests, including
    those for linting and type checking. Your test output should look something like
    this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这应该足以让您完成一个解决方案。您可以做到。害怕是心灵的杀手。继续努力直到通过*所有*测试，包括那些用于检查代码风格和类型的测试。您的测试输出应该看起来像这样：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Solutions
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: As before, all the solutions share the same `get_args()`, so only the differences
    will be shown.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与以往一样，所有解决方案共享相同的`get_args()`，因此只显示差异。
- en: 'Solution 1: Using a List'
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案1：使用列表
- en: 'Let’s look at my first solution. I always try to start with the most obvious
    and simple way, and you’ll find this is often the most verbose. Once you understand
    the logic, I hope you’ll be able to follow more powerful and terse ways to express
    the same ideas. For this first solution, be sure to also import `List` and `Tuple`
    from the `typing` module:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我的第一个解决方案。我总是试图从最明显和简单的方法开始，您会发现这通常是最冗长的。一旦理解了逻辑，希望您能够理解更强大和更简洁的表达相同想法的方式。对于这个第一个解决方案，确保还从`typing`模块中导入`List`和`Tuple`：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-1)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-1)'
- en: Initialize an empty list to hold the GC content and sequence IDs as tuples.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化一个空列表以保存 GC 含量和序列 ID 的元组。
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-2)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-2)'
- en: Iterate through each record in the input file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历输入文件中的每个记录。
- en: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-3)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-3)'
- en: Initialize a GC counter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化一个 GC 计数器。
- en: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-4)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-4)'
- en: Iterate through each sequence, uppercased to guard against possible mixed-case
    input.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历每个序列，将其大写以防止可能的混合大小写输入。
- en: '[![5](assets/5.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-5)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-5)'
- en: Check if the base is a *C* or *G*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 检查基序是否为*C*或*G*。
- en: '[![6](assets/6.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-6)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-6)'
- en: Increment the GC counter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 增加 GC 计数器。
- en: '[![7](assets/7.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-7)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-7)'
- en: Calculate the GC content.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 GC 含量。
- en: '[![8](assets/8.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-8)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-8)'
- en: Append a new tuple of the GC content and the sequence ID.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新的元组，包括 GC 含量和序列 ID。
- en: '[![9](assets/9.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-9)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-9)'
- en: Take the maximum value.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 取最大值。
- en: '[![10](assets/10.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-10)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-10)'
- en: Print the sequence ID and GC content of the highest value.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 打印最高值的序列 ID 和 GC 含量。
- en: The type annotation `List[Tuple[float, str]]` on the `seqs` variable provides
    not only a way to programmatically check the code using tools like `mypy` but
    also an added layer of documentation. The reader of this code doesn’t have to
    jump ahead to see what kind of data will be added to the list because it has been
    explicitly described using types.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`seqs`的类型注解`List[Tuple[float, str]]`不仅提供了一种通过像`mypy`这样的工具来程序化地检查代码的方式，还增加了一层文档说明。代码的读者不必跳到前面去看将要添加到列表中的数据类型，因为已经通过类型显式地描述了。
- en: 'In this solution, I decided to make a list of all the IDs and GC percentages
    mostly so that I could show you how to create a list of tuples. Then I wanted
    to point out a few magical properties of Python’s sorting. Let’s start with the
    `sorted()` function, which works on strings as you might imagine:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个解决方案中，我决定制作一个包含所有 ID 和 GC 百分比的列表，主要是为了展示如何创建元组列表。然后我想指出 Python 排序的一些神奇属性。让我们从`sorted()`函数开始，它在处理字符串时与你想象的一样有效：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When all the values are numbers, they will be sorted numerically, so I’ve got
    that going for me, which is nice:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有值都是数字时，它们将按数字顺序排序，所以我得到了这个有点不错的功能：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note that those same values *as strings* will sort in lexicographic order:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，相同的值*作为字符串*会按字典顺序排序：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now consider a list of tuples where the first element is a `float` and the
    second element is a `str`. How will `sorted()` handle this? By first sorting all
    the data by the first elements *numerically* and then the second elements *lexicographically*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个元组列表，其中第一个元素是`float`，第二个元素是`str`。`sorted()`将如何处理这个列表？首先按第一个元素*数字*排序，然后按第二个元素*字典顺序*排序：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Structuring `seqs` as `List[Tuple[float, str]]` takes advantage of this built-in
    behavior of `sorted()`, allowing me to quickly sort the sequences by GC content
    and select the highest value:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将`seqs`结构化为`List[Tuple[float, str]]`利用了`sorted()`的内置行为，允许我快速地按 GC 含量对序列进行排序并选择最高值：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is the same as finding the highest value, which the `max()` function can
    do more easily:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这与找到最高值相同，`max()`函数可以更容易地实现：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`high` is a tuple where the first position is the sequence ID and the zeroth
    position is the GC content that needs to be formatted:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`high`是一个元组，第一个位置是序列 ID，零位置是需要格式化的 GC 含量：'
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Solution 2: Type Annotations and Unit Tests'
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 2：类型注解和单元测试
- en: 'Hidden inside the `for` loop is a kernel of code to compute GC content that
    needs to be extracted into a function with a test. Following the ideas of test-driven
    development (TDD), I will first define a `find_gc()` function:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中隐藏着一个计算 GC 含量的代码片段，需要将其提取到一个带有测试的函数中。遵循测试驱动开发（TDD）的思想，我将首先定义一个`find_gc()`函数：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO9-1)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO9-1)'
- en: The function accepts a `str` and returns a `float`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个`str`并返回一个`float`。
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO9-2)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO9-2)'
- en: For now, I return `0`. Note the trailing `.` tells Python this is a `float`.
    This is shorthand for `0.0`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我返回 `0`。请注意，末尾的 `.` 告诉 Python 这是一个 `float`。这是 `0.0` 的简写。
- en: 'Next, I’ll define a function that will serve as a unit test. Since I’m using
    `pytest`, this function’s name must start with `test_`. Because I’m testing the
    `find_gc()` function, I’ll name the function `test_find_gc`. I will use a series
    of `assert` statements to test if the function returns the expected result for
    a given input. Note how this test function serves both as a formal test and as
    an additional piece of documentation, as the reader can see the inputs and outputs:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将定义一个函数作为单元测试。因为我使用 `pytest`，所以这个函数的名称必须以 `test_` 开头。因为我正在测试 `find_gc()`
    函数，所以我将函数命名为 `test_find_gc`。我将使用一系列 `assert` 语句来测试函数对给定输入返回的预期结果。请注意，这个测试函数既作为正式测试，又作为额外的文档片段，因为读者可以看到输入和输出：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-1)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-1)'
- en: If a function accepts a `str`, I always start by testing with the empty string
    to make sure it returns something useful.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数接受一个 `str`，我总是从空字符串开始测试，以确保它返回一些有用的东西。
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-2)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-2)'
- en: A single `C` should be 100% GC.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 单个 `C` 应为 100% GC。
- en: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-3)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-3)'
- en: Same for a single `G`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 单个 `G` 也是如此。
- en: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-4)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-4)'
- en: Various other tests mixing bases at various percentages.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 各种其他测试混合各种百分比的碱基。
- en: 'It’s rarely possible to exhaustively check every possible input to a function,
    so I often rely on spot-checking. Note that the [`hypothesis` module](https://hypothesis.readthedocs.io/en/latest)
    can generate random values for testing. Presumably, the `find_gc()` function is
    simple enough that these tests are sufficient. My goal in writing functions is
    to make them as simple as possible, but no simpler. As Tony Hoare says, “There
    are two ways to write code: write code so simple there are obviously no bugs in
    it, or write code so complex that there are no obvious bugs in it.”'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎不可能彻底检查函数的每个可能输入，因此我通常依赖于抽样检查。请注意，[`hypothesis` 模块](https://hypothesis.readthedocs.io/en/latest)
    可以生成随机值进行测试。可以假设 `find_gc()` 函数足够简单，这些测试就足够了。我编写函数的目标是使其尽可能简单，但不简化。正如 Tony Hoare
    所说，“编写代码有两种方式：编写简单到明显没有错误的代码，或者编写复杂到明显没有明显错误的代码。”
- en: 'The `find_gc()` and `test_find_gc()` functions are inside the `cgc.py` program,
    not in the *tests/cgc_test.py* module. To execute the unit test, I run `pytest`
    on the source code *expecting the test to fail*:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_gc()` 和 `test_find_gc()` 函数在 `cgc.py` 程序中，而不在 *tests/cgc_test.py* 模块中。要执行单元测试，我在源代码上运行
    `pytest`，*期望测试失败*：'
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO11-1)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO11-1)'
- en: The unit test fails as expected.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试如预期般失败。
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO11-2)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO11-2)'
- en: The first test passes because it was expecting `0`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试通过，因为预期结果是`0`。
- en: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO11-3)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO11-3)'
- en: This test fails because it should have returned `100`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试失败，因为它应该返回 `100`。
- en: 'Now I have established a baseline from which I can proceed. I know that my
    code fails to meet some expectation as formally defined using a test. To fix this,
    I move all the relevant code from `main()` into the function:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经建立了一个基准，可以继续进行。我知道我的代码未能达到某些期望，这是通过测试正式定义的。为了解决这个问题，我将`main()`中的所有相关代码移动到函数中：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO12-1)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO12-1)'
- en: This guards against trying to divide by 0 when the sequence is the empty string.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当序列为空字符串时，防止尝试除以 0。
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO12-2)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO12-2)'
- en: If there is no sequence, the GC content is 0.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有序列，GC 含量为 0。
- en: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO12-3)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO12-3)'
- en: This is the same code as before.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的代码相同。
- en: 'Then I run `pytest` again to check that the function works:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后再次运行`pytest`检查函数是否工作：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is TDD:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 TDD：
- en: Define a function to test.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个测试函数。
- en: Write the test.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试。
- en: Ensure the function fails the test.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保函数未通过测试。
- en: Make the function work.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使函数工作。
- en: Ensure the function passes the test (and all your previous tests still pass).
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保函数通过测试（并且所有之前的测试仍然通过）。
- en: If I later encounter sequences that trigger bugs in my code, I’ll fix the code
    and add those as more tests. I shouldn’t have to worry about weird cases like
    the `find_gc()` function receiving a `None` or a list of integers *because I used
    type annotations*. Testing is useful. Type annotations are useful. Combining tests
    and types leads to code that is easier to verify and comprehend.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以后遇到导致我的代码出现错误的序列，我会修复代码并将其添加为更多测试。我不应该担心像`find_gc()`函数接收`None`或整数列表这样的奇怪情况*因为我使用了类型注解*。测试是有用的。类型注解是有用的。结合测试和类型可以使代码更易于验证和理解。
- en: 'I want to make one other addition to this solution: a custom type to document
    the tuple holding the GC content and sequence ID. I’ll call it `MySeq` just to
    avoid any confusion with the `Bio.Seq` class. I add this below the `Args` definition:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我想对这个解决方案进行另一个添加：一个自定义类型来记录持有 GC 含量和序列 ID 的元组。我将其称为`MySeq`，只是为了避免与`Bio.Seq`类产生混淆。我在`Args`定义下面添加了这个：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO13-1)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO13-1)'
- en: The GC content is a percentage.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: GC 含量是一个百分比。
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO13-2)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO13-2)'
- en: I would prefer to use the field name `id`, but that conflicts with the `id()`
    *identity* function which is built into Python.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我更愿意使用字段名`id`，但那与内置于 Python 中的`id()`*标识*函数冲突。
- en: 'Here is how it can be incorporated into the code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何将其合并到代码中的方法：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-1)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-1)'
- en: Use `MySeq` as a type annotation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`MySeq`作为类型注解。
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-2)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-2)'
- en: Create `MySeq` using the return value from the `find_gc()` function and the
    record ID.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来自`find_gc()`函数的返回值和记录 ID 创建`MySeq`。
- en: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-3)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-3)'
- en: This still works because `MySeq` is a tuple.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然有效，因为`MySeq`是一个元组。
- en: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-4)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-4)'
- en: Use the field access rather than the index position of the tuple.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字段访问而不是元组的索引位置。
- en: This version of the program is arguably easier to read. You can and should create
    as many custom types as you want to better document and test your code.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的程序可能更容易阅读。您可以创建尽可能多的自定义类型来更好地记录和测试您的代码。
- en: 'Solution 3: Keeping a Running Max Variable'
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 3：保持运行的最大变量
- en: The previous solution works well, but it’s a bit verbose and needlessly keeps
    track of *all* the sequences when I only care about the maximum value. Given how
    small the test inputs are, this will never be a problem, but bioinformatics is
    always about scaling up. A solution that tries to store all the sequences will
    eventually choke. Consider processing 1 million sequences, or 1 billion, or 100
    billion. Eventually, I’d run out of memory.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个解决方案效果不错，但有点啰嗦，并且在我只关心最大值时无谓地跟踪*所有*序列。考虑到测试输入很小，这永远不会成为问题，但生物信息学始终关注扩展。试图存储所有序列的解决方案最终会导致内存耗尽。考虑处理100万、10亿或1000亿序列。最终，内存会耗尽。
- en: 'Here’s a solution that would scale to any number of sequences, as it only ever
    allocates a single tuple to remember the highest value:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个能够适应任意序列数量的解决方案，因为它只分配一个单个元组来记住最高值：
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-1)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-1)'
- en: Initialize a variable to remember the highest value. Type annotation is superfluous
    as `mypy` will expect this variable to remain this type forever.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化一个变量来记住最高值。类型注释是多余的，因为`mypy`将期望此变量始终保持此类型。
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-2)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-2)'
- en: Calculate the GC content.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 计算GC含量。
- en: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-3)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-3)'
- en: See if the percent GC is greater than the highest value.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 查看GC百分比是否大于最高值。
- en: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-4)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-4)'
- en: If so, overwrite the highest value using this percent GC and sequence ID.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是，使用这个百分比GC和序列ID覆盖最高值。
- en: '[![5](assets/5.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-5)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-5)'
- en: Print the highest value.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 打印最高值。
- en: 'For this solution, I also took a slightly different approach to compute the
    `GC` content:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此解决方案，我也采用了稍微不同的方法来计算`GC`含量：
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO16-1)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO16-1)'
- en: Use the `str.count()` method to find the `C`s and `G`s in the sequence.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`str.count()`方法来查找序列中的`C`和`G`。
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO16-2)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO16-2)'
- en: Since there are two conditions for the state of the sequence—the empty string
    or not—I prefer to write a single `return` using an `if` expression.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于序列状态有两个条件——空字符串或非空字符串——我更喜欢使用一个`if`表达式编写单个`return`。
- en: 'I’ll benchmark the last solution against this one. First I need to generate
    an input file with a significant number of sequences, say 10K. In the *05_gc*
    directory, you’ll find a `genseq.py` file similar to the one I used in the *02_rna*
    directory. This one generates a FASTA file:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我将用最后一个解决方案来进行基准测试。首先，我需要生成一个包含大量序列的输入文件，比如10K。在*05_gc*目录中，您会找到一个类似于我在*02_rna*目录中使用的`genseq.py`文件。这个文件生成一个FASTA文件：
- en: '[PRE47]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here’s how I’ll generate an input file:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我生成输入文件的方式：
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'I can use that with `hyperfine` to compare these two implementations:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用`hyperfine`来比较这两种实现：
- en: '[PRE49]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It would appear that the third solution is about four times faster than the
    second running on 10K sequences. You can try generating more and longer sequences
    for your own benchmarking. I would recommend you create a file with at least one
    million sequences and compare your first solution with this version.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来第三个解决方案比在10K序列上运行的第二个解决方案快大约四倍。您可以尝试生成更多和更长的序列进行自己的基准测试。我建议您创建一个包含至少一百万序列的文件，并将您的第一个解决方案与此版本进行比较。
- en: 'Solution 4: Using a List Comprehension with a Guard'
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 4：使用带有保护条件的列表推导式
- en: '[Figure 5-1](#fig_5.1) shows that another way to find all the *C*s and *G*s
    in the sequence is to use a list comprehension and the `if` comparison from the
    first solution, which is called a *guard*.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-1](#fig_5.1) 显示了在序列中查找所有*C*和*G*的另一种方法是使用列表推导和第一个解决方案中的`if`比较，这被称为*guard*。'
- en: '![mpfb 0501](assets/mpfb_0501.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0501](assets/mpfb_0501.png)'
- en: Figure 5-1\. A list comprehension with a guard will select only those elements
    returning a truthy value for the `if` expression
  id: totrans-251
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-1\. 一个带有guard的列表推导将只选择对于`if`表达式返回真值的元素
- en: 'The list comprehension only yields those elements passing the guard which checks
    that the `base` is in the string `''CG''`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导仅产生通过检查`base`是否在字符串`'CG'`中的guard的元素：
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Since the result is a new list, I can use the `len()` function to find how
    many `C`s and `G`s are present:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于结果是一个新列表，我可以使用`len()`函数来找出有多少个`C`和`G`：
- en: '[PRE51]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'I can incorporate this idea into the `find_gc()` function:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以将这个想法整合到`find_gc()`函数中：
- en: '[PRE52]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO17-1)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO17-1)'
- en: Another way to count the *C*s and *G*s is to select them using a list comprehension
    with a guard.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种计算*C*和*G*数量的方法是使用带有guard的列表推导来选择它们。
- en: 'Solution 5: Using the filter() Function'
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'Solution 5: 使用filter()函数'
- en: 'The idea of a list comprehension with a guard can be expressed with the higher-order
    function `filter()`. Earlier in the chapter I used the `map()` function to apply
    the `int()` function to all the elements of a list to produce a new list of integers.
    The `filter()` function works similarly, accepting a function as the first argument
    and an iterable as the second. It’s different, though, as only those elements
    returning a truthy value when the function is applied will be returned. As this
    is a lazy function, I will need to coerce with `list()` in the REPL:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 带有guard的列表推导的概念可以使用高阶函数`filter()`来表达。在本章的早些时候，我使用`map()`函数将`int()`函数应用于列表的所有元素，以产生一个新的整数列表。`filter()`函数的工作方式类似，接受一个函数作为第一个参数和一个可迭代对象作为第二个参数。但它有所不同，只有在应用函数时返回真值的元素才会被返回。由于这是一个惰性函数，因此在REPL中我需要用`list()`来强制转换：
- en: '[PRE53]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'So here’s another way to express the same idea from the last solution:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里是表达与上一个解决方案相同的另一种方式：
- en: '[PRE54]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO18-1)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO18-1)'
- en: Use `filter()` to select only those bases matching *C* or *G*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`filter()`选择仅匹配*C*或*G*的碱基。
- en: 'Solution 6: Using the map() Function and Summing Booleans'
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'Solution 6: 使用map()函数和布尔值求和'
- en: 'The `map()` function is a favorite of mine, so I want to show another way to
    use it. I could use `map()` to turn each base into a 1 if it’s a *C* or *G*, and
    a `0` otherwise:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`函数是我喜欢的一个函数，所以我想展示另一种使用它的方法。我可以使用`map()`将每个碱基转换为1（如果它是*C*或*G*），否则为`0`：'
- en: '[PRE55]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Counting the *C*s and *G*s would then be a matter of summing this list, which
    I can do using the `sum()` function:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后计算*C*和*G*的数量只是简单地对这个列表求和，我可以使用`sum()`函数来实现：
- en: '[PRE56]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'I can shorten my `map()` to return the result of the comparison (which is a
    `bool` but also an `int`) and sum that instead:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以缩短我的`map()`以返回比较的结果（它是一个`bool`但也是一个`int`），然后将其求和：
- en: '[PRE57]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here is how I could incorporate this idea:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我如何将这个想法整合进来：
- en: '[PRE58]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO19-1)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO19-1)'
- en: Transform the sequence into Boolean values based on their comparison to the
    bases *C* or *G*, then sum the `True` values to get a count.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它们与碱基*C*或*G*的比较将序列转换为布尔值，然后对`True`值求和以得到计数。
- en: 'Solution 7: Using Regular Expressions to Find Patterns'
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'Solution 7: 使用正则表达式查找模式'
- en: 'So far I’ve been showing you multiple ways to manually iterate a sequence of
    characters in a string to pick out those matching `C` or `G`. This is pattern
    matching, and it’s precisely what regular expressions do. The cost to you is learning
    another domain-specific language (DSL), but this is well worth the effort as regexes
    are widely used outside of Python. Begin by importing the `re` module:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经向您展示了多种手动迭代字符串中字符序列的方法，以挑选出匹配`C`或`G`的字符。这就是模式匹配，而这正是正则表达式所做的。对您来说，学习另一种领域特定语言（DSL）的成本是必要的，但由于正则表达式在Python之外广泛使用，这是值得的。首先导入`re`模块：
- en: '[PRE59]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You should read **`help(re)`**, as this is a fantastically useful module. I
    want to use the `re.findall()` function to find all occurrences of a pattern in
    a string. I can create a *character class* pattern for the regex engine by using
    square brackets to enclose any characters I want to include. The class `[GC]`
    means *match either G or C*:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该阅读**`help(re)`**，因为这是一个非常有用的模块。我想使用`re.findall()`函数来查找字符串中模式的所有出现。我可以通过使用方括号将要包含的任何字符括起来来为正则表达式引擎创建*字符类*模式。类`[GC]`表示*匹配G或C*：
- en: '[PRE60]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As before, I can use the `len()` function to find how many `C`s and `G`s there
    are. The following code shows how I would incorporate this into my function. Note
    that I use the `if` expression to return `0` if the sequence is the empty string
    so I can avoid division when `len(seq)` is `0`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我可以使用`len()`函数找出有多少个`C`和`G`。以下代码显示了我如何将其合并到我的函数中。请注意，如果序列为空字符串，我使用`if`表达式返回`0`，这样可以避免在`len(seq)`为`0`时进行除法：
- en: '[PRE61]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Note that it’s important to change how this function is called from `main()`
    to explicitly coerce the `rec.seq` value (which is a `Seq` object) to a string
    by using `str()`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，重要的是从`main()`中调用此函数时要显式强制`rec.seq`值（即`Seq`对象）转换为字符串，使用`str()`：
- en: '[PRE62]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO20-1)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO20-1)'
- en: Coerce the sequence to a string value or the `Seq` object will be passed.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 强制将序列转换为字符串值，否则将传递`Seq`对象。
- en: 'Solution 8: A More Complex find_gc() Function'
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案8：一个更复杂的`find_gc()`函数
- en: In this final solution, I’ll move almost all of the code from `main()` into
    the `find_gc()` function. I want the function to accept a `SeqRecord` object rather
    than a string of the sequence, and I want it to return the `MySeq` tuple.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最终的解决方案中，我将几乎所有代码从`main()`移动到`find_gc()`函数中。我希望该函数接受一个`SeqRecord`对象而不是序列的字符串，并且希望它返回`MySeq`元组。
- en: 'First I’ll change the tests:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我将更改测试：
- en: '[PRE63]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'These are essentially the same tests as before, but I’m now passing `SeqRecord`
    objects. To make this work in the REPL, you will need to import a couple of classes:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本上与以前相同的测试，但我现在传递的是`SeqRecord`对象。为了使其在 REPL 中工作，您需要导入一些类：
- en: '[PRE64]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If you look at the object, it looks similar enough to the data I’ve been reading
    from input files because I only care about the `seq` field:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看对象，它看起来与我从输入文件中读取的数据非常相似，因为我只关心`seq`字段：
- en: '[PRE65]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If you run **`pytest`**, your `test_find_gc()` function should fail because
    you haven’t yet changed your `find_gc()` function. Here’s how I wrote it:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行**`pytest`**，你的`test_find_gc()`函数应该失败，因为你还没有修改`find_gc()`函数。以下是我编写它的方式：
- en: '[PRE66]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-1)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-1)'
- en: The function accepts a `SeqRecord` and returns a `MySeq`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个`SeqRecord`并返回一个`MySeq`。
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-2)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-2)'
- en: Initialize this to a floating-point `0.`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 将其初始化为浮点数`0.`。
- en: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-3)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-3)'
- en: This syntax is new as of Python 3.8 and allows variable assignment (first) and
    testing (second) in one line using the *walrus* operator (`:=`).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 此语法是 Python 3.8 新增的，允许在一行中使用*海象*操作符（`:=`）进行变量赋值（第一步）和测试（第二步）。
- en: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-4)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-4)'
- en: This is the same code as before.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与以前的代码相同。
- en: '[![5](assets/5.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-5)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-5)'
- en: Return a `MySeq` object.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个`MySeq`对象。
- en: The walrus operator `:=` was proposed in [PEP 572](https://www.python.org/dev/peps/pep-0572),
    which notes that the `=` operator allows you to name the result of an expression
    only in a statement form, “making it unavailable in list comprehensions and other
    expression contexts.” This new operator combines two actions, that of *assigning*
    the value of an expression to a variable and then *evaluating* that variable.
    In the preceding code, `seq` is assigned the value of the stringified sequence.
    If that evaluates to something truthy, such as a nonempty string, then the following
    block of code will be executed.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[PEP 572](https://www.python.org/dev/peps/pep-0572)提出了海象运算符`:=`，指出`=`运算符只能在语句形式下命名表达式的结果，“使其在列表推导和其他表达式上下文中不可用”。这个新操作符结合了两个动作，即将表达式的值赋给变量，然后评估该变量。在前述代码中，`seq`被赋予字符串化序列的值。如果评估结果为真值，例如非空字符串，则将执行以下代码块。'
- en: 'This radically changes the `main()` function. The `for` loop can incorporate
    a `map()` function to turn each `SeqRecord` into a `MySeq`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这会根本改变`main()`函数。`for`循环可以包含一个`map()`函数，将每个`SeqRecord`转换为`MySeq`：
- en: '[PRE67]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-1)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-1)'
- en: Initialize the `high` variable.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化`high`变量。
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-2)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-2)'
- en: Use `map()` to turn each `SeqRecord` into a `MySeq`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`map()`将每个`SeqRecord`转换为`MySeq`。
- en: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-3)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-3)'
- en: Compare the current sequence’s GC content against the running high.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 将当前序列的GC含量与运行时高值进行比较。
- en: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-4)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-4)'
- en: Overwrite the value.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖该值。
- en: '[![5](assets/5.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-5)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-5)'
- en: Print the results.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 打印结果。
- en: The point of the expanded `find_gc()` function was to hide more of the guts
    of the program so I can write a more expressive program. You may disagree, but
    I think this is the most readable version of the program.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展`find_gc()`函数的要点是隐藏更多程序的内部细节，这样我可以编写更具表现力的程序。也许你会有不同看法，但我认为这是程序中最易读的版本。
- en: Benchmarking
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试
- en: 'So which one is the winner? There is a `bench.sh` program that will run `hyperfine`
    on all the `solution*.py` with the *seqs.fa* file. Here is the result:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 那么谁是赢家呢？有一个`bench.sh`程序将在所有`solution*.py`与*seqs.fa*文件上运行`hyperfine`。以下是结果：
- en: '[PRE68]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Going Further
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步
- en: 'Try writing a FASTA parser. Create a new directory called *faparser*:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编写一个FASTA解析器。创建一个名为*faparser*的新目录：
- en: '[PRE69]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Change into that directory, and run **`new.py`** with the `-t|--write_test`
    option:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到该目录，并使用`-t|--write_test`选项运行**`new.py`**：
- en: '[PRE70]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You should now have a structure that includes a *tests* directory along with
    a starting test file:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该有一个包含*tests*目录和一个起始测试文件的结构：
- en: '[PRE71]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You can run **`make test`** or **`pytest`** to verify that everything at least
    runs. Copy the *tests/inputs* directory from *05_gc* to the new *tests* directory
    so you have some test input files. Now consider how you want your new program
    to work. I would imagine it would take one (or more) readable text files as inputs,
    so you could define your arguments accordingly. Then what will your program do
    with the data? Do you want it to print, for instance, the IDs and the length of
    each sequence? Now write the tests and code to manually parse the input FASTA
    files and print the output. Challenge yourself.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行**`make test`**或**`pytest`**来验证至少一切都在运行。将*05_gc*目录中的*tests/inputs*目录复制到新的*tests*目录中，以便有一些测试输入文件。现在考虑一下你希望你的新程序如何工作。我想它将接受一个（或多个）可读的文本文件作为输入，因此您可以相应地定义您的参数。然后，您的程序会对数据做什么？例如，您是否希望打印每个序列的ID和长度？现在编写测试和代码来手动解析输入的FASTA文件并打印输出。挑战自己。
- en: Review
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习
- en: 'Key points from this chapter:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的要点：
- en: You can read `STDIN` from the open filehandle `sys.stdin`.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以从打开的文件句柄`sys.stdin`读取`STDIN`。
- en: The `Bio.SeqIO.parse()` function will parse FASTA-formatted sequence files into
    records, which provides access to the record’s ID and sequence.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bio.SeqIO.parse()`函数将解析FASTA格式的序列文件为记录，这样可以访问记录的ID和序列。'
- en: You can use several constructs to visit all the elements of iterables, including
    `for` loops, list comprehensions, and the functions `filter()` and `map()`.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用多种结构来访问可迭代对象的所有元素，包括`for`循环、列表推导式以及`filter()`和`map()`函数。
- en: A list comprehension with a guard will only produce elements that return a truthy
    value for the guard. This can also be expressed using the `filter()` function.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带守卫条件的列表推导式仅会生成在守卫条件返回真值的元素。这也可以使用`filter()`函数来表达。
- en: Avoid writing algorithms that attempt to store all the data from an input file,
    as you could exceed the available memory on your machine.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免编写试图存储输入文件中所有数据的算法，因为这样可能超出机器可用的内存。
- en: The `sorted()` function will sort homogeneous lists of strings and numbers lexicographically
    and numerically, respectively. It can also sort homogeneous lists of tuples using
    each position of the tuples in order.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sorted()`函数将按字典顺序和数字顺序分别对字符串和数字的同类列表进行排序。它还可以按顺序对元组列表的每个位置进行排序。'
- en: Formatting templates for strings can include `printf()`-like instructions to
    control how output values are presented.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串格式化模板可以包含类似于`printf()`的指令，以控制输出值的呈现方式。
- en: The `sum()` function will add a list of numbers.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sum()`函数将对一组数字进行求和。'
- en: Booleans in Python are actually integers.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 中的布尔值实际上是整数。
- en: Regular expressions can find patterns of text.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式可以找到文本的模式。
- en: ^([1](ch05.html#idm45963634979240-marker)) As the saying goes, “Weeks of coding
    can save you hours of planning.”
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.html#idm45963634979240-marker)) 俗话说，“几周的编码可以节省几小时的规划。”
