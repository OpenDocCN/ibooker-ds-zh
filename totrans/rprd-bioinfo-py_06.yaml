- en: 'Chapter 5\. Computing GC Content: Parsing FASTA and Analyzing Sequences'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html#ch01), you counted all the bases in a string of DNA.
    In this exercise, you need to count the *G*s and *C*s in a sequence and divide
    by the length of the sequence to determine the GC content as described on [the
    Rosalind GC page](https://oreil.ly/gv8V7). GC content is informative in several
    ways. A higher GC content level indicates a relatively higher melting temperature
    in molecular biology, and DNA sequences that encode proteins tend to be found
    in GC-rich regions. There are many ways to solve this problem, and they all start
    with using Biopython to parse a FASTA file, a key file format in bioinformatics.
    I’ll show you how to use the `Bio.SeqIO` module to iterate over the sequences
    in the file to identify the sequence with the highest GC content.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to parse FASTA format using `Bio.SeqIO`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to read `STDIN` (pronounced *standard in*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several ways to express the notion of a `for` loop using list comprehensions,
    `filter()`, and `map()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to address runtime challenges such as memory allocation when parsing large
    files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More about the `sorted()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to include formatting instructions in format strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `sum()` function to add a list of numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use regular expressions to count the occurrences of a pattern in a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code and tests for this program are in the *05_gc* directory. While
    I’d like to name this program `gc.py`, it turns out that this conflicts with a
    very important Python module called [`gc.py`](https://oreil.ly/7eNBw) which is
    used for garbage collection, such as freeing memory. Instead, I’ll use `cgc.py`
    for *calculate GC*.
  prefs: []
  type: TYPE_NORMAL
- en: If I called my program `gc.py`, my code would *shadow* the built-in `gc` module,
    making it unavailable. Likewise, I can create variables and functions with names
    like `len` or `dict` which would shadow those built-in functions. This will cause
    many bad things to happen, so it’s best to avoid these names. Programs like `pylint`
    and `flake8` can find problems like this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by copying the first solution and asking for the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the positional `[FILE]` is in square brackets to indicate that it
    is optional.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This is a rather ugly message that is trying to explain that the default input
    is `STDIN`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in [Chapter 2](ch02.html#ch02), this program expects a file as input and
    will reject invalid or unreadable files. To illustrate this second point, create
    an empty file using `touch` and then use `chmod` (change mode) to set the permissions
    to `000` (all read/write/execute bits off):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the error message specifically tells me that I lack permission
    to read the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the program with valid input and observe that the program prints the
    ID of the record having the highest percentage of GC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This program can also read from `STDIN`. Simply because I think it’s fun, I’ll
    show you how, in the `bash` shell, I can use the pipe operator (`|`) to route
    the `STDOUT` from one program to the `STDIN` of another program. For instance,
    the `cat` program will print the contents of a file to `STDOUT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the pipe, I can feed this to my program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'I can also use the `<` operator to redirect input from a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To get started, remove this program and start over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows how to modify the first part of the program to accept a
    single positional argument that is a valid, readable file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The only attribute of the `Args` class is a filehandle.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a positional file argument that, if provided, must be a readable text
    file.
  prefs: []
  type: TYPE_NORMAL
- en: It’s rare to make a positional argument optional, but in this case, I want to
    either handle a single file input or read from `STDIN`. To do this, I use `nargs='?'`
    to indicate that the parameter should accept zero or one argument (see [Table 2-2](ch02.html#table_2.2)
    in [“Opening the Output Files”](ch02.html#openingOutputFiles)) and set `default=sys.stdin`.
    In [Chapter 2](ch02.html#ch02), I mentioned that `sys.stdout` is a filehandle
    that is always open for writing. Similarly, `sys.stdin` is an open filehandle
    from which you can always read `STDIN`. This is all the code that is required
    to make your program read either from a file or from `STDIN`, and I think that’s
    rather neat and tidy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your `main()` to print the name of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run **`pytest`** to see how you’re faring. You should pass the first three
    tests and fail on the fourth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The test is running the program using the first input file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The output is expected to be the given string.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the expected string.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the string that was printed.
  prefs: []
  type: TYPE_NORMAL
- en: So far you have created a syntactically correct, well-structured, and documented
    program that validates a file input, all by doing relatively little work. Next,
    you need to figure out how to find the sequence with the highest GC content.
  prefs: []
  type: TYPE_NORMAL
- en: Get Parsing FASTA Using Biopython
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The data from the incoming file or `STDIN` should be sequence data in FASTA
    format, which is a common way to represent biological sequences. Let’s look at
    the first file to understand the format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: A FASTA record starts with a `>` at the beginning of a line. The sequence ID
    is any following text up to the first space.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A sequence can be any length and can span multiple lines or be placed on a single
    line.
  prefs: []
  type: TYPE_NORMAL
- en: The header of a FASTA file can get very ugly, very quickly. I would encourage
    you to download real sequences from the National Center for Biotechnology Information
    (NCBI) or look at the files in the *17_synth/tests/inputs* directory for more
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'While it would be fun (for certain values of fun) to teach you how to manually
    parse this file, I’ll go straight to using Biopython’s `Bio.SeqIO` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is the name of the input file. As this function can parse
    many different record formats, the second argument is the format of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can check the type of `recs` using `type()`, as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve shown iterators a couple of times now, even creating one in [Chapter 4](ch04.html#ch04).
    In that exercise, I used the `next()` function to retrieve the next value from
    the Fibonacci sequence generator. I’ll do the same here to retrieve the first
    record and inspect its type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To learn more about a sequence record, I highly recommend you read [the `SeqRecord`
    documentation](https://biopython.org/wiki/SeqRecord) in addition to the documentation
    in the REPL, which you can view using **`help(rec)`**. The data from the FASTA
    record must be *parsed*, which means discerning the meaning of the data from its
    syntax and structure. If you look at `rec` in the REPL, you’ll see something that
    looks like a dictionary. This output is the same as that from `repr(seq)`, which
    is used to “return the canonical string representation of the object”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The multiple lines of the sequence are concatenated into a single sequence represented
    by a `Seq` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `ID` of a FASTA record is all the characters in the header starting *after*
    the `>` and continuing up to the first space.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `SeqRecord` object is meant to also handle data with more fields, such as
    `name`, `description`, and database cross-references (`dbxrefs`). Since those
    fields are not present in FASTA records, the ID is duplicated for `name` and `description`,
    and the `dbxrefs` value is the empty list.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you print the sequence, this information will be *stringified* so it’s a
    little easier to read. This output is the same as that for `str(rec)`, which is
    meant to provide a useful string representation of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The most salient feature for this program is the record’s sequence. You might
    expect this would be a `str`, but it’s actually another object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Use **`help(rec.seq)`** to see what attributes and methods the `Seq` object
    offers. I only want the DNA sequence itself, which I can get by coercing the sequence
    to a string using the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note this is the same class I used in the last solution of [Chapter 3](ch03.html#ch03)
    to create a reverse complement. I can use it here like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `Seq` object has many other useful methods, and I encourage you to explore
    the documentation as these can save you a lot of time.^([1](ch05.html#idm45963634979240))
    At this point, you may feel you have enough information to finish the challenge.
    You need to iterate through all the sequences, determine what percentage of the
    bases are *G* or *C*, and return the ID and GC content of the record with the
    maximum value. I would challenge you to write a solution on your own. If you need
    more help, I’ll show you one approach, and then I’ll cover several variations
    in the solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating the Sequences Using a for Loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far I’ve shown that `SeqIO.parse()` accepts a filename as the first argument,
    but the `args.file` argument will be an open filehandle. Luckily, the function
    will also accept this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'I can use a `for` loop to iterate through each record to print the ID and the
    first 10 bases of each sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a moment to run those lines again and notice that nothing will be printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Earlier I showed that `recs` is a `Bio.SeqIO.FastaIO.FastaIterator`, and, like
    all iterators, it will produce values until exhausted. If you want to loop through
    the records again, you will need to recreate the `recs` object using the `SeqIO.parse()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the moment, assume the sequence is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'I need to find how many *C*s and *G*s occur in that string. I can use another
    `for` loop to iterate each base of the sequence and increment a counter whenever
    the base is a *G* or a *C*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a variable for the counts of the *G/C* bases.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate each base (character) in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: See if the base is in the tuple containing `G` or `C`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Increment the GC counter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the percentage of GC content, divide the GC count by the length of
    the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The output from the program should be the ID of the sequence with the highest
    `GC` count, a single space, and the GC content truncated to six significant digits.
    The easiest way to format the number is to learn more about `str.format()`. The
    `help` doesn’t have much in the way of documentation, so I recommend you read
    [PEP 3101](https://oreil.ly/OIpEq) on advanced string formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 1](ch01.html#ch01), I showed how I can use `{}` as placeholders
    for interpolating variables either using `str.format()` or f-strings. I can add
    formatting instructions after a colon (`:`) in the curly brackets. The syntax
    looks like that used with the `printf()` function in C-like languages, so `{:0.6f}`
    is a floating-point number to six places:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, to execute the code directly inside an f-string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To figure out the sequence with the maximum `GC` count, you have a couple of
    options, both of which I’ll demonstrate in the solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: Make a list of all the IDs and their GC content (a list of tuples would serve
    well). Sort the list by GC content and take the maximum value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep track of the ID and GC content of the maximum value. Overwrite this when
    a new maximum is found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I think that should be enough for you to finish a solution. You can do this.
    Fear is the mind killer. Keep going until you pass *all* the tests, including
    those for linting and type checking. Your test output should look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As before, all the solutions share the same `get_args()`, so only the differences
    will be shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 1: Using a List'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at my first solution. I always try to start with the most obvious
    and simple way, and you’ll find this is often the most verbose. Once you understand
    the logic, I hope you’ll be able to follow more powerful and terse ways to express
    the same ideas. For this first solution, be sure to also import `List` and `Tuple`
    from the `typing` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize an empty list to hold the GC content and sequence IDs as tuples.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through each record in the input file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a GC counter.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through each sequence, uppercased to guard against possible mixed-case
    input.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Check if the base is a *C* or *G*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Increment the GC counter.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the GC content.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Append a new tuple of the GC content and the sequence ID.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Take the maximum value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](assets/10.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-10)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the sequence ID and GC content of the highest value.
  prefs: []
  type: TYPE_NORMAL
- en: The type annotation `List[Tuple[float, str]]` on the `seqs` variable provides
    not only a way to programmatically check the code using tools like `mypy` but
    also an added layer of documentation. The reader of this code doesn’t have to
    jump ahead to see what kind of data will be added to the list because it has been
    explicitly described using types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this solution, I decided to make a list of all the IDs and GC percentages
    mostly so that I could show you how to create a list of tuples. Then I wanted
    to point out a few magical properties of Python’s sorting. Let’s start with the
    `sorted()` function, which works on strings as you might imagine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When all the values are numbers, they will be sorted numerically, so I’ve got
    that going for me, which is nice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that those same values *as strings* will sort in lexicographic order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now consider a list of tuples where the first element is a `float` and the
    second element is a `str`. How will `sorted()` handle this? By first sorting all
    the data by the first elements *numerically* and then the second elements *lexicographically*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Structuring `seqs` as `List[Tuple[float, str]]` takes advantage of this built-in
    behavior of `sorted()`, allowing me to quickly sort the sequences by GC content
    and select the highest value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same as finding the highest value, which the `max()` function can
    do more easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`high` is a tuple where the first position is the sequence ID and the zeroth
    position is the GC content that needs to be formatted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Solution 2: Type Annotations and Unit Tests'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hidden inside the `for` loop is a kernel of code to compute GC content that
    needs to be extracted into a function with a test. Following the ideas of test-driven
    development (TDD), I will first define a `find_gc()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The function accepts a `str` and returns a `float`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: For now, I return `0`. Note the trailing `.` tells Python this is a `float`.
    This is shorthand for `0.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I’ll define a function that will serve as a unit test. Since I’m using
    `pytest`, this function’s name must start with `test_`. Because I’m testing the
    `find_gc()` function, I’ll name the function `test_find_gc`. I will use a series
    of `assert` statements to test if the function returns the expected result for
    a given input. Note how this test function serves both as a formal test and as
    an additional piece of documentation, as the reader can see the inputs and outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: If a function accepts a `str`, I always start by testing with the empty string
    to make sure it returns something useful.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A single `C` should be 100% GC.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Same for a single `G`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Various other tests mixing bases at various percentages.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s rarely possible to exhaustively check every possible input to a function,
    so I often rely on spot-checking. Note that the [`hypothesis` module](https://hypothesis.readthedocs.io/en/latest)
    can generate random values for testing. Presumably, the `find_gc()` function is
    simple enough that these tests are sufficient. My goal in writing functions is
    to make them as simple as possible, but no simpler. As Tony Hoare says, “There
    are two ways to write code: write code so simple there are obviously no bugs in
    it, or write code so complex that there are no obvious bugs in it.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `find_gc()` and `test_find_gc()` functions are inside the `cgc.py` program,
    not in the *tests/cgc_test.py* module. To execute the unit test, I run `pytest`
    on the source code *expecting the test to fail*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The unit test fails as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The first test passes because it was expecting `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This test fails because it should have returned `100`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now I have established a baseline from which I can proceed. I know that my
    code fails to meet some expectation as formally defined using a test. To fix this,
    I move all the relevant code from `main()` into the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This guards against trying to divide by 0 when the sequence is the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: If there is no sequence, the GC content is 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the same code as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then I run `pytest` again to check that the function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This is TDD:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a function to test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure the function fails the test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the function work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure the function passes the test (and all your previous tests still pass).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If I later encounter sequences that trigger bugs in my code, I’ll fix the code
    and add those as more tests. I shouldn’t have to worry about weird cases like
    the `find_gc()` function receiving a `None` or a list of integers *because I used
    type annotations*. Testing is useful. Type annotations are useful. Combining tests
    and types leads to code that is easier to verify and comprehend.
  prefs: []
  type: TYPE_NORMAL
- en: 'I want to make one other addition to this solution: a custom type to document
    the tuple holding the GC content and sequence ID. I’ll call it `MySeq` just to
    avoid any confusion with the `Bio.Seq` class. I add this below the `Args` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The GC content is a percentage.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO13-2)'
  prefs: []
  type: TYPE_NORMAL
- en: I would prefer to use the field name `id`, but that conflicts with the `id()`
    *identity* function which is built into Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how it can be incorporated into the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `MySeq` as a type annotation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create `MySeq` using the return value from the `find_gc()` function and the
    record ID.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This still works because `MySeq` is a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the field access rather than the index position of the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: This version of the program is arguably easier to read. You can and should create
    as many custom types as you want to better document and test your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 3: Keeping a Running Max Variable'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous solution works well, but it’s a bit verbose and needlessly keeps
    track of *all* the sequences when I only care about the maximum value. Given how
    small the test inputs are, this will never be a problem, but bioinformatics is
    always about scaling up. A solution that tries to store all the sequences will
    eventually choke. Consider processing 1 million sequences, or 1 billion, or 100
    billion. Eventually, I’d run out of memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a solution that would scale to any number of sequences, as it only ever
    allocates a single tuple to remember the highest value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a variable to remember the highest value. Type annotation is superfluous
    as `mypy` will expect this variable to remain this type forever.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the GC content.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-3)'
  prefs: []
  type: TYPE_NORMAL
- en: See if the percent GC is greater than the highest value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-4)'
  prefs: []
  type: TYPE_NORMAL
- en: If so, overwrite the highest value using this percent GC and sequence ID.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the highest value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this solution, I also took a slightly different approach to compute the
    `GC` content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `str.count()` method to find the `C`s and `G`s in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO16-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Since there are two conditions for the state of the sequence—the empty string
    or not—I prefer to write a single `return` using an `if` expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll benchmark the last solution against this one. First I need to generate
    an input file with a significant number of sequences, say 10K. In the *05_gc*
    directory, you’ll find a `genseq.py` file similar to the one I used in the *02_rna*
    directory. This one generates a FASTA file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how I’ll generate an input file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'I can use that with `hyperfine` to compare these two implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: It would appear that the third solution is about four times faster than the
    second running on 10K sequences. You can try generating more and longer sequences
    for your own benchmarking. I would recommend you create a file with at least one
    million sequences and compare your first solution with this version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 4: Using a List Comprehension with a Guard'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Figure 5-1](#fig_5.1) shows that another way to find all the *C*s and *G*s
    in the sequence is to use a list comprehension and the `if` comparison from the
    first solution, which is called a *guard*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 0501](assets/mpfb_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. A list comprehension with a guard will select only those elements
    returning a truthy value for the `if` expression
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The list comprehension only yields those elements passing the guard which checks
    that the `base` is in the string `''CG''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the result is a new list, I can use the `len()` function to find how
    many `C`s and `G`s are present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'I can incorporate this idea into the `find_gc()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO17-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Another way to count the *C*s and *G*s is to select them using a list comprehension
    with a guard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 5: Using the filter() Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The idea of a list comprehension with a guard can be expressed with the higher-order
    function `filter()`. Earlier in the chapter I used the `map()` function to apply
    the `int()` function to all the elements of a list to produce a new list of integers.
    The `filter()` function works similarly, accepting a function as the first argument
    and an iterable as the second. It’s different, though, as only those elements
    returning a truthy value when the function is applied will be returned. As this
    is a lazy function, I will need to coerce with `list()` in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'So here’s another way to express the same idea from the last solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO18-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `filter()` to select only those bases matching *C* or *G*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 6: Using the map() Function and Summing Booleans'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `map()` function is a favorite of mine, so I want to show another way to
    use it. I could use `map()` to turn each base into a 1 if it’s a *C* or *G*, and
    a `0` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Counting the *C*s and *G*s would then be a matter of summing this list, which
    I can do using the `sum()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'I can shorten my `map()` to return the result of the comparison (which is a
    `bool` but also an `int`) and sum that instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how I could incorporate this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO19-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Transform the sequence into Boolean values based on their comparison to the
    bases *C* or *G*, then sum the `True` values to get a count.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 7: Using Regular Expressions to Find Patterns'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far I’ve been showing you multiple ways to manually iterate a sequence of
    characters in a string to pick out those matching `C` or `G`. This is pattern
    matching, and it’s precisely what regular expressions do. The cost to you is learning
    another domain-specific language (DSL), but this is well worth the effort as regexes
    are widely used outside of Python. Begin by importing the `re` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'You should read **`help(re)`**, as this is a fantastically useful module. I
    want to use the `re.findall()` function to find all occurrences of a pattern in
    a string. I can create a *character class* pattern for the regex engine by using
    square brackets to enclose any characters I want to include. The class `[GC]`
    means *match either G or C*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, I can use the `len()` function to find how many `C`s and `G`s there
    are. The following code shows how I would incorporate this into my function. Note
    that I use the `if` expression to return `0` if the sequence is the empty string
    so I can avoid division when `len(seq)` is `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that it’s important to change how this function is called from `main()`
    to explicitly coerce the `rec.seq` value (which is a `Seq` object) to a string
    by using `str()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO20-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Coerce the sequence to a string value or the `Seq` object will be passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 8: A More Complex find_gc() Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this final solution, I’ll move almost all of the code from `main()` into
    the `find_gc()` function. I want the function to accept a `SeqRecord` object rather
    than a string of the sequence, and I want it to return the `MySeq` tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'First I’ll change the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'These are essentially the same tests as before, but I’m now passing `SeqRecord`
    objects. To make this work in the REPL, you will need to import a couple of classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the object, it looks similar enough to the data I’ve been reading
    from input files because I only care about the `seq` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run **`pytest`**, your `test_find_gc()` function should fail because
    you haven’t yet changed your `find_gc()` function. Here’s how I wrote it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The function accepts a `SeqRecord` and returns a `MySeq`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize this to a floating-point `0.`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This syntax is new as of Python 3.8 and allows variable assignment (first) and
    testing (second) in one line using the *walrus* operator (`:=`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the same code as before.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Return a `MySeq` object.
  prefs: []
  type: TYPE_NORMAL
- en: The walrus operator `:=` was proposed in [PEP 572](https://www.python.org/dev/peps/pep-0572),
    which notes that the `=` operator allows you to name the result of an expression
    only in a statement form, “making it unavailable in list comprehensions and other
    expression contexts.” This new operator combines two actions, that of *assigning*
    the value of an expression to a variable and then *evaluating* that variable.
    In the preceding code, `seq` is assigned the value of the stringified sequence.
    If that evaluates to something truthy, such as a nonempty string, then the following
    block of code will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This radically changes the `main()` function. The `for` loop can incorporate
    a `map()` function to turn each `SeqRecord` into a `MySeq`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the `high` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `map()` to turn each `SeqRecord` into a `MySeq`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Compare the current sequence’s GC content against the running high.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Overwrite the value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the results.
  prefs: []
  type: TYPE_NORMAL
- en: The point of the expanded `find_gc()` function was to hide more of the guts
    of the program so I can write a more expressive program. You may disagree, but
    I think this is the most readable version of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So which one is the winner? There is a `bench.sh` program that will run `hyperfine`
    on all the `solution*.py` with the *seqs.fa* file. Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Going Further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try writing a FASTA parser. Create a new directory called *faparser*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Change into that directory, and run **`new.py`** with the `-t|--write_test`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now have a structure that includes a *tests* directory along with
    a starting test file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: You can run **`make test`** or **`pytest`** to verify that everything at least
    runs. Copy the *tests/inputs* directory from *05_gc* to the new *tests* directory
    so you have some test input files. Now consider how you want your new program
    to work. I would imagine it would take one (or more) readable text files as inputs,
    so you could define your arguments accordingly. Then what will your program do
    with the data? Do you want it to print, for instance, the IDs and the length of
    each sequence? Now write the tests and code to manually parse the input FASTA
    files and print the output. Challenge yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Key points from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You can read `STDIN` from the open filehandle `sys.stdin`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Bio.SeqIO.parse()` function will parse FASTA-formatted sequence files into
    records, which provides access to the record’s ID and sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use several constructs to visit all the elements of iterables, including
    `for` loops, list comprehensions, and the functions `filter()` and `map()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list comprehension with a guard will only produce elements that return a truthy
    value for the guard. This can also be expressed using the `filter()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid writing algorithms that attempt to store all the data from an input file,
    as you could exceed the available memory on your machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sorted()` function will sort homogeneous lists of strings and numbers lexicographically
    and numerically, respectively. It can also sort homogeneous lists of tuples using
    each position of the tuples in order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting templates for strings can include `printf()`-like instructions to
    control how output values are presented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sum()` function will add a list of numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Booleans in Python are actually integers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions can find patterns of text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch05.html#idm45963634979240-marker)) As the saying goes, “Weeks of coding
    can save you hours of planning.”
  prefs: []
  type: TYPE_NORMAL
