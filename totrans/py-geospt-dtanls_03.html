<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 3. QGIS: Exploring PyQGIS and Native Algorithms for Spatial Analytics" data-type="chapter" epub:type="chapter"><div class="chapter" id="qgis_exploring_pyqgis_and_native_algori">
<h1><span class="label">Chapter 3. </span>QGIS: Exploring PyQGIS and Native Algorithms for Spatial Analytics</h1>
<p>In this chapter, we will continue to focus on QGIS as you level up your skills with Python and QGIS. <a contenteditable="false" data-primary="PyQGIS" data-type="indexterm" id="idm45433742253376"/>These are foundational concepts, and learning them will be critical to future geospatial analysis skills, including spatial algorithms, data engineering, prediction modeling and forecasting, and machine learning.</p>
<p>The QGIS integration of Python is called <em>PyQGIS</em>, a Python API that uses defined protocols and customization to automate workflows. <a contenteditable="false" data-primary="QGIS" data-secondary="PyQGIS Python API" data-type="indexterm" id="idm45433742250768"/>Automation is important when running large scripts or building applications. The integration with an API allows you access to a large variety of datasets for exploration and analysis. You can create, modify, and query digital objects of interest that represent features in the real world.</p>
<p>PyQGIS is a wrapper around the underlying C++ library. All the methods and class variables implemented by the C++ version of <code>QgisInterface</code> are made available through the Python wrapper.<a contenteditable="false" data-primary="classes" data-secondary="PyQGIS" data-type="indexterm" id="idm45433742285952"/> PyQGIS <em>classes</em> target functionality within QGIS. You do not need a separate installation of Python because it is installed with QGIS directly into your system.</p>
<p>Python is an object-oriented programming language. You can think of objects as chunks of data (<em>attributes</em>) and behaviors (<em>methods</em>). <a contenteditable="false" data-primary="attributes" data-type="indexterm" id="idm45433742312560"/><a contenteditable="false" data-primary="methods" data-type="indexterm" id="idm45433742244160"/>In Python, objects also include functions. <a contenteditable="false" data-primary="Python" data-secondary="attributes, methods, and classes" data-type="indexterm" id="idm45433742242992"/>Attributes can be either data or functions. Methods are also attributes, which means you can store them in variables, just like any other attribute. A Python class<a contenteditable="false" data-primary="classes" data-secondary="Python" data-type="indexterm" id="idm45433742241824"/> describes instructions for how to change the state of an object and the attributes of the object.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="python_classes">
<h5>Python Classes</h5>
<p>Classes provide a means of bundling data and functionality together. Creating a new class creates a new type of object, allowing new instances of that type to be made. Each class instance can have attributes attached to it for maintaining its state.<a contenteditable="false" data-primary="instances (class)" data-type="indexterm" id="idm45433742237904"/> Class instances can also have methods (defined by the class) for modifying that instance’s state. An <em>instance</em> of the class has a copy of all the same attributes and methods defined in the class; the class acts as a sort of template to define the data and behaviors in instances.</p>
</div></aside>
<p>I will revisit these concepts when we briefly explore Python scripting templates later in the chapter, but I will also highlight them when we use methods or functions that are defined by the <code>QgisInterface</code> class. <a contenteditable="false" data-primary="QgisInterface class" data-type="indexterm" id="idm45433742415152"/>We will begin by using PyQGIS to navigate a sample project. You will upload data layers and learn how to interact with them using the Python Console.</p>
<section data-pdf-bookmark="Exploring the QGIS Workspace: Tree Cover and Inequality in San Francisco" data-type="sect1"><div class="sect1" id="exploring_the_qgis_workspace_tree_cover">
<h1>Exploring the QGIS Workspace: Tree Cover and Inequality in San Francisco</h1>
<p>You learned about urban heat islands in <a data-type="xref" href="ch02.xhtml#essential_facilities_for_spatial_analys">Chapter 2</a>, and we’re going to expand on that here. <a contenteditable="false" data-primary="QGIS" data-secondary="exploring the workspace, tree cover and inequality in San Francisco" data-type="indexterm" id="ix_QGISwksp"/>It is well known that neighborhoods with less tree cover tend to be hotter, often leading to increased health risks. We’re going to explore that idea in the first example of this chapter as it plays out in one US city, San Francisco, with the research question: <em>which neighborhoods in San Francisco are less likely to have tree cover?</em></p>
<p>The map in <a data-type="xref" href="#urban_heat_islands_in_san_franciscocomm">Figure 3-1</a> has four layers of data superimposed onto it: one delineating neighborhood boundaries, one that provides data about tree cover in San Francisco, one that provides data about income level and race, and an OpenStreetMap for location context. <a contenteditable="false" data-primary="urban heat islands" data-secondary="in San Francisco, generated by ArcQGIS" data-secondary-sortas="San" data-type="indexterm" id="idm45433742272544"/>The purple lines indicate neighborhood boundaries represented as a summary feature class.</p>
<p>One last thing we need is a <em>proxy</em>, or stand-in, for low-income neighborhoods. Is there a measure already in use that will tell us what we need to know? In fact, there is: <a href="https://oreil.ly/HeLPB">Equity Strategy Neighborhoods</a>. The San Francisco Municipal Transportation Agency (SFMTA) uses this measure in applying equity policies that attempt to address disparities in transit performance. These neighborhoods were identified based on their percentage of low-income households and public housing and residents’ access to personal vehicles, race/ethnicity, and disability. This could serve our purpose as a proxy for low-income neighborhoods.</p>
<p>With these layers in place, we can think about where areas of adequate tree cover are located and compare them to neighborhoods of different income levels and racial composition.</p>
<figure><div class="figure" id="urban_heat_islands_in_san_franciscocomm"><img alt="Urban heat islands in San Francisco, generated in ArcGIS Online" height="833" src="assets/pgda_0301.png" width="980"/>
<h6><span class="label">Figure 3-1. </span>Urban heat islands in San Francisco, generated in ArcGIS Online</h6>
</div></figure>
<p>You’ll be looking at sample data from <a href="https://oreil.ly/pLNTb">DataSF</a> (pictured in <a data-type="xref" href="#sample_data_visible_in_the_qgis_map_can">Figure 3-2</a>). <a contenteditable="false" data-primary="QGIS" data-secondary="exploring the workspace, tree cover and inequality in San Francisco" data-tertiary="sample data visible in QGIS map canvas" data-type="indexterm" id="idm45433742209872"/>Download the shapefiles from these three data resource links: <a href="https://oreil.ly/HPve3">Equity Strategy Neighborhoods</a>, <a href="https://oreil.ly/RIKUa">SF Urban Tree Canopy</a>, and <a href="https://oreil.ly/qNEsQ">SF_neighborhoods</a>. You will return to these files as soon as you set up your workspace.</p>
<figure><div class="figure" id="sample_data_visible_in_the_qgis_map_can"><img alt="Sample data visible in the QGIS map canvas" height="851" src="assets/pgda_0302.png" width="1502"/>
<h6><span class="label">Figure 3-2. </span>Sample data visible in the QGIS map canvas</h6>
</div></figure>
<section data-pdf-bookmark="The Python Plug-in" data-type="sect2"><div class="sect2" id="the_python_plug_in">
<h2>The Python Plug-in</h2>
<p>Open the Python Console, just as you did in <a data-type="xref" href="ch02.xhtml#essential_facilities_for_spatial_analys">Chapter 2</a>, by either selecting the icon in the toolbar at the top of your window or opening Plugins &gt;&gt; Python Console from the menu bar.<a contenteditable="false" data-primary="Python plug-in for QGIS" data-type="indexterm" id="ix_Pyplg"/><a contenteditable="false" data-primary="QGIS" data-secondary="exploring the workspace, tree cover and inequality in San Francisco" data-tertiary="Python plug-in" data-type="indexterm" id="ix_QGISwkspPyplg"/> You can click the console, and the plug-in will be added to your work space, like in <a data-type="xref" href="#installing_the_python_plug_in">Figure 3-3</a>.</p>
<figure><div class="figure" id="installing_the_python_plug_in"><img alt="Installing the Python plug-in" height="841" src="assets/pgda_0303.png" width="1908"/>
<h6><span class="label">Figure 3-3. </span>Installing the Python plug-in</h6>
</div></figure>
<p>The <code>QgisInterface</code> class provides methods for interacting with the QGIS environment. <a contenteditable="false" data-primary="QgisInterface class" data-type="indexterm" id="idm45433742192320"/>When QGIS is running, a variable<a contenteditable="false" data-primary="iface variable" data-type="indexterm" id="idm45433742193552"/> called <code>iface</code> is set up to provide an object of the <code>QgisInterface</code> class to interact with the running QGIS environment. This interface allows access to the map canvas, menus, toolbars, and other parts of the QGIS application. Both the Python Console and plug-in can use <code>iface</code> to access various parts of the QGIS interface.</p>
<p>In the QGIS desktop application, <code>iface.activeLayer()</code> gives access to the currently selected layer in the legend. The most common use of the <code>iface</code> class is to get a reference to the canvas where maps are displayed.<a contenteditable="false" data-primary="iface.activeLayer method" data-type="indexterm" id="idm45433742186080"/></p>
<p>The prompt at the bottom left of <a data-type="xref" href="#python_console_left_parenthesisleftrigh">Figure 3-4</a> is where you will enter your short code snippets. The results of your queries will appear in the upper console. <a contenteditable="false" data-primary="Python Console in QGIS" data-type="indexterm" id="idm45433742184096"/><a contenteditable="false" data-primary="Python" data-secondary="code editor in QGIS" data-type="indexterm" id="idm45433742183456"/><a contenteditable="false" data-primary="code editor (Python) in QGIS" data-type="indexterm" id="idm45433742184608"/>The code editor, on the right, accommodates longer lines of code and lets you work with your code a bit before you run it.</p>
<figure><div class="figure" id="python_console_left_parenthesisleftrigh"><img alt="Python Console (left) and a Python code editor (right)" height="189" src="assets/pgda_0304.png" width="1193"/>
<h6><span class="label">Figure 3-4. </span>Python Console (left) and a Python code editor (right)</h6>
</div></figure>
<p>Reading the toolbar icons from left to right in <a data-type="xref" href="#python_console_left_parenthesisleftrigh">Figure 3-4</a>, you will see Clear Console (removes the contents in the console), Run Command, Show Editor, Options, and Help.</p>
<p>Selecting Options in the toolbar lets you set the font and perform additional customization. <a contenteditable="false" data-primary="functions" data-secondary="function icons in QGIS" data-type="indexterm" id="idm45433742176352"/>The code editor also lists icons for functions, which you can use when creating scripts directly in the editor window. A full list is given in <a data-type="xref" href="#function_icons_in_qgis">Table 3-1</a>.</p>
<table class="border" id="function_icons_in_qgis">
<caption><span class="label">Table 3-1. </span>Function icons in QGIS</caption>
<tbody>
<tr>
<td><span class="inlineimage"><img alt="Inline" height="18" src="assets/icon01.png" width="14"/></span></td>
<td>Clear Console</td>
</tr>
<tr>
<td><span class="inlineimage"><img alt="Inline" height="14" src="assets/icon02.png" width="11"/></span></td>
<td>Run Command/Run Script</td>
</tr>
<tr>
<td><span class="inlineimage"><img alt="Inline" height="23" src="assets/icon03.png" width="28"/></span></td>
<td>Show Editor/Open in External Editor</td>
</tr>
<tr>
<td><span class="inlineimage"><img alt="Inline" height="16" src="assets/icon04.png" width="24"/></span></td>
<td>Options</td>
</tr>
<tr>
<td><span class="inlineimage"><img alt="Inline" height="16" src="assets/icon05.png" width="17"/></span></td>
<td>Python Console Help</td>
</tr>
<tr>
<td><span class="inlineimage"><img alt="Inline" height="14" src="assets/icon06.png" width="16"/></span></td>
<td>Open Script</td>
</tr>
<tr>
<td><span class="inlineimage"><img alt="Inline" height="16" src="assets/icon07.png" width="23"/></span></td>
<td>Save</td>
</tr>
<tr>
<td><span class="inlineimage"><img alt="Inline" height="16" src="assets/icon08.png" width="15"/></span></td>
<td>Save As</td>
</tr>
<tr>
<td><span class="inlineimage"><img alt="Inline" height="11" src="assets/icon09.png" width="24"/></span></td>
<td>Cut</td>
</tr>
<tr>
<td><span class="inlineimage"><img alt="Inline" height="14" src="assets/icon10.png" width="12"/></span></td>
<td>Copy</td>
</tr>
<tr>
<td><span class="inlineimage"><img alt="Inline" height="15" src="assets/icon11.png" width="12"/></span></td>
<td>Paste</td>
</tr>
<tr>
<td><span class="inlineimage"><img alt="Inline" height="14" src="assets/icon12.png" width="22"/></span></td>
<td>Find Text</td>
</tr>
<tr>
<td><span class="inlineimage"><img alt="Inline" height="15" src="assets/icon13.png" width="13"/></span></td>
<td>Comment</td>
</tr>
<tr>
<td><span class="inlineimage"><img alt="Inline" height="15" src="assets/icon14.png" width="14"/></span></td>
<td>Uncomment</td>
</tr>
<tr>
<td><span class="inlineimage"><img alt="Inline" height="14" src="assets/icon15.png" width="21"/></span></td>
<td>Object Inspector</td>
</tr>
</tbody>
</table>
<p>Type into the console at the &gt;&gt;&gt; prompt:</p>
<pre data-type="programlisting">
print("Save the Planet!")</pre>
<p>Hit Enter and you get the output: Save the Planet!</p>
<p>I also want to point out that the string “Save the Planet!” appears in red in the GQIS console when you type in this code, while the rest appears in black. <a contenteditable="false" data-primary="syntax highlighting" data-type="indexterm" id="idm45433742136016"/>This is called <em>syntax highlighting</em>, and it’s a helpful tool that makes it easier to spot if you’ve made any typing mistakes in your code. <a contenteditable="false" data-primary="brackets ([]) in Python code" data-type="indexterm" id="idm45433742133104"/>Brackets will also be highlighted, because it is a common mistake to accidentally leave out a required opening or <a contenteditable="false" data-primary="Python plug-in for QGIS" data-startref="ix_Pyplg" data-type="indexterm" id="idm45433742133488"/>closing bracket.<a contenteditable="false" data-primary="QGIS" data-secondary="exploring the workspace, tree cover and inequality in San Francisco" data-startref="ix_QGISwkspPyplg" data-tertiary="Python plug-in" data-type="indexterm" id="idm45433742240976"/></p>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="Accessing the Data" data-type="sect2"><div class="sect2" id="accessing_the_dat">
<h2 class="less_space">Accessing the Data</h2>
<p>Before we explore a multilayer example, let’s load a vector layer using Python.<a contenteditable="false" data-primary="vectors" data-secondary="loading vector layer into QGIS using Python" data-type="indexterm" id="idm45433742125776"/><a contenteditable="false" data-primary="QGIS" data-secondary="exploring the workspace, tree cover and inequality in San Francisco" data-tertiary="accessing the data" data-type="indexterm" id="ix_QGISwkspaccda"/> This is the neighborhood layer from <a data-type="xref" href="#urban_heat_islands_in_san_franciscocomm">Figure 3-1</a>. You will need to know the URL from where you downloaded your files. If you go to the Browser panel and locate the downloaded file, the URL is retrievable from Layer Properties, as shown in <a data-type="xref" href="#loading_data_from_the_browser">Figure 3-5</a>.</p>
<figure><div class="figure" id="loading_data_from_the_browser"><img alt="Loading data from the Browser" height="370" src="assets/pgda_0305.png" width="718"/>
<h6><span class="label">Figure 3-5. </span>Loading data from the Browser</h6>
</div></figure>
<p>You’ll have to tell <code>iface</code> to add the vector layer.<a contenteditable="false" data-primary="OGR Simple Features Library" data-secondary="ogr provider" data-type="indexterm" id="idm45433742117680"/> In the code snippet that follows, <code>ogr</code> is the provider key name you saw in <a data-type="xref" href="ch02.xhtml#essential_facilities_for_spatial_analys">Chapter 2</a>. You will work with a few different provider keys in this chapter. Replace <code><em>Path to your shape file.shp</em></code> with the URL you retrieved from the Layer Properties. You’ll also create a variable for San Francisco, <code>SF</code>, and store the location information in it, which lets you refer to it later without having to reenter the string:</p>
<pre data-type="programlisting">
<strong>for</strong> layer <strong>in</strong> QgsProject.instance().mapLayers().values():
    print(layer.name())
SF = iface.addVectorLayer(<span>'</span><span>Path to your shape file.shp</span><span>'</span>,<span>'SF_neighborhoods'</span>,<span>'ogr'</span>)
QgsProject.instance().addMapLayer(SF)
<strong>if</strong> SF.isValid():
    QgsProject.instance().addMapLayer(SF)</pre>
<p>The code here is obtaining the polygon shapes for the neighborhoods in the layer we’re calling SF_neighborhoods. If the vector is valid, this code will add the layer to the canvas. The <code>.isValid</code><code>():</code> is a program check to verify that the input entered is correct.</p>
<p>You have now loaded a layer onto the canvas from the Python Console. The color of the vector layer is random, but you can modify the attributes:</p>
<pre data-type="programlisting">
renderer = SF.renderer()
symbol = renderer.symbol()
symbol.setColor(QColor(<span>'pink'</span>))</pre>
<p>Next, you’ll want to include the names of the neighborhoods. Select Layer Properties and format the Labels to update the map with the names.<a contenteditable="false" data-primary="labels" data-secondary="adding to map in QGIS" data-type="indexterm" id="idm45433742547664"/> <a contenteditable="false" data-primary="Layer Properties (QGIS)" data-type="indexterm" id="idm45433742108160"/>In <a data-type="xref" href="#layer_properties_adding_labels_to_a_map">Figure 3-6</a>, you can see how to adjust the Font, Style (bold), Size, Color, and Opacity.</p>
<figure><div class="figure" id="layer_properties_adding_labels_to_a_map"><img alt="Layer properties: adding labels to a map" height="600" src="assets/pgda_0306.png" width="821"/>
<h6><span class="label">Figure 3-6. </span>Layer properties: adding labels to a map</h6>
</div></figure>
<p>The labels are added to the canvas (<a data-type="xref" href="#sf_neighborhood_layer_from_qgiscomma_wi">Figure 3-7</a>) when you select Apply and OK.</p>
<p>Load in the remaining layers. <a contenteditable="false" data-primary="iface.addVectorLayer method" data-type="indexterm" id="idm45433742101808"/><a contenteditable="false" data-primary="addVectorLayer method" data-type="indexterm" id="idm45433742100672"/>The quickest way is to use the <code>addVectorLayer()</code> method as follows:</p>
<pre data-type="programlisting">
<span>vlayer = iface.addVectorLayer(</span>"Path to SF Urban Tree Canopy.shp"<span>,</span> "SF_TREES"<span>,</span>
"ogr"<span>)
<strong>if not</strong> vlayer:
  print(</span>"Layer failed to load!"<span>)

vlayer = iface.addVectorLayer(</span>"Path to Equity Strategy Neighborhoods.shp"<span>,</span> 
"ESN layer"<span>,</span> "ogr"<span>)
<strong>if not</strong> vlayer:
  print(</span>"Layer failed to load!"<span>)</span></pre>
<figure><div class="figure" id="sf_neighborhood_layer_from_qgiscomma_wi"><img alt="SF neighborhood layer from QGIS, with labels" height="856" src="assets/pgda_0307.png" width="1161"/>
<h6><span class="label">Figure 3-7. </span>SF neighborhood layer from QGIS, with labels</h6>
</div></figure>
<p>Earlier, you used the method <code>QgsProject.instance().addMapLayer(SF)</code> to set the active layer. <a contenteditable="false" data-primary="QGIS" data-secondary="exploring the workspace, tree cover and inequality in San Francisco" data-startref="ix_QGISwkspaccda" data-tertiary="accessing the data" data-type="indexterm" id="idm45433742090592"/>Here, you are adding the vector layer, <code>iface.addVectorLayer</code>.</p>
</div></section>
<section data-pdf-bookmark="Working with Layer Panels" data-type="sect2"><div class="sect2" id="working_with_layer_panels">
<h2>Working with Layer Panels</h2>
<p>Before we view the final map, I want to rewind a little to show you how we got here. On your canvas you have three vector layers.<a contenteditable="false" data-primary="QGIS" data-secondary="exploring the workspace, tree cover and inequality in San Francisco" data-tertiary="working with Layer panels" data-type="indexterm" id="idm45433742086480"/><a contenteditable="false" data-primary="layers" data-secondary="working with Layer panels in QGIS" data-type="indexterm" id="idm45433742084304"/></p>
<p>Click on View in the menu bar and scroll down to Panels (<a data-type="xref" href="#types_of_panels_available_in_qgis">Figure 3-8</a>) to see a nested menu of Panel options. <a contenteditable="false" data-primary="panels" data-secondary="types of Panels available in QGIS" data-type="indexterm" id="idm45433742081904"/>You can dock these options onto your canvas to make them accessible while you are building a visualization (map) and interacting with the features and underlying data.</p>
<figure><div class="figure" id="types_of_panels_available_in_qgis"><img alt="Types of panels available in QGIS" height="1058" src="assets/pgda_0308.png" width="1675"/>
<h6><span class="label">Figure 3-8. </span>Types of panels available in QGIS</h6>
</div></figure>
<p>To dock panels, you can <a contenteditable="false" data-primary="panels" data-secondary="docking/undocking in QGIS" data-type="indexterm" id="idm45433742076992"/>drag them on top of one another to save space and move between them as needed by selecting the panel. If you decide you prefer to undock them, click the stacked image next to the X, and one by one they will undock. I suggest docking Layers &gt;&gt; Layer Styling &gt;&gt; Browser &gt;&gt; Processing Toolbox. As you begin working, you can remove or add panels simply by returning to your canvas or by clicking View in the menu and scrolling to Panels, then checking or unchecking options.</p>
<p>The panels are a type of widget. You can use them to provide inputs and visibility, digitize coordinates, perform statistical analysis, and add data sources, to name a few examples. See the <a href="https://oreil.ly/QWQF1">QGIS User Guide</a> for details on all the different options. I will walk you through the panels I use in almost all of the map projects I create.</p>
<p>In <a data-type="xref" href="#editing_the_layers_on_the_map_canvas">Figure 3-9</a>, you can see that the layers in the upper left window have been moved into a hierarchy that allows each to be visible. For example, the labels for the neighborhoods are at the highest level, so they aren’t buried beneath the other features or the polygons.<a contenteditable="false" data-primary="layers" data-secondary="editing on map canvas in QGIS" data-type="indexterm" id="idm45433742549120"/></p>
<figure><div class="figure" id="editing_the_layers_on_the_map_canvas"><img alt="Editing the layers on the map canvas" height="1058" src="assets/pgda_0309.png" width="1637"/>
<h6><span class="label">Figure 3-9. </span>Editing the layers on the map canvas</h6>
</div></figure>
<p>In the Layers panel, you can also adjust opacity and colors. You want to be certain that the Equity Strategy Neighborhoods data is visible but not masking the SF Urban Tree Canopy beneath. Select the panels and arrange them on the canvas.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Now that you have been introduced to writing Python code in the console, the <a href="https://oreil.ly/yXc82">QGIS Cheat sheet for PyQGIS</a> has a list of code snippets for you.  <a contenteditable="false" data-primary="PyQGIS" data-secondary="QGIS Cheat Sheet for" data-type="indexterm" id="idm45433742225024"/>Feel free to experiment with them and decide which might introduce efficiencies in your <span class="keep-together">workflow</span>.</p>
</div>
</div></section>
<section data-pdf-bookmark="Addressing the Research Question" data-type="sect2"><div class="sect2" id="addressing_the_research_question">
<h2>Addressing the Research Question</h2>
<p>Now let’s address our original research question. <a contenteditable="false" data-primary="QGIS" data-secondary="exploring the workspace, tree cover and inequality in San Francisco" data-tertiary="addressing the research question" data-type="indexterm" id="idm45433742061968"/>How <em>does</em> the tree-cover data line up with low-income neighborhoods? Can you get a sense of the answer by looking at the map?</p>
<p>At a glance, the tree cover seems sparse in many of the low-income areas we’ve identified. Performing additional calculations of tree-cover density would be the next step in quantifying what we observe in the maps. Selecting one of the neighborhoods reveals the underlying data (<a data-type="xref" href="#selecting_a_neighborhood_and_exploring">Figure 3-10</a>). We won’t come to any formal conclusions here, but I encourage you to see how deep you can go.</p>
<figure><div class="figure" id="selecting_a_neighborhood_and_exploring"><img alt="Selecting a neighborhood and exploring the features" height="906" src="assets/pgda_0310.png" width="1582"/>
<h6><span class="label">Figure 3-10. </span>Selecting a neighborhood and exploring the features</h6>
</div></figure>
<p>This exercise helped you get familiar with the QGIS workspace and the Python plug-in. You learned how to work with layers and add labels. You also learned about finding existing datasets that can serve as a proxy for something you want to measure, and you got a sense of how aligning two datasets on a map can help address research questions.<a contenteditable="false" data-primary="QGIS" data-secondary="exploring the workspace, tree cover and inequality in San Francisco" data-startref="ix_QGISwksp" data-type="indexterm" id="idm45433742062496"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Web Feature Service: Identifying Environmental Threats in Massachusetts" data-type="sect1"><div class="sect1" id="web_feature_service_identifying_environ">
<h1>Web Feature Service: Identifying Environmental Threats in Massachusetts</h1>
<p>In the next example, you will explore another open dataset.<a contenteditable="false" data-primary="Web Feature Service (WFS)" data-secondary="identifying environmental threats in Massachusetts" data-type="indexterm" id="ix_WFS"/> The Massachusetts state government’s <a href="https://oreil.ly/SNfaJ">MassGIS Bureau of Geographic Information</a> provides a GIS tool called <a href="https://oreil.ly/JickV">MassMapper</a>. One of the many data layers provided within this tool is called <a href="https://oreil.ly/9Z3zd">Areas of Critical Environmental Concern (ACECs)</a>. This layer is developed and maintained by the Massachusetts Department of Conservation and Recreation (DCR). According to the site, this data provides information about places in Massachusetts selected for the “quality, uniqueness, and significance of their natural and cultural resources.” Using the ACECs data, we can build a map and see how these areas might be affected by local features, such as the density of nearby roadways and proximity to wetlands or airports.</p>
<section class="pagebreak-before" data-pdf-bookmark="Accessing the Data" data-type="sect2"><div class="sect2" id="accessing_the_data">
<h2 class="less_space">Accessing the Data</h2>
<p>There are many ways to connect to data in QGIS, so here we’ll explore a new one.<a contenteditable="false" data-primary="Web Feature Service (WFS)" data-secondary="identifying environmental threats in Massachusetts" data-tertiary="accessing the data" data-type="indexterm" id="ix_WFSaccda"/></p>
<p>The Web Feature Service (WFS) specification is a type of provider key that allows access to geographic features, with geometry and attributes available for your queries and analyses.<a contenteditable="false" data-primary="Web Feature Service (WFS)" data-type="indexterm" id="idm45433742042240"/><a contenteditable="false" data-primary="WFS" data-see="Web Feature Service" data-type="indexterm" id="idm45433742949616"/>  Connect to the data by selecting Layer &gt;&gt; Data Source Manager or by clicking the icon in the toolbar.<a contenteditable="false" data-primary="WFS/OGC API" data-type="indexterm" id="idm45433742038752"/><a contenteditable="false" data-primary="Data Source Manager (QGIS)" data-secondary="creating WFS connection" data-type="indexterm" id="idm45433742038112"/> Select WFS/OGC API - Features. You can also scroll vertically in your Browser panel. Click on the WFS/OGC API, and the pop-up in <a data-type="xref" href="#creating_a_new_wfs_connection">Figure 3-11</a> will become visible.</p>
<figure><div class="figure" id="creating_a_new_wfs_connection"><img alt="Creating a new WFS connection" height="1198" src="assets/pgda_0311.png" width="1113"/>
<h6><span class="label">Figure 3-11. </span>Creating a new WFS connection</h6>
</div></figure>
<p>Connect to the service by entering the URL <em>http://giswebservices.massgis.state.ma.us/geoserver/wfs</em> into the dialog field (<a data-type="xref" href="#wfs_connection_details">Figure 3-12</a>). You’ll be prompted to create a name for the connection: use MASS_Sample and click OK. The defaults are fine.</p>
<figure><div class="figure" id="wfs_connection_details"><img alt="WFS connection details" height="435" src="assets/pgda_0312.png" width="782"/>
<h6><span class="label">Figure 3-12. </span>WFS connection details</h6>
</div></figure>
<p>The new connection appears in Server Connections. Click Connect and you will see the list of available layers, as pictured in <a data-type="xref" href="#data_source_manager_wfs_connection">Figure 3-13</a>.</p>
<p>Scroll down to find and select the following layers, then click Add:</p>
<ul>
<li>
<p>GISDATA.AIRPORTS_PT (locations of airports)</p>
</li>
<li>
<p>GISDATA.BM2_CH_BIOMAP2_WETLANDS (locations of wetlands)</p>
</li>
<li>
<p>GISDATA.ACECS_POLY (areas of critical environmental concern)</p>
</li>
<li>
<p>GISDATA.CENSUS2010TIGERROADS_ARC (locations<a contenteditable="false" data-primary="Web Feature Service (WFS)" data-secondary="identifying environmental threats in Massachusetts" data-startref="ix_WFSaccda" data-tertiary="accessing the data" data-type="indexterm" id="idm45433742023520"/> of roads)</p>
</li>
</ul>
<figure><div class="figure" id="data_source_manager_wfs_connection"><img alt="Data Source Manager WFS connection" height="1918" src="assets/pgda_0313.png" width="2484"/>
<h6><span class="label">Figure 3-13. </span>Data Source Manager WFS connection</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="Discovering Attributes" data-type="sect2"><div class="sect2" id="discovering_attributes">
<h2>Discovering Attributes</h2>
<p>Enter the following <a contenteditable="false" data-primary="Python Console in QGIS" data-secondary="discovering attributes in layers" data-type="indexterm" id="idm45433742018000"/>code into the<a contenteditable="false" data-primary="attributes" data-secondary="discovering in QGIS layer using Python Console" data-type="indexterm" id="idm45433742016496"/> console<a contenteditable="false" data-primary="Web Feature Service (WFS)" data-secondary="identifying environmental threats in Massachusetts" data-tertiary="discovering attributes" data-type="indexterm" id="idm45433742014992"/> and hit run (the green arrow):</p>
<pre data-type="programlisting">
active_layer = iface.activeLayer()
iface.showAttributeTable(active_layer)
iface.showLayerProperties(active_layer)</pre>
<p>This creates a reference to the active layer, in this case, GISDATA.AIRPORTS_PT. Once you create this reference, you can access the properties of the layer.</p>
<p>Now you can explore a few of the options or access them directly in the console. First, select Open Attribute Table to view the attributes associated with the layer. You can do the same for any layer you want to explore.</p>
<p>As you type code into the console, you may notice that suggestions appear, as shown in <a data-type="xref" href="#automatic_suggestions_in_the_qgis_pytho">Figure 3-14</a>.</p>
<figure><div class="figure" id="automatic_suggestions_in_the_qgis_pytho"><img alt="Automatic suggestions in the QGIS Python Console" height="44" src="assets/pgda_0314.png" width="685"/>
<h6><span class="label">Figure 3-14. </span>Automatic suggestions in the QGIS Python Console</h6>
</div></figure>
<p>Let’s look at the snippet that appears when opening the attribute table:</p>
<pre data-type="programlisting">
showAttributeTable(QgsVectorLayer, QString filterExpression='') -&gt; QDialog</pre>
<p>The yellow box contains the arguments you can supply to the <code>showAttributeTable</code> method and what will be delivered. Here you are calling the <code>QgsVectorLayer</code> object and a string that represents a filter expression, which you can use to filter the data by identifying a specific field, as shown in <a data-type="xref" href="#layers_and_attribute_table">Figure 3-15</a>. The <code>filterExpression</code> is not required, which is indicated by the empty string: <code>=''</code>. If left empty, it simply provides the default, an empty string in this case. The output <code>QDialog</code> constructs the actual attribute table. This is just a brief sample; to learn more about the full functionalities of this particular class, see the <a href="https://oreil.ly/70feB"><code>QgisInterface</code> documentation</a>.</p>
<figure><div class="figure" id="layers_and_attribute_table"><img alt="Layers and attribute table" height="980" src="assets/pgda_0315.png" width="1021"/>
<h6><span class="label">Figure 3-15. </span>Layers and attribute table</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="Working with Iterators" data-type="sect2"><div class="sect2" id="working_with_iterators">
<h2>Working with Iterators</h2>
<p>Next, let’s find the airports.<a contenteditable="false" data-primary="Web Feature Service (WFS)" data-secondary="identifying environmental threats in Massachusetts" data-tertiary="working with iterators" data-type="indexterm" id="ix_WFSiter"/> <a contenteditable="false" data-primary="iterators" data-type="indexterm" id="ix_iter"/><a contenteditable="false" data-primary="Python" data-secondary="iterators, working with" data-type="indexterm" id="ix_Pyiter"/>Writing the following code directly into the console identifies the layer and feature count of the towns where airports are located:</p>
<pre data-type="programlisting">
layer = iface.activeLayer()
print(type(layer))

&lt;class 'qgis._core.QgsVectorLayer'&gt;

print(layer.sourceName())
massgis:GISDATA.AIRPORTS_PT
layer.featureCount()
42</pre>
<p>And here is a snippet of the output:</p>
<pre data-type="programlisting">
BEDFORD
BEVERLY
BOSTON
HANSON
HOPEDALE
...</pre>
<p>An iterator is a type of Python object that contains items that can be iterated upon. Iterators give you a window into a larger dataset, one element at a time. They are similar to other objects, like lists, but with a key difference: when you create an iterator, you don’t store all the items in memory. The iterator loads a single item at a time and then fetches the next item when asked for it. This makes iterators very efficient. They can read large amounts of data without having to read the entire dataset. QGIS implements iterators for many different object types.<a contenteditable="false" data-primary="lists (Python)" data-type="indexterm" id="idm45433742998304"/></p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="lists_in_python">
<h5>Lists in Python</h5>
<p>Lists are mutable. You can add, delete, or change elements within a list. In Python, lists are defined with comma-separated values between square brackets [ ]. You can access each item by its position, or index. In programming, the counting starts from 0, not 1. So the first item has an index of 0, the second item an index of 1, and so on.</p>
</div></aside>
<p class="pagebreak-before less_space">In the following code, the result <a contenteditable="false" data-primary="layer.getFeatures method" data-type="indexterm" id="idm45433742777824"/>of calling <code>layer.getFeatures()</code> is an<a contenteditable="false" data-primary="features" data-secondary="getting for layer in QGIS" data-type="indexterm" id="idm45433742778784"/> iterator; the <code>next()</code> function<a contenteditable="false" data-primary="next function" data-type="indexterm" id="idm45433741980384"/> is a manual iterator; and lists, tuples, and strings are iterables:</p>
<pre data-type="programlisting">
layer = iface.activeLayer()
features = layer.getFeatures()
f = next(features)
print(f.attributes())
f = next(features)
print(f.attributes())</pre>
<p>This outputs:</p>
<pre data-type="programlisting">
<span>[</span>'BED'<span>,</span> 'BEDFORD'<span>,</span> 'HANSCOM FIELD'<span>,</span> 'MassPort'<span>,</span> 'PUBLIC OWNED AP'<span>,</span> 'TRAN'<span>,</span> 
2<span>,</span> '42 28 12'<span>,</span> '71 17 22'<span>,</span> 133<span>,</span> 7001.0<span>,</span> 5106<span>,</span> 150<span>,</span> 150<span>,</span> 'ASPHALT-GROOVED'<span>,</span> 
'ASPHALT'<span>,</span> 'HIRLS'<span>,</span> 'MIRLS'<span>,</span> 'FAA'<span>,</span> 'N'<span>,</span> ' '<span>,</span> 'RELIEVER W/ COMMERCIAL SERVICE'<span>,</span> 
'Y'<span>]
[</span>'BVY'<span>,</span> 'BEVERLY'<span>,</span> 'BEVERLY MUNICIPAL AIRPORT'<span>,</span> 'MAC'<span>,</span> 'PUBLIC OWNED AP'<span>,</span> 'GU-2'<span>,</span> 
2<span>,</span> '42 35 03'<span>,</span> '70 55 03'<span>,</span> 108<span>,</span> 5001.0<span>,</span> 4637<span>,</span> 150<span>,</span> 100<span>,</span> 'ASPHALT'<span>,</span> 'ASPHALT'<span>,</span> 
'MIRLS'<span>,</span> 'MIRLS'<span>,</span> 'CONTRACT'<span>,</span> 'Y'<span>,</span> ' '<span>,</span> 'RELIEVER GA'<span>,</span> 'N'<span>]</span></pre>
<p>If you want a list of all the layers in your map, use the following code:</p>
<pre data-type="programlisting">
<strong>for</strong> layer <strong>in</strong> QgsProject.instance().mapLayers().values():
    print(layer.name())</pre>
<p>It then outputs:</p>
<pre data-type="programlisting">
OpenStreetMap
massgis:GISDATA.ACECS_POLY
massgis:GISDATA.AIRPORTS_PT
massgis:GISDATA.BM2_CH_BIOMAP2_WETLANDS
massgis:GISDATA.CENSUS2010TIGERROADS_ARC</pre>
<p>Selecting Layer Properties will also open up tables, as shown in <a data-type="xref" href="#attributes_and_properties_of_the_select">Figure 3-16</a>. <a contenteditable="false" data-primary="attributes" data-secondary="showing for selected layer in QGIS" data-type="indexterm" id="idm45433741952432"/>Running the code <code>layer.featureCount()</code> earlier showed 42 features total, in this case, airports (the active layer) plus the 23 fields (columns) listed in the Layer Properties panel.</p>
<figure><div class="figure" id="attributes_and_properties_of_the_select"><img alt="Attributes and properties of the selected layer, GISDATA.AIRPORTS_PT" height="972" src="assets/pgda_0316.png" width="1188"/>
<h6><span class="label">Figure 3-16. </span>Attributes and properties of the selected layer, GISDATA.AIRPORTS_PT</h6>
</div></figure>
<p>Adding sample code to the Python <a contenteditable="false" data-primary="Python Console in QGIS" data-secondary="running Python code to add data to the canvas" data-type="indexterm" id="idm45433741946560"/>Console will generate the information for the map layer. When running code a single line at a time, you can use the console and type your code at the &gt;&gt;&gt; prompt. When running multiline scripts, you will want to use the editor: the panel on the right in <a data-type="xref" href="#running_python_code_in_the_console_to_a">Figure 3-17</a>. Line numbers populate as the code runs. You will see this in the final example in the chapter.</p>
<figure><div class="figure" id="running_python_code_in_the_console_to_a"><img alt="Running Python code in the console to add data to the canvas" height="341" src="assets/pgda_0317.png" width="1467"/>
<h6><span class="label">Figure 3-17. </span>Running Python code in the console to add data to the canvas</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="Layer Styling" data-type="sect2"><div class="sect2" id="layer_styling">
<h2>Layer Styling</h2>
<p>The layers can now be<a contenteditable="false" data-primary="Python" data-secondary="iterators, working with" data-startref="ix_Pyiter" data-type="indexterm" id="idm45433741939536"/> modified<a contenteditable="false" data-primary="Web Feature Service (WFS)" data-secondary="identifying environmental threats in Massachusetts" data-startref="ix_WFSiter" data-tertiary="working with iterators" data-type="indexterm" id="idm45433741937856"/> to make <a contenteditable="false" data-primary="iterators" data-startref="ix_iter" data-type="indexterm" id="idm45433741935872"/>features visible and clear so that your audience will understand them.<a contenteditable="false" data-primary="Web Feature Service (WFS)" data-secondary="identifying environmental threats in Massachusetts" data-tertiary="styling layers" data-type="indexterm" id="idm45433741933136"/><a contenteditable="false" data-primary="layers" data-secondary="styling with Layer Styling in QGIS" data-type="indexterm" id="idm45433741931552"/><a contenteditable="false" data-primary="features" data-secondary="making visible and clear with Layer Styling in QGIS" data-type="indexterm" id="idm45433741930208"/> The colors generated are often random, so I like to customize them using Layer Styling.</p>
<p>Now you can view the map (<a data-type="xref" href="#map_of_massachusetts_acecs_areas">Figure 3-18</a>) and explore airport locations, roadways, and wetlands and how they relate to ACECs areas. Where do you see potential for these features to affect the health of these environmentally sensitive areas? What other features might you want to look for in answering this research question?</p>
<figure><div class="figure" id="map_of_massachusetts_acecs_areas"><img alt="Map of Massachusetts ACECs areas" height="841" src="assets/pgda_0318.png" width="1382"/>
<h6><span class="label">Figure 3-18. </span>Map of Massachusetts ACECs areas</h6>
</div></figure>
<p>This exercise gave you some more practice with QGIS layers and introduced you to layer styling. You also learned how to work with iterators and discover attributes.<a contenteditable="false" data-primary="Web Feature Service (WFS)" data-secondary="identifying environmental threats in Massachusetts" data-startref="ix_WFS" data-type="indexterm" id="idm45433742989296"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Using Processing Algorithms in the Python Console" data-type="sect1"><div class="sect1" id="using_processing_algorithms_in_the_pyth">
<h1>Using Processing Algorithms in the Python Console</h1>
<p>So far, you’ve been learning about the capabilities of both the Python Console and QGIS in geospatial analysis. <a contenteditable="false" data-primary="QGIS" data-secondary="using processing algorithms in Python Console" data-type="indexterm" id="ix_QGISprocalg"/><a contenteditable="false" data-primary="Python Console in QGIS" data-secondary="using processing algorithms in" data-type="indexterm" id="ix_PyConprcalg"/><a contenteditable="false" data-primary="processing algorithms" data-secondary="using in Python Console" data-type="indexterm" id="ix_procalg"/>You are gaining familiarity with an information system that combines geographic data with robust software for managing, analyzing, and visualizing that data. By now, you’ve likely discovered even more plug-ins and powerful tools in the Processing Toolbox. <a contenteditable="false" data-primary="Processing Toolbox (QGIS)" data-type="indexterm" id="idm45433741916592"/>You’ve got a great start on using Python for engaging with a system like QGIS.</p>
<p>From here on, you can continue building your expertise by making use of help functions, QGIS documentation, and other resources. You’ll practice that in the following exercise. For this exercise, our research question will be: <em>which cities are located along the Amazonas River?</em> Perhaps you are hoping to focus your attention on how flooding or agricultural runoff affect local communities. The exercise is an opportunity to try filtering and analyzing a large open source dataset. Explore the attribute tables and customize a query!</p>
<p>One of the biggest advantages of Python scripting is that your tasks can be flexible and easy to reproduce. In the final section of this chapter, you will learn how to use <em>processing algorithms:</em> algorithms that let you save your scripts and chain them together. Adapting existing scripts is one of the best ways to learn how Python operates. You’ll be working with a script adapted from Anita Graser<sup><a data-type="noteref" href="ch03.xhtml#ch01fn8" id="ch01fn8-marker">1</a></sup> to build a workflow in the Python console. This workflow will use three processing algorithms:</p>
<ul>
<li>
<p>native:extractbyexpression</p>
</li>
<li>
<p>native:buffer</p>
</li>
<li>
<p>native:extractbylocation</p>
</li>
</ul>
<p>As we did in <a data-type="xref" href="ch02.xhtml#essential_facilities_for_spatial_analys">Chapter 2</a>, we’ll use data from Natural Earth Data. The canvas in <a data-type="xref" href="#exploring_the_area_of_interest_in_the_m">Figure 3-19</a> shows two kinds of data for Brazil: populated places and rivers and lakes. Download <a href="https://oreil.ly/IMccr">GeoPackage</a>, if you have not done so already. Select GeoPackage from Data Source Manager to upload the files.</p>
<figure><div class="figure" id="exploring_the_area_of_interest_in_the_m"><img alt="Exploring the area of interest in the map canvas" height="863" src="assets/pgda_0319.png" width="1740"/>
<h6><span class="label">Figure 3-19. </span>Exploring the area of interest in the map canvas</h6>
</div></figure>
<section data-pdf-bookmark="Working with Algorithms" data-type="sect2"><div class="sect2" id="working_with_algorithms">
<h2>Working with Algorithms</h2>
<p>Before we start, you need to understand where these algorithms originate and how to work with the different parameters.<a contenteditable="false" data-primary="processing algorithms" data-secondary="using in Python Console" data-tertiary="working with algorithms" data-type="indexterm" id="idm45433741903472"/> Write the following code in your Python Console to get started:</p>
<pre data-type="programlisting">
<strong>from</strong> qgis <strong>import</strong> processing</pre>
<p>When working with functions, it’s important to call algorithms by name so that they execute reliably. <a contenteditable="false" data-primary="QgsProcessingRegistry" data-type="indexterm" id="idm45433741899984"/>The <a href="https://oreil.ly/yXOkX"><code>QgsProcessingRegistry</code></a> will list the algorithms correctly. Registries are where you can access algorithms, parameters, and different outputs. You can access the registry by writing this code:</p>
<pre data-type="programlisting">
<strong>for</strong> alg <strong>in</strong> QgsApplication.processingRegistry().algorithms():
        print(alg.id(), <span>"-&gt;"</span>, alg.displayName())</pre>
<p>Algorithms with names starting with <code>native</code> are processing algorithms that still port to C++ and impart a speed advantage over other algorithms.<a contenteditable="false" data-primary="native, algorithm names starting with" data-type="indexterm" id="idm45433741893536"/></p>
<p>You can scroll through the long list in the output (excerpted below) to see the others, but you can also access them directly with a little bit of code:</p>
<pre data-type="programlisting">
native:atlaslayouttomultiplepdf -&gt; Export atlas layout as PDF (multiple files)
native:atlaslayouttopdf -&gt; Export atlas layout as PDF (single file)
native:batchnominatimgeocoder -&gt; Batch Nominatim geocoder
native:bookmarkstolayer -&gt; Convert spatial bookmarks to layer
native:boundary -&gt; Boundary
native:boundingboxes -&gt; Bounding boxes
native:buffer -&gt; Buffer
…</pre>
<p>I counted more than two thousand algorithms when I ran this code. Each algorithm needs certain parameters to execute its code successfully. <a contenteditable="false" data-primary="processing.algorithmHelp parameter" data-type="indexterm" id="idm45433741924416"/>Use the parameter <span class="keep-together"><code>processing.algorithmHelp("algorithmID")</code></span> with the name of the algorithm to output the characteristics of the syntax. This will help familiarize you with writing the code.</p>
<p>First, let’s look at the script we’ll use. Don’t run it yet! Before you do, I’ll break down each piece:</p>
<pre data-type="programlisting">
<span>buffered_amazonas = processing.run(</span>"native:buffer"<span>, 
    {</span>'INPUT'<span>:amazonas,</span>'DISTANCE'<span>:buffer_distance,</span>'SEGMENTS'<span>:</span>5<span>,</span>'END_CAP_STYLE'<span>:</span>0<span>,
   </span> 'JOIN_STYLE'<span>:</span>0<span>,</span>'MITER_LIMIT'<span>:</span>2<span>,</span>'DISSOLVE'<span>:<strong>False</strong>,</span>'OUTPUT'<span>:</span>'memory:'<span>}
    )[</span>'OUTPUT'<span>]my_gpkg =</span> "/Users/bonnymcclain/Downloads/natural_earth_vector/
	packages/natural_earth_vector.gpkg"<span>
rivers =</span> '{}|layername=ne_110m_rivers_lake_centerlines'<span>.format(my_gpkg)
places =</span>'{}|layername=ne_110m_populated_places'<span>.format(my_gpkg)
expression =</span> "name = 'Amazonas'"<span>
amazonas = processing.run(</span>"native:extractbyexpression"<span>, 
    {</span>'INPUT'<span>:rivers,</span>'EXPRESSION'<span>:expression,</span>'OUTPUT'<span>:</span>'memory:'<span>}
    )[</span>'OUTPUT'<span>]
 </span>
<span>buffer_distance =</span> 0.1 <span>#degrees</span> <span>

 </span>
<span>places_along_amazonas = processing.run</span>("native:extractbylocation"<span>, 
    {</span>'INPUT'<span>:places,</span>'PREDICATE'<span>:[</span>0<span>],</span>'INTERSECT'<span>:buffered_amazonas,</span>'OUTPUT'<span>:</span>
	'memory:'<span>}
    )[</span>'OUTPUT'<span>]
 </span>
<span>QgsProject.instance().addMapLayer(places_along_amazonas)
 </span>
<span><strong>for</strong> feature <strong>in</strong> places_along_amazonas.getFeatures():
    print(feature[</span>"name"<span>])</span></pre>
<p>Notice that it runs your three algorithms in order. First, you’ll extract by expression. The result is a layer that is stored in the <code>amazonas</code> variable and passed as input into the next algorithm. The buffer algorithm creates buffers that intersect with buffered river centerlines. The distance from the river, for example, should be within a certain distance of the city. The buffer sets this distance. Next, <code>extractbylocation</code> pulls your list of cities along the river.</p>
</div></section>
<section data-pdf-bookmark="Extract by Expression" data-type="sect2"><div class="sect2" id="extract_by_expression">
<h2>Extract by Expression</h2>
<p>Here’s how the <code>algorithmHelp()</code> function <a contenteditable="false" data-primary="extract by expression processing algorithm" data-type="indexterm" id="idm45433741864416"/>describes <a contenteditable="false" data-primary="processing algorithms" data-secondary="using in Python Console" data-tertiary="extract by expression algorithm" data-type="indexterm" id="idm45433741863152"/>native:extractbyexpression:</p>
<blockquote>
<p>This algorithm creates a new vector layer that only contains matching features from an input layer. The criteria for adding features to the resulting layer is based on a QGIS expression.</p>
</blockquote>
<p>Take a moment to run <code>processing.algorithmHelp("native:extractbyexpression")</code> and read the rest now. It will provide important details and describe the output you can anticipate. If you don’t list a parameter, the default will be applied and output is sent to memory.</p>
<p>Here is the segment of the script that uses this algorithm, so you can examine it in more detail:</p>
<pre data-type="programlisting">
 amazonas = processing.run(<span>"native:extractbyexpression"</span>, 
    {<span>'INPUT'</span>:rivers,<span>'EXPRESSION'</span>:expression,<span>'OUTPUT'</span>:<span>'memory:'</span>}
    )[<span>'OUTPUT'</span>]
buffer_distance = <span>0.1</span> <span>#degrees</span></pre>
</div></section>
<section data-pdf-bookmark="Buffer" data-type="sect2"><div class="sect2" id="buffer">
<h2>Buffer</h2>
<p>Next, run:</p>
<pre data-type="programlisting">
processing.algorithmHelp("native:buffer")</pre>
<p>Let’s see<a contenteditable="false" data-primary="processing algorithms" data-secondary="using in Python Console" data-tertiary="buffer algorithm" data-type="indexterm" id="idm45433741854624"/> what the<a contenteditable="false" data-primary="buffer processing algorithm" data-type="indexterm" id="idm45433741853120"/> <a href="https://oreil.ly/pNmzd">help documentation</a> tells us about native:buffer:</p>
<blockquote>
<p>This algorithm computes a buffer area for all the features in an input layer, using a fixed or dynamic distance.</p>
<p>The segments parameter controls the number of line segments to use to approximate a quarter circle when creating rounded offsets.</p>
<p>The end cap style parameter controls how line endings are handled in the buffer.</p>
<p>The join style parameter specifies whether round, miter or beveled joins should be used when offsetting corners in a line.</p>
<p>The miter limit parameter is only applicable for miter join styles, and controls the maximum distance from the offset curve to use when creating a mitered join.</p>
</blockquote>
<p>Read the full output for the information you need to understand the algorithm and the inputs and outputs needed.<a contenteditable="false" data-primary="parameters for processing algorithms" data-secondary="buffer algorithm" data-type="indexterm" id="idm45433741845904"/> In particular, you need to understand the parameters so you can include them in your query. You will see information for <code>INPUT</code>, <code>DISTANCE</code>, <code>SEGMENTS</code>, <code>END_CAP_STYLE</code>, <code>JOIN_STYLE</code>, <code>MITER_LIMIT</code>, <code>DISSOLVE</code>, and <code>OUTPUT</code>.</p>
<p>Here is the script segment that includes this algorithm:</p>
<pre data-type="programlisting">
<span>buffered_amazonas = processing.run(</span>"native:buffer"<span>, 
    {</span>'INPUT'<span>:amazonas,</span>'DISTANCE'<span>:buffer_distance,</span>'SEGMENTS'<span>:</span>5<span>,</span>'END_CAP_STYLE'<span>:</span>0<span>,
   </span> 'JOIN_STYLE'<span>:</span>0<span>,</span>'MITER_LIMIT'<span>:</span>2<span>,</span>'DISSOLVE'<span>:<strong>False</strong>,</span>'OUTPUT'<span>:</span>
   'memory:'<span>}
    )[</span>'OUTPUT'<span>]</span></pre>
<p>What is this code doing? What can you tell from the syntax here? From reading the output of the <code>algorithmHelp</code> function, you can see that the location vector is now the input for the native.buffer. The buffer will be interested only in data within the buffer range. For example, the rivers and cities should be within 10 kilometers.</p>
</div></section>
<section data-pdf-bookmark="Extract by Location" data-type="sect2"><div class="sect2" id="extract_by_location">
<h2>Extract by Location</h2>
<p>Our third<a contenteditable="false" data-primary="processing algorithms" data-secondary="using in Python Console" data-tertiary="extract by location algorithm" data-type="indexterm" id="idm45433741913008"/> algorithm is native:extractbylocation. <a contenteditable="false" data-primary="extract by location processing algorithm" data-type="indexterm" id="idm45433741827632"/>Next, we’ll <em>intersect</em> the buffered Amazonas data–that is, compare the two sets of data we now have–to combine the rivers data with the places data. This will include the cities along the river we are interested in.</p>
<p>First, run:</p>
<pre data-type="programlisting">
processing.algorithmHelp(<span>"native:extractbylocation"</span>)</pre>
<p>The help documentation again contains important information about the parameters.</p>
<p>Here is the section of our script <a contenteditable="false" data-primary="parameters for processing algorithms" data-secondary="extract by location algorithm" data-type="indexterm" id="idm45433741824080"/>that uses extract by location:</p>
<pre data-type="programlisting">
places_along_amazonas = processing.run(<span>"native:extractbylocation"</span>, 
    {<span>'INPUT'</span>:places,<span>'PREDICATE'</span>:[<span>0</span>],<span>'INTERSECT'</span>:buffered_amazonas,<span>'OUTPUT'</span>:
    <span>'memory:'</span>}
    )[<span>'OUTPUT'</span>]</pre>
<p>The QGIS GUI contains<a contenteditable="false" data-primary="QGIS GUI" data-secondary="algorithms in" data-type="indexterm" id="idm45433741817360"/> similar tools in the Processing Toolbox functions (<a data-type="xref" href="#algorithms_in_the_qgis_gui">Figure 3-20</a>), but you need to run the processes separately and locate the suitable input and output parameters in output (which will resemble that in <a data-type="xref" href="#the_input_and_output_parameters_buried">Figure 3-21</a>).</p>
<pre data-type="programlisting">
processing.algorithmHelp(<span>"native:extractbylocation"</span>)</pre>
<figure><div class="figure" id="algorithms_in_the_qgis_gui"><img alt="Algorithms in the QGIS GUI" height="576" src="assets/pgda_0320.png" width="1016"/>
<h6><span class="label">Figure 3-20. </span>Algorithms in the QGIS GUI</h6>
</div></figure>
<figure><div class="figure" id="the_input_and_output_parameters_buried"><img alt="The input and output parameters buried in the QGIS GUI output" height="485" src="assets/pgda_0321.png" width="1024"/>
<h6><span class="label">Figure 3-21. </span>The input and output parameters buried in the QGIS GUI output</h6>
</div></figure>
<p>Now<a contenteditable="false" data-primary="QGIS GUI" data-secondary="algorithm input and output parameters in GUI output" data-type="indexterm" id="idm45433741808448"/> that you’ve examined it, go ahead and run the script in the console. <a contenteditable="false" data-primary="parameters for processing algorithms" data-secondary="input and output parameters in QGIS GUI output" data-type="indexterm" id="idm45433741805328"/>The output, shown in <a data-type="xref" href="#the_amazonas_river_with_cities_along_it">Figure 3-22</a>, is a map of cities along the Amazonas river in Brazil. This exercise is an example of how creating algorithms to run on large datasets reinforces efficient and repeatable workflows. Now you can query the data with your own ideas. Use the attribute tables available for each dataset to note how the variables or column headings are listed. Saving your Python scripts will allow you to create templates to practice and update as your curiosity grows!</p>
<figure><div class="figure" id="the_amazonas_river_with_cities_along_it"><img alt="The Amazonas River with cities along its route" height="798" src="assets/pgda_0322.png" width="1518"/>
<h6><span class="label">Figure 3-22. </span>The Amazonas River with cities along its route</h6>
</div></figure>
</div></section>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary-id00016">
<h1>Summary</h1>
<p>This chapter showed you how to download QGIS, customize your workspace, and upload data from different provider keys, both within the Python Console and directly from the Browser. <a contenteditable="false" data-primary="QGIS" data-secondary="using processing algorithms in Python Console" data-startref="ix_QGISprocalg" data-type="indexterm" id="idm45433742568960"/><a contenteditable="false" data-primary="processing algorithms" data-secondary="using in Python Console" data-startref="ix_procalg" data-type="indexterm" id="idm45433741797440"/><a contenteditable="false" data-primary="Python Console in QGIS" data-secondary="using processing algorithms in" data-startref="ix_PyConprcalg" data-type="indexterm" id="idm45433741795984"/>You also learned to customize your maps to increase their legibility and started becoming familiar with the canvas and layer styling. You were introduced to the Processing Tools. These are complex, but splitting the code into small sections and learning about the syntax is often perfect practice for gaining more advanced skills. You learned how to chain three algorithms together and store results in a variable, to be used as input.</p>
<p>In coming chapters, you will continue to build your Python skills by interacting with additional tools like Google Earth Engine and ArcGIS.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="ch01fn8"><sup><a href="ch03.xhtml#ch01fn8-marker">1</a></sup> This workflow is adapted from Anita Graser’s undated blog post <a href="https://oreil.ly/RdQxx">“PyQGIS 101: Chaining Processing Tools”</a>, a tutorial for working with processing tools.</p></div></div></section></div></body></html>