- en: 4 Streamlit's execution model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating apps that require maintaining state between page updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting your apps effectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The all important `st.session_state` and `st.rerun`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streamlit's execution model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the last two chapters, you''ve gotten your feet wet with Streamlit by building
    two fully-functional apps: a password checker and a unit converter. You''ve learned
    the basics of Streamlit''s syntax and how to create interactive elements. But
    what happens behind the scenes when you run a Streamlit app? Understanding this
    is key to building more complex applications.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter delves into the heart of Streamlit's execution model, where we'll
    explore how to manage an app's state.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also takes a slightly different approach than the previous ones.
    While we'll still build a practical application – a daily to-do list app – the
    primary focus is on equipping you with troubleshooting skills. We'll intentionally
    introduce some bugs into the app to simulate real-world situations where things
    might not go according to plan. By following along and fixing these issues, you'll
    gain a deeper understanding of Streamlit's inner workings and how to debug your
    own apps effectively.
  prefs: []
  type: TYPE_NORMAL
- en: '4.1 A more complex app: Daily to-dos'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ever juggled multiple deadlines at work while mentally planning a vacation for
    your family, while *also* trying to remember to buy bread on the way home? Regardless
    of your specific situation, the frenzy of modern life has a way of getting you
    in its grip, pulling you into a whirlwind of endless activity and demands. Hopefully
    this chapter's Streamlit app helps you manage the chaos even if it can't actually
    deliver the bread to your doorstep.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to be making a to-do list app that lets a user track the various
    things they have to get done in a day.
  prefs: []
  type: TYPE_NORMAL
- en: Since the primary point of this chapter is to get you familiar with Streamlit's
    execution model, we won't go through the entire six-step development process in
    detail as we did in the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we'll breeze through the concept, the requirements and a mock design,
    and then jump straight to implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.1 Stating the concept
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you hopefully remember from the last chapter, the concept is a succinct
    statement of what our app is. Here it is for our app:'
  prefs: []
  type: TYPE_NORMAL
- en: Concept
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A Streamlit app that lets users add tasks to a daily to-do list and track their
    status.
  prefs: []
  type: TYPE_NORMAL
- en: That seems pretty crisp and clear, so let's dive into the detailed requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.2 Defining the requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To recap from Chapter 3, while the concept provides a general idea of your app,
    it's your requirements that make it concrete, laying out what the user needs from
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirements for the to-do list app we''re building are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Requirements:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The user should be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: view their daily to-do list, made up of tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: add a task to their to-do list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: remove a task from their list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mark a task in their list as done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: undo marking a task as done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: see their overall task completion status, i.e., their total number of tasks
    and the number they've completed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s just as important, if not even more so, to clarify what our app *won''t*
    do, so let''s specify that as well:'
  prefs: []
  type: TYPE_NORMAL
- en: What's out of scope
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Retrieving a to-do list when the user refreshes or reopens the page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting a to-do list to an external file or format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving the history of added or completed to-dos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The two lists above should give you a sense of what we''re trying to build
    in this chapter: it''s a fairly basic daily to-do list that lives entirely within
    a single browser session.'
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, the way we expect the user to interact with our app is to open
    it in a browser window at the beginning of the day, add their tasks, and mark
    them as done/not done as their day progresses, *keeping the window open until
    the end of the day and never refreshing it*. Rinse and repeat the next day.
  prefs: []
  type: TYPE_NORMAL
- en: We're not going to build the ability to *persist* (or save) any tasks outside
    of the browser session. If you refresh the page, you lose your data.
  prefs: []
  type: TYPE_NORMAL
- en: '*"Doesn''t that limit the usefulness of the app somewhat?"* you might ask.
    Absolutely. It''s just that we don''t want to introduce the complexity of external
    storage just yet. We''ll explore that later on in the book, especially in Part
    2.'
  prefs: []
  type: TYPE_NORMAL
- en: However, one might also argue that giving users a blank slate at the start of
    each day makes them *more* productive. So you see, not being able to save your
    tasks is a *feature*, not a bug!
  prefs: []
  type: TYPE_NORMAL
- en: It's mostly the complexity thing. Still, you should know that spinning the limitations
    of your product into positives is practically a survival skill in the industry!
    I bet your other frontend tech manuals don't also give you free life advice.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.3 Visualizing the user experience
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now know with a fair amount of precision what our app needs to be able to
    do, so with that in mind and keeping with the principle we introduced in the last
    chapter of putting the user experience front and center, let's turn our attention
    to the mock UI design shown in figure 4.1.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 The mock UI design for our daily to-do list app
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Our design has two sections: a sidebar where you can enter new tasks, and a
    "main" area where you can view the tasks you''ve added and update their status.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you add a task by entering the task text and clicking the button on the
    left, it appears on the right. Each task is rendered as a checkbox. You mark a
    task as "done" by checking the box, which also satisfyingly strikes through the
    task. You can delete a task entirely by clicking the button to its right.
  prefs: []
  type: TYPE_NORMAL
- en: There's also a tracker at the top which tells you how many tasks you've completed
    out of the total.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.4 Brainstorming the implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have realized that our to-do list app is somewhat more complex than
    the password checker we built in Chapter 2 or even the unit conversion app in
    Chapter 3\. In both of those cases, there was ultimately a single primary action
    the user could take—to evaluate the entered password in the case of the former,
    and to perform the conversion in the case of the latter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our to-do list has *four* different actions the user can take:'
  prefs: []
  type: TYPE_NORMAL
- en: add a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mark it as done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mark it as not done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: delete it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a moment to brainstorm how we're going to make this happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Central to our implementation is the notion of a *task*, and by extension a
    *task list*. For the purposes of our app, a task is an object with two properties:
    a name, and a status which can be "done" or "not done.” A task list is simply
    an ordered list of tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: The four user actions mentioned above are simply different ways in which you
    can modify the task list; adding a task adds an item to the list, marking it as
    done/not done updates the status of an item in the list, and deleting a task removes
    it from the list.
  prefs: []
  type: TYPE_NORMAL
- en: At every point, the app should show the latest state of the task list to the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can therefore divide our app into three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The task list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions, which are wired up to buttons and checkboxes, and modify the task list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display logic, which renders the task list on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever an action is performed, the task list is modified, and the display
    logic automatically updates what's shown on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 shows what happens when a new task is added; the task is appended
    to the task list, and the display logic loops through all the tasks again and
    renders them on the screen based on a number of rules such as "strikethrough if
    done.”
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image002.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 Adding a task appends an item to the task list and the display logic
    renders the updated task list
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Something very similar happens when a task is checked off, as shown in figure
    4.3\. This time, the status of the task is updated in the task list. Everything
    else goes the same way; the display logic once again loops through every task.
    The "checked if done" and "strikethrough if done" rule are picked up to give the
    completed "Buy bread" task the appearance we want.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image003.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 Checking off a task updates the status of the item in the task list
    and the same display logic re-renders the updated task list
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Deleting a task or un-checking one works pretty much the same way; the task
    list stored in memory is updated and re-rendered by the display logic.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we've identified how we'll represent the key entities in our
    app, and what effect each user action will have. It's now time to implement our
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 Implementing and troubleshooting our app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we built the unit conversion app in Chapter 3, we took the scenic route,
    walking through each step of the app development process in detail. However, there''s
    a part of the process we didn''t really dwell on: what happens when things go
    wrong, and how to troubleshoot the problem. It was a fairly smooth ride.'
  prefs: []
  type: TYPE_NORMAL
- en: This time around, we'll take a bumpier path that you'll find to be more representative
    of the real world. We'll run into various issues and errors as we implement our
    to-do list app. Just as in the real world, these errors will prompt us to learn
    about Streamit in more depth. And we'll use our deeper understanding to power
    through and fix the problems.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Since the focus of this chapter is to give you experience in troubleshooting
    problems with your apps, we'll eschew some of the best practices we learned in
    Chapter 3 ( such as maintaining a strict separation between backend and frontend,
    or defining a clear API), in favor of more concise code.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, spin up a new file in your code editor and name it `todo_list.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.1 Displaying the task list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While we've done our planning up front in one shot, when it comes to writing
    the actual code, we're going to be building our app iteratively as we did in Chapter
    3, going part-by-part and viewing the results in Streamlit along the way.
  prefs: []
  type: TYPE_NORMAL
- en: So where do we start? What's the first iteration?
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in the previous section, the notion of a task list is central to
    our app's implementation. The display logic component of our app always needs
    to show the latest state of the task list.
  prefs: []
  type: TYPE_NORMAL
- en: Our very first step can be as simple as creating the heading for the task list.
  prefs: []
  type: TYPE_NORMAL
- en: st.header
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Streamlit has several different text elements which simply display text in various
    sizes and formatting. We've used `st.title` before to render large titles.
  prefs: []
  type: TYPE_NORMAL
- en: '`st.header` is pretty similar, but it displays text that''s a bit smaller than
    `st.title`.'
  prefs: []
  type: TYPE_NORMAL
- en: Use it by putting the code in Listing 4.1 into `todo_list.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.1 todo_list.py with just a header
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we've included a divider argument, which simply displays a gray
    line beneath your header. Neat, huh?
  prefs: []
  type: TYPE_NORMAL
- en: As always, to see your work in action, save your file and run `streamlit run
    todo_list.py` or `streamlit run <path to frontend.py>` if you're in a different
    working directory.
  prefs: []
  type: TYPE_NORMAL
- en: When your browser window opens, you should see something like figure 4.4.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image004.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 st.header with a divider
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you happen to have multiple headers in your app, you can even cycle between
    divider colors by setting `divider` to `True` instead of a specific color.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a task list
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, let's turn to our notion of a task. As mentioned earlier, a task has a
    name and a done/not-done status.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can therefore use a dataclass to represent a task with exactly those two
    fields: a string `name` and a boolean `is_done` to represent the task status.
    Listing 4.2 shows the `Task` class. Go ahead and save this into a new file called
    `task.py` in the same directory as `todo_list.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.2 task.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the line `is_done: bool = False`. Here, we''re setting `is_done` to
    `False` by default, in case it''s not specified while creating an instance of
    `Task`. This will come in handy momentarily.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a task, our task list is literally a Python list of `Task`
    objects. You can create this in `todo_list.py` with a couple of dummy tasks to
    test it out like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Since we've specified a default value of `False` for `is_done`, there's no need
    to specify it for each instance of `Task`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget to import your `Task` class at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Checkboxes for tasks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Starting out, our display logic can be simple: let''s just display a checkbox
    for each task. We know how to create a static checkbox with a string label; recall
    that we used `st.checkbox` to make a checkbox that rounds the results of our unit
    conversion in Chapter 3.'
  prefs: []
  type: TYPE_NORMAL
- en: But here, we don't know the labels for each checkbox beforehand. Instead we
    have to infer them from `task_list`. How do we do that?
  prefs: []
  type: TYPE_NORMAL
- en: The answer, of course, is a loop. When a Streamlit element is placed in a loop,
    a new element is rendered each time the loop runs. We've actually already encountered
    this in our initial password checker example in Chapter 2, where we used `st.success`
    and `st.error` in a loop to display the green and red boxes that indicated the
    pass/fail status of each condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create checkboxes from our task list like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Recall that the first argument passed to `st.checkbox` is the label (the task's
    name in this case) and the second is a boolean that indicates whether the checkbox
    should be rendered as checked or not. We want each checkbox to be checked if the
    task is done, so it makes sense to pass the task's `is_done` field here directly.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.3 shows what `todo_list.py` should look like at this point.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.3 task.py with checkboxes for each task
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Save and run to get the output shown in figure 4.5
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image005.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 Using st.checkbox in a loop to display one for each task
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Our checkboxes don't actually do anything yet. We'll get to that in a minute,
    but first let's add a "delete" button to each task.
  prefs: []
  type: TYPE_NORMAL
- en: Adding delete buttons
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We want a button to delete each task in the list, situated to its right. Similar
    to how we did it for the checkboxes, we're going to be generating these buttons
    dynamically, so they should go into the loop we wrote earlier.
  prefs: []
  type: TYPE_NORMAL
- en: But if we simply tack on the button inside the loop, Streamlit will put it *under*
    the checkbox for the task, not to the *right* of the task, because Streamlit renders
    elements vertically by default as we saw in Chapter 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, we''ll use `st.columns` to work around this. Here, we''ll make two
    columns—one for the checkbox and task text and another for the button. Go ahead
    and replace your existing `for task in task_list` loop with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we''re calling `st.columns` a little differently from how we did
    in the previous chapter: `st.columns([0.8, 0.2])`. Instead of passing the number
    of columns, we''re passing a list of numbers. This list has the *relative widths*
    of each column. We''re saying that the column with the task should take up 80%
    of the horizontal space and the column with the button should take 20%. If we
    had simply passed the number of columns, i.e., `st.columns(2)`, Streamlit would
    have made the two columns equally wide, which doesn''t make sense because the
    task text can be arbitrarily long, while the button can''t.'
  prefs: []
  type: TYPE_NORMAL
- en: We're not making the button do anything just yet, so we just wrote `pass`, which
    is a keyword in Python that means "do nothing.”
  prefs: []
  type: TYPE_NORMAL
- en: Widget keys
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's go ahead and run our app again to see how it looks. Figure 4.6 depicts
    what you'll likely see.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image006.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 Streamlit throws an error when there are multiple identical widgets
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There's a button to the right of the first task but not the second. Most importantly,
    there's an error message big red box underneath; Streamlit is complaining because
    we tried to create multiple `st.button` widgets with the same *key*.
  prefs: []
  type: TYPE_NORMAL
- en: A key is a piece of text that Streamlit uses to identify a *widget*—essentially
    what we've been calling a Streamlit element, like `st.button`, `st.checkbox` etc.
    Widget keys need to be unique so that Streamlit can distinguish between any two
    widgets.
  prefs: []
  type: TYPE_NORMAL
- en: You don't have to specify the key for a widget in your code manually most of
    the time because Streamlit specifies one internally based on its characteristics.
    For a button, Streamlit's internal key is based on the text in it. So when you
    have two buttons that say "Delete,” their keys are identical, which breaks the
    uniqueness constraint.
  prefs: []
  type: TYPE_NORMAL
- en: The way around this, as the error suggests, is to manually specify a unique
    key for each button we create.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we need a unique delete-button key for every task in our list, one way
    of ensuring a unique key might be to include the list index for the task within
    the key. For instance, the key for the first task''s delete-button could be `delete_0`,
    the key for the second could be `delete_1,` and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Since we need both the index of the task and the task itself, we've changed
    the for-loop's header to `for idx, task in enumerate(task_list)`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`enumerate`, as you may know, is a handy little function in Python that lets
    you iterate through a list in an elegant way, obtaining both the index and the
    element in one shot. The less elegant alternative would have been to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As we discussed, we form each button''s unique key using its index: `key=f"delete_{idx}"`.
    If you run your code now, you should see the error disappear, as shown in figure
    4.7'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image007.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 Passing a unique key to each button allows Streamlit to distinguish
    between otherwise identical buttons
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You may now be wondering, "why didn't we need to pass a key to the checkboxes
    then?"
  prefs: []
  type: TYPE_NORMAL
- en: Well, because the checkboxes already had unique internal keys since their labels
    (the task names) were different. We'll actually face the same issue if we try
    to put two identical tasks in our list. For instance, if we change our task list
    to `task_list = [Task("Buy milk"), Task("Buy milk")]`, we'll see an error similar
    to what we saw for the buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s probably a good idea to let the user enter the same task twice if they
    want to, so let''s fix the problem by passing a unique key to each checkbox as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This lets us have two tasks with the same name if we like without issues.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.2 Enabling actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we've set up our app to display our tasks in roughly the way we want
    them to appear, using dummy tasks to test it. We haven't actually provided a way
    for users to interact with or modify their tasks.
  prefs: []
  type: TYPE_NORMAL
- en: That's what we'll do in this section. We'll start by defining functions that
    update our task list, and then hook them up to Streamlit UI elements.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a task
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To add a task to our task list, we need a task name. Once we have that, adding
    it is as simple as creating a `Task` object and appending it to our list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write this out in a simple `add_task` function in `todo_list.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Marking a task done or not done
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A task''s status is denoted by the `is_done` field of the `Task` instance.
    Therefore, marking it done or not done involves updating this field. Let''s create
    two functions for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that the argument to these functions is the `Task` instance itself, not
    the task name string.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a task
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Deleting a task is also straightforward. For this function, we need the index
    of the task in our list, so we can remove it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Enabling users to add tasks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we now have an `add_task` function, we no longer have to seed our task list
    with dummy tasks. Let''s replace the line `task_list = [Task("Buy milk"), Task("Walk
    the dog")]` with an empty list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll add Streamlit elements to let the user call our `add_task` function.
    We'll need an `st.text_input` for the user to enter the task name, and an `st.button`
    to trigger the addition. We'll wrap both of these in `st.sidebar` so they appear
    in a left-hand-side panel in our app. Again, if any of this sounds unfamiliar,
    you should review Chapter 3.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note the `type="primary"` in `st.button`. The `type` parameter lets you add
    emphasis to a button (in the form of a different color) by denoting that it's
    linked to a "primary action.” In UI design, it's a good idea to have your user's
    eyes be drawn to the actions that they would commonly perform. Here, adding a
    task is something we'd expect the user to do all the time, so using a primary
    button makes sense. If you don't specify this parameter (which we've been doing
    all along until now), it defaults to "secondary,” which—at the time of writing—results
    in a white button.
  prefs: []
  type: TYPE_NORMAL
- en: Note also that we didn't add a widget key to the button because we only have
    one "Add task" button and Streamlit doesn't need any extra help to distinguish
    it from other buttons.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, your `todo_list.py` file should like what's shown in listing
    4.4.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.4 todo_list.py so far
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Save and run your code. To check the result (see figure 4.8), enter a new task
    called "Clean garage" and click "Add task.”
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image008.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 To-do list app with one to-do added
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: So far so good, but when we try adding another task, say "Finalize project proposal,”
    we see the problematic output shown in figure 4.9.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image009.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 When a new task is added, the old one disappears
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We see our new task alright but the old one, "Clean garage,” is gone. Something
    seems wrong, but we don't see an error as we did for the widget key issue.
  prefs: []
  type: TYPE_NORMAL
- en: Oddly, clicking "Delete" removes the remaining task (see figure 4.10), even
    though we didn't actually wire it up to anything; recall that we used `pass` to
    make the button do nothing—something that's commonly referred to as a *no-op.*
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image010.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 Clicking "Delete" removes the task even though we didn't hook it
    up to anything.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The same thing happens if you add a task again and click the checkbox: the
    task just disappears. Feel free to try that out as well.'
  prefs: []
  type: TYPE_NORMAL
- en: What's gone wrong?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Clearly, our app isn't working as we intended. Streamlit doesn't show an error,
    so it's up to us to figure out what's happening. Is our display logic only showing
    the last task added? Or is there something wrong with the task list itself?
  prefs: []
  type: TYPE_NORMAL
- en: Let's find out. One of the most important parts of troubleshooting code is inspecting
    the value of variables while a program is running. In a normal Python script (i.e.,
    one that you would run from the command-line rather than using Streamlit), you
    might include `print` statements to display the value of a variable. You could
    also use your IDE's debugger or the `pdb` module, but let's keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: '`print` statements don''t show up on the browser window of your Streamlit app,
    however. Instead, let''s use an appropriate Streamlit element. We''re interested
    in the `task_list` variable, so go ahead and write the following right under the
    line `st.header("Today''s to-dos:", divider="gray")`, before our display logic
    for-loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`st.info` is an element that displays some text in a colored box. It''s part
    of a family of elements we''ve seen already in Chapter 2: `st.success`, `st.error`,
    and `st.warning`, which also display text in colored boxes. For `st.info`, the
    box is blue.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you save and run (or refresh the page), you''ll see a box with the text
    task_list: [], since there are no tasks yet. Add a task like before and you''ll
    see the output in figure 4.11.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image011.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 task_list contains a single Task instance
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you can see, `task_list` now contains a single instance of `Task`, corresponding
    to "Clean garage.” When we add a second task, our `task_list` variable only has
    the new task. That shows that it's not our display logic that's faulty; the `task_list`
    variable itself has lost the "Clean garage" task. .
  prefs: []
  type: TYPE_NORMAL
- en: When we try either checking the box next to the task or pressing "Delete” `task_list`
    is now empty again, which is why no tasks are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so here''s what we know: adding a task seems to add a task to `task_list`
    correctly, but whenever you do *anything* else afterwards, whether it''s adding
    another task or clicking a checkbox or the "Delete" button, it removes the previously
    added task from `task_list`.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we can fix this, we'll need to understand why this is happening. For
    this, let's review how a Streamlit app actually works.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 How Streamlit executes an app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last two chapters, we've learned how to use Streamlit and even developed
    a couple of non-trivial apps with it. However, we've mostly focused on syntax
    and a surface-level understanding of how apps work.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be successful in writing more complex Streamlit apps, we''ll need to diver
    deeper than that. To go further, we need to talk about something quite fundamental
    to Streamlit: its execution model.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.1 Frontend and server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A Streamlit app actually has two parts: a backend *Streamlit server* and a
    *frontend*.'
  prefs: []
  type: TYPE_NORMAL
- en: A server, for our purposes, is a software program that runs on your computer,
    waiting for requests to be sent to it. In technical terms, we say that a server
    is *listening* at a *port*.
  prefs: []
  type: TYPE_NORMAL
- en: A port is a virtual designation that identifies a particular kind of communication
    channel, kind of like an extension number in a large office. Just as an extension
    allows you to reach a specific person within a company, a port allows network
    communication to reach a specific program running on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you enter `streamlit run <filename.py>` in your terminal, you may have
    noticed output that looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: What's actually happening here is that a Streamlit server starts up and starts
    listening for requests on the port 8502 (the exact port number may differ for
    you).
  prefs: []
  type: TYPE_NORMAL
- en: When you now open a browser and navigate to the given address (i.e., `http://localhost:8502`)
    or just wait until the server automatically does this for you, the browser sends
    a request to the Streamlit server on port 8502.
  prefs: []
  type: TYPE_NORMAL
- en: In response, the Streamlit server executes your Python script from top to bottom
    and sends a message back to the browser, telling it what to display, i.e., the
    frontend.
  prefs: []
  type: TYPE_NORMAL
- en: The frontend is thus the front-facing part of your app that users can see and
    interact with, and it runs on your web browser. It consists of HTML, CSS, and
    Javascript code that your browser understands.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.2 App re-runs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, here''s the important part: the Streamlit server runs your Python script
    in its entirety *every* time the page needs to change. This includes each time
    the user interacts with a widget in your app.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, figure 4.12 details what happens when a user clicks a button in
    your app.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image012.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 Every time the user interacts with the app, the Python script is
    re-run
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once the frontend detects the button-click, it sends a message to the server,
    informing it about the click. The server reacts to this information by re-running
    the Python code, setting the button to evaluate to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: When that's done, the server sends the frontend a message with the changes that
    need to be made to the display. The frontend then makes those changes and the
    user sees the updated display.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this isn't unique to button clicks; it applies for *any* interaction
    or *any* time Streamlit determines the display needs to change. This means that
    every single time the user clicks a button or selects a different item from a
    dropdown or moves a slider, the cycle repeats and the server re-runs your whole
    Python script.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.3 Applying this to our app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's see if we can figure out what's happening in our to-do list app with this
    knowledge of app re-runs.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.5 shows the code as it exists at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.5 todo_list.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We're now going to walk through how this code executes at various points in
    the app's usage.
  prefs: []
  type: TYPE_NORMAL
- en: First run
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The very first time our app runs, i.e., when the user first loads it, `task_list`
    is set to an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider this line within the `st.sidebar` context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is an `if` statement, so the line under it, i.e., `add_task(task)`, will
    only be executed if the `st.button` expression evaluates to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: So far the button hasn't been clicked, so it evaluates to `False` and `add_task`
    is not called. `task_list` is therefore still an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: The code then proceeds to the `st.info` box and display logic, but since there
    are no tasks, `st.info` shows an empty list, and the loop never executes, so there
    are no checkboxes.
  prefs: []
  type: TYPE_NORMAL
- en: User adds a task
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's now say the user has entered a task, "Clean garage,” and clicked the "Add
    task" button. As mentioned earlier, this triggers a re-run of the entire Python
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Technically, a re-run may already have occurred at this point even *before*
    the user clicks the button. When the user has finished entering "Clean garage,”
    if they shift focus outside of the textbox by clicking outside it, that would
    qualify as an interaction (since the value in the textbox has changed) and trigger
    a re-run of the code. This doesn't lead to any interesting changes though, so
    let's ignore it for now.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the top of the script again, `task_list` is set to the empty list.
    Due to the line `task = st.text_input("Enter a task")`, the variable task now
    holds the string "Clean garage" as that's what's in the textbox.
  prefs: []
  type: TYPE_NORMAL
- en: Since the button has just been clicked, `st.button` evaluates to `True`, so
    the `if` statement is triggered and `add_task` is called.
  prefs: []
  type: TYPE_NORMAL
- en: '`add_task` creates a `Task` instance for "Clean garage" and appends it to `task_list`
    so it''s no longer empty. This is what `st.info` shows.'
  prefs: []
  type: TYPE_NORMAL
- en: The display logic loop thus runs once, and proceeds to render a checkbox and
    delete-button. This concludes the re-run, producing the results shown in figure
    4.13.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image011.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 When the user clicks "Add task,” st.button evaluates to True and
    task_list has a task
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: User clicks the task checkbox
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far so good. Everything seems like it's working. But when the user clicks
    the checkbox for "Clean garage,” it triggers another re-run.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we start from the top, where we have the line `task_list = []`,
    which again sets it to the empty list, discarding the "Clean garage" task that
    was in there before!
  prefs: []
  type: TYPE_NORMAL
- en: But let's assume that the *textbox* hasn't been cleared yet, and still says
    "Clean garage.” This means that once the line `task = st.text_input("Enter a task")`
    has been executed, the variable `task` still contains the string "Clean garage.”
  prefs: []
  type: TYPE_NORMAL
- en: What happens when we get to the `st.button` line? The button has been clicked
    before, so does that mean it would evaluate to `True`? If it does, then `add_task`
    would be triggered again, appending "Clean garage" to `task_list`, restoring its
    earlier state, and everything would be fine.
  prefs: []
  type: TYPE_NORMAL
- en: But that's not how `st.button` works. In reality, `st.button` evaluates to `True`
    only in the re-run that happens *immediately* after a click. In all later re-runs,
    it reverts to its original `False` value. In this case, clicking the checkbox
    triggered an all new re-run, so `st.button` now evaluates to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: This means that `add_task` is never called and `task_list` is never updated.
    It remains an empty list, so in turn, the for-loop is never executed and there
    are no displayed tasks.
  prefs: []
  type: TYPE_NORMAL
- en: User adds another task instead of clicking the task checkbox
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just to close out this discussion, let's consider the scenario where, instead
    of clicking the task checkbox, the user tries to add another task (by entering
    "Finalize project proposal" in the task-entry textbox and clicking "Add task").
  prefs: []
  type: TYPE_NORMAL
- en: The execution proceeds similarly in this case. `st_task` is set to the empty
    list at the top, so we lose the previous "Clean garage" task.
  prefs: []
  type: TYPE_NORMAL
- en: Since we entered a new task, the textbox now holds "Finalize project proposal,”
    so that's what the `task` variable holds.
  prefs: []
  type: TYPE_NORMAL
- en: This time, our `st.button` does evaluate to `True` by virtue of our latest button-click,
    and `add_task` is called with "Finalize project proposal" as the value of the
    passed argument. This adds the new `Task` to our otherwise empty list.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of this, `task_list` contains just one element: "Finalize project
    proposal,” which is what''s displayed by `st.info` and our display logic loop,
    as seen in figure 4.14.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image013.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 When the user adds a different task, st.button evaluates to True
    again, and "Finalize project proposal" is added to task_list which was empty at
    the start.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can finally explain the weird results we were seeing. The problem boils down
    to the fact that since our script re-runs each time, `task_list` keeps getting
    reset.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4 Persisting variables across re-runs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last section, we were able to explain the unexpected output we were getting
    by reviewing Streamlit's execution model and stepping through our app's execution
    at various stages with our newfound understanding. In this section, we'll try
    and identify an approach to actually solve the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, our dilemma is that the app we wrote is behaving like a goldfish:
    it has no memory of anything that happened in any previous run. And since Streamlit
    re-runs the entirety of our code every chance it gets, our app''s memory gets
    wiped out repeatedly, resetting the `task_list` variable that we''re using to
    hold the user''s tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.1 st.session_state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As it turns out, Streamlit has a solution for this, in the form of `st.session_state`.
    In a nutshell, `st.session_state` is a container for variables whose values will
    persist across re-runs.
  prefs: []
  type: TYPE_NORMAL
- en: '*Session* here refers to an app session, which you can loosely think about
    as the time between when you open an app and either refresh the page or close
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: When you need to remember a value, you can just save it into `st.session_state`,
    and retrieve that value in the next run, as shown in figure 4.15.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image014.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 st.session_state can be used to save and retrieve values between
    re-runs
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`st.session_state` is thus a rock of stability in an ocean of change. Or if
    you want a more technical metaphor, a store for the variables you want to persist
    across re-runs.'
  prefs: []
  type: TYPE_NORMAL
- en: So how do we actually make use of it? Well, `st.session_state` acts almost exactly
    like a Python dictionary though it technically isn't one. Just as in the case
    of a dictionary, you can add key-value pairs to it, check if a particular key
    exists, look up its value, or remove it altogether. Even the syntax used is identical
    to that of a dictionary for the most part.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if you wanted to store a variable `x` with a value of 5 in `st.session_state`,
    you would write `st.session_state["x"] = 5`, and then retrieve the value using
    `st.session_state["x"]`.
  prefs: []
  type: TYPE_NORMAL
- en: To check if `x` exists in the session state, you would write `if "x" in st.session_state`.
    You can even iterate through the items in `st.session_state` using `for key, value
    in st.session_state.items()`, and delete a key using `del st.session_state`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike a dictionary though, you can also use dot-notation to refer to the value
    of a key `x` like this: `st.session_state.x.`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 4.6 shows a toy Streamlit app using `st.session_state` whose job is
    to simply keep track of and increment a number:'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.6 A simple number-increment app
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We start by checking if the key `"number"` exists in the session state and adding
    it with a value of zero if it doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: Then we have a button that increments the value of "number" each time it's clicked,
    and an `st.info` box to retrieve and display the value of number.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.16 shows the output after pressing the "Increment" button five times.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image015.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16 A toy Streamlit app using st.session_state to keep track of and
    increment a number
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If we hadn't used `st.session_state` here and had simply stored `number` in
    its own variable (or in a regular dictionary), it wouldn't have worked because
    the value (or the dictionary itself) would have gotten reset each time the app
    re-ran. `st.session_state` is the only thing that retains its state across re-runs
    of an app.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need the initial check to see if "number" already exists in the session
    state before adding it? Well, without this, we'd run into the same problem as
    before. Each time the app runs, it would set `st.session_state.number` to zero,
    overriding whatever value it had been incremented to in the earlier run, and we'd
    never see the number actually change.
  prefs: []
  type: TYPE_NORMAL
- en: By checking to see if "number" exists, we're ensuring that the line `st.session_state.number
    = 0` is only executed once—in the very first run when `"number"` hasn't been added
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5 Completing our app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now know how to give our app a "memory.” When you start writing Streamlit
    apps for your own purposes, you'll quickly realize that this knowledge is absolutely
    crucial—to the point that you couldn't write anything but the simplest apps without
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with the powerful `st.session_state`, we're ready to take another crack
    at getting our to-do list app to work!
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.1 Adding session state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we last ran our app, our main problem was the fact that the `task_list`
    variable, which holds all our tasks, was getting reset with every re-run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix this by adding `task_list` to `st.session_state`. Replace the line
    `task_list = []` in your earlier code with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This mirrors the toy example we walked through in the last section. The only
    difference is that we're storing `task_list` in `st.session_state` rather than
    a single number.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could now modify the rest of our code to reference `st.session_state.task_list`
    everywhere it''s currently referencing `task_list`, but that seems tedious and
    rather clunky. Instead, let''s just point the variable `task_list` to the version
    in `st.session_state` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now the rest of our code should work fine since they're referring to `task_list`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.7 shows what our code should contain now.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.7 todo_list.py with st.session_state
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Save, re-run, and try adding multiple tasks. Figure 4.17 shows what you get
    when you do this.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image016.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17 With st.session_state, Streamlit remembers our old tasks
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: And voila! `task_list` can finally be updated with multiple tasks, and our display
    logic shows everything.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.2 Wiring up the "Delete" buttons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With that in place, let's get our "Delete" buttons working. Recall that we had
    previously set them up to do nothing by writing `pass` under the code for the
    buttons within the display loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Since then, we''ve created a `delete_task` function, so let''s call that here
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If we now click “Delete” next to “Buy Bread” after saving and re-running (and
    adding the three tasks back in order if you refreshed the page), we see... no
    changes! If we click the button a second time, however, the task disappears. Something
    still isn’t right.
  prefs: []
  type: TYPE_NORMAL
- en: I won't detail all of it with screenshots, but if you play around with the app
    at this point, you'll notice more odd behavior. The first time you click the "Delete"
    button against the last task in the list, it doesn't do anything. But if you then
    immediately click a checkbox (*any* checkbox), the task disappears.
  prefs: []
  type: TYPE_NORMAL
- en: Or if you delete a task from the middle of the list, the *next* one disappears,
    not the one you deleted! But if you *then* do something else, like clicking a
    checkbox or adding another task, that task comes back and the one you actually
    deleted is correctly removed and everything is the way it should be.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, there seems to be a *lag* between when you actually click the "Delete"
    button and when the task is removed. You seem to need to do something else (anything
    else, like clicking one of the checkboxes, or editing the text in the task entry
    textbox and clicking outside) *after* clicking the button for the correct results
    to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.3 What's happening behind the scenes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To understand what''s going on, we need to do a deep-dive into our app''s execution
    once again. Let''s assume we''re at the stage in the app where the user has entered
    three tasks in order: "Clean garage.” "Finalize project proposal.” and "Buy bread.”'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, `task_list` has been populated with these three tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Stepping through the app's execution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's say the user tries to delete the third task. Figure 4.18 shows diagrammatically
    what happens in the app. The delete buttons are identified by the Streamlit widget
    keys assigned to them, i.e., `delete_0`, `delete_1`, etc.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image017.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.18 Step-by-step app execution: the delete button evaluates to True
    in the second run, but the task and button are displayed *before* delete_task
    is called'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The first run is the one that happens before the button is clicked. Streamlit
    simply loops through our task list, displaying each task along with its checkbox
    and delete button. As we discussed earlier in the chapter, each `st.button` evaluates
    to `False`, since none of them have been pressed yet.
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks the delete button for "Buy bread.” it triggers a re-run
    of the app. Everything remains the same until after we have displayed the third
    task's `st.button`. This time, this button evaluates to `True` since it was just
    clicked. As the condition is true, the app enters the code nested under `st.button`,
    `delete_task(idx)`. Since `idx` is 2 in this iteration of the loop, `delete_task(2)`
    is called, and "Buy bread" is removed from `task_list`. Execution stops at this
    point.
  prefs: []
  type: TYPE_NORMAL
- en: See the problem? All three buttons had *already* been displayed *before* `delete_task`
    was executed, updating `task_list`. And since there are no other user actions,
    no more re-runs are triggered. So `task_list` is updated all right, but the display
    logic has already been executed on the old version of `task_list`. That's why
    we still see the three tasks after clicking "Delete.”
  prefs: []
  type: TYPE_NORMAL
- en: But at this point, if the user does something else, like clicking a checkbox
    or even clicking the "Delete" button again, it triggers another re-run. This time,
    the display logic runs over the latest version of `task_list`, so we finally see
    the third task and its checkbox and delete button removed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Stepping through the execution like this can also explain the other odd behavior
    we noticed, such as when you click the delete button for a task in the middle
    of the list, and the *next* task disappears. This happens because when delete_task
    is called, the list indices all get moved up by one, and the next display loop
    iteration ends up skipping a task because its index changed.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.4 Triggering re-runs automatically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we've seen, though our delete button doesn't work correctly immediately,
    Streamlit does get the results right eventually, provided the user takes an extra
    action, triggering a re-run.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this knowledge to our advantage. All we need is a way to trigger
    a re-run of the app through code, rather than through a user action. Streamlit
    offers this functionality through `st.rerun`, and you can call it at any time
    without any arguments, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When you call `st.rerun`, you're essentially telling Streamlit, "Quit the current
    run and start again from the top."
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we should trigger the re-run once a task has been deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you make this change, re-run and recreate the tasks as before, and try deleting
    "Buy bread" again, you'll see the output in figure 4.19.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image018.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.19 Pressing "Delete" works as expected with st.rerun
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It worked! "Buy bread" is no more, and it's also missing from `task_list` as
    you can see from the `st.info` box in the screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.5 Wiring up the checkboxes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s move on to the next part of our app: the checkboxes. We''ve added them
    in the display and you can check them, but they don''t actually do anything. Our
    next step, then, is to hook them up to the functionality we''ve defined for changing
    the status of a task.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our current checkbox code is a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user checks a task checkbox, we want to achieve two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Mark the task as done, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strike it through
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also want to reverse the above changes if the user unchecks a box.
  prefs: []
  type: TYPE_NORMAL
- en: To change the task's status, we can use the functions we created earlier for
    the purpose, `mark_done` and `mark_not_done`.
  prefs: []
  type: TYPE_NORMAL
- en: How do we achieve the strikethrough? For this formatting effect (and several
    others), Streamlit supports a language called *markdown*.
  prefs: []
  type: TYPE_NORMAL
- en: Markdown is a special text-based notation to add various kinds of formatting.
    It has ways to display text in bold or italic, to create links, lists, headings,
    and much more. We'll encounter these in later chapters, but for now let's focus
    on the strikethrough effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'To strike a piece of text through in markdown, you surround it with two pairs
    of tildes, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This plugs into our checkbox through the label parameter, which supports markdown.
    We''ll define a variable that contains the name of a task by itself if the task
    has not been done, and the name with a markdown strikethrough if it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then feed it into our checkbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let's also wire up our checkboxes to our `mark_*` functions. We want
    to call `mark_done` if the checkbox is checked, or `mark_not_done` otherwise.
    Our overall code should now be as shown in listing 4.8.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.8 todo_list.py after wiring up the task checkboxes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '#A Add a strikethrough effect to the label if the task is done'
  prefs: []
  type: TYPE_NORMAL
- en: '#B Call mark_done if the checkbox happens to be checked and therefore evaluates
    to True'
  prefs: []
  type: TYPE_NORMAL
- en: '#C Call mark_not_done if the checkbox is not checked'
  prefs: []
  type: TYPE_NORMAL
- en: Save, re-run, and add your tasks back, then check one of the tasks to get results
    similar to what's shown in figure 4.20.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image019.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.20 Checking a task doesn't immediately work as expected
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once again, we didn't get the results we expected. "Clean garage" remains unstruck,
    and our info box shows that `task_list` hasn't changed. Before you throw your
    computer out the window and dedicate the rest of your existence to sheep-farming,
    try checking off another task.
  prefs: []
  type: TYPE_NORMAL
- en: You'll see that now the original task we checked has its strikethrough, and
    its `is_done` field is `True` as per our `st.info` box.
  prefs: []
  type: TYPE_NORMAL
- en: Sound familiar? Looks like there's a lag of one user action between when we
    click a checkbox and when the result of that action shows up.
  prefs: []
  type: TYPE_NORMAL
- en: What's going on here is very similar to what we saw in the case of the delete
    button. Clicking the checkbox does trigger our function and sets `is_done` to
    `True`, but by that point, the task and its label have already been displayed.
    Only in the *next* re-run is the *actual display* updated, and that re-run is
    only triggered when the user takes a further action.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this is the same as before: we can trigger a manual re-run
    each time one of our `mark_*` functions runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Save the output, refresh the page, and let's try again. Figure 4.21 shows the
    output.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image020.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.21 Our app hangs and never stops loading
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Something's very wrong here. Our app seems to stop responding entirely once
    we add our first task. The screen's grayed out, and there's the "RUNNING…" indicator
    at the top.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.6 An infinite re-run loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You've just encountered your first Streamlit infinite re-run loop. Let's try
    to understand what went wrong by stepping through the execution one more time.
    Figure 4.22 shows this in a diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image021.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.22 Step-by-step app execution: A chain of st.reruns leads to an infinite
    loop'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once we've added our "Clean garage" task, `task_list` contains a single `Task`
    instance with its `is_done` field set to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Since `task_list` is non-empty, we enter the display loop, and the checkbox
    for "Clean garage" is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now our task has branching logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The checkbox evaluates to `False` since it's not checked, which means the app
    enters the `else` clause.
  prefs: []
  type: TYPE_NORMAL
- en: '`mark_not_done` is called, which sets `is_done` to `False` (even though it''s
    already `False`), and then `st.rerun()` forces Streamit to stop the current run
    and start again from the top.'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, in the second run, we enter the loop. The checkbox is still not
    checked, so `mark_not_done` is called again, and `st.rerun()` after that, which
    begins a third run, and so on and on.
  prefs: []
  type: TYPE_NORMAL
- en: Since this never stops, Streamlit chokes and stops responding.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.7 Preventing the infinite re-run
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The trouble here is that `mark_done` is getting called even when there's no
    need for it. Reviewing the execution steps we saw just now, you'll notice that
    the "Clean garage" task's `is_done` field was already set to `False`, so there
    was no actual need to call `mark_not_done` again.
  prefs: []
  type: TYPE_NORMAL
- en: The way our code is set up right now, once we enter our display for-loop, there's
    no exiting it. If our checkbox evaluates to `True`, `st.rerun()` is called after
    the `mark_done` function. If it evaluates to `False`, `st.rerun()` is called after
    the `mark_not_done` function.
  prefs: []
  type: TYPE_NORMAL
- en: We need to make sure that this only happens when it absolutely needs to. `mark_done`
    (and the associated `st.rerun`) should only be called if the checkbox is checked
    *and* the task is not already marked as "done.” Similarly, `mark_not_done` and
    *its* `st.rerun` should only be called if the checkbox is not checked and the
    task is currently marked as "done.”
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make this happen by editing our code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '#A Save the checkbox''s value in a new variable called checked, for readability.'
  prefs: []
  type: TYPE_NORMAL
- en: '#B Only call mark_done if the checkbox is checked AND the task is not yet marked
    as done.'
  prefs: []
  type: TYPE_NORMAL
- en: '#C Only call mark_not_done if the checkbox is not checked AND the task is still
    marked as done.'
  prefs: []
  type: TYPE_NORMAL
- en: This way, when the checkbox is checked, the task's status is set to `is_done`,
    but in the next re-run, both the if and elif clauses evaluate to `False`, and
    `st.rerun` never executes.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and try it out. Our checkboxes should now be working correctly, as
    shown in figure 4.23.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image022.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.23 Our checkboxes now work as expected
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 4.5.8 Adding the completion progress indicator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We're *almost* done with our app. The only thing that remains from our earlier
    mock design is to add a progress indicator to give the user that extra sense of
    accomplishment.
  prefs: []
  type: TYPE_NORMAL
- en: This is quite straightforward. We want the indicator to be nice and large, so
    `st.metric`, which we encountered first in Chapter 3, seems ideal.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need to show two things: the total number of tasks, and the number of
    completed tasks, both of which we can get from `task_list`. Our code for `st.metric`
    could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: To get `completed_tasks`, we use a list comprehension (you can skip the square
    brackets when it's wrapped in a function like sum) for conciseness.
  prefs: []
  type: TYPE_NORMAL
- en: Oh, and we can probably get rid of our info box (`st.info`) since we're no longer
    in troubleshooting mode.
  prefs: []
  type: TYPE_NORMAL
- en: Our final code should look like what's shown in Listing 4.9.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 4.9 The final version of todo_list.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Figure 4.24 provides a final glance at our app in all its glory.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/04__image023.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.24 The final to-do list app
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: With that, you have another full app under your belt, and maybe even a tool
    you can use every day to stay productive! You're now already in a position to
    start using Streamlit in your own projects. In the next chapter, we'll see how
    to publish them for other people to use.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the real world, the development process is not smooth; much of your time
    will be spent troubleshooting things that don't work as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`st.header` is used to display headings in large font.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streamlit identifies UI widgets using a unique widget key based on its characteristics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When two widgets are identical in every respect, you have to specify a widget
    key manually to enable Streamlit to tell them apart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good way to keep track of the values of variables as the app executes is to
    display them on the app's screen using `st.info`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever the page needs to change, the Streamlit server re-runs your Python
    code from top to bottom.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-runs reset all the regular variables in your app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`st.session_state` is used to store variables that you want Streamlit to remember
    between re-runs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's a good idea to step through the app's execution when you see unexpected
    results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can trigger a re-run of your app using `st.rerun.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While using `st.rerun`, your app may end up in an infinite re-run loop if you
    don't provide a path for your script to exit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
