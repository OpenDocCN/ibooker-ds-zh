<html><head></head><body><section data-pdf-bookmark="Chapter 10. Privacy-Preserving Record Linkage" data-type="chapter" epub:type="chapter"><div class="chapter" id="chapter_10">&#13;
<h1><span class="label">Chapter 10. </span>Privacy-Preserving Record Linkage</h1>&#13;
&#13;
<p>In<a contenteditable="false" data-primary="privacy considerations" data-secondary="privacy preserving record linkage" data-type="indexterm" id="id601"/> previous chapters, we have seen how to resolve entities via exact and probabilistic matching techniques, using both local compute and cloud-based solutions. The first step in these matching processes is to assemble the data sources onto a single platform for comparison. Where the data sources to be resolved share a common owner, or can be freely shared in their entirety for the purposes of matching, then centralized processing is the most efficient approach.</p>&#13;
&#13;
<p>However, data sources can often be sensitive, and privacy considerations may preclude unrestricted sharing with another party. This chapter considers how privacy-preserving record linkage techniques can be used to perform basic entity resolution across data sources held separately by two parties. In particular, we will consider private set intersection as a practical means to identify entities known to both parties without either side disclosing their full dataset to the other.</p>&#13;
&#13;
<section data-pdf-bookmark="An Introduction to Private Set Intersection" data-type="sect1"><div class="sect1" id="id136">&#13;
<h1>An Introduction to Private Set Intersection</h1>&#13;
&#13;
<p>Private set intersection (PSI)<a contenteditable="false" data-primary="privacy considerations" data-secondary="PSI technique" data-type="indexterm" id="id602"/> is a cryptographic technique that allows the intersection between two overlapping sets of information, held by two different parties, to be identified without revealing the nonintersecting elements to either counterparty.</p>&#13;
&#13;
<p>For example, as shown in <a data-type="xref" href="#fig-10-1">Figure 10-1</a>, the intersection between Set A, owned by Alice, and Set B, owned by Bob, can be identified as comprising elements 4 and 5 without revealing Bob’s knowledge of entities 6, 7, or 8 to Alice or Alice’s knowledge of 1, 2, or 3 to Bob.</p>&#13;
&#13;
<figure><div class="figure" id="fig-10-1"><img alt="" class="iimagesch10ch10psipng" src="assets/hoer_1001.png"/>&#13;
<h6><span class="label">Figure 10-1. </span>Private set intersection</h6>&#13;
</div></figure>&#13;
&#13;
<p>Once this intersection is known, we can combine the information held by both Alice and Bob about resolved entities 4 and 5 to allow us to make better decisions about how to handle these entities. This technique is commonly applied in a single direction, say between Alice (acting as a client) and Bob (acting as a server), where Alice learns the intersecting elements but Bob learns nothing about Alice’s dataset.</p>&#13;
&#13;
<div data-type="note" epub:type="note">&#13;
<h1>Example Use Case for PSI</h1>&#13;
&#13;
<p>A<a contenteditable="false" data-primary="privacy considerations" data-secondary="PSI use cases" data-type="indexterm" id="id603"/> financial institution in a privacy jurisdiction might wish to see whether any of its customers are shared with another organization without revealing the identity of its customers. The sharing organization is willing to disclose the individuals they have in common but is not willing to divulge its full customer list.</p>&#13;
</div>&#13;
&#13;
<p>This is the approach we will examine in this chapter, where the sets of information are lists of entities held by both parties, and the client is trying to establish whether the server holds information on an entity in their set without revealing any of their entities in the process. This perhaps sounds like magic, but bear with me!</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="How PSI Works" data-type="sect1"><div class="sect1" id="id76">&#13;
<h1>How PSI Works</h1>&#13;
&#13;
<p>In<a contenteditable="false" data-primary="privacy considerations" data-secondary="how PSI (private set intersection) works" data-type="indexterm" id="id604"/> a client/server setting where the server is happy to share its dataset with the client, the simplest solution for the client to discover the intersection is simply for the server to send a full copy of its dataset to the client, who can then perform the matching process in private. The client learns which matching elements are also held by the server and can build a fuller picture of the common entities while the server learns nothing.</p>&#13;
&#13;
<p>In practice, this full disclosure approach is often not possible, either because the size of the server dataset exceeds the capacity of the client device or because while the server is willing to reveal the existence of, and information describing, the intersecting elements it has in common with the client, it is not willing or permitted to divulge the entire set.</p>&#13;
&#13;
<p>If full sharing from server to client is not possible, then a commonly proposed solution, often referred to as<a contenteditable="false" data-primary="privacy considerations" data-secondary="naive PSI" data-type="indexterm" id="id605"/><a contenteditable="false" data-primary="naive PSI" data-type="indexterm" id="id606"/> <em>naive PSI</em>, is for both parties to apply the same mapping function to each of the elements in their datasets. The server then shares its transformed values with the client who can compare these processed values with their own equivalents to find the intersection and then look up the corresponding original element using the matching client reference as a key. A<a contenteditable="false" data-primary="hash functions" data-type="indexterm" id="id607"/><a contenteditable="false" data-primary="cryptographic hash functions" data-type="indexterm" id="id608"/> <em>cryptographic hash function</em> is often used for this purpose.</p>&#13;
&#13;
<div data-type="note" epub:type="note">&#13;
<h1>Cryptographic Hash Functions</h1>&#13;
&#13;
<p>A<a contenteditable="false" data-primary="privacy considerations" data-secondary="cryptographic hash functions" data-type="indexterm" id="id609"/><a contenteditable="false" data-primary="encryption" data-secondary="cryptographic hash functions" data-type="indexterm" id="id610"/> cryptographic hash function is a hash algorithm (a map of an arbitrary binary string to a binary string of a fixed size). SHA-256 is a commonly used cryptographic hash that generates a 256-bit value, known as a digest.</p>&#13;
</div>&#13;
&#13;
<p>Although efficient, this hash-based approach can potentially be exploited by the client to attempt to discover the full server dataset. One possible attack is for the client to prepare a comprehensive table of original and transformed values, match this inclusive set against all the received server values, and then look up the original values in the table, thereby reconstructing the full server dataset. When a hash function is used to perform the mapping, this precomputed lookup table is called a rainbow table.</p>&#13;
&#13;
<p>For this reason, we will continue our search for a stronger cryptographic solution. Over the years, several different cryptographic techniques have been employed to implement PSI solutions. The first class of algorithms used public key cryptography to secure the exchange so that only the client could decrypt the matching elements and discover the intersection. This approach is highly efficient in the bandwidth required between the client and the server but at the expense of longer runtimes to compute the intersection.</p>&#13;
&#13;
<p>Generic secure computation circuits have also been applied to the PSI problem, as have oblivious transfer techniques. More recently, fully homomorphic encryption schemes have been proposed to enable approximate, as well as exact, matching to take place.</p>&#13;
&#13;
<p>For the purposes of this book, we will consider the original public key technique, proposed by Catherine Meadows in 1986 using the<a contenteditable="false" data-primary="Elliptic Curve Diffie-Hellman (ECDH) protocol" data-type="indexterm" id="id611"/> <em>Elliptic Curve Diffie-Hellman</em> (ECDH) protocol.<sup><a data-type="noteref" href="ch10.html#id612" id="id612-marker">1</a></sup> We won’t delve into the details or the mathematics behind the encryption and decryption process. If you’d like to understand this subject in more detail, I recommend <em>Learning Digital Identity</em> by Phillip J. Windley (O’Reilly) as a good primer.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="PSI Protocol Based on ECDH" data-type="sect1"><div class="sect1" id="id77">&#13;
<h1>PSI Protocol Based on ECDH</h1>&#13;
&#13;
<p>The<a contenteditable="false" data-primary="privacy considerations" data-secondary="PSI protocol based on ECDH" data-type="indexterm" id="PCpsiecdh10"/> basic PSI protocol works like this:</p>&#13;
&#13;
<ol>&#13;
<li><p>The client encrypts its data elements, using a<a contenteditable="false" data-primary="commutative encryption" data-type="indexterm" id="id613"/><a contenteditable="false" data-primary="encryption" data-secondary="commutative encryption" data-type="indexterm" id="id614"/> commutative encryption scheme, with its secret key.</p>&#13;
&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id615">&#13;
<h1>Commutative Encryption</h1>&#13;
&#13;
<p>An encryption algorithm is called commutative if double encryption using two different keys produces a ciphertext that can be correctly decrypted using the keys in arbitrary order.</p>&#13;
</div></aside></li>&#13;
&#13;
<li><p>The client sends the server their encrypted elements. This reveals the number of distinct elements in the client dataset but nothing else to the server.</p></li>&#13;
&#13;
<li><p>The server then further encrypts the client-encrypted values, using a new secret key unique to this request, and sends these values back to the client.</p></li>&#13;
&#13;
<li><p>The client then exploits the commutative properties of the encryption scheme to allow it to decrypt the all-server elements received from the server, effectively removing the original encryption it applied, but leaving the elements encrypted by the server secret key.</p></li>&#13;
&#13;
<li><p>The server encrypts all the elements in its dataset using the same scheme and secret key created for this request and sends the encrypted values to the client.</p></li>&#13;
&#13;
<li><p>The client can then compare the full set of encrypted server elements, received at step 5, with the members of its own set, now encrypted only by the server key from step 4, to determine the intersection.</p></li>&#13;
</ol>&#13;
&#13;
<p>This protocol is shown in <a data-type="xref" href="#fig-10-2">Figure 10-2</a>.</p>&#13;
&#13;
&#13;
&#13;
<p>In its basic form, this protocol means that the entire server dataset is sent to the client, in encrypted form, in response to each client query. This volume of data could be prohibitive, in either compute or space requirements. However, we can employ encoding techniques to drastically reduce the volume of data we have to exchange, at the price of introducing a small percentage of false positives. We will consider two techniques: Bloom filters and Golomb-coded sets (GCSs). Simple examples to illustrate the encoding process are provided in <em>Chapter10GCSBloomExamples.ipynb</em>.</p>&#13;
&#13;
<figure><div class="figure" id="fig-10-2"><img class="iimagesch10ch10psiexchangepng" src="assets/hoer_1002.png"/>&#13;
<h6><span class="label">Figure 10-2. </span>PSI protocol</h6>&#13;
</div></figure>&#13;
&#13;
<section data-pdf-bookmark="Bloom Filters" data-type="sect2"><div class="sect2" id="id78">&#13;
<h2>Bloom Filters</h2>&#13;
&#13;
<p><em>Bloom filters<a contenteditable="false" data-primary="Bloom filters" data-type="indexterm" id="bloomfilter10"/></em> are a probabilistic data structure that can very efficiently store, and allow us to confirm, the presence of a data element in a set. An empty Bloom filter is a bit array whose bits are initialized to 0. To add an item to the filter, the data element is processed by a number of hash functions; the output of each maps to a bit position in the filter, which is then set to 1.</p>&#13;
&#13;
<p>To test whether a new data element is in the set, we simply check whether the bit positions corresponding to its hashed values are all set to 1. If they are, then the new element is probably already present in the set. I say probably because it’s possible that those bits may have been set independently to represent other values, resulting in a false positive. What we can be sure of though is that if any of the bits are not set to 1, then our new element is not present in the set; i.e., there are no false negatives.</p>&#13;
&#13;
<p>The likelihood of a false positive depends on the length of the filter, the number of hash functions, and the number of elements in the dataset. These can be optimized as:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper B l o o m f i l t e r l e n g t h left-parenthesis b i t s right-parenthesis equals left ceiling StartFraction minus m a x normal bar e l e m e n t s times log Subscript 2 Baseline left-parenthesis f p r right-parenthesis Over 8 times ln 2 EndFraction right ceiling times 8">&#13;
  <mrow>&#13;
    <mi>B</mi>&#13;
    <mi>l</mi>&#13;
    <mi>o</mi>&#13;
    <mi>o</mi>&#13;
    <mi>m</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>f</mi>&#13;
    <mi>i</mi>&#13;
    <mi>l</mi>&#13;
    <mi>t</mi>&#13;
    <mi>e</mi>&#13;
    <mi>r</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>l</mi>&#13;
    <mi>e</mi>&#13;
    <mi>n</mi>&#13;
    <mi>g</mi>&#13;
    <mi>t</mi>&#13;
    <mi>h</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>b</mi>&#13;
      <mi>i</mi>&#13;
      <mi>t</mi>&#13;
      <mi>s</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>=</mo>&#13;
    <mrow>&#13;
      <mo>⌈</mo>&#13;
      <mfrac><mrow><mo>-</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>_</mo><mi>e</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>s</mi><mo>×</mo><msub><mo form="prefix">log</mo> <mn>2</mn> </msub><mrow><mo>(</mo><mi>f</mi><mi>p</mi><mi>r</mi><mo>)</mo></mrow></mrow> <mrow><mn>8</mn><mo>×</mo><mo form="prefix">ln</mo><mn>2</mn></mrow></mfrac>&#13;
      <mo>⌉</mo>&#13;
    </mrow>&#13;
    <mo>×</mo>&#13;
    <mn>8</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>where</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="f p r equals f a l s e p o s i t i v e r a t e">&#13;
  <mrow>&#13;
    <mi>f</mi>&#13;
    <mi>p</mi>&#13;
    <mi>r</mi>&#13;
    <mo>=</mo>&#13;
    <mi>f</mi>&#13;
    <mi>a</mi>&#13;
    <mi>l</mi>&#13;
    <mi>s</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>p</mi>&#13;
    <mi>o</mi>&#13;
    <mi>s</mi>&#13;
    <mi>i</mi>&#13;
    <mi>t</mi>&#13;
    <mi>i</mi>&#13;
    <mi>v</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>r</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>e</mi>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="m a x normal bar e l e m e n t s equals max left-parenthesis n u m normal bar c l i e n t normal bar i n p u t s comma n u m normal bar s e r v e r normal bar i n p u t s right-parenthesis">&#13;
  <mrow>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>x</mi>&#13;
    <mo>_</mo>&#13;
    <mi>e</mi>&#13;
    <mi>l</mi>&#13;
    <mi>e</mi>&#13;
    <mi>m</mi>&#13;
    <mi>e</mi>&#13;
    <mi>n</mi>&#13;
    <mi>t</mi>&#13;
    <mi>s</mi>&#13;
    <mo>=</mo>&#13;
    <mo form="prefix" movablelimits="true">max</mo>&#13;
    <mo>(</mo>&#13;
    <mi>n</mi>&#13;
    <mi>u</mi>&#13;
    <mi>m</mi>&#13;
    <mo>_</mo>&#13;
    <mi>c</mi>&#13;
    <mi>l</mi>&#13;
    <mi>i</mi>&#13;
    <mi>e</mi>&#13;
    <mi>n</mi>&#13;
    <mi>t</mi>&#13;
    <mo>_</mo>&#13;
    <mi>i</mi>&#13;
    <mi>n</mi>&#13;
    <mi>p</mi>&#13;
    <mi>u</mi>&#13;
    <mi>t</mi>&#13;
    <mi>s</mi>&#13;
    <mo>,</mo>&#13;
    <mi>n</mi>&#13;
    <mi>u</mi>&#13;
    <mi>m</mi>&#13;
    <mo>_</mo>&#13;
    <mi>s</mi>&#13;
    <mi>e</mi>&#13;
    <mi>r</mi>&#13;
    <mi>v</mi>&#13;
    <mi>e</mi>&#13;
    <mi>r</mi>&#13;
    <mo>_</mo>&#13;
    <mi>i</mi>&#13;
    <mi>n</mi>&#13;
    <mi>p</mi>&#13;
    <mi>u</mi>&#13;
    <mi>t</mi>&#13;
    <mi>s</mi>&#13;
    <mo>)</mo>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>and</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper N u m b e r h a s h f u n c t i o n s equals left ceiling minus log Subscript 2 Baseline left-parenthesis f p r right-parenthesis right ceiling">&#13;
  <mrow>&#13;
    <mi>N</mi>&#13;
    <mi>u</mi>&#13;
    <mi>m</mi>&#13;
    <mi>b</mi>&#13;
    <mi>e</mi>&#13;
    <mi>r</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>h</mi>&#13;
    <mi>a</mi>&#13;
    <mi>s</mi>&#13;
    <mi>h</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>f</mi>&#13;
    <mi>u</mi>&#13;
    <mi>n</mi>&#13;
    <mi>c</mi>&#13;
    <mi>t</mi>&#13;
    <mi>i</mi>&#13;
    <mi>o</mi>&#13;
    <mi>n</mi>&#13;
    <mi>s</mi>&#13;
    <mo>=</mo>&#13;
    <mo>⌈</mo>&#13;
    <mo>-</mo>&#13;
    <msub><mo form="prefix">log</mo> <mn>2</mn> </msub>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>f</mi>&#13;
      <mi>p</mi>&#13;
      <mi>r</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>⌉</mo>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>Using a Bloom filter to encode and return the encrypted server values, as opposed to returning the full set of raw encrypted values, allows us to reduce this set representation to a practical size the client can handle. The client can then apply the same Bloom encoding process to check if any of the elements of its set (encrypted by the server) are present in the filter.</p>&#13;
&#13;
<section data-pdf-bookmark="Bloom filter example" data-type="sect3"><div class="sect3" id="id79">&#13;
<h3>Bloom filter example</h3>&#13;
&#13;
<p>Let’s progressively build a simple Bloom filter to illustrate the process.</p>&#13;
&#13;
<p>Say we incrementally add decimal values 217, 354, and 466 to a Bloom filter of length 32 bits using 4 hash iterations. Suppose the hash iteration is calculated according to the following:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper H a s h Baseline 1 equals upper S upper H upper A Baseline 256 left-parenthesis upper E n c r y p t e d v a l u e p r e f i x e d b y 1 right-parenthesis percent-sign 32">&#13;
  <mrow>&#13;
    <mi>H</mi>&#13;
    <mi>a</mi>&#13;
    <mi>s</mi>&#13;
    <mi>h</mi>&#13;
    <mn>1</mn>&#13;
    <mo>=</mo>&#13;
    <mi>S</mi>&#13;
    <mi>H</mi>&#13;
    <mi>A</mi>&#13;
    <mn>256</mn>&#13;
    <mo>(</mo>&#13;
    <mi>E</mi>&#13;
    <mi>n</mi>&#13;
    <mi>c</mi>&#13;
    <mi>r</mi>&#13;
    <mi>y</mi>&#13;
    <mi>p</mi>&#13;
    <mi>t</mi>&#13;
    <mi>e</mi>&#13;
    <mi>d</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>v</mi>&#13;
    <mi>a</mi>&#13;
    <mi>l</mi>&#13;
    <mi>u</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>p</mi>&#13;
    <mi>r</mi>&#13;
    <mi>e</mi>&#13;
    <mi>f</mi>&#13;
    <mi>i</mi>&#13;
    <mi>x</mi>&#13;
    <mi>e</mi>&#13;
    <mi>d</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>b</mi>&#13;
    <mi>y</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mn>1</mn>&#13;
    <mo>)</mo>&#13;
    <mo>%</mo>&#13;
    <mn>32</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper H a s h Baseline 2 equals upper S upper H upper A Baseline 256 left-parenthesis upper E n c r y p t e d v a l u e p r e f i x e d b y 2 right-parenthesis percent-sign 32">&#13;
  <mrow>&#13;
    <mi>H</mi>&#13;
    <mi>a</mi>&#13;
    <mi>s</mi>&#13;
    <mi>h</mi>&#13;
    <mn>2</mn>&#13;
    <mo>=</mo>&#13;
    <mi>S</mi>&#13;
    <mi>H</mi>&#13;
    <mi>A</mi>&#13;
    <mn>256</mn>&#13;
    <mo>(</mo>&#13;
    <mi>E</mi>&#13;
    <mi>n</mi>&#13;
    <mi>c</mi>&#13;
    <mi>r</mi>&#13;
    <mi>y</mi>&#13;
    <mi>p</mi>&#13;
    <mi>t</mi>&#13;
    <mi>e</mi>&#13;
    <mi>d</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>v</mi>&#13;
    <mi>a</mi>&#13;
    <mi>l</mi>&#13;
    <mi>u</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>p</mi>&#13;
    <mi>r</mi>&#13;
    <mi>e</mi>&#13;
    <mi>f</mi>&#13;
    <mi>i</mi>&#13;
    <mi>x</mi>&#13;
    <mi>e</mi>&#13;
    <mi>d</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>b</mi>&#13;
    <mi>y</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mn>2</mn>&#13;
    <mo>)</mo>&#13;
    <mo>%</mo>&#13;
    <mn>32</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>and</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper H a s h upper V a l u e equals left-parenthesis upper H a s h Baseline 1 plus upper I t e r a t i o n n u m b e r times upper H a s h Baseline 2 right-parenthesis percent-sign 32">&#13;
  <mrow>&#13;
    <mi>H</mi>&#13;
    <mi>a</mi>&#13;
    <mi>s</mi>&#13;
    <mi>h</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>V</mi>&#13;
    <mi>a</mi>&#13;
    <mi>l</mi>&#13;
    <mi>u</mi>&#13;
    <mi>e</mi>&#13;
    <mo>=</mo>&#13;
    <mo>(</mo>&#13;
    <mi>H</mi>&#13;
    <mi>a</mi>&#13;
    <mi>s</mi>&#13;
    <mi>h</mi>&#13;
    <mn>1</mn>&#13;
    <mo>+</mo>&#13;
    <mi>I</mi>&#13;
    <mi>t</mi>&#13;
    <mi>e</mi>&#13;
    <mi>r</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>i</mi>&#13;
    <mi>o</mi>&#13;
    <mi>n</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>n</mi>&#13;
    <mi>u</mi>&#13;
    <mi>m</mi>&#13;
    <mi>b</mi>&#13;
    <mi>e</mi>&#13;
    <mi>r</mi>&#13;
    <mo>×</mo>&#13;
    <mi>H</mi>&#13;
    <mi>a</mi>&#13;
    <mi>s</mi>&#13;
    <mi>h</mi>&#13;
    <mn>2</mn>&#13;
    <mo>)</mo>&#13;
    <mo>%</mo>&#13;
    <mn>32</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>then we progressively build the Bloom filter in <a data-type="xref" href="#table-10-1">Table 10-1</a>.</p>&#13;
&#13;
<table id="table-10-1">&#13;
	<caption><span class="label">Table 10-1. </span>Bloom filter example</caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th scope="col">Encrypted value</th>&#13;
			<th scope="col">Hash iteration</th>&#13;
			<th scope="col">Hash value<br/>&#13;
			(Range<br/>&#13;
			0-31)</th>&#13;
			<th scope="col">Bloom filter<br/>&#13;
			(Positions 0–31, right to left)</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td colspan="3" rowspan="1">Empty filter</td>&#13;
			<td>00000000000000000000000000000000</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td colspan="1" rowspan="4">217</td>&#13;
			<td>0</td>&#13;
			<td>24</td>&#13;
			<td>0000000<strong><u>1</u></strong>000000000000000000000000</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>1</td>&#13;
			<td>19</td>&#13;
			<td>000000010000<strong><u>1</u></strong>0000000000000000000</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>2</td>&#13;
			<td><strong><em>14</em></strong></td>&#13;
			<td>00000001000010000<strong><u>1</u></strong>00000000000000</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>3</td>&#13;
			<td>9</td>&#13;
			<td>0000000100001000010000<strong><u>1</u></strong>000000000</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td colspan="1" rowspan="4">354</td>&#13;
			<td>0</td>&#13;
			<td>5</td>&#13;
			<td>00000001000010000100001000<strong><u>1</u></strong>00000</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>1</td>&#13;
			<td>4</td>&#13;
			<td>000000010000100001000010001<strong><u>1</u></strong>0000</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>2</td>&#13;
			<td>3</td>&#13;
			<td>0000000100001000010000100011<strong><u>1</u></strong>000</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>3</td>&#13;
			<td>2</td>&#13;
			<td>00000001000010000100001000111<strong><u>1</u></strong>00</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td colspan="1" rowspan="4">466</td>&#13;
			<td>0</td>&#13;
			<td><strong><em>14</em></strong></td>&#13;
			<td>00000001000010000<strong><u>1</u></strong>00001000111100</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>1</td>&#13;
			<td>18</td>&#13;
			<td>0000000100001<strong><u>1</u></strong>000100001000111100</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>2</td>&#13;
			<td>22</td>&#13;
			<td>000000010<strong><u>1</u></strong>0011000100001000111100</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>3</td>&#13;
			<td>26</td>&#13;
			<td>00000<strong><u>1</u></strong>01010011000100001000111100</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td colspan="3" rowspan="1">Completed filter</td>&#13;
			<td>00000101010011000100001000111100</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<p>Here we can see a collision where the first hash iteration of the third value sets the bit in position 14 to 1, although it’s already been set to 1 previously by the third iteration of the first value.</p>&#13;
&#13;
<p>Similarly, if all the bit positions corresponding to the hash iterations for a new value were already set to 1, then it would appear that element was in the dataset when in fact it wasn’t. For example, if we want to test if the value decimal 14 is in the server dataset, we compute its hash values as shown in <a data-type="xref" href="#table-10-2">Table 10-2</a>.</p>&#13;
&#13;
<table id="table-10-2">&#13;
	<caption><span class="label">Table 10-2. </span>Bloom filter test</caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th scope="col">Test value</th>&#13;
			<th scope="col">Hash iteration</th>&#13;
			<th scope="col">Hash value<br/>&#13;
			(Range<br/>&#13;
			0–31)</th>&#13;
			<th scope="col">Bloom filter<br/>&#13;
			(Positions 0–31, right to left)</th>&#13;
			<th scope="col">Bit check</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td colspan="3" rowspan="1">Bloom filter</td>&#13;
			<td>00000<strong><u>1</u></strong>010<strong><u>1</u></strong>0011000<strong><u>1</u></strong>00001000111<strong><u>1</u></strong>00</td>&#13;
			<td> </td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td colspan="1" rowspan="5">14</td>&#13;
			<td>0</td>&#13;
			<td>22</td>&#13;
			<td>000000000<strong><u>1</u></strong>0000000000000000000000</td>&#13;
			<td>True</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>1</td>&#13;
			<td>2</td>&#13;
			<td>00000000000000000000000000000<strong><u>1</u></strong>00</td>&#13;
			<td>True</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>2</td>&#13;
			<td><em>14</em></td>&#13;
			<td>00000000000000000<strong><u>1</u></strong>00000000000000</td>&#13;
			<td>True</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>3</td>&#13;
			<td>26</td>&#13;
			<td>00000<strong><u>1</u></strong>00000000000000000000000000</td>&#13;
			<td>True</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<p>From this simple example, we would erroneously conclude that the value 14 is in the server data when it isn’t. Clearly, a longer Bloom filter length is needed.<a contenteditable="false" data-primary="" data-startref="bloomfilter10" data-type="indexterm" id="id616"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Golomb-Coded Sets" data-type="sect2"><div class="sect2" id="id80">&#13;
<h2>Golomb-Coded Sets</h2>&#13;
&#13;
<p><em>Golomb-coded sets</em> (GCS), like<a contenteditable="false" data-primary="Golomb-coded sets (GCS)" data-type="indexterm" id="golset10"/><a contenteditable="false" data-primary="GCS (Golomb-coded sets)" data-type="indexterm" id="gcs10"/> Bloom filters, are a probabilistic data structure that can offer an even more efficient way of encoding the presence of elements in a dataset. To construct a GCS representation of a dataset, we first hash the original data elements into a set of hash values within a set range.</p>&#13;
&#13;
<p>The hash range is calculated as:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="StartFraction upper H a s h r a n g e equals m a x normal bar e l e m e n t s Over f p r EndFraction">&#13;
  <mfrac><mrow><mi>H</mi><mi>a</mi><mi>s</mi><mi>h</mi><mspace width="4pt"/><mi>r</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>e</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>_</mo><mi>e</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>s</mi></mrow> <mrow><mi>f</mi><mi>p</mi><mi>r</mi></mrow></mfrac>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>As before:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="f p r equals f a l s e p o s i t i v e r a t e">&#13;
  <mrow>&#13;
    <mi>f</mi>&#13;
    <mi>p</mi>&#13;
    <mi>r</mi>&#13;
    <mo>=</mo>&#13;
    <mi>f</mi>&#13;
    <mi>a</mi>&#13;
    <mi>l</mi>&#13;
    <mi>s</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>p</mi>&#13;
    <mi>o</mi>&#13;
    <mi>s</mi>&#13;
    <mi>i</mi>&#13;
    <mi>t</mi>&#13;
    <mi>i</mi>&#13;
    <mi>v</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>r</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>e</mi>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="m a x normal bar e l e m e n t s equals max left-parenthesis n u m normal bar c l i e n t normal bar i n p u t s comma n u m normal bar s e r v e r normal bar i n p u t s right-parenthesis">&#13;
  <mrow>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>x</mi>&#13;
    <mo>_</mo>&#13;
    <mi>e</mi>&#13;
    <mi>l</mi>&#13;
    <mi>e</mi>&#13;
    <mi>m</mi>&#13;
    <mi>e</mi>&#13;
    <mi>n</mi>&#13;
    <mi>t</mi>&#13;
    <mi>s</mi>&#13;
    <mo>=</mo>&#13;
    <mo form="prefix" movablelimits="true">max</mo>&#13;
    <mo>(</mo>&#13;
    <mi>n</mi>&#13;
    <mi>u</mi>&#13;
    <mi>m</mi>&#13;
    <mo>_</mo>&#13;
    <mi>c</mi>&#13;
    <mi>l</mi>&#13;
    <mi>i</mi>&#13;
    <mi>e</mi>&#13;
    <mi>n</mi>&#13;
    <mi>t</mi>&#13;
    <mo>_</mo>&#13;
    <mi>i</mi>&#13;
    <mi>n</mi>&#13;
    <mi>p</mi>&#13;
    <mi>u</mi>&#13;
    <mi>t</mi>&#13;
    <mi>s</mi>&#13;
    <mo>,</mo>&#13;
    <mi>n</mi>&#13;
    <mi>u</mi>&#13;
    <mi>m</mi>&#13;
    <mo>_</mo>&#13;
    <mi>s</mi>&#13;
    <mi>e</mi>&#13;
    <mi>r</mi>&#13;
    <mi>v</mi>&#13;
    <mi>e</mi>&#13;
    <mi>r</mi>&#13;
    <mo>_</mo>&#13;
    <mi>i</mi>&#13;
    <mi>n</mi>&#13;
    <mi>p</mi>&#13;
    <mi>u</mi>&#13;
    <mi>t</mi>&#13;
    <mi>s</mi>&#13;
    <mo>)</mo>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>We then sort these hash values in ascending order and calculate a divisor that represents the geometric range of values. If this divisor is chosen to be a power of 2, then this variant is called Rice encoding and can be calculated from the ascending list as:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper G upper C upper S normal bar d i v i s o r normal bar p o w e r normal bar o f normal bar 2 equals max left-parenthesis 0 comma r o u n d left-parenthesis minus l o g 2 left-parenthesis minus l o g 2 left-parenthesis 1.0 minus p r o b right-parenthesis right-parenthesis right-parenthesis">&#13;
  <mrow>&#13;
    <mi>G</mi>&#13;
    <mi>C</mi>&#13;
    <mi>S</mi>&#13;
    <mo>_</mo>&#13;
    <mi>d</mi>&#13;
    <mi>i</mi>&#13;
    <mi>v</mi>&#13;
    <mi>i</mi>&#13;
    <mi>s</mi>&#13;
    <mi>o</mi>&#13;
    <mi>r</mi>&#13;
    <mo>_</mo>&#13;
    <mi>p</mi>&#13;
    <mi>o</mi>&#13;
    <mi>w</mi>&#13;
    <mi>e</mi>&#13;
    <mi>r</mi>&#13;
    <mo>_</mo>&#13;
    <mi>o</mi>&#13;
    <mi>f</mi>&#13;
    <mo>_</mo>&#13;
    <mn>2</mn>&#13;
    <mo>=</mo>&#13;
    <mo form="prefix" movablelimits="true">max</mo>&#13;
    <mo>(</mo>&#13;
    <mn>0</mn>&#13;
    <mo>,</mo>&#13;
    <mi>r</mi>&#13;
    <mi>o</mi>&#13;
    <mi>u</mi>&#13;
    <mi>n</mi>&#13;
    <mi>d</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mo>-</mo>&#13;
      <mi>l</mi>&#13;
      <mi>o</mi>&#13;
      <msub><mi>g</mi> <mn>2</mn> </msub>&#13;
      <mrow>&#13;
        <mo>(</mo>&#13;
        <mo>-</mo>&#13;
        <mi>l</mi>&#13;
        <mi>o</mi>&#13;
        <msub><mi>g</mi> <mn>2</mn> </msub>&#13;
        <mrow>&#13;
          <mo>(</mo>&#13;
          <mn>1</mn>&#13;
          <mo>.</mo>&#13;
          <mn>0</mn>&#13;
          <mo>-</mo>&#13;
          <mi>p</mi>&#13;
          <mi>r</mi>&#13;
          <mi>o</mi>&#13;
          <mi>b</mi>&#13;
          <mo>)</mo>&#13;
        </mrow>&#13;
        <mo>)</mo>&#13;
      </mrow>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>where</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="p r o b equals StartFraction 1 Over a v g EndFraction">&#13;
  <mrow>&#13;
    <mi>p</mi>&#13;
    <mi>r</mi>&#13;
    <mi>o</mi>&#13;
    <mi>b</mi>&#13;
    <mo>=</mo>&#13;
    <mfrac><mn>1</mn> <mrow><mi>a</mi><mi>v</mi><mi>g</mi></mrow></mfrac>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="a v g equals StartFraction left-parenthesis l a s t normal bar e l e m e n t normal bar i n normal bar a s c e n d i n g normal bar l i s t plus 1 right-parenthesis Over n u m b e r normal bar e l e m e n t s normal bar i n normal bar a s c e n d i n g normal bar l i s t EndFraction">&#13;
  <mrow>&#13;
    <mi>a</mi>&#13;
    <mi>v</mi>&#13;
    <mi>g</mi>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>e</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>_</mo><mi>i</mi><mi>n</mi><mo>_</mo><mi>a</mi><mi>s</mi><mi>c</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>_</mo><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow> <mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mo>_</mo><mi>e</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>s</mi><mo>_</mo><mi>i</mi><mi>n</mi><mo>_</mo><mi>a</mi><mi>s</mi><mi>c</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>_</mo><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi></mrow></mfrac>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>Next, we compute the differences between consecutive values, removing any 0-value differences, and divide these delta hash values by 2 to the power of the GCS divisor previously calculated. This division yields a quotient and a remainder. To complete the encoding, we represent the quotient using unary coding and the remainder in binary, padded to the maximum length using 0s.</p>&#13;
&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id617">&#13;
<h5>Unary Coding</h5>&#13;
&#13;
<p>Unary coding<a contenteditable="false" data-primary="unary coding" data-type="indexterm" id="id618"/> represents a natural number as a sequence of 1s (or 0s) whose length is equivalent to the number to be represented, followed by a terminating 0 (or 1). A few examples are shown in <a data-type="xref" href="#table-10-3">Table 10-3</a>.</p>&#13;
&#13;
<table id="table-10-3">&#13;
	<caption><span class="label">Table 10-3. </span>Examples of unary encoding</caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th>Number</th>&#13;
			<th>Unary with 0s</th>&#13;
			<th>Unary with 1s</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td>0</td>&#13;
			<td>1</td>&#13;
			<td>0</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>1</td>&#13;
			<td>01</td>&#13;
			<td>10</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>2</td>&#13;
			<td>001</td>&#13;
			<td>110</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>3</td>&#13;
			<td>0001</td>&#13;
			<td>1110</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<p>For those of us used to looking at binary values, this takes a bit of getting used to.</p>&#13;
</div></aside>&#13;
&#13;
<p>Each element is encoded in this manner and the bits concatenated together to form the GCS structure. To check for a given element in the structure, we scan through the bits, reconstructing each element in turn from the unary quotient and binary remainder, and then progressively sum the difference values we obtain to reconstruct the original hashed values, which we can compare against the hash of our test value.</p>&#13;
&#13;
<p>As with Bloom filters, there is a possibility of a false positive due to a hash collision, the probability of which depends on the size of the hash range and number of elements to be encoded. Again, false negatives aren’t possible.</p>&#13;
&#13;
<p>Let’s consider a short example.</p>&#13;
&#13;
<section data-pdf-bookmark="GCS example" data-type="sect3"><div class="sect3" id="id81">&#13;
<h3>GCS example</h3>&#13;
&#13;
<p>Start with the same encrypted values 217, 354, and 466 and a hash range of decimal 128. We calculate the SHA256 hash for these values (as bytes) and then divide by the hash range to obtain a remainder between 0 and 127. This gives us the values shown in <a data-type="xref" href="#table-10-4">Table 10-4</a>.</p>&#13;
&#13;
<table id="table-10-4">&#13;
	<caption><span class="label">Table 10-4. </span>GCS hash value calculation</caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th>Encrypted value</th>&#13;
			<th>SHA256 hash of encrypted value (hex)</th>&#13;
			<th>Hash value range 0-127</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td>217</td>&#13;
			<td>16badfc6202cb3f8889e0f2779b19218af4cbb736e56acadce8148aba9a7a9f8</td>&#13;
			<td>120</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>354</td>&#13;
			<td>09a1b036b82baba3177d83c27c1f7d0beacaac6de1c5fdcc9680c49f638c5fb9</td>&#13;
			<td>57</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>466</td>&#13;
			<td>826e27285307a923759de350de081d6218a04f4cff82b20c5ddaa8c60138c066</td>&#13;
			<td>102</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<p>Sorting the reduced-range hash values into ascending order we have 57, 102, and 120. The delta values are therefore 57 (57–0), 45 (102–57), and 18 (120–102).</p>&#13;
&#13;
<p>Our divisor power we calculate as:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="a v g equals StartFraction 120 plus 1 Over 3 EndFraction almost-equals 40.33">&#13;
  <mrow>&#13;
    <mi>a</mi>&#13;
    <mi>v</mi>&#13;
    <mi>g</mi>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mn>120</mn><mo>+</mo><mn>1</mn></mrow> <mn>3</mn></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mn>40</mn>&#13;
    <mo>.</mo>&#13;
    <mn>33</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="p r o b equals StartFraction 1 Over 40.33 EndFraction almost-equals 0.02479">&#13;
  <mrow>&#13;
    <mi>p</mi>&#13;
    <mi>r</mi>&#13;
    <mi>o</mi>&#13;
    <mi>b</mi>&#13;
    <mo>=</mo>&#13;
    <mfrac><mn>1</mn> <mrow><mn>40</mn><mo>.</mo><mn>33</mn></mrow></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mn>0</mn>&#13;
    <mo>.</mo>&#13;
    <mn>02479</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper G upper C upper S normal bar d i v i s o r normal bar p o w e r normal bar o f normal bar 2 equals max left-parenthesis 0 comma r o u n d left-parenthesis minus l o g 2 left-parenthesis minus l o g 2 left-parenthesis 1.0 minus 0.02479 right-parenthesis right-parenthesis right-parenthesis equals 5">&#13;
  <mrow>&#13;
    <mi>G</mi>&#13;
    <mi>C</mi>&#13;
    <mi>S</mi>&#13;
    <mo>_</mo>&#13;
    <mi>d</mi>&#13;
    <mi>i</mi>&#13;
    <mi>v</mi>&#13;
    <mi>i</mi>&#13;
    <mi>s</mi>&#13;
    <mi>o</mi>&#13;
    <mi>r</mi>&#13;
    <mo>_</mo>&#13;
    <mi>p</mi>&#13;
    <mi>o</mi>&#13;
    <mi>w</mi>&#13;
    <mi>e</mi>&#13;
    <mi>r</mi>&#13;
    <mo>_</mo>&#13;
    <mi>o</mi>&#13;
    <mi>f</mi>&#13;
    <mo>_</mo>&#13;
    <mn>2</mn>&#13;
    <mo>=</mo>&#13;
    <mo form="prefix" movablelimits="true">max</mo>&#13;
    <mo>(</mo>&#13;
    <mn>0</mn>&#13;
    <mo>,</mo>&#13;
    <mi>r</mi>&#13;
    <mi>o</mi>&#13;
    <mi>u</mi>&#13;
    <mi>n</mi>&#13;
    <mi>d</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mo>-</mo>&#13;
      <mi>l</mi>&#13;
      <mi>o</mi>&#13;
      <msub><mi>g</mi> <mn>2</mn> </msub>&#13;
      <mrow>&#13;
        <mo>(</mo>&#13;
        <mo>-</mo>&#13;
        <mi>l</mi>&#13;
        <mi>o</mi>&#13;
        <msub><mi>g</mi> <mn>2</mn> </msub>&#13;
        <mrow>&#13;
          <mo>(</mo>&#13;
          <mn>1</mn>&#13;
          <mo>.</mo>&#13;
          <mn>0</mn>&#13;
          <mo>-</mo>&#13;
          <mn>0</mn>&#13;
          <mo>.</mo>&#13;
          <mn>02479</mn>&#13;
          <mo>)</mo>&#13;
        </mrow>&#13;
        <mo>)</mo>&#13;
      </mrow>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>=</mo>&#13;
    <mn>5</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>Using a divisor parameter of 32 (<math alttext="2 Superscript 5">&#13;
  <msup><mn>2</mn> <mn>5</mn> </msup>&#13;
</math>), we can encode these values as shown in <a data-type="xref" href="#table-10-5">Table 10-5</a>.</p>&#13;
&#13;
<table id="table-10-5">&#13;
	<caption><span class="label">Table 10-5. </span>GCS binary and unary encoding</caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th scope="col">Delta<br/>&#13;
			hash value<br/>&#13;
			range 0–127</th>&#13;
			<th scope="col">Quotient<br/>&#13;
			(/32)</th>&#13;
			<th scope="col">Remainder<br/>&#13;
			(%32)</th>&#13;
			<th scope="col">Remainder<br/>&#13;
			(binary 5 bits)</th>&#13;
			<th scope="col">Unary quotient<br/>&#13;
			(R to L with 0s)</th>&#13;
			<th scope="col">GCS encoded</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td>57</td>&#13;
			<td>1 </td>&#13;
			<td>25</td>&#13;
			<td>11001</td>&#13;
			<td>10</td>&#13;
			<td>1100110</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>45</td>&#13;
			<td>1</td>&#13;
			<td>13</td>&#13;
			<td>01101</td>&#13;
			<td>10</td>&#13;
			<td>0110110</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>18</td>&#13;
			<td>0</td>&#13;
			<td>18</td>&#13;
			<td>10010</td>&#13;
			<td>1</td>&#13;
			<td>100101</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<p>Together, last to first, left to right, the set is encoded as: 10010101101101100110.<a contenteditable="false" data-primary="" data-startref="golset10" data-type="indexterm" id="id619"/><a contenteditable="false" data-primary="" data-startref="PCpsiecdh10" data-type="indexterm" id="id620"/><a contenteditable="false" data-primary="" data-startref="gcs10" data-type="indexterm" id="id621"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Example: Using the PSI Process" data-type="sect1"><div class="sect1" id="id137">&#13;
<h1>Example: Using the PSI Process</h1>&#13;
&#13;
<p>Now<a contenteditable="false" data-primary="privacy considerations" data-secondary="PSI process example" data-type="indexterm" id="PCexamp10"/> that we understand the basic PSI process, let’s apply it to the challenge of identifying the companies present in the list published by the UK MCA and also present in the Companies House register. If we consider the MCA as the client party and Companies House as the server party, then we can examine how to find those MCA companies that are present on the Companies House register without revealing the contents of the MCA list to Companies House.</p>&#13;
&#13;
<p><em>Please note that this example is for illustration purposes only.</em></p>&#13;
&#13;
<section data-pdf-bookmark="Environment Setup" data-type="sect2"><div class="sect2" id="id138">&#13;
<h2>Environment Setup</h2>&#13;
&#13;
<p>As<a contenteditable="false" data-primary="environment setup" data-secondary="for PSI process" data-secondary-sortas="PSI process" data-type="indexterm" id="id622"/> the PSI process is computationally intensive, we will use Google Cloud to temporarily provide us with the infrastructure to run this example.</p>&#13;
&#13;
<p>In <a data-type="xref" href="ch06.html#chapter_6">Chapter 6</a>, we standardized the MCA and Companies House register datasets and saved them as standardized and cleansed CSV files. In <a data-type="xref" href="ch07.html#chapter_7">Chapter 7</a>, we uploaded these files onto a Google Cloud Storage bucket. For the purposes of this chapter, we will imagine that these datasets are held by two separate parties.</p>&#13;
&#13;
<p>We will transfer these files to a single data science workbench instance on GCP upon which we will run both the server and client to illustrate the intersection process. This example can be easily extended to run on two different machines to illustrate the distinct server and client roles and the separation of data.</p>&#13;
&#13;
<section data-pdf-bookmark="Google Cloud setup" data-type="sect3"><div class="sect3" id="id82">&#13;
<h3>Google Cloud setup</h3>&#13;
&#13;
<p>To<a contenteditable="false" data-primary="Google Cloud Platform (GCP)" data-secondary="environment setup for PSI" data-type="indexterm" id="id623"/><a contenteditable="false" data-primary="Workbench environment" data-type="indexterm" id="id624"/> begin, we select Workbench from the AI Platform menu on the Google Cloud console. To create the environment we select User-Managed Notebooks (as opposed to Managed Notebook) as this option will allow us to install the packages we need.</p>&#13;
&#13;
<p>The first step is to select Create New. From here we can rename the notebook to a name of our choice. Under the Environment section, select the basic Python3 option, then click Create. As in <a data-type="xref" href="ch07.html#chapter_7">Chapter 7</a>, you can change the region and zone settings if you wish or accept the defaults. If (optionally) you select “IAM and security,” you’ll note that root access to the virtual machine will be granted.</p>&#13;
&#13;
<div data-type="warning" epub:type="warning">&#13;
<h1>Costs</h1>&#13;
&#13;
<p>Be<a contenteditable="false" data-primary="Google Cloud Platform (GCP)" data-secondary="fees" data-type="indexterm" id="id625"/> aware that once you create a new Workbench environment, you begin to incur costs, both when the instance is running and disk space costs even when the instance is stopped. By default the Workbench instance creates 2 × 100 GB disks!</p>&#13;
&#13;
<p><em>It is your responsibility to ensure that the instance is stopped and/or deleted to avoid incurring unexpected costs.</em></p>&#13;
</div>&#13;
&#13;
<p>Once your instance is created, you’ll be able to click Open JupyterLab to open a local window to a JupyterLab environment hosted on your new GCP Workbench.<sup><a data-type="noteref" href="ch10.html#id626" id="id626-marker">2</a></sup> From here, we can select Terminal under Other to open a terminal window to configure our environment.</p>&#13;
&#13;
<p>The PSI package we are going to use is released and distributed by the OpenMined community.</p>&#13;
&#13;
<div data-type="note" epub:type="note">&#13;
<h1>OpenMined</h1>&#13;
&#13;
<p>OpenMined<a contenteditable="false" data-primary="OpenMined PSI package" data-type="indexterm" id="id627"/> is an open source community whose goal is to make the world more privacy preserving by lowering the barrier-to-entry to private AI technologies. Their PSI repository provides a Private Set Intersection Cardinality protocol based on ECDH and Bloom filters.</p>&#13;
</div>&#13;
&#13;
<p>At the time of writing, the<a contenteditable="false" data-primary="privacy considerations" data-secondary="OpenMined PSI package" data-type="indexterm" id="id628"/> OpenMined PSI package is available <a href="https://oreil.ly/XaKJs">online</a>. From this site we can download a prebuilt distribution compatible with a Google Cloud Workbench (currently an x86 64-bit virtual machine running Debian 11 OS) that we can readily install (option 1). Alternatively, if you prefer to use a different environment or build the package yourself, you can (option 2).</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Option 1: Prebuilt PSI package" data-type="sect3"><div class="sect3" id="id258">&#13;
<h3>Option 1: Prebuilt PSI package</h3>&#13;
&#13;
<p>Create a PSI directory and switch into this location:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&gt;&gt;&gt;<strong>mkdir psi</strong>&#13;
&#13;
&gt;&gt;&gt;<strong>cd psi</strong></pre>&#13;
&#13;
<p>Copy the link address for the compatible Python distribution and use wget to download. Currently, this would be:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&gt;&gt;&gt;<strong>wget https://files.pythonhosted.org/packages/2b/ac/&#13;
   a62c753f91139597b2baf6fb3207d29bd98a6cf01da918660c8d58a756e8/&#13;
   openmined.psi-2.0.1-cp310-cp310-manylinux_2_31_x86_64.whl</strong></pre>&#13;
&#13;
<p>Install the package as follows:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&gt;&gt;&gt;<strong>pip install openmined.psi-2.0.1-cp310-cp310-&#13;
    manylinux_2_31_x86_64.whl</strong></pre>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Option 2: Build PSI package" data-type="sect3"><div class="sect3" id="id259">&#13;
<h3>Option 2: Build PSI package</h3>&#13;
&#13;
<p>At the terminal prompt we clone the repository for the OpenMined psi package:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&gt;&gt;&gt;<strong>git clone http://github.com/openmined/psi</strong></pre>&#13;
&#13;
<p>Next switch into the psi directory:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&gt;&gt;&gt;<strong>cd psi</strong></pre>&#13;
&#13;
<p>To build the psi package from the repository source we need to install the appropriate version of the build package, Bazel. Use wget to acquire the appropriate prebuilt Debian release package from the GitHub repository:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&gt;&gt;&gt;<strong>wget https://github.com/bazelbuild/bazel/releases/download/&#13;
    6.0.0/bazel_6.0.0-linux-x86_64.deb</strong></pre>&#13;
&#13;
<p>Install this package as root:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&gt;&gt;&gt;<strong>sudo dpkg -i *.deb</strong></pre>&#13;
&#13;
<p>Next we use Bazel to build the Python distribution, a wheel file, with the necessary dependencies. This step may take a few moments:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&gt;&gt;&gt;<strong>bazel build -c opt //private_set_intersection/python:wheel</strong></pre>&#13;
&#13;
<p>Once we have built the wheel archive, then we can use a Python utility provided by OpenMined to rename the file to reflect the environment it supports:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&gt;&gt;&gt;<strong>python ./private_set_intersection/python/rename.py</strong></pre>&#13;
&#13;
<p>The rename utility will output the path and name of the renamed file. We now need to install this newly renamed package from the provided path, for example:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&gt;&gt;&gt;<strong>pip install ./bazel-bin/private_set_intersection/python/&#13;
   openmined.psi-2.0.1-cp310-cp310-manylinux_2_31_x86_64.whl</strong></pre>&#13;
&#13;
<p>Again, this installation may take a few moments but once it’s complete we have the building blocks we need to execute a PSI on our sample problem data.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Server install" data-type="sect3"><div class="sect3" id="id260">&#13;
<h3>Server install</h3>&#13;
&#13;
<p>Once our psi package is installed, one more thing we will need is a basic client/server framework to handle the matching requests. For this purpose we use the Flask lightweight microframework that we can install using pip:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&gt;&gt;&gt;<strong>pip install flask</strong></pre>&#13;
&#13;
<p>Once this install is complete, we can navigate up from the psi directory so that we can copy across our example files:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&gt;&gt;&gt;<strong>cd ..</strong>&#13;
&#13;
&gt;&gt;&gt;<strong>gsutil cp gs://&lt;your bucket&gt;/&lt;your path&gt;/Chapter10* . </strong>&#13;
&gt;&gt;&gt;<strong>gsutil cp gs://&lt;your bucket&gt;/&lt;your path&gt;/mari_clean.csv .</strong>&#13;
&gt;&gt;&gt;<strong>gsutil cp gs://&lt;your bucket&gt;/&lt;your path&gt;/basic_clean.csv .</strong></pre>&#13;
&#13;
<p>To start the flask server and run the <code>Chapter10Server</code> Python script, we use the following at a terminal tab prompt:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&gt;&gt;&gt;<strong>flask --app Chapter10Server run --host 0.0.0.0</strong></pre>&#13;
&#13;
<p>The server will take a few moments to start as it reads in the Companies House dataset and assembles the entities into a list of concatenated <code>CompanyName</code> and <code>Postcode</code> strings.</p>&#13;
&#13;
<p>Once it is ready to process requests, it will display the following at the command prompt:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
* Serving Flask app 'Chapter10Server'&#13;
...&#13;
* Running on http://127.0.0.1:5000&#13;
PRESS CTRL+C to quit</pre>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Server Code" data-type="sect2"><div class="sect2" id="id261">&#13;
<h2>Server Code</h2>&#13;
&#13;
<p>Let’s look at the server code by opening the Python file <em>Chapter10Server.py</em>:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
import private_set_intersection.python as psi&#13;
from flask import Flask, request&#13;
from pandas import read_csv&#13;
&#13;
fpr = 0.01&#13;
num_client_inputs = 100&#13;
&#13;
df_m = read_csv('basic_clean.csv',keep_default_na=False)&#13;
server_items = ['ABLY RESOURCES G2 1PB','ADVANCE GLOBAL RECRUITMENT EH7 4HG']&#13;
#server_items = (df_m['CompanyName']+' '+ df_m['Postcode']).to_list()&#13;
&#13;
app = Flask(__name__)</pre>&#13;
&#13;
<p>We start by importing the PSI package we installed and then the <code>flask</code> and <code>pandas</code> functions we need.</p>&#13;
&#13;
<p>Next, we set the desired false positive rate (<code>fpr</code>) and the number of client inputs we will check in each request. Together these parameters are used to calculate the length of the Bloom filter and hash range used in GCS encoding.</p>&#13;
&#13;
<p>We then read in the cleansed Companies House records that we transferred from our Cloud Storage bucket earlier, specifying that we ignore null values. We then create a list of server items by concatenating each of the <code>CompanyName</code> and <code>Postcode</code> values together, separated by a space. This allows us to check for an exact name and postcode match per entity.</p>&#13;
&#13;
<p>To allow us to examine the encoding protocols in detail using a more manageable server set, I’ve selected two entities from the MCA list and manually created their cleansed name and postcode strings as an alternative set of server items. <em>To use the full Companies House dataset instead, just remove the comment marker (leading <code>#</code>) from the list creation statement to override the <code>server_items</code>:</em></p>&#13;
&#13;
<pre data-type="programlisting">&#13;
#server_items = (df_m['CompanyName']+' '+ df_m['Postcode']).to_list()</pre>&#13;
&#13;
<p>The remainder of the server file defines a class to hold the server key and then creates the <code>key</code> object:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
class psikey(object):&#13;
   def __init__(self):&#13;
      self.key = None&#13;
   def set_key(self, newkey):&#13;
      self.key = newkey&#13;
      return self.key&#13;
   def get_key(self):&#13;
      return self.key&#13;
&#13;
pkey = psikey()</pre>&#13;
&#13;
<p>The Flask web application allows us to respond to both GET and POST requests.</p>&#13;
&#13;
<p>The server responds to a POST request to the <code>/match</code> path by creating a new server key and a <code>psirequest</code> object. We then parse the data within the POST request, process (i.e., encrypt) the received data using the new key and then serialize these processed values before returning them to the client:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
@app.route('/match', methods=['POST'])&#13;
def match():&#13;
   s = pkey.set_key(psi.server.CreateWithNewKey(True))&#13;
   psirequest = psi.Request()&#13;
   psirequest.ParseFromString(request.data)&#13;
   return s.ProcessRequest(psirequest).SerializeToString()</pre>&#13;
&#13;
<p>After a match request has been processed, the server can then respond to client GET requests for the different encoding schemes: raw encrypted values, Bloom filter, and GCS. In each case, we reuse the key created during the match request and we supply the desired false positive rate and number of items in each client request so that we can configure the Bloom and GCS options:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
@app.route('/gcssetup', methods=['GET'])&#13;
def gcssetup():&#13;
   s = pkey.get_key()&#13;
   return s.CreateSetupMessage(fpr, num_client_inputs, server_items,&#13;
      psi.DataStructure.GCS).SerializeToString()&#13;
&#13;
@app.route('/rawsetup', methods=['GET'])&#13;
def rawsetup():&#13;
   s = pkey.get_key()&#13;
   return s.CreateSetupMessage(fpr, num_client_inputs, server_items,&#13;
      psi.DataStructure.RAW).SerializeToString()&#13;
&#13;
@app.route('/bloomsetup', methods=['GET'])&#13;
def bloomsetup():&#13;
   s = pkey.get_key()&#13;
   return s.CreateSetupMessage(fpr, num_client_inputs, server_items,&#13;
      psi.DataStructure.BLOOM_FILTER).SerializeToString()</pre>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Client Code" data-type="sect2"><div class="sect2" id="id262">&#13;
<h2>Client Code</h2>&#13;
&#13;
<p>The notebook containing the client code is <em>Chapter10Client.ipynb</em>, beginning:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
import requests&#13;
import private_set_intersection.python as psi&#13;
from pandas import read_csv&#13;
&#13;
url="http://localhost:5000/"</pre>&#13;
&#13;
<p>As with the server setup, we read in the cleansed MCA company details, create a client key, encrypt, and then serialize for transmission to the server.</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
df_m = read_csv('mari_clean.csv')&#13;
client_items = (df_m['CompanyName']+' '+df_m['Postcode']).to_list()&#13;
c = psi.client.CreateWithNewKey(True)&#13;
psirequest = c.CreateRequest(client_items).SerializeToString()&#13;
&#13;
c.CreateRequest(client_items)</pre>&#13;
&#13;
<p>Prior to serialization, the first few lines of the <code>psirequest</code> look like:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
reveal_intersection: true&#13;
encrypted_elements: &#13;
    "\002r\022JjD\303\210*\354\027\267aRId\2522\213\304\250%\005J\224\222m\354\&#13;
    207`\2136\306"&#13;
encrypted_elements: &#13;
    "\002\005\352\245r\343n\325\277\026\026\355V\007P\260\313b\377\016\000{\336\&#13;
    343\033&amp;\217o\210\263\255[\350"</pre>&#13;
&#13;
<p>We include the serialized encrypted values as message content in a POST request to the <code>/match</code> URL path, indicating in the header that the content we are passing is a protobuf structure. The server response, containing the server-encrypted versions of the client encrypted values, is then parsed into a <code>response</code> object:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
response = requests.post(url+'match',&#13;
    headers={'Content-Type': 'application/protobuf'}, data=psirequest)&#13;
psiresponse = psi.Response()&#13;
psiresponse.ParseFromString(response.content)&#13;
psiresponse</pre>&#13;
&#13;
<section data-pdf-bookmark="Using raw encrypted server values" data-type="sect3"><div class="sect3" id="id263">&#13;
<h3>Using raw encrypted server values</h3>&#13;
&#13;
<p>To retrieve the raw encrypted server values, the client sends a request to the <code>/rawsetup</code> URL path:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
setupresponse = requests.get(url+'rawsetup')&#13;
rawsetup = psi.ServerSetup()&#13;
rawsetup.ParseFromString(setupresponse.content)&#13;
rawsetup</pre>&#13;
&#13;
<p>If we have selected to use just the two test entries in the server setup file, then we can expect only two encrypted elements in the setup response. The values will depend on the server key, but the structure will look something like this:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
raw {&#13;
  encrypted_elements: &#13;
      "\003&gt;W.x+\354\310\246\302z\341\364%\255\202\354\021n\t\211\037\221\255\&#13;
      263\006\305NU\345.\243@"&#13;
  encrypted_elements: &#13;
      "\003\304Q\373\224.\0348\025\3452\323\024\317l~\220\020\311A\257\002\&#13;
      014J0?\274$\031`N\035\277"&#13;
}</pre>&#13;
&#13;
<p>We can then calculate the intersection from the server values in the <code>rawsetup</code> structure and the <code>client</code> values in the <code>psiresponse</code> structure:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
intersection = c.GetIntersection(gcssetup, psiresponse)&#13;
#intersection = c.GetIntersection(bloomsetup, psiresponse)&#13;
#intersection = c.GetIntersection(rawsetup, psiresponse)&#13;
&#13;
iset = set(intersection)&#13;
sorted(intersection)</pre>&#13;
&#13;
<p>This gives us the list index of the matching entities, in this simple case:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
[1, 2]</pre>&#13;
&#13;
<p>We can then look up the corresponding client entities:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
for index in sorted(intersection):&#13;
   print(client_items[index])&#13;
&#13;
ABLY RESOURCES G2 1PB&#13;
ADVANCE GLOBAL RECRUITMENT EH7 4HG</pre>&#13;
&#13;
<p>Success! We have resolved these entities between the client and server records, exact-matching <code>CompanyName</code> and <code>Postcode</code> attributes, without revealing the client items to the server.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Using Bloom filter–encoded encrypted server values" data-type="sect3"><div class="sect3" id="id83">&#13;
<h3>Using Bloom filter–encoded encrypted server values</h3>&#13;
&#13;
<p>Now<a contenteditable="false" data-primary="Bloom filters" data-type="indexterm" id="id629"/> let’s examine how we would use a Bloom filter to encode the set of server encrypted values:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
setupresponse = requests.get(url+'bloomsetup')&#13;
bloomsetup = psi.ServerSetup()&#13;
bloomsetup.ParseFromString(setupresponse.content)&#13;
bloomsetup</pre>&#13;
&#13;
<p class="pagebreak-before">If we submit a request via the <code>/bloomsetup</code> path, we get an output that looks like:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
bloom_filter {&#13;
  num_hash_functions: 14&#13;
  bits: "\000\000\000\000 ...\000"&#13;
}</pre>&#13;
&#13;
<p>The server calculates the number of bits in the filter according to the formula in the Bloom filters section. We can re-create this as:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
from math import ceil, log, log2&#13;
	&#13;
fpr = 0.01&#13;
num_client_inputs = 10&#13;
&#13;
correctedfpr = fpr / num_client_inputs&#13;
len_server_items = 2&#13;
&#13;
max_elements = max(num_client_inputs, len_server_items)&#13;
num_bits = (ceil(-max_elements * log2(correctedfpr) / log(2) /8))* 8</pre>&#13;
&#13;
<p>The false positive rate is set at 1 in 100 per query with a batch size of 100 client items to check at a time, giving an overall (corrected) fpr of 0.0001. For our very basic example, <code>max_elements</code> is also equal to 100. This gives us a Bloom filter bit length of 1920:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
num_hash_functions = ceil(-log2(correctedfpr))</pre>&#13;
&#13;
<p>This gives us 14 hash functions.</p>&#13;
&#13;
<p>We can reproduce the Bloom filter by processing the raw encrypted server elements:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
from hashlib import sha256&#13;
&#13;
#num_bits = len(bloomsetup.bloom_filter.bits)*8&#13;
filterlist = ['0'] * num_bits&#13;
for element in rawsetup.raw.encrypted_elements:&#13;
   element1 = str.encode('1') + element&#13;
   k = sha256(element1).hexdigest()&#13;
   h1 = int(k,16) % num_bits&#13;
&#13;
   element2 = str.encode('2') + element&#13;
   k = sha256(element2).hexdigest()&#13;
   h2 = int(k,16) % num_bits&#13;
&#13;
  for i in range(bloomsetup.bloom_filter.num_hash_functions):&#13;
      pos = ((h1 + i * h2) % num_bits)&#13;
      filterlist[num_bits-1-pos]='1'&#13;
&#13;
filterstring = ''.join(filterlist)</pre>&#13;
&#13;
<p class="pagebreak-before">Then we can compare our filter against the filter bits returned by the server when assembled in the same order and converted to a string:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
bloombits = ''.join(format(byte, '08b') for byte in&#13;
   reversed(bloomsetup.bloom_filter.bits))&#13;
bloombits == filterstring</pre>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Using GCS-encoded encrypted server values" data-type="sect3"><div class="sect3" id="id84">&#13;
<h3>Using GCS-encoded encrypted server values</h3>&#13;
&#13;
<p>Finally, let’s examine how we would use<a contenteditable="false" data-primary="GCS (Golomb-coded sets)" data-type="indexterm" id="id630"/><a contenteditable="false" data-primary="Golomb-coded sets (GCS)" data-type="indexterm" id="id631"/> GCS to encode the set of server-encrypted values.</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
setupresponse = requests.get(url+'gcssetup')&#13;
gcssetup =&#13;
   psi.ServerSetup()gcssetup.ParseFromString(setupresponse.content)</pre>&#13;
&#13;
<p>If we submit a request via the <code>/gcssetup</code> path, we get an output that looks like:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
gcs {&#13;
  div: 17&#13;
  hash_range: 1000000&#13;
  bits: ")![Q\026"&#13;
}</pre>&#13;
&#13;
<p>To reproduce these values, we can apply the formulas in the preceding PSI section:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
from math import ceil, log, log2&#13;
&#13;
fpr = 0.01&#13;
num_client_inputs = 100&#13;
correctedfpr = fpr/num_client_inputs&#13;
&#13;
hash_range = max_elements/correctedfpr&#13;
hash_range</pre>&#13;
&#13;
<p>This gives us the hash range of 1000000.</p>&#13;
&#13;
<p>As with Bloom filter, we can reproduce the GCS structure by processing the raw encrypted server elements. First, we hash the raw encrypted server values into the <code>gcs_hash_range</code>, sort in ascending order, and calculate the differences:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
from hashlib import sha256&#13;
	&#13;
ulist = []&#13;
for element in rawsetup.raw.encrypted_elements:&#13;
   k = sha256(element).hexdigest()&#13;
   ks = int(k,16) % gcssetup.gcs.hash_range&#13;
   ulist.append(ks)&#13;
&#13;
ulist.sort()&#13;
udiff = [ulist[0]] + [ulist[n]-ulist[n-1]&#13;
   for n in range(1,len(ulist))]</pre>&#13;
&#13;
<p class="pagebreak-before">Now we can calculate the GCS divisor as:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
avg = (ulist[-1]+1)/len(ulist)&#13;
prob = 1/avg&#13;
gcsdiv = max(0,round(-log2(-log2(1.0-prob))))</pre>&#13;
&#13;
<p>This gives us a divisor of 17, which we can then use to calculate the quotient and remainder before we encode these in unary and binary, respectively. We concatenate these bit patterns together:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
encoded = ''&#13;
for diff in udiff:&#13;
   if diff != 0:&#13;
      quot = int(diff / pow(2,gcssetup.gcs.div))&#13;
      rem = diff % pow(2,gcssetup.gcs.div)&#13;
&#13;
      next = '{0:b}'.format(rem) + '1' + ('0' * quot)&#13;
      pad = next.zfill(quot+gcssetup.gcs.div+1)&#13;
      encoded = pad + encoded</pre>&#13;
&#13;
<p>Finally, we pad out the encoded string to be a multiple of 8 so that we can match against the returned GCS bits:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
from math import ceil&#13;
padlength = ceil(len(encoded)/8)*8&#13;
padded = encoded.zfill(padlength)&#13;
&#13;
gcsbits = ''.join(format(byte, '08b') for byte in&#13;
   reversed(gcssetup.gcs.bits))&#13;
gcsbits == padded</pre>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Full MCA and Companies House Sample Example" data-type="sect2"><div class="sect2" id="id85">&#13;
<h2>Full MCA and Companies House Sample Example</h2>&#13;
&#13;
<p>Now that we have seen the end-to-end PSI entity matching process using a tiny server dataset of only two items, we’re ready to use the full Companies House dataset.</p>&#13;
&#13;
<p>Open the <em>Chapter10Server.py</em> file and uncomment:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
#server_items = (df_m['CompanyName']+' '+&#13;
   df_m['Postcode']).to_list()</pre>&#13;
&#13;
<p>and then stop (Ctrl+C or Cmd-C) and restart the Flask server:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&gt;&gt;&gt;<strong>flask --app Chapter10Server run --host 0.0.0.0</strong></pre>&#13;
&#13;
<p>Now we can restart the client kernel and rerun the notebook to get the full intersection between the MCA and Companies House data, resolving the entities on <code>CompanyName</code> and <code>Postcode</code>.</p>&#13;
&#13;
<p>We can request either a raw, Bloom, or GCS response. Allow approximately 10 minutes for the server to process and return. <em>I suggest you skip over the steps to reproduce the Bloom/GCS structures as these could take quite a while</em>.</p>&#13;
&#13;
<p>Jumping to calculate the intersection then gives us 45 exact matches:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
ADVANCE GLOBAL RECRUITMENT EH7 4HG&#13;
ADVANCED RESOURCE MANAGERS PO6 4PR&#13;
...&#13;
&#13;
WORLDWIDE RECRUITMENT SOLUTIONS WA15 8AB</pre>&#13;
&#13;
<div data-type="warning" epub:type="warning">&#13;
<h1>Tidy Up</h1>&#13;
&#13;
<p>Remember to stop and delete your User-Managed Notebook and any associated disks to avoid ongoing charges!</p>&#13;
</div>&#13;
&#13;
<p>This PSI example has shown how we can resolve entities between two parties even if one party cannot share their data with the other. In this basic example, we have been able to look for simultaneous exact matches on only two attributes.</p>&#13;
&#13;
<p>In certain situations, exact matching may be sufficient. However, when approximate matching is needed, and at least one party is prepared to share partial matches, we need a more sophisticated approach that is beyond the scope of this book. There is ongoing research into the practicality of using fully<a contenteditable="false" data-primary="homomorphic encryption" data-type="indexterm" id="id632"/><a contenteditable="false" data-primary="encryption" data-secondary="homomorphic encryption" data-type="indexterm" id="id633"/> homomorphic encryption to enable privacy-preserving<a contenteditable="false" data-primary="matching" data-secondary="fuzzy matching" data-type="indexterm" id="id634"/><a contenteditable="false" data-primary="fuzzy matching" data-type="indexterm" id="id635"/> fuzzy matching, which would open up a wider field of potential use cases for this<a contenteditable="false" data-primary="" data-startref="PCexamp10" data-type="indexterm" id="id636"/> technique.<sup><a data-type="noteref" href="ch10.html#id637" id="id637-marker">3</a></sup></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="id86">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter we learned how to use Private Set Intersection to resolve entities between two parties without either party revealing their full dataset. We saw how to use compressed data representations to reduce the volume of data we needed to pass between the two parties at the price of introducing a small percentage of false positives.</p>&#13;
&#13;
<p>We noted that these techniques can be readily applied to exact matching scenarios but that more advanced<a contenteditable="false" data-primary="approximate (fuzzy) matching techniques" data-type="indexterm" id="id638"/> approximate or<a contenteditable="false" data-primary="probabilistic matching" data-secondary="privacy challenges" data-type="indexterm" id="id639"/> probabilistic matching remains a challenge and a subject of active research.</p>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="id612"><sup><a href="ch10.html#id612-marker">1</a></sup> Meadows, Catherine, “A More Efficient Cryptographic Matchmaking Protocol for Use in the Absence of a Continuously Available Third Party,” <em>1986 IEEE Symposium on Security and Privacy</em>, Oakland, CA, USA, 1986, pp. 134, <em>https://doi.org/10.1109/SP.1986.10022</em>.</p><p data-type="footnote" id="id626"><sup><a href="ch10.html#id626-marker">2</a></sup> You may need to allow pop-ups on your local browser.</p><p data-type="footnote" id="id637"><sup><a href="ch10.html#id637-marker">3</a></sup> See the patent “Compact fuzzy private matching using a fully-homomorphic encryption scheme,” <a href="https://patents.google.com/patent/US20160119119"><em>https://patents.google.com/patent/US20160119119</em></a>.</p></div></div></section></body></html>