<html><head></head><body><section data-pdf-bookmark="Chapter 10. Working with Data" data-type="chapter" epub:type="chapter"><div class="chapter" id="working_with_data">&#13;
<h1><span class="label">Chapter 10. </span>Working with Data</h1>&#13;
&#13;
<blockquote data-type="epigraph" epub:type="epigraph">&#13;
    <p>Experts often possess more data than judgment.</p>&#13;
    <p data-type="attribution">Colin Powell</p>&#13;
</blockquote>&#13;
&#13;
<p>Working with data is both an art and a science.  We’ve mostly been talking about the science part, but in this chapter we’ll look at some of the art.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exploring Your Data" data-type="sect1"><div class="sect1" id="exploring_your_data">&#13;
<h1>Exploring Your Data</h1>&#13;
&#13;
<p>After<a data-primary="data" data-secondary="working with" data-tertiary="exploring your data" data-type="indexterm" id="DWexpl10"/> you’ve identified the questions you’re trying to answer and have gotten&#13;
your hands on some data, you might be tempted to dive in and immediately start&#13;
building models and getting answers.  But you should resist this urge.&#13;
Your first step should be to <em>explore</em> your data.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exploring One-Dimensional Data" data-type="sect2"><div class="sect2" id="idm45635748067992">&#13;
<h2>Exploring One-Dimensional Data</h2>&#13;
&#13;
<p>The simplest case is when you have a<a data-primary="one-dimensional datasets" data-type="indexterm" id="idm45635748066168"/> one-dimensional dataset, which is just a collection of numbers.  For example, these could be the daily average number of minutes each user spends on your site,&#13;
the number of times each of a collection of data science tutorial videos was watched,&#13;
or the number of pages of each of the data science books in your data science library.</p>&#13;
&#13;
<p>An obvious first step is to compute a few summary statistics.  You’d like to know how many data points you have, the smallest, the largest, the mean, and the standard deviation.</p>&#13;
&#13;
<p>But even these don’t necessarily give you a great understanding.  A good next step is to create a histogram, in which you group your data into discrete <em>buckets</em> and count how many points fall into each bucket:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">List</code><code class="p">,</code> <code class="n">Dict</code>&#13;
<code class="kn">from</code> <code class="nn">collections</code> <code class="kn">import</code> <code class="n">Counter</code>&#13;
<code class="kn">import</code> <code class="nn">math</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">matplotlib.pyplot</code> <code class="kn">as</code> <code class="nn">plt</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">bucketize</code><code class="p">(</code><code class="n">point</code><code class="p">:</code> <code class="nb">float</code><code class="p">,</code> <code class="n">bucket_size</code><code class="p">:</code> <code class="nb">float</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">float</code><code class="p">:</code>&#13;
    <code class="sd">"""Floor the point to the next lower multiple of bucket_size"""</code>&#13;
    <code class="k">return</code> <code class="n">bucket_size</code> <code class="o">*</code> <code class="n">math</code><code class="o">.</code><code class="n">floor</code><code class="p">(</code><code class="n">point</code> <code class="o">/</code> <code class="n">bucket_size</code><code class="p">)</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">make_histogram</code><code class="p">(</code><code class="n">points</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="nb">float</code><code class="p">],</code> <code class="n">bucket_size</code><code class="p">:</code> <code class="nb">float</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Dict</code><code class="p">[</code><code class="nb">float</code><code class="p">,</code> <code class="nb">int</code><code class="p">]:</code>&#13;
    <code class="sd">"""Buckets the points and counts how many in each bucket"""</code>&#13;
    <code class="k">return</code> <code class="n">Counter</code><code class="p">(</code><code class="n">bucketize</code><code class="p">(</code><code class="n">point</code><code class="p">,</code> <code class="n">bucket_size</code><code class="p">)</code> <code class="k">for</code> <code class="n">point</code> <code class="ow">in</code> <code class="n">points</code><code class="p">)</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">plot_histogram</code><code class="p">(</code><code class="n">points</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="nb">float</code><code class="p">],</code> <code class="n">bucket_size</code><code class="p">:</code> <code class="nb">float</code><code class="p">,</code> <code class="n">title</code><code class="p">:</code> <code class="nb">str</code> <code class="o">=</code> <code class="s2">""</code><code class="p">):</code>&#13;
    <code class="n">histogram</code> <code class="o">=</code> <code class="n">make_histogram</code><code class="p">(</code><code class="n">points</code><code class="p">,</code> <code class="n">bucket_size</code><code class="p">)</code>&#13;
    <code class="n">plt</code><code class="o">.</code><code class="n">bar</code><code class="p">(</code><code class="n">histogram</code><code class="o">.</code><code class="n">keys</code><code class="p">(),</code> <code class="n">histogram</code><code class="o">.</code><code class="n">values</code><code class="p">(),</code> <code class="n">width</code><code class="o">=</code><code class="n">bucket_size</code><code class="p">)</code>&#13;
    <code class="n">plt</code><code class="o">.</code><code class="n">title</code><code class="p">(</code><code class="n">title</code><code class="p">)</code></pre>&#13;
&#13;
<p>For example, consider the two following sets of data:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">import</code> <code class="nn">random</code>&#13;
<code class="kn">from</code> <code class="nn">scratch.probability</code> <code class="kn">import</code> <code class="n">inverse_normal_cdf</code>&#13;
&#13;
<code class="n">random</code><code class="o">.</code><code class="n">seed</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>&#13;
&#13;
<code class="c1"># uniform between -100 and 100</code>&#13;
<code class="n">uniform</code> <code class="o">=</code> <code class="p">[</code><code class="mi">200</code> <code class="o">*</code> <code class="n">random</code><code class="o">.</code><code class="n">random</code><code class="p">()</code> <code class="o">-</code> <code class="mi">100</code> <code class="k">for</code> <code class="n">_</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="mi">10000</code><code class="p">)]</code>&#13;
&#13;
<code class="c1"># normal distribution with mean 0, standard deviation 57</code>&#13;
<code class="n">normal</code> <code class="o">=</code> <code class="p">[</code><code class="mi">57</code> <code class="o">*</code> <code class="n">inverse_normal_cdf</code><code class="p">(</code><code class="n">random</code><code class="o">.</code><code class="n">random</code><code class="p">())</code>&#13;
          <code class="k">for</code> <code class="n">_</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="mi">10000</code><code class="p">)]</code></pre>&#13;
&#13;
<p>Both have means close to 0 and standard deviations close to 58.&#13;
However, they have very different distributions. <a data-type="xref" href="#histogram_uniform">Figure 10-1</a> shows the distribution of <code>uniform</code>:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">plot_histogram</code><code class="p">(</code><code class="n">uniform</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="s2">"Uniform Histogram"</code><code class="p">)</code></pre>&#13;
&#13;
<p>while <a data-type="xref" href="#histogram_normal">Figure 10-2</a> shows the distribution of <code>normal</code>:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">plot_histogram</code><code class="p">(</code><code class="n">normal</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="s2">"Normal Histogram"</code><code class="p">)</code></pre>&#13;
&#13;
<figure><div class="figure" id="histogram_uniform">&#13;
<img alt="Histogram of uniform" src="assets/dsf2_1001.png"/>&#13;
<h6><span class="label">Figure 10-1. </span>Histogram of uniform</h6>&#13;
</div></figure>&#13;
&#13;
<p>In this case the two distributions have a pretty different <code>max</code> and <code>min</code>, but even knowing&#13;
that wouldn’t have been sufficient to understand <em>how</em> they differed.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Two Dimensions" data-type="sect2"><div class="sect2" id="idm45635748067336">&#13;
<h2>Two Dimensions</h2>&#13;
&#13;
<p>Now<a data-primary="two-dimensional datasets" data-type="indexterm" id="idm45635747809880"/> imagine you have a dataset with two dimensions.  Maybe in addition to daily minutes you have years of data science experience.  Of course you’d want to understand each dimension individually.  But you probably also want to scatter the data.</p>&#13;
&#13;
<p>For example, consider another fake dataset:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">def</code> <code class="nf">random_normal</code><code class="p">()</code> <code class="o">-&gt;</code> <code class="nb">float</code><code class="p">:</code>&#13;
    <code class="sd">"""Returns a random draw from a standard normal distribution"""</code>&#13;
    <code class="k">return</code> <code class="n">inverse_normal_cdf</code><code class="p">(</code><code class="n">random</code><code class="o">.</code><code class="n">random</code><code class="p">())</code>&#13;
&#13;
<code class="n">xs</code> <code class="o">=</code> <code class="p">[</code><code class="n">random_normal</code><code class="p">()</code> <code class="k">for</code> <code class="n">_</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="mi">1000</code><code class="p">)]</code>&#13;
<code class="n">ys1</code> <code class="o">=</code> <code class="p">[</code> <code class="n">x</code> <code class="o">+</code> <code class="n">random_normal</code><code class="p">()</code> <code class="o">/</code> <code class="mi">2</code> <code class="k">for</code> <code class="n">x</code> <code class="ow">in</code> <code class="n">xs</code><code class="p">]</code>&#13;
<code class="n">ys2</code> <code class="o">=</code> <code class="p">[</code><code class="o">-</code><code class="n">x</code> <code class="o">+</code> <code class="n">random_normal</code><code class="p">()</code> <code class="o">/</code> <code class="mi">2</code> <code class="k">for</code> <code class="n">x</code> <code class="ow">in</code> <code class="n">xs</code><code class="p">]</code></pre>&#13;
&#13;
<p>If you were to run <code>plot_histogram</code> on <code>ys1</code> and <code>ys2</code>, you’d get similar-looking plots&#13;
(indeed, both are normally distributed with the same mean and standard deviation).</p>&#13;
&#13;
<figure><div class="figure" id="histogram_normal">&#13;
<img alt="Histogram of normal" src="assets/dsf2_1002.png"/>&#13;
<h6><span class="label">Figure 10-2. </span>Histogram of normal</h6>&#13;
</div></figure>&#13;
&#13;
<p>But each has a very different joint distribution with <code>xs</code>, as shown in <a data-type="xref" href="#scatter_ys1_ys2">Figure 10-3</a>:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">plt</code><code class="o">.</code><code class="n">scatter</code><code class="p">(</code><code class="n">xs</code><code class="p">,</code> <code class="n">ys1</code><code class="p">,</code> <code class="n">marker</code><code class="o">=</code><code class="s1">'.'</code><code class="p">,</code> <code class="n">color</code><code class="o">=</code><code class="s1">'black'</code><code class="p">,</code> <code class="n">label</code><code class="o">=</code><code class="s1">'ys1'</code><code class="p">)</code>&#13;
<code class="n">plt</code><code class="o">.</code><code class="n">scatter</code><code class="p">(</code><code class="n">xs</code><code class="p">,</code> <code class="n">ys2</code><code class="p">,</code> <code class="n">marker</code><code class="o">=</code><code class="s1">'.'</code><code class="p">,</code> <code class="n">color</code><code class="o">=</code><code class="s1">'gray'</code><code class="p">,</code>  <code class="n">label</code><code class="o">=</code><code class="s1">'ys2'</code><code class="p">)</code>&#13;
<code class="n">plt</code><code class="o">.</code><code class="n">xlabel</code><code class="p">(</code><code class="s1">'xs'</code><code class="p">)</code>&#13;
<code class="n">plt</code><code class="o">.</code><code class="n">ylabel</code><code class="p">(</code><code class="s1">'ys'</code><code class="p">)</code>&#13;
<code class="n">plt</code><code class="o">.</code><code class="n">legend</code><code class="p">(</code><code class="n">loc</code><code class="o">=</code><code class="mi">9</code><code class="p">)</code>&#13;
<code class="n">plt</code><code class="o">.</code><code class="n">title</code><code class="p">(</code><code class="s2">"Very Different Joint Distributions"</code><code class="p">)</code>&#13;
<code class="n">plt</code><code class="o">.</code><code class="n">show</code><code class="p">()</code></pre>&#13;
&#13;
<figure><div class="figure" id="scatter_ys1_ys2">&#13;
<img alt="Scattering two different ys's" src="assets/dsf2_1003.png"/>&#13;
<h6><span class="label">Figure 10-3. </span>Scattering two different ys</h6>&#13;
</div></figure>&#13;
&#13;
<p>This difference would also be apparent if you looked at the correlations:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">scratch.statistics</code> <code class="kn">import</code> <code class="n">correlation</code>&#13;
&#13;
<code class="k">print</code><code class="p">(</code><code class="n">correlation</code><code class="p">(</code><code class="n">xs</code><code class="p">,</code> <code class="n">ys1</code><code class="p">))</code>      <code class="c1"># about 0.9</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="n">correlation</code><code class="p">(</code><code class="n">xs</code><code class="p">,</code> <code class="n">ys2</code><code class="p">))</code>      <code class="c1"># about -0.9</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Many Dimensions" data-type="sect2"><div class="sect2" id="idm45635747499800">&#13;
<h2>Many Dimensions</h2>&#13;
&#13;
<p>With<a data-primary="correlation matrix" data-type="indexterm" id="idm45635747492712"/><a data-primary="multi-dimensional datasets" data-type="indexterm" id="idm45635747491976"/> many dimensions, you’d like to know how all the dimensions relate to one another.  A simple approach is to look at the <em>correlation matrix</em>, in which the entry in row <em>i</em> and column <em>j</em> is the correlation between the <em>i</em>th dimension and the <em>j</em>th dimension of the data:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">scratch.linear_algebra</code> <code class="kn">import</code> <code class="n">Matrix</code><code class="p">,</code> <code class="n">Vector</code><code class="p">,</code> <code class="n">make_matrix</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">correlation_matrix</code><code class="p">(</code><code class="n">data</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">Vector</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="n">Matrix</code><code class="p">:</code>&#13;
    <code class="sd">"""</code>&#13;
<code class="sd">    Returns the len(data) x len(data) matrix whose (i, j)-th entry</code>&#13;
<code class="sd">    is the correlation between data[i] and data[j]</code>&#13;
<code class="sd">    """</code>&#13;
    <code class="k">def</code> <code class="nf">correlation_ij</code><code class="p">(</code><code class="n">i</code><code class="p">:</code> <code class="nb">int</code><code class="p">,</code> <code class="n">j</code><code class="p">:</code> <code class="nb">int</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">float</code><code class="p">:</code>&#13;
        <code class="k">return</code> <code class="n">correlation</code><code class="p">(</code><code class="n">data</code><code class="p">[</code><code class="n">i</code><code class="p">],</code> <code class="n">data</code><code class="p">[</code><code class="n">j</code><code class="p">])</code>&#13;
&#13;
    <code class="k">return</code> <code class="n">make_matrix</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">data</code><code class="p">),</code> <code class="nb">len</code><code class="p">(</code><code class="n">data</code><code class="p">),</code> <code class="n">correlation_ij</code><code class="p">)</code></pre>&#13;
&#13;
<p>A<a data-primary="scatterplot matrix" data-type="indexterm" id="idm45635747487336"/> more visual approach (if you don’t have too many dimensions) is to make a <em>scatterplot matrix</em> (<a data-type="xref" href="#scatterplot_matrix">Figure 10-4</a>) showing all the pairwise scatterplots.&#13;
To do that we’ll use <code>plt.subplots</code>,&#13;
which allows us to create subplots of our chart.&#13;
We give it the number of rows and the number of columns,&#13;
and it returns a <code>figure</code> object (which we won’t use)&#13;
and a two-dimensional array of <code>axes</code> objects&#13;
(each of which we’ll plot to):</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="c1"># corr_data is a list of four 100-d vectors</code>&#13;
<code class="n">num_vectors</code> <code class="o">=</code> <code class="nb">len</code><code class="p">(</code><code class="n">corr_data</code><code class="p">)</code>&#13;
<code class="n">fig</code><code class="p">,</code> <code class="n">ax</code> <code class="o">=</code> <code class="n">plt</code><code class="o">.</code><code class="n">subplots</code><code class="p">(</code><code class="n">num_vectors</code><code class="p">,</code> <code class="n">num_vectors</code><code class="p">)</code>&#13;
&#13;
<code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="n">num_vectors</code><code class="p">):</code>&#13;
    <code class="k">for</code> <code class="n">j</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="n">num_vectors</code><code class="p">):</code>&#13;
&#13;
        <code class="c1"># Scatter column_j on the x-axis vs. column_i on the y-axis</code>&#13;
        <code class="k">if</code> <code class="n">i</code> <code class="o">!=</code> <code class="n">j</code><code class="p">:</code> <code class="n">ax</code><code class="p">[</code><code class="n">i</code><code class="p">][</code><code class="n">j</code><code class="p">]</code><code class="o">.</code><code class="n">scatter</code><code class="p">(</code><code class="n">corr_data</code><code class="p">[</code><code class="n">j</code><code class="p">],</code> <code class="n">corr_data</code><code class="p">[</code><code class="n">i</code><code class="p">])</code>&#13;
&#13;
        <code class="c1"># unless i == j, in which case show the series name</code>&#13;
        <code class="k">else</code><code class="p">:</code> <code class="n">ax</code><code class="p">[</code><code class="n">i</code><code class="p">][</code><code class="n">j</code><code class="p">]</code><code class="o">.</code><code class="n">annotate</code><code class="p">(</code><code class="s2">"series "</code> <code class="o">+</code> <code class="nb">str</code><code class="p">(</code><code class="n">i</code><code class="p">),</code> <code class="p">(</code><code class="mf">0.5</code><code class="p">,</code> <code class="mf">0.5</code><code class="p">),</code>&#13;
                                <code class="n">xycoords</code><code class="o">=</code><code class="s1">'axes fraction'</code><code class="p">,</code>&#13;
                                <code class="n">ha</code><code class="o">=</code><code class="s2">"center"</code><code class="p">,</code> <code class="n">va</code><code class="o">=</code><code class="s2">"center"</code><code class="p">)</code>&#13;
&#13;
        <code class="c1"># Then hide axis labels except left and bottom charts</code>&#13;
        <code class="k">if</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="n">num_vectors</code> <code class="o">-</code> <code class="mi">1</code><code class="p">:</code> <code class="n">ax</code><code class="p">[</code><code class="n">i</code><code class="p">][</code><code class="n">j</code><code class="p">]</code><code class="o">.</code><code class="n">xaxis</code><code class="o">.</code><code class="n">set_visible</code><code class="p">(</code><code class="bp">False</code><code class="p">)</code>&#13;
        <code class="k">if</code> <code class="n">j</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">:</code> <code class="n">ax</code><code class="p">[</code><code class="n">i</code><code class="p">][</code><code class="n">j</code><code class="p">]</code><code class="o">.</code><code class="n">yaxis</code><code class="o">.</code><code class="n">set_visible</code><code class="p">(</code><code class="bp">False</code><code class="p">)</code>&#13;
&#13;
<code class="c1"># Fix the bottom-right and top-left axis labels, which are wrong because</code>&#13;
<code class="c1"># their charts only have text in them</code>&#13;
<code class="n">ax</code><code class="p">[</code><code class="o">-</code><code class="mi">1</code><code class="p">][</code><code class="o">-</code><code class="mi">1</code><code class="p">]</code><code class="o">.</code><code class="n">set_xlim</code><code class="p">(</code><code class="n">ax</code><code class="p">[</code><code class="mi">0</code><code class="p">][</code><code class="o">-</code><code class="mi">1</code><code class="p">]</code><code class="o">.</code><code class="n">get_xlim</code><code class="p">())</code>&#13;
<code class="n">ax</code><code class="p">[</code><code class="mi">0</code><code class="p">][</code><code class="mi">0</code><code class="p">]</code><code class="o">.</code><code class="n">set_ylim</code><code class="p">(</code><code class="n">ax</code><code class="p">[</code><code class="mi">0</code><code class="p">][</code><code class="mi">1</code><code class="p">]</code><code class="o">.</code><code class="n">get_ylim</code><code class="p">())</code>&#13;
&#13;
<code class="n">plt</code><code class="o">.</code><code class="n">show</code><code class="p">()</code></pre>&#13;
&#13;
<figure><div class="figure" id="scatterplot_matrix">&#13;
<img alt="Scatterplot matrix" src="assets/dsf2_1004.png"/>&#13;
<h6><span class="label">Figure 10-4. </span>Scatterplot matrix</h6>&#13;
</div></figure>&#13;
&#13;
<p>Looking at the scatterplots, you can see that series 1 is&#13;
very negatively correlated with series 0, series 2 is positively&#13;
correlated with series 1, and series 3 only takes on the values 0 and 6,&#13;
with 0 corresponding to small values of series 2 and 6 corresponding&#13;
to large values.</p>&#13;
&#13;
<p>This is a quick way to get a rough sense of which of your variables&#13;
are correlated (unless you spend hours tweaking matplotlib&#13;
to display things exactly the way you want them to, in which case it’s not a quick way).<a data-primary="" data-startref="DWexpl10" data-type="indexterm" id="idm45635747161864"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using NamedTuples" data-type="sect1"><div class="sect1" id="using_namedtuples">&#13;
<h1>Using NamedTuples</h1>&#13;
&#13;
<p>One<a data-primary="data" data-secondary="working with" data-tertiary="using namedtuple class" data-type="indexterm" id="idm45635747159064"/><a data-primary="namedtuple class" data-type="indexterm" id="idm45635747157784"/><a data-primary="tuples" data-type="indexterm" id="idm45635747157112"/> common way of representing data is using <code>dict</code>s:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">import</code> <code class="nn">datetime</code>&#13;
&#13;
<code class="n">stock_price</code> <code class="o">=</code> <code class="p">{</code><code class="s1">'closing_price'</code><code class="p">:</code> <code class="mf">102.06</code><code class="p">,</code>&#13;
               <code class="s1">'date'</code><code class="p">:</code> <code class="n">datetime</code><code class="o">.</code><code class="n">date</code><code class="p">(</code><code class="mi">2014</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">29</code><code class="p">),</code>&#13;
               <code class="s1">'symbol'</code><code class="p">:</code> <code class="s1">'AAPL'</code><code class="p">}</code></pre>&#13;
&#13;
<p>There are several reasons why this is less than ideal, however.&#13;
This is a slightly inefficient representation (a <code>dict</code> involves&#13;
some overhead), so that if you have a lot of stock prices they’ll&#13;
take up more memory than they have to. For the most part, this is&#13;
a minor consideration.</p>&#13;
&#13;
<p>A larger issue is that accessing things by <code>dict</code> key is error-prone.&#13;
The following code will run without error and just do the wrong thing:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="c1"># oops, typo</code>&#13;
<code class="n">stock_price</code><code class="p">[</code><code class="s1">'cosing_price'</code><code class="p">]</code> <code class="o">=</code> <code class="mf">103.06</code></pre>&#13;
&#13;
<p>Finally, while we can type-annotate uniform dictionaries:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">prices</code><code class="p">:</code> <code class="n">Dict</code><code class="p">[</code><code class="n">datetime</code><code class="o">.</code><code class="n">date</code><code class="p">,</code> <code class="nb">float</code><code class="p">]</code> <code class="o">=</code> <code class="p">{}</code></pre>&#13;
&#13;
<p>there’s no helpful way to annotate&#13;
dictionaries-as-data that have lots of different value types.&#13;
So we also lose the power of type hints.</p>&#13;
&#13;
<p>As an alternative, Python includes a <code>namedtuple</code> class,&#13;
which is like a <code>tuple</code> but with named slots:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">collections</code> <code class="kn">import</code> <code class="n">namedtuple</code>&#13;
&#13;
<code class="n">StockPrice</code> <code class="o">=</code> <code class="n">namedtuple</code><code class="p">(</code><code class="s1">'StockPrice'</code><code class="p">,</code> <code class="p">[</code><code class="s1">'symbol'</code><code class="p">,</code> <code class="s1">'date'</code><code class="p">,</code> <code class="s1">'closing_price'</code><code class="p">])</code>&#13;
<code class="n">price</code> <code class="o">=</code> <code class="n">StockPrice</code><code class="p">(</code><code class="s1">'MSFT'</code><code class="p">,</code> <code class="n">datetime</code><code class="o">.</code><code class="n">date</code><code class="p">(</code><code class="mi">2018</code><code class="p">,</code> <code class="mi">12</code><code class="p">,</code> <code class="mi">14</code><code class="p">),</code> <code class="mf">106.03</code><code class="p">)</code>&#13;
&#13;
<code class="k">assert</code> <code class="n">price</code><code class="o">.</code><code class="n">symbol</code> <code class="o">==</code> <code class="s1">'MSFT'</code>&#13;
<code class="k">assert</code> <code class="n">price</code><code class="o">.</code><code class="n">closing_price</code> <code class="o">==</code> <code class="mf">106.03</code></pre>&#13;
&#13;
<p>Like regular <code>tuple</code>s, <code>namedtuple</code>s are immutable, which means that&#13;
you can’t modify their values once they’re created. Occasionally this will&#13;
get in our way, but mostly that’s a good thing.</p>&#13;
&#13;
<p>You’ll notice that we still haven’t solved the type annotation issue.&#13;
We do that by using the typed variant, <code>NamedTuple</code>:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">NamedTuple</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">StockPrice</code><code class="p">(</code><code class="n">NamedTuple</code><code class="p">):</code>&#13;
    <code class="n">symbol</code><code class="p">:</code> <code class="nb">str</code>&#13;
    <code class="n">date</code><code class="p">:</code> <code class="n">datetime</code><code class="o">.</code><code class="n">date</code>&#13;
    <code class="n">closing_price</code><code class="p">:</code> <code class="nb">float</code>&#13;
&#13;
    <code class="k">def</code> <code class="nf">is_high_tech</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">bool</code><code class="p">:</code>&#13;
        <code class="sd">"""It's a class, so we can add methods too"""</code>&#13;
        <code class="k">return</code> <code class="bp">self</code><code class="o">.</code><code class="n">symbol</code> <code class="ow">in</code> <code class="p">[</code><code class="s1">'MSFT'</code><code class="p">,</code> <code class="s1">'GOOG'</code><code class="p">,</code> <code class="s1">'FB'</code><code class="p">,</code> <code class="s1">'AMZN'</code><code class="p">,</code> <code class="s1">'AAPL'</code><code class="p">]</code>&#13;
&#13;
<code class="n">price</code> <code class="o">=</code> <code class="n">StockPrice</code><code class="p">(</code><code class="s1">'MSFT'</code><code class="p">,</code> <code class="n">datetime</code><code class="o">.</code><code class="n">date</code><code class="p">(</code><code class="mi">2018</code><code class="p">,</code> <code class="mi">12</code><code class="p">,</code> <code class="mi">14</code><code class="p">),</code> <code class="mf">106.03</code><code class="p">)</code>&#13;
&#13;
<code class="k">assert</code> <code class="n">price</code><code class="o">.</code><code class="n">symbol</code> <code class="o">==</code> <code class="s1">'MSFT'</code>&#13;
<code class="k">assert</code> <code class="n">price</code><code class="o">.</code><code class="n">closing_price</code> <code class="o">==</code> <code class="mf">106.03</code>&#13;
<code class="k">assert</code> <code class="n">price</code><code class="o">.</code><code class="n">is_high_tech</code><code class="p">()</code></pre>&#13;
&#13;
<p>And now your editor can help you out, as shown in <a data-type="xref" href="#helpful_editor">Figure 10-5</a>.</p>&#13;
&#13;
<figure><div class="figure" id="helpful_editor">&#13;
<img alt="Helpful editor" src="assets/dsf2_1005.png"/>&#13;
<h6><span class="label">Figure 10-5. </span>Helpful editor</h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Very few people use <code>NamedTuple</code> in this way. But they should!</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Dataclasses" data-type="sect1"><div class="sect1" id="idm45635747160168">&#13;
<h1>Dataclasses</h1>&#13;
&#13;
<p>Dataclasses<a data-primary="data" data-secondary="working with" data-tertiary="dataclasses" data-type="indexterm" id="idm45635746793880"/><a data-primary="dataclasses" data-type="indexterm" id="idm45635746792600"/> are (sort of) a mutable version of <code>NamedTuple</code>.&#13;
(I say “sort of” because <code>NamedTuple</code>s represent their data compactly&#13;
 as tuples, whereas dataclasses are regular Python classes that&#13;
 simply generate some methods for you automatically.)</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Dataclasses are new in Python 3.7.&#13;
If you’re using an older version, this section won’t work for you.</p>&#13;
</div>&#13;
&#13;
<p>The syntax is very similar to <code>NamedTuple</code>. But instead of inheriting&#13;
from a base class, we use a decorator:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">dataclasses</code> <code class="kn">import</code> <code class="n">dataclass</code>&#13;
&#13;
<code class="nd">@dataclass</code>&#13;
<code class="k">class</code> <code class="nc">StockPrice2</code><code class="p">:</code>&#13;
    <code class="n">symbol</code><code class="p">:</code> <code class="nb">str</code>&#13;
    <code class="n">date</code><code class="p">:</code> <code class="n">datetime</code><code class="o">.</code><code class="n">date</code>&#13;
    <code class="n">closing_price</code><code class="p">:</code> <code class="nb">float</code>&#13;
&#13;
    <code class="k">def</code> <code class="nf">is_high_tech</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">bool</code><code class="p">:</code>&#13;
        <code class="sd">"""It's a class, so we can add methods too"""</code>&#13;
        <code class="k">return</code> <code class="bp">self</code><code class="o">.</code><code class="n">symbol</code> <code class="ow">in</code> <code class="p">[</code><code class="s1">'MSFT'</code><code class="p">,</code> <code class="s1">'GOOG'</code><code class="p">,</code> <code class="s1">'FB'</code><code class="p">,</code> <code class="s1">'AMZN'</code><code class="p">,</code> <code class="s1">'AAPL'</code><code class="p">]</code>&#13;
&#13;
<code class="n">price2</code> <code class="o">=</code> <code class="n">StockPrice2</code><code class="p">(</code><code class="s1">'MSFT'</code><code class="p">,</code> <code class="n">datetime</code><code class="o">.</code><code class="n">date</code><code class="p">(</code><code class="mi">2018</code><code class="p">,</code> <code class="mi">12</code><code class="p">,</code> <code class="mi">14</code><code class="p">),</code> <code class="mf">106.03</code><code class="p">)</code>&#13;
&#13;
<code class="k">assert</code> <code class="n">price2</code><code class="o">.</code><code class="n">symbol</code> <code class="o">==</code> <code class="s1">'MSFT'</code>&#13;
<code class="k">assert</code> <code class="n">price2</code><code class="o">.</code><code class="n">closing_price</code> <code class="o">==</code> <code class="mf">106.03</code>&#13;
<code class="k">assert</code> <code class="n">price2</code><code class="o">.</code><code class="n">is_high_tech</code><code class="p">()</code></pre>&#13;
&#13;
<p>As mentioned, the big difference is that we can modify a dataclass instance’s values:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="c1"># stock split</code>&#13;
<code class="n">price2</code><code class="o">.</code><code class="n">closing_price</code> <code class="o">/=</code> <code class="mi">2</code>&#13;
<code class="k">assert</code> <code class="n">price2</code><code class="o">.</code><code class="n">closing_price</code> <code class="o">==</code> <code class="mf">51.03</code></pre>&#13;
&#13;
<p>If we tried to modify a field of the <code>NamedTuple</code> version, we’d get an <code>AttributeError</code>.</p>&#13;
&#13;
<p>This also leaves us susceptible to the kind of errors we were hoping to avoid by not using <code>dict</code>s:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="c1"># It's a regular class, so add new fields however you like!</code>&#13;
<code class="n">price2</code><code class="o">.</code><code class="n">cosing_price</code> <code class="o">=</code> <code class="mi">75</code>  <code class="c1"># oops</code></pre>&#13;
&#13;
<p>We won’t be using dataclasses, but you may encounter them out in the wild.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Cleaning and Munging" data-type="sect1"><div class="sect1" id="idm45635746794856">&#13;
<h1>Cleaning and Munging</h1>&#13;
&#13;
<p>Real-world<a data-primary="data" data-secondary="working with" data-tertiary="cleaning and munging" data-type="indexterm" id="idm45635746628360"/><a data-primary="cleaning data" data-type="indexterm" id="idm45635746638632"/><a data-primary="munging data" data-type="indexterm" id="idm45635746637960"/> data is <em>dirty</em>.  Often you’ll have to do some work on it before you can use it.&#13;
We saw examples of this in <a data-type="xref" href="ch09.html#getting_data">Chapter 9</a>. We have to convert strings to <code>float</code>s or <code>int</code>s before we can use them. We have to check for missing values and outliers and bad data.</p>&#13;
&#13;
<p>Previously, we did that right before using the data:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">closing_price</code> <code class="o">=</code> <code class="nb">float</code><code class="p">(</code><code class="n">row</code><code class="p">[</code><code class="mi">2</code><code class="p">])</code></pre>&#13;
&#13;
<p>But it’s probably less error-prone to do the parsing in a function that we can test:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">dateutil.parser</code> <code class="kn">import</code> <code class="n">parse</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">parse_row</code><code class="p">(</code><code class="n">row</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="nb">str</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="n">StockPrice</code><code class="p">:</code>&#13;
    <code class="n">symbol</code><code class="p">,</code> <code class="n">date</code><code class="p">,</code> <code class="n">closing_price</code> <code class="o">=</code> <code class="n">row</code>&#13;
    <code class="k">return</code> <code class="n">StockPrice</code><code class="p">(</code><code class="n">symbol</code><code class="o">=</code><code class="n">symbol</code><code class="p">,</code>&#13;
                      <code class="n">date</code><code class="o">=</code><code class="n">parse</code><code class="p">(</code><code class="n">date</code><code class="p">)</code><code class="o">.</code><code class="n">date</code><code class="p">(),</code>&#13;
                      <code class="n">closing_price</code><code class="o">=</code><code class="nb">float</code><code class="p">(</code><code class="n">closing_price</code><code class="p">))</code>&#13;
&#13;
<code class="c1"># Now test our function</code>&#13;
<code class="n">stock</code> <code class="o">=</code> <code class="n">parse_row</code><code class="p">([</code><code class="s2">"MSFT"</code><code class="p">,</code> <code class="s2">"2018-12-14"</code><code class="p">,</code> <code class="s2">"106.03"</code><code class="p">])</code>&#13;
&#13;
<code class="k">assert</code> <code class="n">stock</code><code class="o">.</code><code class="n">symbol</code> <code class="o">==</code> <code class="s2">"MSFT"</code>&#13;
<code class="k">assert</code> <code class="n">stock</code><code class="o">.</code><code class="n">date</code> <code class="o">==</code> <code class="n">datetime</code><code class="o">.</code><code class="n">date</code><code class="p">(</code><code class="mi">2018</code><code class="p">,</code> <code class="mi">12</code><code class="p">,</code> <code class="mi">14</code><code class="p">)</code>&#13;
<code class="k">assert</code> <code class="n">stock</code><code class="o">.</code><code class="n">closing_price</code> <code class="o">==</code> <code class="mf">106.03</code></pre>&#13;
&#13;
<p>What if there’s bad data?  A “float” value that doesn’t actually represent a number?&#13;
Maybe you’d rather get a <code>None</code> than crash your program?</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">Optional</code>&#13;
<code class="kn">import</code> <code class="nn">re</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">try_parse_row</code><code class="p">(</code><code class="n">row</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="nb">str</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="n">Optional</code><code class="p">[</code><code class="n">StockPrice</code><code class="p">]:</code>&#13;
    <code class="n">symbol</code><code class="p">,</code> <code class="n">date_</code><code class="p">,</code> <code class="n">closing_price_</code> <code class="o">=</code> <code class="n">row</code>&#13;
&#13;
    <code class="c1"># Stock symbol should be all capital letters</code>&#13;
    <code class="k">if</code> <code class="ow">not</code> <code class="n">re</code><code class="o">.</code><code class="n">match</code><code class="p">(</code><code class="s-Affix">r</code><code class="s2">"^[A-Z]+$"</code><code class="p">,</code> <code class="n">symbol</code><code class="p">):</code>&#13;
        <code class="k">return</code> <code class="bp">None</code>&#13;
&#13;
    <code class="k">try</code><code class="p">:</code>&#13;
        <code class="n">date</code> <code class="o">=</code> <code class="n">parse</code><code class="p">(</code><code class="n">date_</code><code class="p">)</code><code class="o">.</code><code class="n">date</code><code class="p">()</code>&#13;
    <code class="k">except</code> <code class="ne">ValueError</code><code class="p">:</code>&#13;
        <code class="k">return</code> <code class="bp">None</code>&#13;
&#13;
    <code class="k">try</code><code class="p">:</code>&#13;
        <code class="n">closing_price</code> <code class="o">=</code> <code class="nb">float</code><code class="p">(</code><code class="n">closing_price_</code><code class="p">)</code>&#13;
    <code class="k">except</code> <code class="ne">ValueError</code><code class="p">:</code>&#13;
        <code class="k">return</code> <code class="bp">None</code>&#13;
&#13;
    <code class="k">return</code> <code class="n">StockPrice</code><code class="p">(</code><code class="n">symbol</code><code class="p">,</code> <code class="n">date</code><code class="p">,</code> <code class="n">closing_price</code><code class="p">)</code>&#13;
&#13;
<code class="c1"># Should return None for errors</code>&#13;
<code class="k">assert</code> <code class="n">try_parse_row</code><code class="p">([</code><code class="s2">"MSFT0"</code><code class="p">,</code> <code class="s2">"2018-12-14"</code><code class="p">,</code> <code class="s2">"106.03"</code><code class="p">])</code> <code class="ow">is</code> <code class="bp">None</code>&#13;
<code class="k">assert</code> <code class="n">try_parse_row</code><code class="p">([</code><code class="s2">"MSFT"</code><code class="p">,</code> <code class="s2">"2018-12--14"</code><code class="p">,</code> <code class="s2">"106.03"</code><code class="p">])</code> <code class="ow">is</code> <code class="bp">None</code>&#13;
<code class="k">assert</code> <code class="n">try_parse_row</code><code class="p">([</code><code class="s2">"MSFT"</code><code class="p">,</code> <code class="s2">"2018-12-14"</code><code class="p">,</code> <code class="s2">"x"</code><code class="p">])</code> <code class="ow">is</code> <code class="bp">None</code>&#13;
&#13;
<code class="c1"># But should return same as before if data is good</code>&#13;
<code class="k">assert</code> <code class="n">try_parse_row</code><code class="p">([</code><code class="s2">"MSFT"</code><code class="p">,</code> <code class="s2">"2018-12-14"</code><code class="p">,</code> <code class="s2">"106.03"</code><code class="p">])</code> <code class="o">==</code> <code class="n">stock</code></pre>&#13;
&#13;
<p>For example, if we have comma-delimited stock prices with bad data:</p>&#13;
&#13;
<pre data-type="programlisting">AAPL,6/20/2014,90.91&#13;
MSFT,6/20/2014,41.68&#13;
FB,6/20/3014,64.5&#13;
AAPL,6/19/2014,91.86&#13;
MSFT,6/19/2014,n/a&#13;
FB,6/19/2014,64.34</pre>&#13;
&#13;
<p>we can now read and return only the valid rows:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">import</code> <code class="nn">csv</code>&#13;
&#13;
<code class="n">data</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">StockPrice</code><code class="p">]</code> <code class="o">=</code> <code class="p">[]</code>&#13;
&#13;
<code class="k">with</code> <code class="nb">open</code><code class="p">(</code><code class="s2">"comma_delimited_stock_prices.csv"</code><code class="p">)</code> <code class="k">as</code> <code class="n">f</code><code class="p">:</code>&#13;
    <code class="n">reader</code> <code class="o">=</code> <code class="n">csv</code><code class="o">.</code><code class="n">reader</code><code class="p">(</code><code class="n">f</code><code class="p">)</code>&#13;
    <code class="k">for</code> <code class="n">row</code> <code class="ow">in</code> <code class="n">reader</code><code class="p">:</code>&#13;
        <code class="n">maybe_stock</code> <code class="o">=</code> <code class="n">try_parse_row</code><code class="p">(</code><code class="n">row</code><code class="p">)</code>&#13;
        <code class="k">if</code> <code class="n">maybe_stock</code> <code class="ow">is</code> <code class="bp">None</code><code class="p">:</code>&#13;
            <code class="k">print</code><code class="p">(</code><code class="n">f</code><code class="s2">"skipping invalid row: {row}"</code><code class="p">)</code>&#13;
        <code class="k">else</code><code class="p">:</code>&#13;
            <code class="n">data</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">maybe_stock</code><code class="p">)</code></pre>&#13;
&#13;
<p>and decide what we want to do about the invalid ones. Generally speaking, the three options are to get rid of them, to go back to the source and try to fix the bad/missing data, or to do nothing and cross our fingers.&#13;
If there’s one bad row out of millions, it’s probably okay to ignore it. But if half your rows have bad data, that’s something you need to fix.</p>&#13;
&#13;
<p>A good next step is to check for outliers, using techniques from <a data-type="xref" href="#exploring_your_data">“Exploring Your Data”</a> or by ad hoc investigating.  For example, did you notice that one of the dates in the stocks file had the year 3014?  That won’t (necessarily) give you an error, but it’s quite plainly wrong, and you’ll get screwy results if you don’t catch it.  Real-world datasets have missing decimal points, extra zeros, typographical errors, and countless other problems that it’s your job to catch. (Maybe it’s not officially your job, but who else is going to do it?)</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Manipulating Data" data-type="sect1"><div class="sect1" id="idm45635746629592">&#13;
<h1>Manipulating Data</h1>&#13;
&#13;
<p>One<a data-primary="data" data-secondary="working with" data-tertiary="manipulating data" data-type="indexterm" id="idm45635746190136"/><a data-primary="manipulating data" data-type="indexterm" id="idm45635746188856"/> of the most important skills of a data scientist is <em>manipulating data</em>.&#13;
It’s more of a general approach than a specific technique, so we’ll just&#13;
work through a handful of examples to give you the flavor of it.</p>&#13;
&#13;
<p>Imagine we have a bunch of stock price data that looks like this:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">data</code> <code class="o">=</code> <code class="p">[</code>&#13;
    <code class="n">StockPrice</code><code class="p">(</code><code class="n">symbol</code><code class="o">=</code><code class="s1">'MSFT'</code><code class="p">,</code>&#13;
               <code class="n">date</code><code class="o">=</code><code class="n">datetime</code><code class="o">.</code><code class="n">date</code><code class="p">(</code><code class="mi">2018</code><code class="p">,</code> <code class="mi">12</code><code class="p">,</code> <code class="mi">24</code><code class="p">),</code>&#13;
               <code class="n">closing_price</code><code class="o">=</code><code class="mf">106.03</code><code class="p">),</code>&#13;
    <code class="c1"># ...</code>&#13;
<code class="p">]</code></pre>&#13;
&#13;
<p>Let’s start asking questions about this data.  Along the way we’ll try to notice patterns in what we’re doing and abstract out some tools to make the manipulation easier.</p>&#13;
&#13;
<p>For instance, suppose we want to know the highest-ever closing price for AAPL.  Let’s break this down into concrete steps:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Restrict ourselves to AAPL rows.</p>&#13;
</li>&#13;
<li>&#13;
<p>Grab the <code>closing_price</code> from each row.</p>&#13;
</li>&#13;
<li>&#13;
<p>Take the <code>max</code> of those prices.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>We can do all three at once using a comprehension:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">max_aapl_price</code> <code class="o">=</code> <code class="nb">max</code><code class="p">(</code><code class="n">stock_price</code><code class="o">.</code><code class="n">closing_price</code>&#13;
                     <code class="k">for</code> <code class="n">stock_price</code> <code class="ow">in</code> <code class="n">data</code>&#13;
                     <code class="k">if</code> <code class="n">stock_price</code><code class="o">.</code><code class="n">symbol</code> <code class="o">==</code> <code class="s2">"AAPL"</code><code class="p">)</code></pre>&#13;
&#13;
<p>More generally, we might want to know the highest-ever closing price for each stock in our dataset.  One way to do this is:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Create a <code>dict</code> to keep track of highest prices (we’ll use a <code>defaultdict</code> that returns minus infinity for missing values, since any price will be greater than that).</p>&#13;
</li>&#13;
<li>&#13;
<p>Iterate over our data, updating it.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Here’s the code:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">collections</code> <code class="kn">import</code> <code class="n">defaultdict</code>&#13;
&#13;
<code class="n">max_prices</code><code class="p">:</code> <code class="n">Dict</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code> <code class="nb">float</code><code class="p">]</code> <code class="o">=</code> <code class="n">defaultdict</code><code class="p">(</code><code class="k">lambda</code><code class="p">:</code> <code class="nb">float</code><code class="p">(</code><code class="s1">'-inf'</code><code class="p">))</code>&#13;
&#13;
<code class="k">for</code> <code class="n">sp</code> <code class="ow">in</code> <code class="n">data</code><code class="p">:</code>&#13;
    <code class="n">symbol</code><code class="p">,</code> <code class="n">closing_price</code> <code class="o">=</code> <code class="n">sp</code><code class="o">.</code><code class="n">symbol</code><code class="p">,</code> <code class="n">sp</code><code class="o">.</code><code class="n">closing_price</code>&#13;
    <code class="k">if</code> <code class="n">closing_price</code> <code class="o">&gt;</code> <code class="n">max_prices</code><code class="p">[</code><code class="n">symbol</code><code class="p">]:</code>&#13;
        <code class="n">max_prices</code><code class="p">[</code><code class="n">symbol</code><code class="p">]</code> <code class="o">=</code> <code class="n">closing_price</code></pre>&#13;
&#13;
<p>We can now start to ask more complicated things, like what are the largest and smallest one-day percent changes in our dataset. The percent change is <code>price_today / price_yesterday - 1</code>, which means we need some way of associating today’s price and yesterday’s price. One approach is to group the prices by symbol, and then, within each group:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Order the prices by date.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use <code>zip</code> to get (previous, current) pairs.</p>&#13;
</li>&#13;
<li>&#13;
<p>Turn the pairs into new “percent change” rows.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Let’s start by grouping the prices by symbol:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">List</code>&#13;
<code class="kn">from</code> <code class="nn">collections</code> <code class="kn">import</code> <code class="n">defaultdict</code>&#13;
&#13;
<code class="c1"># Collect the prices by symbol</code>&#13;
<code class="n">prices</code><code class="p">:</code> <code class="n">Dict</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code> <code class="n">List</code><code class="p">[</code><code class="n">StockPrice</code><code class="p">]]</code> <code class="o">=</code> <code class="n">defaultdict</code><code class="p">(</code><code class="nb">list</code><code class="p">)</code>&#13;
&#13;
<code class="k">for</code> <code class="n">sp</code> <code class="ow">in</code> <code class="n">data</code><code class="p">:</code>&#13;
    <code class="n">prices</code><code class="p">[</code><code class="n">sp</code><code class="o">.</code><code class="n">symbol</code><code class="p">]</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">sp</code><code class="p">)</code></pre>&#13;
&#13;
<p>Since the prices are tuples, they’ll get sorted by their fields in order: first by symbol, then by date, then by price. This means that if we have some prices all with the same symbol, <code>sort</code> will sort them by date (and then by price, which does nothing, since we only have one per date), which is what we want.</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="c1"># Order the prices by date</code>&#13;
<code class="n">prices</code> <code class="o">=</code> <code class="p">{</code><code class="n">symbol</code><code class="p">:</code> <code class="nb">sorted</code><code class="p">(</code><code class="n">symbol_prices</code><code class="p">)</code>&#13;
          <code class="k">for</code> <code class="n">symbol</code><code class="p">,</code> <code class="n">symbol_prices</code> <code class="ow">in</code> <code class="n">prices</code><code class="o">.</code><code class="n">items</code><code class="p">()}</code></pre>&#13;
&#13;
<p>which we can use to compute a sequence of day-over-day changes:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">def</code> <code class="nf">pct_change</code><code class="p">(</code><code class="n">yesterday</code><code class="p">:</code> <code class="n">StockPrice</code><code class="p">,</code> <code class="n">today</code><code class="p">:</code> <code class="n">StockPrice</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">float</code><code class="p">:</code>&#13;
    <code class="k">return</code> <code class="n">today</code><code class="o">.</code><code class="n">closing_price</code> <code class="o">/</code> <code class="n">yesterday</code><code class="o">.</code><code class="n">closing_price</code> <code class="o">-</code> <code class="mi">1</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">DailyChange</code><code class="p">(</code><code class="n">NamedTuple</code><code class="p">):</code>&#13;
    <code class="n">symbol</code><code class="p">:</code> <code class="nb">str</code>&#13;
    <code class="n">date</code><code class="p">:</code> <code class="n">datetime</code><code class="o">.</code><code class="n">date</code>&#13;
    <code class="n">pct_change</code><code class="p">:</code> <code class="nb">float</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">day_over_day_changes</code><code class="p">(</code><code class="n">prices</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">StockPrice</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="n">List</code><code class="p">[</code><code class="n">DailyChange</code><code class="p">]:</code>&#13;
    <code class="sd">"""</code>&#13;
<code class="sd">    Assumes prices are for one stock and are in order</code>&#13;
<code class="sd">    """</code>&#13;
    <code class="k">return</code> <code class="p">[</code><code class="n">DailyChange</code><code class="p">(</code><code class="n">symbol</code><code class="o">=</code><code class="n">today</code><code class="o">.</code><code class="n">symbol</code><code class="p">,</code>&#13;
                        <code class="n">date</code><code class="o">=</code><code class="n">today</code><code class="o">.</code><code class="n">date</code><code class="p">,</code>&#13;
                        <code class="n">pct_change</code><code class="o">=</code><code class="n">pct_change</code><code class="p">(</code><code class="n">yesterday</code><code class="p">,</code> <code class="n">today</code><code class="p">))</code>&#13;
            <code class="k">for</code> <code class="n">yesterday</code><code class="p">,</code> <code class="n">today</code> <code class="ow">in</code> <code class="nb">zip</code><code class="p">(</code><code class="n">prices</code><code class="p">,</code> <code class="n">prices</code><code class="p">[</code><code class="mi">1</code><code class="p">:])]</code></pre>&#13;
&#13;
<p>and then collect them all:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">all_changes</code> <code class="o">=</code> <code class="p">[</code><code class="n">change</code>&#13;
               <code class="k">for</code> <code class="n">symbol_prices</code> <code class="ow">in</code> <code class="n">prices</code><code class="o">.</code><code class="n">values</code><code class="p">()</code>&#13;
               <code class="k">for</code> <code class="n">change</code> <code class="ow">in</code> <code class="n">day_over_day_changes</code><code class="p">(</code><code class="n">symbol_prices</code><code class="p">)]</code></pre>&#13;
&#13;
<p>At which point it’s easy to find the largest and smallest:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">max_change</code> <code class="o">=</code> <code class="nb">max</code><code class="p">(</code><code class="n">all_changes</code><code class="p">,</code> <code class="n">key</code><code class="o">=</code><code class="k">lambda</code> <code class="n">change</code><code class="p">:</code> <code class="n">change</code><code class="o">.</code><code class="n">pct_change</code><code class="p">)</code>&#13;
<code class="c1"># see e.g. http://news.cnet.com/2100-1001-202143.html</code>&#13;
<code class="k">assert</code> <code class="n">max_change</code><code class="o">.</code><code class="n">symbol</code> <code class="o">==</code> <code class="s1">'AAPL'</code>&#13;
<code class="k">assert</code> <code class="n">max_change</code><code class="o">.</code><code class="n">date</code> <code class="o">==</code> <code class="n">datetime</code><code class="o">.</code><code class="n">date</code><code class="p">(</code><code class="mi">1997</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">6</code><code class="p">)</code>&#13;
<code class="k">assert</code> <code class="mf">0.33</code> <code class="o">&lt;</code> <code class="n">max_change</code><code class="o">.</code><code class="n">pct_change</code> <code class="o">&lt;</code> <code class="mf">0.34</code>&#13;
&#13;
<code class="n">min_change</code> <code class="o">=</code> <code class="nb">min</code><code class="p">(</code><code class="n">all_changes</code><code class="p">,</code> <code class="n">key</code><code class="o">=</code><code class="k">lambda</code> <code class="n">change</code><code class="p">:</code> <code class="n">change</code><code class="o">.</code><code class="n">pct_change</code><code class="p">)</code>&#13;
<code class="c1"># see e.g. http://money.cnn.com/2000/09/29/markets/techwrap/</code>&#13;
<code class="k">assert</code> <code class="n">min_change</code><code class="o">.</code><code class="n">symbol</code> <code class="o">==</code> <code class="s1">'AAPL'</code>&#13;
<code class="k">assert</code> <code class="n">min_change</code><code class="o">.</code><code class="n">date</code> <code class="o">==</code> <code class="n">datetime</code><code class="o">.</code><code class="n">date</code><code class="p">(</code><code class="mi">2000</code><code class="p">,</code> <code class="mi">9</code><code class="p">,</code> <code class="mi">29</code><code class="p">)</code>&#13;
<code class="k">assert</code> <code class="o">-</code><code class="mf">0.52</code> <code class="o">&lt;</code> <code class="n">min_change</code><code class="o">.</code><code class="n">pct_change</code> <code class="o">&lt;</code> <code class="o">-</code><code class="mf">0.51</code></pre>&#13;
&#13;
<p>We can now use this new <code>all_changes</code> dataset to find which month is the best to invest in tech stocks.  We’ll just look at the average daily change by month:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">changes_by_month</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">DailyChange</code><code class="p">]</code> <code class="o">=</code> <code class="p">{</code><code class="n">month</code><code class="p">:</code> <code class="p">[]</code> <code class="k">for</code> <code class="n">month</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">13</code><code class="p">)}</code>&#13;
&#13;
<code class="k">for</code> <code class="n">change</code> <code class="ow">in</code> <code class="n">all_changes</code><code class="p">:</code>&#13;
    <code class="n">changes_by_month</code><code class="p">[</code><code class="n">change</code><code class="o">.</code><code class="n">date</code><code class="o">.</code><code class="n">month</code><code class="p">]</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">change</code><code class="p">)</code>&#13;
&#13;
<code class="n">avg_daily_change</code> <code class="o">=</code> <code class="p">{</code>&#13;
    <code class="n">month</code><code class="p">:</code> <code class="nb">sum</code><code class="p">(</code><code class="n">change</code><code class="o">.</code><code class="n">pct_change</code> <code class="k">for</code> <code class="n">change</code> <code class="ow">in</code> <code class="n">changes</code><code class="p">)</code> <code class="o">/</code> <code class="nb">len</code><code class="p">(</code><code class="n">changes</code><code class="p">)</code>&#13;
    <code class="k">for</code> <code class="n">month</code><code class="p">,</code> <code class="n">changes</code> <code class="ow">in</code> <code class="n">changes_by_month</code><code class="o">.</code><code class="n">items</code><code class="p">()</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1"># October is the best month</code>&#13;
<code class="k">assert</code> <code class="n">avg_daily_change</code><code class="p">[</code><code class="mi">10</code><code class="p">]</code> <code class="o">==</code> <code class="nb">max</code><code class="p">(</code><code class="n">avg_daily_change</code><code class="o">.</code><code class="n">values</code><code class="p">())</code></pre>&#13;
&#13;
<p>We’ll be doing these sorts of manipulations throughout the book, usually without calling too much explicit attention to them.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Rescaling" data-type="sect1"><div class="sect1" id="rescaling">&#13;
<h1>Rescaling</h1>&#13;
&#13;
<p>Many<a data-primary="data" data-secondary="working with" data-tertiary="rescaling" data-type="indexterm" id="idm45635745380840"/><a data-primary="rescaling data" data-type="indexterm" id="idm45635745379560"/><a data-primary="scale" data-type="indexterm" id="idm45635745378888"/> techniques are sensitive to the <em>scale</em> of your data.  For example, imagine that you have a dataset consisting of the heights and weights of hundreds of data scientists, and that you are trying to identify <em>clusters</em> of body sizes.</p>&#13;
&#13;
<p>Intuitively, we’d like clusters to represent points near each other, which means that we need some notion of distance between points. We already have a Euclidean <code>distance</code> function, so a natural approach might be to treat (height, weight) pairs as points in two-dimensional space. Consider the people listed in <a data-type="xref" href="#heights-and-weights">Table 10-1</a>.</p>&#13;
<table id="heights-and-weights">&#13;
<caption><span class="label">Table 10-1. </span>Heights and weights</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Person</th>&#13;
<th>Height (inches)</th>&#13;
<th>Height (centimeters)</th>&#13;
<th>Weight (pounds)</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>A</p></td>&#13;
<td><p>63</p></td>&#13;
<td><p>160</p></td>&#13;
<td><p>150</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>B</p></td>&#13;
<td><p>67</p></td>&#13;
<td><p>170.2</p></td>&#13;
<td><p>160</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>C</p></td>&#13;
<td><p>70</p></td>&#13;
<td><p>177.8</p></td>&#13;
<td><p>171</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>If we measure height in inches, then B’s nearest neighbor is A:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">scratch.linear_algebra</code> <code class="kn">import</code> <code class="n">distance</code>&#13;
&#13;
<code class="n">a_to_b</code> <code class="o">=</code> <code class="n">distance</code><code class="p">([</code><code class="mi">63</code><code class="p">,</code> <code class="mi">150</code><code class="p">],</code> <code class="p">[</code><code class="mi">67</code><code class="p">,</code> <code class="mi">160</code><code class="p">])</code>        <code class="c1"># 10.77</code>&#13;
<code class="n">a_to_c</code> <code class="o">=</code> <code class="n">distance</code><code class="p">([</code><code class="mi">63</code><code class="p">,</code> <code class="mi">150</code><code class="p">],</code> <code class="p">[</code><code class="mi">70</code><code class="p">,</code> <code class="mi">171</code><code class="p">])</code>        <code class="c1"># 22.14</code>&#13;
<code class="n">b_to_c</code> <code class="o">=</code> <code class="n">distance</code><code class="p">([</code><code class="mi">67</code><code class="p">,</code> <code class="mi">160</code><code class="p">],</code> <code class="p">[</code><code class="mi">70</code><code class="p">,</code> <code class="mi">171</code><code class="p">])</code>        <code class="c1"># 11.40</code></pre>&#13;
&#13;
<p>However, if we measure height in centimeters, then B’s nearest neighbor is instead C:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">a_to_b</code> <code class="o">=</code> <code class="n">distance</code><code class="p">([</code><code class="mi">160</code><code class="p">,</code> <code class="mi">150</code><code class="p">],</code> <code class="p">[</code><code class="mf">170.2</code><code class="p">,</code> <code class="mi">160</code><code class="p">])</code>    <code class="c1"># 14.28</code>&#13;
<code class="n">a_to_c</code> <code class="o">=</code> <code class="n">distance</code><code class="p">([</code><code class="mi">160</code><code class="p">,</code> <code class="mi">150</code><code class="p">],</code> <code class="p">[</code><code class="mf">177.8</code><code class="p">,</code> <code class="mi">171</code><code class="p">])</code>    <code class="c1"># 27.53</code>&#13;
<code class="n">b_to_c</code> <code class="o">=</code> <code class="n">distance</code><code class="p">([</code><code class="mf">170.2</code><code class="p">,</code> <code class="mi">160</code><code class="p">],</code> <code class="p">[</code><code class="mf">177.8</code><code class="p">,</code> <code class="mi">171</code><code class="p">])</code>  <code class="c1"># 13.37</code></pre>&#13;
&#13;
<p>Obviously it’s a problem if changing units can change results like this.  For this reason,&#13;
when dimensions aren’t comparable with one another, we will sometimes <em>rescale</em> our data so that each dimension has mean 0 and standard deviation 1.  This effectively gets rid of the units, converting each dimension to “standard deviations from the mean.”</p>&#13;
&#13;
<p>To start with, we’ll need to compute the <code>mean</code> and the <code>standard_deviation</code> for each position:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">Tuple</code>&#13;
&#13;
<code class="kn">from</code> <code class="nn">scratch.linear_algebra</code> <code class="kn">import</code> <code class="n">vector_mean</code>&#13;
<code class="kn">from</code> <code class="nn">scratch.statistics</code> <code class="kn">import</code> <code class="n">standard_deviation</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">scale</code><code class="p">(</code><code class="n">data</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">Vector</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="n">Tuple</code><code class="p">[</code><code class="n">Vector</code><code class="p">,</code> <code class="n">Vector</code><code class="p">]:</code>&#13;
    <code class="sd">"""returns the mean and standard deviation for each position"""</code>&#13;
    <code class="n">dim</code> <code class="o">=</code> <code class="nb">len</code><code class="p">(</code><code class="n">data</code><code class="p">[</code><code class="mi">0</code><code class="p">])</code>&#13;
&#13;
    <code class="n">means</code> <code class="o">=</code> <code class="n">vector_mean</code><code class="p">(</code><code class="n">data</code><code class="p">)</code>&#13;
    <code class="n">stdevs</code> <code class="o">=</code> <code class="p">[</code><code class="n">standard_deviation</code><code class="p">([</code><code class="n">vector</code><code class="p">[</code><code class="n">i</code><code class="p">]</code> <code class="k">for</code> <code class="n">vector</code> <code class="ow">in</code> <code class="n">data</code><code class="p">])</code>&#13;
              <code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="n">dim</code><code class="p">)]</code>&#13;
&#13;
    <code class="k">return</code> <code class="n">means</code><code class="p">,</code> <code class="n">stdevs</code>&#13;
&#13;
<code class="n">vectors</code> <code class="o">=</code> <code class="p">[[</code><code class="o">-</code><code class="mi">3</code><code class="p">,</code> <code class="o">-</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">],</code> <code class="p">[</code><code class="o">-</code><code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">],</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">]]</code>&#13;
<code class="n">means</code><code class="p">,</code> <code class="n">stdevs</code> <code class="o">=</code> <code class="n">scale</code><code class="p">(</code><code class="n">vectors</code><code class="p">)</code>&#13;
<code class="k">assert</code> <code class="n">means</code> <code class="o">==</code> <code class="p">[</code><code class="o">-</code><code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">]</code>&#13;
<code class="k">assert</code> <code class="n">stdevs</code> <code class="o">==</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">]</code></pre>&#13;
&#13;
<p>We can then use them to create a new dataset:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">def</code> <code class="nf">rescale</code><code class="p">(</code><code class="n">data</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">Vector</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="n">List</code><code class="p">[</code><code class="n">Vector</code><code class="p">]:</code>&#13;
    <code class="sd">"""</code>&#13;
<code class="sd">    Rescales the input data so that each position has</code>&#13;
<code class="sd">    mean 0 and standard deviation 1. (Leaves a position</code>&#13;
<code class="sd">    as is if its standard deviation is 0.)</code>&#13;
<code class="sd">    """</code>&#13;
    <code class="n">dim</code> <code class="o">=</code> <code class="nb">len</code><code class="p">(</code><code class="n">data</code><code class="p">[</code><code class="mi">0</code><code class="p">])</code>&#13;
    <code class="n">means</code><code class="p">,</code> <code class="n">stdevs</code> <code class="o">=</code> <code class="n">scale</code><code class="p">(</code><code class="n">data</code><code class="p">)</code>&#13;
&#13;
    <code class="c1"># Make a copy of each vector</code>&#13;
    <code class="n">rescaled</code> <code class="o">=</code> <code class="p">[</code><code class="n">v</code><code class="p">[:]</code> <code class="k">for</code> <code class="n">v</code> <code class="ow">in</code> <code class="n">data</code><code class="p">]</code>&#13;
&#13;
    <code class="k">for</code> <code class="n">v</code> <code class="ow">in</code> <code class="n">rescaled</code><code class="p">:</code>&#13;
        <code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="n">dim</code><code class="p">):</code>&#13;
            <code class="k">if</code> <code class="n">stdevs</code><code class="p">[</code><code class="n">i</code><code class="p">]</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">:</code>&#13;
                <code class="n">v</code><code class="p">[</code><code class="n">i</code><code class="p">]</code> <code class="o">=</code> <code class="p">(</code><code class="n">v</code><code class="p">[</code><code class="n">i</code><code class="p">]</code> <code class="o">-</code> <code class="n">means</code><code class="p">[</code><code class="n">i</code><code class="p">])</code> <code class="o">/</code> <code class="n">stdevs</code><code class="p">[</code><code class="n">i</code><code class="p">]</code>&#13;
&#13;
    <code class="k">return</code> <code class="n">rescaled</code></pre>&#13;
&#13;
<p>Of course, let’s write a test to conform that <code>rescale</code> does what we think it should:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">means</code><code class="p">,</code> <code class="n">stdevs</code> <code class="o">=</code> <code class="n">scale</code><code class="p">(</code><code class="n">rescale</code><code class="p">(</code><code class="n">vectors</code><code class="p">))</code>&#13;
<code class="k">assert</code> <code class="n">means</code> <code class="o">==</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">]</code>&#13;
<code class="k">assert</code> <code class="n">stdevs</code> <code class="o">==</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">]</code></pre>&#13;
&#13;
<p>As always, you need to use your judgment. If you were to take a huge dataset of heights and weights and filter it down to only the people with heights between 69.5 inches and 70.5 inches, it’s quite likely (depending on the question you’re trying to answer) that the variation remaining is simply <em>noise</em>, and you might not want to put its standard deviation on equal footing with other dimensions’ deviations.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="An Aside: tqdm" data-type="sect1"><div class="sect1" id="idm45635745500136">&#13;
<h1>An Aside: tqdm</h1>&#13;
&#13;
<p>Frequently<a data-primary="data" data-secondary="working with" data-tertiary="generating progress bars" data-type="indexterm" id="idm45635744871112"/><a data-primary="progress bars, generating" data-type="indexterm" id="idm45635744869864"/><a data-primary="tqdm library" data-type="indexterm" id="idm45635744869224"/> we’ll end up doing computations that take a long time.&#13;
When you’re doing such work, you’d like to know that you’re making progress&#13;
and how long you should expect to wait.</p>&#13;
&#13;
<p>One way of doing this is with the <code>tqdm</code> library, which generates custom progress bars.&#13;
We’ll use it some throughout the rest of the book, so let’s take this chance to learn how it works.</p>&#13;
&#13;
<p>To start with, you’ll need to install it:</p>&#13;
&#13;
<pre data-type="programlisting">python -m pip install tqdm</pre>&#13;
&#13;
<p>There are only a few features you need to know about. The first is that an iterable wrapped in&#13;
<code>tqdm.tqdm</code> will produce a progress bar:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">import</code> <code class="nn">tqdm</code>&#13;
&#13;
<code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="n">tqdm</code><code class="o">.</code><code class="n">tqdm</code><code class="p">(</code><code class="nb">range</code><code class="p">(</code><code class="mi">100</code><code class="p">)):</code>&#13;
    <code class="c1"># do something slow</code>&#13;
    <code class="n">_</code> <code class="o">=</code> <code class="p">[</code><code class="n">random</code><code class="o">.</code><code class="n">random</code><code class="p">()</code> <code class="k">for</code> <code class="n">_</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="mi">1000000</code><code class="p">)]</code></pre>&#13;
&#13;
<p>which produces an output that looks like this:</p>&#13;
&#13;
<pre data-type="programlisting"> 56%|████████████████████              | 56/100 [00:08&lt;00:06,  6.49it/s]</pre>&#13;
&#13;
<p>In particular, it shows you what fraction of your loop is done&#13;
(though it can’t do this if you use a generator),&#13;
how long it’s been running, and how long it expects to run.</p>&#13;
&#13;
<p>In this case (where we are just wrapping a call to <code>range</code>) you can just use <code>tqdm.trange</code>.</p>&#13;
&#13;
<p>You can also set the description of the progress bar while it’s running. To do that,&#13;
you need to capture the <code>tqdm</code> iterator in a <code>with</code> statement:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">List</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">primes_up_to</code><code class="p">(</code><code class="n">n</code><code class="p">:</code> <code class="nb">int</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">List</code><code class="p">[</code><code class="nb">int</code><code class="p">]:</code>&#13;
    <code class="n">primes</code> <code class="o">=</code> <code class="p">[</code><code class="mi">2</code><code class="p">]</code>&#13;
&#13;
    <code class="k">with</code> <code class="n">tqdm</code><code class="o">.</code><code class="n">trange</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="n">n</code><code class="p">)</code> <code class="k">as</code> <code class="n">t</code><code class="p">:</code>&#13;
        <code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="n">t</code><code class="p">:</code>&#13;
            <code class="c1"># i is prime if no smaller prime divides it</code>&#13;
            <code class="n">i_is_prime</code> <code class="o">=</code> <code class="ow">not</code> <code class="nb">any</code><code class="p">(</code><code class="n">i</code> <code class="o">%</code> <code class="n">p</code> <code class="o">==</code> <code class="mi">0</code> <code class="k">for</code> <code class="n">p</code> <code class="ow">in</code> <code class="n">primes</code><code class="p">)</code>&#13;
            <code class="k">if</code> <code class="n">i_is_prime</code><code class="p">:</code>&#13;
                <code class="n">primes</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">i</code><code class="p">)</code>&#13;
&#13;
            <code class="n">t</code><code class="o">.</code><code class="n">set_description</code><code class="p">(</code><code class="n">f</code><code class="s2">"{len(primes)} primes"</code><code class="p">)</code>&#13;
&#13;
    <code class="k">return</code> <code class="n">primes</code>&#13;
&#13;
<code class="n">my_primes</code> <code class="o">=</code> <code class="n">primes_up_to</code><code class="p">(</code><code class="mi">100</code><code class="n">_000</code><code class="p">)</code></pre>&#13;
&#13;
<p>This adds a description like the following, with a counter that updates as new primes are discovered:</p>&#13;
&#13;
<pre data-type="programlisting">5116 primes:  50%|████████        | 49529/99997 [00:03&lt;00:03, 15905.90it/s]</pre>&#13;
&#13;
<p>Using <code>tqdm</code> will occasionally make your code flaky—sometimes the screen redraws poorly, and sometimes the loop will simply hang. And if you accidentally wrap a <code>tqdm</code> loop inside another <code>tqdm</code> loop, strange things might happen. Typically its benefits outweigh these downsides, though, so we’ll try to use it whenever we have slow-running computations.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Dimensionality Reduction" data-type="sect1"><div class="sect1" id="principal_component_analysis">&#13;
<h1>Dimensionality Reduction</h1>&#13;
&#13;
<p>Sometimes<a data-primary="data" data-secondary="working with" data-tertiary="dimensionality reduction" data-type="indexterm" id="idm45635744637704"/><a data-primary="dimensionality reduction" data-type="indexterm" id="idm45635744636456"/> the “actual” (or useful) dimensions of the data might not correspond to the dimensions we have.  For example, consider the dataset pictured in <a data-type="xref" href="#scatter_pca_data">Figure 10-6</a>.</p>&#13;
&#13;
<figure><div class="figure" id="scatter_pca_data">&#13;
<img alt="Data with the 'wrong' axes" src="assets/dsf2_1006.png"/>&#13;
<h6><span class="label">Figure 10-6. </span>Data with the “wrong” axes</h6>&#13;
</div></figure>&#13;
&#13;
<p>Most of the variation in the data seems to be along a single dimension that doesn’t correspond to either the x-axis or the y-axis.</p>&#13;
&#13;
<p>When<a data-primary="principal component analysis (PCA)" data-type="indexterm" id="idm45635744631720"/> this is the case, we can use a technique called <em>principal component analysis</em> (PCA) to extract one or more dimensions that capture as much of the variation in the data as possible.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In practice, you wouldn’t use this technique on such a low-dimensional dataset. Dimensionality reduction is mostly useful when your dataset has a large number of dimensions and you want to find a small subset that captures most of the variation.  Unfortunately, that case is difficult to illustrate in a two-dimensional book format.</p>&#13;
</div>&#13;
&#13;
<p>As a first step, we’ll need to translate the data so that each dimension has mean 0:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">scratch.linear_algebra</code> <code class="kn">import</code> <code class="n">subtract</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">de_mean</code><code class="p">(</code><code class="n">data</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">Vector</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="n">List</code><code class="p">[</code><code class="n">Vector</code><code class="p">]:</code>&#13;
    <code class="sd">"""Recenters the data to have mean 0 in every dimension"""</code>&#13;
    <code class="n">mean</code> <code class="o">=</code> <code class="n">vector_mean</code><code class="p">(</code><code class="n">data</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="p">[</code><code class="n">subtract</code><code class="p">(</code><code class="n">vector</code><code class="p">,</code> <code class="n">mean</code><code class="p">)</code> <code class="k">for</code> <code class="n">vector</code> <code class="ow">in</code> <code class="n">data</code><code class="p">]</code></pre>&#13;
&#13;
<p>(If we don’t do this, our techniques are likely to identify the mean itself rather than the variation in the data.)</p>&#13;
&#13;
<p><a data-type="xref" href="#pca_data_mean_removed">Figure 10-7</a> shows the example<a data-primary="de-meaning data" data-type="indexterm" id="idm45635744585992"/> data after de-meaning.</p>&#13;
&#13;
<figure><div class="figure" id="pca_data_mean_removed">&#13;
<img alt="PCA data with mean removed." src="assets/dsf2_1007.png"/>&#13;
<h6><span class="label">Figure 10-7. </span>Data after de-meaning</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now, given a de-meaned matrix <em>X</em>, we can ask which is the direction that captures the greatest variance in the data.</p>&#13;
&#13;
<p>Specifically, given a direction <code>d</code> (a vector of magnitude 1), each row <code>x</code> in the matrix extends <code>dot(x, d)</code> in the <code>d</code> direction.  And every nonzero vector <code>w</code> determines a direction if we rescale it to have magnitude 1:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">scratch.linear_algebra</code> <code class="kn">import</code> <code class="n">magnitude</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">direction</code><code class="p">(</code><code class="n">w</code><code class="p">:</code> <code class="n">Vector</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Vector</code><code class="p">:</code>&#13;
    <code class="n">mag</code> <code class="o">=</code> <code class="n">magnitude</code><code class="p">(</code><code class="n">w</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="p">[</code><code class="n">w_i</code> <code class="o">/</code> <code class="n">mag</code> <code class="k">for</code> <code class="n">w_i</code> <code class="ow">in</code> <code class="n">w</code><code class="p">]</code></pre>&#13;
&#13;
<p>Therefore, given a nonzero vector <code>w</code>, we can compute the variance of our dataset in the direction determined by <code>w</code>:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">scratch.linear_algebra</code> <code class="kn">import</code> <code class="n">dot</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">directional_variance</code><code class="p">(</code><code class="n">data</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">Vector</code><code class="p">],</code> <code class="n">w</code><code class="p">:</code> <code class="n">Vector</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">float</code><code class="p">:</code>&#13;
    <code class="sd">"""</code>&#13;
<code class="sd">    Returns the variance of x in the direction of w</code>&#13;
<code class="sd">    """</code>&#13;
    <code class="n">w_dir</code> <code class="o">=</code> <code class="n">direction</code><code class="p">(</code><code class="n">w</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="nb">sum</code><code class="p">(</code><code class="n">dot</code><code class="p">(</code><code class="n">v</code><code class="p">,</code> <code class="n">w_dir</code><code class="p">)</code> <code class="o">**</code> <code class="mi">2</code> <code class="k">for</code> <code class="n">v</code> <code class="ow">in</code> <code class="n">data</code><code class="p">)</code></pre>&#13;
&#13;
<p>We’d like to find the direction that maximizes this variance.&#13;
We can do this using gradient descent, as soon as we have&#13;
the gradient function:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">def</code> <code class="nf">directional_variance_gradient</code><code class="p">(</code><code class="n">data</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">Vector</code><code class="p">],</code> <code class="n">w</code><code class="p">:</code> <code class="n">Vector</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Vector</code><code class="p">:</code>&#13;
    <code class="sd">"""</code>&#13;
<code class="sd">    The gradient of directional variance with respect to w</code>&#13;
<code class="sd">    """</code>&#13;
    <code class="n">w_dir</code> <code class="o">=</code> <code class="n">direction</code><code class="p">(</code><code class="n">w</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="p">[</code><code class="nb">sum</code><code class="p">(</code><code class="mi">2</code> <code class="o">*</code> <code class="n">dot</code><code class="p">(</code><code class="n">v</code><code class="p">,</code> <code class="n">w_dir</code><code class="p">)</code> <code class="o">*</code> <code class="n">v</code><code class="p">[</code><code class="n">i</code><code class="p">]</code> <code class="k">for</code> <code class="n">v</code> <code class="ow">in</code> <code class="n">data</code><code class="p">)</code>&#13;
            <code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">w</code><code class="p">))]</code></pre>&#13;
&#13;
<p>And now the first principal component that we have is just the direction that maximizes the <code>directional_variance</code> function:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">scratch.gradient_descent</code> <code class="kn">import</code> <code class="n">gradient_step</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">first_principal_component</code><code class="p">(</code><code class="n">data</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">Vector</code><code class="p">],</code>&#13;
                              <code class="n">n</code><code class="p">:</code> <code class="nb">int</code> <code class="o">=</code> <code class="mi">100</code><code class="p">,</code>&#13;
                              <code class="n">step_size</code><code class="p">:</code> <code class="nb">float</code> <code class="o">=</code> <code class="mf">0.1</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Vector</code><code class="p">:</code>&#13;
    <code class="c1"># Start with a random guess</code>&#13;
    <code class="n">guess</code> <code class="o">=</code> <code class="p">[</code><code class="mf">1.0</code> <code class="k">for</code> <code class="n">_</code> <code class="ow">in</code> <code class="n">data</code><code class="p">[</code><code class="mi">0</code><code class="p">]]</code>&#13;
&#13;
    <code class="k">with</code> <code class="n">tqdm</code><code class="o">.</code><code class="n">trange</code><code class="p">(</code><code class="n">n</code><code class="p">)</code> <code class="k">as</code> <code class="n">t</code><code class="p">:</code>&#13;
        <code class="k">for</code> <code class="n">_</code> <code class="ow">in</code> <code class="n">t</code><code class="p">:</code>&#13;
            <code class="n">dv</code> <code class="o">=</code> <code class="n">directional_variance</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> <code class="n">guess</code><code class="p">)</code>&#13;
            <code class="n">gradient</code> <code class="o">=</code> <code class="n">directional_variance_gradient</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> <code class="n">guess</code><code class="p">)</code>&#13;
            <code class="n">guess</code> <code class="o">=</code> <code class="n">gradient_step</code><code class="p">(</code><code class="n">guess</code><code class="p">,</code> <code class="n">gradient</code><code class="p">,</code> <code class="n">step_size</code><code class="p">)</code>&#13;
            <code class="n">t</code><code class="o">.</code><code class="n">set_description</code><code class="p">(</code><code class="n">f</code><code class="s2">"dv: {dv:.3f}"</code><code class="p">)</code>&#13;
&#13;
    <code class="k">return</code> <code class="n">direction</code><code class="p">(</code><code class="n">guess</code><code class="p">)</code></pre>&#13;
&#13;
<p>On the de-meaned dataset, this returns the direction <code>[0.924, 0.383]</code>, which does appear to capture the primary axis along which our data varies (<a data-type="xref" href="#pca_data_with_first_principal_component">Figure 10-8</a>).</p>&#13;
&#13;
<figure><div class="figure" id="pca_data_with_first_principal_component">&#13;
<img alt="PCA data with first component." src="assets/dsf2_1008.png"/>&#13;
<h6><span class="label">Figure 10-8. </span>First principal component</h6>&#13;
</div></figure>&#13;
&#13;
<p>Once we’ve found the direction that’s the first principal component, we can project our data onto it to find the values of that component:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">scratch.linear_algebra</code> <code class="kn">import</code> <code class="n">scalar_multiply</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">project</code><code class="p">(</code><code class="n">v</code><code class="p">:</code> <code class="n">Vector</code><code class="p">,</code> <code class="n">w</code><code class="p">:</code> <code class="n">Vector</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Vector</code><code class="p">:</code>&#13;
    <code class="sd">"""return the projection of v onto the direction w"""</code>&#13;
    <code class="n">projection_length</code> <code class="o">=</code> <code class="n">dot</code><code class="p">(</code><code class="n">v</code><code class="p">,</code> <code class="n">w</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="n">scalar_multiply</code><code class="p">(</code><code class="n">projection_length</code><code class="p">,</code> <code class="n">w</code><code class="p">)</code></pre>&#13;
&#13;
<p>If we want to find further components, we first remove the projections from the data:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">scratch.linear_algebra</code> <code class="kn">import</code> <code class="n">subtract</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">remove_projection_from_vector</code><code class="p">(</code><code class="n">v</code><code class="p">:</code> <code class="n">Vector</code><code class="p">,</code> <code class="n">w</code><code class="p">:</code> <code class="n">Vector</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Vector</code><code class="p">:</code>&#13;
    <code class="sd">"""projects v onto w and subtracts the result from v"""</code>&#13;
    <code class="k">return</code> <code class="n">subtract</code><code class="p">(</code><code class="n">v</code><code class="p">,</code> <code class="n">project</code><code class="p">(</code><code class="n">v</code><code class="p">,</code> <code class="n">w</code><code class="p">))</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">remove_projection</code><code class="p">(</code><code class="n">data</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">Vector</code><code class="p">],</code> <code class="n">w</code><code class="p">:</code> <code class="n">Vector</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">List</code><code class="p">[</code><code class="n">Vector</code><code class="p">]:</code>&#13;
    <code class="k">return</code> <code class="p">[</code><code class="n">remove_projection_from_vector</code><code class="p">(</code><code class="n">v</code><code class="p">,</code> <code class="n">w</code><code class="p">)</code> <code class="k">for</code> <code class="n">v</code> <code class="ow">in</code> <code class="n">data</code><code class="p">]</code></pre>&#13;
&#13;
<p>Because this example dataset is only two-dimensional, after we remove the first component, what’s left will be effectively one-dimensional (<a data-type="xref" href="#pca_data_with_first_component_removed">Figure 10-9</a>).</p>&#13;
&#13;
<figure><div class="figure" id="pca_data_with_first_component_removed">&#13;
<img alt="Data after removing first principal component" src="assets/dsf2_1009.png"/>&#13;
<h6><span class="label">Figure 10-9. </span>Data after removing the first principal component</h6>&#13;
</div></figure>&#13;
&#13;
<p>At that point, we can find the next principal component by repeating the process on the result of <code>remove_projection</code> (<a data-type="xref" href="#second_principal_component">Figure 10-10</a>).</p>&#13;
&#13;
<p>On a higher-dimensional dataset, we can iteratively find as many components as we want:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">def</code> <code class="nf">pca</code><code class="p">(</code><code class="n">data</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">Vector</code><code class="p">],</code> <code class="n">num_components</code><code class="p">:</code> <code class="nb">int</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">List</code><code class="p">[</code><code class="n">Vector</code><code class="p">]:</code>&#13;
    <code class="n">components</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">Vector</code><code class="p">]</code> <code class="o">=</code> <code class="p">[]</code>&#13;
    <code class="k">for</code> <code class="n">_</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="n">num_components</code><code class="p">):</code>&#13;
        <code class="n">component</code> <code class="o">=</code> <code class="n">first_principal_component</code><code class="p">(</code><code class="n">data</code><code class="p">)</code>&#13;
        <code class="n">components</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">component</code><code class="p">)</code>&#13;
        <code class="n">data</code> <code class="o">=</code> <code class="n">remove_projection</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> <code class="n">component</code><code class="p">)</code>&#13;
&#13;
    <code class="k">return</code> <code class="n">components</code></pre>&#13;
&#13;
<p>We can then <em>transform</em> our data into the lower-dimensional space spanned by the components:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">def</code> <code class="nf">transform_vector</code><code class="p">(</code><code class="n">v</code><code class="p">:</code> <code class="n">Vector</code><code class="p">,</code> <code class="n">components</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">Vector</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="n">Vector</code><code class="p">:</code>&#13;
    <code class="k">return</code> <code class="p">[</code><code class="n">dot</code><code class="p">(</code><code class="n">v</code><code class="p">,</code> <code class="n">w</code><code class="p">)</code> <code class="k">for</code> <code class="n">w</code> <code class="ow">in</code> <code class="n">components</code><code class="p">]</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">transform</code><code class="p">(</code><code class="n">data</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">Vector</code><code class="p">],</code> <code class="n">components</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">Vector</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="n">List</code><code class="p">[</code><code class="n">Vector</code><code class="p">]:</code>&#13;
    <code class="k">return</code> <code class="p">[</code><code class="n">transform_vector</code><code class="p">(</code><code class="n">v</code><code class="p">,</code> <code class="n">components</code><code class="p">)</code> <code class="k">for</code> <code class="n">v</code> <code class="ow">in</code> <code class="n">data</code><code class="p">]</code></pre>&#13;
&#13;
<p>This technique is valuable for a couple of reasons. First, it can help us clean our data by eliminating noise dimensions and consolidating highly correlated dimensions.</p>&#13;
&#13;
<figure><div class="figure" id="second_principal_component">&#13;
<img alt="First two principal components." src="assets/dsf2_1010.png"/>&#13;
<h6><span class="label">Figure 10-10. </span>First two principal components</h6>&#13;
</div></figure>&#13;
&#13;
<p>Second, after extracting a low-dimensional representation of our data, we can use a variety of techniques that don’t work as well on high-dimensional data.  We’ll see examples of such techniques throughout the book.</p>&#13;
&#13;
<p>At the same time, while this technique can help you build better models,&#13;
it can also make those models harder to interpret.  It’s easy to understand&#13;
conclusions like “every extra year of experience adds an average of $10k in salary.”&#13;
It’s much harder to make sense of “every increase of 0.1 in the third principal component&#13;
adds an average of $10k in salary.”</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="For Further Exploration" data-type="sect1"><div class="sect1" id="idm45635744638808">&#13;
<h1>For Further Exploration</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>As<a data-primary="data" data-secondary="working with" data-tertiary="resources for learning about" data-type="indexterm" id="idm45635743800520"/><a data-primary="pandas" data-type="indexterm" id="idm45635743799224"/> mentioned at the end of <a data-type="xref" href="ch09.html#getting_data">Chapter 9</a>, <a href="http://pandas.pydata.org/">pandas</a> is probably the primary Python tool&#13;
for cleaning, munging, manipulating, and working with data.&#13;
All the examples we did by hand in this chapter could&#13;
be done much more simply using pandas.&#13;
<a class="orm:hideurl" href="https://learning.oreilly.com/library/view/python-for-data/9781491957653/"><em>Python for Data Analysis</em></a> (O’Reilly), by Wes McKinney, is probably the best way to learn pandas.</p>&#13;
</li>&#13;
<li>&#13;
<p>scikit-learn has<a data-primary="scikit-learn" data-type="indexterm" id="idm45635743794776"/><a data-primary="data" data-secondary="working with" data-tertiary="tools for" data-type="indexterm" id="idm45635743794040"/><a data-primary="matrix decomposition functions" data-type="indexterm" id="idm45635743792824"/> a wide variety of <a href="https://scikit-learn.org/stable/modules/classes.html#module-sklearn.decomposition">matrix decomposition</a> functions, including PCA.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>