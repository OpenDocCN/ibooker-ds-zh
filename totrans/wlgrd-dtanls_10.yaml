- en: '11 Rapid prototyping: Creating the proof of concept'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Identifying tools to create proofs of concept
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Producing a proof of concept to showcase the reality of ideas in action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will build a proof of concept using data we explored and
    exported in the previous chapter. In chapter 10, we identified and explored Welsh
    property transactions, which will need to be presented as an interactive application
    to end users.
  prefs: []
  type: TYPE_NORMAL
- en: The data is available for you to attempt it yourself at [https://davidasboth.com/book-code](https://davidasboth.com/book-code).
    You will find the files you can use for the project, as well as the example solution
    in the form of a Jupyter notebook and Python scripts.
  prefs: []
  type: TYPE_NORMAL
- en: We have explored the available data, corrected issues, and identified visualizations
    to go into the proof of concept. In this chapter, we will build the proof of concept
    itself. First, let’s recap the project brief.
  prefs: []
  type: TYPE_NORMAL
- en: '11.1 Project 7 revisited: Building a proof of concept to investigate Welsh
    property prices'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’re working for CymruHomes Connect, a property company specializing in homes
    in Wales. They’re looking to expand their business with the help of data; they
    want to provide insights about the Welsh property market to customers in the form
    of a new app. This app would use historic property sales data to allow users to
    explore property prices in their area of interest. The stakeholders have some
    ideas they’d like to incorporate:'
  prefs: []
  type: TYPE_NORMAL
- en: They are particularly interested in the analysis of property types, that is,
    whether a house is terraced or detached because they believe it strongly influences
    their customers when choosing a property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They also believe users will be interested in comparing properties at the lowest
    level of granularity, so the ability to see street-level data is important.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s review the data we are working with and the work done so far.
  prefs: []
  type: TYPE_NORMAL
- en: 11.1.1 Data dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our stakeholders have discovered that the UK government’s Land Registry has
    a dataset called “Price Paid,” which contains publicly available historical sales
    data. They have extracted and made available a few years’ worth of this data.
    Table 11.1 shows the data dictionary, not of the original data, but the dataset
    we exported at the end of the previous chapter, which is what our proof of concept
    will use.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE  Original data comes from [https://mng.bz/yWvB](https://mng.bz/yWvB). It
    contains HM Land Registry data © Crown copyright and database right 2021\. This
    data is licensed under the Open Government Licence v3.0\. Thank you both to the
    Land Registry and Royal Mail for permission to use the house price and address
    data, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Table 11.1 Data dictionary of the modified Welsh property transaction data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Column | Definition |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `transaction_id`  | A reference number generated automatically, recording
    each published sale. The number is unique and will change each time a sale is
    recorded.  |'
  prefs: []
  type: TYPE_TB
- en: '| `sale_price`  | Sale price stated on the transfer deed.  |'
  prefs: []
  type: TYPE_TB
- en: '| `sale_date`  | Date when the sale was completed, as stated on the transfer
    deed.  |'
  prefs: []
  type: TYPE_TB
- en: '| `postcode`  | Postal code of the address.  |'
  prefs: []
  type: TYPE_TB
- en: '| `property_type`  | D = Detached, S = Semi-detached, T = Terraced, F = Flats/Maisonettes,
    O = Other  |'
  prefs: []
  type: TYPE_TB
- en: '| `old_new`  | Indicates the age of the property and applies to all Price Paid
    transactions, residential and nonresidential. Y = A newly built property, N =
    An established residential building  |'
  prefs: []
  type: TYPE_TB
- en: '| `duration`  | Relates to the tenure: F = Freehold, L= Leasehold  |'
  prefs: []
  type: TYPE_TB
- en: '| `house_number_name`  | Typically house number/name (e.g., 42 or “Oak Cottage”).  |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '| If there is a sub-building, for example, the building is divided into flats,
    there will be an SAON.  |'
  prefs: []
  type: TYPE_TB
- en: '| `street`  | The street part of the address.  |'
  prefs: []
  type: TYPE_TB
- en: '| `locality`  | Additional detail about the location (e.g., a district in a
    city).  |'
  prefs: []
  type: TYPE_TB
- en: '| `town_city`  | The town/city part of the address.  |'
  prefs: []
  type: TYPE_TB
- en: '| `district`  | The district part of the address.  |'
  prefs: []
  type: TYPE_TB
- en: '| `county`  | The county part of the address.  |'
  prefs: []
  type: TYPE_TB
- en: '| `category_type`  | Indicates the type of Price Paid transaction. A = Standard
    Price Paid entry; includes single residential property sold for full market value.'
  prefs: []
  type: TYPE_NORMAL
- en: B = Additional Price Paid entry; includes transfers under a power of sale/repossessions,
    buy-to-lets (where they can be identified by a mortgage) and transfers to nonprivate
    individuals.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `record_status`  | Relevant to monthly files only. Indicates additions, changes,
    and deletions to the records. Yearly files contain latest versions of all records.  |'
  prefs: []
  type: TYPE_TB
- en: '| `country`  | The country of the transaction. It can be England or Wales,
    but will all be Wales for the exported subset of data.  |'
  prefs: []
  type: TYPE_TB
- en: '| `year`  | The year of the transaction.  |'
  prefs: []
  type: TYPE_TB
- en: 11.1.2 Desired outcomes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our stakeholders initially want recommendations about what kind of analyses
    we could include in a potential app with the available data. Recommendations about
    additional data sources to incorporate would also be useful. Finally, we have
    decided to build a proof of concept, partly to show the stakeholders what their
    potential app might look like but also to test whether the data is sufficient
    to build a useful product.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s review our progress in the previous chapter before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: 11.1.3 Project summary so far
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous chapter, we
  prefs: []
  type: TYPE_NORMAL
- en: Merged multiple years of property sales data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Investigated the quality of the data, including missing values and outliers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identified geographic data of interest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Investigated the distribution and outliers of the sale price column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhanced our geographic data with external government data to separate English
    property transactions from Welsh ones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identified appropriate visualizations for our proof of concept, including a
    ridgeplot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exported the relevant, cleaned Welsh property transactions, which our proof
    of concept will use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 11.1 shows the analysis process so far.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/11-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 The project progress so far
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can now take the exported dataset of Welsh property transactions and use
    it to build our proof of concept in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2 Building a proof of concept
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have investigated the available data, extracted the relevant part,
    and explored it to understand what aspects to include in our proof of concept.
    Our action plan for building the proof of concept is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Choose a rapid prototyping tool *—This choice will depend on what we are familiar
    with and what is available in our usual toolkit.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Design the app layout *—We need to plan what the app is going to look like
    and how it will work before we start writing the code. Focusing on the end result
    means we minimize the amount of experimentation we need to do in building the
    proof of concept.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Write helper functions that extract and filter our data *—Abstracting away
    the data from the interactive part of the app will make it easier to change the
    frontend of the app if we need to, without having to rewrite the data access part.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Build the proof of concept *—By this point, we will have the functionality
    to read and filter the data, as well as a plan for what the app will look like.
    The final step is to build the proof of concept with the tool we decided on in
    step 1\.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first three steps are preparation for the final step of building the proof
    of concept.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2.1 Preparing to build a proof of concept
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s tackle the first step, which is choosing a prototyping tool. If you have
    not built a working proof of concept or prototype before, this is a good point
    at which to explore some of the options in your existing toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding on a rapid prototyping tool
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you are an R user, for example, you might explore Shiny’s capabilities.
    As a Python user, you also have a plethora of options available. This is another
    good opportunity to make use of a large language model to help you investigate
    the landscape. In this instance, I used Claude 3 Sonnet by Anthropic to show different
    options and not just ChatGPT. Here is the prompt I gave it:'
  prefs: []
  type: TYPE_NORMAL
- en: '*I want to build an interactive proof of concept for a data-driven app in Python.
    Please suggest libraries that could help me build a web-based interactive proof
    of concept with the following features:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*The ability to display visualizations, ideally using existing code that produces
    matplotlib charts.*'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Interactivity, i.e., dropdowns to filter the data, which will then refresh
    the page and all its visualizations.*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The app needs to be web based so that users do not need to install any software
    to get it working.*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*I will use the pandas library for data manipulation and matplotlib to create
    the charts, but ideally all the other features should be covered by a single additional
    library. Please provide a bulleted list of possible options and 1–2 sentences
    explaining each option.*'
  prefs: []
  type: TYPE_NORMAL
- en: Claude listed several options as the response, as shown in figure 11.2.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/11-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 Claude 3 Sonnet’s suggestions for rapid prototyping tools in Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: These are all solid options within the Python ecosystem, and all of them would
    be suitable for our proof of concept. I chose `streamlit`, mostly because I was
    already familiar with it. Otherwise, I would have spent some time reading the
    documentation of each library and evaluating the example code snippets to see
    which library would allow me to build the proof of concept the quickest.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start tracking the progress of this part of the project. Figure 11.3 shows
    the first step that we have just taken.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/11-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 The first step toward building the proof of concept
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that we have chosen our tool, let’s think about the app’s layout. If we
    know exactly what elements we want to add and where, then we can work in a results-driven
    way. We will only read the necessary part of the tool’s documentation and only
    work with elements we’re actually going to use.
  prefs: []
  type: TYPE_NORMAL
- en: Designing an app layout
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this part, we need to do two things: decide on what elements will go on
    the page and where they will go. We have more or less already decided on this,
    so let’s recap:'
  prefs: []
  type: TYPE_NORMAL
- en: There will be a ridgeplot showing price distribution by county for 2023\.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will be user filters for county, town, and street.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will show a line chart of transactions over time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will be two bar charts showing frequency and median sale price by property
    type, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Depending on the target audience, we might also want to show the raw data that
    powers the various charts and calculations. For internal tools, I would always
    consider doing this for two reasons: to build trust that the calculations are
    correct and allow stakeholders to export the underlying data to Excel, which they
    invariably end up wanting to do. For a customer-facing tool, this is perhaps not
    necessary, but since this is a proof of concept that will be evaluated by internal
    users, we’ll display the raw data as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We might also decide to display some summary metrics about the subset of properties
    the user has selected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exact placement of these elements is mostly a personal choice, but we should
    at least order them logically from top to bottom. First, the user should see components
    they cannot change, such as the ridgeplot. Then, any subsequent elements will
    depend on user inputs, so the next item down the page should be the county, town,
    and street dropdowns. After that, we will display the summary metrics and the
    charts, finishing off with the raw data table at the bottom. Apart from some explanatory
    text, this is all we need for our proof of concept. Figure 11.4 shows a basic
    wireframe mockup of what we want to build.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/11-4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 A mockup of a possible app layout
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Because this mockup includes some specific decisions we made, let’s add that
    to the diagram of this part of the project. The latest version is shown in figure
    11.5.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/11-5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 The latest progress of part 2 of the project
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that we have our tool and an idea for the layout, let’s write the data access
    part of our code. This is the code that the app will use to read our data and
    get its filtered versions based on user input.
  prefs: []
  type: TYPE_NORMAL
- en: Writing reusable helper functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In software development, it is generally a good idea to separate data access
    components from the presentation layer. It is good practice to do this even for
    simple proofs of concept because if they develop into prototypes and working applications,
    we will have a reusable data access layer to use at all stages.
  prefs: []
  type: TYPE_NORMAL
- en: Software development skills for analysts
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you work with code, you will benefit from learning about software best practices.
    Analysts don’t need to be software developers, but there are elements of writing
    good software that are relevant to data professionals.
  prefs: []
  type: TYPE_NORMAL
- en: Good software development practice means readability and reusability, first
    and foremost. Once you get into the habit of writing clean, reusable code, which
    is easy to change when the requirements inevitably change, you will find a marked
    improvement in productivity.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to find out more about software skills for data people, one excellent
    resource is Laszlo Sragner’s “Code Quality for Data Science,” a Discord community
    dedicated to teaching all data scientists, regardless of skill level, to write
    better code, available at [https://cq4ds.com](https://cq4ds.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our specific app, we will require functions for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading in our property data as a DataFrame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a list of counties, towns, and street names to populate the dropdowns
    from which the user will make their selections. These dropdowns should also depend
    on each other, meaning that, for example, when a user selects a county, the town/city
    dropdown should update to reflect only towns within that county.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating all necessary visualizations based on a filtered version of the data.
    These functions will return actual chart objects for the app to display.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s walk through each of the functions in the example solution, which can
    be found in a file called `helpers.py`. First, here is a simple function to read
    the data we prepared and exported earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the app will run when it first starts. Then, we need functions
    to populate each dropdown. Here is a function to return all possible counties
    in the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how this function doesn’t reference the Welsh properties directly; it
    simply returns all county values from any DataFrame it is given. That is because
    different components of the app should not depend on the specific implementation
    of the others. For example, the functionality to return a list of counties does
    not need to know where the underlying data came from. What follows is a list of
    towns based on a given county:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This function takes in a null value as an additional parameter, which is a special
    value for when a dropdown is deselected. If a user has selected a county and then
    a town but wants to go back to viewing data at the entire county level, they can
    select this null value in the town dropdown to clear it. This null value will
    read something like “no town selected,” so it is obvious to the user that they
    have cleared the town dropdown.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final dropdown will be a list of street names, which depend on both the
    county and the town/city:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need some functions to draw our charts. First, here is the number of
    transactions per year, which will be similar to the chart in figure 10.25:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Calculates number of records per year, where “YS” means “start of year”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to show the breakdown of property type. We want to show both
    the distribution of property types and the median price by property type. We could
    combine this information in a single chart, for example, by representing number
    of transactions as the length of a bar in bar chart and the median price by a
    color value. However, we want the app to be as easily understood as possible,
    so we will separate this information into two bar charts with the following two
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will include the ridgeplot we created in the previous chapter,
    so we need a helper function to create that as well. As we discovered, the ridgeplot
    requires data in a specific format, so we need a function to create that data
    and another to create the plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: These functions will then be imported into the app, which can use them to filter
    our data, populate the dropdowns, and display the correct visualization based
    on user input. Let’s add the creation of helper functions to our diagram to document
    our progress. This is shown in figure 11.6.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/11-6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 The latest progress in building the proof of concept
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now, it’s finally time to build the app itself, using our chosen tool and the
    app layout and helper functions we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2.2 Using streamlit to build a proof of concept
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have our tool of choice, `streamlit`, a desired layout, and helper functions
    to manage data access, filtering, and charts so we can build our proof of concept
    in a very targeted way. We need to figure out the basics of `streamlit` and only
    how to display text, dropdowns, charts, and tables. This means we will not be
    lost in a sea of tutorials and code samples—we will only take what we need.
  prefs: []
  type: TYPE_NORMAL
- en: We will now walk through the individual components of the final app, the code
    for which can be found in the file called `house_price_app.py`. To see the example
    solution’s final app in action, open a terminal or command prompt, activate the
    poetry environment with the command `poetry` `shell`, and then run the `streamlit`
    `run` `house_` `price_app.py` command, which should look like the example in figure
    11.7\. For more information on setting up your Python environment to reproduce
    the example solutions, see the appendix.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/11-7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 A command prompt window showing how to run the app in the example
    solution
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To build the app, we first set up some `streamlit` options and read in our data.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data into streamlit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, we will import the necessary libraries and set up some `streamlit` options,
    namely, that we want the page to be full width, which isn’t the default option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '#1 helpers in this context is the code in helpers.py that we wrote earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we read the property data as well as the data that will populate the
    county dropdown as that will not change dynamically. We can also read in the data
    that will power the ridgeplot since, again, that will not change. Optionally,
    we can also get `streamlit` to cache these datasets, which will mean they don’t
    get reloaded every time a user performs an action, such as changing a dropdown.
    We do this by wrapping the helper functions in small functions and annotating
    them with the `st.cache_data` decorator. The following is the code responsible
    for loading and caching the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Next, we define the layout of the app.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the app layout in streamlit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The apps will simply be `streamlit` elements defined in the order that we’d
    like the app to look from top to bottom—first, the title, brief explanation, and
    the ridgeplot. The following code builds these elements, and the relevant portion
    of the final app is shown in figure 11.8\. The full explanation is omitted from
    the code snippet for space reasons but is shown in the figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/11-8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 The first elements in the house price app proof of concept
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Next, we will add interactivity consisting of the three dropdowns that drill
    into specific geographic areas. By default, adding elements to `streamlit` will
    add them below the previous one. Since we want the dropdowns to be on the same
    row, we can create some columns and add the dropdowns to them to avoid this. Each
    dropdown will be a `streamlit` `selectbox` that will be populated using our helper
    functions. The dropdowns that depend on others will reference the value of the
    other dropdowns. That is, selecting a list of towns will depend on the value selected
    in the county dropdown, and that value will be passed to the `get_towns` helper
    function. The following code creates the three dropdowns in a three-column format,
    and the relevant section of the app is shown in figure 11.9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '#1 An example of the value the user selects if they want to clear a dropdown'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The currently selected county will be passed to the get_towns function.'
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/11-9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 The initial state of the geographic dropdowns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Figure 11.9 shows the initial state of the dropdowns. The town and street are
    light grey, meaning they are currently disabled until the user selects a county.
    Figure 11.10 shows the state of the dropdowns when some values are selected, as
    well as the options for the street.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/11-10.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.10 The geographic dropdowns with some values selected and the available
    values shown for the street**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, we need some code that will filter the raw data down to the correct geographic
    level based on the user’s selection.
  prefs: []
  type: TYPE_NORMAL
- en: Interactively filtering data in streamlit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Depending on your tool, this will look different, but here, we will utilize
    the `query` method in `pandas`, which lets us specify the filter to apply to our
    data as a single string. We can build up this query string based on how many dropdowns
    have a value selected. The more dropdowns the user has used, the longer the query
    string, the more specific the query, and the less data we will retrieve. The following
    code builds up this query string and applies it to the data. We also build up
    a message that will reflect the user’s choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, based on this filtered data, we can start calculating the summary metrics
    and create the charts as per our wireframe in figure 11.4\. To calculate the summary
    metrics, we need to work out the median sale price in the filtered data, as well
    as count the number of records returned. The following code does this, and only
    if the user has selected at least a county. An example of the message we built
    previously, as well as the summary metrics, is shown in figure 11.11:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Selecting a county is enough to trigger the widgets.'
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/11-11.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 A message showing geographic filters the user has applied and associated
    summary metrics
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now, we can use our helper methods to create the relevant charts.
  prefs: []
  type: TYPE_NORMAL
- en: Creating charts in streamlit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The charts will be alongside each other, so they need to be in `streamlit`
    columns again. Finally, we display the filtered data as a table at the bottom
    of the page. The following code finishes off our app. Because the entire bottom
    section depends on the user having selected at least a county, I have included
    the entire code block, which contains the summary metrics seen previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let’s see the final part of the app, which contains the summary metrics,
    charts, and underlying data. The raw data is truncated on the figure but is shown
    in full in the app. This is illustrated in figure 11.12.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/11-12.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 The bottom part of the finished proof of concept app with the raw
    data table truncated
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Before we communicate our conclusions, let’s review everything we’ve done in
    this project. Figure 11.13 shows the process of exploring and cleaning the data,
    leading to the design and development of the proof of concept app.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/11-13.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.13 The entire process, from exploration and analysis to building a
    proof of concept
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We have successfully delivered our minimum viable answer. It’s time to reflect
    on what we found and what the next steps are from here.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2.3 Project outcomes and next steps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We fulfilled the brief by investigating property types, where we found a disparity
    between what different property types sell for, and by investigating street-level
    data. We can confidently tell our stakeholders that the data is suitable for looking
    at both of those aspects. We then went above and beyond the brief by building
    a proof of concept to illustrate what their planned app might look like and whether
    it’s even feasible to build with the available data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few points to address about our proof of concept:'
  prefs: []
  type: TYPE_NORMAL
- en: First, there are missing values in relevant address fields. To launch and possibly
    charge money for an app like this, the data would need to be complete. To that
    end, we would need to clean the data and fill in the missing address details,
    perhaps using a third-party geocoding service such as the Google Maps API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, the app shows the charts associated with a user’s choices, even if there
    are only a few available records, as illustrated by figure 11.12\. Depending on
    what we believe the user will use the summary metrics and charts for, we may wish
    to issue a disclaimer in the app if the sample size of properties returned is
    too small.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if we iron some of these problems out and the proof of concept makes
    it to the prototype stage, we would need to user test it to make sure that users
    can find the relevant addresses. In this case, that would mean ensuring the values
    for county, town, and street are correctly categorized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When presenting this app to our stakeholders, we may also want to suggest improvements
    for a final version. Here are some ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: Users would probably want to investigate a property after seeing it on a property
    listing website, such as Rightmove or Zoopla. It might be useful to establish
    a link between those sites and our app. For example, a user might paste a link
    to a property on Rightmove into our app, which could then filter the data automatically
    based on that property’s address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other options for filtering the results automatically might be to simply enter
    an address or select it on an interactive map. This would save users time and
    make their experience smoother.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could enhance our address data with information about the local area that
    might affect property prices, such as crime rates or availability of utilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whatever we choose to do next, it would start with a presentation to our stakeholders
    and a discussion about whether to take this project further into the prototype
    phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Further project ideas with this data'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Think about other analyses you could do with this house price dataset. In particular,
    you might want to practice different approaches to building a proof of concept
    to develop your skills in this area. Here are some directions you may wish to
    go:'
  prefs: []
  type: TYPE_NORMAL
- en: Geographic data like this is perfect for map-based visualizations. You could
    create an application to identify transaction hotspots, areas of the country where
    there is a lot of “turnover” of properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there any seasonal patterns in property sales? Do these differ across different
    geographic areas?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By enhancing the data with demographic information (e.g., population data),
    you could see if there are places around the country where there are more property
    sales than is typical for an area of that size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.3 Closing thoughts on the rapid prototyping of ideas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in this project, it can be useful to extend an analysis by building
    a proof of concept from the available data. This is also true for building predictive
    models; rather than presenting accuracy metrics, these models can come alive if
    we can demonstrate how they would work in practice. Having a proof of concept
    and then a prototype also lets us identify problems with the data that would affect
    the building of a fully working product.
  prefs: []
  type: TYPE_NORMAL
- en: 'To hone your skills specifically in this area, there are a number of approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: The obvious one is to get familiar with a rapid prototyping tool. This could
    be building dashboards with a BI tool, such as Power BI or Tableau. It could be
    learning a library for your programming language, such as Shiny for R or `streamlit`
    for Python. Or, it could be learning about a “no code” platform, where you can
    make working applications without explicitly writing code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another skill that could help here, especially if you want to build working
    prototypes, is to learn about building for the web. Specifically, learning a bit
    of HTML, CSS, and JavaScript is useful to help craft bespoke web-based applications.
    Platforms such as the Web Design Playground ([https://www.manning.com/books/web-design-playground-second-edition](https://www.manning.com/books/web-design-playground-second-edition))
    are great for learning the basics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning design principles is also useful if you will be building proofs of
    concept and prototypes as part of your job. Knowing the fundamentals of UI and
    UX design principles, user flows, and storyboarding will help you build better
    prototypes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, the best way to learn this skill is by practicing it. Look for opportunities
    to build small, interactive applications to complement your analysis. They’ll
    be useful learning experiences both for you and the stakeholders you show them
    to.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3.1 Skills for rapid prototyping for any project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To build an interactive proof of concept based on available data, the key skills,
    which can be applied to any similar project, include
  prefs: []
  type: TYPE_NORMAL
- en: Focusing on the features of the prototype when exploring the available data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying the quality of our data since it will be exposed to external customers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing the data from reputable sources (e.g., using official city names)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring interesting variations in our data to identify what to focus on in
    the proof of concept
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying visualizations appropriate for the prototype and the intended audience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing an appropriate rapid prototyping tool with which to build a proof of
    concept
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the layout of the app as a wireframe before writing any code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing helper functions that the app can use but are not tightly coupled with
    the app code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a rapid prototyping tool such as `streamlit`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the desired layout in a prototyping tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying data and charts in your prototyping tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing for user interaction with the presented data and visualizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The journey from idea to working product should include the creation of proofs
    of concept and prototypes, both of which are areas where analysts can participate
    and are a useful addition to an analyst’s toolkit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proofs of concept and prototypes are an effective way to bring an analysis to
    life for stakeholders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a tool for creating proofs of concept should depend on the existing
    tools available, how the audience will interact with the end product, and the
    speed at which a proof of concept can be created with the chosen tool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rapid prototyping also requires a results-driven approach to ensure only necessary
    functionality is built in initial versions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
