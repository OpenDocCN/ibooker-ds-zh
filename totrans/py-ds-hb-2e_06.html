<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 4. Understanding Data Types in Python" data-type="chapter" epub:type="chapter"><div class="chapter" id="section-0201-understanding-data-types">
<h1><span class="label">Chapter 4. </span>Understanding Data Types in Python</h1>
<p><a data-primary="data types" data-type="indexterm" id="ix_ch04-asciidoc0"/><a data-primary="NumPy" data-secondary="data types in Python" data-type="indexterm" id="ix_ch04-asciidoc1"/>Effective data-driven science and computation requires understanding how
data is stored and manipulated. This chapter outlines and contrasts how
arrays of data are handled in the Python language itself, and how NumPy
improves on this. Understanding this difference is fundamental to
understanding much of the material throughout the rest of the book.</p>
<p><a data-primary="dynamic typing" data-type="indexterm" id="idm45858810513680"/><a data-primary="variables" data-secondary="dynamic typing" data-type="indexterm" id="idm45858810512976"/>Users of Python are often drawn in by its ease of use, one piece of
which is dynamic typing. While a statically typed language like C or
Java requires each variable to be explicitly declared, a dynamically
typed language like Python skips this specification. For example, in C
you might specify a particular operation as follows:</p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* C code */</code><code class="w"/>
<code class="kt">int</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="k">for</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">&lt;</code><code class="mi">100</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">){</code><code class="w"/>
<code class="w">    </code><code class="n">result</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>While in Python the equivalent operation could be written this way:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Python code</code>
<code class="n">result</code> <code class="o">=</code> <code class="mi">0</code>
<code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="mi">100</code><code class="p">):</code>
    <code class="n">result</code> <code class="o">+=</code> <code class="n">i</code></pre>
<p>Notice one main difference: in C, the data types of each variable are
explicitly declared, while in Python the types are dynamically inferred.
This means, for example, that we can assign any kind of data to any
variable:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Python code</code>
<code class="n">x</code> <code class="o">=</code> <code class="mi">4</code>
<code class="n">x</code> <code class="o">=</code> <code class="s2">"four"</code></pre>
<p>Here we’ve switched the contents of <code>x</code> from an integer to a
string. The same thing in C would lead (depending on compiler settings)
to a compilation error or other unintended consequences:</p>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* C code */</code><code class="w"/>
<code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">4</code><code class="p">;</code><code class="w"/>
<code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"four"</code><code class="p">;</code><code class="w">  </code><code class="c1">// FAILS</code></pre>
<p>This sort of flexibility is one element that makes Python and other
dynamically typed languages convenient and easy to use. Understanding
<em>how</em> this works is an important piece of learning to analyze data
efficiently and effectively with Python. But what this type flexibility
also points to is the fact that Python variables are more than just
their values; they also contain extra information about the <em>type</em> of
the value. We’ll explore this more in the sections that
follow.</p>
<section data-pdf-bookmark="A Python Integer Is More Than Just an Integer" data-type="sect1"><div class="sect1" id="ch_0201-understanding-data-types_a-python-integer-is-more-than-just-an-integer">
<h1>A Python Integer Is More Than Just an Integer</h1>
<p><a data-primary="data types" data-secondary="integers" data-type="indexterm" id="idm45858810306624"/><a data-primary="integers, Python" data-type="indexterm" id="idm45858810305648"/>The standard Python implementation is written in C. This means that
every Python object is simply a cleverly disguised C structure, which
contains not only its value, but other information as well. For example,
when we define an integer in Python, such as <code>x = 10000</code>, <code>x</code> is not
just a “raw” integer. It’s actually a pointer to a
compound C structure, which contains several values. Looking through the
Python 3.10 source code, we find that the integer (long) type definition
effectively looks like this (once the C macros are expanded):</p>
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">_longobject</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kt">long</code><code class="w"> </code><code class="n">ob_refcnt</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="n">PyTypeObject</code><code class="w"> </code><code class="o">*</code><code class="n">ob_type</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="kt">size_t</code><code class="w"> </code><code class="n">ob_size</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="kt">long</code><code class="w"> </code><code class="n">ob_digit</code><code class="p">[</code><code class="mi">1</code><code class="p">];</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>A single integer in Python 3.10 actually contains four pieces:</p>
<ul>
<li>
<p><code>ob_refcnt</code>, a reference count that helps Python silently handle
memory allocation and deallocation</p>
</li>
<li>
<p><code>ob_type</code>, which encodes the type of the variable</p>
</li>
<li>
<p><code>ob_size</code>, which specifies the size of the following data members</p>
</li>
<li>
<p><code>ob_digit</code>, which contains the actual integer value that we expect the
Python variable to represent</p>
</li>
</ul>
<p>This means that there is some overhead involved in storing an integer in
Python as compared to a compiled language like C, as illustrated in <a data-type="xref" href="#fig_images_in_cint_vs_pyint">Figure 4-1</a>.</p>
<figure><div class="figure" id="fig_images_in_cint_vs_pyint">
<img alt="cint vs pyint" height="265" src="assets/cint_vs_pyint.png" width="548"/>
<h6><span class="label">Figure 4-1. </span>The difference between C and Python integers</h6>
</div></figure>
<p>Here, <code>PyObject_HEAD</code> is the part of the structure containing the
reference count, type code, and other pieces mentioned before.</p>
<p>Notice the difference here: a C integer is essentially a label for a
position in memory whose bytes encode an integer value. A Python integer
is a pointer to a position in memory containing all the Python object
information, including the bytes that contain the integer value. This
extra information in the Python integer structure is what allows Python
to be coded so freely and dynamically. All this additional information
in Python types comes at a cost, however, which becomes especially
apparent in structures that combine many of these objects.</p>
</div></section>
<section data-pdf-bookmark="A Python List Is More Than Just a List" data-type="sect1"><div class="sect1" id="ch_0201-understanding-data-types_a-python-list-is-more-than-just-a-list">
<h1>A Python List Is More Than Just a List</h1>
<p><a data-primary="data types" data-secondary="lists" data-type="indexterm" id="ix_ch04-asciidoc2"/><a data-primary="lists, Python" data-secondary="about" data-type="indexterm" id="ix_ch04-asciidoc3"/>Let’s consider now what happens when we use a Python data
structure that holds many Python objects. The standard mutable
multielement container in Python is the list. We can create a list of
integers as follows:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="n">L</code> <code class="o">=</code> <code class="nb">list</code><code class="p">(</code><code class="nb">range</code><code class="p">(</code><code class="mi">10</code><code class="p">))</code>
        <code class="n">L</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">9</code><code class="p">]</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="nb">type</code><code class="p">(</code><code class="n">L</code><code class="p">[</code><code class="mi">0</code><code class="p">])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="nb">int</code></pre>
<p>Or, similarly, a list of strings:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="n">L2</code> <code class="o">=</code> <code class="p">[</code><code class="nb">str</code><code class="p">(</code><code class="n">c</code><code class="p">)</code> <code class="k">for</code> <code class="n">c</code> <code class="ow">in</code> <code class="n">L</code><code class="p">]</code>
        <code class="n">L2</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="p">[</code><code class="s1">'0'</code><code class="p">,</code> <code class="s1">'1'</code><code class="p">,</code> <code class="s1">'2'</code><code class="p">,</code> <code class="s1">'3'</code><code class="p">,</code> <code class="s1">'4'</code><code class="p">,</code> <code class="s1">'5'</code><code class="p">,</code> <code class="s1">'6'</code><code class="p">,</code> <code class="s1">'7'</code><code class="p">,</code> <code class="s1">'8'</code><code class="p">,</code> <code class="s1">'9'</code><code class="p">]</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="nb">type</code><code class="p">(</code><code class="n">L2</code><code class="p">[</code><code class="mi">0</code><code class="p">])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="nb">str</code></pre>
<p>Because of Python’s dynamic typing, we can even create
heterogeneous lists:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">L3</code> <code class="o">=</code> <code class="p">[</code><code class="kc">True</code><code class="p">,</code> <code class="s2">"2"</code><code class="p">,</code> <code class="mf">3.0</code><code class="p">,</code> <code class="mi">4</code><code class="p">]</code>
        <code class="p">[</code><code class="nb">type</code><code class="p">(</code><code class="n">item</code><code class="p">)</code> <code class="k">for</code> <code class="n">item</code> <code class="ow">in</code> <code class="n">L3</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="p">[</code><code class="nb">bool</code><code class="p">,</code> <code class="nb">str</code><code class="p">,</code> <code class="nb">float</code><code class="p">,</code> <code class="nb">int</code><code class="p">]</code></pre>
<p>But this flexibility comes at a cost: to allow these flexible types,
each item in the list must contain its own type, reference count, and
other information. That is, each item is a complete Python object. In
the special case that all variables are of the same type, much of this
information is redundant, so it can be much more efficient to store the
data in a fixed-type array. The difference between a dynamic-type list
and a fixed-type (NumPy-style) array is illustrated in <a data-type="xref" href="#fig_images_in_array_vs_list">Figure 4-2</a>.</p>
<figure><div class="figure" id="fig_images_in_array_vs_list">
<img alt="array vs list" height="796" src="assets/array_vs_list.png" width="600"/>
<h6><span class="label">Figure 4-2. </span>The difference between C and Python lists</h6>
</div></figure>
<p>At the implementation level, the array essentially contains a single
pointer to one contiguous block of data. The Python list, on the other
hand, contains a pointer to a block of pointers, each of which in turn
points to a full Python object like the Python integer we saw earlier.
Again, the advantage of the list is flexibility: because each list
element is a full structure containing both data and type information,
the list can be filled with data of any desired type. Fixed-type
NumPy-style arrays lack this flexibility, but are much more efficient
for storing and manipulating data.<a data-startref="ix_ch04-asciidoc3" data-type="indexterm" id="idm45858809929040"/><a data-startref="ix_ch04-asciidoc2" data-type="indexterm" id="idm45858809928336"/></p>
</div></section>
<section data-pdf-bookmark="Fixed-Type Arrays in Python" data-type="sect1"><div class="sect1" id="ch_0201-understanding-data-types_fixed-type-arrays-in-python">
<h1>Fixed-Type Arrays in Python</h1>
<p><a data-primary="arrays" data-secondary="fixed-type" data-type="indexterm" id="idm45858809926048"/><a data-primary="data types" data-secondary="fixed-type arrays" data-type="indexterm" id="idm45858809925072"/><a data-primary="fixed-type arrays" data-type="indexterm" id="idm45858809924128"/>Python offers several different options for storing data in efficient,
fixed-type data buffers. The built-in <code>array</code> module (available since
Python 3.3) can be used to create dense arrays of a uniform type:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">array</code>
        <code class="n">L</code> <code class="o">=</code> <code class="nb">list</code><code class="p">(</code><code class="nb">range</code><code class="p">(</code><code class="mi">10</code><code class="p">))</code>
        <code class="n">A</code> <code class="o">=</code> <code class="n">array</code><code class="o">.</code><code class="n">array</code><code class="p">(</code><code class="s1">'i'</code><code class="p">,</code> <code class="n">L</code><code class="p">)</code>
        <code class="n">A</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">array</code><code class="p">(</code><code class="s1">'i'</code><code class="p">,</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">9</code><code class="p">])</code></pre>
<p>Here, <code>'i'</code> is a type code indicating the
contents are integers.</p>
<p>Much more useful, however, is the <code>ndarray</code> object of the NumPy package.
While Python’s <code>array</code> object provides efficient storage of
array-based data, NumPy adds to this efficient <em>operations</em> on that
data. We will explore these operations in later chapters; next,
I’ll show you a few different ways of creating a NumPy
array.</p>
</div></section>
<section data-pdf-bookmark="Creating Arrays from Python Lists" data-type="sect1"><div class="sect1" id="ch_0201-understanding-data-types_creating-arrays-from-python-lists">
<h1>Creating Arrays from Python Lists</h1>
<p><a data-primary="arrays" data-secondary="creating from Python lists" data-type="indexterm" id="idm45858809866144"/><a data-primary="lists, Python" data-secondary="creating arrays from" data-type="indexterm" id="idm45858809865200"/>We’ll start with the standard NumPy import, under the alias
<code>np</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code></pre>
<p>Now we can use <code>np.array</code> to create arrays from Python lists:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="c1"># Integer array</code>
        <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code></pre>
<p>Remember that unlike Python lists, NumPy arrays can only contain data of
the same type. If the types do not match, NumPy will upcast them
according to its type promotion rules; here, integers are upcast to
floating point:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mf">3.14</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mf">3.14</code><code class="p">,</code> <code class="mf">4.</code>  <code class="p">,</code> <code class="mf">2.</code>  <code class="p">,</code> <code class="mf">3.</code>  <code class="p">])</code></pre>
<p class="pagebreak-before less_space">If we want to explicitly set the data type of the resulting array, we
can use the <code>dtype</code> keyword:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">],</code> <code class="n">dtype</code><code class="o">=</code><code class="n">np</code><code class="o">.</code><code class="n">float32</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mf">1.</code><code class="p">,</code> <code class="mf">2.</code><code class="p">,</code> <code class="mf">3.</code><code class="p">,</code> <code class="mf">4.</code><code class="p">],</code> <code class="n">dtype</code><code class="o">=</code><code class="n">float32</code><code class="p">)</code></pre>
<p>Finally, unlike Python lists, which are always one-dimensional
sequences, NumPy arrays can be multidimensional. Here’s one
way of initializing a multidimensional array using a list of lists:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="c1"># Nested lists result in multidimensional arrays</code>
         <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="nb">range</code><code class="p">(</code><code class="n">i</code><code class="p">,</code> <code class="n">i</code> <code class="o">+</code> <code class="mi">3</code><code class="p">)</code> <code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">6</code><code class="p">]])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">],</code>
                <code class="p">[</code><code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">],</code>
                <code class="p">[</code><code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">8</code><code class="p">]])</code></pre>
<p>The inner lists are treated as rows of the resulting two-dimensional
array.</p>
</div></section>
<section data-pdf-bookmark="Creating Arrays from Scratch" data-type="sect1"><div class="sect1" id="ch_0201-understanding-data-types_creating-arrays-from-scratch">
<h1>Creating Arrays from Scratch</h1>
<p><a data-primary="arrays" data-secondary="creating from scratch" data-type="indexterm" id="idm45858809559584"/>Especially for larger arrays, it is more efficient to create arrays from
scratch using routines built into NumPy. Here are several examples:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="c1"># Create a length-10 integer array filled with 0s</code>
         <code class="n">np</code><code class="o">.</code><code class="n">zeros</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code> <code class="n">dtype</code><code class="o">=</code><code class="nb">int</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="c1"># Create a 3x5 floating-point array filled with 1s</code>
         <code class="n">np</code><code class="o">.</code><code class="n">ones</code><code class="p">((</code><code class="mi">3</code><code class="p">,</code> <code class="mi">5</code><code class="p">),</code> <code class="n">dtype</code><code class="o">=</code><code class="nb">float</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">],</code>
                <code class="p">[</code><code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">],</code>
                <code class="p">[</code><code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">]])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="c1"># Create a 3x5 array filled with 3.14</code>
         <code class="n">np</code><code class="o">.</code><code class="n">full</code><code class="p">((</code><code class="mi">3</code><code class="p">,</code> <code class="mi">5</code><code class="p">),</code> <code class="mf">3.14</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mf">3.14</code><code class="p">,</code> <code class="mf">3.14</code><code class="p">,</code> <code class="mf">3.14</code><code class="p">,</code> <code class="mf">3.14</code><code class="p">,</code> <code class="mf">3.14</code><code class="p">],</code>
                <code class="p">[</code><code class="mf">3.14</code><code class="p">,</code> <code class="mf">3.14</code><code class="p">,</code> <code class="mf">3.14</code><code class="p">,</code> <code class="mf">3.14</code><code class="p">,</code> <code class="mf">3.14</code><code class="p">],</code>
                <code class="p">[</code><code class="mf">3.14</code><code class="p">,</code> <code class="mf">3.14</code><code class="p">,</code> <code class="mf">3.14</code><code class="p">,</code> <code class="mf">3.14</code><code class="p">,</code> <code class="mf">3.14</code><code class="p">]])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="c1"># Create an array filled with a linear sequence</code>
         <code class="c1"># starting at 0, ending at 20, stepping by 2</code>
         <code class="c1"># (this is similar to the built-in range function)</code>
         <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">20</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code> <code class="mi">0</code><code class="p">,</code>  <code class="mi">2</code><code class="p">,</code>  <code class="mi">4</code><code class="p">,</code>  <code class="mi">6</code><code class="p">,</code>  <code class="mi">8</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">12</code><code class="p">,</code> <code class="mi">14</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">18</code><code class="p">])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="c1"># Create an array of five values evenly spaced between 0 and 1</code>
         <code class="n">np</code><code class="o">.</code><code class="n">linspace</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">5</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mf">0.</code>  <code class="p">,</code> <code class="mf">0.25</code><code class="p">,</code> <code class="mf">0.5</code> <code class="p">,</code> <code class="mf">0.75</code><code class="p">,</code> <code class="mf">1.</code>  <code class="p">])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="c1"># Create a 3x3 array of uniformly distributed</code>
         <code class="c1"># pseudorandom values between 0 and 1</code>
         <code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">random</code><code class="p">((</code><code class="mi">3</code><code class="p">,</code> <code class="mi">3</code><code class="p">))</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mf">0.09610171</code><code class="p">,</code> <code class="mf">0.88193001</code><code class="p">,</code> <code class="mf">0.70548015</code><code class="p">],</code>
                <code class="p">[</code><code class="mf">0.35885395</code><code class="p">,</code> <code class="mf">0.91670468</code><code class="p">,</code> <code class="mf">0.8721031</code> <code class="p">],</code>
                <code class="p">[</code><code class="mf">0.73237865</code><code class="p">,</code> <code class="mf">0.09708562</code><code class="p">,</code> <code class="mf">0.52506779</code><code class="p">]])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">18</code><code class="p">]:</code> <code class="c1"># Create a 3x3 array of normally distributed pseudorandom</code>
         <code class="c1"># values with mean 0 and standard deviation 1</code>
         <code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">normal</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="mi">3</code><code class="p">))</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">18</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="o">-</code><code class="mf">0.46652655</code><code class="p">,</code> <code class="o">-</code><code class="mf">0.59158776</code><code class="p">,</code> <code class="o">-</code><code class="mf">1.05392451</code><code class="p">],</code>
                <code class="p">[</code><code class="o">-</code><code class="mf">1.72634268</code><code class="p">,</code>  <code class="mf">0.03194069</code><code class="p">,</code> <code class="o">-</code><code class="mf">0.51048869</code><code class="p">],</code>
                <code class="p">[</code> <code class="mf">1.41240208</code><code class="p">,</code>  <code class="mf">1.77734462</code><code class="p">,</code> <code class="o">-</code><code class="mf">0.43820037</code><code class="p">]])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">19</code><code class="p">]:</code> <code class="c1"># Create a 3x3 array of pseudorandom integers in the interval [0, 10)</code>
         <code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">randint</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="mi">3</code><code class="p">))</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">19</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mi">4</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">8</code><code class="p">],</code>
                <code class="p">[</code><code class="mi">6</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">0</code><code class="p">],</code>
                <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">4</code><code class="p">]])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">20</code><code class="p">]:</code> <code class="c1"># Create a 3x3 identity matrix</code>
         <code class="n">np</code><code class="o">.</code><code class="n">eye</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">20</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mf">1.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">],</code>
                <code class="p">[</code><code class="mf">0.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">],</code>
                <code class="p">[</code><code class="mf">0.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">]])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">21</code><code class="p">]:</code> <code class="c1"># Create an uninitialized array of three integers; the values will be</code>
         <code class="c1"># whatever happens to already exist at that memory location</code>
         <code class="n">np</code><code class="o">.</code><code class="n">empty</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">21</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">])</code></pre>
</div></section>
<section data-pdf-bookmark="NumPy Standard Data Types" data-type="sect1"><div class="sect1" id="ch_0201-understanding-data-types_numpy-standard-data-types">
<h1>NumPy Standard Data Types</h1>
<p><a data-primary="arrays" data-secondary="standard data types" data-type="indexterm" id="idm45858808790256"/><a data-primary="data types" data-secondary="NumPy" data-type="indexterm" id="idm45858808789312"/><a data-primary="NumPy" data-secondary="standard data types" data-type="indexterm" id="idm45858808788368"/>NumPy arrays contain values of a single type, so it is important to have
detailed knowledge of those types and their limitations. Because NumPy
is built in C, the types will be familiar to users of C, Fortran, and
other related languages.</p>
<p>The standard NumPy data types are listed in <a data-type="xref" href="#table-4-1">Table 4-1</a>. Note
that when constructing an array, they can be specified using a string:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">np</code><code class="o">.</code><code class="n">zeros</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code> <code class="n">dtype</code><code class="o">=</code><code class="s1">'int16'</code><code class="p">)</code></pre>
<p>Or using the associated NumPy object:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">np</code><code class="o">.</code><code class="n">zeros</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code> <code class="n">dtype</code><code class="o">=</code><code class="n">np</code><code class="o">.</code><code class="n">int16</code><code class="p">)</code></pre>
<p>More advanced type specification is possible, such as specifying big- or
little-endian numbers; for more information, refer to the
<a href="http://numpy.org">NumPy documentation</a>. NumPy also supports compound
data types, which will be covered in
<a data-type="xref" href="ch12.xhtml#section-0209-structured-data-numpy">Chapter 12</a>.<a data-startref="ix_ch04-asciidoc1" data-type="indexterm" id="idm45858808711472"/><a data-startref="ix_ch04-asciidoc0" data-type="indexterm" id="idm45858808710800"/></p>
<table class="pagebreak-before less_space" id="table-4-1">
<caption><span class="label">Table 4-1. </span>Standard NumPy data types</caption>
<thead>
<tr>
<th>Data type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>bool_</code></p></td>
<td><p>Boolean (True or False) stored as a byte</p></td>
</tr>
<tr>
<td><p><code>int_</code></p></td>
<td><p>Default integer type (same as C <code>long</code>; normally either <code>int64</code>
or <code>int32</code>)</p></td>
</tr>
<tr>
<td><p><code>intc</code></p></td>
<td><p>Identical to C <code>int</code> (normally <code>int32</code> or <code>int64</code>)</p></td>
</tr>
<tr>
<td><p><code>intp</code></p></td>
<td><p>Integer used for indexing (same as C <code>ssize_t</code>; normally either
<code>int32</code> or <code>int64</code>)</p></td>
</tr>
<tr>
<td><p><code>int8</code></p></td>
<td><p>Byte (–128 to 127)</p></td>
</tr>
<tr>
<td><p><code>int16</code></p></td>
<td><p>Integer (–32768 to 32767)</p></td>
</tr>
<tr>
<td><p><code>int32</code></p></td>
<td><p>Integer (–2147483648 to 2147483647)</p></td>
</tr>
<tr>
<td><p><code>int64</code></p></td>
<td><p>Integer (–9223372036854775808 to 9223372036854775807)</p></td>
</tr>
<tr>
<td><p><code>uint8</code></p></td>
<td><p>Unsigned integer (0 to 255)</p></td>
</tr>
<tr>
<td><p><code>uint16</code></p></td>
<td><p>Unsigned integer (0 to 65535)</p></td>
</tr>
<tr>
<td><p><code>uint32</code></p></td>
<td><p>Unsigned integer (0 to 4294967295)</p></td>
</tr>
<tr>
<td><p><code>uint64</code></p></td>
<td><p>Unsigned integer (0 to 18446744073709551615)</p></td>
</tr>
<tr>
<td><p><code>float_</code></p></td>
<td><p>Shorthand for <code>float64</code></p></td>
</tr>
<tr>
<td><p><code>float16</code></p></td>
<td><p>Half-precision float: sign bit, 5 bits exponent, 10 bits
mantissa</p></td>
</tr>
<tr>
<td><p><code>float32</code></p></td>
<td><p>Single-precision float: sign bit, 8 bits exponent, 23 bits
mantissa</p></td>
</tr>
<tr>
<td><p><code>float64</code></p></td>
<td><p>Double-precision float: sign bit, 11 bits exponent, 52 bits
mantissa</p></td>
</tr>
<tr>
<td><p><code>complex_</code></p></td>
<td><p>Shorthand for <code>complex128</code></p></td>
</tr>
<tr>
<td><p><code>complex64</code></p></td>
<td><p>Complex number, represented by two 32-bit floats</p></td>
</tr>
<tr>
<td><p><code>complex128</code></p></td>
<td><p>Complex number, represented by two 64-bit floats</p></td>
</tr>
</tbody>
</table>
</div></section>
</div></section></div></body></html>