<html><head></head><body>
<div id="sbo-rt-content"><div class="readable-text" id="p1">
<h1 class="readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">11</span></span> <span class="chapter-title-text">Rapid prototyping: Creating the proof of concept</span></h1>
</div>
<div class="introduction-summary">
<h3 class="introduction-header sigil_not_in_toc">This chapter covers</h3>
<ul>
<li class="readable-text" id="p2">Identifying tools to create proofs of concept</li>
<li class="readable-text" id="p3">Producing a proof of concept to showcase the reality of ideas in action</li>
</ul>
</div>
<div class="readable-text" id="p4">
<p>In this chapter, we will build a proof of concept using data we explored and exported in the previous chapter. In chapter 10, we identified and explored Welsh property transactions, which will need to be presented as an interactive application to end users.</p>
</div>
<div class="readable-text intended-text" id="p5">
<p>The data is available for you to attempt it yourself at <a href="https://davidasboth.com/book-code">https://davidasboth.com/book-code</a>. You will find the files you can use for the project, as well as the example solution in the form of a Jupyter notebook and Python scripts.</p>
</div>
<div class="readable-text intended-text" id="p6">
<p>We have explored the available data, corrected issues, and identified visualizations to go into the proof of concept. In this chapter, we will build the proof of concept itself. First, let’s recap the project brief.</p>
</div>
<div class="readable-text" id="p7">
<h2 class="readable-text-h2" id="sigil_toc_id_136"><span class="num-string">11.1</span> Project 7 revisited: Building a proof of concept to investigate Welsh property prices</h2>
</div>
<div class="readable-text" id="p8">
<p>You’re working for CymruHomes Connect, a property company specializing in homes in Wales. They’re looking to expand their business with the help of data; they want to provide insights about the Welsh property market to customers in the form of a new app. This app would use historic property sales data to allow users to explore property prices in their area of interest. The stakeholders have some ideas they’d like to incorporate:</p>
</div>
<ul>
<li class="readable-text" id="p9"> They are particularly interested in the analysis of property types, that is, whether a house is terraced or detached because they believe it strongly influences their customers when choosing a property. </li>
<li class="readable-text" id="p10"> They also believe users will be interested in comparing properties at the lowest level of granularity, so the ability to see street-level data is important. </li>
</ul>
<div class="readable-text" id="p11">
<p>Let’s review the data we are working with and the work done so far.</p>
</div>
<div class="readable-text" id="p12">
<h3 class="readable-text-h3" id="sigil_toc_id_137"><span class="num-string">11.1.1</span> Data dictionary</h3>
</div>
<div class="readable-text" id="p13">
<p>Our stakeholders have discovered that the UK government’s Land Registry has a dataset called “Price Paid,” which contains publicly available historical sales data. They have extracted and made available a few years’ worth of this data. Table 11.1 shows the data dictionary, not of the original data, but the dataset we exported at the end of the previous chapter, which is what our proof of concept will use.</p>
</div>
<div class="readable-text print-book-callout" id="p14">
<p><span class="print-book-callout-head">NOTE</span>  Original data comes from <a href="https://mng.bz/yWvB">https://mng.bz/yWvB</a>. It contains HM Land Registry data © Crown copyright and database right 2021. This data is licensed under the Open Government Licence v3.0. Thank you both to the Land Registry and Royal Mail for permission to use the house price and address data, respectively.</p>
</div>
<div class="browsable-container browsable-table-container framemaker-table-container" id="p15">
<h5 class="browsable-container-h5 sigil_not_in_toc"><span class="num-string">Table 11.1</span> Data dictionary of the modified Welsh property transaction data</h5>
<table>
<thead>
<tr>
<th>
<div>
         Column 
       </div></th>
<th>
<div>
         Definition 
       </div></th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>transaction_id</code> <br/></td>
<td>  A reference number generated automatically, recording each published sale. The number is unique and will change each time a sale is recorded. <br/></td>
</tr>
<tr>
<td> <code>sale_price</code> <br/></td>
<td>  Sale price stated on the transfer deed. <br/></td>
</tr>
<tr>
<td> <code>sale_date</code> <br/></td>
<td>  Date when the sale was completed, as stated on the transfer deed. <br/></td>
</tr>
<tr>
<td> <code>postcode</code> <br/></td>
<td>  Postal code of the address. <br/></td>
</tr>
<tr>
<td> <code>property_type</code> <br/></td>
<td>  D = Detached, S = Semi-detached, T = Terraced, F = Flats/Maisonettes, O = Other <br/></td>
</tr>
<tr>
<td> <code>old_new</code> <br/></td>
<td>  Indicates the age of the property and applies to all Price Paid transactions, residential and nonresidential. Y = A newly built property, N = An established residential building <br/></td>
</tr>
<tr>
<td> <code>duration</code> <br/></td>
<td>  Relates to the tenure: F = Freehold, L= Leasehold <br/></td>
</tr>
<tr>
<td> <code>house_number_name</code> <br/></td>
<td>  Typically house number/name (e.g., 42 or “Oak Cottage”). <br/></td>
</tr>
<tr>
<td> <pre>second_addressable_
object_name</pre> <br/></td>
<td>  If there is a sub-building, for example, the building is divided into flats, there will be an SAON. <br/></td>
</tr>
<tr>
<td> <code>street</code> <br/></td>
<td>  The street part of the address. <br/></td>
</tr>
<tr>
<td> <code>locality</code> <br/></td>
<td>  Additional detail about the location (e.g., a district in a city). <br/></td>
</tr>
<tr>
<td> <code>town_city</code> <br/></td>
<td>  The town/city part of the address. <br/></td>
</tr>
<tr>
<td> <code>district</code> <br/></td>
<td>  The district part of the address. <br/></td>
</tr>
<tr>
<td> <code>county</code> <br/></td>
<td>  The county part of the address. <br/></td>
</tr>
<tr>
<td> <code>category_type</code> <br/></td>
<td>  Indicates the type of Price Paid transaction. <br/>  A = Standard Price Paid entry; includes single residential property sold for full market value. <br/>  B = Additional Price Paid entry; includes transfers under a power of sale/repossessions, buy-to-lets (where they can be identified by a mortgage) and transfers to nonprivate individuals. <br/></td>
</tr>
<tr>
<td> <code>record_status</code> <br/></td>
<td>  Relevant to monthly files only. Indicates additions, changes, and deletions to the records. Yearly files contain latest versions of all records. <br/></td>
</tr>
<tr>
<td> <code>country</code> <br/></td>
<td>  The country of the transaction. It can be England or Wales, but will all be Wales for the exported subset of data. <br/></td>
</tr>
<tr>
<td> <code>year</code> <br/></td>
<td>  The year of the transaction. <br/></td>
</tr>
</tbody>
</table>
</div>
<div class="readable-text" id="p16">
<h3 class="readable-text-h3" id="sigil_toc_id_138"><span class="num-string">11.1.2</span> Desired outcomes</h3>
</div>
<div class="readable-text" id="p17">
<p>Our stakeholders initially want recommendations about what kind of analyses we could include in a potential app with the available data. Recommendations about additional data sources to incorporate would also be useful. Finally, we have decided to build a proof of concept, partly to show the stakeholders what their potential app might look like but also to test whether the data is sufficient to build a useful product.</p>
</div>
<div class="readable-text intended-text" id="p18">
<p>Let’s review our progress in the previous chapter before continuing.</p>
</div>
<div class="readable-text" id="p19">
<h3 class="readable-text-h3" id="sigil_toc_id_139"><span class="num-string">11.1.3</span> Project summary so far</h3>
</div>
<div class="readable-text" id="p20">
<p>In the previous chapter, we</p>
</div>
<ul>
<li class="readable-text" id="p21"> Merged multiple years of property sales data </li>
<li class="readable-text" id="p22"> Investigated the quality of the data, including missing values and outliers </li>
<li class="readable-text" id="p23"> Identified geographic data of interest </li>
<li class="readable-text" id="p24"> Investigated the distribution and outliers of the sale price column </li>
<li class="readable-text" id="p25"> Enhanced our geographic data with external government data to separate English property transactions from Welsh ones </li>
<li class="readable-text" id="p26"> Identified appropriate visualizations for our proof of concept, including a ridgeplot </li>
<li class="readable-text" id="p27"> Exported the relevant, cleaned Welsh property transactions, which our proof of concept will use </li>
</ul>
<div class="readable-text" id="p28">
<p>Figure 11.1 shows the analysis process so far.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p29">
<img alt="figure" height="1259" src="../Images/11-1.png" width="632"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 11.1</span> The project progress so far</h5>
</div>
<div class="readable-text" id="p30">
<p>We can now take the exported dataset of Welsh property transactions and use it to build our proof of concept in this chapter.</p>
</div>
<div class="readable-text" id="p31">
<h2 class="readable-text-h2" id="sigil_toc_id_140"><span class="num-string">11.2</span> Building a proof of concept</h2>
</div>
<div class="readable-text" id="p32">
<p>So far, we have investigated the available data, extracted the relevant part, and explored it to understand what aspects to include in our proof of concept. Our action plan for building the proof of concept is as follows:</p>
</div>
<ol>
<li class="readable-text" id="p33"> <em>Choose a rapid prototyping tool </em>—This choice will depend on what we are familiar with and what is available in our usual toolkit. </li>
<li class="readable-text" id="p34"> <em>Design the app layout </em>—We need to plan what the app is going to look like and how it will work before we start writing the code. Focusing on the end result means we minimize the amount of experimentation we need to do in building the proof of concept. </li>
<li class="readable-text" id="p35"> <em>Write helper functions that extract and filter our data </em>—Abstracting away the data from the interactive part of the app will make it easier to change the frontend of the app if we need to, without having to rewrite the data access part. </li>
<li class="readable-text" id="p36"> <em>Build the proof of concept </em>—By this point, we will have the functionality to read and filter the data, as well as a plan for what the app will look like. The final step is to build the proof of concept with the tool we decided on in step 1. </li>
</ol>
<div class="readable-text" id="p37">
<p>The first three steps are preparation for the final step of building the proof of concept.</p>
</div>
<div class="readable-text" id="p38">
<h3 class="readable-text-h3" id="sigil_toc_id_141"><span class="num-string">11.2.1</span> Preparing to build a proof of concept</h3>
</div>
<div class="readable-text" id="p39">
<p>Let’s tackle the first step, which is choosing a prototyping tool. If you have not built a working proof of concept or prototype before, this is a good point at which to explore some of the options in your existing toolkit.</p>
</div>
<div class="readable-text" id="p40">
<h4 class="readable-text-h4 sigil_not_in_toc">Deciding on a rapid prototyping tool</h4>
</div>
<div class="readable-text" id="p41">
<p>If you are an R user, for example, you might explore Shiny’s capabilities. As a Python user, you also have a plethora of options available. This is another good opportunity to make use of a large language model to help you investigate the landscape. In this instance, I used Claude 3 Sonnet by Anthropic to show different options and not just ChatGPT. Here is the prompt I gave it:</p>
</div>
<div class="readable-text prompt" id="p42">
<p><em>I want to build an interactive proof of concept for a data-driven app in Python. Please suggest libraries that could help me build a web-based interactive proof of concept with the following features:</em></p>
</div>
<ul>
<li class="buletless-item" style="list-style-type: none;">
<ul>
<li class="readable-text prompt" id="p43"> <em>The ability to display visualizations, ideally using existing code that produces matplotlib charts.</em> </li>
<li class="readable-text prompt" id="p44"> <em>Interactivity, i.e., dropdowns to filter the data, which will then refresh the page and all its visualizations.</em> </li>
<li class="readable-text prompt" id="p45"> <em>The app needs to be web based so that users do not need to install any software to get it working.</em> </li>
</ul></li>
</ul>
<div class="readable-text prompt" id="p46">
<p><em>I will use the pandas library for data manipulation and matplotlib to create the charts, but ideally all the other features should be covered by a single additional library. Please provide a bulleted list of possible options and 1–2 sentences explaining each option.</em></p>
</div>
<div class="readable-text" id="p47">
<p>Claude listed several options as the response, as shown in figure 11.2.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p48">
<img alt="figure" height="746" src="../Images/11-2.png" width="800"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 11.2</span> Claude 3 Sonnet’s suggestions for rapid prototyping tools in Python</h5>
</div>
<div class="readable-text" id="p49">
<p>These are all solid options within the Python ecosystem, and all of them would be suitable for our proof of concept. I chose <code>streamlit</code>, mostly because I was already familiar with it. Otherwise, I would have spent some time reading the documentation of each library and evaluating the example code snippets to see which library would allow me to build the proof of concept the quickest.</p>
</div>
<div class="readable-text intended-text" id="p50">
<p>Let’s start tracking the progress of this part of the project. Figure 11.3 shows the first step that we have just taken.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p51">
<img alt="figure" height="600" src="../Images/11-3.png" width="1029"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 11.3</span> The first step toward building the proof of concept</h5>
</div>
<div class="readable-text intended-text" id="p52">
<p>Now that we have chosen our tool, let’s think about the app’s layout. If we know exactly what elements we want to add and where, then we can work in a results-driven way. We will only read the necessary part of the tool’s documentation and only work with elements we’re actually going to use.</p>
</div>
<div class="readable-text" id="p53">
<h4 class="readable-text-h4 sigil_not_in_toc">Designing an app layout</h4>
</div>
<div class="readable-text" id="p54">
<p>In this part, we need to do two things: decide on what elements will go on the page and where they will go. We have more or less already decided on this, so let’s recap:</p>
</div>
<ul>
<li class="readable-text" id="p55"> There will be a ridgeplot showing price distribution by county for 2023. </li>
<li class="readable-text" id="p56"> There will be user filters for county, town, and street. </li>
<li class="readable-text" id="p57"> We will show a line chart of transactions over time. </li>
<li class="readable-text" id="p58"> There will be two bar charts showing frequency and median sale price by property type, respectively. </li>
<li class="readable-text" id="p59"> Depending on the target audience, we might also want to show the raw data that powers the various charts and calculations. For internal tools, I would always consider doing this for two reasons: to build trust that the calculations are correct and allow stakeholders to export the underlying data to Excel, which they invariably end up wanting to do. For a customer-facing tool, this is perhaps not necessary, but since this is a proof of concept that will be evaluated by internal users, we’ll display the raw data as well. </li>
<li class="readable-text" id="p60"> We might also decide to display some summary metrics about the subset of properties the user has selected. </li>
</ul>
<div class="readable-text" id="p61">
<p>The exact placement of these elements is mostly a personal choice, but we should at least order them logically from top to bottom. First, the user should see components they cannot change, such as the ridgeplot. Then, any subsequent elements will depend on user inputs, so the next item down the page should be the county, town, and street dropdowns. After that, we will display the summary metrics and the charts, finishing off with the raw data table at the bottom. Apart from some explanatory text, this is all we need for our proof of concept. Figure 11.4 shows a basic wireframe mockup of what we want to build.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p62">
<img alt="figure" height="652" src="../Images/11-4.png" width="542"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 11.4</span> A mockup of a possible app layout</h5>
</div>
<div class="readable-text intended-text" id="p63">
<p>Because this mockup includes some specific decisions we made, let’s add that to the diagram of this part of the project. The latest version is shown in figure 11.5.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p64">
<img alt="figure" height="867" src="../Images/11-5.png" width="996"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 11.5</span> The latest progress of part 2 of the project</h5>
</div>
<div class="readable-text" id="p65">
<p>Now that we have our tool and an idea for the layout, let’s write the data access part of our code. This is the code that the app will use to read our data and get its filtered versions based on user input.</p>
</div>
<div class="readable-text" id="p66">
<h4 class="readable-text-h4 sigil_not_in_toc">Writing reusable helper functions</h4>
</div>
<div class="readable-text" id="p67">
<p>In software development, it is generally a good idea to separate data access components from the presentation layer. It is good practice to do this even for simple proofs of concept because if they develop into prototypes and working applications, we will have a reusable data access layer to use at all stages.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p68">
<h5 class="callout-container-h5 readable-text-h5 sigil_not_in_toc">Software development skills for analysts</h5>
</div>
<div class="readable-text" id="p69">
<p>If you work with code, you will benefit from learning about software best practices. Analysts don’t need to be software developers, but there are elements of writing good software that are relevant to data professionals.</p>
</div>
<div class="readable-text" id="p70">
<p>Good software development practice means readability and reusability, first and foremost. Once you get into the habit of writing clean, reusable code, which is easy to change when the requirements inevitably change, you will find a marked improvement in productivity.</p>
</div>
<div class="readable-text" id="p71">
<p>If you want to find out more about software skills for data people, one excellent resource is Laszlo Sragner’s “Code Quality for Data Science,” a Discord community dedicated to teaching all data scientists, regardless of skill level, to write better code, available at <a href="https://cq4ds.com">https://cq4ds.com</a>.</p>
</div>
</div>
<div class="readable-text" id="p72">
<p>In our specific app, we will require functions for the following:</p>
</div>
<ul>
<li class="readable-text" id="p73"> Reading in our property data as a DataFrame. </li>
<li class="readable-text" id="p74"> Getting a list of counties, towns, and street names to populate the dropdowns from which the user will make their selections. These dropdowns should also depend on each other, meaning that, for example, when a user selects a county, the town/city dropdown should update to reflect only towns within that county. </li>
<li class="readable-text" id="p75"> Creating all necessary visualizations based on a filtered version of the data. These functions will return actual chart objects for the app to display. </li>
</ul>
<div class="readable-text" id="p76">
<p>Let’s walk through each of the functions in the example solution, which can be found in a file called <code>helpers.py</code>. First, here is a simple function to read the data we prepared and exported earlier:</p>
</div>
<div class="browsable-container listing-container" id="p77">
<div class="code-area-container">
<pre class="code-area">import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from ridgeplot import ridgeplot

def load_price_data():
    return pd.read_parquet("./data/wales.parquet")</pre>
</div>
</div>
<div class="readable-text" id="p78">
<p>This is what the app will run when it first starts. Then, we need functions to populate each dropdown. Here is a function to return all possible counties in the data:</p>
</div>
<div class="browsable-container listing-container" id="p79">
<div class="code-area-container">
<pre class="code-area">def get_counties(df):
    return sorted(df["county"].unique())</pre>
</div>
</div>
<div class="readable-text" id="p80">
<p>Notice how this function doesn’t reference the Welsh properties directly; it simply returns all county values from any DataFrame it is given. That is because different components of the app should not depend on the specific implementation of the others. For example, the functionality to return a list of counties does not need to know where the underlying data came from. What follows is a list of towns based on a given county:</p>
</div>
<div class="browsable-container listing-container" id="p81">
<div class="code-area-container">
<pre class="code-area">def get_towns(df, county, null_value):
    if (not county) or (county == null_value):
        return []

    return (
        [null_value]
        + sorted(
            df.loc[df["county"] == county, "town_city"]
            .unique()
        )
    )</pre>
</div>
</div>
<div class="readable-text" id="p82">
<p>This function takes in a null value as an additional parameter, which is a special value for when a dropdown is deselected. If a user has selected a county and then a town but wants to go back to viewing data at the entire county level, they can select this null value in the town dropdown to clear it. This null value will read something like “no town selected,” so it is obvious to the user that they have cleared the town dropdown.</p>
</div>
<div class="readable-text intended-text" id="p83">
<p>The final dropdown will be a list of street names, which depend on both the county and the town/city:</p>
</div>
<div class="browsable-container listing-container" id="p84">
<div class="code-area-container">
<pre class="code-area">def get_streets(df, county, town, null_value):
    if (not (county and town)) or (town == null_value):
        return []

    return (
        [null_value] +
        sorted(
            df.loc[(df["county"] == county)
                   &amp; (df["town_city"] == town),
            "street"]
            .unique()
        )
    )</pre>
</div>
</div>
<div class="readable-text" id="p85">
<p>Now we need some functions to draw our charts. First, here is the number of transactions per year, which will be similar to the chart in figure 10.25:</p>
</div>
<div class="browsable-container listing-container" id="p86">
<div class="code-area-container">
<pre class="code-area">def transactions_per_year(df):
    fig, axis = plt.subplots()

    (
        df
        .set_index("sale_date")
        .resample("YS")     <span class="aframe-location"/> #1
        .size()
        .plot(ax=axis, color="gray", marker="x")
    )

    axis.set(
        ylabel="# of transactions"
    )

    return fig</pre>
<div class="code-annotations-overlay-container">
     #1 Calculates number of records per year, where “YS” means “start of year”
     <br/>
</div>
</div>
</div>
<div class="readable-text" id="p87">
<p>Next, we want to show the breakdown of property type. We want to show both the distribution of property types and the median price by property type. We could combine this information in a single chart, for example, by representing number of transactions as the length of a bar in bar chart and the median price by a color value. However, we want the app to be as easily understood as possible, so we will separate this information into two bar charts with the following two functions:</p>
</div>
<div class="browsable-container listing-container" id="p88">
<div class="code-area-container">
<pre class="code-area">def distribution_of_property_type(df):    
    fig, axis = plt.subplots()

    (
        df["property_type"]
        .value_counts()
        .sort_values()
        .plot
        .barh(ax=axis, color="gray")
    )

    axis.set(
        xlabel="# of transactions"
    )

    return fig

def median_price_by_property_type(df):
    fig, axis = plt.subplots()

    (
        df
        .groupby("property_type")
        ["sale_price"]
        .median()
        .sort_values()
        .plot
        .barh(ax=axis, color="gray")
    )
    axis.set(
        xlabel="Median price (£)",
        ylabel=None
    )

    return fig</pre>
</div>
</div>
<div class="readable-text" id="p89">
<p>Finally, we will include the ridgeplot we created in the previous chapter, so we need a helper function to create that as well. As we discovered, the ridgeplot requires data in a specific format, so we need a function to create that data and another to create the plot:</p>
</div>
<div class="browsable-container listing-container" id="p90">
<div class="code-area-container">
<pre class="code-area">def get_county_ridgeplot_data(df, counties):
    sales_by_county = []

    for county in counties:
        prices = (
            df
            .loc[(df["county"] == county)
                 &amp; (df["sale_price"] &lt; 500_000)
                 &amp; (df["year"] == 2023),
            "sale_price"]
        )
        sales_by_county.append([prices])

    return sales_by_county

def county_ridgeplot(sales_by_county, counties):
    fig = ridgeplot(sales_by_county,
                    labels=counties,
                    colorscale="gray",
                    coloralpha=0.9,
                    colormode="mean-minmax",
                    spacing=0.7)

    fig.update_layout(
        title="Distribution of house sale prices in Wales in 2023, by county",
        height=650,
        width=950,
        font_size=12,
        plot_bgcolor="rgb(245, 245, 245)",
        xaxis_gridcolor="white",
        yaxis_gridcolor="white",
        xaxis_gridwidth=2,
        yaxis_title="County",
        xaxis_title="Sale price (£)",
        showlegend=False
    )

    return fig</pre>
</div>
</div>
<div class="readable-text" id="p91">
<p>These functions will then be imported into the app, which can use them to filter our data, populate the dropdowns, and display the correct visualization based on user input. Let’s add the creation of helper functions to our diagram to document our progress. This is shown in figure 11.6.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p92">
<img alt="figure" height="345" src="../Images/11-6.png" width="270"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 11.6</span> The latest progress in building the proof of concept</h5>
</div>
<div class="readable-text" id="p93">
<p>Now, it’s finally time to build the app itself, using our chosen tool and the app layout and helper functions we created earlier.</p>
</div>
<div class="readable-text" id="p94">
<h3 class="readable-text-h3" id="sigil_toc_id_142"><span class="num-string">11.2.2</span> Using streamlit to build a proof of concept</h3>
</div>
<div class="readable-text" id="p95">
<p>We have our tool of choice, <code>streamlit</code>, a desired layout, and helper functions to manage data access, filtering, and charts so we can build our proof of concept in a very targeted way. We need to figure out the basics of <code>streamlit</code> and only how to display text, dropdowns, charts, and tables. This means we will not be lost in a sea of tutorials and code samples—we will only take what we need.</p>
</div>
<div class="readable-text intended-text" id="p96">
<p>We will now walk through the individual components of the final app, the code for which can be found in the file called <code>house_price_app.py</code>. To see the example solution’s final app in action, open a terminal or command prompt, activate the poetry environment with the command <code>poetry</code> <code>shell</code>, and then run the <code>streamlit</code> <code>run</code> <code>house_</code> <code>price_app.py</code> command, which should look like the example in figure 11.7. For more information on setting up your Python environment to reproduce the example solutions, see the appendix.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p97">
<img alt="figure" height="234" src="../Images/11-7.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 11.7</span> A command prompt window showing how to run the app in the example solution</h5>
</div>
<div class="readable-text" id="p98">
<p>To build the app, we first set up some <code>streamlit</code> options and read in our data.</p>
</div>
<div class="readable-text" id="p99">
<h4 class="readable-text-h4 sigil_not_in_toc">Reading data into streamlit</h4>
</div>
<div class="readable-text" id="p100">
<p>First, we will import the necessary libraries and set up some <code>streamlit</code> options, namely, that we want the page to be full width, which isn’t the default option:</p>
</div>
<div class="browsable-container listing-container" id="p101">
<div class="code-area-container">
<pre class="code-area">import streamlit as st
import pandas as pd
import helpers     <span class="aframe-location"/> #1

st.set_page_config(layout="wide")</pre>
<div class="code-annotations-overlay-container">
     #1 helpers in this context is the code in helpers.py that we wrote earlier.
     <br/>
</div>
</div>
</div>
<div class="readable-text" id="p102">
<p>Next, we read the property data as well as the data that will populate the county dropdown as that will not change dynamically. We can also read in the data that will power the ridgeplot since, again, that will not change. Optionally, we can also get <code>streamlit</code> to cache these datasets, which will mean they don’t get reloaded every time a user performs an action, such as changing a dropdown. We do this by wrapping the helper functions in small functions and annotating them with the <code>st.cache_data</code> decorator. The following is the code responsible for loading and caching the data:</p>
</div>
<div class="browsable-container listing-container" id="p103">
<div class="code-area-container">
<pre class="code-area">@st.cache_data
def get_price_data():
    return helpers.load_price_data()

wales = get_price_data()

@st.cache_data
def get_counties(wales):
    return helpers.get_counties()

counties = get_counties(wales)

@st.cache_data
def get_county_data(wales, counties):
    return helpers.get_county_ridgeplot_data(wales, counties)

sales_by_county = get_county_data(wales, counties)</pre>
</div>
</div>
<div class="readable-text" id="p104">
<p>Next, we define the layout of the app.</p>
</div>
<div class="readable-text" id="p105">
<h4 class="readable-text-h4 sigil_not_in_toc">Defining the app layout in streamlit</h4>
</div>
<div class="readable-text" id="p106">
<p>The apps will simply be <code>streamlit</code> elements defined in the order that we’d like the app to look from top to bottom—first, the title, brief explanation, and the ridgeplot. The following code builds these elements, and the relevant portion of the final app is shown in figure 11.8. The full explanation is omitted from the code snippet for space reasons but is shown in the figure:</p>
</div>
<div class="browsable-container listing-container" id="p107">
<div class="code-area-container">
<pre class="code-area">st.title("House price explorer - Wales")
st.markdown("""This tool lets you explore...""")

st.plotly_chart(helpers.county_ridgeplot(sales_by_county, counties))<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p108">
<img alt="figure" height="1158" src="../Images/11-8.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 11.8</span> The first elements in the house price app proof of concept</h5>
</div>
<div class="readable-text" id="p109">
<p>Next, we will add interactivity consisting of the three dropdowns that drill into specific geographic areas. By default, adding elements to <code>streamlit</code> will add them below the previous one. Since we want the dropdowns to be on the same row, we can create some columns and add the dropdowns to them to avoid this. Each dropdown will be a <code>streamlit</code> <code>selectbox</code> that will be populated using our helper functions. The dropdowns that depend on others will reference the value of the other dropdowns. That is, selecting a list of towns will depend on the value selected in the county dropdown, and that value will be passed to the <code>get_towns</code> helper function. The following code creates the three dropdowns in a three-column format, and the relevant section of the app is shown in figure 11.9:</p>
</div>
<div class="browsable-container listing-container" id="p110">
<div class="code-area-container">
<pre class="code-area">st.header("Explore house prices at different levels")

select_col1, select_col2, select_col3 = st.columns(3)

with select_col1:
    county_select = st.selectbox(
        'Select a county:',
        helpers.get_counties(wales),
        index=None,
        placeholder="-- Select a county --"
    )

TOWN_NULL_VALUE = "-- No town selected --"   <span class="aframe-location"/> #1

with select_col2:
    town_select = st.selectbox(
        'Select a town:',
        helpers.get_towns(
            wales,
            county_select,    <span class="aframe-location"/> #2
            null_value=TOWN_NULL_VALUE),
        index=None,
        placeholder=TOWN_NULL_VALUE
    )

STREET_NULL_VALUE = "-- No street selected --"

with select_col3:
    street_select = st.selectbox(
        'Select a street:',
        helpers.get_streets(
            wales,
            county_select,
            town_select,
            null_value=STREET_NULL_VALUE),
        index=None,
        placeholder=STREET_NULL_VALUE
    )<span class="aframe-location"/></pre>
<div class="code-annotations-overlay-container">
     #1 An example of the value the user selects if they want to clear a dropdown
     <br/>#2 The currently selected county will be passed to the get_towns function.
     <br/>
</div>
</div>
</div>
<div class="browsable-container figure-container" id="p111">
<img alt="figure" height="163" src="../Images/11-9.png" width="868"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 11.9</span> The initial state of the geographic dropdowns</h5>
</div>
<div class="readable-text" id="p112">
<p>Figure 11.9 shows the initial state of the dropdowns. The town and street are light grey, meaning they are currently disabled until the user selects a county. Figure 11.10 shows the state of the dropdowns when some values are selected, as well as the options for the street.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p113">
<img alt="figure" height="428" src="../Images/11-10.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><strong><span class="num-string">Figure 11.10</span> The geographic dropdowns with some values selected and the available values shown for the street</strong></h5>
</div>
<div class="readable-text" id="p114">
<p>Next, we need some code that will filter the raw data down to the correct geographic level based on the user’s selection.</p>
</div>
<div class="readable-text" id="p115">
<h4 class="readable-text-h4 sigil_not_in_toc">Interactively filtering data in streamlit</h4>
</div>
<div class="readable-text" id="p116">
<p>Depending on your tool, this will look different, but here, we will utilize the <code>query</code> method in <code>pandas</code>, which lets us specify the filter to apply to our data as a single string. We can build up this query string based on how many dropdowns have a value selected. The more dropdowns the user has used, the longer the query string, the more specific the query, and the less data we will retrieve. The following code builds up this query string and applies it to the data. We also build up a message that will reflect the user’s choices:</p>
</div>
<div class="browsable-container listing-container" id="p117">
<div class="code-area-container">
<pre class="code-area">house_filter_query = "county == @county_select"
filter_message = f"Results for {county_select}"

if town_select and town_select != TOWN_NULL_VALUE:
    house_filter_query += " and town_city == @town_select"
    filter_message += f", {town_select}"

if street_select and street_select != STREET_NULL_VALUE:
    house_filter_query += " and street == @street_select"
    filter_message += f", {street_select}"

selected_data = wales.query(house_filter_query)</pre>
</div>
</div>
<div class="readable-text" id="p118">
<p>Next, based on this filtered data, we can start calculating the summary metrics and create the charts as per our wireframe in figure 11.4. To calculate the summary metrics, we need to work out the median sale price in the filtered data, as well as count the number of records returned. The following code does this, and only if the user has selected at least a county. An example of the message we built previously, as well as the summary metrics, is shown in figure 11.11:</p>
</div>
<div class="browsable-container listing-container" id="p119">
<div class="code-area-container">
<pre class="code-area">median_price = selected_data["sale_price"].median()

if county_select:  <span class="aframe-location"/> #1
    st.header(filter_message)

    metric_col1, metric_col2 = st.columns(2)
    metric_col1.metric("Number of records", f"{len(selected_data):,.0f}")
    metric_col2.metric("Median sale price", f"£{median_price:,.0f}")<span class="aframe-location"/></pre>
<div class="code-annotations-overlay-container">
     #1 Selecting a county is enough to trigger the widgets.
     <br/>
</div>
</div>
</div>
<div class="browsable-container figure-container" id="p120">
<img alt="figure" height="433" src="../Images/11-11.png" width="871"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 11.11</span> A message showing geographic filters the user has applied and associated summary metrics</h5>
</div>
<div class="readable-text" id="p121">
<p>Now, we can use our helper methods to create the relevant charts.</p>
</div>
<div class="readable-text" id="p122">
<h4 class="readable-text-h4 sigil_not_in_toc">Creating charts in streamlit</h4>
</div>
<div class="readable-text" id="p123">
<p>The charts will be alongside each other, so they need to be in <code>streamlit</code> columns again. Finally, we display the filtered data as a table at the bottom of the page. The following code finishes off our app. Because the entire bottom section depends on the user having selected at least a county, I have included the entire code block, which contains the summary metrics seen previously:</p>
</div>
<div class="browsable-container listing-container" id="p124">
<div class="code-area-container">
<pre class="code-area">if county_select:
    st.header(filter_message)

    metric_col1, metric_col2 = st.columns(2)
    metric_col1.metric("Number of records", f"{len(selected_data):,.0f}")
    metric_col2.metric("Median sale price", f"£{median_price:,.0f}")

    chart_col1, chart_col2, chart_col3 = st.columns(3)

    with chart_col1:
        st.subheader("Transactions over time")
        st.pyplot(helpers.transactions_per_year(selected_data))

    with chart_col2:
        st.subheader("Distribution of property type")
        st.pyplot(helpers.distribution_of_property_type(selected_data))

    with chart_col3:
        st.subheader("Median sale price by property type")
        st.pyplot(helpers.median_price_by_property_type(selected_data))

    st.header("Raw data")
    st.write(selected_data)</pre>
</div>
</div>
<div class="readable-text" id="p125">
<p>Finally, let’s see the final part of the app, which contains the summary metrics, charts, and underlying data. The raw data is truncated on the figure but is shown in full in the app. This is illustrated in figure 11.12.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p126">
<img alt="figure" height="1123" src="../Images/11-12.png" width="971"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 11.12</span> The bottom part of the finished proof of concept app with the raw data table truncated</h5>
</div>
<div class="readable-text intended-text" id="p127">
<p>Before we communicate our conclusions, let’s review everything we’ve done in this project. Figure 11.13 shows the process of exploring and cleaning the data, leading to the design and development of the proof of concept app.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p128">
<img alt="figure" height="1256" src="../Images/11-13.png" width="984"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 11.13</span> The entire process, from exploration and analysis to building a proof of concept</h5>
</div>
<div class="readable-text intended-text" id="p129">
<p>We have successfully delivered our minimum viable answer. It’s time to reflect on what we found and what the next steps are from here.</p>
</div>
<div class="readable-text" id="p130">
<h3 class="readable-text-h3" id="sigil_toc_id_143"><span class="num-string">11.2.3</span> Project outcomes and next steps</h3>
</div>
<div class="readable-text" id="p131">
<p>We fulfilled the brief by investigating property types, where we found a disparity between what different property types sell for, and by investigating street-level data. We can confidently tell our stakeholders that the data is suitable for looking at both of those aspects. We then went above and beyond the brief by building a proof of concept to illustrate what their planned app might look like and whether it’s even feasible to build with the available data.</p>
</div>
<div class="readable-text" id="p132">
<p>There are a few points to address about our proof of concept:</p>
</div>
<ul>
<li class="readable-text" id="p133"> First, there are missing values in relevant address fields. To launch and possibly charge money for an app like this, the data would need to be complete. To that end, we would need to clean the data and fill in the missing address details, perhaps using a third-party geocoding service such as the Google Maps API. </li>
<li class="readable-text" id="p134"> Second, the app shows the charts associated with a user’s choices, even if there are only a few available records, as illustrated by figure 11.12. Depending on what we believe the user will use the summary metrics and charts for, we may wish to issue a disclaimer in the app if the sample size of properties returned is too small. </li>
<li class="readable-text" id="p135"> Finally, if we iron some of these problems out and the proof of concept makes it to the prototype stage, we would need to user test it to make sure that users can find the relevant addresses. In this case, that would mean ensuring the values for county, town, and street are correctly categorized. </li>
</ul>
<div class="readable-text" id="p136">
<p>When presenting this app to our stakeholders, we may also want to suggest improvements for a final version. Here are some ideas:</p>
</div>
<ul>
<li class="readable-text" id="p137"> Users would probably want to investigate a property after seeing it on a property listing website, such as Rightmove or Zoopla. It might be useful to establish a link between those sites and our app. For example, a user might paste a link to a property on Rightmove into our app, which could then filter the data automatically based on that property’s address. </li>
<li class="readable-text" id="p138"> Other options for filtering the results automatically might be to simply enter an address or select it on an interactive map. This would save users time and make their experience smoother. </li>
<li class="readable-text" id="p139"> We could enhance our address data with information about the local area that might affect property prices, such as crime rates or availability of utilities. </li>
</ul>
<div class="readable-text" id="p140">
<p>Whatever we choose to do next, it would start with a presentation to our stakeholders and a discussion about whether to take this project further into the prototype phase.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p141">
<h5 class="callout-container-h5 readable-text-h5 sigil_not_in_toc">Activity: Further project ideas with this data</h5>
</div>
<div class="readable-text" id="p142">
<p>Think about other analyses you could do with this house price dataset. In particular, you might want to practice different approaches to building a proof of concept to develop your skills in this area. Here are some directions you may wish to go:</p>
</div>
<ul>
<li class="readable-text" id="p143"> Geographic data like this is perfect for map-based visualizations. You could create an application to identify transaction hotspots, areas of the country where there is a lot of “turnover” of properties. </li>
<li class="readable-text" id="p144"> Are there any seasonal patterns in property sales? Do these differ across different geographic areas? </li>
<li class="readable-text" id="p145"> By enhancing the data with demographic information (e.g., population data), you could see if there are places around the country where there are more property sales than is typical for an area of that size. </li>
</ul>
</div>
<div class="readable-text" id="p146">
<h2 class="readable-text-h2" id="sigil_toc_id_144"><span class="num-string">11.3</span> Closing thoughts on the rapid prototyping of ideas</h2>
</div>
<div class="readable-text" id="p147">
<p>As we saw in this project, it can be useful to extend an analysis by building a proof of concept from the available data. This is also true for building predictive models; rather than presenting accuracy metrics, these models can come alive if we can demonstrate how they would work in practice. Having a proof of concept and then a prototype also lets us identify problems with the data that would affect the building of a fully working product.</p>
</div>
<div class="readable-text intended-text" id="p148">
<p>To hone your skills specifically in this area, there are a number of approaches:</p>
</div>
<ul>
<li class="readable-text" id="p149"> The obvious one is to get familiar with a rapid prototyping tool. This could be building dashboards with a BI tool, such as Power BI or Tableau. It could be learning a library for your programming language, such as Shiny for R or <code>streamlit</code> for Python. Or, it could be learning about a “no code” platform, where you can make working applications without explicitly writing code. </li>
<li class="readable-text" id="p150"> Another skill that could help here, especially if you want to build working prototypes, is to learn about building for the web. Specifically, learning a bit of HTML, CSS, and JavaScript is useful to help craft bespoke web-based applications. Platforms such as the Web Design Playground (<a href="https://www.manning.com/books/web-design-playground-second-edition">https://www.manning.com/books/web-design-playground-second-edition</a>) are great for learning the basics. </li>
<li class="readable-text" id="p151"> Learning design principles is also useful if you will be building proofs of concept and prototypes as part of your job. Knowing the fundamentals of UI and UX design principles, user flows, and storyboarding will help you build better prototypes. </li>
</ul>
<div class="readable-text" id="p152">
<p>Of course, the best way to learn this skill is by practicing it. Look for opportunities to build small, interactive applications to complement your analysis. They’ll be useful learning experiences both for you and the stakeholders you show them to.</p>
</div>
<div class="readable-text" id="p153">
<h3 class="readable-text-h3" id="sigil_toc_id_145"><span class="num-string">11.3.1</span> Skills for rapid prototyping for any project</h3>
</div>
<div class="readable-text" id="p154">
<p>To build an interactive proof of concept based on available data, the key skills, which can be applied to any similar project, include</p>
</div>
<ul>
<li class="readable-text" id="p155"> Focusing on the features of the prototype when exploring the available data </li>
<li class="readable-text" id="p156"> Verifying the quality of our data since it will be exposed to external customers </li>
<li class="readable-text" id="p157"> Enhancing the data from reputable sources (e.g., using official city names) </li>
<li class="readable-text" id="p158"> Exploring interesting variations in our data to identify what to focus on in the proof of concept </li>
<li class="readable-text" id="p159"> Identifying visualizations appropriate for the prototype and the intended audience </li>
<li class="readable-text" id="p160"> Choosing an appropriate rapid prototyping tool with which to build a proof of concept </li>
<li class="readable-text" id="p161"> Designing the layout of the app as a wireframe before writing any code </li>
<li class="readable-text" id="p162"> Writing helper functions that the app can use but are not tightly coupled with the app code </li>
<li class="readable-text" id="p163"> Setting up a rapid prototyping tool such as <code>streamlit</code> </li>
<li class="readable-text" id="p164"> Implementing the desired layout in a prototyping tool </li>
<li class="readable-text" id="p165"> Displaying data and charts in your prototyping tool </li>
<li class="readable-text" id="p166"> Providing for user interaction with the presented data and visualizations </li>
</ul>
<div class="readable-text" id="p167">
<h2 class="readable-text-h2" id="sigil_toc_id_146">Summary</h2>
</div>
<ul>
<li class="readable-text" id="p168"> The journey from idea to working product should include the creation of proofs of concept and prototypes, both of which are areas where analysts can participate and are a useful addition to an analyst’s toolkit. </li>
<li class="readable-text" id="p169"> Proofs of concept and prototypes are an effective way to bring an analysis to life for stakeholders. </li>
<li class="readable-text" id="p170"> Choosing a tool for creating proofs of concept should depend on the existing tools available, how the audience will interact with the end product, and the speed at which a proof of concept can be created with the chosen tool. </li>
<li class="readable-text" id="p171"> Rapid prototyping also requires a results-driven approach to ensure only necessary functionality is built in initial versions. </li>
</ul>
</div></body></html>