- en: Chapter 9\. Excel Automation
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve learned how to replace typical Excel tasks with pandas ([Part II](index_split_013.html#filepos433190))
    and how to use Excel files both as a data source as well as a file format for
    your reports ([Part III](index_split_018.html#filepos863198)). This chapter kicks
    off [Part IV](index_split_023.html#filepos1235617), where we switch away from
    manipulating Excel files with the reader and writer packages and begin automating
    the Excel application with xlwings.
  prefs: []
  type: TYPE_NORMAL
- en: The main use case of xlwings is to build interactive applications where Excel
    spreadsheets act as the user interface, allowing you to call Python by clicking
    a button or calling a user-defined function—that’s the type of functionality that
    isn’t covered by the reader and writer packages. But that doesn’t mean that xlwings
    can’t be used to read and write files, as long as you are on either macOS or Windows
    and have Excel installed. One advantage that xlwings has in this area is the ability
    to truly edit Excel files, in all formats, without changing or losing any of the
    existing content or formatting. Another advantage is that you can read the cell
    values from an Excel workbook without the need to save it first. It can, however,
    also make perfect sense to use an Excel reader/writer package and xlwings together,
    as we will see when we pick up the reporting case study from [Chapter 7](index_split_019.html#filepos863345)
    one more time.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll start this chapter by introducing you to the Excel object model as well
    as xlwings: we’ll first learn the basics like connecting to a workbook or reading
    and writing cell values before digging a bit deeper to understand how converters
    and options allow us to work with pandas DataFrames and NumPy arrays. We also
    look at how to interact with charts, pictures, and defined names before moving
    on to the last section, which explains how xlwings works under the hood: this
    will give you the required knowledge to make your scripts performant as well as
    work around missing functionality. From this chapter on, you will need to run
    the code samples on either Windows or macOS, as they depend on a local installation
    of Microsoft Excel.[1](index_split_025.html#filepos1437419)'
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started with xlwings
  prefs: []
  type: TYPE_NORMAL
- en: One goal of xlwings is to serve as a drop-in replacement for VBA, allowing you
    to interact with Excel from Python on Windows and macOS. Since Excel’s grid is
    the perfect layout to display Python’s data structures like nested lists, NumPy
    arrays, and pandas DataFrames, one of xlwings’ core features is to make reading
    and writing them from and to Excel as easy as possible. I’ll start this section
    by introducing you to Excel as a data viewer—this is useful when you are interacting
    with DataFrames in a Jupyter notebook. I’ll then explain the Excel object model
    before exploring it interactively with xlwings. To wrap this section up, I’ll
    show you how to call VBA code that you may still have in legacy workbooks. Since
    xlwings is part of Anaconda, we don’t need to install it manually.
  prefs: []
  type: TYPE_NORMAL
- en: Using Excel as Data Viewer
  prefs: []
  type: TYPE_NORMAL
- en: 'You probably noticed in the previous chapters that by default, Jupyter notebooks
    hide the majority of data for bigger DataFrames and only show the top and bottom
    rows as well as the first and last few columns. One way to get a better feeling
    for your data is to plot it—this allows you to spot outliers or other irregularities.
    Sometimes, however, it’s just really helpful to be able to scroll through a data
    table. After reading [Chapter 7](index_split_019.html#filepos863345), you know
    how to use the `to_excel` method on your DataFrame. While this works, it can be
    a bit cumbersome: you need to give the Excel file a name, find it on the file
    system, open it, and, after making changes to your DataFrame, you need to close
    the Excel file and run the whole process again. A better idea may be to run `df.to_clipboard()`,
    which copies the DataFrame `df` to the clipboard, allowing you to paste it into
    Excel, but there is an even simpler way—use the `view` function that comes with
    xlwings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``1``]:``# First, let''s import the packages that we"ll use in this chapter``import``datetime``as``dt``import``xlwings``as``xw``import``pandas``as``pd``import``numpy``as``np`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``2``]:``# Let''s create a DataFrame based on pseudorandom numbers and``#
    with enough rows that only the head and tail are shown``df``=``pd``.``DataFrame``(``data``=``np``.``random``.``randn``(``100``,``5``),``columns``=``[``f``"Trial
    {i}"``for``i``in``range``(``1``,``6``)])``df`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[2]:      Trial 1   Trial 2   Trial 3   Trial 4   Trial 5         0  -1.313877 
    1.164258 -1.306419 -0.529533 -0.524978         1  -0.854415  0.022859 -0.246443
    -0.229146 -0.005493         2  -0.327510 -0.492201 -1.353566 -1.229236  0.024385
            3  -0.728083 -0.080525  0.628288 -0.382586 -0.590157         4  -1.227684 
    0.498541 -0.266466  0.297261 -1.297985         ..       ...       ...       ...      
    ...       ...         95 -0.903446  1.103650  0.033915  0.336871  0.345999        
    96 -1.354898 -1.290954 -0.738396 -1.102659  0.115076         97 -0.070092 -0.416991
    -0.203445 -0.686915 -1.163205         98 -1.201963  0.471854 -0.458501 -0.357171 
    1.954585         99  1.863610  0.214047 -1.426806  0.751906 -2.338352         
    [100 rows x 5 columns]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``3``]:``# View the DataFrame in Excel``xw``.``view``(``df``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `view` function accepts all common Python objects, including numbers, strings,
    lists, dictionaries, tuples, NumPy arrays, and pandas DataFrames. By default,
    it opens a new workbook and pastes the object into cell A1 of the first sheet—it
    even adjusts the column widths by using Excel’s AutoFit functionality. Instead
    of opening a new workbook every time, you can also reuse the same one by providing
    the `view` function an xlwings `sheet` object as the second argument: `xw.view(df,
    mysheet)`. How you get access to such a `sheet` object and how it fits into the
    Excel object model is what I will explain next.[2](index_split_025.html#filepos1437838)'
  prefs: []
  type: TYPE_NORMAL
- en: 'MACOS: PERMISSIONS AND PREFERENCES'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'On macOS, make sure to run Jupyter notebooks and VS Code from an Anaconda Prompt
    (i.e., via Terminal) as shown in [Chapter 2](index_split_008.html#filepos96824).
    This ensures that you will be greeted by two pop-ups when you use xlwings for
    the first time: the first one is “Terminal wants access to control System Events”
    and the second one is “Terminal wants access to control Microsoft Excel.” You
    will need to confirm both pop-ups to allow Python to automate Excel. In theory,
    these pop-ups should be triggered by any application from which you run xlwings
    code, but in practice, that’s often not the case, so running them via the Terminal
    will keep you out of trouble. Also, you’ll need to open Excel’s Preferences and
    uncheck “Show Workbook Gallery when opening Excel” under the General category.
    This opens Excel directly on an empty workbook instead of opening the gallery
    first, which would get in your way when you open a new Excel instance via xlwings.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Excel Object Model
  prefs: []
  type: TYPE_NORMAL
- en: 'When you work with Excel programmatically, you interact with its components
    like a workbook or a sheet. These components are organized in the Excel object
    model, a hierarchical structure that represents Excel’s graphical user interface
    (see [Figure 9-1](#filepos1253700)). Microsoft largely uses the same object model
    with all programming languages they officially support, whether that’s VBA, Office
    Scripts (the JavaScript interface for Excel on the web), or C#. In contrast to
    the reader and writer packages from [Chapter 8](index_split_020.html#filepos959867),
    xlwings follows the Excel object model very closely, only with a breath of fresh
    air: for example, xlwings uses the names `app` instead of `application` and `book`
    instead of `workbook`:'
  prefs: []
  type: TYPE_NORMAL
- en: An `app` contains the `books` collection
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: A `book` contains the `sheets` collection
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: A `sheet` gives access to `range` objects and collections such as `charts`
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: A `range` contains one or more contiguous cells as its items
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The dashed boxes are collections and contain one or more objects of the same
    type. An `app` corresponds to an Excel instance, i.e., an Excel application that
    runs as a separate process. Power users sometimes use multiple Excel instances
    in parallel to open the same workbook twice, for example, to calculate a workbook
    with different inputs in parallel. With the more recent versions of Excel, Microsoft
    made it slightly more complicated to open multiple instances of Excel manually:
    start Excel, then right-click on its icon in the Windows taskbar. In the appearing
    menu, left-click on the Excel entry while holding down the Alt key at the same
    time (make sure to keep the Alt key pressed until after you release your mouse
    button)—a pop-up will ask if you want to start a new instance of Excel. On macOS,
    there is no manual way of launching more than one instance of the same program
    but you can launch multiple Excel instances programmatically via xlwings, as we
    will see later. To summarize, an Excel instance is a sandboxed environment, which
    means that one instance can’t communicate with the other one.[3](index_split_025.html#filepos1438450)
    The `sheet` object gives you access to collections like charts, pictures, and
    defined names—topics that we will look into in the second section of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/00006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-1\. The Excel object model as implemented by xlwings (excerpt)
  prefs: []
  type: TYPE_NORMAL
- en: LANGUAGE AND REGIONAL SETTINGS
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This book is based on the US-English version of Excel. I will occasionally
    refer to default names like “Book1” or “Sheet1,” which will be different if you
    use Excel in another language. For example, “Sheet1” is called “Feuille1” in French
    and “Hoja1” in Spanish. Also, the list separator, which is the separator that
    Excel uses in cell formulas, depends on your settings: I will be using the comma,
    but your version may require a semicolon or another character. For example, instead
    of writing `=SUM(A1, A2)`, you will need to write `=SUMME(A1; A2)` on a computer
    with German regional settings.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'On Windows, if you wanted to change the list separator from a semicolon to
    a comma, you need to change it outside of Excel via your Windows settings: click
    on the Windows start button, search for Settings (or click the cog icon), then
    go to “Time & Language” > “Region & language” > “Additional date, time & regional
    settings” where you finally click on “Region” > “Change location.” Under “List
    separator,” you will be able to change it from a semicolon to a comma. Bear in
    mind that this only works if your “Decimal symbol” (in the same menu) is not also
    a comma. To override the system-wide decimal and thousands separators (but not
    the list separator), in Excel go to “Options” > “Advanced,” where you will find
    the settings under “Editing Options.”'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'On macOS, it works similarly, except that you can’t change the list separator
    directly: under System Preferences of your macOS (not Excel), select Language
    & Region. There, set a specific region either globally (under the General tab)
    or specifically for Excel (under the Apps tab).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To get a feeling for the Excel object model, as usual, it’s best to play around
    with it interactively. Let’s start with the `Book` class: it allows you to create
    new workbooks and connect to existing ones; see [Table 9-1](#filepos1256373) for
    an overview.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-1\. Working with Excel workbooks
  prefs: []
  type: TYPE_NORMAL
- en: '|  Command  |  Description  |'
  prefs: []
  type: TYPE_TB
- en: '|   `xw.Book()` |  Returns a  `book` object representing a new Excel workbook
    in the active Excel instance. If there is no active instance, Excel will be started.
    |'
  prefs: []
  type: TYPE_TB
- en: '|   `xw.Book("Book1")` |  Returns a  `book` object representing an unsaved
    workbook with the name Book1 (name without file extension). |'
  prefs: []
  type: TYPE_TB
- en: '|   `xw.Book("Book1.xlsx")` |  Returns a  `book` object representing a previously
    saved workbook with the name Book1.xlsx (name with file extension). The file has
    to be either open or in the current working directory. |'
  prefs: []
  type: TYPE_TB
- en: '|   `xw.Book(r"C:\path\Book1.xlsx")` |  Returns a  `book` object of a previously
    saved workbook (full file path). The file can be open or closed. The leading `r`
    turns the string into a raw string so the backslashes (`\`) of the path are interpreted
    literally on Windows (I introduced raw strings in [Chapter 5](index_split_015.html#filepos482650)).
    On macOS, the `r` isn’t required as file paths use forward slashes instead of
    backslashes. |'
  prefs: []
  type: TYPE_TB
- en: '|   `xw.books.active` |  Returns a  `book` object representing the active workbook
    in the active Excel instance. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see how we can walk through the object model hierarchy from the `book`
    object down to the `range` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``4``]:``# Create a new empty workbook and print its name. This is the``#
    book we will use to run most of the code samples in this chapter.``book``=``xw``.``Book``()``book``.``name`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[4]: ''Book2''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``5``]:``# Accessing the sheets collection``book``.``sheets`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[5]: Sheets([<Sheet [Book2]Sheet1>])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``6``]:``# Get a sheet object by index or name. You will need to adjust``#
    "Sheet1" if your sheet is called differently.``sheet1``=``book``.``sheets``[``0``]``sheet1``=``book``.``sheets``[``"Sheet1"``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``7``]:``sheet1``.``range``(``"A1"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[7]: <Range [Book2]Sheet1!$A$1>`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'With the `range` object, we have arrived at the bottom of the hierarchy. The
    string that gets printed in between angle brackets gives you useful information
    about that object, but to do something, you usually use the object with an attribute,
    as the next sample shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``8``]:``# Most common tasks: write values...``sheet1``.``range``(``"A1"``)``.``value``=``[[``1``,``2``],``[``3``,``4``]]``sheet1``.``range``(``"A4"``)``.``value``=``"Hello!"`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``9``]:``# ...and read values``sheet1``.``range``(``"A1:B2"``)``.``value`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[9]: [[1.0, 2.0], [3.0, 4.0]]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``10``]:``sheet1``.``range``(``"A4"``)``.``value`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[10]: ''Hello!''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As you can see, by default, the `value` attribute of an xlwings `range` object
    accepts and returns a nested list for two-dimensional ranges and a scalar for
    a single cell. Everything we’ve used so far is almost identical to VBA: assuming
    that `book` is a VBA or xlwings workbook object, respectively, this is how you
    access the `value` attribute from cells A1 to B2 in VBA and with xlwings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`book``.``Sheets``(``1``)``.``Range``(``"A1:B2"``)``.``Value``# VBA``book``.``sheets``[``0``]``.``range``(``"A1:B2"``)``.``value``#
    xlwings`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The differences are:'
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs: []
  type: TYPE_NORMAL
- en: Python uses lowercase letters, potentially with underscores as suggested by
    PEP 8, Python’s style guide that I introduced in [Chapter 3](index_split_010.html#filepos178328).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Indexing
  prefs: []
  type: TYPE_NORMAL
- en: Python uses square brackets and zero-based indices to access an element in the
    `sheets` collection.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Table 9-2](#filepos1273710) gives you an overview of the strings that an xlwings
    `range` accepts.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-2\. Strings to define a range in A1 notation
  prefs: []
  type: TYPE_NORMAL
- en: '|  Reference  |  Description  |'
  prefs: []
  type: TYPE_TB
- en: '|   `"A1"` |  A Single Cell  |'
  prefs: []
  type: TYPE_TB
- en: '|   `"A1:B2"` |  Cells from A1 to B2  |'
  prefs: []
  type: TYPE_TB
- en: '|   `"A:A"` |  Column A  |'
  prefs: []
  type: TYPE_TB
- en: '|   `"A:B"` |  Columns A to B  |'
  prefs: []
  type: TYPE_TB
- en: '|   `"1:1"` |  Row 1  |'
  prefs: []
  type: TYPE_TB
- en: '|   `"1:2"` |  Rows 1 to 2  |'
  prefs: []
  type: TYPE_TB
- en: 'Indexing and slicing work with xlwings `range` objects—watch the address in
    between angle brackets (the printed object representation) to see what cell range
    you end up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``11``]:``# Indexing``sheet1``.``range``(``"A1:B2"``)[``0``,``0``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[11]: <Range [Book2]Sheet1!$A$1>`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``12``]:``# Slicing``sheet1``.``range``(``"A1:B2"``)[:,``1``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[12]: <Range [Book2]Sheet1!$B$1:$B$2>`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Indexing corresponds to using the `Cells` property in VBA:'
  prefs: []
  type: TYPE_NORMAL
- en: '`book``.``Sheets``(``1``)``.``Range``(``"A1:B2"``)``.``Cells``(``1``,``1``)``#
    VBA``book``.``sheets``[``0``]``.``range``(``"A1:B2"``)[``0``,``0``]``# xlwings`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Instead of using `range` explicitly as an attribute of the `sheet` object,
    you can also get a `range` object by indexing and slicing the `sheet` object.
    Using this with A1 notation will allow you to type less, and using this with integer
    indices makes the Excel sheet feel like a NumPy array:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``13``]:``# Single cell: A1 notation``sheet1``[``"A1"``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[13]: <Range [Book2]Sheet1!$A$1>`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``14``]:``# Multiple cells: A1 notation``sheet1``[``"A1:B2"``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[14]: <Range [Book2]Sheet1!$A$1:$B$2>`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``15``]:``# Single cell: indexing``sheet1``[``0``,``0``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[15]: <Range [Book2]Sheet1!$A$1>`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``16``]:``# Multiple cells: slicing``sheet1``[:``2``,``:``2``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[16]: <Range [Book2]Sheet1!$A$1:$B$2>`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Sometimes, however, it may be more intuitive to define a range by referring
    to the top-left and bottom-right cell of a range. The following samples refer
    to the cell ranges D10 and D10:F11, respectively, allowing you to understand the
    difference between indexing/slicing a `sheet` object and working with a `range`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``17``]:``# D10 via sheet indexing``sheet1``[``9``,``3``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[17]: <Range [Book2]Sheet1!$D$10>`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``18``]:``# D10 via range object``sheet1``.``range``((``10``,``4``))`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[18]: <Range [Book2]Sheet1!$D$10>`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``19``]:``# D10:F11 via sheet slicing``sheet1``[``9``:``11``,``3``:``6``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[19]: <Range [Book2]Sheet1!$D$10:$F$11>`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``20``]:``# D10:F11 via range object``sheet1``.``range``((``10``,``4``),``(``11``,``6``))`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[20]: <Range [Book2]Sheet1!$D$10:$F$11>`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Defining `range` objects with tuples is very similar to how the `Cells` property
    works in VBA, as the following comparison shows—this assumes again that `book`
    is either a VBA workbook object or an xlwings `book` object. Let’s first look
    at the VBA version:'
  prefs: []
  type: TYPE_NORMAL
- en: '`With``book``.``Sheets``(``1``)``myrange``=``.``Range``(.``Cells``(``10``,``4``),``.``Cells``(``11``,``6``))``End``With`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This is equivalent to the following xlwings expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '`myrange``=``book``.``sheets``[``0``]``.``range``((``10``,``4``),``(``11``,``6``))`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ZERO VS. ONE-BASED INDICES
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As a Python package, xlwings consistently uses zero-based indexing whenever
    you access elements via Python’s index or slice syntax, i.e., via square brackets.
    xlwings `range` objects, however, use Excel’s one-based row and column indices.
    Having the same row/column indices as Excel’s user interface may sometimes be
    beneficial. If you prefer to only ever use Python’s zero-based indexing, simply
    use the `sheet[row_selection, column_selection]` syntax.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following sample shows you how to get from a `range` object (`sheet1["A1"]`)
    all the way up again to the `app` object. Remember that the `app` object represents
    an Excel instance (the output in between angle brackets represents Excel’s process
    ID and will therefore be different on your machine):'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``21``]:``sheet1``[``"A1"``]``.``sheet``.``book``.``app`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[21]: <Excel App 9092>`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Having arrived at the very top of the Excel object model, it’s a good moment
    to see how you can work with multiple Excel instances. You will need to use the
    `app` object explicitly if you want to open the same workbook in multiple Excel
    instances or if you specifically want to distribute your workbooks across different
    instances for performance reasons. Another common use case for working with an
    `app` object is to open your workbook in a hidden Excel instance: this allows
    you to run an xlwings script in the background without blocking you from doing
    other work in Excel in the meantime:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``22``]:``# Get one app object from the open workbook``# and create an
    additional invisible app instance``visible_app``=``sheet1``.``book``.``app``invisible_app``=``xw``.``App``(``visible``=``False``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``23``]:``# List the book names that are open in each instance``# by
    using a list comprehension``[``book``.``name``for``book``in``visible_app``.``books``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[23]: [''Book1'', ''Book2'']`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``24``]:``[``book``.``name``for``book``in``invisible_app``.``books``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[24]: [''Book3'']`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``25``]:``# An app key represents the process ID (PID)``xw``.``apps``.``keys``()`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[25]: [5996, 9092]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``26``]:``# It can also be accessed via the pid attribute``xw``.``apps``.``active``.``pid`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[26]: 5996`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``27``]:``# Work with the book in the invisible Excel instance``invisible_book``=``invisible_app``.``books``[``0``]``invisible_book``.``sheets``[``0``][``"A1"``]``.``value``=``"Created
    by an invisible app."`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``28``]:``# Save the Excel workbook in the xl directory``invisible_book``.``save``(``"xl/invisible.xlsx"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``29``]:``# Quit the invisible Excel instance``invisible_app``.``quit``()`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'MACOS: ACCESSING THE FILE SYSTEM PROGRAMMATICALLY'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you run the `save` command on macOS, you will get a Grant File Access pop-up
    in Excel that you will need to confirm by clicking the Select button before clicking
    on Grant Access. On macOS, Excel is sandboxed, which means that your program can
    only access files and folders outside of the Excel app by confirming this prompt.
    Once confirmed, Excel will remember the locations and won’t bug you again when
    you run the script the next time.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you have the same workbook open in two instances of Excel or if you want
    to specify in which Excel instance you want to open a workbook, you can’t use
    `xw.Book` anymore. Instead, you need to use the `books` collection as laid out
    in [Table 9-3](#filepos1310515). Note that `myapp` stands for an xlwings `app`
    object. If you would replace `myapp.books` with `xw.books` instead, xlwings will
    use the active `app`.
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-3\. Working with the `books` collection
  prefs: []
  type: TYPE_NORMAL
- en: '|  Command  |  Description  |'
  prefs: []
  type: TYPE_TB
- en: '|   `myapp.books.add()` |  Creates a new Excel workbook in the Excel instance
    that  `myapp` refers to and returns the corresponding `book` object. |'
  prefs: []
  type: TYPE_TB
- en: '|   `myapp.books.open(r"C:\path\Book.xlsx")` |  Returns the  `book` if it’s
    already open, otherwise opens it first in the Excel instance that `myapp` refers
    to. Remember that the leading `r` turns the file path into a raw string to interpret
    the backslashes literally. |'
  prefs: []
  type: TYPE_TB
- en: '|   `myapp.books["Book1.xlsx"]` |  Returns the  `book` object if it’s open.
    This will raise a `KeyError` if it isn’t open yet. Make sure to use the name and
    not the full path. Use this if you need to know if a workbook is already open
    in Excel. |'
  prefs: []
  type: TYPE_TB
- en: 'Before we dive deeper into how xlwings can replace your VBA macros, let’s see
    how xlwings can interact with your existing VBA code: this can be useful if you
    have a lot of legacy code and don’t have the time to migrate everything to Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Running VBA Code
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have legacy Excel projects with lots of VBA code, it may be a lot of
    work to migrate everything to Python. In that case, you can use Python to run
    your VBA macros. The following sample uses the vba.xlsm file that you will find
    in the xl folder of the companion repo. It contains the following code in Module1:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Function``MySum``(``x``As``Double``,``y``As``Double``)``As``Double``MySum``=``x``+``y``End``Function`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Sub``ShowMsgBox``(``msg``As``String``)``MsgBox``msg``End``Sub`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To call these functions via Python, you first need to instantiate an xlwings
    `macro` object that you subsequently call, making it feel as if it was a native
    Python function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``30``]:``vba_book``=``xw``.``Book``(``"xl/vba.xlsm"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``31``]:``# Instantiate a macro object with the VBA function``mysum``=``vba_book``.``macro``(``"Module1.MySum"``)``#
    Call a VBA function``mysum``(``5``,``4``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[31]: 9.0`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``32``]:``# It works the same with a VBA Sub procedure``show_msgbox``=``vba_book``.``macro``(``"Module1.ShowMsgBox"``)``show_msgbox``(``"Hello
    xlwings!"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``33``]:``# Close the book again (make sure to close the MessageBox first)``vba_book``.``close``()`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: DON’T STORE VBA FUNCTIONS IN SHEET AND THISWORKBOOK MODULES
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you store the VBA function `MySum` in the workbook module `ThisWorkbook`
    or a sheet module (e.g., `Sheet1`), you have to refer to it as `ThisWorkbook.MySum`
    or `Sheet1.MySum`. However, you won’t be able to access the function’s return
    value from Python, so make sure to store VBA functions in a standard VBA code
    module that you insert by right-clicking on the Modules folder in the VBA editor.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that you know how to interact with existing VBA code, we can continue our
    exploration of xlwings by looking at how to use it with DataFrames, NumPy arrays,
    and collections like charts, pictures, and defined names.
  prefs: []
  type: TYPE_NORMAL
- en: Converters, Options, and Collections
  prefs: []
  type: TYPE_NORMAL
- en: In the introductory code samples of this chapter, we were already reading and
    writing a string and a nested list from and to Excel by using the `value` attribute
    of an xlwings `range` object. I’ll start this section by showing you how this
    works with pandas DataFrames before having a closer look at the `options` method
    that allows us to influence how xlwings reads and writes values. We move on with
    charts, pictures, and defined names, the collections that you usually access from
    a `sheet` object. Armed with these xlwings basics, we’ll have another look at
    the reporting case study from [Chapter 7](index_split_019.html#filepos863345).
  prefs: []
  type: TYPE_NORMAL
- en: Working with DataFrames
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing a DataFrame to Excel is no different from writing a scalar or a nested
    list to Excel: simply assign the DataFrame to the top-left cell of an Excel range:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``34``]:``data``=``[[``"Mark"``,``55``,``"Italy"``,``4.5``,``"Europe"``],``[``"John"``,``33``,``"USA"``,``6.7``,``"America"``]]``df``=``pd``.``DataFrame``(``data``=``data``,``columns``=``[``"name"``,``"age"``,``"country"``,``"score"``,``"continent"``],``index``=``[``1001``,``1000``])``df``.``index``.``name``=``"user_id"``df`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[34]:          name  age country  score continent          user_id         
    1001     Mark   55   Italy    4.5    Europe          1000     John   33     USA   
    6.7   America`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``35``]:``sheet1``[``"A6"``]``.``value``=``df`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If, however, you would like to suppress the column headers and/or the index,
    use the `options` method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``36``]:``sheet1``[``"B10"``]``.``options``(``header``=``False``,``index``=``False``)``.``value``=``df`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Reading Excel ranges as DataFrames requires you to provide the `DataFrame` class
    as the `convert` parameter in the `options` method. By default, it expects that
    your data has both a header and index, but you can again use the `index` and `header`
    parameters to change this. Instead of using the converter, you could also read
    in the values first as a nested list and then manually construct your DataFrame,
    but using the converter makes it quite a bit easier to handle the index and header.
  prefs: []
  type: TYPE_NORMAL
- en: THE EXPAND METHOD
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following code sample, I am introducing the `expand` method that makes
    it easy to read a contiguous block of cells, delivering the same range as if you
    were doing Shift+Ctrl+Down-Arrow+Right-Arrow in Excel, except that `expand` jumps
    over an empty cell in the top-left corner.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``37``]:``df2``=``sheet1``[``"A6"``]``.``expand``()``.``options``(``pd``.``DataFrame``)``.``value``df2`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[37]:          name   age country  score continent          user_id         
    1001.0   Mark  55.0   Italy    4.5    Europe          1000.0   John  33.0    
    USA    6.7   America`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``38``]:``# If you want the index to be an integer index,``# you can
    change its data type``df2``.``index``=``df2``.``index``.``astype``(``int``)``df2`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[38]:       name   age country  score continent          1001  Mark  55.0  
    Italy    4.5    Europe          1000  John  33.0     USA    6.7   America`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``39``]:``# By setting index=False, it will put all the values from Excel
    into``# the data part of the DataFrame and will use the default index``sheet1``[``"A6"``]``.``expand``()``.``options``(``pd``.``DataFrame``,``index``=``False``)``.``value`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[39]:    user_id  name   age country  score continent          0   1001.0 
    Mark  55.0   Italy    4.5    Europe          1   1000.0  John  33.0     USA   
    6.7   America`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Reading and writing DataFrames was a first example of how converters and options
    work. How they are formally defined and how you use them with other data structures
    is what we will look into next.
  prefs: []
  type: TYPE_NORMAL
- en: Converters and Options
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have just seen, the `options` method of the xlwings `range` object allows
    you to influence the way that values are read and written from and to Excel. That
    is, `options` are only evaluated when you call the `value` attribute on a `range`
    object. The syntax is as follows (`myrange` is an xlwings `range` object):'
  prefs: []
  type: TYPE_NORMAL
- en: '`myrange``.``options``(``convert``=``None``,``option1``=``value1``,``option2``=``value2``,``...``)``.``value`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Table 9-4](#filepos1343026) shows the built-in converters, i.e., the values
    that the `convert` argument accepts. They are called built-in as xlwings offers
    a way to write your own converters, which could be useful if you have to repeatedly
    apply additional transformations before writing or after reading values—to see
    how it works, have a look at the [xlwings docs](https://oreil.ly/Ruw8v).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-4\. Built-in converters
  prefs: []
  type: TYPE_NORMAL
- en: '|  Converter  |  Description  |'
  prefs: []
  type: TYPE_TB
- en: '|   `dict` |  Simple dictionaries without nesting, i.e., in the form  `{key1:
    value1, key2: value2, ...}` |'
  prefs: []
  type: TYPE_TB
- en: '|   `np.array` |  NumPy arrays, requires  `import numpy as np` |'
  prefs: []
  type: TYPE_TB
- en: '|   `pd.Series` |  pandas Series, requires  `import pandas as pd` |'
  prefs: []
  type: TYPE_TB
- en: '|   `pd.DataFrame` |  pandas DataFrame, requires  `import pandas as pd` |'
  prefs: []
  type: TYPE_TB
- en: We have already used the `index` and `header` options with the DataFrame example,
    but there are more options available, as shown in [Table 9-5](#filepos1345335).
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-5\. Built-in options
  prefs: []
  type: TYPE_NORMAL
- en: '|  Option  |  Description  |'
  prefs: []
  type: TYPE_TB
- en: '|   `empty` |  By default, empty cells are read as  `None`. Change this by
    providing a value for `empty`. |'
  prefs: []
  type: TYPE_TB
- en: '|   `date` |  Accepts a function that is applied to values from date-formatted
    cells.  |'
  prefs: []
  type: TYPE_TB
- en: '|   `number` |  Accepts a function that is applied to numbers.  |'
  prefs: []
  type: TYPE_TB
- en: '|   `ndim` |   Number of dimensions: when reading, use `ndim` to force the
    values of a range to arrive in a certain dimensionality. Must be either `None`,
    `1`, or `2`. Can be used when reading values as lists or NumPy arrays. |'
  prefs: []
  type: TYPE_TB
- en: '|   `transpose` |  Transposes the values, i.e., turns the columns into rows
    or vice versa.  |'
  prefs: []
  type: TYPE_TB
- en: '|   `index` |  To be used with pandas DataFrames and Series: when reading,
    use it to define whether the Excel range contains the index. Can be  `True`/`False`
    or an integer. The integer defines how many columns should be turned into a `MultiIndex`.
    For example, `2` will use the two left-most columns as index. When writing, you
    can decide if you want to write out the index by setting `index` to `True` or
    `False`. |'
  prefs: []
  type: TYPE_TB
- en: '|   `header` |  Works the same as  `index`, but applied to the column headers.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s have a closer look at `ndim`: by default, when you read in a single cell
    from Excel, you will get a scalar (e.g., a float or a string); when you read in
    a column or row, you will get a simple list; and finally, when you read in a two-dimensional
    range, you will get a nested (i.e., two-dimensional) list. This is not only consistent
    in itself, but it is also equivalent to how slicing works with NumPy arrays, as
    seen in [Chapter 4](index_split_014.html#filepos433313). The one-dimensional case
    is a special one: sometimes, a column may just be an edge case of what is otherwise
    a two-dimensional range. In this case, it makes sense to force a range to always
    arrive as a two-dimensional list by using `ndim=2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``40``]:``# Horizontal range (one-dimensional)``sheet1``[``"A1:B1"``]``.``value`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[40]: [1.0, 2.0]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``41``]:``# Vertical range (one-dimensional)``sheet1``[``"A1:A2"``]``.``value`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[41]: [1.0, 3.0]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``42``]:``# Horizontal range (two-dimensional)``sheet1``[``"A1:B1"``]``.``options``(``ndim``=``2``)``.``value`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[42]: [[1.0, 2.0]]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``43``]:``# Vertical range (two-dimensional)``sheet1``[``"A1:A2"``]``.``options``(``ndim``=``2``)``.``value`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[43]: [[1.0], [3.0]]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``44``]:``# Using the NumPy array converter behaves the same:``# vertical
    range leads to a one-dimensional array``sheet1``[``"A1:A2"``]``.``options``(``np``.``array``)``.``value`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[44]: array([1., 3.])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``45``]:``# Preserving the column orientation``sheet1``[``"A1:A2"``]``.``options``(``np``.``array``,``ndim``=``2``)``.``value`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[45]: array([[1.],                 [3.]])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``46``]:``# If you need to write out a list vertically,``# the "transpose"
    option comes in handy``sheet1``[``"D1"``]``.``options``(``transpose``=``True``)``.``value``=``[``100``,``200``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Use `ndim=1` to force the value of a single cell to be read as a list instead
    of a scalar. You won’t need `ndim` with pandas, as a DataFrame is always two-dimensional
    and a Series is always one-dimensional. Here is one more example showing how the
    `empty`, `date`, and `number` options work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``47``]:``# Write out some sample data``sheet1``[``"A13"``]``.``value``=``[``dt``.``datetime``(``2020``,``1``,``1``),``None``,``1.0``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``48``]:``# Read it back using the default options``sheet1``[``"A13:C13"``]``.``value`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[48]: [datetime.datetime(2020, 1, 1, 0, 0), None, 1.0]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``49``]:``# Read it back using non-default options``sheet1``[``"A13:C13"``]``.``options``(``empty``=``"NA"``,``dates``=``dt``.``date``,``numbers``=``int``)``.``value`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[49]: [datetime.date(2020, 1, 1), ''NA'', 1]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So far, we have worked with the `book`, `sheet`, and `range` objects. Let’s
    now move on to learn how to deal with collections such as charts that you access
    from the `sheet` object!
  prefs: []
  type: TYPE_NORMAL
- en: Charts, Pictures, and Defined Names
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, I’ll show you how to work with three collections that you
    access via the `sheet` or `book` object: charts, pictures, and defined names.[4](#filepos1438843)
    xlwings only supports the most basic chart functionality, but since you can work
    with templates, you may not even be missing much. And to compensate, xlwings allows
    you to embed Matplotlib plots as pictures—you may remember from [Chapter 5](index_split_015.html#filepos482650)
    that Matplotlib is pandas’ default plotting backend. Let’s start by creating a
    first Excel chart!'
  prefs: []
  type: TYPE_NORMAL
- en: Excel charts
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a new chart, use the `add` method of the `charts` collection, and then
    set the chart type and source data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``50``]:``sheet1``[``"A15"``]``.``value``=``[[``None``,``"North"``,``"South"``],``[``"Last
    Year"``,``2``,``5``],``[``"This Year"``,``3``,``6``]]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``51``]:``chart``=``sheet1``.``charts``.``add``(``top``=``sheet1``[``"A19"``]``.``top``,``left``=``sheet1``[``"A19"``]``.``left``)``chart``.``chart_type``=``"column_clustered"``chart``.``set_source_data``(``sheet1``[``"A15"``]``.``expand``())`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This will produce the chart shown on the lefthand side of [Figure 9-2](#filepos1388244).
    To look up the available chart types, have a look at the [xlwings docs](https://oreil.ly/2B58q).
    If you enjoy working with pandas plots more than with Excel charts, or if you
    want to use a chart type that is not available in Excel, xlwings has you covered—let’s
    see how!
  prefs: []
  type: TYPE_NORMAL
- en: 'Pictures: Matplotlib plots'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use pandas’ default plotting backend, you are creating a Matplotlib
    plot. To bring such a plot over to Excel, you first need to get ahold of its `figure`
    object, which you provide as an argument to `pictures.add`—this will convert the
    plot into a picture and send it over to Excel:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``52``]:``# Read in the chart data as DataFrame``df``=``sheet1``[``"A15"``]``.``expand``()``.``options``(``pd``.``DataFrame``)``.``value``df`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[52]:            North  South          Last Year    2.0    5.0         
    This Year    3.0    6.0`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``53``]:``# Enable Matplotlib by using the notebook magic command``#
    and switch to the "seaborn" style``%``matplotlib``inline``import``matplotlib.pyplot``as``plt``plt``.``style``.``use``(``"seaborn"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``54``]:``# The pandas plot method returns an "axis" object from``# where
    you can get the figure. "T" transposes the``# DataFrame to bring the plot into
    the desired orientation``ax``=``df``.``T``.``plot``.``bar``()``fig``=``ax``.``get_figure``()`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``55``]:``# Send the plot to Excel``plot``=``sheet1``.``pictures``.``add``(``fig``,``name``=``"SalesPlot"``,``top``=``sheet1``[``"H19"``]``.``top``,``left``=``sheet1``[``"H19"``]``.``left``)``#
    Let''s scale the plot to 70%``plot``.``width``,``plot``.``height``=``plot``.``width``*``0.7``,``plot``.``height``*``0.7`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To update the picture with a new plot, simply use the `update` method with
    another `figure` object—technically, this will replace the picture in Excel but
    will preserve all properties like the location, size, and name:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``56``]:``ax``=``(``df``+``1``)``.``T``.``plot``.``bar``()``plot``=``plot``.``update``(``ax``.``get_figure``())`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-2\. An Excel chart (left) and Matplotlib plot (right)
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-2](#filepos1388244) shows how the Excel chart and the Matplotlib
    plot compare after the `update` call.'
  prefs: []
  type: TYPE_NORMAL
- en: MAKE SURE THAT PILLOW IS INSTALLED
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'When working with pictures, make sure that [Pillow](https://oreil.ly/3HYkf),
    Python’s go-to library for pictures, is installed: this will make sure that the
    pictures arrive in the correct size and proportion in Excel. Pillow is part of
    Anaconda, so if you use a different distribution, you’ll need to install it by
    either running `conda install pillow` or `pip install pillow`. Note that `pictures.add`
    also accepts a path to a picture on disk instead of a Matplotlib figure.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Charts and pictures are collections that are accessed via a `sheet` object.
    Defined names, the collection we are going to look at next, can be accessed from
    the `sheet` or the `book` object. Let’s see what difference this makes!
  prefs: []
  type: TYPE_NORMAL
- en: Defined names
  prefs: []
  type: TYPE_NORMAL
- en: 'In Excel, you create a defined name by assigning a name to a range, a formula,
    or a constant.[5](#filepos1439272) Assigning a name to a range is probably the
    most common case and called a named range. With a named range, you can refer to
    the Excel range in formulas and code by using a descriptive name rather than an
    abstract address in the form of `A1:B2`. Using them with xlwings makes your code
    more flexible and solid: reading and writing values from and to named ranges gives
    you the flexibility to restructure your workbook without having to adjust your
    Python code: a name sticks to the cell, even if you move it around by inserting
    a new row, for example. Defined names can be set on either the global book scope
    or the local sheet scope. The advantage of a name with sheet scope is that you
    could copy the sheet without running into conflicts with duplicate named ranges.
    In Excel, you add defined names manually by going to Formulas > Define Name or
    by selecting a range, then writing the desired name into the Name Box—this is
    the text box to the left of the formula bar, where you see the cell address by
    default. Here is how you manage defined names with xlwings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``57``]:``# The book scope is the default scope``sheet1``[``"A1:B2"``]``.``name``=``"matrix1"`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``58``]:``# For the sheet scope, prepend the sheet name with``# an exclamation
    point``sheet1``[``"B10:E11"``]``.``name``=``"Sheet1!matrix2"`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``59``]:``# Now you can access the range by name``sheet1``[``"matrix1"``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[59]: <Range [Book2]Sheet1!$A$1:$B$2>`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``60``]:``# If you access the names collection via the "sheet1" object,``#
    it contains only names with that sheet''s scope``sheet1``.``names`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[60]: [<Name ''Sheet1!matrix2'': =Sheet1!$B$10:$E$11>]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``61``]:``# If you access the names collection via the "book" object,``#
    it contains all names, including book and sheet scope``book``.``names`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[61]: [<Name ''matrix1'': =Sheet1!$A$1:$B$2>, <Name ''Sheet1!matrix2'':
              =Sheet1!$B$10:$E$11>]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``62``]:``# Names have various methods and attributes.``# You can, for
    example, get the respective range object.``book``.``names``[``"matrix1"``]``.``refers_to_range`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[62]: <Range [Book2]Sheet1!$A$1:$B$2>`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``63``]:``# If you want to assign a name to a constant``# or a formula,
    use the "add" method``book``.``names``.``add``(``"EURUSD"``,``"=1.1151"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[63]: <Name ''EURUSD'': =1.1151>`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Have a look at the generated defined names in Excel by opening the Name Manager
    via Formulas > Name Manager (see [Figure 9-3](#filepos1400210)). Note that Excel
    on macOS doesn’t have a Name Manager—instead, go to Formulas > Define Name, from
    where you will see the existing names.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/00014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-3\. Excel’s Name Manager after adding a few defined names via xlwings
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you know how to work with the most commonly used components
    of an Excel workbook. This means that we can look at the reporting case study
    from [Chapter 7](index_split_019.html#filepos863345) one more time: let’s see
    what changes when we bring xlwings into the picture!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Case Study (Re-Revisited): Excel Reporting'
  prefs: []
  type: TYPE_NORMAL
- en: 'Being able to truly edit Excel files via xlwings enables us to work with template
    files that will be 100% preserved, no matter how complex they are or in which
    format they are stored—for example, you can easily edit an xlsb file, a case that
    is currently not supported by any of the writer packages we met in the previous
    chapter. When you look at sales_report_openpxyl.py in the companion repo, you
    will see that after preparing the `summary` DataFrame, we had to write almost
    forty lines of code to create one chart and style one DataFrame with OpenPyXL.
    With xlwings, you achieve the same in just six lines of code, as shown in [Example 9-1](#filepos1403182).
    Being able to handle the formatting in the Excel template will save you a lot
    of work. This, however, comes at a price: xlwings requires an installation of
    Excel to run—that’s usually fine if you have to create these reports infrequently
    on your own machine, but it may be less ideal if you try to create reports on
    a server as part of a web application.'
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to make sure that your Microsoft Office license covers the installation
    on a server and second, Excel wasn’t made for unattended automation, which means
    that you may run into stability issues, especially if you need to generate many
    reports in a short amount of time. That being said, I have seen more than one
    client doing this successfully, so if you can’t use a writer package for whatever
    reason, running xlwings on a server may very well be an option worth exploring.
    Just make sure to run each script in a new Excel instance via `app = xw.App()`
    to ship around the typical stability issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find the full xlwings script under sales_report_xlwings.py in the
    companion repository (the first half is the same as we used with OpenPyXL and
    XlsxWriter). It is also a perfect example for combining a reader package with
    xlwings: while pandas (via OpenPyXL and xlrd) is faster with reading many files
    from disk, xlwings makes it easier to fill in a preformatted template.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-1\. sales_report_xlwings.py (second part only)
  prefs: []
  type: TYPE_NORMAL
- en: '`# Open the template, paste the data, autofit the columns``# and adjust the
    chart source. Then save it under a different name.``template``=``xw``.``Book``(``this_dir``/``"xl"``/``"sales_report_template.xlsx"``)``sheet``=``template``.``sheets``[``"Sheet1"``]``sheet``[``"B3"``]``.``value``=``summary``sheet``[``"B3"``]``.``expand``()``.``columns``.``autofit``()``sheet``.``charts``[``"Chart
    1"``]``.``set_source_data``(``sheet``[``"B3"``]``.``expand``()[:``-``1``,``:``-``1``])``template``.``save``(``this_dir``/``"sales_report_xlwings.xlsx"``)`'
  prefs: []
  type: TYPE_NORMAL
- en: When you run this script for the very first time on macOS (for example by opening
    it in VS Code and clicking the Run File button), you will have to again confirm
    a pop-up to grant access to the file system, something we’ve already come across
    earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'With formatted Excel templates, you can build beautiful Excel reports very
    quickly. You also get access to methods like `autofit`, something that’s not available
    with the writer packages as it relies on calculations done by the Excel application:
    this allows you to properly set the width and height of your cells according to
    their content. [Figure 9-4](#filepos1410076) shows you the upper part of the sales
    report as generated by xlwings with a customized table header as well as columns
    where the `autofit` method has been applied.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you start using xlwings for more than just filling in a couple of cells
    in a template, it’s good to know a little bit about its internals: the next section
    looks at how xlwings works under the hood.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-4\. The table of the sales report based on a preformatted template
  prefs: []
  type: TYPE_NORMAL
- en: Advanced xlwings Topics
  prefs: []
  type: TYPE_NORMAL
- en: This section shows you how to make your xlwings code performant and how to work
    around missing functionality. To understand these topics, though, we first need
    to say a few words about the way xlwings communicates with Excel.
  prefs: []
  type: TYPE_NORMAL
- en: xlwings Foundations
  prefs: []
  type: TYPE_NORMAL
- en: 'xlwings depends on other Python packages to communicate with the automation
    mechanism of the respective operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, xlwings relies on the COM technology, short for Component Object
    Model. COM is a standard that allows two processes to communicate with each other—in
    our case Excel and Python. xlwings uses the Python package [pywin32](https://oreil.ly/tm7sK)
    to handle the COM calls.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: macOS
  prefs: []
  type: TYPE_NORMAL
- en: On macOS, xlwings relies on AppleScript. AppleScript is Apple’s scripting language
    to automate scriptable applications—fortunately, Excel is such a scriptable application.
    To run AppleScript commands, xlwings uses the Python package [appscript](https://oreil.ly/tIsDd).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'WINDOWS: HOW TO PREVENT ZOMBIE PROCESSES'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When you play around with xlwings on Windows, you will sometimes notice that
    Excel seems to be completely closed, yet when you open the Task Manager (right-click
    on the Windows taskbar, then select Task Manager), you will see Microsoft Excel
    under Background processes on the Processes tab. If you don’t see any tab, click
    on “More details” first. Alternatively, go to the Details tab, where you will
    see Excel listed as “EXCEL.EXE.” To terminate a zombie process, right-click the
    respective row and select “End task” to force Excel to close.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Because these processes are undead rather than properly terminated, they are
    often called zombie processes. Leaving them around uses resources and can lead
    to undesired behavior: for example, files may be blocked or add-ins may not be
    properly loaded when you open a new instance of Excel. The reason why Excel sometimes
    doesn’t manage to shut down properly is that processes can only be terminated
    once there are no more COM references, e.g., in the form of an xlwings `app` object.
    Most commonly, you end up with an Excel zombie process after killing the Python
    interpreter as this prevents it from properly cleaning up the COM references.
    Consider this example on an Anaconda Prompt:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`(base)>` `python` `>>>` `import xlwings as xw` `>>>` `app = xw.App()`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Once the new Excel instance is running, quit it again via the Excel user interface:
    while Excel closes, the Excel process in the Task Manager will keep running. If
    you shut down the Python session properly by running `quit()` or by using the
    Ctrl+Z shortcut, the Excel process will eventually be shut down. If, however,
    you kill the Anaconda Prompt by clicking the “x” at the top right of the window,
    you will notice that the process sticks around as a zombie process. The same happens
    if you kill the Anaconda Prompt before closing Excel or if you kill it while it
    is running a Jupyter server and you hold an xlwings `app` object in one of the
    Jupyter notebook cells. To minimize the chances of ending up with Excel zombie
    processes, here are a few suggestions:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Run `app.quit()` from Python instead of closing Excel manually. This makes sure
    that the references are cleaned up properly.
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Don’t kill interactive Python sessions when you work with xlwings, e.g., if
    you run a Python REPL on an Anaconda Prompt, shut the Python interpreter down
    properly by running `quit()` or by using the Ctrl+Z shortcut. When you work with
    Jupyter notebooks, shut the server down by clicking on Quit on the web interface.
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: With interactive Python sessions, it helps to avoid using the `app` object directly,
    e.g., by using `xw.Book()` instead of `myapp.books.add()`. This should properly
    terminate Excel even if the Python process is killed.
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that you have an idea about the underlying technology of xlwings, let’s
    see how we can speed up slow scripts!
  prefs: []
  type: TYPE_NORMAL
- en: Improving Performance
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep your xlwings scripts performant, there are a few strategies: the most
    important one is to keep cross-application calls to an absolute minimum. Using
    raw values can be another option, and finally, setting the right `app` properties
    may also help. Let’s go through these options one after another!'
  prefs: []
  type: TYPE_NORMAL
- en: Minimize cross-application calls
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s crucial to know that every cross-application call from Python to Excel
    is “expensive,” i.e., slow. Therefore, such calls should be reduced as much as
    possible. The easiest way to do this is by reading and writing entire Excel ranges
    instead of looping through individual cells. In the following example, we read
    and write 150 cells, first by looping through every cell and then by dealing with
    the entire range in one call:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``64``]:``# Add a new sheet and write 150 values``# to it to have something
    to work with``sheet2``=``book``.``sheets``.``add``()``sheet2``[``"A1"``]``.``value``=``np``.``arange``(``150``)``.``reshape``(``30``,``5``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``65``]:``%%``time``# This makes 150 cross-application calls``for``cell``in``sheet2``[``"A1:E30"``]:``cell``.``value``+=``1`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Wall time: 909 ms`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``66``]:``%%``time``# This makes just two cross-application calls``values``=``sheet2``[``"A1:E30"``]``.``options``(``np``.``array``)``.``value``sheet2``[``"A1"``]``.``value``=``values``+``1`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Wall time: 97.2 ms`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: These numbers are even more extreme on macOS, where the second option is about
    50 times faster than the first one on my machine.
  prefs: []
  type: TYPE_NORMAL
- en: Raw values
  prefs: []
  type: TYPE_NORMAL
- en: 'xlwings was primarily designed with a focus on convenience rather than speed.
    However, if you deal with huge cell ranges, you may run into situations where
    you can save time by skipping xlwings’ data cleaning step: xlwings loops through
    each value when you read and write data, for example, to align data types between
    Windows and macOS. By using the string `raw` as converter in the `options` method,
    you skip this step. While this should make all operations faster, the difference
    may not be significant unless you write large arrays on Windows. Using raw values,
    however, means that you cannot directly work with DataFrames anymore. Instead,
    you need to provide your values as nested lists or tuples. Also, you will need
    to provide the full address of the range you are writing to—providing the top-left
    cell isn’t enough anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``67``]:``# With raw values, you must provide the full``# target range,
    sheet["A35"] doesn''t work anymore``sheet1``[``"A35:B36"``]``.``options``(``"raw"``)``.``value``=``[[``1``,``2``],``[``3``,``4``]]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: App properties
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the content of your workbook, changing the properties of your
    `app` objects can also help to make code run faster. Usually, you want to look
    at the following properties (`myapp` is an xlwings `app` object):'
  prefs: []
  type: TYPE_NORMAL
- en: '`myapp.screen_updating = False`'
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`myapp.calculation = "manual"`'
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`myapp.display_alerts = False`'
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: At the end of the script, make sure to set the attributes back to their original
    state. If you are on Windows, you may also see a slight performance improvement
    by running your script in a hidden Excel instance via `xw.App(visible=False)`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to keep performance under control, let’s have a look at
    how to extend the functionality of xlwings.
  prefs: []
  type: TYPE_NORMAL
- en: How to Work Around Missing Functionality
  prefs: []
  type: TYPE_NORMAL
- en: 'xlwings provides a Pythonic interface for the most commonly used Excel commands
    and makes them work across Windows and macOS. There are, however, many methods
    and attributes of the Excel object model that are not yet covered natively by
    xlwings—but all is not lost! xlwings gives you access to the underlying pywin32
    object on Windows and the appscript object on macOS by using the `api` attribute
    on any xlwings object. This way, you have access to the whole Excel object model,
    but in turn, you lose cross-platform compatibility. For example, assume you wanted
    to clear the formatting of a cell. Here is how you would go about this:'
  prefs: []
  type: TYPE_NORMAL
- en: Check if the method is available on the xlwings `range` object, e.g., by using
    the Tab key after putting a dot at the end of a `range` object in a Jupyter notebook,
    by running `dir(sheet["A1"])` or by searching the [xlwings API reference](https://oreil.ly/EiXBc).
    On VS Code, the available methods should be shown automatically in a tooltip.
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If the desired functionality is missing, use the `api` attribute to get the
    underlying object: on Windows, `sheet["A1"].api` will give you a pywin32 object
    and an on macOS, you will get an appscript object.'
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Check Excel’s object model in the [Excel VBA reference](https://oreil.ly/UILPo).
    To clear the format of a range, you would end up under [Range.ClearFormats](https://oreil.ly/kcEsw).
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'On Windows, in most cases, you can use the VBA method or property directly
    with your `api` object. If it is a method, make sure to add parentheses in Python:
    `sheet["A1"].api.ClearFormats()`. If you are doing this on macOS, things are more
    complicated as appscript uses a syntax that can be difficult to guess. Your best
    approach is to look at the developer guide that is part of the [xlwings source
    code](https://oreil.ly/YSS0Y). Clearing the cell formatting, however, is easy
    enough: just apply Python’s syntax rules on the method name by using lowercase
    characters with underscores: `sheet["A1"].api.clear_formats()`.'
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you need to make sure that `ClearFormats` works across both platforms, you
    can do it as follows (`darwin` is the core of macOS and used as its name by `sys.platform`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`import``sys``if``sys``.``platform``.``startswith``(``"darwin"``):``sheet``[``"A10"``]``.``api``.``clear_formats``()``elif``sys``.``platform``.``startswith``(``"win"``):``sheet``[``"A10"``]``.``api``.``ClearFormats``()`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In any case, it’s worth opening an issue on xlwings’ [GitHub repository](https://oreil.ly/kFkD0)
    to have the functionality included in a future version.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter introduced you to the concept of Excel automation: via xlwings,
    you can use Python for tasks that you would traditionally do in VBA. We learned
    about the Excel object model and how xlwings allows you to interact with its components
    like the `sheet` and `range` objects. Equipped with this knowledge, we went back
    to the reporting case study from [Chapter 7](index_split_019.html#filepos863345)
    and used xlwings to fill in a preformatted report template; this showed you that
    there is a case for using the reader packages and xlwings side by side. We also
    learned about the libraries that xlwings uses under the hood to understand how
    we can improve performance and work around missing functionality. My favorite
    xlwings feature is that it works equally well on macOS as it does on Windows.
    This is even more exciting as Power Query on macOS doesn’t have all the features
    of the Windows version yet: whatever is missing, you should be able to easily
    replace it with a combination of pandas and xlwings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know the xlwings basics, you are ready for the next chapter: there,
    we’re going to take the next step and call xlwings scripts from Excel itself,
    allowing you to build Excel tools that are powered by Python.'
  prefs: []
  type: TYPE_NORMAL
- en: '[1  ](index_split_024.html#filepos1238292) On Windows, you need at least Excel
    2007, and on macOS, you need at least Excel 2016\. Alternatively, you can install
    the desktop version of Excel, which is part of your Microsoft 365 subscription.
    Check your subscription for details on how to do this.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[2  ](index_split_024.html#filepos1248734) Note that xlwings 0.22.0 introduced
    the `xw.load` function, which is similar to `xw.view`, but works in the opposite
    direction: it allows you to load an Excel range easily into a Jupyter notebook
    as a pandas DataFrame, see [the docs](https://oreil.ly/x7sTR).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[3  ](index_split_024.html#filepos1253391) See [“What are Excel instances,
    and why is this important?”](https://oreil.ly/L2FDT) for more information about
    separate Excel instances.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[4  ](#filepos1367425) Another popular collection is `tables`. To use them,
    you need at least xlwings 0.21.0; see the [docs](https://oreil.ly/H2Imd).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[5  ](#filepos1390175) Defined names with formulas are also used for lambda
    functions, a new way of defining user-defined functions without VBA or JavaScript,
    that Microsoft announced as a new feature for Microsoft 365 subscribers in December
    2020.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
