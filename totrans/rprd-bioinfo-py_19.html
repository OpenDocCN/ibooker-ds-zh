<html><head></head><body><section data-pdf-bookmark="Chapter 17. DNA Synthesizer: Creating Synthetic Data with Markov Chains" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch17">&#13;
<h1><span class="label">Chapter 17. </span>DNA Synthesizer: Creating Synthetic Data with Markov Chains</h1>&#13;
&#13;
&#13;
<p>A Markov chain is a model for representing a sequence of possibilities found in a given dataset.<a data-primary="DNA" data-secondary="synthesizer via Markov chains" data-tertiary="about Markov chains" data-type="indexterm" id="ch17-mar"/><a data-primary="Markov chains" data-secondary="about" data-type="indexterm" id="ch17-mar2"/><a data-primary="machine learning (ML)" data-secondary="about Markov chains" data-type="indexterm" id="ch17-mar3"/><a data-primary="synthesizing DNA via Markov chains" data-secondary="about Markov chains" data-type="indexterm" id="ch17-mar4"/>&#13;
It is a machine learning (ML) algorithm because it discovers or learns patterns from input data.&#13;
In this exercise, I’ll show how to use Markov chains trained on a set of DNA sequences to generate novel DNA sequences.</p>&#13;
&#13;
<p>In this exercise, you will:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Read some number of input sequence files to find all the unique k-mers for a given <em>k</em>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Create a Markov chain using these k-mers to produce some number of novel sequences of lengths bounded by a minimum and maximum.</p>&#13;
</li>&#13;
<li>&#13;
<p>Learn about generators.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use a random seed to replicate random selections.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Understanding Markov Chains" data-type="sect1"><div class="sect1" id="idm45963627726856">&#13;
<h1>Understanding Markov Chains</h1>&#13;
&#13;
<p>In Claude Shannon’s <a href="https://oreil.ly/8Gka4">“A Mathematical Theory of Communication”</a> (1948), the <a data-primary="Shannon, Claude" data-type="indexterm" id="idm45963627724792"/><a data-primary="A Mathematical Theory of Communication (Shannon)" data-primary-sortas="Mathematical Theory" data-type="indexterm" id="idm45963627724120"/><a data-primary="Markov chains" data-secondary="about" data-tertiary="Markoff process" data-type="indexterm" id="idm45963627723144"/><a data-primary="DNA" data-secondary="synthesizer via Markov chains" data-tertiary="Markoff process" data-type="indexterm" id="idm45963627721928"/><a data-primary="machine learning (ML)" data-secondary="about Markov chains" data-tertiary="Markoff process" data-type="indexterm" id="idm45963627720696"/><a data-primary="finite state machine (FSM)" data-secondary="Markoff process" data-type="indexterm" id="idm45963627719480"/><a data-primary="synthesizing DNA via Markov chains" data-secondary="about Markov chains" data-tertiary="Markoff process" data-type="indexterm" id="idm45963627718520"/>author describes a <em>Markoff process</em> that is surprisingly similar to graphs and the finite state diagrams I’ve been using to illustrate regular expressions.&#13;
Shannon describes this process as “a finite number of possible <em>states</em> of a system” and “a set of transition probabilities” that one state will lead to another.</p>&#13;
&#13;
<p>For one example of a Markov process, Shannon describes a system for generating strings of text by randomly selecting from the 26 letters of the English alphabet and a space.&#13;
In a “zero-order approximation,” each character has an equal probability of being chosen.&#13;
This process generates strings where letter combinations like <em>bz</em> and <em>qr</em> might appear as frequently as <em>st</em> and <em>qu</em>.&#13;
An examination of actual English words, however, would show that the latter two are orders of magnitude more common than the first two:</p>&#13;
&#13;
<pre data-type="programlisting">$ for LETTERS in bz qr st qu&#13;
&gt; do echo -n $LETTERS &amp;&amp; grep $LETTERS /usr/share/dict/words | wc -l; done&#13;
bz       4&#13;
qr       1&#13;
st   21433&#13;
qu    3553</pre>&#13;
&#13;
<p>To more accurately model the possible transition from one letter to another, Shannon introduces a “first-order approximation…obtained by choosing successive letters independently but each letter having the same probability that it has in the natural language.”&#13;
For this model, I need to train the selection process on representative texts of English.&#13;
Shannon notes that the letter <em>e</em> has a probability of 0.12, reflecting the frequency of its use in English words, whereas <em>w</em>, being much less frequently used, has a probability of 0.02, as shown in <a data-type="xref" href="#fig_17.1">Figure 17-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig_17.1">&#13;
<img alt="mpfb 1701" src="assets/mpfb_1701.png"/>&#13;
<h6><span class="label">Figure 17-1. </span>A finite state diagram that includes the probability of moving from any character in English to the letters “e” or “w”</h6>&#13;
</div></figure>&#13;
&#13;
<p>Shannon goes on to describe a “second-order approximation” where subsequent letters are “chosen in accordance with the frequencies with which the various letters follow the first one.”<a data-primary="k-mers" data-secondary="ML DNA synthesizer" data-tertiary="Markoff process" data-type="indexterm" id="idm45963627706952"/>&#13;
This relates to k-mers that I used several times in <a data-type="xref" href="part01.html#part_one">Part I</a>.&#13;
In linguistics, these are called <em>N-grams</em>.&#13;
For instance, what possible 3-mers could be created given the 2-mer <em>th</em>?&#13;
The letters <em>e</em> or <em>r</em> would be rather likely, whereas <em>z</em> would be impossible as no English word contains the sequence <em>thz</em>.</p>&#13;
&#13;
<p>I can perform a rough estimation of how often I can find these patterns.&#13;
I find approximately 236K English words using <strong><code>wc -l</code></strong> to count the lines of my system dictionary:</p>&#13;
&#13;
<pre data-type="programlisting">$ wc -l /usr/share/dict/words&#13;
  235886 /usr/share/dict/words</pre>&#13;
&#13;
<p>To find the frequency of the substrings, I need to account for the fact that some words may have the pattern twice.&#13;
For instance, here are a few words that have more than one occurrence of the pattern <em>the</em>:</p>&#13;
&#13;
<pre data-type="programlisting">$ grep -E '.*the.*the.*' /usr/share/dict/words | head -3&#13;
diathermotherapy&#13;
enthelminthes&#13;
hyperthermesthesia</pre>&#13;
&#13;
<p>I can use <code>grep -io</code> to search in a case-insensitive fashion (<code>-i</code>) for the strings <em>thr</em> and <em>the</em>, while the <code>-o</code> flag tells <code>grep</code> to return <em>only</em> the matching strings, which will reveal all the matches in each word.&#13;
I find that <em>thr</em> occurs 1,270 times, while <em>the</em> occurs 3,593 times:</p>&#13;
&#13;
<pre data-type="programlisting">$ grep -io thr /usr/share/dict/words | wc -l&#13;
    1270&#13;
$ grep -io the /usr/share/dict/words | wc -l&#13;
    3593</pre>&#13;
&#13;
<p>Dividing these numbers by the total number of words leads to a frequency of 0.005 for <em>thr</em> and 0.015 for <em>the</em>, as shown in <a data-type="xref" href="#fig_17.2">Figure 17-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig_17.2">&#13;
<img alt="mpfb 1702" src="assets/mpfb_1702.png"/>&#13;
<h6><span class="label">Figure 17-2. </span>A finite state diagram showing the probability of moving from “th” to either an “r” or an “e”</h6>&#13;
</div></figure>&#13;
&#13;
<p>I can apply these ideas to generate novel DNA sequences by reading some sample sequences and noting the ordering of the bases at the level of some k-mer like 10 base pairs (bp).&#13;
It’s important to note that different training texts will affect the model.&#13;
For instance, English words and spellings have changed over time, so training on older English texts like <em>Beowulf</em> and <em>Canterbury Tales</em> will yield different results than articles from modern newspapers.&#13;
This is the <em>learning</em> part of machine learning.&#13;
Many ML algorithms are designed to find patterns from some sets of data to apply to another set.&#13;
In the case of this program, the generated sequences will bear some resemblance in composition to the input sequences.&#13;
Running the program with the human genome as training data will produce different results than using a viral metagenome from an oceanic hydrothermal flume.<a data-startref="ch17-mar" data-type="indexterm" id="idm45963627685688"/><a data-startref="ch17-mar2" data-type="indexterm" id="idm45963627685016"/><a data-startref="ch17-mar3" data-type="indexterm" id="idm45963627684344"/><a data-startref="ch17-mar4" data-type="indexterm" id="idm45963627683672"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Getting Started" data-type="sect1"><div class="sect1" id="idm45963627682680">&#13;
<h1>Getting Started</h1>&#13;
&#13;
<p>You should work in the <em>17_synth</em> directory containing the inputs and tests for this program.<a data-primary="DNA" data-secondary="synthesizer via Markov chains" data-tertiary="getting started" data-type="indexterm" id="idm45963627680888"/><a data-primary="Markov chains" data-secondary="getting started" data-type="indexterm" id="idm45963627679656"/><a data-primary="machine learning (ML)" data-secondary="getting started" data-type="indexterm" id="idm45963627678712"/><a data-primary="synthesizing DNA via Markov chains" data-secondary="getting started" data-type="indexterm" id="idm45963627677768"/>&#13;
Start by copying the solution to the program <code>synth.py</code>:</p>&#13;
&#13;
<pre data-type="programlisting">$ cd 17_synth&#13;
$ cp solution.py synth.py</pre>&#13;
&#13;
<p>This program has a large number of parameters.&#13;
Run the help to see them:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./synth.py -h&#13;
usage: synth.py [-h] [-o FILE] [-f format] [-n number] [-x max] [-m min]&#13;
                [-k kmer] [-s seed]&#13;
                FILE [FILE ...]&#13;
&#13;
Create synthetic DNA using Markov chain&#13;
&#13;
positional arguments:&#13;
  FILE                  Training file(s) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-1" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
optional arguments:&#13;
  -h, --help            show this help message and exit&#13;
  -o FILE, --outfile FILE&#13;
                        Output filename (default: out.fa) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-2" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-2"><img alt="2" src="assets/2.png"/></a>&#13;
  -f format, --format format&#13;
                        Input file format (default: fasta) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-3" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-3"><img alt="3" src="assets/3.png"/></a>&#13;
  -n number, --num number&#13;
                        Number of sequences to create (default: 100) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-4" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-4"><img alt="4" src="assets/4.png"/></a>&#13;
  -x max, --max_len max&#13;
                        Maximum sequence length (default: 75) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-5" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-5"><img alt="5" src="assets/5.png"/></a>&#13;
  -m min, --min_len min&#13;
                        Minimum sequence length (default: 50) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-6" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-6"><img alt="6" src="assets/6.png"/></a>&#13;
  -k kmer, --kmer kmer  Size of kmers (default: 10) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-7" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-7"><img alt="7" src="assets/7.png"/></a>&#13;
  -s seed, --seed seed  Random seed value (default: None) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-8" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-8"><img alt="8" src="assets/8.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-1" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The only required parameter is one or more input files.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-2" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The output filename will default to <em>out.fa</em>.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-3" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The input format should be either <em>fasta</em> or <em>fastq</em> and defaults to the first.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-4" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>The default number of sequences generated will be 100.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-5" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>The default maximum sequence length is 75 bp.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-6" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>The default minimum sequence length is 50 bp.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-7" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>The default k-mer length is 10 bp.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-8" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>The default random seed is the <code>None</code> value.</p></dd>&#13;
</dl>&#13;
&#13;
<p>As usual, I create an <code>Args</code> class to represent these parameters.&#13;
I use the following &#13;
<span class="keep-together"><code>typing</code></span> imports.&#13;
Note the <code>Dict</code> is used later in the program:</p>&#13;
&#13;
<pre data-type="programlisting">from typing import NamedTuple, List, TextIO, Dict, Optional&#13;
&#13;
class Args(NamedTuple):&#13;
    """ Command-line arguments """&#13;
    files: List[TextIO] <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-1" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-1"><img alt="1" src="assets/1.png"/></a>&#13;
    outfile: TextIO <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-2" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-2"><img alt="2" src="assets/2.png"/></a>&#13;
    file_format: str <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-3" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-3"><img alt="3" src="assets/3.png"/></a>&#13;
    num: int <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-4" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-4"><img alt="4" src="assets/4.png"/></a>&#13;
    min_len: int <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-5" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-5"><img alt="5" src="assets/5.png"/></a>&#13;
    max_len: int <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-6" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-6"><img alt="6" src="assets/6.png"/></a>&#13;
    k: int <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-7" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-7"><img alt="7" src="assets/7.png"/></a>&#13;
    seed: Optional[int] <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-8" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-8"><img alt="8" src="assets/8.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-1" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The input <code>files</code> will be a list of open filehandles.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-2" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The <code>outfile</code> will be an open filehandle.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-3" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The <code>file_format</code> of the input files is a string.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-4" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>The number of sequences to generate (<code>num</code>) is an integer.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-5" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>The <code>min_len</code> is an integer.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-6" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>The <code>max_len</code> is an integer.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-7" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>The <code>k</code> for k-mer length is an integer.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-8" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>The random seed can either be the value <code>None</code> or an integer.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Here is how I define the program’s parameters:</p>&#13;
&#13;
<pre data-type="programlisting">def get_args() -&gt; Args:&#13;
    """ Get command-line arguments """&#13;
&#13;
    parser = argparse.ArgumentParser(&#13;
        description='Create synthetic DNA using Markov chain',&#13;
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)&#13;
&#13;
    parser.add_argument('file',&#13;
                        help='Training file(s)',&#13;
                        metavar='FILE',&#13;
                        nargs='+',&#13;
                        type=argparse.FileType('rt')) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-1" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
    parser.add_argument('-o',&#13;
                        '--outfile',&#13;
                        help='Output filename',&#13;
                        metavar='FILE',&#13;
                        type=argparse.FileType('wt'), <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-2" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-2"><img alt="2" src="assets/2.png"/></a>&#13;
                        default='out.fa')&#13;
&#13;
    parser.add_argument('-f',&#13;
                        '--format',&#13;
                        help='Input file format',&#13;
                        metavar='format',&#13;
                        type=str,&#13;
                        choices=['fasta', 'fastq'], <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-3" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-3"><img alt="3" src="assets/3.png"/></a>&#13;
                        default='fasta')&#13;
&#13;
    parser.add_argument('-n',&#13;
                        '--num',&#13;
                        help='Number of sequences to create',&#13;
                        metavar='number',&#13;
                        type=int,&#13;
                        default=100) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-4" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-4"><img alt="4" src="assets/4.png"/></a>&#13;
&#13;
    parser.add_argument('-x',&#13;
                        '--max_len',&#13;
                        help='Maximum sequence length',&#13;
                        metavar='max',&#13;
                        type=int,&#13;
                        default=75) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-5" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-5"><img alt="5" src="assets/5.png"/></a>&#13;
&#13;
    parser.add_argument('-m',&#13;
                        '--min_len',&#13;
                        help='Minimum sequence length',&#13;
                        metavar='min',&#13;
                        type=int,&#13;
                        default=50) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-6" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-6"><img alt="6" src="assets/6.png"/></a>&#13;
&#13;
    parser.add_argument('-k',&#13;
                        '--kmer',&#13;
                        help='Size of kmers',&#13;
                        metavar='kmer',&#13;
                        type=int,&#13;
                        default=10) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-7" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-7"><img alt="7" src="assets/7.png"/></a>&#13;
&#13;
    parser.add_argument('-s',&#13;
                        '--seed',&#13;
                        help='Random seed value',&#13;
                        metavar='seed',&#13;
                        type=int,&#13;
                        default=None) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-8" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-8"><img alt="8" src="assets/8.png"/></a>&#13;
&#13;
    args = parser.parse_args()&#13;
&#13;
    return Args(files=args.file,&#13;
                outfile=args.outfile,&#13;
                file_format=args.format,&#13;
                num=args.num,&#13;
                min_len=args.min_len,&#13;
                max_len=args.max_len,&#13;
                k=args.kmer,&#13;
                seed=args.seed)</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-1" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The <code>type</code> restricts the values to readable text files, and the <code>nargs</code> requires one or more values.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-2" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The <code>type</code> restricts the value to a writable text file, and the default filename will be <em>out.fa</em>.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-3" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The <code>choices</code> restrict the values to either <code>fasta</code> or <code>fastq</code>, and the default will be <code>fasta</code>.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-4" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>The <code>type</code> restricts this to a valid integer value, and the default is <code>100</code>.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-5" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>The <code>type</code> restricts this to a valid integer value, and the default is <code>75</code>.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-6" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>The <code>type</code> restricts this to a valid integer value, and the default is <code>50</code>.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-7" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>The <code>type</code> restricts this to a valid integer value, and the default is <code>10</code>.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-8" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>The <code>type</code> restricts this to a valid integer value, and the default is <code>None</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>It might seem a little odd that the <code>seed</code> has <code>type=int</code> but has a default of <code>None</code> because <code>None</code> is not an integer.&#13;
What I’m saying is that if the user provides any value for the seed, it must be a valid integer; otherwise, the value will be <code>None</code>.&#13;
This is also reflected in the <code>Args.seed</code> definition as an <code>Optional[int]</code>, which means the value can either be <code>int</code> or <code>None</code>.&#13;
Note that this is equivalent to <code>typing.Union[int, None]</code>, the union of the <code>int</code> type and <code>None</code> value.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Understanding Random Seeds" data-type="sect2"><div class="sect2" id="idm45963627534808">&#13;
<h2>Understanding Random Seeds</h2>&#13;
&#13;
<p>There is an element of randomness to this program as you generate the sequences.<a data-primary="DNA" data-secondary="synthesizer via Markov chains" data-tertiary="random seeds explained" data-type="indexterm" id="idm45963627533432"/><a data-primary="Markov chains" data-secondary="random seeds explained" data-type="indexterm" id="idm45963627532200"/><a data-primary="machine learning (ML)" data-secondary="random seeds explained" data-type="indexterm" id="idm45963627531256"/><a data-primary="synthesizing DNA via Markov chains" data-secondary="random seeds explained" data-type="indexterm" id="idm45963627530312"/>&#13;
I can start with Shannon’s zero-order implementation where I select each base independently at random.&#13;
I can use the <code>random.choice()</code> function to select one base:<a data-primary="random() function" data-secondary="choice()" data-type="indexterm" id="idm45963627528616"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; bases = list('ACGT')&#13;
&gt;&gt;&gt; import random&#13;
&gt;&gt;&gt; random.choice(bases)&#13;
'G'</pre>&#13;
&#13;
<p class="pagebreak-before">If I wanted to generate a 10-bp sequence, I could use a list comprehension with the <code>range()</code> function, like this:<a data-primary="range() function" data-secondary="random() used with" data-type="indexterm" id="idm45963627525672"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; [random.choice(bases) for _ in range(10)]&#13;
['G', 'T', 'A', 'A', 'C', 'T', 'C', 'T', 'C', 'T']</pre>&#13;
&#13;
<p>I could further select a random sequence length between some minimum and maximum length using the <code>random.randint()</code> function:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; [random.choice(bases) for _ in range(random.randint(10, 20))]&#13;
['G', 'T', 'C', 'A', 'C', 'C', 'A', 'G', 'C', 'A', 'G']</pre>&#13;
&#13;
<p>If you execute the preceding code on your computer, it’s highly unlikely you will see the same output as shown.&#13;
Fortunately, these selections are only pseudorandom as they are produced deterministically by a random number generator (RNG).<a data-primary="random number generator (RNG)" data-type="indexterm" id="idm45963627521448"/>&#13;
Truly random, unreproducible choices would make testing this program impossible.</p>&#13;
&#13;
<p>I can use a <em>seed</em> or initial value to force the pseudorandom selections to be predictable.&#13;
If you read <strong><code>help(random.seed)</code></strong>, you’ll see that the “supported seed types are <code>None</code>, <code>int</code>, <code>float</code>, <code>str</code>, <code>bytes</code>, and <code>bytearray</code>.”&#13;
For instance, I can seed using an <span class="keep-together">integer:</span></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; random.seed(1)&#13;
&gt;&gt;&gt; [random.choice(bases) for _ in range(random.randint(10, 20))]&#13;
['A', 'G', 'A', 'T', 'T', 'T', 'T', 'C', 'A', 'T', 'A', 'T']</pre>&#13;
&#13;
<p>I can also use a string:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; random.seed('markov')&#13;
&gt;&gt;&gt; [random.choice(bases) for _ in range(random.randint(10, 20))]&#13;
['G', 'A', 'G', 'C', 'T', 'A', 'A', 'C', 'G', 'T', 'C', 'C', 'C', 'G', 'G']</pre>&#13;
&#13;
<p>If you execute the preceding code, you should get the exact output shown.&#13;
By default, the random seed is <code>None</code>, which you’ll notice is the default for the program.&#13;
This is the same as not setting the seed at all, so when the program runs with the default it will act in a pseudorandom manner.&#13;
When testing, I can provide a value that will produce a known result to verify that the program works correctly.</p>&#13;
&#13;
<p>Note that I have forced the user to provide an integer value.&#13;
Although I find using integers to be convenient, you can seed using strings, numbers, or bytes when writing your own programs.&#13;
Just remember that the integer <code>4</code> and the string <code>'4'</code> are two different values and will produce different results:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; random.seed(4) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO4-1" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO4-1"><img alt="1" src="assets/1.png"/></a>&#13;
&gt;&gt;&gt; [random.choice(bases) for _ in range(random.randint(10, 20))]&#13;
['G', 'A', 'T', 'T', 'C', 'A', 'A', 'A', 'T', 'G', 'A', 'C', 'G']&#13;
&gt;&gt;&gt; random.seed('4') <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO4-2" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO4-2"><img alt="2" src="assets/2.png"/></a>&#13;
&gt;&gt;&gt; [random.choice(bases) for _ in range(random.randint(10, 20))]&#13;
['G', 'A', 'T', 'C', 'G', 'G', 'A', 'G', 'A', 'C', 'C', 'A']</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO4-1" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Seed using the integer value <code>4</code>.<a data-primary="random() function" data-secondary="seed()" data-type="indexterm" id="idm45963627502136"/></p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO4-2" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Seed using the string value <code>'4'</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>The random seed affects every call to <code>random</code> functions from that point forward.&#13;
This creates a <em>global</em> change to your program, and so should be viewed with extreme caution.&#13;
Typically, I will set the random seed in my program immediately after validating the arguments:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    random.seed(args.seed)</pre>&#13;
&#13;
<p>If the seed is the default value of <code>None</code>, this will not affect the <code>random</code> functions.&#13;
If the user has provided a seed value, then all subsequent <code>random</code> calls will be affected.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reading the Training Files" data-type="sect2"><div class="sect2" id="idm45963627493416">&#13;
<h2>Reading the Training Files</h2>&#13;
&#13;
<p>The first step in my program is to read the training files.<a data-primary="DNA" data-secondary="synthesizer via Markov chains" data-tertiary="reading the training files" data-type="indexterm" id="idm45963627492056"/><a data-primary="Markov chains" data-secondary="reading the training files" data-type="indexterm" id="idm45963627490808"/><a data-primary="machine learning (ML)" data-secondary="reading the training files" data-type="indexterm" id="idm45963627489848"/><a data-primary="synthesizing DNA via Markov chains" data-secondary="reading the training files" data-type="indexterm" id="idm45963627488888"/>&#13;
Due to how I defined this argument with <code>argparse</code>, the process of validating the input files has been handled, and I know I will have a <code>List[TextIO]</code> which is a list of open filehandles.&#13;
I will use <code>Bio.SeqIO.parse()</code>, as in previous chapters, to read the sequences.<a data-primary="Biopython library" data-secondary="Bio.SeqIO" data-tertiary="ML training files parsed" data-type="indexterm" id="idm45963627486248"/></p>&#13;
&#13;
<p>From the training files, I want to produce a dictionary that describes the weighted possible bases that can follow each k-mer.<a data-primary="dictionaries" data-secondary="ML DNA synthesizer" data-type="indexterm" id="ch17-dict"/><a data-primary="k-mers" data-secondary="ML DNA synthesizer" data-tertiary="dictionary of weighted bases" data-type="indexterm" id="ch17-dict2"/>&#13;
I think it’s helpful to use a type alias to define a couple of new types to describe this.&#13;
First, I want a dictionary that maps a base like <em>T</em> to a floating-point value between 0 and 1 to describe the probability of choosing this base.&#13;
I’ll call it a <code>WeightedChoice</code>:</p>&#13;
&#13;
<pre data-type="programlisting">WeightedChoice = Dict[str, float]</pre>&#13;
&#13;
<p>For instance, in the sequence <em>ACGTACGC</em>, the 3-mer <em>ACG</em> is followed by either <em>T</em> or <em>C</em> with equal likelihood.&#13;
I represent this like so:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; choices = {'T': 0.5, 'C': 0.5}</pre>&#13;
&#13;
<p>Next, I want a type that maps the k-mer <em>ACG</em> to the choices.&#13;
I’ll call this a <code>Chain</code> as it represents the Markov chain:</p>&#13;
&#13;
<pre data-type="programlisting">Chain = Dict[str, WeightedChoice]</pre>&#13;
&#13;
<p>It would look like this:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; weighted = {'ACG': {'T': 0.5, 'C': 0.5}}</pre>&#13;
&#13;
<p>Each k-mer from the sequences in the input file will have a dictionary of weighted options for use in selecting the next base.&#13;
Here is how I use it to define a function to read the training files:</p>&#13;
&#13;
<pre data-type="programlisting">def read_training(fhs: List[TextIO], file_format: str, k: int) -&gt; Chain: <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO5-1" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO5-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Read training files, return dict of chains """&#13;
&#13;
    pass <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO5-2" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO5-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO5-1" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The function accepts a list of filehandles, the file format of the files, and the size of the k-mers to read. It returns the type <code>Chain</code>.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO5-2" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Use <code>pass</code> to do nothing and return <code>None</code> for now.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Since k-mers figure prominently in this solution, you may want to use the <code>find_kmers()</code> function from <a data-type="xref" href="part01.html#part_one">Part I</a>.&#13;
As a reminder, for a function with this signature:</p>&#13;
&#13;
<pre data-type="programlisting">def find_kmers(seq: str, k: int) -&gt; List[str]:&#13;
    """ Find k-mers in string """</pre>&#13;
&#13;
<p>I would use the following test:</p>&#13;
&#13;
<pre data-type="programlisting">def test_find_kmers() -&gt; None:&#13;
    """ Test find_kmers """&#13;
&#13;
    assert find_kmers('ACTG', 2) == ['AC', 'CT', 'TG']&#13;
    assert find_kmers('ACTG', 3) == ['ACT', 'CTG']&#13;
    assert find_kmers('ACTG', 4) == ['ACTG']</pre>&#13;
&#13;
<p>I think it’s helpful to see exactly what goes into this function and what I expect it to return.&#13;
In the <em>tests/unit_test.py</em> file, you’ll find all the unit tests for this program.&#13;
Here is the test for this function:</p>&#13;
&#13;
<pre data-type="programlisting">def test_read_training() -&gt; None: <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-1" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Test read_training """&#13;
&#13;
    f1 = io.StringIO('&gt;1\nACGTACGC\n') <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-2" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-2"><img alt="2" src="assets/2.png"/></a>&#13;
    assert read_training([f1], 'fasta', 4) == { <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-3" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-3"><img alt="3" src="assets/3.png"/></a>&#13;
        'ACG': { 'T': 0.5, 'C': 0.5 },&#13;
        'CGT': { 'A': 1.0 },&#13;
        'GTA': { 'C': 1.0 },&#13;
        'TAC': { 'G': 1.0 }&#13;
    }&#13;
&#13;
    f2 = io.StringIO('@1\nACGTACGC\n+\n!!!!!!!!') <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-4" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-4"><img alt="4" src="assets/4.png"/></a>&#13;
    assert read_training([f2], 'fastq', 5) == {  <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-5" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-5"><img alt="5" src="assets/5.png"/></a>&#13;
        'ACGT': { 'A': 1.0 },&#13;
        'CGTA': { 'C': 1.0 },&#13;
        'GTAC': { 'G': 1.0 },&#13;
        'TACG': { 'C': 1.0 }&#13;
    }</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-1" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The function takes no arguments and returns <code>None</code>.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-2" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Define a mock filehandle containing a single sequence in FASTA format.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-3" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Read the data in FASTA format and return the Markov chains for 4-mers.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-4" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Define a mock filehandle containing a single sequence in FASTQ format.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-5" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Read the data in FASTQ format and return the Markov chains for 5-mers.</p></dd>&#13;
</dl>&#13;
&#13;
<p>To help you better understand k-mers, I’ve included a program called <code>kmer_tiler.py</code> that will show you the overlapping k-mers in a given sequence.<a data-primary="k-mers" data-secondary="overlapping k-mers in a given sequence" data-type="indexterm" id="idm45963627429240"/>&#13;
The first test in the preceding function checks that the 3-mer <em>ACG</em> is followed by either <em>T</em> or <em>C</em> with equal probability to create the 4-mers <em>ACGT</em> and <em>ACGC</em>.&#13;
Looking at the output from <code>kmer_tiler.py</code>, I can see these two possibilities:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./kmer_tiler.py ACGTACGC -k 4&#13;
There are 5 4-mers in "ACGTACGC."&#13;
ACGTACGC&#13;
ACGT <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO7-1" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO7-1"><img alt="1" src="assets/1.png"/></a>&#13;
 CGTA&#13;
  GTAC&#13;
   TACG&#13;
    ACGC <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO7-2" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO7-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO7-1" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><em>ACG</em> followed by <em>T</em>.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO7-2" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO7-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p><em>ACG</em> followed by <em>C</em>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Using this information, I can create Shannon’s second-order approximation.&#13;
For instance, if I randomly select the 3-mer <em>ACG</em> to start generating a new sequence, I can add either <em>T</em> or <em>C</em> with equal probability.&#13;
Given this training data, I could never append either <em>A</em> or <em>G</em>, as these patterns never occur.</p>&#13;
&#13;
<p>This is a tricky function to write, so let me give you some pointers.&#13;
First, you need to find all the k-mers in all the sequences in all the files.&#13;
For each k-mer, you need <span class="keep-together">to find</span> all the possible endings for a sequence of length <code>k - 1</code>.&#13;
That is, if <code>k</code> is <code>4</code>, you first find all the 4-mers and then note how the leading 3-mer can be completed with the last base.</p>&#13;
&#13;
<p>I used <code>collections.Counter()</code> and ended up with an interim data structure that looks like this:</p>&#13;
&#13;
<pre data-type="programlisting">{&#13;
    'ACG': Counter({'T': 1, 'C': 1}),&#13;
    'CGT': Counter({'A': 1}),&#13;
    'GTA': Counter({'C': 1}),&#13;
    'TAC': Counter({'G': 1})&#13;
}</pre>&#13;
&#13;
<p>Since the input files are all DNA sequences, each k-mer can have at most four possible choices.&#13;
The key to the Markov chain is in giving these values weights, so next, I need to divide each option by the total number of options.&#13;
In the case of <em>ACG</em>, there are two possible values each occurring once, so they each get a weight of 1/2 or 0.5.&#13;
The data structure I return from this function looks like the following:</p>&#13;
&#13;
<pre data-type="programlisting">{&#13;
    'ACG': {'T': 0.5, 'C': 0.5},&#13;
    'CGT': {'A': 1.0},&#13;
    'GTA': {'C': 1.0},&#13;
    'TAC': {'G': 1.0}&#13;
}</pre>&#13;
&#13;
<p>I recommend you first focus on writing a function that passes this test.<a data-startref="ch17-dict" data-type="indexterm" id="idm45963627403256"/><a data-startref="ch17-dict2" data-type="indexterm" id="idm45963627402584"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Generating the Sequences" data-type="sect2"><div class="sect2" id="idm45963627401592">&#13;
<h2>Generating the Sequences</h2>&#13;
&#13;
<p>Next, I recommend you concentrate on using the <code>Chain</code> to generate new sequences.<a data-primary="DNA" data-secondary="synthesizer via Markov chains" data-tertiary="generating the sequences" data-type="indexterm" id="idm45963627399784"/><a data-primary="Markov chains" data-secondary="generating the sequences" data-type="indexterm" id="idm45963627398536"/><a data-primary="machine learning (ML)" data-secondary="generating the sequences" data-type="indexterm" id="idm45963627397576"/><a data-primary="synthesizing DNA via Markov chains" data-secondary="generating the sequences" data-type="indexterm" id="idm45963627396616"/>&#13;
Here is a stub for your function:</p>&#13;
&#13;
<pre data-type="programlisting">def gen_seq(chain: Chain, k: int, min_len: int, max_len: int) -&gt; Optional[str]: <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO8-1" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO8-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Generate a sequence """&#13;
&#13;
    return '' <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO8-2" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO8-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO8-1" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO8-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The function accepts the <code>Chain</code>, the size of the k-mers, and the minimum and maximum sequence length. It might or might not return a new sequence as a string, for reasons I’ll explain shortly.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO8-2" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO8-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>For now, return the empty string.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note">&#13;
<p>When stubbing a function, I interchange <code>pass</code> with returning some dummy value. Here I use the empty string since the function returns a <code>str</code>. The point is only to create a function that Python parses and which I can use for testing. At this point, I <em>expect</em> the function to fail.</p>&#13;
</div>&#13;
&#13;
<p>Here is the test I wrote for this:</p>&#13;
&#13;
<pre data-type="programlisting">def test_gen_seq() -&gt; None: <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-1" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Test gen_seq """&#13;
&#13;
    chain = { <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-2" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-2"><img alt="2" src="assets/2.png"/></a>&#13;
        'ACG': { 'T': 0.5, 'C': 0.5 },&#13;
        'CGT': { 'A': 1.0 },&#13;
        'GTA': { 'C': 1.0 },&#13;
        'TAC': { 'G': 1.0 }&#13;
    }&#13;
&#13;
    state = random.getstate() <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-3" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-3"><img alt="3" src="assets/3.png"/></a>&#13;
    random.seed(1) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-4" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-4"><img alt="4" src="assets/4.png"/></a>&#13;
    assert gen_seq(chain, k=4, min_len=6, max_len=12) == 'CGTACGTACG' <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-5" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-5"><img alt="5" src="assets/5.png"/></a>&#13;
    random.seed(2) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-6" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-6"><img alt="6" src="assets/6.png"/></a>&#13;
    assert gen_seq(chain, k=4, min_len=5, max_len=10) == 'ACGTA' <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-7" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-7"><img alt="7" src="assets/7.png"/></a>&#13;
    random.setstate(state) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-8" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-8"><img alt="8" src="assets/8.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-1" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The function accepts no arguments and returns <code>None</code>.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-2" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>This is the data structure returned by the <code>read_training()</code> function.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-3" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Save the current global state of the <code>random</code> module.<a data-primary="random() function" data-secondary="getstate()" data-type="indexterm" id="idm45963627354872"/></p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-4" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Set the seed to a known value of <code>1</code>.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-5" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Verify that the proper sequence is generated.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-6" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Set the seed to a different known value of <code>2</code>.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-7" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Verify that the proper sequence is generated.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-8" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Restore the <code>random</code> module to any previous state.<a data-primary="random() function" data-secondary="setstate()" data-type="indexterm" id="idm45963627339256"/></p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note">&#13;
<p>As noted before, calling <code>random.seed()</code> globally modifies the state of the <code>random</code> module.<a data-primary="random() function" data-secondary="seed()" data-type="indexterm" id="idm45963627336216"/> I use <code>random.getstate()</code> to save the current state before modifying and then restore that state when the testing is finished.</p>&#13;
</div>&#13;
&#13;
<p>This is a tricky function to write, so I’ll give you some direction.&#13;
You will first randomly select the length of the sequence to generate, and the <code>random.randint()</code> function will do just that.&#13;
Note that the upper and lower bounds are inclusive:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; min_len, max_len = 5, 10&#13;
&gt;&gt;&gt; import random&#13;
&gt;&gt;&gt; seq_len = random.randint(min_len, max_len)&#13;
&gt;&gt;&gt; seq_len&#13;
9</pre>&#13;
&#13;
<p>Next, you should initialize the sequence using one of the keys from the Markov <code>Chain</code> structure.&#13;
Note the need to coerce the <code>list(chain.keys())</code> to avoid the error “<code>dict_keys</code> object is not subscriptable”:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; chain = {&#13;
...     'ACG': { 'T': 0.5, 'C': 0.5 },&#13;
...     'CGT': { 'A': 1.0 },&#13;
...     'GTA': { 'C': 1.0 },&#13;
...     'TAC': { 'G': 1.0 }&#13;
... }&#13;
&gt;&gt;&gt; seq = random.choice(list(chain.keys()))&#13;
&gt;&gt;&gt; seq&#13;
'ACG'</pre>&#13;
&#13;
<p>I decided to set up a loop with the condition that the length of the sequence is less than the chosen sequence length.&#13;
While inside the loop, I will keep appending bases.&#13;
To select each new base, I need to get the last <code>k - 1</code> bases of the ever-growing sequence, which I can do using a list slice and negative indexing.&#13;
Here’s one pass through the loop:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; k = 4&#13;
&gt;&gt;&gt; while len(seq) &lt; seq_len:&#13;
...     prev = seq[-1 * (k - 1):]&#13;
...     print(prev)&#13;
...     break&#13;
...&#13;
ACG</pre>&#13;
&#13;
<p>If this previous value occurs in the given chain, then I can select the next base using the <code>random.choices()</code> function.&#13;
If you read <strong><code>help(random.choices)</code></strong>, you will see that this function accepts a <code>population</code> from which to select, <code>weights</code> to consider when making the selection, and a <code>k</code> for the number of choices to return.&#13;
The keys of the chain for a given k-mer are the population:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; opts = chain['ACG']&#13;
&gt;&gt;&gt; pop = opts.keys()&#13;
&gt;&gt;&gt; pop&#13;
dict_keys(['T', 'C'])</pre>&#13;
&#13;
<p>The values of the chain are the weights:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; weights = opts.values()&#13;
&gt;&gt;&gt; weights&#13;
dict_values([0.5, 0.5])</pre>&#13;
&#13;
<p>Note the need to coerce the keys and values using <code>list()</code>, and that &#13;
<span class="keep-together"><code>random.choices()</code></span> always returns a <code>list</code> even when you ask for just one, so you’ll need to select the first value:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from random import choices&#13;
&gt;&gt;&gt; next = choices(population=list(pop), weights=list(weights), k=1)&#13;
&gt;&gt;&gt; next&#13;
['T']</pre>&#13;
&#13;
<p>I can append this to the sequence:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq += next[0]&#13;
&gt;&gt;&gt; seq&#13;
'ACGT'</pre>&#13;
&#13;
<p>The loop repeats until either the sequence is the correct length or I select a previous value that does not exist in the chain.&#13;
The next time through the loop, the <code>prev</code> 3-mer will be <em>CGT</em>, as these are the last three bases in <code>seq</code>.&#13;
It happens that <em>CGT</em> is a key in the chain, but you may sometimes find that there is no way to continue the sequence because the next k-mer doesn’t exist in the chain.&#13;
In this case, you can exit your loop and return <code>None</code> from the function. This is why the <code>gen_seq()</code> function signature returns an <code>Optional[str]</code>;&#13;
I don’t want my function to return sequences that are too short.&#13;
I recommend that you not move on until this function passes the unit test.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Structuring the Program" data-type="sect2"><div class="sect2" id="idm45963627313896">&#13;
<h2>Structuring the Program</h2>&#13;
&#13;
<p>Once you can read the training files and generate a new sequence using the Markov chain algorithm, you are ready to print the new sequences to the output file.<a data-primary="DNA" data-secondary="synthesizer via Markov chains" data-tertiary="structuring the program" data-type="indexterm" id="idm45963627312456"/><a data-primary="Markov chains" data-secondary="structuring the program" data-type="indexterm" id="idm45963627311224"/><a data-primary="machine learning (ML)" data-secondary="structuring the program" data-type="indexterm" id="idm45963627310280"/><a data-primary="synthesizing DNA via Markov chains" data-secondary="structuring the program" data-type="indexterm" id="idm45963627309336"/>&#13;
Here is a general outline of how my program works:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    random.seed(args.seed)&#13;
    chains = read_training(...)&#13;
    seqs = calls to gen_seq(...)&#13;
    print each sequence to the output file&#13;
    print the final status</pre>&#13;
&#13;
<p>Note that the program will only generate FASTA output, and each sequence should be numbered from 1 as the ID.&#13;
That is, your output file should look something like this:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;1&#13;
GGATTAGATA&#13;
&gt;2&#13;
AGTCAACG</pre>&#13;
&#13;
<p>The test suite is pretty large as there are so many options to check.<a data-primary="DNA" data-secondary="synthesizer via Markov chains" data-tertiary="test suite" data-type="indexterm" id="idm45963627305432"/><a data-primary="Markov chains" data-secondary="test suite" data-type="indexterm" id="idm45963627304200"/><a data-primary="machine learning (ML)" data-secondary="test suite" data-type="indexterm" id="idm45963627303256"/><a data-primary="synthesizing DNA via Markov chains" data-secondary="test suite" data-type="indexterm" id="idm45963627302312"/>&#13;
I recommend you run <strong><code>make test</code></strong> or read the <em>Makefile</em> to see the longer command to ensure that you are properly running all the unit and integration tests.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect1"><div class="sect1" id="idm45963627299608">&#13;
<h1>Solution</h1>&#13;
&#13;
<p>I have just one solution for this program as it’s complicated enough.<a data-primary="DNA" data-secondary="synthesizer via Markov chains" data-tertiary="solution" data-type="indexterm" id="ch17-mcsol"/><a data-primary="Markov chains" data-secondary="solution" data-type="indexterm" id="ch17-mcsol2"/><a data-primary="machine learning (ML)" data-secondary="solution" data-type="indexterm" id="ch17-mcsol3"/><a data-primary="synthesizing DNA via Markov chains" data-secondary="solution" data-type="indexterm" id="ch17-mcsol4"/>&#13;
I’ll start with my function to read the training files, which requires you to import <code>defaultdict()</code> and <code>Counter()</code> from the <code>collections</code> module:</p>&#13;
&#13;
<pre data-type="programlisting">def read_training(fhs: List[TextIO], file_format: str, k: int) -&gt; Chain:&#13;
    """ Read training files, return dict of chains """&#13;
&#13;
    counts: Dict[str, Dict[str, int]] = defaultdict(Counter) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-1" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-1"><img alt="1" src="assets/1.png"/></a>&#13;
    for fh in fhs: <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-2" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-2"><img alt="2" src="assets/2.png"/></a>&#13;
        for rec in SeqIO.parse(fh, file_format): <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-3" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-3"><img alt="3" src="assets/3.png"/></a>&#13;
            for kmer in find_kmers(str(rec.seq), k): <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-4" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-4"><img alt="4" src="assets/4.png"/></a>&#13;
                counts[kmer[:k - 1]][kmer[-1]] += 1 <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-5" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-5"><img alt="5" src="assets/5.png"/></a>&#13;
&#13;
    def weight(freqs: Dict[str, int]) -&gt; Dict[str, float]: <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-6" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-6"><img alt="6" src="assets/6.png"/></a>&#13;
        total = sum(freqs.values()) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-7" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-7"><img alt="7" src="assets/7.png"/></a>&#13;
        return {base: freq / total for base, freq in freqs.items()} <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-8" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-8"><img alt="8" src="assets/8.png"/></a>&#13;
&#13;
    return {kmer: weight(freqs) for kmer, freqs in counts.items()} <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-9" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-9"><img alt="9" src="assets/9.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-1" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Initialize a dictionary to hold the Markov chains.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-2" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Iterate through each filehandle.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-3" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Iterate through each sequence in the filehandle.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-4" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Iterate through each k-mer in the sequence.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-5" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Use the prefix of the k-mer as the key into the Markov chain, and add to the count of the final base.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-6" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Define a function that will turn the counts into weighted values.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-7" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Find the total number of bases.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-8" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Divide the frequencies of each base by the total.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-9" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-9"><img alt="9" src="assets/9.png"/></a></dt>&#13;
<dd><p>Use a dictionary comprehension to convert the raw counts into weights.</p></dd>&#13;
</dl>&#13;
&#13;
<p>This uses the <code>find_kmers()</code> function from <a data-type="xref" href="part01.html#part_one">Part I</a>, which is:</p>&#13;
&#13;
<pre data-type="programlisting">def find_kmers(seq: str, k: int) -&gt; List[str]:&#13;
    """ Find k-mers in string """&#13;
&#13;
    n = len(seq) - k + 1 <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO11-1" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO11-1"><img alt="1" src="assets/1.png"/></a>&#13;
    return [] if n &lt; 1 else [seq[i:i + k] for i in range(n)] <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO11-2" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO11-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO11-1" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO11-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The number of k-mers is the length of the sequence minus <code>k</code> plus 1.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO11-2" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO11-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Use a list comprehension to select all the k-mers from the sequence.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Here is how I wrote the <code>gen_seq()</code> function to generate a single sequence:</p>&#13;
&#13;
<pre data-type="programlisting">def gen_seq(chain: Chain, k: int, min_len: int, max_len: int) -&gt; Optional[str]:&#13;
    """ Generate a sequence """&#13;
&#13;
    seq = random.choice(list(chain.keys())) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-1" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-1"><img alt="1" src="assets/1.png"/></a>&#13;
    seq_len = random.randint(min_len, max_len) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-2" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-2"><img alt="2" src="assets/2.png"/></a>&#13;
&#13;
    while len(seq) &lt; seq_len: <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-3" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-3"><img alt="3" src="assets/3.png"/></a>&#13;
        prev = seq[-1 * (k - 1):] <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-4" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-4"><img alt="4" src="assets/4.png"/></a>&#13;
        if choices := chain.get(prev): <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-5" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-5"><img alt="5" src="assets/5.png"/></a>&#13;
            seq += random.choices(population=list(choices.keys()), <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-6" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-6"><img alt="6" src="assets/6.png"/></a>&#13;
                                  weights=list(choices.values()),&#13;
                                  k=1)[0]&#13;
        else:&#13;
            break <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-7" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-7"><img alt="7" src="assets/7.png"/></a>&#13;
&#13;
    return seq if len(seq) &gt;= min_len else None <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-8" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-8"><img alt="8" src="assets/8.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-1" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Initialize the sequence to a random choice from the keys of the chain.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-2" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Select a length for the sequence.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-3" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Execute a loop while the length of the sequence is less than the desired length.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-4" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Select the last <code>k - 1</code> bases.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-5" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Attempt to get a list of choices for this k-mer.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-6" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Randomly choose the next base using the weighted choices.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-7" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>If we cannot find this k-mer in the chain, exit the loop.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-8" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Return the new sequence if it is long enough; otherwise return <code>None</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>To integrate all these, here is my <code>main()</code> function:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    random.seed(args.seed) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-1" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-1"><img alt="1" src="assets/1.png"/></a>&#13;
    if chain := read_training(args.files, args.file_format, args.k): <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-2" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-2"><img alt="2" src="assets/2.png"/></a>&#13;
        seqs = (gen_seq(chain, args.k, args.min_len, args.max_len) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-3" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-3"><img alt="3" src="assets/3.png"/></a>&#13;
                for _ in count())&#13;
&#13;
        for i, seq in enumerate(filter(None, seqs), start=1): <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-4" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-4"><img alt="4" src="assets/4.png"/></a>&#13;
            print(f'&gt;{i}\n{seq}', file=args.outfile) <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-5" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-5"><img alt="5" src="assets/5.png"/></a>&#13;
            if i == args.num: <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-6" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-6"><img alt="6" src="assets/6.png"/></a>&#13;
                break&#13;
&#13;
        print(f'Done, see output in "{args.outfile.name}".') <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-7" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-7"><img alt="7" src="assets/7.png"/></a>&#13;
    else:&#13;
        sys.exit(f'No {args.k}-mers in input sequences.') <a class="co" href="#callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-8" id="co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-8"><img alt="8" src="assets/8.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-1" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Set the random seed.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-2" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Read the training files in the given format using the given size <code>k</code>. This may fail if the sequences are shorter than <code>k</code>.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-3" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Create a generator to produce the sequences.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-4" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Use <code>filter()</code> with a predicate of <code>None</code> to remove falsey elements from the <code>seqs</code> generator. Use <code>enumerate()</code> to iterate through the index positions and sequences starting at 1 instead of 0.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-5" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Print the sequence in FASTA format using the index position as the ID.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-6" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Break out of the loop if enough sequences have been generated.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-7" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Print the final status.</p></dd>&#13;
<dt><a class="co" href="#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-8" id="callout_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Let the user know why no sequences could be generated.</p></dd>&#13;
</dl>&#13;
&#13;
<p>I’d like to take a moment to explain the generator in the preceding code.&#13;
I use the <code>range()</code> function to generate the desired number of sequences.&#13;
I could have used a list comprehension like so:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from solution import gen_seq, read_training&#13;
&gt;&gt;&gt; import io&#13;
&gt;&gt;&gt; f1 = io.StringIO('&gt;1\nACGTACGC\n')&#13;
&gt;&gt;&gt; chain = read_training([f1], 'fasta', k=4)&#13;
&gt;&gt;&gt; [gen_seq(chain, k=4, min_len=3, max_len=5) for _ in range(3)]&#13;
['CGTACG', 'CGTACG', 'TACGTA']</pre>&#13;
&#13;
<p>A list comprehension will force the creation of all the sequences before moving to the next line.&#13;
If I were creating millions of sequences, the program would block here and likely use a large amount of memory to store all the sequences.&#13;
If I replace the square brackets <code>[]</code> of the list comprehension with parentheses <code>()</code>, then it becomes a lazy generator:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seqs = (gen_seq(chain, k=4, min_len=3, max_len=5) for _ in range(3))&#13;
&gt;&gt;&gt; type(seqs)&#13;
&lt;class 'generator'&gt;</pre>&#13;
&#13;
<p>I can still treat this like a list by iterating over the values, but these values are only produced as needed.&#13;
That means the line of code to create the generator executes almost immediately and moves on to the <code>for</code> loop.&#13;
Additionally, the program only uses the memory needed to produce the next sequence.</p>&#13;
&#13;
<p>One small problem with using <code>range()</code> and the number of sequences is that I know the <code>gen_seq()</code> function may sometimes return <code>None</code> to indicate that random choices lead down a chain that didn’t produce a long enough sequence.&#13;
I need the generator to run with no upper limit, and I’ll write code to stop requesting sequences when enough have been generated.&#13;
I can use <code>itertools.count()</code> to create an infinite sequence, and I use <code>filter()</code> with a predicate of <code>None</code> to remove falsey elements:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seqs = ['ACGT', None, 'CCCGT']&#13;
&gt;&gt;&gt; list(filter(None, seqs))&#13;
['ACGT', 'CCCGT']</pre>&#13;
&#13;
<p>I can run the final program to create an output file using the defaults:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./synth.py tests/inputs/*&#13;
Done, see output in "out.fa".</pre>&#13;
&#13;
<p>And then I can use <code>seqmagique.py</code> from <a data-type="xref" href="ch15.html#ch15">Chapter 15</a> to verify that it generated the correct number of sequences in the expected ranges:</p>&#13;
&#13;
<pre data-type="programlisting">$ ../15_seqmagique/seqmagique.py out.fa&#13;
name      min_len    max_len    avg_len    num_seqs&#13;
out.fa         50         75      63.56         100</pre>&#13;
&#13;
<p>Flippin’ sweet.<a data-startref="ch17-mcsol" data-type="indexterm" id="idm45963627138520"/><a data-startref="ch17-mcsol2" data-type="indexterm" id="idm45963627137848"/><a data-startref="ch17-mcsol3" data-type="indexterm" id="idm45963627137176"/><a data-startref="ch17-mcsol4" data-type="indexterm" id="idm45963627136504"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Going Further" data-type="sect1"><div class="sect1" id="idm45963627135512">&#13;
<h1>Going Further</h1>&#13;
&#13;
<p>Add a sequence <code>--type</code> option to produce either DNA or RNA.</p>&#13;
&#13;
<p>Expand the program to handle paired-end sequences where the forward and reverse reads are in two separate files.</p>&#13;
&#13;
<p>Now that you understand Markov chains, you might be interested to see how they are used elsewhere in bioinformatics.&#13;
For instance, the <a href="http://hmmer.org">HMMER</a> tool uses hidden Markov models to find homologs in sequence databases and to create sequence <span class="keep-together">alignments.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review" data-type="sect1"><div class="sect1" id="idm45963627130968">&#13;
<h1>Review</h1>&#13;
&#13;
<p>Key points from this chapter:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Random seeds are used to replicate pseudorandom selections.</p>&#13;
</li>&#13;
<li>&#13;
<p>Markov chains can be used to encode the probabilities that a node in a graph can move to another node or state.</p>&#13;
</li>&#13;
<li>&#13;
<p>A list comprehension can be made into a lazy generator by replacing the square brackets with parentheses.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>