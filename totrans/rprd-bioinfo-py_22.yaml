- en: Appendix A. Documenting Commands and Creating Workflows with make
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `make` program was created in 1976 to help build executable programs from
    source code files. Though it was originally developed to assist with programming
    in the C language, it is not limited to that language or even to the task of compiling
    code. According to the manual, one “can use it to describe any task where some
    files must be updated automatically from others whenever the others change.” The
    `make` program has evolved far beyond its role as a build tool to become a workflow
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Makefiles Are Recipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you run the `make` command, it looks for a file called *Makefile* (or *makefile*)
    in the current working directory. This file contains recipes that describe discrete
    actions that combine to create some output. Think of how a recipe for a lemon
    meringue pie has steps that need to be completed in a particular order and combination.
    For instance, I need to separately create the crust, filling, and meringue and
    then put them together and bake them before I can enjoy a tasty treat. I can visualize
    this with something called a *string diagram*, as illustrated in [Figure A-1](#fig_a1.1).
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb aa01](assets/mpfb_aa01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A-1\. A string diagram describing how to make a pie, adapted from Brendan
    Fong and David Spivak, An Invitation to Applied Category Theory (Seven Sketches
    in Compositionality), Cambridge University Press, 2019
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s not important if you make the pie crust the day before and keep it chilled,
    and the same might hold true for the filling, but it’s certainly true that the
    crust needs to go into the dish first, followed by the filling and finally the
    meringue. An actual recipe might refer to generic recipes for crust and meringue
    elsewhere and list only the steps for the lemon filling and baking instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can write a *Makefile* to mock up these ideas. I’ll use shell scripts to
    pretend I’m assembling the various ingredients into some output files like *crust.txt*
    and *filling.txt*. In the *app01_makefiles/pie* directory, I’ve written a *combine.sh*
    script that expects a filename and a list of “ingredients” to put into the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'I can pretend to make the crust like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There is now a *crust.txt* file with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s common but not necessary for a recipe in a *Makefile* to create an output
    file. Note in this example that the `clean` target removes files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_documenting_commands_and_creating_workflows_with_make_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This defines a target called `all`. The first target will be the one that is
    run when no target is specified. Convention holds that the `all` target will run
    *all* the targets necessary to accomplish some default goal, like building a piece
    of software. Here I want to create the *pie.txt* file from the component files
    and “cook” it. The name `all` is not as important as the fact that it is defined
    first. The target name is followed by a colon and then any dependencies that must
    be satisfied before running this target.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_documenting_commands_and_creating_workflows_with_make_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `all` target has two commands to run. Each command is indented with a Tab
    character.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_documenting_commands_and_creating_workflows_with_make_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the `filling.txt` target. The goal of this target is to create the file
    called *filling.txt*. It’s common but not necessary to use the output filename
    as the target name. This target has just one command, which is to combine the
    ingredients for the filling.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_documenting_commands_and_creating_workflows_with_make_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the `meringue.txt` target, and it combines the egg whites and sugar.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_documenting_commands_and_creating_workflows_with_make_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the `crust.txt` target that combines flour, butter, and water.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_documenting_commands_and_creating_workflows_with_make_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: It’s common to have a `clean` target to remove any files that were created in
    the normal course of building.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding example, the target has a name followed by a
    colon. Any dependent actions can be listed after the colon in the order you wish
    them to be run. The actions for a target must be indented with a Tab character,
    as shown in Figure A-2, and you are allowed to define as many commands as you
    like.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb aa02](assets/mpfb_aa02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A-2\. A Makefile target is terminated by a colon and optionally followed
    by dependencies; all the target’s actions must be indented with a single tab character
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Running a Specific Target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each action in a *Makefile* is called a *target*, *rule*, or *recipe*. The order
    of the targets is not important beyond the first target being the default. Targets,
    like the functions in Python programs, can reference other targets defined earlier
    or later in the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run a specific target, I run **`make target`** to have `make` run the commands
    for a given recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And now there is a file called *filling.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If I try to run this target again, I’ll be told there’s nothing to do because
    the file already exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the reasons for the existence of `make` is precisely not to do extra
    work to create files unless some underlying source has changed. In the course
    of building software or running a pipeline, it may not be necessary to generate
    some output unless the inputs have changed, such as the source code being modified.
    To force `make` to run the *filling.txt* target, I can either remove that file
    or run **`make clean`** to remove any of the files that have been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Running with No Target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you run the `make` command with no arguments, it will automatically run the
    first target. This is the main reason to place the `all` target (or something
    like it) first. Be careful not to put something destructive like a `clean` target
    first, as you might end up accidentally running it and removing valuable data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output when I run `make` with the preceding *Makefile*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_documenting_commands_and_creating_workflows_with_make_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: I run `make` with no arguments. It looks for the first target in a file called
    *Makefile* in the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_documenting_commands_and_creating_workflows_with_make_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The *crust.txt* recipe is run first. Because I didn’t specify a target, `make`
    runs the `all` target which is defined first, and this target lists *crust.txt*
    as the first dependency.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_documenting_commands_and_creating_workflows_with_make_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the *filling.txt* target is run.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_documenting_commands_and_creating_workflows_with_make_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This is followed by the *meringue.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_documenting_commands_and_creating_workflows_with_make_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Next I assemble *pie.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_documenting_commands_and_creating_workflows_with_make_CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: And then I “cook” the pie at 375 degrees for 45 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I run `make` again, I’ll see that the intermediate steps to produce the
    *crust.txt*, *filling.txt*, and *meringue.txt* files are skipped because they
    already exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If I want to force them to be recreated I can run `make clean && make`, where
    the `&&` is a logical *and* that will only run the second command if the first
    command succeeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Makefiles Create DAGs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each target can specify other targets as prerequisites or dependencies that
    must be completed first. These actions create a graph structure with a starting
    point and paths through targets to finally create some output file(s). The path
    described for any target should be a *directed* (from a start to a stop) *acyclic*
    (having no cycles or infinite loops) *graph*, or DAG, as shown in Figure A-3.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb aa03](assets/mpfb_aa03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A-3\. The targets may join together to describe a directed acyclic graph
    of actions to produce some result
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Many analysis pipelines are just that—a graph of some input, like a FASTA sequence
    file, and some transformations (trimming, filtering, comparisons) into some output,
    like BLAST hits, gene predictions, or functional annotations. You would be surprised
    at just how far `make` can be abused to document your work and even create fully
    functional analysis pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Using make to Compile a C Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I believe it helps to use `make` for its intended purpose at least once in
    your life to understand why it exists. I’ll take a moment to write and compile
    a “Hello, World” example in the C language. In the *app01_makefiles/c-hello* directory,
    you will find a simple C program that will print “Hello, World!” Here is the *hello.c*
    source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_documenting_commands_and_creating_workflows_with_make_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Like in `bash`, the `#` character introduces comments in the C language, but
    this is a special comment that allows external modules of code to be used. Here,
    I want to use the `printf` (print-format) function, so I need to `include` the
    standard I/O (input/output) module, called `stdio`. I only need to include the
    “header” file, `stdio.h`, to get at the function definitions in that module. This
    is a standard module, and the C compiler will look in various locations for any
    included files to find it. There may be times when you are unable to compile C
    (or C++ programs) from source code because some header file cannot be found. For
    example, the `gzip` library is often used to de/compress data, but it is not always
    installed in a library form that other programs may `include` in this way. Therefore,
    you will have to download and install the `libgz` program, being sure to install
    the headers into the proper `include` directories. Note that package managers
    like `apt-get` and `yum` often have `-dev` or `-devel` packages that you have
    to install to get these headers; that is, you’ll need to install both `libgz`
    and `libgz-dev` or whatnot.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_documenting_commands_and_creating_workflows_with_make_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the start of a function declaration in C. The function name (`main`)
    is preceded by its return type (`int`). The parameters to the function are listed
    inside the parentheses after its name. In this case there are none, so the parentheses
    are empty. The opening curly brace (`{`) shows the start of the code that belongs
    to the function. Note that C will automatically execute the `main()` function,
    and every C program must have a `main()` function where the program starts.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_documenting_commands_and_creating_workflows_with_make_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `printf()` function will print the given string to the command line. This
    function is defined in the `stdio` library, which is why I need to `#include`
    the header file above.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_documenting_commands_and_creating_workflows_with_make_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: '`return` will exit the function and return the value `0`. Since this is the
    return value for the `main()` function, this will be the exit value for the entire
    program. The value `0` indicates that the program ran normally—think “zero errors.”
    Any non-zero value would indicate a failure.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_documenting_commands_and_creating_workflows_with_make_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The closing curly brace (`}`) is the mate for the one on line 2 and marks the
    end of the `main()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To turn that into an executable program you will need to have a C compiler
    on your machine. For instance, I can use `gcc`, the GNU C compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'That will create a file called *a.out*, which is an executable file. On my
    Macintosh, this is what `file` will report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And I can execute that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'I don’t like the name *a.out*, though, so I can use the `-o` option to name
    the output file *hello*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Run the resulting *hello* executable. You should see the same output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than typing `gcc -o hello hello.c` every time I modify *hello.c*, I
    can put that in a *Makefile*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And now I can run **`make hello`** or just **`make`** if this is the first
    target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If I run **`make`** again, nothing happens because the *hello.c* file hasn’t
    changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What happens if I alter the *hello.c* code to print “Hola” instead of “Hello,”
    and then try running `make` again?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'I can force `make` to run the targets using the `-B` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And now the new program has been compiled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is a trivial example, and you may be wondering how this saves time. A real-world
    project in C or any language would likely have multiple *.c* files with headers
    (*.h* files) describing their functions so that they could be used by other *.c*
    files. The C compiler would need to turn each *.c* file into a *.o* (*out*) file
    and then link them together into a single executable. Imagine you have dozens
    of *.c* files, and you change one line of code in one file. Do you want to type
    dozens of commands to recompile and link all your code? Of course not. You would
    build a tool to automate those actions for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can add targets to the *Makefile* that don’t generate new files. It’s common
    to have a `clean` target that will clean up files and directories that I no longer
    need. Here I can create a `clean` target to remove the *hello* executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If I want to be sure that the executable is always removed before running the
    `hello` target, I can add it as a dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s good to document for `make` that this is a *phony* target because the
    result of the target is not a newly created file. I use the `.PHONY:` target and
    list all the phonies. Here is the complete *Makefile* now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run **`make`** in the *c-hello* directory with the preceding *Makefile*,
    you should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And there should now be a *hello* executable in your directory that you can
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `clean` target can be listed as a dependency to the `hello`
    target even *before* the target itself is mentioned. `make` will read the entire
    file and then use the dependencies to resolve the graph. If you were to put `foo`
    as an additional dependency to `hello` and then run **`make`** again, you would
    see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: A *Makefile* allows me to write independent groups of actions that are ordered
    by their dependencies. They are like *functions* in a higher-level language. I
    have essentially written a program whose output is another program.
  prefs: []
  type: TYPE_NORMAL
- en: I’d encourage you to run **`cat hello`** to view the contents of the *hello*
    file. It’s mostly binary information that will look like gibberish, but you will
    probably be able to make out some plain English, too. You can also use **`strings
    hello`** to extract just the strings of text.
  prefs: []
  type: TYPE_NORMAL
- en: Using make for a Shortcut
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s look at how I can abuse a *Makefile* to create shortcuts for commands.
    In the *app01_makefiles/hello* directory, you will find the following *Makefile*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_documenting_commands_and_creating_workflows_with_make_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Since the `hello` target doesn’t produce a file, I list it as a phony target.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_documenting_commands_and_creating_workflows_with_make_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the `hello` target. The name of the target should be composed only of
    letters and numbers, should have no spaces before it, and is followed by a colon
    (`:`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_documenting_commands_and_creating_workflows_with_make_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The command(s) to run for the `hello` target are listed on lines that are indented
    with a tab character.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can execute this with **`make`**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: I often use a *Makefile* to remember how to invoke a command with various arguments.
    That is, I might write an analysis pipeline and then document how to run the program
    on various datasets with all their parameters. In this way, I’m documenting my
    work in a way that I can immediately reproduce by running the target.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is an example of a *Makefile* I wrote to document how I used the Centrifuge
    program for making taxonomic assignments to short reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_documenting_commands_and_creating_workflows_with_make_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Here I define the variable `INDEX_DIR` and assign a value. Note that there must
    be spaces on either side of the `=`. I prefer ALL_CAPS for my variable names,
    but this is my personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_documenting_commands_and_creating_workflows_with_make_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `clean_paired` target prior to running this target. This ensures that
    there is no leftover output from a previous run.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_documenting_commands_and_creating_workflows_with_make_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This action is long, so I used backslashes (`\`) as on the command line to indicate
    that the command continues to the next line.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_documenting_commands_and_creating_workflows_with_make_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: To have `make` *deference* or use the value of the `$HOME` environment variable,
    use the syntax `$(HOME)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_documenting_commands_and_creating_workflows_with_make_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: '`$(INDEX_DIR)` refers to the variable defined at the top.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the *app01_makefiles/yeast* directory is an example of how to write a workflow
    as `make` targets. The goal is to download the yeast genome and characterize various
    gene types as “Dubious,” “Uncharacterized,” “Verified,” and so on. This is accomplished
    with a collection of command-line tools such as `wget`, `grep`, and `awk`, combined
    with a custom shell script called *download.sh*, all pieced together and run in
    order by `make`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: I won’t bother commenting on all the commands. Mostly I want to demonstrate
    how far I can abuse a *Makefile* to create a workflow. Not only have I documented
    all the steps, but they are *runnable* with nothing more than the command **`make`**.
    Absent using `make`, I’d have to write a shell script to accomplish this or, more
    likely, move to a more powerful language like Python. The resulting program written
    in either language would probably be longer, buggier, and more difficult to understand.
    Sometimes, all you need is a *Makefile* and some shell commands.
  prefs: []
  type: TYPE_NORMAL
- en: Other Workflow Managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you bump up against the limitations of `make`, you may choose to move to
    a workflow manager. There are many to choose from. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Snakemake extends the basic concepts of `make` with Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Common Workflow Language (CWL) defines workflows and parameters in a configuration
    file (in YAML), and you use tools like `cwltool` or `cwl-runner` (both implemented
    in Python) to execute the workflow with another configuration file that describes
    the arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Workflow Description Language (WDL) takes a similar approach to describe
    workflows and arguments and can be run with the Cromwell engine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pegasus allows you to use Python code to describe a workflow that then is written
    to an XML file, which is the input for the engine that will run your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nextflow is similar in that you use a full programming language called Groovy
    (a subset of Java) to write a workflow that can be run by the Nextflow engine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these systems follow the same basic ideas as `make`, so understanding
    how `make` works and how to write the pieces of your workflow and how they interact
    is the basis for any larger analysis workflow you may create.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some other resources you can use to learn about `make`:'
  prefs: []
  type: TYPE_NORMAL
- en: The [GNU Make Manual](https://oreil.ly/D9daZ)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The GNU Make Book* by John Graham-Cumming (No Starch Press, 2015)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Managing Projects with GNU Make*](https://oreil.ly/D8Oyk) by Robert Mecklenburg
    (O’Reilly, 2004)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
