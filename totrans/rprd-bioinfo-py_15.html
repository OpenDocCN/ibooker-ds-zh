<html><head></head><body><section data-pdf-bookmark="Chapter 14. Finding Open Reading Frames" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch14">&#13;
<h1><span class="label">Chapter 14. </span>Finding Open Reading Frames</h1>&#13;
&#13;
&#13;
<p>The <a href="https://oreil.ly/DPWXc">ORF challenge</a> is the last Rosalind problem I’ll tackle in this book.&#13;
The goal is to find all the possible open reading frames (ORFs) in a sequence of DNA.<a data-primary="open reading frames (ORFs)" data-secondary="about" data-type="indexterm" id="idm45963629162232"/><a data-primary="DNA" data-secondary="open reading frames" data-see="open reading frames" data-type="indexterm" id="idm45963629161272"/><a data-primary="proteins" data-secondary="open reading frames" data-see="open reading frames" data-type="indexterm" id="idm45963629160056"/><a data-primary="codons" data-secondary="open reading frames" data-tertiary="about" data-type="indexterm" id="idm45963629158840"/>&#13;
An ORF is a region of nucleotides between the start codon and the stop codon.<a data-primary="codons" data-secondary="stop codons" data-type="indexterm" id="idm45963629157400"/><a data-primary="start codons" data-type="indexterm" id="idm45963629156456"/><a data-primary="codons" data-secondary="start codons" data-type="indexterm" id="idm45963629155784"/><a data-primary="stop codons" data-type="indexterm" id="idm45963629154840"/>&#13;
The solution will consider both the forward and reverse complement as well as frameshifts.&#13;
Although there are existing tools such as TransDecoder to find coding regions, writing<a data-primary="TransDecoder to find coding regions" data-type="indexterm" id="idm45963629153848"/> a bespoke solution brings together many skills from previous chapters, including reading a FASTA file, creating the reverse complement of a sequence, using string slices, finding k-mers, using multiple <code>for</code> loops/iterations, translating DNA, and using regular expressions.</p>&#13;
&#13;
<p>You will learn:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>How to truncate a sequence to a length evenly divisible by a codon size</p>&#13;
</li>&#13;
<li>&#13;
<p>How to use the <code>str.find()</code> and <code>str.partition()</code> functions</p>&#13;
</li>&#13;
<li>&#13;
<p>How to document a regular expression using code formatting, comments, and Python’s implicit string concatenation</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Getting Started" data-type="sect1"><div class="sect1" id="idm45963629147528">&#13;
<h1>Getting Started</h1>&#13;
&#13;
<p>The code, tests, and solutions for this challenge are located in the <em>14_orf</em> directory.<a data-primary="open reading frames (ORFs)" data-secondary="getting started" data-type="indexterm" id="idm45963629145736"/><a data-primary="codons" data-secondary="open reading frames" data-tertiary="getting started" data-type="indexterm" id="idm45963629144776"/>&#13;
Start by copying the first solution to the program <code>orf.py</code>:</p>&#13;
&#13;
<pre data-type="programlisting">$ cd 14_orf/&#13;
$ cp solution1_iterate_set.py orf.py</pre>&#13;
&#13;
<p>If you request the usage, you’ll see the program takes a single positional argument of a FASTA-formatted file of sequences:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./orf.py -h&#13;
usage: orf.py [-h] FILE&#13;
&#13;
Open Reading Frames&#13;
&#13;
positional arguments:&#13;
  FILE        Input FASTA file&#13;
&#13;
optional arguments:&#13;
  -h, --help  show this help message and exit</pre>&#13;
&#13;
<p>The first test input file has the same content as the example on the Rosalind page.&#13;
Note that I’ve broken the sequence file here, but it’s a single line in the input file:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat tests/inputs/1.fa&#13;
&gt;Rosalind_99&#13;
AGCCATGTAGCTAACTCAGGTTACATGGGGATGACCCCGCGACTTGGATTAGAGTCTCTTTTGGAATAAG\&#13;
CCTGAATGATCCGAGTAGCATCTCAG</pre>&#13;
&#13;
<p>Run the program with this input file and note the output.&#13;
The order of the ORFs is not important:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./orf.py tests/inputs/1.fa&#13;
M&#13;
MGMTPRLGLESLLE&#13;
MLLGSFRLIPKETLIQVAGSSPCNLS&#13;
MTPRLGLESLLE</pre>&#13;
&#13;
<p>Run the test suite to ensure the program passes the tests.&#13;
When you are satisfied with how your program should work, start over:</p>&#13;
&#13;
<pre data-type="programlisting">$ new.py -fp 'Open Reading Frames' orf.py&#13;
Done, see new script "orf.py".</pre>&#13;
&#13;
<p>At this point, you probably need no help in defining a single positional file argument, but here is the code you can use:</p>&#13;
&#13;
<pre data-type="programlisting">class Args(NamedTuple):&#13;
    """ Command-line arguments """&#13;
    file: TextIO&#13;
&#13;
&#13;
def get_args() -&gt; Args:&#13;
    """ Get command-line arguments """&#13;
&#13;
    parser = argparse.ArgumentParser(&#13;
        description='Open Reading Frames',&#13;
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)&#13;
&#13;
    parser.add_argument('file', <a class="co" href="#callout_finding_open_reading_frames_CO1-1" id="co_finding_open_reading_frames_CO1-1"><img alt="1" src="assets/1.png"/></a>&#13;
                        help='Input FASTA file',&#13;
                        metavar='FILE',&#13;
                        type=argparse.FileType('rt'))&#13;
&#13;
    args = parser.parse_args()&#13;
&#13;
    return Args(args.file)</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO1-1" id="callout_finding_open_reading_frames_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Define a positional argument that must be a readable text file.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Modify the <code>main()</code> to print the incoming filename:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    print(args.file.name)</pre>&#13;
&#13;
<p>Verify that the program prints the usage, rejects bad files, and prints the filename for a valid argument:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./orf.py tests/inputs/1.fa&#13;
tests/inputs/1.fa</pre>&#13;
&#13;
<p>At this point, your program should pass the first three tests.&#13;
Next, I’ll talk about how to make the program find ORFs.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Translating Proteins Inside Each Frame" data-type="sect2"><div class="sect2" id="idm45963629125944">&#13;
<h2>Translating Proteins Inside Each Frame</h2>&#13;
&#13;
<p>It might be helpful to write a bit of pseudocode to help sketch out what needs to <span class="keep-together">happen:</span><a data-primary="open reading frames (ORFs)" data-secondary="translating proteins inside each frame" data-type="indexterm" id="idm45963629124008"/><a data-primary="codons" data-secondary="open reading frames" data-tertiary="translating proteins inside each frame" data-type="indexterm" id="idm45963629123032"/><a data-primary="mRNA" data-secondary="open reading frames" data-type="indexterm" id="idm45963629121800"/></p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
&#13;
    # Iterate through each DNA sequence in the file:&#13;
        # Transcribe the sequence from DNA to mRNA&#13;
        # Iterate using the forward and reverse complement of the mRNA:&#13;
            # Iterate through 0, 1, 2 for frames in this sequence:&#13;
                # Translate the mRNA frame into a protein sequence&#13;
                # Try to find the ORFs in this protein sequence</pre>&#13;
&#13;
<p>You can use a <code>for</code> loop to iterate through the input sequences using <code>Bio.SeqIO</code>:<a data-primary="Biopython library" data-secondary="Bio.SeqIO" data-tertiary="open reading frames" data-type="indexterm" id="idm45963629118360"/></p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
&#13;
    for rec in SeqIO.parse(args.file, 'fasta'):&#13;
        print(str(rec.seq))</pre>&#13;
&#13;
<p>Run the program to verify that this works:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./orf.py tests/inputs/1.fa&#13;
AGCCATGTAGCTAACTCAGGTTACATGGGGATGACCCCGCGACTTGGATTAGAGTCTCTTTTGGA\&#13;
ATAAGCCTGAATGATCCGAGTAGCATCTCAG</pre>&#13;
&#13;
<p>I need to transcribe this to mRNA, which entails changing all the <em>T</em>s to <em>U</em>s.&#13;
I’ll let you use whatever solution from <a data-type="xref" href="ch02.html#ch02">Chapter 2</a> you like so long as your program can now print this:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./orf.py tests/inputs/1.fa&#13;
AGCCAUGUAGCUAACUCAGGUUACAUGGGGAUGACCCCGCGACUUGGAUUAGAGUCUCUUUUGGA\&#13;
AUAAGCCUGAAUGAUCCGAGUAGCAUCUCAG</pre>&#13;
&#13;
<p>Next, refer to <a data-type="xref" href="ch03.html#ch03">Chapter 3</a> and have your program print both the forward and reverse complements of this sequence:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./orf.py tests/inputs/1.fa&#13;
AGCCAUGUAGCUAACUCAGGUUACAUGGGGAUGACCCCGCGACUUGGAUUAGAGUCUCUUUUGGA\&#13;
AUAAGCCUGAAUGAUCCGAGUAGCAUCUCAG&#13;
CUGAGAUGCUACUCGGAUCAUUCAGGCUUAUUCCAAAAGAGACUCUAAUCCAAGUCGCGGGGUCA\&#13;
UCCCCAUGUAACCUGAGUUAGCUACAUGGCU</pre>&#13;
&#13;
<p>Refer to <a data-type="xref" href="ch07.html#ch07">Chapter 7</a> to translate the forward and reverse complements to proteins:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./orf.py tests/inputs/1.fa&#13;
SHVANSGYMGMTPRLGLESLLE*A*MIRVASQ&#13;
LRCYSDHSGLFQKRL*SKSRGHPHVT*VSYMA</pre>&#13;
&#13;
<p>Now, rather than reading each mRNA sequence from the beginning, implement frameshifts <a data-primary="codons" data-secondary="open reading frames" data-tertiary="translating proteins inside each frame" data-type="indexterm" id="idm45963629106984"/><a data-primary="mRNA" data-secondary="open reading frames" data-tertiary="frameshifts in reading" data-type="indexterm" id="idm45963629105752"/><a data-primary="open reading frames (ORFs)" data-secondary="translating proteins inside each frame" data-tertiary="frameshifts in reading" data-type="indexterm" id="idm45963629104536"/><a data-primary="frameshifts in open reading frames" data-type="indexterm" id="idm45963629103288"/>by reading them starting from the zeroth, first, and second characters, which you can do using a string slice.&#13;
If you use Biopython to translate the mRNA slice, you may encounter the warning:<a data-primary="Biopython library" data-secondary="error of partial codon" data-type="indexterm" id="idm45963629102264"/><a data-primary="errors" data-secondary="Biopython partial codon" data-type="indexterm" id="idm45963629101320"/><a data-primary="Biopython library" data-secondary="Bio.SeqIO" data-tertiary="error of partial codon" data-type="indexterm" id="idm45963629100376"/></p>&#13;
<blockquote>&#13;
<em>Partial codon, len(sequence) not a multiple of three. Explicitly trim the sequence or add trailing N before translation. This may become an error in the future.</em>&#13;
</blockquote>&#13;
<br/>&#13;
&#13;
<p>To fix this, I created a function to truncate a sequence to the nearest even division by a value:</p>&#13;
&#13;
<pre data-type="programlisting">def truncate(seq: str, k: int) -&gt; str:&#13;
    """ Truncate a sequence to even division by k """&#13;
&#13;
    return ''</pre>&#13;
&#13;
<p><a data-type="xref" href="#fig_14.1">Figure 14-1</a> shows the results of shifting through the string <code>0123456789</code> and truncating each result to a length that is evenly divisible by 3.</p>&#13;
&#13;
<figure><div class="figure" id="fig_14.1">&#13;
<img alt="mpfb 1401" src="assets/mpfb_1401.png"/>&#13;
<h6><span class="label">Figure 14-1. </span>Truncating the various frameshifts to a length that is evenly divisible by the codon size 3</h6>&#13;
</div></figure>&#13;
&#13;
<p>Here is a test you could use:</p>&#13;
&#13;
<pre data-type="programlisting">def test_truncate() -&gt; None:&#13;
    """ Test truncate """&#13;
&#13;
    seq = '0123456789'&#13;
    assert truncate(seq, 3) == '012345678'&#13;
    assert truncate(seq[1:], 3) == '123456789'&#13;
    assert truncate(seq[2:], 3) == '234567'</pre>&#13;
&#13;
<p>Change your program to print the protein translations for the three shifts for both the forward and reverse complements of the mRNA.&#13;
Be sure to print the entire translation, including all stop (<code>*</code>) codons, like so:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./orf.py tests/inputs/1.fa&#13;
SHVANSGYMGMTPRLGLESLLE*A*MIRVASQ&#13;
AM*LTQVTWG*PRDLD*SLFWNKPE*SE*HL&#13;
PCS*LRLHGDDPATWIRVSFGISLNDPSSIS&#13;
LRCYSDHSGLFQKRL*SKSRGHPHVT*VSYMA&#13;
*DATRIIQAYSKRDSNPSRGVIPM*PELATW&#13;
EMLLGSFRLIPKETLIQVAGSSPCNLS*LHG</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Finding the ORFs in a Protein Sequence" data-type="sect2"><div class="sect2" id="idm45963629089016">&#13;
<h2>Finding the ORFs in a Protein Sequence</h2>&#13;
&#13;
<p>Now that the program can find all the protein sequences from each frameshift of the mRNA, it’s time to look for the open reading frames in the proteins.<a data-primary="codons" data-secondary="open reading frames" data-tertiary="finding in a protein sequence" data-type="indexterm" id="idm45963629087560"/><a data-primary="open reading frames (ORFs)" data-secondary="finding in a protein sequence" data-type="indexterm" id="idm45963629086328"/>&#13;
Your code will need to consider every interval from each start codon to the first subsequent stop codon.<a data-primary="codons" data-secondary="start codons" data-type="indexterm" id="idm45963629085096"/><a data-primary="codons" data-secondary="stop codons" data-type="indexterm" id="idm45963629084152"/><a data-primary="start codons" data-type="indexterm" id="idm45963629083208"/><a data-primary="stop codons" data-type="indexterm" id="idm45963629082536"/>&#13;
The codon <em>AUG</em> is the most common start codon, and it codes for the amino acid methionine (<em>M</em>).&#13;
There are three possible stop codons shown with the asterisk (<code>*</code>).&#13;
For example, <a data-type="xref" href="#fig_14.2">Figure 14-2</a> shows that the amino acid sequence <em>MAMAPR*</em> contains two start codons and one stop codon and so has two possible proteins of <em>MAMAPR</em> and <em>MAPR</em>.&#13;
Although it is common for tools to report only the longer sequence, the Rosalind challenge expects all possible sequences.</p>&#13;
&#13;
<figure><div class="figure" id="fig_14.2">&#13;
<img alt="mpfb 1402" src="assets/mpfb_1402.png"/>&#13;
<h6><span class="label">Figure 14-2. </span>The protein sequence MAMAPR* has two overlapping open reading frames</h6>&#13;
</div></figure>&#13;
&#13;
<p>I decided to write a function called <code>find_orfs()</code> that will accept an amino acid string and return a list of ORFs:</p>&#13;
&#13;
<pre data-type="programlisting">def find_orfs(aa: str) -&gt; List[str]: <a class="co" href="#callout_finding_open_reading_frames_CO2-1" id="co_finding_open_reading_frames_CO2-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Find ORFs in AA sequence """&#13;
&#13;
    return [] <a class="co" href="#callout_finding_open_reading_frames_CO2-2" id="co_finding_open_reading_frames_CO2-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO2-1" id="callout_finding_open_reading_frames_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The function accepts a string of amino acids and returns a list of possible protein strings.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO2-2" id="callout_finding_open_reading_frames_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>For now, return the empty list.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Here is a test for this function.&#13;
If you can implement the <code>find_orfs()</code> that passes this test, then you should be able to pass the integration test:</p>&#13;
&#13;
<pre data-type="programlisting">def test_find_orfs() -&gt; None:&#13;
    """ Test find_orfs """&#13;
&#13;
    assert find_orfs('') == [] <a class="co" href="#callout_finding_open_reading_frames_CO3-1" id="co_finding_open_reading_frames_CO3-1"><img alt="1" src="assets/1.png"/></a>&#13;
    assert find_orfs('M') == [] <a class="co" href="#callout_finding_open_reading_frames_CO3-2" id="co_finding_open_reading_frames_CO3-2"><img alt="2" src="assets/2.png"/></a>&#13;
    assert find_orfs('*') == [] <a class="co" href="#callout_finding_open_reading_frames_CO3-3" id="co_finding_open_reading_frames_CO3-3"><img alt="3" src="assets/3.png"/></a>&#13;
    assert find_orfs('M*') == ['M'] <a class="co" href="#callout_finding_open_reading_frames_CO3-4" id="co_finding_open_reading_frames_CO3-4"><img alt="4" src="assets/4.png"/></a>&#13;
    assert find_orfs('MAMAPR*') == ['MAMAPR', 'MAPR'] <a class="co" href="#callout_finding_open_reading_frames_CO3-5" id="co_finding_open_reading_frames_CO3-5"><img alt="5" src="assets/5.png"/></a>&#13;
    assert find_orfs('MAMAPR*M') == ['MAMAPR', 'MAPR'] <a class="co" href="#callout_finding_open_reading_frames_CO3-6" id="co_finding_open_reading_frames_CO3-6"><img alt="6" src="assets/6.png"/></a>&#13;
    assert find_orfs('MAMAPR*MP*') == ['MAMAPR', 'MAPR', 'MP'] <a class="co" href="#callout_finding_open_reading_frames_CO3-7" id="co_finding_open_reading_frames_CO3-7"><img alt="7" src="assets/7.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO3-1" id="callout_finding_open_reading_frames_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The empty string should produce no ORFs.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO3-2" id="callout_finding_open_reading_frames_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>A single start codon with no stop codon should produce no ORFs.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO3-3" id="callout_finding_open_reading_frames_CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>A single stop codon with no preceding start codon should produce no ORFs.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO3-4" id="callout_finding_open_reading_frames_CO3-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>The function should return the start codon even if there are no intervening bases before the stop codon.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO3-5" id="callout_finding_open_reading_frames_CO3-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>This sequence contains two ORFs.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO3-6" id="callout_finding_open_reading_frames_CO3-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>This sequence also contains only two ORFs.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO3-7" id="callout_finding_open_reading_frames_CO3-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>This sequence contains three putative ORFs in two separate sections.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Once you can find all the ORFs in each mRNA sequence, you should collect them into a distinct list.&#13;
I suggest you use a <code>set()</code> for this.<a data-primary="open reading frames (ORFs)" data-secondary="set() for collecting ORFs" data-type="indexterm" id="idm45963629029480"/><a data-primary="set() for collecting" data-type="indexterm" id="idm45963629028504"/><a data-primary="codons" data-secondary="open reading frames" data-tertiary="set() for collecting ORFs" data-type="indexterm" id="idm45963629027832"/>&#13;
Though my solution prints the ORFs in sorted order, this is not a requirement for the test.&#13;
The solution will bring together many of the skills you’ve already learned.&#13;
The craft of writing longer and longer programs lies in composing smaller pieces that you understand and test.&#13;
Keep plugging away at your program until you pass all the tests.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solutions" data-type="sect1"><div class="sect1" id="idm45963629025624">&#13;
<h1>Solutions</h1>&#13;
&#13;
<p>I’ll present three solutions to finding ORFs using two string functions and regular expressions.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 1: Using the str.index() Function" data-type="sect2"><div class="sect2" id="idm45963629024088">&#13;
<h2>Solution 1: Using the str.index() Function</h2>&#13;
&#13;
<p>To start, here is how I wrote the <code>truncate()</code> function that will assuage the <code>Bio.Seq.translate()</code> function when I try to translate the various frame-shifted mRNA sequences:<a data-primary="codons" data-secondary="open reading frames" data-tertiary="solution 1 str.index()" data-type="indexterm" id="idm45963629021768"/><a data-primary="open reading frames (ORFs)" data-secondary="solution 1 str.index()" data-type="indexterm" id="idm45963629020552"/><a data-primary="Biopython library" data-secondary="Bio.Seq" data-tertiary="translate() needing truncation" data-type="indexterm" id="idm45963629019592"/><a data-primary="translate() function for strings" data-secondary="frameshifted mRNA sequences" data-type="indexterm" id="idm45963629018360"/><a data-primary="index() of strings" data-secondary="finding open reading frames" data-type="indexterm" id="idm45963629017384"/><a data-primary="strings (str)" data-secondary="index()" data-tertiary="finding open reading frames" data-type="indexterm" id="idm45963629016424"/><a data-primary="strings (str)" data-secondary="translate() function" data-type="indexterm" id="idm45963629015192"/></p>&#13;
&#13;
<pre data-type="programlisting">def truncate(seq: str, k: int) -&gt; str:&#13;
    """ Truncate a sequence to even division by k """&#13;
&#13;
    length = len(seq) <a class="co" href="#callout_finding_open_reading_frames_CO4-1" id="co_finding_open_reading_frames_CO4-1"><img alt="1" src="assets/1.png"/></a>&#13;
    end = length - (length % k) <a class="co" href="#callout_finding_open_reading_frames_CO4-2" id="co_finding_open_reading_frames_CO4-2"><img alt="2" src="assets/2.png"/></a>&#13;
    return seq[:end] <a class="co" href="#callout_finding_open_reading_frames_CO4-3" id="co_finding_open_reading_frames_CO4-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO4-1" id="callout_finding_open_reading_frames_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Find the length of the sequence.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO4-2" id="callout_finding_open_reading_frames_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The end of the desired subsequence is the length minus the length modulo <code>k</code>.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO4-3" id="callout_finding_open_reading_frames_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Return the subsequence.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Next, here is one way to write the <code>find_orfs()</code> that uses the <code>str.index()</code> function to find each starting <em>M</em> codon followed by a <code>*</code> stop codon:</p>&#13;
&#13;
<pre data-type="programlisting">def find_orfs(aa: str) -&gt; List[str]:&#13;
    orfs = [] <a class="co" href="#callout_finding_open_reading_frames_CO5-1" id="co_finding_open_reading_frames_CO5-1"><img alt="1" src="assets/1.png"/></a>&#13;
    while 'M' in aa: <a class="co" href="#callout_finding_open_reading_frames_CO5-2" id="co_finding_open_reading_frames_CO5-2"><img alt="2" src="assets/2.png"/></a>&#13;
        start = aa.index('M') <a class="co" href="#callout_finding_open_reading_frames_CO5-3" id="co_finding_open_reading_frames_CO5-3"><img alt="3" src="assets/3.png"/></a>&#13;
        if '*' in aa[start + 1:]: <a class="co" href="#callout_finding_open_reading_frames_CO5-4" id="co_finding_open_reading_frames_CO5-4"><img alt="4" src="assets/4.png"/></a>&#13;
            stop = aa.index('*', start + 1) <a class="co" href="#callout_finding_open_reading_frames_CO5-5" id="co_finding_open_reading_frames_CO5-5"><img alt="5" src="assets/5.png"/></a>&#13;
            orfs.append(''.join(aa[start:stop])) <a class="co" href="#callout_finding_open_reading_frames_CO5-6" id="co_finding_open_reading_frames_CO5-6"><img alt="6" src="assets/6.png"/></a>&#13;
            aa = aa[start + 1:] <a class="co" href="#callout_finding_open_reading_frames_CO5-7" id="co_finding_open_reading_frames_CO5-7"><img alt="7" src="assets/7.png"/></a>&#13;
        else:&#13;
            break <a class="co" href="#callout_finding_open_reading_frames_CO5-8" id="co_finding_open_reading_frames_CO5-8"><img alt="8" src="assets/8.png"/></a>&#13;
&#13;
    return orfs</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO5-1" id="callout_finding_open_reading_frames_CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Initialize a list to hold the ORFs.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO5-2" id="callout_finding_open_reading_frames_CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Create a loop to iterate while there are start codons present.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO5-3" id="callout_finding_open_reading_frames_CO5-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Use <code>str.index()</code> to find the location of the start codon.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO5-4" id="callout_finding_open_reading_frames_CO5-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>See if the stop codon is present after the start codon’s position.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO5-5" id="callout_finding_open_reading_frames_CO5-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Get the index of the stop codon after the start codon.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO5-6" id="callout_finding_open_reading_frames_CO5-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Use a string slice to grab the protein.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO5-7" id="callout_finding_open_reading_frames_CO5-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Set the amino acid string to the index after the position of the start codon to find the next start codon.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO5-8" id="callout_finding_open_reading_frames_CO5-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Leave the <code>while</code> loop if there is no stop codon.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Here is how I incorporate these ideas into the program:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    for rec in SeqIO.parse(args.file, 'fasta'): <a class="co" href="#callout_finding_open_reading_frames_CO6-1" id="co_finding_open_reading_frames_CO6-1"><img alt="1" src="assets/1.png"/></a>&#13;
        rna = str(rec.seq).replace('T', 'U') <a class="co" href="#callout_finding_open_reading_frames_CO6-2" id="co_finding_open_reading_frames_CO6-2"><img alt="2" src="assets/2.png"/></a>&#13;
        orfs = set() <a class="co" href="#callout_finding_open_reading_frames_CO6-3" id="co_finding_open_reading_frames_CO6-3"><img alt="3" src="assets/3.png"/></a>&#13;
&#13;
        for seq in [rna, Seq.reverse_complement(rna)]: <a class="co" href="#callout_finding_open_reading_frames_CO6-4" id="co_finding_open_reading_frames_CO6-4"><img alt="4" src="assets/4.png"/></a>&#13;
            for i in range(3): <a class="co" href="#callout_finding_open_reading_frames_CO6-5" id="co_finding_open_reading_frames_CO6-5"><img alt="5" src="assets/5.png"/></a>&#13;
                if prot := Seq.translate(truncate(seq[i:], 3), to_stop=False): <a class="co" href="#callout_finding_open_reading_frames_CO6-6" id="co_finding_open_reading_frames_CO6-6"><img alt="6" src="assets/6.png"/></a>&#13;
                    for orf in find_orfs(prot): <a class="co" href="#callout_finding_open_reading_frames_CO6-7" id="co_finding_open_reading_frames_CO6-7"><img alt="7" src="assets/7.png"/></a>&#13;
                        orfs.add(orf) <a class="co" href="#callout_finding_open_reading_frames_CO6-8" id="co_finding_open_reading_frames_CO6-8"><img alt="8" src="assets/8.png"/></a>&#13;
&#13;
        print('\n'.join(sorted(orfs))) <a class="co" href="#callout_finding_open_reading_frames_CO6-9" id="co_finding_open_reading_frames_CO6-9"><img alt="9" src="assets/9.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO6-1" id="callout_finding_open_reading_frames_CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Iterate through the input sequences.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO6-2" id="callout_finding_open_reading_frames_CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Transcribe the DNA sequence to mRNA.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO6-3" id="callout_finding_open_reading_frames_CO6-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Create an empty set to hold all the ORFs.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO6-4" id="callout_finding_open_reading_frames_CO6-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Iterate through the forward and reverse complement of the mRNA.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO6-5" id="callout_finding_open_reading_frames_CO6-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Iterate through the frameshifts.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO6-6" id="callout_finding_open_reading_frames_CO6-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Attempt to translate the truncated, frame-shifted mRNA into a protein sequence.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO6-7" id="callout_finding_open_reading_frames_CO6-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Iterate through each ORF found in the protein sequence.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO6-8" id="callout_finding_open_reading_frames_CO6-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Add the ORF to the set to maintain a unique list.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO6-9" id="callout_finding_open_reading_frames_CO6-9"><img alt="9" src="assets/9.png"/></a></dt>&#13;
<dd><p>Print the sorted ORFs.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 2: Using the str.partition() Function" data-type="sect2"><div class="sect2" id="idm45963628915640">&#13;
<h2>Solution 2: Using the str.partition() Function</h2>&#13;
&#13;
<p>Here is another approach to writing the <code>find_orfs()</code> function that uses <code>str.partition()</code>.<a data-primary="open reading frames (ORFs)" data-secondary="solution 2 str.partition()" data-type="indexterm" id="idm45963628913384"/><a data-primary="codons" data-secondary="open reading frames" data-tertiary="solution 2 str.partition()" data-type="indexterm" id="idm45963628912408"/><a data-primary="strings (str)" data-secondary="partition() breaking strings into parts" data-type="indexterm" id="idm45963628911176"/><a data-primary="partition() breaking strings into parts" data-type="indexterm" id="idm45963628910216"/>&#13;
This function breaks a string into the part before some substring, the substring, and the part after.&#13;
For instance, the string <em>MAMAPR*MP*</em> can be partitioned on the stop codon (<code>*</code>):</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; 'MAMAPR*MP*'.partition('*')&#13;
('MAMAPR', '*', 'MP*')</pre>&#13;
&#13;
<p>If the protein sequence does not contain a stop codon, the function returns the entire sequence in the first position and empty strings for the others:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; 'M'.partition('*')&#13;
('M', '', '')</pre>&#13;
&#13;
<p>In this version, I use two infinite loops.&#13;
The first tries to partition the given amino acid sequence on the stop codon.&#13;
If this is not successful, I exit the loop.&#13;
<a data-type="xref" href="#fig_14.3">Figure 14-3</a> shows that the protein sequence <em>MAMAPR*MP*</em> contains two sections that have start and end codons.</p>&#13;
&#13;
<figure><div class="figure" id="fig_14.3">&#13;
<img alt="mpfb 1403" src="assets/mpfb_1403.png"/>&#13;
<h6><span class="label">Figure 14-3. </span>The protein sequence MAMAPR*MP* has three ORFs in two sections</h6>&#13;
</div></figure>&#13;
&#13;
<p>The second loop checks the first partition to find all the subsequences starting with the <em>M</em> start codon.&#13;
So in the partition <em>MAMAPR</em>, it finds the two sequences <em>MAMAPR</em> and <em>MAPR</em>.&#13;
The code then truncates the amino acid sequence to the last partition, <em>MP*</em>, to repeat the operation until all ORFs have been found:</p>&#13;
&#13;
<pre data-type="programlisting">def find_orfs(aa: str) -&gt; List[str]:&#13;
    """ Find ORFs in AA sequence """&#13;
&#13;
    orfs = [] <a class="co" href="#callout_finding_open_reading_frames_CO7-1" id="co_finding_open_reading_frames_CO7-1"><img alt="1" src="assets/1.png"/></a>&#13;
    while True: <a class="co" href="#callout_finding_open_reading_frames_CO7-2" id="co_finding_open_reading_frames_CO7-2"><img alt="2" src="assets/2.png"/></a>&#13;
        first, middle, rest = aa.partition('*') <a class="co" href="#callout_finding_open_reading_frames_CO7-3" id="co_finding_open_reading_frames_CO7-3"><img alt="3" src="assets/3.png"/></a>&#13;
        if middle == '': <a class="co" href="#callout_finding_open_reading_frames_CO7-4" id="co_finding_open_reading_frames_CO7-4"><img alt="4" src="assets/4.png"/></a>&#13;
            break&#13;
&#13;
        last = 0 <a class="co" href="#callout_finding_open_reading_frames_CO7-5" id="co_finding_open_reading_frames_CO7-5"><img alt="5" src="assets/5.png"/></a>&#13;
        while True: <a class="co" href="#callout_finding_open_reading_frames_CO7-6" id="co_finding_open_reading_frames_CO7-6"><img alt="6" src="assets/6.png"/></a>&#13;
            start = first.find('M', last) <a class="co" href="#callout_finding_open_reading_frames_CO7-7" id="co_finding_open_reading_frames_CO7-7"><img alt="7" src="assets/7.png"/></a>&#13;
            if start == -1: <a class="co" href="#callout_finding_open_reading_frames_CO7-8" id="co_finding_open_reading_frames_CO7-8"><img alt="8" src="assets/8.png"/></a>&#13;
                break&#13;
            orfs.append(first[start:]) <a class="co" href="#callout_finding_open_reading_frames_CO7-9" id="co_finding_open_reading_frames_CO7-9"><img alt="9" src="assets/9.png"/></a>&#13;
            last = start + 1 <a class="co" href="#callout_finding_open_reading_frames_CO7-10" id="co_finding_open_reading_frames_CO7-10"><img alt="10" src="assets/10.png"/></a>&#13;
        aa = rest <a class="co" href="#callout_finding_open_reading_frames_CO7-11" id="co_finding_open_reading_frames_CO7-11"><img alt="11" src="assets/11.png"/></a>&#13;
&#13;
    return orfs <a class="co" href="#callout_finding_open_reading_frames_CO7-12" id="co_finding_open_reading_frames_CO7-12"><img alt="12" src="assets/12.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO7-1" id="callout_finding_open_reading_frames_CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Initialize a list for the ORFs to return.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO7-2" id="callout_finding_open_reading_frames_CO7-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Create the first infinite loop.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO7-3" id="callout_finding_open_reading_frames_CO7-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Partition the amino acid sequence on the stop codon.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO7-4" id="callout_finding_open_reading_frames_CO7-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>The middle will be empty if the stop codon is not present, so break from the outer loop.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO7-5" id="callout_finding_open_reading_frames_CO7-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Set a variable to remember the last position of a start codon.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO7-6" id="callout_finding_open_reading_frames_CO7-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Create a second infinite loop.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO7-7" id="callout_finding_open_reading_frames_CO7-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Use the <code>str.find()</code> method to locate the index of the start codon.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO7-8" id="callout_finding_open_reading_frames_CO7-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>The value -1 indicates that the start codon is not present, so leave the inner loop.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO7-9" id="callout_finding_open_reading_frames_CO7-9"><img alt="9" src="assets/9.png"/></a></dt>&#13;
<dd><p>Add the substring from the start index to the list of ORFs.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO7-10" id="callout_finding_open_reading_frames_CO7-10"><img alt="10" src="assets/10.png"/></a></dt>&#13;
<dd><p>Move the last known position to after the current start position.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO7-11" id="callout_finding_open_reading_frames_CO7-11"><img alt="11" src="assets/11.png"/></a></dt>&#13;
<dd><p>Truncate the protein sequence to the last part of the initial partition.</p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO7-12" id="callout_finding_open_reading_frames_CO7-12"><img alt="12" src="assets/12.png"/></a></dt>&#13;
<dd><p>Return the ORFs to the caller.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 3: Using a Regular Expression" data-type="sect2"><div class="sect2" id="idm45963628843176">&#13;
<h2>Solution 3: Using a Regular Expression</h2>&#13;
&#13;
<p>In this final solution, I’ll once again point out that a regular expression is probably the most fitting solution to find a pattern of text.<a data-primary="open reading frames (ORFs)" data-secondary="solution 3 regular expression" data-type="indexterm" id="idm45963628841736"/><a data-primary="codons" data-secondary="open reading frames" data-tertiary="solution 3 regular expression" data-type="indexterm" id="idm45963628840760"/><a data-primary="regular expressions (regexes)" data-secondary="open reading frames" data-type="indexterm" id="idm45963628839528"/>&#13;
This pattern always starts with <em>M</em>, and I can use the <code>re.findall()</code> function to find the four <em>M</em>s in this protein sequence:<a data-primary="regular expressions (regexes)" data-secondary="findall()" data-type="indexterm" id="idm45963628837016"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import re&#13;
&gt;&gt;&gt; re.findall('M', 'MAMAPR*MP*M')&#13;
['M', 'M', 'M', 'M']</pre>&#13;
&#13;
<p>The Rosalind challenge does not consider noncanonical start codons, so an ORF will always start with an <em>M</em> and extend to the first stop codon.<a data-primary="codons" data-secondary="noncanonical start codons" data-type="indexterm" id="idm45963628834280"/><a data-primary="Rosalind.info challenges" data-secondary="noncanonical start codons" data-type="indexterm" id="idm45963628833320"/>&#13;
In between these, there can be zero or more not-stop codons which I can represent using a negated character class of <code>[^*]</code> that excludes the stop codon followed by a <code>*</code> to indicate that there can be <em>zero or more</em> of the preceding pattern:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; re.findall('M[^*]*', 'MAMAPR*MP*M')&#13;
['MAMAPR', 'MP', 'M']</pre>&#13;
&#13;
<p>I need to add the stop codon <code>*</code> to this pattern.&#13;
Because the literal asterisk is a metacharacter, I must use a backslash to escape it:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; re.findall('M[^*]*\*', 'MAMAPR*MP*M')&#13;
['MAMAPR*', 'MP*']</pre>&#13;
&#13;
<p>I can also place the asterisk inside a character class where it has no meta meaning:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; re.findall('M[^*]*[*]', 'MAMAPR*MP*M')&#13;
['MAMAPR*', 'MP*']</pre>&#13;
&#13;
<p><a data-type="xref" href="#fig_14.4">Figure 14-4</a> shows this pattern using a finite state machine diagram.<a data-primary="regular expressions (regexes)" data-secondary="finite state machine" data-type="indexterm" id="idm45963628825704"/><a data-primary="finite state machine (FSM)" data-secondary="regular expressions" data-type="indexterm" id="idm45963628824744"/></p>&#13;
&#13;
<figure><div class="figure" id="fig_14.4">&#13;
<img alt="mpfb 1404" src="assets/mpfb_1404.png"/>&#13;
<h6><span class="label">Figure 14-4. </span>A finite state machine diagram of the regular expression to find an open reading frame</h6>&#13;
</div></figure>&#13;
&#13;
<p>I can see that this pattern is close to working, but it’s only finding two of the three ORFs because the first one overlaps the second one.&#13;
As in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch08.html#ch08">8</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch11.html#ch11">11</a>, I can wrap the pattern in a positive look-ahead assertion.<a data-primary="regular expressions (regexes)" data-secondary="look-ahead assertions" data-type="indexterm" id="idm45963628818504"/><a data-primary="look-ahead assertions in regexes" data-type="indexterm" id="idm45963628817544"/>&#13;
Further, I will use parentheses to create a capture group around the ORF up to the stop codon:<a data-primary="regular expressions (regexes)" data-secondary="capture groups" data-type="indexterm" id="idm45963628816616"/><a data-primary="() (regex capture groups)" data-primary-sortas="# regex capture groups" data-type="indexterm" id="idm45963628815656"/><a data-primary="parentheses for regex capture groups" data-type="indexterm" id="idm45963628814696"/><a data-primary="capture groups in regular expressions" data-type="indexterm" id="idm45963628814008"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; re.findall('(?=(M[^*]*)[*])', 'MAMAPR*MP*M')&#13;
['MAMAPR', 'MAPR', 'MP']</pre>&#13;
&#13;
<p>Here is one version of the <code>find_orfs()</code> that uses this pattern:</p>&#13;
&#13;
<pre data-type="programlisting">def find_orfs(aa: str) -&gt; List[str]:&#13;
    """ Find ORFs in AA sequence """&#13;
&#13;
    return re.findall('(?=(M[^*]*)[*])', aa)</pre>&#13;
&#13;
<p>While this passes <code>test_find_orfs()</code>, this is a complicated regex that I will have to relearn every time I come back to it.<a data-primary="regular expressions (regexes)" data-secondary="breaking across lines" data-type="indexterm" id="idm45963628809832"/>&#13;
An alternate way to write this is to place each functional piece of the regex on a separate line, followed by an end-of-line comment, and rely on Python’s implicit string concatenation (first shown in <a data-type="xref" href="ch02.html#ch02">Chapter 2</a>) to join these into a single string.<a data-primary="strings (str)" data-secondary="concatenation implicit in Python" data-type="indexterm" id="idm45963628807672"/><a data-primary="Python" data-secondary="string concatenation" data-type="indexterm" id="idm45963628806712"/><a data-primary="documentation" data-secondary="program providing" data-type="indexterm" id="idm45963628805768"/><a data-primary="best practices" data-secondary="documentation provided by programs" data-type="indexterm" id="idm45963628804824"/><a data-primary="reproducible programs" data-secondary="documentation provided by programs" data-type="indexterm" id="idm45963628803864"/><a data-primary="concatenation implicit in Python" data-type="indexterm" id="idm45963628802904"/>&#13;
This is my preferred method to find the ORFs:</p>&#13;
&#13;
<pre data-type="programlisting">def find_orfs(aa: str) -&gt; List[str]:&#13;
    """ Find ORFs in AA sequence """&#13;
&#13;
    pattern = ( <a class="co" href="#callout_finding_open_reading_frames_CO8-1" id="co_finding_open_reading_frames_CO8-1"><img alt="1" src="assets/1.png"/></a>&#13;
        '(?='    # start positive look-ahead to handle overlaps&#13;
        '('      # start a capture group&#13;
        'M'      # a literal M&#13;
        '[^*]*'  # zero or more of anything not the asterisk&#13;
        ')'      # end the capture group&#13;
        '[*]'    # a literal asterisk&#13;
        ')')     # end the look-ahead group&#13;
&#13;
    return re.findall(pattern, aa) <a class="co" href="#callout_finding_open_reading_frames_CO8-2" id="co_finding_open_reading_frames_CO8-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO8-1" id="callout_finding_open_reading_frames_CO8-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The parentheses group the following lines such that Python will automatically join the strings into a single string. Be sure there are no commas or Python will create a tuple.<a data-primary="strings (str)" data-secondary="concatenation implicit in Python" data-tertiary="tuple if commas present" data-type="indexterm" id="idm45963628794008"/><a data-primary="Python" data-secondary="string concatenation" data-tertiary="tuple if commas present" data-type="indexterm" id="idm45963628792776"/><a data-primary="concatenation implicit in Python" data-secondary="tuple if commas present" data-type="indexterm" id="idm45963628791560"/></p></dd>&#13;
<dt><a class="co" href="#co_finding_open_reading_frames_CO8-2" id="callout_finding_open_reading_frames_CO8-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Use the pattern with the <code>re.findall()</code> function.</p></dd>&#13;
</dl>&#13;
&#13;
<p>This is a longer function, but it will be much easier to understand the next time I see it.&#13;
One downside is that <code>yapf</code> that I use to format my code will remove the vertical alignment of the comments, so I must manually format this section.<a data-primary="yapf to auto format code" data-type="indexterm" id="idm45963628786296"/>&#13;
Still, I think it’s worth it to have more self-documenting code.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Going Further" data-type="sect1"><div class="sect1" id="idm45963628784920">&#13;
<h1>Going Further</h1>&#13;
&#13;
<p>Expand the program to process multiple input files, writing all the unique ORFs to an indicated output file.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review" data-type="sect1"><div class="sect1" id="idm45963628783208">&#13;
<h1>Review</h1>&#13;
&#13;
<p>Key points from this chapter:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The <code>Bio.Seq.translate()</code> function will print warnings if the input sequence is not evenly divisible by three, so I wrote a <code>truncate()</code> function to trim the <span class="keep-together">protein.</span></p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>str.find()</code> and <code>str.partition()</code> functions each present ways to find subsequences in a string.</p>&#13;
</li>&#13;
<li>&#13;
<p>A regular expression remains my preferred method to find a pattern in some text.</p>&#13;
</li>&#13;
<li>&#13;
<p>A complicated regex can be written over multiple lines with comments so that Python will implicitly concatenate them into a single string.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>