<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 35. Three-Dimensional Plotting in Matplotlib" data-type="chapter" epub:type="chapter"><div class="chapter" id="section-0412-three-dimensional-plotting">
<h1><span class="label">Chapter 35. </span>Three-Dimensional Plotting in Matplotlib</h1>
<p><a data-primary="Matplotlib" data-secondary="three-dimensional plotting" data-type="indexterm" id="ix_ch35-asciidoc0"/><a data-primary="plotting" data-secondary="three-dimensional" data-type="indexterm" id="ix_ch35-asciidoc1"/><a data-primary="three-dimensional plotting" data-secondary="with Matplotlib" data-secondary-sortas="Matplotlib" data-type="indexterm" id="ix_ch35-asciidoc2"/>Matplotlib was initially designed with only two-dimensional plotting in
mind. Around the time of the 1.0 release, some three-dimensional
plotting utilities were built on top of Matplotlib’s
two-dimensional display, and the result is a convenient (if somewhat
limited) set of tools for three-dimensional data visualization.
Three-dimensional plots are enabled by importing the <code>mplot3d</code> toolkit,
included with the main Matplotlib installation:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="kn">from</code> <code class="nn">mpl_toolkits</code> <code class="kn">import</code> <code class="n">mplot3d</code></pre>
<p>Once this submodule is imported, a three-dimensional axes can be created
by passing the keyword <code>projection='3d'</code> to any
of the normal axes creation routines, as shown here (see <a data-type="xref" href="#fig_0412-three-dimensional-plotting_files_in_output_5_0">Figure 35-1</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="o">%</code><code class="k">matplotlib</code> inline
        <code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>
        <code class="kn">import</code> <code class="nn">matplotlib.pyplot</code> <code class="k">as</code> <code class="nn">plt</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="n">fig</code> <code class="o">=</code> <code class="n">plt</code><code class="o">.</code><code class="n">figure</code><code class="p">()</code>
        <code class="n">ax</code> <code class="o">=</code> <code class="n">plt</code><code class="o">.</code><code class="n">axes</code><code class="p">(</code><code class="n">projection</code><code class="o">=</code><code class="s1">'3d'</code><code class="p">)</code></pre>
<p>With this three-dimensional axes enabled, we can now plot a variety of
three-dimensional plot types. Three-dimensional plotting is one of the
functionalities that benefits immensely from viewing figures
interactively rather than statically, in the notebook; recall that to
use interactive figures, you can use <code>%matplotlib notebook</code> rather than
<code>%matplotlib inline</code> when running this code.</p>
<figure class="width-50"><div class="figure" id="fig_0412-three-dimensional-plotting_files_in_output_5_0">
<img alt="output 5 0" height="392" src="assets/output_5_0.png" width="600"/>
<h6><span class="label">Figure 35-1. </span>An empty three-dimensional axes</h6>
</div></figure>
<section data-pdf-bookmark="Three-Dimensional Points and Lines" data-type="sect1"><div class="sect1" id="ch_0412-three-dimensional-plotting_three-dimensional-points-and-lines">
<h1>Three-Dimensional Points and Lines</h1>
<p><a data-primary="three-dimensional plotting" data-secondary="points and lines" data-type="indexterm" id="idm45858749119440"/>The most basic three-dimensional plot is a line or collection of scatter
plots created from sets of (x, y, z) triples. In analogy with the more
common two-dimensional plots discussed earlier, these can be created
using the <code>ax.plot3D</code> and <code>ax.scatter3D</code> functions. The call signature
for these is nearly identical to that of their two-dimensional
counterparts, so you can refer to Chapters
<a href="ch26.xhtml#section-0401-simple-line-plots">26</a> and
<a href="ch27.xhtml#section-0402-simple-scatter-plots">27</a> for more
information on controlling the output. Here we’ll plot a
trigonometric spiral, along with some points drawn randomly near the
line (see <a data-type="xref" href="#fig_0412-three-dimensional-plotting_files_in_output_8_0">Figure 35-2</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="n">ax</code> <code class="o">=</code> <code class="n">plt</code><code class="o">.</code><code class="n">axes</code><code class="p">(</code><code class="n">projection</code><code class="o">=</code><code class="s1">'3d'</code><code class="p">)</code>

        <code class="c1"># Data for a three-dimensional line</code>
        <code class="n">zline</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">linspace</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">15</code><code class="p">,</code> <code class="mi">1000</code><code class="p">)</code>
        <code class="n">xline</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">sin</code><code class="p">(</code><code class="n">zline</code><code class="p">)</code>
        <code class="n">yline</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">cos</code><code class="p">(</code><code class="n">zline</code><code class="p">)</code>
        <code class="n">ax</code><code class="o">.</code><code class="n">plot3D</code><code class="p">(</code><code class="n">xline</code><code class="p">,</code> <code class="n">yline</code><code class="p">,</code> <code class="n">zline</code><code class="p">,</code> <code class="s1">'gray'</code><code class="p">)</code>

        <code class="c1"># Data for three-dimensional scattered points</code>
        <code class="n">zdata</code> <code class="o">=</code> <code class="mi">15</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">random</code><code class="p">(</code><code class="mi">100</code><code class="p">)</code>
        <code class="n">xdata</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">sin</code><code class="p">(</code><code class="n">zdata</code><code class="p">)</code> <code class="o">+</code> <code class="mf">0.1</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">randn</code><code class="p">(</code><code class="mi">100</code><code class="p">)</code>
        <code class="n">ydata</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">cos</code><code class="p">(</code><code class="n">zdata</code><code class="p">)</code> <code class="o">+</code> <code class="mf">0.1</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">randn</code><code class="p">(</code><code class="mi">100</code><code class="p">)</code>
        <code class="n">ax</code><code class="o">.</code><code class="n">scatter3D</code><code class="p">(</code><code class="n">xdata</code><code class="p">,</code> <code class="n">ydata</code><code class="p">,</code> <code class="n">zdata</code><code class="p">,</code> <code class="n">c</code><code class="o">=</code><code class="n">zdata</code><code class="p">,</code> <code class="n">cmap</code><code class="o">=</code><code class="s1">'Greens'</code><code class="p">);</code></pre>
<figure class="width-50"><div class="figure" id="fig_0412-three-dimensional-plotting_files_in_output_8_0">
<img alt="output 8 0" height="392" src="assets/output_8_0.png" width="600"/>
<h6><span class="label">Figure 35-2. </span>Points and lines in three dimensions</h6>
</div></figure>
<p>Notice that scatter points have their transparency adjusted to give a
sense of depth on the page. While the three-dimensional effect is
sometimes difficult to see within a static image, an interactive view
can lead to some nice intuition about the layout of the points.</p>
</div></section>
<section data-pdf-bookmark="Three-Dimensional Contour Plots" data-type="sect1"><div class="sect1" id="ch_0412-three-dimensional-plotting_three-dimensional-contour-plots">
<h1>Three-Dimensional Contour Plots</h1>
<p><a data-primary="contour plots" data-secondary="three-dimensional plot" data-type="indexterm" id="ix_ch35-asciidoc3"/><a data-primary="three-dimensional plotting" data-secondary="contour plots" data-type="indexterm" id="ix_ch35-asciidoc4"/>Analogous to the contour plots we explored in
<a data-type="xref" href="ch28.xhtml#section-0404-density-and-contour-plots">Chapter 28</a>,
<code>mplot3d</code> contains tools to create three-dimensional relief plots using
the same inputs. Like <code>ax.contour</code>, <code>ax.contour3D</code> requires all the
input data to be in the form of two-dimensional regular grids, with the
<em>z</em> data evaluated at each point. Here we’ll show a
three-dimensional contour diagram of a three-dimensional sinusoidal
function (see <a data-type="xref" href="#fig_0412-three-dimensional-plotting_files_in_output_12_0">Figure 35-3</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="k">def</code> <code class="nf">f</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">):</code>
            <code class="k">return</code> <code class="n">np</code><code class="o">.</code><code class="n">sin</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">sqrt</code><code class="p">(</code><code class="n">x</code> <code class="o">**</code> <code class="mi">2</code> <code class="o">+</code> <code class="n">y</code> <code class="o">**</code> <code class="mi">2</code><code class="p">))</code>

        <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">linspace</code><code class="p">(</code><code class="o">-</code><code class="mi">6</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">30</code><code class="p">)</code>
        <code class="n">y</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">linspace</code><code class="p">(</code><code class="o">-</code><code class="mi">6</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">30</code><code class="p">)</code>

        <code class="n">X</code><code class="p">,</code> <code class="n">Y</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">meshgrid</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">)</code>
        <code class="n">Z</code> <code class="o">=</code> <code class="n">f</code><code class="p">(</code><code class="n">X</code><code class="p">,</code> <code class="n">Y</code><code class="p">)</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">fig</code> <code class="o">=</code> <code class="n">plt</code><code class="o">.</code><code class="n">figure</code><code class="p">()</code>
        <code class="n">ax</code> <code class="o">=</code> <code class="n">plt</code><code class="o">.</code><code class="n">axes</code><code class="p">(</code><code class="n">projection</code><code class="o">=</code><code class="s1">'3d'</code><code class="p">)</code>
        <code class="n">ax</code><code class="o">.</code><code class="n">contour3D</code><code class="p">(</code><code class="n">X</code><code class="p">,</code> <code class="n">Y</code><code class="p">,</code> <code class="n">Z</code><code class="p">,</code> <code class="mi">40</code><code class="p">,</code> <code class="n">cmap</code><code class="o">=</code><code class="s1">'binary'</code><code class="p">)</code>
        <code class="n">ax</code><code class="o">.</code><code class="n">set_xlabel</code><code class="p">(</code><code class="s1">'x'</code><code class="p">)</code>
        <code class="n">ax</code><code class="o">.</code><code class="n">set_ylabel</code><code class="p">(</code><code class="s1">'y'</code><code class="p">)</code>
        <code class="n">ax</code><code class="o">.</code><code class="n">set_zlabel</code><code class="p">(</code><code class="s1">'z'</code><code class="p">);</code></pre>
<figure class="width-60"><div class="figure" id="fig_0412-three-dimensional-plotting_files_in_output_12_0">
<img alt="output 12 0" height="528" src="assets/output_12_0.png" width="600"/>
<h6><span class="label">Figure 35-3. </span>A three-dimensional contour plot</h6>
</div></figure>
<p>Sometimes the default viewing angle is not optimal, in which case we can
use the <code>view_init</code> method to set the elevation and azimuthal angles. In
the following example, visualized in <a data-type="xref" href="#fig_0412-three-dimensional-plotting_files_in_output_14_0">Figure 35-4</a>,
we’ll use an elevation of 60 degrees (that is, 60 degrees
above the x-y plane) and an azimuth of 35 degrees (that is, rotated 35
degrees counter-clockwise about the z-axis):</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">ax</code><code class="o">.</code><code class="n">view_init</code><code class="p">(</code><code class="mi">60</code><code class="p">,</code> <code class="mi">35</code><code class="p">)</code>
        <code class="n">fig</code></pre>
<p>Again, note that this type of rotation can be accomplished interactively
by clicking and dragging when using one of Matplotlib’s
interactive backends.<a data-startref="ix_ch35-asciidoc4" data-type="indexterm" id="idm45858748667936"/><a data-startref="ix_ch35-asciidoc3" data-type="indexterm" id="idm45858748667328"/></p>
<figure class="width-60"><div class="figure" id="fig_0412-three-dimensional-plotting_files_in_output_14_0">
<img alt="output 14 0" height="395" src="assets/output_14_0.png" width="600"/>
<h6><span class="label">Figure 35-4. </span>Adjusting the view angle for a three-dimensional plot</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="Wireframes and Surface Plots" data-type="sect1"><div class="sect1" id="ch_0412-three-dimensional-plotting_wireframes-and-surface-plots">
<h1>Wireframes and Surface Plots</h1>
<p><a data-primary="three-dimensional plotting" data-secondary="wireframes" data-type="indexterm" id="ix_ch35-asciidoc5"/><a data-primary="wireframe plot" data-type="indexterm" id="ix_ch35-asciidoc6"/>Two <a data-primary="surface plots, three-dimensional" data-type="indexterm" id="ix_ch35-asciidoc7"/><a data-primary="three-dimensional plotting" data-secondary="surface plots" data-type="indexterm" id="ix_ch35-asciidoc8"/>other types of three-dimensional plots that work on gridded data are
wireframes and surface plots. These take a grid of values and project it
onto the specified three-dimensional surface, and can make the resulting
three-dimensional forms quite easy to visualize. Here’s an
example of using a wireframe (see <a data-type="xref" href="#fig_0412-three-dimensional-plotting_files_in_output_17_0">Figure 35-5</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">fig</code> <code class="o">=</code> <code class="n">plt</code><code class="o">.</code><code class="n">figure</code><code class="p">()</code>
        <code class="n">ax</code> <code class="o">=</code> <code class="n">plt</code><code class="o">.</code><code class="n">axes</code><code class="p">(</code><code class="n">projection</code><code class="o">=</code><code class="s1">'3d'</code><code class="p">)</code>
        <code class="n">ax</code><code class="o">.</code><code class="n">plot_wireframe</code><code class="p">(</code><code class="n">X</code><code class="p">,</code> <code class="n">Y</code><code class="p">,</code> <code class="n">Z</code><code class="p">)</code>
        <code class="n">ax</code><code class="o">.</code><code class="n">set_title</code><code class="p">(</code><code class="s1">'wireframe'</code><code class="p">);</code></pre>
<figure class="width-60"><div class="figure" id="fig_0412-three-dimensional-plotting_files_in_output_17_0">
<img alt="output 17 0" height="401" src="assets/output_17_0.png" width="600"/>
<h6><span class="label">Figure 35-5. </span>A wireframe plot</h6>
</div></figure>
<p>A surface plot is like a wireframe plot, but each face of the wireframe
is a filled polygon. Adding a colormap to the filled polygons can aid
perception of the topology of the surface being visualized, as you can
see in <a data-type="xref" href="#fig_0412-three-dimensional-plotting_files_in_output_19_0">Figure 35-6</a>.</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">ax</code> <code class="o">=</code> <code class="n">plt</code><code class="o">.</code><code class="n">axes</code><code class="p">(</code><code class="n">projection</code><code class="o">=</code><code class="s1">'3d'</code><code class="p">)</code>
        <code class="n">ax</code><code class="o">.</code><code class="n">plot_surface</code><code class="p">(</code><code class="n">X</code><code class="p">,</code> <code class="n">Y</code><code class="p">,</code> <code class="n">Z</code><code class="p">,</code> <code class="n">rstride</code><code class="o">=</code><code class="mi">1</code><code class="p">,</code> <code class="n">cstride</code><code class="o">=</code><code class="mi">1</code><code class="p">,</code>
                        <code class="n">cmap</code><code class="o">=</code><code class="s1">'viridis'</code><code class="p">,</code> <code class="n">edgecolor</code><code class="o">=</code><code class="s1">'none'</code><code class="p">)</code>
        <code class="n">ax</code><code class="o">.</code><code class="n">set_title</code><code class="p">(</code><code class="s1">'surface'</code><code class="p">);</code></pre>
<figure class="width-60"><div class="figure" id="fig_0412-three-dimensional-plotting_files_in_output_19_0">
<img alt="output 19 0" height="398" src="assets/output_19_0.png" width="600"/>
<h6><span class="label">Figure 35-6. </span>A three-dimensional surface plot</h6>
</div></figure>
<p>Though the grid of values for a surface plot needs to be
two-dimensional, it need not be rectilinear. Here is an example of
creating a partial polar grid, which when used with the <code>surface3D</code> plot
can give us a slice into the function we’re visualizing (see
<a data-type="xref" href="#fig_0412-three-dimensional-plotting_files_in_output_21_0">Figure 35-7</a>).<a data-startref="ix_ch35-asciidoc8" data-type="indexterm" id="idm45858748542080"/><a data-startref="ix_ch35-asciidoc7" data-type="indexterm" id="idm45858748541376"/></p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">r</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">linspace</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">20</code><code class="p">)</code>
         <code class="n">theta</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">linspace</code><code class="p">(</code><code class="o">-</code><code class="mf">0.9</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">pi</code><code class="p">,</code> <code class="mf">0.8</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">pi</code><code class="p">,</code> <code class="mi">40</code><code class="p">)</code>
         <code class="n">r</code><code class="p">,</code> <code class="n">theta</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">meshgrid</code><code class="p">(</code><code class="n">r</code><code class="p">,</code> <code class="n">theta</code><code class="p">)</code>

         <code class="n">X</code> <code class="o">=</code> <code class="n">r</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">sin</code><code class="p">(</code><code class="n">theta</code><code class="p">)</code>
         <code class="n">Y</code> <code class="o">=</code> <code class="n">r</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">cos</code><code class="p">(</code><code class="n">theta</code><code class="p">)</code>
         <code class="n">Z</code> <code class="o">=</code> <code class="n">f</code><code class="p">(</code><code class="n">X</code><code class="p">,</code> <code class="n">Y</code><code class="p">)</code>

         <code class="n">ax</code> <code class="o">=</code> <code class="n">plt</code><code class="o">.</code><code class="n">axes</code><code class="p">(</code><code class="n">projection</code><code class="o">=</code><code class="s1">'3d'</code><code class="p">)</code>
         <code class="n">ax</code><code class="o">.</code><code class="n">plot_surface</code><code class="p">(</code><code class="n">X</code><code class="p">,</code> <code class="n">Y</code><code class="p">,</code> <code class="n">Z</code><code class="p">,</code> <code class="n">rstride</code><code class="o">=</code><code class="mi">1</code><code class="p">,</code> <code class="n">cstride</code><code class="o">=</code><code class="mi">1</code><code class="p">,</code>
                         <code class="n">cmap</code><code class="o">=</code><code class="s1">'viridis'</code><code class="p">,</code> <code class="n">edgecolor</code><code class="o">=</code><code class="s1">'none'</code><code class="p">);</code></pre>
<figure class="width-60"><div class="figure" id="fig_0412-three-dimensional-plotting_files_in_output_21_0">
<img alt="output 21 0" height="392" src="assets/output_21_0.png" width="600"/>
<h6><span class="label">Figure 35-7. </span>A polar surface plot</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="Surface Triangulations" data-type="sect1"><div class="sect1" id="ch_0412-three-dimensional-plotting_surface-triangulations">
<h1>Surface Triangulations</h1>
<p><a data-primary="three-dimensional plotting" data-secondary="surface triangulations" data-type="indexterm" id="idm45858748372016"/><a data-primary="triangulated surface plots" data-type="indexterm" id="idm45858748371072"/>For some applications, the evenly sampled grids required by the
preceding routines are too restrictive. In these situations,
triangulation-based plots can come in handy. What if rather than an even
draw from a Cartesian or a polar grid, we instead have a set of random
draws?</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">theta</code> <code class="o">=</code> <code class="mi">2</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">pi</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">random</code><code class="p">(</code><code class="mi">1000</code><code class="p">)</code>
         <code class="n">r</code> <code class="o">=</code> <code class="mi">6</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">random</code><code class="p">(</code><code class="mi">1000</code><code class="p">)</code>
         <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">ravel</code><code class="p">(</code><code class="n">r</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">sin</code><code class="p">(</code><code class="n">theta</code><code class="p">))</code>
         <code class="n">y</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">ravel</code><code class="p">(</code><code class="n">r</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">cos</code><code class="p">(</code><code class="n">theta</code><code class="p">))</code>
         <code class="n">z</code> <code class="o">=</code> <code class="n">f</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">)</code></pre>
<p>We could create a scatter plot of the points to get an idea of the
surface we’re sampling from, as shown in <a data-type="xref" href="#fig_0412-three-dimensional-plotting_files_in_output_25_0">Figure 35-8</a>.</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="n">ax</code> <code class="o">=</code> <code class="n">plt</code><code class="o">.</code><code class="n">axes</code><code class="p">(</code><code class="n">projection</code><code class="o">=</code><code class="s1">'3d'</code><code class="p">)</code>
         <code class="n">ax</code><code class="o">.</code><code class="n">scatter</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">,</code> <code class="n">z</code><code class="p">,</code> <code class="n">c</code><code class="o">=</code><code class="n">z</code><code class="p">,</code> <code class="n">cmap</code><code class="o">=</code><code class="s1">'viridis'</code><code class="p">,</code> <code class="n">linewidth</code><code class="o">=</code><code class="mf">0.5</code><code class="p">);</code></pre>
<figure class="width-60"><div class="figure" id="fig_0412-three-dimensional-plotting_files_in_output_25_0">
<img alt="output 25 0" height="438" src="assets/output_25_0.png" width="600"/>
<h6><span class="label">Figure 35-8. </span>A three-dimensional sampled surface</h6>
</div></figure>
<p>This point cloud leaves a lot to be desired. The function that will help
us in this case is <code>ax.plot_trisurf</code>, which creates a surface by first
finding a set of triangles formed between adjacent points (remember that
<code>x</code>, <code>y</code>, and <code>z</code> here are one-dimensional arrays); <a data-type="xref" href="#fig_0412-three-dimensional-plotting_files_in_output_27_0">Figure 35-9</a>
shows the result:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="n">ax</code> <code class="o">=</code> <code class="n">plt</code><code class="o">.</code><code class="n">axes</code><code class="p">(</code><code class="n">projection</code><code class="o">=</code><code class="s1">'3d'</code><code class="p">)</code>
         <code class="n">ax</code><code class="o">.</code><code class="n">plot_trisurf</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">,</code> <code class="n">z</code><code class="p">,</code>
                         <code class="n">cmap</code><code class="o">=</code><code class="s1">'viridis'</code><code class="p">,</code> <code class="n">edgecolor</code><code class="o">=</code><code class="s1">'none'</code><code class="p">);</code></pre>
<p>The result is certainly not as clean as when it is plotted with a grid,
but the flexibility of such a triangulation allows for some really
interesting three-dimensional plots. For example, it is actually
possible to plot a three-dimensional Möbius strip using this, as
we’ll see next.<a data-startref="ix_ch35-asciidoc6" data-type="indexterm" id="idm45858748133360"/><a data-startref="ix_ch35-asciidoc5" data-type="indexterm" id="idm45858748124528"/></p>
<figure class="width-60"><div class="figure" id="fig_0412-three-dimensional-plotting_files_in_output_27_0">
<img alt="output 27 0" height="383" src="assets/output_27_0.png" width="600"/>
<h6><span class="label">Figure 35-9. </span>A triangulated surface plot</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="Example: Visualizing a Möbius Strip" data-type="sect1"><div class="sect1" id="ch_0412-three-dimensional-plotting_example-visualizing-a-mobius-strip">
<h1>Example: Visualizing a Möbius Strip</h1>
<p><a data-primary="Möbius strip" data-type="indexterm" id="idm45858748105824"/><a data-primary="three-dimensional plotting" data-secondary="Mobius strip visualization" data-type="indexterm" id="idm45858748105216"/>A Möbius strip is similar to a strip of paper glued into a loop with a
half-twist, resulting in an object with only a single side! Here we will
visualize such an object using Matplotlib’s
three-dimensional tools. The key to creating the Möbius strip is to
think about its parametrization: it’s a two-dimensional
strip, so we need two intrinsic dimensions. Let’s call them
<math alttext="theta">
<mi>θ</mi>
</math>, which ranges from 0 to
<math alttext="2 pi">
<mrow>
<mn>2</mn>
<mi>π</mi>
</mrow>
</math> around the loop, and <math alttext="w">
<mi>w</mi>
</math>, which ranges
from –1 to 1 across the width of the strip:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="n">theta</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">linspace</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">2</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">pi</code><code class="p">,</code> <code class="mi">30</code><code class="p">)</code>
         <code class="n">w</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">linspace</code><code class="p">(</code><code class="o">-</code><code class="mf">0.25</code><code class="p">,</code> <code class="mf">0.25</code><code class="p">,</code> <code class="mi">8</code><code class="p">)</code>
         <code class="n">w</code><code class="p">,</code> <code class="n">theta</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">meshgrid</code><code class="p">(</code><code class="n">w</code><code class="p">,</code> <code class="n">theta</code><code class="p">)</code></pre>
<p>Now from this parametrization, we must determine the (<em>x</em>, <em>y</em>, <em>z</em>)
positions of the embedded strip.</p>
<p>Thinking about it, we might realize that there are two rotations
happening: one is the position of the loop about its center (what
we’ve called <math alttext="theta">
<mi>θ</mi>
</math>), while the other is the
twisting of the strip about its axis (we’ll call this
<math alttext="phi">
<mi>φ</mi>
</math>). For a Möbius strip, we must have the strip make
half a twist during a full loop, or
<math alttext="normal upper Delta phi equals normal upper Delta theta slash 2">
<mrow>
<mi>Δ</mi>
<mi>φ</mi>
<mo>=</mo>
<mi>Δ</mi>
<mi>θ</mi>
<mo>/</mo>
<mn>2</mn>
</mrow>
</math>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="n">phi</code> <code class="o">=</code> <code class="mf">0.5</code> <code class="o">*</code> <code class="n">theta</code></pre>
<p>Now we use our recollection of trigonometry to derive the
three-dimensional embedding. We’ll define <math alttext="r">
<mi>r</mi>
</math>,
the distance of each point from the center, and use this to find the
embedded <math alttext="left-parenthesis x comma y comma z right-parenthesis">
<mrow>
<mo>(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo>,</mo>
<mi>z</mi>
<mo>)</mo>
</mrow>
</math> coordinates:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="c1"># radius in x-y plane</code>
         <code class="n">r</code> <code class="o">=</code> <code class="mi">1</code> <code class="o">+</code> <code class="n">w</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">cos</code><code class="p">(</code><code class="n">phi</code><code class="p">)</code>

         <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">ravel</code><code class="p">(</code><code class="n">r</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">cos</code><code class="p">(</code><code class="n">theta</code><code class="p">))</code>
         <code class="n">y</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">ravel</code><code class="p">(</code><code class="n">r</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">sin</code><code class="p">(</code><code class="n">theta</code><code class="p">))</code>
         <code class="n">z</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">ravel</code><code class="p">(</code><code class="n">w</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">sin</code><code class="p">(</code><code class="n">phi</code><code class="p">))</code></pre>
<p>Finally, to plot the object, we must make sure the triangulation is
correct. The best way to do this is to define the triangulation <em>within
the underlying parametrization</em>, and then let Matplotlib project this
triangulation into the three-dimensional space of the Möbius strip. This
can be accomplished as follows (see <a data-type="xref" href="#fig_0412-three-dimensional-plotting_files_in_output_36_0">Figure 35-10</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="c1"># triangulate in the underlying parametrization</code>
         <code class="kn">from</code> <code class="nn">matplotlib.tri</code> <code class="kn">import</code> <code class="n">Triangulation</code>
         <code class="n">tri</code> <code class="o">=</code> <code class="n">Triangulation</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">ravel</code><code class="p">(</code><code class="n">w</code><code class="p">),</code> <code class="n">np</code><code class="o">.</code><code class="n">ravel</code><code class="p">(</code><code class="n">theta</code><code class="p">))</code>

         <code class="n">ax</code> <code class="o">=</code> <code class="n">plt</code><code class="o">.</code><code class="n">axes</code><code class="p">(</code><code class="n">projection</code><code class="o">=</code><code class="s1">'3d'</code><code class="p">)</code>
         <code class="n">ax</code><code class="o">.</code><code class="n">plot_trisurf</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">,</code> <code class="n">z</code><code class="p">,</code> <code class="n">triangles</code><code class="o">=</code><code class="n">tri</code><code class="o">.</code><code class="n">triangles</code><code class="p">,</code>
                         <code class="n">cmap</code><code class="o">=</code><code class="s1">'Greys'</code><code class="p">,</code> <code class="n">linewidths</code><code class="o">=</code><code class="mf">0.2</code><code class="p">);</code>

         <code class="n">ax</code><code class="o">.</code><code class="n">set_xlim</code><code class="p">(</code><code class="o">-</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">);</code> <code class="n">ax</code><code class="o">.</code><code class="n">set_ylim</code><code class="p">(</code><code class="o">-</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">);</code> <code class="n">ax</code><code class="o">.</code><code class="n">set_zlim</code><code class="p">(</code><code class="o">-</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code>
         <code class="n">ax</code><code class="o">.</code><code class="n">axis</code><code class="p">(</code><code class="s1">'off'</code><code class="p">);</code></pre>
<figure><div class="figure" id="fig_0412-three-dimensional-plotting_files_in_output_36_0">
<img alt="output 36 0" height="381" src="assets/output_36_0.png" width="600"/>
<h6><span class="label">Figure 35-10. </span>Visualizing a Möbius strip</h6>
</div></figure>
<p>Combining all of these techniques, it is possible to create and display
a wide variety of three-dimensional objects and patterns in Matplotlib.<a data-startref="ix_ch35-asciidoc2" data-type="indexterm" id="idm45858747777584"/><a data-startref="ix_ch35-asciidoc1" data-type="indexterm" id="idm45858747776880"/><a data-startref="ix_ch35-asciidoc0" data-type="indexterm" id="idm45858747776208"/></p>
</div></section>
</div></section></div></body></html>