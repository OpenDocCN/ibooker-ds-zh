<html><head></head><body><section data-pdf-bookmark="Chapter 8. Find a Motif in DNA: Exploring Sequence Similarity" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch08">&#13;
<h1><span class="label">Chapter 8. </span>Find a Motif in DNA: <span class="keep-together">Exploring Sequence Similarity</span></h1>&#13;
&#13;
&#13;
<p>In <a href="https://oreil.ly/hoUhB">the Rosalind SUBS challenge</a>, I’ll be searching for any occurrences of one sequence inside another.<a data-primary="DNA" data-secondary="finding motifs" data-see="longest shared subsequence; sequence similarity" data-type="indexterm" id="idm45963633542184"/><a data-primary="sequence similarity" data-secondary="about" data-type="indexterm" id="idm45963633540936"/><a data-primary="subsequences" data-secondary="subsequence similarity" data-tertiary="about" data-type="indexterm" id="idm45963633539992"/>&#13;
A shared subsequence might represent a conserved element such as a marker, gene, or regulatory sequence.&#13;
Conserved sequences between two organisms might suggest some inherited or convergent trait.&#13;
I’ll explore how to write a solution using the <code>str</code> (string) class in Python and will compare strings to lists.&#13;
Then I’ll explore how to express these ideas using higher-order functions and will continue the discussion of k-mers I started in <a data-type="xref" href="ch07.html#ch07">Chapter 7</a>.&#13;
Finally, I’ll show how regular expressions can find patterns and will point out problems with overlapping matches.</p>&#13;
&#13;
<p>In this chapter, I’ll demonstrate:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>How to use <code>str.find()</code>, <code>str.index()</code>, and string slices</p>&#13;
</li>&#13;
<li>&#13;
<p>How to use sets to create unique collections of elements</p>&#13;
</li>&#13;
<li>&#13;
<p>How to combine higher-order functions</p>&#13;
</li>&#13;
<li>&#13;
<p>How to find subsequences using k-mers</p>&#13;
</li>&#13;
<li>&#13;
<p>How to find possibly overlapping sequences using regular expressions</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Getting Started" data-type="sect1"><div class="sect1" id="idm45963633530264">&#13;
<h1>Getting Started</h1>&#13;
&#13;
<p>The code and tests for this chapter are in <em>08_subs</em>.<a data-primary="sequence similarity" data-secondary="getting started" data-type="indexterm" id="idm45963633528488"/><a data-primary="subsequences" data-secondary="subsequence similarity" data-tertiary="getting started" data-type="indexterm" id="idm45963633527544"/>&#13;
I suggest you start by copying the first solution to the program <code>subs.py</code> and requesting help:</p>&#13;
&#13;
<pre data-type="programlisting">$ cd 08_subs/&#13;
$ cp solution1_str_find.py subs.py&#13;
$ ./subs.py -h&#13;
usage: subs.py [-h] seq subseq&#13;
&#13;
Find subsequences&#13;
&#13;
positional arguments:&#13;
  seq         Sequence&#13;
  subseq      subsequence&#13;
&#13;
optional arguments:&#13;
  -h, --help  show this help message and exit</pre>&#13;
&#13;
<p>The program should report the starting locations where the subsequence can be found in the sequence.&#13;
As shown in <a data-type="xref" href="#fig_8.1">Figure 8-1</a>, the subsequence <em>ATAT</em> can be found at positions 2, 4, and 10 in the sequence <em>GATATATGCATATACTT</em>:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./subs.py GATATATGCATATACTT ATAT&#13;
2 4 10</pre>&#13;
&#13;
<figure><div class="figure" id="fig_8.1">&#13;
<img alt="mpfb 0801" src="assets/mpfb_0801.png"/>&#13;
<h6><span class="label">Figure 8-1. </span>The subsequence <em>ATAT</em> can be found at positions 2, 4, and 10</h6>&#13;
</div></figure>&#13;
&#13;
<p>Run the tests to see if you understand what will be expected, then start your program from scratch:</p>&#13;
&#13;
<pre data-type="programlisting">$ new.py -fp 'Find subsequences' subs.py&#13;
Done, see new script "subs.py".</pre>&#13;
&#13;
<p>Here is how I define the program’s parameters:</p>&#13;
&#13;
<pre data-type="programlisting">class Args(NamedTuple): <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO1-1" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO1-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Command-line arguments """&#13;
    seq: str&#13;
    subseq: str&#13;
&#13;
&#13;
def get_args() -&gt; Args: <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO1-2" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO1-2"><img alt="2" src="assets/2.png"/></a>&#13;
    """ Get command-line arguments """&#13;
&#13;
    parser = argparse.ArgumentParser(&#13;
        description='Find subsequences',&#13;
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)&#13;
&#13;
    parser.add_argument('seq', metavar='seq', help='Sequence')&#13;
&#13;
    parser.add_argument('subseq', metavar='subseq', help='subsequence')&#13;
&#13;
    args = parser.parse_args()&#13;
&#13;
    return Args(args.seq, args.subseq) <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO1-3" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO1-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO1-1" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The <code>Args</code> class will have two string fields, <code>seq</code> and <code>subseq</code>.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO1-2" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The function returns an <code>Args</code> object.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO1-3" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Package and return the arguments using <code>Args</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Have your <code>main()</code> print the sequence and subsequence:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    print(f'sequence = {args.seq}')&#13;
    print(f'subsequence = {args.subseq}')</pre>&#13;
&#13;
<p>Run the program with the expected inputs and verify that it prints the arguments <span class="keep-together">correctly:</span></p>&#13;
&#13;
<pre data-type="programlisting">$ ./subs.py GATATATGCATATACTT ATAT&#13;
sequence = GATATATGCATATACTT&#13;
subsequence = ATAT</pre>&#13;
&#13;
<p>Now you have a program that should pass the first two tests.&#13;
If you think you can finish this on your own, please proceed; otherwise, I’ll show you one way to find the location of one string inside another.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Finding Subsequences" data-type="sect2"><div class="sect2" id="idm45963633494888">&#13;
<h2>Finding Subsequences</h2>&#13;
&#13;
<p>To demonstrate how to find the subsequence, I’ll start by defining the following sequence and subsequence in the REPL:<a data-primary="sequence similarity" data-secondary="finding subsequences" data-type="indexterm" id="ch08-fnd"/><a data-primary="subsequences" data-secondary="subsequence similarity" data-tertiary="finding subsequences" data-type="indexterm" id="ch08-fnd2"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq = 'GATATATGCATATACTT'&#13;
&gt;&gt;&gt; subseq = 'ATAT'</pre>&#13;
&#13;
<p>I can use <code>in</code> to determine if one sequence is a subset of another.<a data-primary="in operator" data-type="indexterm" id="idm45963633489096"/><a data-primary="strings (str)" data-secondary="in operator" data-type="indexterm" id="idm45963633488424"/>&#13;
This also works for membership in lists, sets, or keys of a dictionary:<a data-primary="lists" data-secondary="in operator" data-type="indexterm" id="idm45963633487256"/><a data-primary="sets using in operator" data-type="indexterm" id="idm45963633486312"/><a data-primary="dictionaries" data-secondary="in operator" data-type="indexterm" id="idm45963633485640"/><a data-primary="keys of a dictionary" data-see="dictionaries" data-type="indexterm" id="idm45963633484696"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; subseq in seq&#13;
True</pre>&#13;
&#13;
<p>That’s good information, but it doesn’t tell me <em>where</em> the string can be found.&#13;
Luckily there’s the <code>str.find()</code> function, which says <code>subseq</code> can be found starting at index 1 (which is the second character):<a data-primary="find() function" data-type="indexterm" id="idm45963633481128"/><a data-primary="strings (str)" data-secondary="find() function" data-type="indexterm" id="idm45963633480456"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq.find(subseq)&#13;
1</pre>&#13;
&#13;
<p>I know from the Rosalind description that the answer should be 2, 4, and 10.&#13;
I just found 2, so how can I find the next?&#13;
I can’t just call the same function again because I’ll get the same answer.&#13;
I need to look further into the sequence.&#13;
Maybe <code>help(str.find)</code> could be of some use?</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; help(str.find)&#13;
find(...)&#13;
    S.find(sub[, start[, end]]) -&gt; int&#13;
&#13;
    Return the lowest index in S where substring sub is found,&#13;
    such that sub is contained within S[start:end].  Optional&#13;
    arguments start and end are interpreted as in slice notation.&#13;
&#13;
    Return -1 on failure.</pre>&#13;
&#13;
<p>It appears I can specify a <em>start</em> position.<a data-primary="find() function" data-secondary="start position" data-type="indexterm" id="idm45963633475752"/><a data-primary="strings (str)" data-secondary="find() function" data-tertiary="start position" data-type="indexterm" id="idm45963633474808"/>&#13;
I’ll use 1 greater than the position where the first subsequence was found, which was 1, so starting at 2:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq.find(subseq, 2)&#13;
3</pre>&#13;
&#13;
<p>Great.&#13;
That’s the next answer—well, 4 is the next answer, but you know what I mean.&#13;
I’ll try that again, this time starting at 4:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq.find(subseq, 4)&#13;
9</pre>&#13;
&#13;
<p>That was the last value I expected.&#13;
What happens if I try using a start of 10?&#13;
As the documentation shows, this will return <code>-1</code> to indicate the subsequence cannot be found:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq.find(subseq, 10)&#13;
-1</pre>&#13;
&#13;
<p>Can you think of a way to iterate through the sequence, remembering the last position where the subsequence was found until it cannot be found?</p>&#13;
&#13;
<p>Another option would be to use <code>str.index()</code>, but only if the subsequence is present:<a data-primary="index() of strings" data-type="indexterm" id="idm45963633468008"/><a data-primary="strings (str)" data-secondary="index()" data-type="indexterm" id="idm45963633467336"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; if subseq in seq:&#13;
...     seq.index(subseq)&#13;
...&#13;
1</pre>&#13;
&#13;
<p>To find the next occurrence, you could slice the sequence using the last known position.&#13;
You’ll have to add this position to the starting position, but you’re essentially doing the same operation of moving further into the sequence to find if the subsequence is present and where:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; if subseq in seq[2:]:&#13;
...     seq.index(subseq[2:])&#13;
...&#13;
1</pre>&#13;
&#13;
<p>If you read <strong><code>help(str.index)</code></strong>, you’ll see that, like <code>str.find()</code>, the function takes a second optional start position of the index at which to start looking:<a data-primary="index() of strings" data-secondary="start position" data-type="indexterm" id="idm45963633462584"/><a data-primary="strings (str)" data-secondary="index()" data-tertiary="start position" data-type="indexterm" id="idm45963633461640"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; if subseq in seq[2:]:&#13;
...     seq.index(subseq, 2)&#13;
...&#13;
3</pre>&#13;
&#13;
<p>A third approach would be to use k-mers.&#13;
If the subsequence is present, then it is by definition a k-mer, where <em>k</em> is the length of the subsequence.<a data-primary="k-mers" data-secondary="subsequences as" data-type="indexterm" id="idm45963633458648"/>&#13;
Use your code from <a data-type="xref" href="ch07.html#ch07">Chapter 7</a> to extract all the k-mers and their positions from the sequence, and note the positions of the k-mers that match the subsequence.</p>&#13;
&#13;
<p>Finally, since I’m looking for a pattern of text, I could use a regular expression.&#13;
In <a data-type="xref" href="ch05.html#ch05">Chapter 5</a>, I used the <code>re.findall()</code> function to find all the <em>G</em>s and <em>C</em>s in DNA.<a data-primary="regular expressions (regexes)" data-secondary="findall()" data-type="indexterm" id="idm45963633453880"/>&#13;
I can similarly use this method to find all the subsequences in the sequence:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import re&#13;
&gt;&gt;&gt; re.findall(subseq, seq)&#13;
['ATAT', 'ATAT']</pre>&#13;
&#13;
<p>That seems to have a couple of problems.&#13;
One is that it only returned two of the subsequences when I know there are three.&#13;
The other problem is that this provides no information about <em>where</em> the matches are found.&#13;
Fear not, the <code>re.finditer()</code> function solves this second problem:<a data-primary="regular expressions (regexes)" data-secondary="finditer()" data-type="indexterm" id="idm45963633450376"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(re.finditer(subseq, seq))&#13;
[&lt;re.Match object; span=(1, 5), match='ATAT'&gt;,&#13;
 &lt;re.Match object; span=(9, 13), match='ATAT'&gt;]</pre>&#13;
&#13;
<p>Now it’s apparent that it finds the first and last subsequences.&#13;
Why doesn’t it find the second instance?&#13;
It turns out regular expressions don’t handle overlapping patterns very well, but some additions to the search pattern can fix this.&#13;
I’ll leave it to you and some internet searching to see if you can figure out a solution.</p>&#13;
&#13;
<p>I’ve presented four different options for how to solve this problem.&#13;
See if you can write solutions using each approach.&#13;
The point is to explore the corners of Python, storing away tasty bits and tricks that might prove decisive in some future program you write.&#13;
It’s OK to spend hours or days working this out.&#13;
Keep at it until you have solutions that pass both <code>pytest</code> and <code>make test</code>.<a data-startref="ch08-fnd" data-type="indexterm" id="idm45963633446120"/><a data-startref="ch08-fnd2" data-type="indexterm" id="idm45963633445448"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solutions" data-type="sect1"><div class="sect1" id="idm45963633444296">&#13;
<h1>Solutions</h1>&#13;
&#13;
<p>All of the solutions share the same <code>get_args()</code> shown previously.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before" data-pdf-bookmark="Solution 1: Using the str.find() Method" data-type="sect2"><div class="sect2" id="idm45963633442376">&#13;
<h2>Solution 1: Using the str.find() Method</h2>&#13;
&#13;
<p>Here is my first solution using the <code>str.find()</code> method:<a data-primary="sequence similarity" data-secondary="solution 1 str.find()" data-type="indexterm" id="idm45963633440328"/><a data-primary="find() function" data-secondary="finding similar sequences" data-type="indexterm" id="idm45963633439384"/><a data-primary="strings (str)" data-secondary="find() function" data-tertiary="finding similar sequences" data-type="indexterm" id="idm45963633438424"/><a data-primary="subsequences" data-secondary="subsequence similarity" data-tertiary="solution 1 str.find()" data-type="indexterm" id="idm45963633437192"/></p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    last = 0 <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-1" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-1"><img alt="1" src="assets/1.png"/></a>&#13;
    found = [] <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-2" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-2"><img alt="2" src="assets/2.png"/></a>&#13;
    while True: <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-3" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-3"><img alt="3" src="assets/3.png"/></a>&#13;
        pos = args.seq.find(args.subseq, last) <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-4" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-4"><img alt="4" src="assets/4.png"/></a>&#13;
        if pos == -1: <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-5" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-5"><img alt="5" src="assets/5.png"/></a>&#13;
            break&#13;
        found.append(pos + 1) <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-6" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-6"><img alt="6" src="assets/6.png"/></a>&#13;
        last = pos + 1 <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-7" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-7"><img alt="7" src="assets/7.png"/></a>&#13;
&#13;
    print(*found) <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-8" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-8"><img alt="8" src="assets/8.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-1" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Initialize the <code>last</code> position to <code>0</code>, the start of the sequence.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-2" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Initialize a list to hold all the positions where the subsequence is found.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-3" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Create an infinite loop using <code>while</code>.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-4" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Use <code>str.find()</code> to look for the subsequence using the last known position.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-5" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>If the return is <code>-1</code>, the subsequence is not found, so exit the loop.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-6" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Append one greater than the index to the list of found positions.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-7" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Update the last known position with one greater than the found index.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-8" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Print the found positions using <code>*</code> to expand the list into the elements. The function will use a space to separate multiple values.</p></dd>&#13;
</dl>&#13;
&#13;
<p>This solution turns on keeping track of the <em>last</em> place the subsequence was found.&#13;
I initialize this to <code>0</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; last = 0</pre>&#13;
&#13;
<p>I use this with <code>str.find()</code> to look for the subsequence starting at the last known position:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq = 'GATATATGCATATACTT'&#13;
&gt;&gt;&gt; subseq = 'ATAT'&#13;
&gt;&gt;&gt; pos = seq.find(subseq, last)&#13;
&gt;&gt;&gt; pos&#13;
1</pre>&#13;
&#13;
<p>As long as <code>seq.find()</code> returns a value other than <code>-1</code>, I update the last position to one greater to search starting at the next character:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; last = pos + 1&#13;
&gt;&gt;&gt; pos = seq.find(subseq, last)&#13;
&gt;&gt;&gt; pos&#13;
3</pre>&#13;
&#13;
<p>Another call to the function finds the last instance:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; last = pos + 1&#13;
&gt;&gt;&gt; pos = seq.find(subseq, last)&#13;
&gt;&gt;&gt; pos&#13;
9</pre>&#13;
&#13;
<p>Finally, <code>seq.find()</code> returns <code>-1</code> to indicate that the pattern can no longer be found:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; last = pos + 1&#13;
&gt;&gt;&gt; pos = seq.find(subseq, last)&#13;
&gt;&gt;&gt; pos&#13;
-1</pre>&#13;
&#13;
<p>This solution would be immediately understandable to someone with a background in the C programming language.&#13;
It’s a very <em>imperative</em> approach with lots of detailed logic for updating the state of the algorithm.&#13;
<em>State</em> is how data in a program changes over time.&#13;
For instance, properly updating and using the last known position is key to making this approach work.&#13;
Later approaches use far less explicit coding.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 2: Using the str.index() Method" data-type="sect2"><div class="sect2" id="idm45963633382680">&#13;
<h2>Solution 2: Using the str.index() Method</h2>&#13;
&#13;
<p>This next solution is a variation that slices the sequence using the last known <span class="keep-together">position:</span><a data-primary="sequence similarity" data-secondary="solution 2 str.index()" data-type="indexterm" id="idm45963633380728"/><a data-primary="subsequences" data-secondary="subsequence similarity" data-tertiary="solution 2 str.index()" data-type="indexterm" id="idm45963633379784"/><a data-primary="index() of strings" data-secondary="finding similar sequences" data-type="indexterm" id="idm45963633378568"/><a data-primary="strings (str)" data-secondary="index()" data-tertiary="finding similar sequences" data-type="indexterm" id="idm45963633377608"/><a data-primary="finding similar sequences" data-see="sequence similarity" data-type="indexterm" id="idm45963633376376"/></p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    seq, subseq = args.seq, args.subseq <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-1" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-1"><img alt="1" src="assets/1.png"/></a>&#13;
    found = []&#13;
    last = 0&#13;
    while subseq in seq[last:]: <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-2" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-2"><img alt="2" src="assets/2.png"/></a>&#13;
        last = seq.index(subseq, last) + 1 <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-3" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-3"><img alt="3" src="assets/3.png"/></a>&#13;
        found.append(last) <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-4" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-4"><img alt="4" src="assets/4.png"/></a>&#13;
&#13;
    print(' '.join(map(str, found))) <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-5" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-5"><img alt="5" src="assets/5.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-1" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Unpack the sequence and subsequence.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-2" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Ask if the subsequence appears in a slice of the sequence starting at the last found position. The <code>while</code> loop will execute as long as this condition is true.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-3" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Use <code>str.index()</code> to get the starting position of the subsequence. The <code>last</code> variable gets updated by adding 1 to the subsequence index to create the next starting position.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-4" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Append this position to the list of found positions.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-5" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Use <code>map()</code> to coerce all the found integer positions to strings, then join them on spaces to print.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Here again, I rely on tracking the last place a subsequence was found.&#13;
I start at position 0, or the beginning of the string:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; last = 0&#13;
&gt;&gt;&gt; if subseq in seq[last:]:&#13;
...     last = seq.index(subseq, last) + 1&#13;
...&#13;
&gt;&gt;&gt; last&#13;
2</pre>&#13;
&#13;
<p>The <code>while True</code> loop in the first solution is a common way to start an infinite loop.&#13;
Here, the <code>while</code> loop will only execute as long as the subsequence is found in the slice of the sequence, meaning I don’t have to manually decide when to <code>break</code> out of the loop:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; last = 0&#13;
&gt;&gt;&gt; found = []&#13;
&gt;&gt;&gt; while subseq in seq[last:]:&#13;
...     last = seq.index(subseq, last) + 1&#13;
...     found.append(last)&#13;
...&#13;
&gt;&gt;&gt; found&#13;
[2, 4, 10]</pre>&#13;
&#13;
<p>The found positions, in this case, are a list of integer values.&#13;
In the first solution, I used <code>*found</code> to splat the list and relied on <code>print()</code> to coerce the values to strings and join them on spaces.&#13;
If instead I were to try to create a new string from <code>found</code> using <code>str.join()</code>, I would run into problems.&#13;
The <code>str.join()</code> function joins many <em>strings</em> into a single string and so raises an exception when you give it nonstring values:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; ' '.join(found)&#13;
Traceback (most recent call last):&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;&#13;
TypeError: sequence item 0: expected str instance, int found</pre>&#13;
&#13;
<p>I could use a list comprehension to turn each number <code>n</code> into a string using the <code>str()</code> function:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; ' '.join([str(n) for n in found])&#13;
'2 4 10'</pre>&#13;
&#13;
<p>This can also be written using a <code>map()</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; ' '.join(map(lambda n: str(n), found))&#13;
'2 4 10'</pre>&#13;
&#13;
<p>I can leave out the <code>lambda</code> entirely because the <code>str()</code> function expects a single argument, and <code>map()</code> will naturally supply each value from <code>found</code> as the argument to <code>str()</code>.&#13;
This is my preferred way to turn a list of integers into a list of strings:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; ' '.join(map(str, found))&#13;
'2 4 10'</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 3: A Purely Functional Approach" data-type="sect2"><div class="sect2" id="idm45963633332312">&#13;
<h2>Solution 3: A Purely Functional Approach</h2>&#13;
&#13;
<p>This next solution combines many of the preceding ideas using a purely functional approach.<a data-primary="sequence similarity" data-secondary="solution 3 list comprehension" data-type="indexterm" id="idm45963633330904"/><a data-primary="subsequences" data-secondary="subsequence similarity" data-tertiary="solution 3 list comprehension" data-type="indexterm" id="idm45963633329944"/><a data-primary="list comprehension" data-secondary="finding similar sequences" data-type="indexterm" id="idm45963633328712"/>&#13;
To start, consider the <code>while</code> loops in the first two solutions used to append nonnegative values to the <code>found</code> list.&#13;
Does that sound like something a list comprehension could do?&#13;
The range of values to iterate includes all the positions <code>n</code> from 0 to the end of the sequence minus the length of the subsequence:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; r = range(len(seq) - len(subseq))&#13;
&gt;&gt;&gt; [n for n in r]&#13;
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</pre>&#13;
&#13;
<p>A list comprehension can use these values with <code>str.find()</code> to search for the subsequence in the sequence starting at each position <code>n</code>.&#13;
Starting at positions 0 and 1, the subsequence can be found at index 1.&#13;
Starting at positions 2 and 3, the subsequence can be found at index 3.&#13;
This continues until <code>-1</code> indicates the subsequence is not present for those positions <code>n</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; [seq.find(subseq, n) for n in r]&#13;
[1, 1, 3, 3, 9, 9, 9, 9, 9, 9, -1, -1, -1]</pre>&#13;
&#13;
<p>I only want the nonnegative values, so I use <code>filter()</code> to remove them:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(filter(lambda n: n &gt;= 0, [seq.find(subseq, n) for n in r]))&#13;
[1, 1, 3, 3, 9, 9, 9, 9, 9, 9]</pre>&#13;
&#13;
<p>Which could also be written by reversing the comparison in the <code>lambda</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(filter(lambda n: 0 &lt;= n, [seq.find(subseq, n) for n in r]))&#13;
[1, 1, 3, 3, 9, 9, 9, 9, 9, 9]</pre>&#13;
&#13;
<p>I show you this because I’d like to use <code>partial()</code> with the <code>operator.le()</code> (less than or equal) function because I don’t like <code>lambda</code> expressions:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from functools import partial&#13;
&gt;&gt;&gt; import operator&#13;
&gt;&gt;&gt; ok = partial(operator.le, 0)&#13;
&gt;&gt;&gt; list(filter(ok, [seq.find(subseq, n) for n in r]))&#13;
[1, 1, 3, 3, 9, 9, 9, 9, 9, 9]</pre>&#13;
&#13;
<p>I’d like to change the list comprehension to a <code>map()</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(filter(ok, map(lambda n: seq.find(subseq, n), r)))&#13;
[1, 1, 3, 3, 9, 9, 9, 9, 9, 9]</pre>&#13;
&#13;
<p>but again I want to get rid of the <code>lambda</code> by using <code>partial()</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; find = partial(seq.find, subseq)&#13;
&gt;&gt;&gt; list(filter(ok, map(find, r)))&#13;
[1, 1, 3, 3, 9, 9, 9, 9, 9, 9]</pre>&#13;
&#13;
<p>I can use <code>set()</code> to get a distinct list:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; set(filter(ok, map(find, r)))&#13;
{1, 3, 9}</pre>&#13;
&#13;
<p>These are almost the correct values, but they are the <em>index</em> positions, which are zero-based.&#13;
I need the values one greater, so I can make a function to add 1 and apply this using a <code>map()</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; add1 = partial(operator.add, 1)&#13;
&gt;&gt;&gt; list(map(add1, set(filter(ok, map(find, r)))))&#13;
[2, 4, 10]</pre>&#13;
&#13;
<p>In these limited examples, the results are properly sorted; however, one can never rely on the order of values from a set.&#13;
I must use the <code>sorted()</code> function to ensure they are properly sorted numerically:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; sorted(map(add1, set(filter(ok, map(find, r)))))&#13;
[2, 4, 10]</pre>&#13;
&#13;
<p>Finally, I need to print these values, which still exist as a list of integers:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; print(sorted(map(add1, set(filter(ok, map(find, r))))))&#13;
[2, 4, 10]</pre>&#13;
&#13;
<p>That’s almost right.&#13;
As in the first solution, I need to splat the results to get <code>print()</code> to see the individual elements:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; print(*sorted(map(add1, set(filter(ok, map(find, r))))))&#13;
2 4 10</pre>&#13;
&#13;
<p>That’s a lot of closing parentheses.&#13;
This code is starting to look a little like Lisp.&#13;
If you combine all these ideas, you wind up with the same answer as the imperative solution but now by combining only functions:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    seq, subseq = args.seq, args.subseq <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-1" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-1"><img alt="1" src="assets/1.png"/></a>&#13;
    r = list(range(len(seq) - len(subseq))) <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-2" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-2"><img alt="2" src="assets/2.png"/></a>&#13;
    ok = partial(operator.le, 0) <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-3" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-3"><img alt="3" src="assets/3.png"/></a>&#13;
    find = partial(seq.find, subseq) <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-4" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-4"><img alt="4" src="assets/4.png"/></a>&#13;
    add1 = partial(operator.add, 1) <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-5" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-5"><img alt="5" src="assets/5.png"/></a>&#13;
    print(*sorted(map(add1, set(filter(ok, map(find, r)))))) <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-6" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-6"><img alt="6" src="assets/6.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-1" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Unpack the sequence and subsequence.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-2" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Generate a range of numbers up to the length of the sequence less the length of the subsequence.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-3" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Create a partial <code>ok()</code> function that will return <code>True</code> if a given number is greater than or equal to <code>0</code>.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-4" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Create a partial <code>find()</code> function that will look for the subsequence in the sequence when provided with a start parameter.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-5" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Create a partial <code>add1()</code> function that will return one greater than the argument.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-6" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Apply all the numbers from the range to the <code>find()</code> function, filter out negative values, make the result unique by using the set() function, add one to the values, and sort the numbers before printing.</p></dd>&#13;
</dl>&#13;
&#13;
<p>This solution uses only <em>pure</em> functions and would be fairly easy to understand for a person with a background in the Haskell programming language.&#13;
If it seems like a jumble of confusion to you, I’d encourage you to spend some time working in the REPL with each piece until you understand how all these functions fit together <span class="keep-together">perfectly.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 4: Using K-mers" data-type="sect2"><div class="sect2" id="idm45963633267624">&#13;
<h2>Solution 4: Using K-mers</h2>&#13;
&#13;
<p>I mentioned that you might try finding the answer using k-mers, which I showed in <a data-type="xref" href="ch07.html#ch07">Chapter 7</a>.<a data-primary="sequence similarity" data-secondary="solution 4 k-mers" data-type="indexterm" id="idm45963633265416"/><a data-primary="k-mers" data-secondary="finding similar sequences" data-type="indexterm" id="idm45963633264472"/><a data-primary="subsequences" data-secondary="subsequence similarity" data-tertiary="solution 4 k-mers" data-type="indexterm" id="idm45963633263512"/>&#13;
If the subsequence exists in the sequence, then it must be a k-mer, where <em>k</em> equals the length of the subsequence:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq = 'GATATATGCATATACTT'&#13;
&gt;&gt;&gt; subseq = 'ATAT'&#13;
&gt;&gt;&gt; k = len(subseq)&#13;
&gt;&gt;&gt; k&#13;
4</pre>&#13;
&#13;
<p>Here are all the 4-mers in the sequence:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; kmers = [seq[i:i + k] for i in range(len(seq) - k + 1)]&#13;
&gt;&gt;&gt; kmers&#13;
['GATA', 'ATAT', 'TATA', 'ATAT', 'TATG', 'ATGC', 'TGCA', 'GCAT', 'CATA',&#13;
 'ATAT', 'TATA', 'ATAC', 'TACT', 'ACTT']</pre>&#13;
&#13;
<p>Here are the 4-mers that are the same as the subsequence I’m looking for:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(filter(lambda s: s == subseq, kmers))&#13;
['ATAT', 'ATAT', 'ATAT']</pre>&#13;
&#13;
<p>I need to know the positions as well as the k-mers.&#13;
The <code>enumerate()</code> function will return both the index and value of all the elements in a sequence.<a data-primary="enumerate() function" data-type="indexterm" id="idm45963633257176"/><a data-primary="lists" data-secondary="enumerate() function" data-type="indexterm" id="idm45963633256504"/>&#13;
Here are the first four:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; kmers = list(enumerate([seq[i:i + k] for i in range(len(seq) - k + 1)]))&#13;
&gt;&gt;&gt; kmers[:4]&#13;
[(0, 'GATA'), (1, 'ATAT'), (2, 'TATA'), (3, 'ATAT')]</pre>&#13;
&#13;
<p>I can use this with <code>filter()</code>, but now the <code>lambda</code> is receiving a tuple of the index and value so I will need to look at the second field (which is at index 1):</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(filter(lambda t: t[1] == subseq, kmers))&#13;
[(1, 'ATAT'), (3, 'ATAT'), (9, 'ATAT')]</pre>&#13;
&#13;
<p>I really only care about getting the index for the matching k-mers.&#13;
I could rewrite this using a <code>map()</code> with an <code>if</code> expression to return the index position when it’s a match, and <code>None</code> otherwise:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(map(lambda t: t[0] if t[1] == subseq else None, kmers))&#13;
[None, 1, None, 3, None, None, None, None, None, 9, None, None, None, None]</pre>&#13;
&#13;
<p>I’m frustrated that the standard <code>map()</code> function can only pass a single value to the <code>lambda</code>.&#13;
What I need is some way to splat the tuple, like <code>*t</code>, to turn it into two values.&#13;
Luckily, I’ve studied the <code>itertools</code> module documentation and found the <code>starmap()</code> function, so named because it will add a <em>star</em> to the <code>lambda</code> argument to splat it.&#13;
This allows me to unpack a tuple value like <code>(0, 'GATA')</code> into the variables <code>i</code> with the index value of <code>0</code> and <code>kmer</code> with the value <code>'GATA'</code>.&#13;
With these, I can compare the <code>kmer</code> to the subsequence and also add 1 to the index (<code>i</code>):</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from itertools import starmap&#13;
&gt;&gt;&gt; list(starmap(lambda i, kmer: i + 1 if kmer == subseq else None, kmers))&#13;
[None, 2, None, 4, None, None, None, None, None, 10, None, None, None, None]</pre>&#13;
&#13;
<p>This probably seems like an odd choice until I show you that <code>filter()</code>, if passed <code>None</code> for the <code>lambda</code>, will use the truthiness of each value, so that <code>None</code> values will be excluded.&#13;
Because this line of code is getting rather long, I’ll write the function <code>f()</code> for <code>map()</code> on a separate line:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; f = lambda i, kmer: i + 1 if kmer == subseq else None&#13;
&gt;&gt;&gt; list(filter(None, starmap(f, kmers)))&#13;
[2, 4, 10]</pre>&#13;
&#13;
<p>I can express a k-mer solution using imperative techniques:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    seq, subseq = args.seq, args.subseq&#13;
    k = len(subseq) <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-1" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-1"><img alt="1" src="assets/1.png"/></a>&#13;
    kmers = [seq[i:i + k] for i in range(len(seq) - k + 1)] <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-2" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-2"><img alt="2" src="assets/2.png"/></a>&#13;
    found = [i + 1 for i, kmer in enumerate(kmers) if kmer == subseq] <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-3" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-3"><img alt="3" src="assets/3.png"/></a>&#13;
    print(*found) <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-4" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-4"><img alt="4" src="assets/4.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-1" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>When looking for k-mers, <code>k</code> is the length of the subsequence.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-2" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Use a list comprehension to generate all the k-mers from the sequence.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-3" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Iterate through the index and value of all the k-mers, where the k-mer is equal to the subsequence. Return one greater than the index position.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-4" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Print the found positions.</p></dd>&#13;
</dl>&#13;
&#13;
<p>I can also express these ideas using purely functional techniques.&#13;
Note that <code>mypy</code> insists on a type annotation for the <code>found</code> variable:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    seq, subseq = args.seq, args.subseq&#13;
    k = len(subseq)&#13;
    kmers = enumerate(seq[i:i + k] for i in range(len(seq) - k + 1)) <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO6-1" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO6-1"><img alt="1" src="assets/1.png"/></a>&#13;
    found: Iterator[int] = filter( <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO6-2" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO6-2"><img alt="2" src="assets/2.png"/></a>&#13;
        None, starmap(lambda i, kmer: i + 1 if kmer == subseq else None, kmers))&#13;
    print(*found) <a class="co" href="#callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO6-3" id="co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO6-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO6-1" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Generate an enumerated list of the k-mers.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO6-2" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Select the positions of those k-mers equal to the subsequence.</p></dd>&#13;
<dt><a class="co" href="#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO6-3" id="callout_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO6-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Print the results.</p></dd>&#13;
</dl>&#13;
&#13;
<p>I find the imperative version easier to read, but would recommend you use whichever you find most intuitive.&#13;
Whichever solution you prefer, the interesting point is that k-mers can prove extremely useful in many situations, such as for partial sequence comparison.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 5: Finding Overlapping Patterns Using Regular Expressions" data-type="sect2"><div class="sect2" id="idm45963633198120">&#13;
<h2>Solution 5: Finding Overlapping Patterns Using Regular Expressions</h2>&#13;
&#13;
<p>To this point, I’ve been writing fairly complex solutions to find a pattern of characters inside a string.<a data-primary="sequence similarity" data-secondary="solution 5 regex overlapping patterns" data-type="indexterm" id="idm45963633196680"/><a data-primary="subsequences" data-secondary="subsequence similarity" data-tertiary="solution 5 regex overlapping patterns" data-type="indexterm" id="idm45963633195720"/><a data-primary="regular expressions (regexes)" data-secondary="overlapping patterns found" data-type="indexterm" id="idm45963633194488"/>&#13;
This is precisely the domain of regular expressions, and so it’s a bit silly to write manual solutions.&#13;
I showed earlier in this chapter that the <span class="keep-together"><code>re.finditer()</code></span> function does not find overlapping matches and so returns just two hits when I know there are three:<a data-primary="regular expressions (regexes)" data-secondary="finditer()" data-type="indexterm" id="idm45963633192296"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import re&#13;
&gt;&gt;&gt; list(re.finditer(subseq, seq))&#13;
[&lt;re.Match object; span=(1, 5), match='ATAT'&gt;,&#13;
 &lt;re.Match object; span=(9, 13), match='ATAT'&gt;]</pre>&#13;
<div data-type="note" epub:type="note">&#13;
<p>I’m going to show you that the solution is quite simple, but I want to stress that I did not know the solution until I searched the internet. The key to finding the answer was knowing what search terms to use—something like <em>regex overlapping patterns</em> turns up several useful results. The point of this aside is that no one knows all the answers, and you will constantly be searching for solutions to problems you never knew even existed. It’s not what you know that’s important, but what you can learn.</p>&#13;
</div>&#13;
&#13;
<p>The problem turns out to be that the regex engine <em>consumes</em> strings as they match.&#13;
That is, once the engine matches the first <em>ATAT</em>, it starts searching again at the end of the match.&#13;
The solution is to wrap the search pattern in a <em>look-ahead assertion</em> using the syntax <code>?=(&lt;<em>pattern</em>&gt;</code>) so that the engine won’t consume the matched string.<a data-primary="regular expressions (regexes)" data-secondary="look-ahead assertions" data-type="indexterm" id="idm45963633185512"/><a data-primary="look-ahead assertions in regexes" data-type="indexterm" id="idm45963633184552"/><a data-primary="?=(&lt;pattern&gt;) (look-ahead assertion)" data-primary-sortas="# look-ahead assertion" data-type="indexterm" id="idm45963633183864"/><a data-primary="equal signs" data-secondary="?=(&lt;pattern&gt;) (look-ahead assertion)" data-secondary-sortas="# look-ahead assertion" data-type="indexterm" id="idm45963633182904"/>&#13;
Note that this is a <em>positive</em> look-ahead; there are also <em>negative</em> look-ahead assertions as well as both positive and negative look-behind assertions.<a data-primary="positive look-ahead assertions" data-type="indexterm" id="idm45963633180536"/></p>&#13;
&#13;
<p>So if the subsequence is <em>ATAT</em>, then I want the pattern to be <code>?=(ATAT)</code>.&#13;
The problem now is that the regex engine won’t <em>save</em> the match—I’ve just told it to look for this pattern but haven’t told it to do anything with the text that is found.&#13;
I need to further wrap the assertion in parentheses to create a <em>capture group</em>:<a data-primary="regular expressions (regexes)" data-secondary="capture groups" data-type="indexterm" id="idm45963633177368"/><a data-primary="capture groups in regular expressions" data-type="indexterm" id="idm45963633176408"/><a data-primary="() (regex capture groups)" data-primary-sortas="# regex capture groups" data-type="indexterm" id="idm45963633175720"/><a data-primary="parentheses for regex capture groups" data-type="indexterm" id="idm45963633174760"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(re.finditer('(?=(ATAT))', 'GATATATGCATATACTT'))&#13;
[&lt;re.Match object; span=(1, 1), match=''&gt;,&#13;
 &lt;re.Match object; span=(3, 3), match=''&gt;,&#13;
 &lt;re.Match object; span=(9, 9), match=''&gt;]</pre>&#13;
&#13;
<p>I can use a list comprehension over this iterator to call the <code>match.start()</code> function on each of the <code>re.Match</code> objects, adding 1 to correct the position:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; [match.start() + 1 for match in re.finditer(f'(?=({subseq}))', seq)]&#13;
[2, 4, 10]</pre>&#13;
&#13;
<p>Here is the final solution that I would suggest as the best way to solve this problem:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    seq, subseq = args.seq, args.subseq&#13;
    print(*[m.start() + 1 for m in re.finditer(f'(?=({subseq}))', seq)])</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Benchmarking" data-type="sect1"><div class="sect1" id="idm45963633169096">&#13;
<h1>Benchmarking</h1>&#13;
&#13;
<p>It’s always interesting for me to see which solution runs the fastest.<a data-primary="sequence similarity" data-secondary="solutions benchmarked" data-type="indexterm" id="idm45963633167736"/><a data-primary="subsequences" data-secondary="subsequence similarity" data-tertiary="solutions benchmarked" data-type="indexterm" id="idm45963633166792"/>&#13;
I’ll use <code>hyperfine</code> again to run each version 1,000 times:<a data-primary="benchmarking the solutions" data-secondary="hyperfine tool for multiple runs" data-tertiary="finding similar sequences" data-type="indexterm" id="idm45963633164952"/><a data-primary="hyperfine tool for benchmarking" data-secondary="finding similar sequences" data-type="indexterm" id="idm45963633163688"/></p>&#13;
&#13;
<pre data-type="programlisting">$ hyperfine -m 1000 -L prg ./solution1_str_find.py,./solution2_str_index.py,\&#13;
./solution3_functional.py,./solution4_kmers_functional.py,\&#13;
./solution4_kmers_imperative.py,./solution5_re.py \&#13;
'{prg} GATATATGCATATACTT ATAT' --prepare 'rm -rf __pycache__'&#13;
...&#13;
Summary&#13;
  './solution2_str_index.py GATATATGCATATACTT ATAT' ran&#13;
    1.01 ± 0.11 times faster than&#13;
        './solution4_kmers_imperative.py GATATATGCATATACTT ATAT'&#13;
    1.02 ± 0.14 times faster than&#13;
        './solution5_re.py GATATATGCATATACTT ATAT'&#13;
    1.02 ± 0.14 times faster than&#13;
        './solution3_functional.py GATATATGCATATACTT ATAT'&#13;
    1.03 ± 0.13 times faster than&#13;
        './solution4_kmers_functional.py GATATATGCATATACTT ATAT'&#13;
    1.09 ± 0.18 times faster than&#13;
        './solution1_str_find.py GATATATGCATATACTT ATAT'</pre>&#13;
&#13;
<p>The differences aren’t significant enough, in my opinion, to sway me to choose based solely on performance.&#13;
My preference would be to use regular expressions given that they are specifically designed to find patterns of text.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Going Further" data-type="sect1"><div class="sect1" id="idm45963633160248">&#13;
<h1>Going Further</h1>&#13;
&#13;
<p>Expand the program to look for a subsequence <em>pattern</em>.&#13;
For example, you might search for simple sequence repeats (also known as <em>SSRs</em> or microsatellites) such as <code>GA(26)</code>, which would mean “<em>GA</em> repeated 26 times.” Or a repeat such as <code>(GA)15GT(GA)2</code>, which means “<em>GA</em> repeated 15 times, followed by <em>GT</em>, followed by <em>GA</em>, repeated 2 times.”&#13;
Also, consider how you might find subsequences expressed using the IUPAC codes mentioned in <a data-type="xref" href="ch01.html#ch01">Chapter 1</a>.&#13;
For instance, <em>R</em> represents either <em>A</em> or <em>G</em>, so <em>ARC</em> can match the sequences <em>AAC</em> and <em>AGC</em>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review" data-type="sect1"><div class="sect1" id="idm45963633151256">&#13;
<h1>Review</h1>&#13;
&#13;
<p>Key points from this chapter:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The <code>str.find()</code> and <code>str.index()</code> methods can determine if a subsequence is present in a given string.</p>&#13;
</li>&#13;
<li>&#13;
<p>Sets can be used to create unique collections of elements.</p>&#13;
</li>&#13;
<li>&#13;
<p>By definition, k-mers are subsequences and are relatively quick to extract and compare.</p>&#13;
</li>&#13;
<li>&#13;
<p>Regular expressions can find overlapping sequences by using a look-ahead assertion combined with a capture group.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>