- en: Chapter 5\. Using Causal Diagrams to Deconfound Data Analyses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cause-and-effect relationships are so fundamental to our understanding of the
    world that even a kindergartner intuitively grasps them. However, that intuition—and
    our data analyses—can be led astray by confounding, as we saw in [Chapter 1](ch01.xhtml#the_causal_behavioral_framework_for_da).
    If we don’t account for a joint cause of our two variables of interest, then we’ll
    misinterpret what’s happening and the regression coefficient for our cause of
    interest will be biased. However, we also saw the risks of taking into account
    the wrong variables. This makes determining which variables to include or not
    one of the most crucial questions in deconfounding data analyses and, more broadly,
    causal thinking.
  prefs: []
  type: TYPE_NORMAL
- en: It is alas a complicated question, with various authors proposing various rules
    that are more or less expansive. On the more expansive end of the spectrum, you
    have rules that err towards caution and simplicity—you can think of them as reasoned
    “everything and the kitchen sink” approaches. On the other end of the spectrum,
    you have rules that try to zero in on the exact variables required and nothing
    else, but at the cost of higher complexity and conceptual requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, answering that question doesn’t require any data. That is, you
    may want or need data to build the right CD, but once you have a CD that is correct,
    you don’t need to look at any data to identify confounding. This puts us squarely
    on the CD-to-behaviors edge of our framework ([Figure 5-1](#this_chapter_deals_with_the_relationshi))
    and as a consequence we won’t use any data in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, I will show you two rules for deconfounding with different pros and
    cons, the “disjunctive cause criterion” and the “backdoor criterion,” so that
    you can choose which one to use depending on your situation. I will set up our
    business problem in the next section before seeing in turn how to apply the two
    criteria.
  prefs: []
  type: TYPE_NORMAL
- en: '![This chapter deals with the relationship between behaviors and causal diagrams](Images/BEDA_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. This chapter deals with the relationship between behaviors and
    causal diagrams
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Business Problem: Ice Cream and Bottled Water Sales'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our starting point in this chapter is that C-Mart’s marketing department has
    released an internal report titled “the healthy customer,” which tracked the long-term
    trend towards healthier products. Based on that report, C-Mart has launched a
    marketing campaign titled “Would you like spring water with that?” for its fast-food
    and ice cream concessions. Our analytical goal is to obtain an unbiased estimate
    for the impact of ice cream sales on bottled water sales.
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging existing data and dedicated surveys, the marketing analytics team
    has established the following causal diagram, with our relationship of interest
    in bold ([Figure 5-2](#the_cd_for_our_business_situatio)).
  prefs: []
  type: TYPE_NORMAL
- en: '![The CD for our business situation](Images/BEDA_0502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. The CD for our business situation
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This CD is moderately complex and it’s not immediately obvious where confounders
    might lurk, so let’s break it down into more manageable pieces ([Figure 5-3](#breaking_down_our_cd_into_conceptual_bl)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Breaking down our CD into conceptual blocks](Images/BEDA_0503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3\. Breaking down our CD into conceptual blocks
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'These two conceptual blocks are just a pedagogical tool for understanding:
    they are not exclusive (our relationship of interest is part of both) nor are
    they exhaustive (some arrows are in neither of them).'
  prefs: []
  type: TYPE_NORMAL
- en: Our first block, in the upper left corner of the CD, shows the connections between
    the sales of ice cream and the sales of burgers and french fries through the number
    of customers. In stores with more traffic, and on busier days, overall sales tend
    to be higher, which makes the various variables move in concert. In addition,
    store staff has been instructed to offer the “Would you like spring water with
    that?” prompt both for sales of ice cream and for sales of french fries, on top
    of the “Would you like fries with that?” prompt for the sales of burgers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our second block, in the bottom right corner of the CD, shows the influence
    of two factors that have been identified in surveys but are not available at the
    individual sale level: the average age of customers (younger customers, and customers
    with children, are more likely to purchase sugary products) and the health mindset
    of customers (health-minded customers are more likely to buy water and less likely
    to buy sodas, everything else being equal).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In real-life settings, feel free to break down a large or complex CD into blocks
    as you see fit for your analyses. This is perfectly fine as long as you do some
    housekeeping at the end and check the paths from your cause of interest to your
    effect of interest that are not part of any block: you must make sure that they
    are not generating confounding, either because they are not confounding in the
    first place, or because their confounding has been taken care of when analyzing
    the conceptual blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: In this situation, it’s not immediately clear whether our relationship of interest
    between *IceCreamSales* and *BottledWaterSales* is subject to confounding and
    if so how to resolve it. Technically speaking, we don’t have any joint cause of
    both in our CD. Let’s turn to our decision rules.
  prefs: []
  type: TYPE_NORMAL
- en: The Disjunctive Cause Criterion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The disjunctive cause criterion is our first decision rule for deconfounding.
    Like an overprotective parent, it goes above and beyond what’s strictly necessary
    to remove confounding, which makes it simpler to understand and apply.
  prefs: []
  type: TYPE_NORMAL
- en: Definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The disjunctive cause criterion (DCC) states that:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding to our regression all variables that are a direct cause of both or either
    of our variables of interest, except mediators between them, removes any confounding
    of our relationship of interest.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: First Block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by breaking down this definition based on the first block in our
    ice cream example:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. All variables that are a direct cause of both or either of our variables
    of interest
  prefs: []
  type: TYPE_NORMAL
- en: This means we should include any variable that is only a direct cause of *IceCreamSales*,
    such as *NumberOfCustomers*. We should also include any variable that is only
    a cause of *BottledWaterSales*, such as *FrenchFrySales*. And finally, we should
    include any cause of both, but we don’t have any in this situation.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Except mediators between them
  prefs: []
  type: TYPE_NORMAL
- en: Mediators are variables that “transmit” the impact of our cause of interest
    on our effect of interest. That is, they are a child of our cause of interest
    and a parent of our effect of interest. We’ll look at mediators in more detail
    in [Chapter 12](ch12.xhtml#mediation_and_instrumental_variables), so for now I’ll
    just point out that we need to *exclude* them from our list of controls, because
    including them would cancel some of the causal relationships we’re trying to capture.
    We don’t have mediators between *IceCreamSales* and *BottledWaterSales* (i.e.,
    a variable that would be a child of the former and a parent of the latter), so
    we’re good on that front.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Removes any confounding of our relationship of interest
  prefs: []
  type: TYPE_NORMAL
- en: If we include the variables described in point 1 but not those described in
    point 2, then our regression coefficient for the effect of *IceCreamSales* on
    *BottledWaterSales* will be unconfounded with respect to the variables in our
    first block.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to note that the DCC is a *sufficient* but not *necessary* rule:
    applying it is enough to remove confounding but you don’t need to. For example,
    if we have a variable that is only a cause of one of our variables of interest
    and we are certain it has absolutely no connection whatsoever with any other variable,
    then it cannot be a confounder and we don’t need to include it to remove confounding.'
  prefs: []
  type: TYPE_NORMAL
- en: But when you don’t have that certainty, the DCC saves you from agonizing over
    which variable causes which, and what is or isn’t a confounder. You may be missing
    some relationships between variables or believe that there are relationships where
    there are none; you may believe that a variable is a confounder when it’s not
    or vice versa. As long as you correctly determine whether or not a variable has
    a direct causal relationship with one of the two variables you’re interested in,
    then you’ll make the right decision whether to include it or not.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s look at the chain from *NumberOfCustomers* to *BottledWaterSales*
    through *BurgerSales* and *FrenchFrySales*. We saw in [Chapter 2](ch02.xhtml#understanding_behavioral_data)
    that a chain is a causal diagram that connects variables with arrows in a straight
    line ([Figure 5-4](#the_extended_chain_in_our_first_block)).
  prefs: []
  type: TYPE_NORMAL
- en: '![The extended chain in our first block](Images/BEDA_0504.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-4\. The extended chain in our first block
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Of course, we could represent this chain with the arrows going up, down, or
    from right to left; the key point is that they are all going in the same direction,
    which allows us to collapse the chain and treat *NumberOfCustomers* as a direct
    cause of *BottledWaterSales*. But then *NumberOfCustomers* is indeed a joint direct
    cause of *IceCreamSales* and *BottledWaterSales*, and a confounder of their relationship
    ([Figure 5-5](#collapsing_the_upper_chain_makes_number)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Collapsing the upper chain makes NumberOfCustomers a direct cause of BottledWaterSales](Images/BEDA_0505.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-5\. Collapsing the upper chain makes NumberOfCustomers a direct cause
    of BottledWaterSales
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By definition of the DCC, applying it to this first block means including both
    *NumberOfCustomers* and *FrenchFrySales* as controls in our regression. Looking
    at [Figure 5-5](#collapsing_the_upper_chain_makes_number), we can see that doing
    so effectively neutralizes the confounding effect of the upper chain. More generally,
    because chains can be expanded or collapsed at will, a variable that is ultimately
    a cause of both of our variables of interest (and therefore a confounder) may
    be hidden behind a succession of intermediary variables in a CD.
  prefs: []
  type: TYPE_NORMAL
- en: 'The beauty of the DCC is that even if the marketing team had missed the upper
    chain from *NumberOfCustomers* to *BottledWaterSales* and it was not included
    in the CD, the requirement of including both *NumberOfCustomers* and *FrenchFrySales*
    would have taken care of the confounding. On the other hand, based on [Figure 5-5](#collapsing_the_upper_chain_makes_number),
    we can see that only including *NumberOfCustomers* would have been enough, and
    including *FrenchFrySales* too is redundant. This is one of the trade-offs I mentioned
    in the chapter introduction: the DCC is an expansive rule, which will remove confounding
    even when there are errors in your CD but at the cost of redundancy and requiring
    more data. Let’s now turn to the second block in our CD.'
  prefs: []
  type: TYPE_NORMAL
- en: Second Block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second block has more complex relationships between variables ([Figure 5-6](#second_block-id00071)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Second block](Images/BEDA_0506.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-6\. Second block
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Here, the only variable for which we have data beyond our variables of interest
    is *SodaSales*. It is not a cause of either *IceCreamSales* or *BottledWaterSales*,
    so the DCC would not call for its inclusion in the regression. However, it would
    call for the inclusion of both *AverageCustomerAge* and *CustomerHealthMindset*,
    for which we don’t have data. This doesn’t necessarily mean that confounding is
    happening, but we can’t be sure that it isn’t. This is the biggest limitation
    of the DCC: if you don’t have data on some of the causes of your variables of
    interest, it cannot help you. Let’s now turn to the backdoor criterion.'
  prefs: []
  type: TYPE_NORMAL
- en: The Backdoor Criterion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The backdoor criterion (BC) constitutes an alternative rule to control for
    confounders. It offers very different trade-offs compared to the disjunctive cause
    criterion: it is more complex to understand and requires having a fully accurate
    CD but it zeroes in on actual confounders and does not require including any redundant
    variable in our regression. In formal terms, it is necessary and sufficient to
    control for the variables identified by this rule to remove confounding.'
  prefs: []
  type: TYPE_NORMAL
- en: Definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The backdoor criterion states that:'
  prefs: []
  type: TYPE_NORMAL
- en: The causal relationship between two variables is confounded if there is at least
    one unblocked noncausal path between them starting with an arrow to our cause
    of interest.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Conversely, to remove all confounding, we need to block all noncausal paths
    between them starting with an arrow to our cause of interest.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To understand this definition, we’ll need to introduce or recall a variety of
    secondary definitions, in the context of the CD for our example that we’ll repeat
    here ([Figure 5-7](#the_cd_for_our_business_situation)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/BEDA_0507.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-7\. The CD for our business situation
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'First, let’s recall the definition of a *path*: we say that there is a path
    between two variables if there are arrows between them, regardless of the direction
    of the arrows, and if no variable appears twice along the way. A chain is a path
    along three or more variables, but so are forks and colliders. In that sense,
    any two variables in a CD are connected by at least one path, and generally several.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, there are seven distinct paths between *NumberOfCustomers* and
    *BottledWaterSales* in our CD:'
  prefs: []
  type: TYPE_NORMAL
- en: '*NumberOfCustomers* → *IceCreamSales* → *BottledWaterSales*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NumberOfCustomers* → *BurgerSales* → *FrenchFrySales* → *BottledWaterSales*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NumberOfCustomers* → *BurgerSales* → *FrenchFrySales* ← *CustomerHealthMindset*
    → *BottledWaterSales*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NumberOfCustomers* → *BurgerSales* → *FrenchFrySales* ← *CustomerHealthMindset*
    → *SodaSales* ← *AverageCustomerAge* → *IceCreamSales* → *BottledWaterSales*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NumberOfCustomers* → *SodaSales* ← *CustomerHealthMindset* → *BottledWaterSales*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NumberOfCustomers* → *SodaSales* ← *CustomerHealthMindset* → *FrenchFrySales*
    → *BottledWaterSales*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NumberOfCustomers* → *SodaSales* ← *AverageCustomerAge* → *IceCreamSales*
    → *BottledWaterSales*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that *NumberOfCustomers* → *BurgerSales* → *FrenchFrySales* ← *CustomerHealthMindset*
    → *SodaSales* ← *NumberOfCustomers* → *IceCreamSales* → *BottledWaterSales* is
    not a path because the variable *NumberOfCustomers* appears twice in it, which
    is forbidden.
  prefs: []
  type: TYPE_NORMAL
- en: A path is *causal* if it’s a chain, i.e., all the arrows in it go in the same
    direction. The label “causal” refers to the fact that a path between two variables
    is causal if one of the two variables causes the other through that path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Paths 1 and 2 in the preceding list are causal: they are chains and represent
    channels through which *NumberOfCustomers* affects *BottledWaterSales*. The other
    paths are *noncausal* because they each include at least one collider or fork.
    Remember that a collider is the situation when two variables cause the same one,
    whereas a fork is the situation when two variables are caused by the same one.
    For example, paths 3 and 4 both have a collider around *FrenchFrySales*, and path
    4 also includes a collider around *SodaSales* and two forks around *CustomerHealthMindset*
    and *AverageCustomerAge*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we’ll say that a path between two variables in our CD is *blocked*
    if either:'
  prefs: []
  type: TYPE_NORMAL
- en: One of the intermediary variables along that path is included in our regression
    and it’s not a collider, or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In that path there is a collider whose central variable is not included in our
    regression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, that path is *unblocked*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of blocked or unblocked is hard to understand because it really
    encapsulates two different things: whether a path is confounding or not in itself,
    and whether it’s controlled for in our regression. You can think of unblocked
    as {confounding *and* uncontrolled}, and blocked as {nonconfounding *or* controlled}.'
  prefs: []
  type: TYPE_NORMAL
- en: The ultimate root cause of confounding is always a joint cause ([Figure 5-8](#a_confounder_is_a_joint_cause_left_pare),
    left panel). However, because we can collapse or expand chains at will, that confounder
    may be “hidden” behind a number of intermediary variables ([Figure 5-8](#a_confounder_is_a_joint_cause_left_pare),
    middle panel). However, we can’t collapse a collider in the middle of a chain
    because it breaks down the direction of the arrows ([Figure 5-8](#a_confounder_is_a_joint_cause_left_pare),
    right panel). Therefore a collider blocks confounding, unless we include it in
    our regression, which neutralizes it.
  prefs: []
  type: TYPE_NORMAL
- en: '![A confounder is a joint cause (left panel), but it can be hidden behind intermediary
    variables (middle panel), while a collider prevents us from collapsing the chain
    and therefore removes confounding (right panel)](Images/BEDA_0508.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-8\. A confounder is a joint cause (left panel), but it can be hidden
    behind intermediary variables (middle panel), while a collider prevents us from
    collapsing the chain and therefore removes confounding (right panel)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: First Block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve seen the definition of the BC, let’s see how it applies to the
    variables in the first block of the causal diagram. Remember that the DCC required
    that we include both *NumbersOfCustomers* and *FrenchFrySales* as controls in
    our regression.
  prefs: []
  type: TYPE_NORMAL
- en: We can start our application of the BC with the condition “starting with an
    arrow to our cause of interest,” which simply means all the causes of our cause
    of interest, which in this case is *IceCreamSales*. There is only one of them
    in the first block, namely *NumberOfCustomers*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each path through *NumberOfCustomers*, let’s apply the other conditions
    of the BC. The first path from *IceCreamSales* to *BottledWaterSales* through
    *NumberOfCustomers* within the first block is *IceCreamSales* ← *NumberOfCustomers*
    → *BurgerSales* → *FrenchFrySales* → *BottledWaterSales*. This is the path that
    the DCC caught and controlled by including *NumberOfCustomers* and *FrenchFrySales*
    in our regression. Let’s check the conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Is that path *noncausal*? Yes, because of the fork around *NumberOfCustomers*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is that path blocked by default? No, as there is no collider in that path, and
    we haven’t included any variable as control yet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, this path is confounding our relationship of interest and we need
    to control for that path by including any one of its noncollider variables in
    our regression. That is, the BC is telling us that including any of (*NumberOfCustomers*,
    *BurgerSales*, *FrenchFrySales*) is sufficient to control for that path. However,
    I have a personal recommendation as to which variable to pick: whenever you can
    include the first variable along that path, i.e., the cause of your cause of interest,
    you should do so. In our example, that would be *NumberOfCustomers*. The reason
    for this choice is that it will also automatically control any other confounding
    path starting with that variable, which means we don’t even have to check any
    other path starting with that variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the BC is more economical than the DCC, by leveraging the assumption
    that we have a complete and correct causal diagram for the variables in that block:
    whereas the DCC asked us to include *both NumberOfCustomers* and *FrenchFrySales*,
    the BC only requires including *NumberOfCustomers*, and we can leave the first
    block without checking any other path.'
  prefs: []
  type: TYPE_NORMAL
- en: Second Block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember that the DCC kept mum about the variables in the second block: we
    couldn’t include the variables *AverageCustomerAge* and *CustomerHealthMindset*
    because we don’t have the corresponding data and therefore we were left uncertain
    whether there was uncontrolled confounding there. The BC will allow us to be much
    more definitive and precise.'
  prefs: []
  type: TYPE_NORMAL
- en: '*AverageCustomerAge* is a cause of our cause of interest, *IceCreamSales*,
    so let’s examine the path *IceCreamSales* ← *AverageCustomerAge* → *SodaSales*
    ← *CustomerHealthMindset* → *BottledWaterSales*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'That path is noncausal (i.e., not a chain): it has a fork around *AverageCustomerAge*,
    a collider around *SodaSales*, and then another fork around *CustomerHealthMindset*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it blocked by default? Yes, because of the collider around *SodaSales*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, this path is not confounding and we don’t need to control for
    it in our regression. More than that, including *SodaSales* in our regression
    would actually create confounding, by unblocking this path!
  prefs: []
  type: TYPE_NORMAL
- en: 'This configuration of two forks around a collider is peculiar enough that it
    has a name: the M-pattern, which we can see by rearranging our CD ([Figure 5-9](#visualizing_the_m_pattern_in_our_cd)).
    Admittedly, this example might seem unduly contrived. But in case you felt it
    was artificial and unrealistic, note that it was adapted from an example in *The
    Book of Why* about actual tobacco litigation in 2006, where the inclusion of a
    control for seatbelt usage biased the estimated impact of smoking on lung cancer.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing the M-pattern in our CD](Images/BEDA_0509.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-9\. Visualizing the M-pattern in our CD
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Beyond that, because all paths from *IceCreamSales* to *BottledWaterSales* through
    *AverageCustomerAge* also go through *SodaSales*, they will all be blocked as
    long as we don’t include *SodaSales* in our regression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding confounding in a CD is science: apply the rules and you’ll know. But
    it also has its back-alley shortcuts: having identified two causes of *IceCreamSales*
    through which confounding was a possibility and having made sure that any confounding
    would be blocked, we don’t have to check each and every path to *IceCreamSales*
    coming through these two causes. As you build and manipulate more CDs, you’ll
    learn to develop an intuition for it. And if you ever have a doubt, you can always
    check the rules for each possible path to make sure that you’re correct.'
  prefs: []
  type: TYPE_NORMAL
- en: The backdoor criterion is more precise than the disjunctive cause criterion,
    backdoor criterion less robust to errorsbut it’s also less robust to errors in
    our CD. Let’s imagine for the sake of the argument that the marketing team made
    a mistake in building the CD and wrongly concluded that *SodaSales* causes *CustomerHealthMindset*
    and not the other way around (in that particular case, this doesn’t make much
    sense from a behavioral perspective, but bear with me), leading to the relationships
    represented in [Figure 5-10](#what_the_second_block_would_look_like_w).
  prefs: []
  type: TYPE_NORMAL
- en: '![What the second block would look like with an error](Images/BEDA_0510.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-10\. What the second block would look like with an error
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In that case, the BC would lead us to mistakenly believe there is confounding
    at play, and to include *SodaSales* in our regression, introducing confounding
    where there had been none.
  prefs: []
  type: TYPE_NORMAL
- en: To recap, the BC identified two potential avenues for confounding, through the
    two direct causes of *IceCreamSales*. By including *NumberOfCustomers* in our
    regression, we take care of all potential confounding paths through it. On the
    other hand, by *not* including *SodaSales*, we leave alone a collider that takes
    care of any confounding through *AverageCustomerAge*.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deconfounding causal relationships is one of the core issues of behavioral data
    analysis, and the solution to the “correlation is not causation” quagmire. In
    this chapter, we saw two deconfounding rules, the *disjunctive cause criterion*
    and the *backdoor criterion*. The first one takes the stance of including all
    direct causes of our variables of interest (except mediators). The second one
    is more surgical in its application and gets to the very mechanism of confounding
    but is less intuitive and less robust to errors in a CD.
  prefs: []
  type: TYPE_NORMAL
