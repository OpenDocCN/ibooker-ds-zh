- en: Chapter 5\. Using Causal Diagrams to Deconfound Data Analyses
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。使用因果图解除数据分析中的混淆
- en: Cause-and-effect relationships are so fundamental to our understanding of the
    world that even a kindergartner intuitively grasps them. However, that intuition—and
    our data analyses—can be led astray by confounding, as we saw in [Chapter 1](ch01.xhtml#the_causal_behavioral_framework_for_da).
    If we don’t account for a joint cause of our two variables of interest, then we’ll
    misinterpret what’s happening and the regression coefficient for our cause of
    interest will be biased. However, we also saw the risks of taking into account
    the wrong variables. This makes determining which variables to include or not
    one of the most crucial questions in deconfounding data analyses and, more broadly,
    causal thinking.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 因果关系对我们理解世界是如此基础性，以至于就连幼儿园的孩子也能直观地把握。然而，这种直觉和我们的数据分析可能会被混淆所误导，正如我们在[第1章](ch01.xhtml#the_causal_behavioral_framework_for_da)中看到的那样。如果我们不考虑我们感兴趣的两个变量的联合原因，那么我们会错误地解释正在发生的事情，而我们感兴趣的原因的回归系数也会出现偏差。然而，我们也看到了考虑错误变量的风险。这使得确定包括还是不包括哪些变量成为解除数据分析中最关键的问题之一，更广泛地说，是因果思维中最关键的问题之一。
- en: It is alas a complicated question, with various authors proposing various rules
    that are more or less expansive. On the more expansive end of the spectrum, you
    have rules that err towards caution and simplicity—you can think of them as reasoned
    “everything and the kitchen sink” approaches. On the other end of the spectrum,
    you have rules that try to zero in on the exact variables required and nothing
    else, but at the cost of higher complexity and conceptual requirements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜这是一个复杂的问题，各位作者提出了各种更多或更少扩展性的规则。在扩展性较高的一端，有一些规则偏向于谨慎和简单——你可以将它们看作是合理的“包罗万象”方法。在另一端，有些规则试图准确找出所需的变量，但这样做会增加复杂性和概念上的要求。
- en: Interestingly, answering that question doesn’t require any data. That is, you
    may want or need data to build the right CD, but once you have a CD that is correct,
    you don’t need to look at any data to identify confounding. This puts us squarely
    on the CD-to-behaviors edge of our framework ([Figure 5-1](#this_chapter_deals_with_the_relationshi))
    and as a consequence we won’t use any data in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，回答这个问题并不需要任何数据。也就是说，你可能想要或需要数据来建立正确的因果图，但一旦你拥有了正确的因果图，就无需查看任何数据来识别混淆。这使我们直接处于我们框架的因果图到行为边缘（[图5-1](#this_chapter_deals_with_the_relationshi)），因此在本章中我们不会使用任何数据。
- en: Instead, I will show you two rules for deconfounding with different pros and
    cons, the “disjunctive cause criterion” and the “backdoor criterion,” so that
    you can choose which one to use depending on your situation. I will set up our
    business problem in the next section before seeing in turn how to apply the two
    criteria.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我将向您展示两个解除混淆的规则，它们各有利弊，“析取性因果准则”和“后门准则”，这样您可以根据您的情况选择使用哪一个。在下一节中，我将设立我们的业务问题，然后依次看看如何应用这两个准则。
- en: '![This chapter deals with the relationship between behaviors and causal diagrams](Images/BEDA_0501.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![本章讨论行为与因果图之间的关系](Images/BEDA_0501.png)'
- en: Figure 5-1\. This chapter deals with the relationship between behaviors and
    causal diagrams
  id: totrans-6
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-1。本章讨论行为与因果图之间的关系
- en: 'Business Problem: Ice Cream and Bottled Water Sales'
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务问题：冰淇淋和瓶装水销售
- en: Our starting point in this chapter is that C-Mart’s marketing department has
    released an internal report titled “the healthy customer,” which tracked the long-term
    trend towards healthier products. Based on that report, C-Mart has launched a
    marketing campaign titled “Would you like spring water with that?” for its fast-food
    and ice cream concessions. Our analytical goal is to obtain an unbiased estimate
    for the impact of ice cream sales on bottled water sales.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章的起点是C-Mart市场部发布的内部报告，题为“健康顾客”，追踪了向健康产品长期趋势的变化。基于该报告，C-Mart推出了名为“您需要配有天然泉水的冰淇淋吗？”的快餐和冰淇淋特许经营的营销活动。我们的分析目标是获得冰淇淋销售对瓶装水销售影响的无偏估计。
- en: By leveraging existing data and dedicated surveys, the marketing analytics team
    has established the following causal diagram, with our relationship of interest
    in bold ([Figure 5-2](#the_cd_for_our_business_situatio)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用现有数据和专用调查，市场分析团队建立了以下因果图，我们感兴趣的关系用粗体标出（[图5-2](#the_cd_for_our_business_situatio)）。
- en: '![The CD for our business situation](Images/BEDA_0502.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![我们业务情况的因果图](Images/BEDA_0502.png)'
- en: Figure 5-2\. The CD for our business situation
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-2\. 我们业务情境的 CD
- en: This CD is moderately complex and it’s not immediately obvious where confounders
    might lurk, so let’s break it down into more manageable pieces ([Figure 5-3](#breaking_down_our_cd_into_conceptual_bl)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 CD 相对复杂，不明显的混杂因素可能潜藏其中，因此让我们将其分解成更易处理的部分（[Figure 5-3](#breaking_down_our_cd_into_conceptual_bl)）。
- en: '![Breaking down our CD into conceptual blocks](Images/BEDA_0503.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![我们的 CD 分解为概念块](Images/BEDA_0503.png)'
- en: Figure 5-3\. Breaking down our CD into conceptual blocks
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-3\. 将我们的 CD 分解为概念块
- en: 'These two conceptual blocks are just a pedagogical tool for understanding:
    they are not exclusive (our relationship of interest is part of both) nor are
    they exhaustive (some arrows are in neither of them).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个概念块仅是理解的教学工具：它们既不是排他的（我们感兴趣的关系同时包含在内），也不是穷尽的（有些箭头两者都没有涵盖）。
- en: Our first block, in the upper left corner of the CD, shows the connections between
    the sales of ice cream and the sales of burgers and french fries through the number
    of customers. In stores with more traffic, and on busier days, overall sales tend
    to be higher, which makes the various variables move in concert. In addition,
    store staff has been instructed to offer the “Would you like spring water with
    that?” prompt both for sales of ice cream and for sales of french fries, on top
    of the “Would you like fries with that?” prompt for the sales of burgers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个块位于 CD 的左上角，显示了冰淇淋销售和汉堡包和薯条销售之间通过客户数量的连接。在客流量更大和更繁忙的日子里，总体销售往往更高，这使得各种变量同时变动。此外，店员已被指示在冰淇淋和薯条销售中提供“您要不要来杯矿泉水？”的提示，以及在汉堡包销售中提供“您要不要薯条？”的提示。
- en: 'Our second block, in the bottom right corner of the CD, shows the influence
    of two factors that have been identified in surveys but are not available at the
    individual sale level: the average age of customers (younger customers, and customers
    with children, are more likely to purchase sugary products) and the health mindset
    of customers (health-minded customers are more likely to buy water and less likely
    to buy sodas, everything else being equal).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个块位于 CD 的右下角，显示了两个在调查中已确定但在个别销售水平上不可用的因素的影响：顾客的平均年龄（年龄较小的顾客和有孩子的顾客更有可能购买含糖产品）和顾客的健康意识（有健康意识的顾客更倾向于购买水，而不倾向于购买苏打水，在其他一切条件相等的情况下）。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'In real-life settings, feel free to break down a large or complex CD into blocks
    as you see fit for your analyses. This is perfectly fine as long as you do some
    housekeeping at the end and check the paths from your cause of interest to your
    effect of interest that are not part of any block: you must make sure that they
    are not generating confounding, either because they are not confounding in the
    first place, or because their confounding has been taken care of when analyzing
    the conceptual blocks.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中的设置中，可以根据分析的需要自由地将大型或复杂的 CD 分解为块。只要在最后进行一些整理并检查从你感兴趣的原因到你感兴趣的效果的路径不包含在任何块中：你必须确保它们不会生成混杂，因为它们本身可能不是混杂，或者在分析概念块时已经处理了它们的混杂。
- en: In this situation, it’s not immediately clear whether our relationship of interest
    between *IceCreamSales* and *BottledWaterSales* is subject to confounding and
    if so how to resolve it. Technically speaking, we don’t have any joint cause of
    both in our CD. Let’s turn to our decision rules.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，目前尚不清楚我们感兴趣的冰淇淋销售与瓶装水销售之间是否存在混杂，以及如何解决。从技术上讲，在我们的 CD 中，我们没有任何同时导致这两者的共同原因。让我们转向我们的决策规则。
- en: The Disjunctive Cause Criterion
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离因果标准
- en: The disjunctive cause criterion is our first decision rule for deconfounding.
    Like an overprotective parent, it goes above and beyond what’s strictly necessary
    to remove confounding, which makes it simpler to understand and apply.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 分离因果标准是我们解除混杂的第一决策规则。像一个过于保护的父母一样，它超出了严格需要去除混杂的范围，使得它更简单易懂且易于应用。
- en: Definition
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义
- en: 'The disjunctive cause criterion (DCC) states that:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 分离因果标准（DCC）指出：
- en: Adding to our regression all variables that are a direct cause of both or either
    of our variables of interest, except mediators between them, removes any confounding
    of our relationship of interest.
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在我们感兴趣的关系中，添加所有直接导致我们感兴趣的变量的回归变量，除了它们之间的中介变量，可以消除任何混杂。
- en: First Block
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一个块
- en: 'Let’s start by breaking down this definition based on the first block in our
    ice cream example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的冰淇淋例子的第一个区块开始分解这个定义：
- en: 1\. All variables that are a direct cause of both or either of our variables
    of interest
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 所有直接导致我们感兴趣的变量的变量
- en: This means we should include any variable that is only a direct cause of *IceCreamSales*,
    such as *NumberOfCustomers*. We should also include any variable that is only
    a cause of *BottledWaterSales*, such as *FrenchFrySales*. And finally, we should
    include any cause of both, but we don’t have any in this situation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们应该包括任何只是直接导致*冰淇淋销售*的变量，例如*顾客数*。我们还应该包括任何只导致*瓶装水销售*的变量，例如*薯条销售*。最后，我们应该包括任何两者都导致的原因，但在这种情况下我们没有这样的变量。
- en: 2\. Except mediators between them
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 除了它们之间的中介者
- en: Mediators are variables that “transmit” the impact of our cause of interest
    on our effect of interest. That is, they are a child of our cause of interest
    and a parent of our effect of interest. We’ll look at mediators in more detail
    in [Chapter 12](ch12.xhtml#mediation_and_instrumental_variables), so for now I’ll
    just point out that we need to *exclude* them from our list of controls, because
    including them would cancel some of the causal relationships we’re trying to capture.
    We don’t have mediators between *IceCreamSales* and *BottledWaterSales* (i.e.,
    a variable that would be a child of the former and a parent of the latter), so
    we’re good on that front.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 中介者是“传输”我们感兴趣的原因对我们感兴趣的效果的影响的变量。也就是说，它们是我们感兴趣的原因的子代和我们感兴趣的效果的父代。我们将在[第十二章](ch12.xhtml#mediation_and_instrumental_variables)更详细地讨论中介者，所以现在我只想指出，我们需要*排除*它们在我们的控制列表之外，因为包括它们将取消我们试图捕捉的一些因果关系。在*冰淇淋销售*和*瓶装水销售*之间我们没有中介者（即，一个变量既是前者的子代又是后者的父代），所以在这一点上我们做得很好。
- en: 3\. Removes any confounding of our relationship of interest
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 消除我们感兴趣的关系的任何混杂
- en: If we include the variables described in point 1 but not those described in
    point 2, then our regression coefficient for the effect of *IceCreamSales* on
    *BottledWaterSales* will be unconfounded with respect to the variables in our
    first block.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们包括第1点描述的变量但不包括第2点描述的变量，那么我们对*冰淇淋销售*对*瓶装水销售*效应的回归系数将不受我们第一个区块中的变量的混杂影响。
- en: 'It’s important to note that the DCC is a *sufficient* but not *necessary* rule:
    applying it is enough to remove confounding but you don’t need to. For example,
    if we have a variable that is only a cause of one of our variables of interest
    and we are certain it has absolutely no connection whatsoever with any other variable,
    then it cannot be a confounder and we don’t need to include it to remove confounding.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，DCC是一个*充分*但不是*必要*的规则：应用它足以消除混杂，但我们并不一定需要。例如，如果我们有一个变量只是我们感兴趣的一个变量的原因，并且我们确信它与任何其他变量绝对没有任何联系，那么它不能是混杂因素，我们也不需要将其包括以消除混杂。
- en: But when you don’t have that certainty, the DCC saves you from agonizing over
    which variable causes which, and what is or isn’t a confounder. You may be missing
    some relationships between variables or believe that there are relationships where
    there are none; you may believe that a variable is a confounder when it’s not
    or vice versa. As long as you correctly determine whether or not a variable has
    a direct causal relationship with one of the two variables you’re interested in,
    then you’ll make the right decision whether to include it or not.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但当你没有这种确定性时，DCC会让你免于苦苦思索哪个变量导致了哪个，以及什么是混杂因素。你可能会忽略一些变量之间的关系，或者认为有关系而实际上没有；你可能会认为一个变量是混杂因素，而实际上不是，反之亦然。只要你正确确定一个变量是否与你感兴趣的两个变量之一有直接因果关系，你就能正确决定是否将其包含在内。
- en: For example, let’s look at the chain from *NumberOfCustomers* to *BottledWaterSales*
    through *BurgerSales* and *FrenchFrySales*. We saw in [Chapter 2](ch02.xhtml#understanding_behavioral_data)
    that a chain is a causal diagram that connects variables with arrows in a straight
    line ([Figure 5-4](#the_extended_chain_in_our_first_block)).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看从*顾客数*到*瓶装水销售量*的链路，途径*汉堡销售*和*薯条销售*。我们在[第二章](ch02.xhtml#understanding_behavioral_data)看到，链路是一个因果图，通过直线箭头连接变量（[图 5-4](#我们第一个区块中的扩展链)）。
- en: '![The extended chain in our first block](Images/BEDA_0504.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![我们第一个区块中的扩展链](Images/BEDA_0504.png)'
- en: Figure 5-4\. The extended chain in our first block
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-4\. 我们第一个区块中的扩展链
- en: Of course, we could represent this chain with the arrows going up, down, or
    from right to left; the key point is that they are all going in the same direction,
    which allows us to collapse the chain and treat *NumberOfCustomers* as a direct
    cause of *BottledWaterSales*. But then *NumberOfCustomers* is indeed a joint direct
    cause of *IceCreamSales* and *BottledWaterSales*, and a confounder of their relationship
    ([Figure 5-5](#collapsing_the_upper_chain_makes_number)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以用箭头表示这条链条向上、向下或从右到左；关键是它们都是朝着同一个方向前进的，这使我们能够折叠这条链条，并将*NumberOfCustomers*视为*BottledWaterSales*的直接原因。但是*NumberOfCustomers*确实是*IceCreamSales*和*BottledWaterSales*的联合直接原因，也是它们关系的混杂因素（[图5-5](#collapsing_the_upper_chain_makes_number)）。
- en: '![Collapsing the upper chain makes NumberOfCustomers a direct cause of BottledWaterSales](Images/BEDA_0505.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![折叠上链使NumberOfCustomers成为BottledWaterSales的直接原因](Images/BEDA_0505.png)'
- en: Figure 5-5\. Collapsing the upper chain makes NumberOfCustomers a direct cause
    of BottledWaterSales
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-5\. 折叠上链使NumberOfCustomers成为BottledWaterSales的直接原因
- en: By definition of the DCC, applying it to this first block means including both
    *NumberOfCustomers* and *FrenchFrySales* as controls in our regression. Looking
    at [Figure 5-5](#collapsing_the_upper_chain_makes_number), we can see that doing
    so effectively neutralizes the confounding effect of the upper chain. More generally,
    because chains can be expanded or collapsed at will, a variable that is ultimately
    a cause of both of our variables of interest (and therefore a confounder) may
    be hidden behind a succession of intermediary variables in a CD.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 根据DCC的定义，将其应用于这个第一个区块意味着在我们的回归中包括*NumberOfCustomers*和*FrenchFrySales*作为控制变量。从[图5-5](#collapsing_the_upper_chain_makes_number)中可以看出，这样做有效地中和了上链的混杂效应。更一般地说，因为链条可以随意扩展或折叠，所以最终是我们感兴趣的两个变量的原因（因此也是混杂因素）的变量可能被隐藏在CD中的一系列中间变量之后。
- en: 'The beauty of the DCC is that even if the marketing team had missed the upper
    chain from *NumberOfCustomers* to *BottledWaterSales* and it was not included
    in the CD, the requirement of including both *NumberOfCustomers* and *FrenchFrySales*
    would have taken care of the confounding. On the other hand, based on [Figure 5-5](#collapsing_the_upper_chain_makes_number),
    we can see that only including *NumberOfCustomers* would have been enough, and
    including *FrenchFrySales* too is redundant. This is one of the trade-offs I mentioned
    in the chapter introduction: the DCC is an expansive rule, which will remove confounding
    even when there are errors in your CD but at the cost of redundancy and requiring
    more data. Let’s now turn to the second block in our CD.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 'DCC的美妙之处在于，即使市场团队忽略了从*NumberOfCustomers*到*BottledWaterSales*的上链，并且它没有被包含在CD中，包括*NumberOfCustomers*和*FrenchFrySales*的要求也会处理混杂问题。另一方面，根据[图5-5](#collapsing_the_upper_chain_makes_number)，我们可以看到仅包括*NumberOfCustomers*就足够了，而包括*FrenchFrySales*也是多余的。这是我在章节介绍中提到的权衡之一：DCC是一个广泛的规则，即使在CD中存在错误，也会消除混杂，但代价是冗余和需要更多数据。现在让我们转向CD中的第二区块。 '
- en: Second Block
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二区块
- en: The second block has more complex relationships between variables ([Figure 5-6](#second_block-id00071)).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第二区块中的变量之间存在更复杂的关系（[图5-6](#second_block-id00071)）。
- en: '![Second block](Images/BEDA_0506.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![第二区块](Images/BEDA_0506.png)'
- en: Figure 5-6\. Second block
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-6\. 第二区块
- en: 'Here, the only variable for which we have data beyond our variables of interest
    is *SodaSales*. It is not a cause of either *IceCreamSales* or *BottledWaterSales*,
    so the DCC would not call for its inclusion in the regression. However, it would
    call for the inclusion of both *AverageCustomerAge* and *CustomerHealthMindset*,
    for which we don’t have data. This doesn’t necessarily mean that confounding is
    happening, but we can’t be sure that it isn’t. This is the biggest limitation
    of the DCC: if you don’t have data on some of the causes of your variables of
    interest, it cannot help you. Let’s now turn to the backdoor criterion.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们除了关注的变量外，唯一拥有数据的变量是*SodaSales*。它既不是*IceCreamSales*也不是*BottledWaterSales*的原因，因此DCC不会要求将其包括在回归中。然而，它会要求包括*AverageCustomerAge*和*CustomerHealthMindset*，而我们没有这些数据。这并不一定意味着混杂正在发生，但我们无法确定它没有发生。这是DCC的最大局限性：如果你没有关于你感兴趣的变量的一些原因的数据，它就无法帮助你。现在让我们转向背门准则。
- en: The Backdoor Criterion
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背门准则
- en: 'The backdoor criterion (BC) constitutes an alternative rule to control for
    confounders. It offers very different trade-offs compared to the disjunctive cause
    criterion: it is more complex to understand and requires having a fully accurate
    CD but it zeroes in on actual confounders and does not require including any redundant
    variable in our regression. In formal terms, it is necessary and sufficient to
    control for the variables identified by this rule to remove confounding.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 背门准则（BC）构成了控制混杂因素的另一种规则。与分离因果准则相比，它提供了非常不同的权衡：理解起来更复杂，并且需要具有完全准确的 CD，但它聚焦于实际的混杂因素，并且不需要在我们的回归中包含任何多余的变量。从形式上讲，控制这一规则确定的变量就足以消除混杂因素。
- en: Definitions
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义
- en: 'The backdoor criterion states that:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 背门准则表明：
- en: The causal relationship between two variables is confounded if there is at least
    one unblocked noncausal path between them starting with an arrow to our cause
    of interest.
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果两个变量之间存在至少一个未阻塞的非因果路径，从我们感兴趣的原因开始，它们之间的因果关系就会受到干扰。
- en: ''
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Conversely, to remove all confounding, we need to block all noncausal paths
    between them starting with an arrow to our cause of interest.
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 相反，要消除所有混杂因素，我们需要阻断所有非因果路径，从我们感兴趣的原因开始。
- en: To understand this definition, we’ll need to introduce or recall a variety of
    secondary definitions, in the context of the CD for our example that we’ll repeat
    here ([Figure 5-7](#the_cd_for_our_business_situation)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这个定义，我们需要介绍或回顾一系列次要定义，在我们的示例中，与我们将在此重复的 CD 上下文相关（[图 5-7](#the_cd_for_our_business_situation)）。
- en: '![](Images/BEDA_0507.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/BEDA_0507.png)'
- en: Figure 5-7\. The CD for our business situation
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-7\. 我们业务情况下的 CD
- en: 'First, let’s recall the definition of a *path*: we say that there is a path
    between two variables if there are arrows between them, regardless of the direction
    of the arrows, and if no variable appears twice along the way. A chain is a path
    along three or more variables, but so are forks and colliders. In that sense,
    any two variables in a CD are connected by at least one path, and generally several.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下“路径”的定义：如果它们之间有箭头，不管箭头的方向如何，并且在这条路上没有变量出现两次，我们称之为存在路径。链是沿着三个或更多变量的路径，分叉和碰撞也是如此。从这个意义上说，CD
    中的任意两个变量都至少通过一条路径相连，通常是几条。
- en: 'For example, there are seven distinct paths between *NumberOfCustomers* and
    *BottledWaterSales* in our CD:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的 CD 中，*NumberOfCustomers* 和 *BottledWaterSales* 之间有七条不同的路径：
- en: '*NumberOfCustomers* → *IceCreamSales* → *BottledWaterSales*'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NumberOfCustomers* → *IceCreamSales* → *BottledWaterSales*'
- en: '*NumberOfCustomers* → *BurgerSales* → *FrenchFrySales* → *BottledWaterSales*'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NumberOfCustomers* → *BurgerSales* → *FrenchFrySales* → *BottledWaterSales*'
- en: '*NumberOfCustomers* → *BurgerSales* → *FrenchFrySales* ← *CustomerHealthMindset*
    → *BottledWaterSales*'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NumberOfCustomers* → *BurgerSales* → *FrenchFrySales* ← *CustomerHealthMindset*
    → *BottledWaterSales*'
- en: '*NumberOfCustomers* → *BurgerSales* → *FrenchFrySales* ← *CustomerHealthMindset*
    → *SodaSales* ← *AverageCustomerAge* → *IceCreamSales* → *BottledWaterSales*'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NumberOfCustomers* → *BurgerSales* → *FrenchFrySales* ← *CustomerHealthMindset*
    → *SodaSales* ← *AverageCustomerAge* → *IceCreamSales* → *BottledWaterSales*'
- en: '*NumberOfCustomers* → *SodaSales* ← *CustomerHealthMindset* → *BottledWaterSales*'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NumberOfCustomers* → *SodaSales* ← *CustomerHealthMindset* → *BottledWaterSales*'
- en: '*NumberOfCustomers* → *SodaSales* ← *CustomerHealthMindset* → *FrenchFrySales*
    → *BottledWaterSales*'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NumberOfCustomers* → *SodaSales* ← *CustomerHealthMindset* → *FrenchFrySales*
    → *BottledWaterSales*'
- en: '*NumberOfCustomers* → *SodaSales* ← *AverageCustomerAge* → *IceCreamSales*
    → *BottledWaterSales*'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NumberOfCustomers* → *SodaSales* ← *AverageCustomerAge* → *IceCreamSales*
    → *BottledWaterSales*'
- en: Note that *NumberOfCustomers* → *BurgerSales* → *FrenchFrySales* ← *CustomerHealthMindset*
    → *SodaSales* ← *NumberOfCustomers* → *IceCreamSales* → *BottledWaterSales* is
    not a path because the variable *NumberOfCustomers* appears twice in it, which
    is forbidden.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*NumberOfCustomers* → *BurgerSales* → *FrenchFrySales* ← *CustomerHealthMindset*
    → *SodaSales* ← *NumberOfCustomers* → *IceCreamSales* → *BottledWaterSales* 不是一条路径，因为变量
    *NumberOfCustomers* 在其中出现了两次，这是不允许的。
- en: A path is *causal* if it’s a chain, i.e., all the arrows in it go in the same
    direction. The label “causal” refers to the fact that a path between two variables
    is causal if one of the two variables causes the other through that path.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是一个链，即其中所有的箭头都是朝着同一个方向的，那么路径就是“因果”的。标签“因果”指的是路径之间的因果关系，如果其中一个变量通过该路径导致另一个变量，则该路径是因果的。
- en: 'Paths 1 and 2 in the preceding list are causal: they are chains and represent
    channels through which *NumberOfCustomers* affects *BottledWaterSales*. The other
    paths are *noncausal* because they each include at least one collider or fork.
    Remember that a collider is the situation when two variables cause the same one,
    whereas a fork is the situation when two variables are caused by the same one.
    For example, paths 3 and 4 both have a collider around *FrenchFrySales*, and path
    4 also includes a collider around *SodaSales* and two forks around *CustomerHealthMindset*
    and *AverageCustomerAge*.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前述列表中的路径1和2是因果关系的：它们是链条，代表*NumberOfCustomers*影响*BottledWaterSales*的通道。其他路径是*非因果关系*，因为它们每个都至少包含一个对撞机或叉路。请记住，对撞机是当两个变量导致同一个变量时的情况，而叉路是当两个变量被同一个变量导致时的情况。例如，路径3和4都在*FrenchFrySales*周围有一个对撞机，路径4还在*SodaSales*周围有一个对撞机，以及*CustomerHealthMindset*和*AverageCustomerAge*周围有两个叉路。
- en: 'Finally, we’ll say that a path between two variables in our CD is *blocked*
    if either:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将说，在我们的CD中，两个变量之间的路径如果是*阻塞*的，那么它要么是：
- en: One of the intermediary variables along that path is included in our regression
    and it’s not a collider, or
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沿着那条路径的中介变量之一包括在我们的回归中，并且它不是一个对撞机，或者
- en: In that path there is a collider whose central variable is not included in our
    regression.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这条路径中，有一个对撞机，其核心变量未包含在我们的回归中。
- en: Otherwise, that path is *unblocked*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，那条路径是*未阻塞*的。
- en: 'The concept of blocked or unblocked is hard to understand because it really
    encapsulates two different things: whether a path is confounding or not in itself,
    and whether it’s controlled for in our regression. You can think of unblocked
    as {confounding *and* uncontrolled}, and blocked as {nonconfounding *or* controlled}.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞或未阻塞的概念很难理解，因为它实际上包含了两件不同的事情：路径本身是否混杂以及它是否在我们的回归中被控制。你可以将未阻塞视为{混杂 *且* 未控制}，阻塞为{非混杂
    *或* 已控制}。
- en: The ultimate root cause of confounding is always a joint cause ([Figure 5-8](#a_confounder_is_a_joint_cause_left_pare),
    left panel). However, because we can collapse or expand chains at will, that confounder
    may be “hidden” behind a number of intermediary variables ([Figure 5-8](#a_confounder_is_a_joint_cause_left_pare),
    middle panel). However, we can’t collapse a collider in the middle of a chain
    because it breaks down the direction of the arrows ([Figure 5-8](#a_confounder_is_a_joint_cause_left_pare),
    right panel). Therefore a collider blocks confounding, unless we include it in
    our regression, which neutralizes it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 混杂的最终根本原因始终是联合原因（[图5-8](#a_confounder_is_a_joint_cause_left_pare)，左面板）。但是，由于我们可以随意折叠或扩展链条，这个混杂因素可能“隐藏”在许多中介变量背后（[图5-8](#a_confounder_is_a_joint_cause_left_pare)，中间面板）。然而，我们无法在链条中间折叠对撞机，因为它会破坏箭头的方向（[图5-8](#a_confounder_is_a_joint_cause_left_pare)，右面板）。因此，对撞机阻止了混杂，除非我们在回归中包括它，这样就中和了它。
- en: '![A confounder is a joint cause (left panel), but it can be hidden behind intermediary
    variables (middle panel), while a collider prevents us from collapsing the chain
    and therefore removes confounding (right panel)](Images/BEDA_0508.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![混杂因素是联合原因（左面板），但它可以隐藏在中介变量背后（中间面板），而对撞机阻止了我们折叠链条，因此消除了混杂（右面板）](Images/BEDA_0508.png)'
- en: Figure 5-8\. A confounder is a joint cause (left panel), but it can be hidden
    behind intermediary variables (middle panel), while a collider prevents us from
    collapsing the chain and therefore removes confounding (right panel)
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-8。混杂因素是联合原因（左面板），但它可以隐藏在中介变量背后（中间面板），而对撞机阻止了我们折叠链条，因此消除了混杂（右面板）
- en: First Block
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一个区块
- en: Now that we’ve seen the definition of the BC, let’s see how it applies to the
    variables in the first block of the causal diagram. Remember that the DCC required
    that we include both *NumbersOfCustomers* and *FrenchFrySales* as controls in
    our regression.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了BC的定义，让我们看看它如何适用于因果图的第一个区块中的变量。记住，DCC要求我们在回归中包括*NumbersOfCustomers*和*FrenchFrySales*作为控制变量。
- en: We can start our application of the BC with the condition “starting with an
    arrow to our cause of interest,” which simply means all the causes of our cause
    of interest, which in this case is *IceCreamSales*. There is only one of them
    in the first block, namely *NumberOfCustomers*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从条件“从指向我们感兴趣的原因的箭头开始”开始应用BC，这意味着我们感兴趣的原因的所有原因，这种情况下是*IceCreamSales*。在第一个区块中，只有一个，即*NumberOfCustomers*。
- en: 'For each path through *NumberOfCustomers*, let’s apply the other conditions
    of the BC. The first path from *IceCreamSales* to *BottledWaterSales* through
    *NumberOfCustomers* within the first block is *IceCreamSales* ← *NumberOfCustomers*
    → *BurgerSales* → *FrenchFrySales* → *BottledWaterSales*. This is the path that
    the DCC caught and controlled by including *NumberOfCustomers* and *FrenchFrySales*
    in our regression. Let’s check the conditions:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通过 *NumberOfCustomers* 的每条路径，让我们应用BC的其他条件。第一块内的 *IceCreamSales* 到 *BottledWaterSales*
    的路径通过 *NumberOfCustomers* 是 *IceCreamSales* ← *NumberOfCustomers* → *BurgerSales*
    → *FrenchFrySales* → *BottledWaterSales*。这是DCC捕获并通过在我们的回归中包括 *NumberOfCustomers*
    和 *FrenchFrySales* 来控制的路径。让我们检查一下条件：
- en: Is that path *noncausal*? Yes, because of the fork around *NumberOfCustomers*.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那条路径是非因果的吗？是的，因为围绕 *NumberOfCustomers* 的分叉。
- en: Is that path blocked by default? No, as there is no collider in that path, and
    we haven’t included any variable as control yet.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下那条路径被阻断了吗？不是的，因为在那条路径中没有碰撞器，并且我们尚未包括任何变量作为控制。
- en: 'Therefore, this path is confounding our relationship of interest and we need
    to control for that path by including any one of its noncollider variables in
    our regression. That is, the BC is telling us that including any of (*NumberOfCustomers*,
    *BurgerSales*, *FrenchFrySales*) is sufficient to control for that path. However,
    I have a personal recommendation as to which variable to pick: whenever you can
    include the first variable along that path, i.e., the cause of your cause of interest,
    you should do so. In our example, that would be *NumberOfCustomers*. The reason
    for this choice is that it will also automatically control any other confounding
    path starting with that variable, which means we don’t even have to check any
    other path starting with that variable.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这条路径混淆了我们感兴趣的关系，我们需要通过在我们的回归中包括该路径的任意一个非碰撞器变量来控制它。也就是说，BC告诉我们，包括任何一个 (*NumberOfCustomers*,
    *BurgerSales*, *FrenchFrySales*) 就足以控制这条路径。然而，我个人建议选择哪个变量：每当你能包括那条路径的第一个变量，即你感兴趣的原因的原因，你应该这样做。在我们的例子中，这将是
    *NumberOfCustomers*。选择这个原因的原因是它也会自动控制起始于该变量的任何其他混淆路径，这意味着我们甚至不必检查起始于该变量的任何其他路径。
- en: 'As you can see, the BC is more economical than the DCC, by leveraging the assumption
    that we have a complete and correct causal diagram for the variables in that block:
    whereas the DCC asked us to include *both NumberOfCustomers* and *FrenchFrySales*,
    the BC only requires including *NumberOfCustomers*, and we can leave the first
    block without checking any other path.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，BC比DCC更经济，通过利用我们对该块中变量的完整和正确因果图的假设：而DCC要求我们包括 *NumberOfCustomers* 和
    *FrenchFrySales*，BC只需要包括 *NumberOfCustomers*，我们可以不检查任何其他路径就将第一块留下。
- en: Second Block
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二个阻止
- en: 'Remember that the DCC kept mum about the variables in the second block: we
    couldn’t include the variables *AverageCustomerAge* and *CustomerHealthMindset*
    because we don’t have the corresponding data and therefore we were left uncertain
    whether there was uncontrolled confounding there. The BC will allow us to be much
    more definitive and precise.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，DCC对第二块中的变量保持沉默：我们不能包括变量 *AverageCustomerAge* 和 *CustomerHealthMindset*，因为我们没有相应的数据，因此我们不确定那里是否存在未受控制的混淆。BC将使我们能够更加确定和精确。
- en: '*AverageCustomerAge* is a cause of our cause of interest, *IceCreamSales*,
    so let’s examine the path *IceCreamSales* ← *AverageCustomerAge* → *SodaSales*
    ← *CustomerHealthMindset* → *BottledWaterSales*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*AverageCustomerAge* 是我们感兴趣的因果关系 *IceCreamSales* 的一个原因，因此让我们来检查路径 *IceCreamSales*
    ← *AverageCustomerAge* → *SodaSales* ← *CustomerHealthMindset* → *BottledWaterSales*：'
- en: 'That path is noncausal (i.e., not a chain): it has a fork around *AverageCustomerAge*,
    a collider around *SodaSales*, and then another fork around *CustomerHealthMindset*.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那条路径是非因果的（即不是一个链）：它在 *AverageCustomerAge* 周围有一个分叉，在 *SodaSales* 周围有一个碰撞器，然后在
    *CustomerHealthMindset* 周围有另一个分叉。
- en: Is it blocked by default? Yes, because of the collider around *SodaSales*.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下它被阻塞了吗？是的，因为围绕 *SodaSales* 的碰撞器。
- en: In other words, this path is not confounding and we don’t need to control for
    it in our regression. More than that, including *SodaSales* in our regression
    would actually create confounding, by unblocking this path!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这条路径并不是混杂因素，我们在回归中不需要控制它。更甚的是，将 *SodaSales* 包含在我们的回归中实际上会创建混杂，通过解除这条路径！
- en: 'This configuration of two forks around a collider is peculiar enough that it
    has a name: the M-pattern, which we can see by rearranging our CD ([Figure 5-9](#visualizing_the_m_pattern_in_our_cd)).
    Admittedly, this example might seem unduly contrived. But in case you felt it
    was artificial and unrealistic, note that it was adapted from an example in *The
    Book of Why* about actual tobacco litigation in 2006, where the inclusion of a
    control for seatbelt usage biased the estimated impact of smoking on lung cancer.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个在对撞机周围有两个叉子的配置非常特殊，以至于有一个名字：M型模式，我们可以通过重新排列我们的CD（[图5-9](#visualizing_the_m_pattern_in_our_cd)）看到。不可否认，这个例子可能看起来有些刻意。但是，如果你觉得它过于人为和不真实，请注意，它是根据《为什么之书》中关于2006年实际烟草诉讼的一个例子改编的，那里包括了一个控制座椅安全带使用对估计吸烟对肺癌影响的偏差。
- en: '![Visualizing the M-pattern in our CD](Images/BEDA_0509.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![在我们的CD中可视化M型模式](Images/BEDA_0509.png)'
- en: Figure 5-9\. Visualizing the M-pattern in our CD
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-9\. 在我们的CD中可视化M型模式
- en: Beyond that, because all paths from *IceCreamSales* to *BottledWaterSales* through
    *AverageCustomerAge* also go through *SodaSales*, they will all be blocked as
    long as we don’t include *SodaSales* in our regression.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为所有从*IceCreamSales*到*BottledWaterSales*的路径都通过*AverageCustomerAge*也经过*SodaSales*，只要我们在回归中不包括*SodaSales*，它们都会被阻断。
- en: 'Finding confounding in a CD is science: apply the rules and you’ll know. But
    it also has its back-alley shortcuts: having identified two causes of *IceCreamSales*
    through which confounding was a possibility and having made sure that any confounding
    would be blocked, we don’t have to check each and every path to *IceCreamSales*
    coming through these two causes. As you build and manipulate more CDs, you’ll
    learn to develop an intuition for it. And if you ever have a doubt, you can always
    check the rules for each possible path to make sure that you’re correct.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在CD中找到混杂因素是一门科学：应用规则，你就会知道。但它也有它的捷径：已经确定了通过两个*IceCreamSales*的原因存在混杂的可能性，并确保任何混杂会被阻断，我们就不必检查每一条通过这两个原因到*IceCreamSales*的路径。当你建立和操作更多的CD时，你会学会发展一种直觉。如果你有疑问，你随时可以检查每条可能的路径的规则，确保你是正确的。
- en: The backdoor criterion is more precise than the disjunctive cause criterion,
    backdoor criterion less robust to errorsbut it’s also less robust to errors in
    our CD. Let’s imagine for the sake of the argument that the marketing team made
    a mistake in building the CD and wrongly concluded that *SodaSales* causes *CustomerHealthMindset*
    and not the other way around (in that particular case, this doesn’t make much
    sense from a behavioral perspective, but bear with me), leading to the relationships
    represented in [Figure 5-10](#what_the_second_block_would_look_like_w).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 后门准则比排除性因果准则更精确，后门准则对我们的CD中的错误不那么鲁棒。为了论证起见，假设营销团队在构建CD时犯了一个错误，并错误地得出结论，即*SodaSales*导致*CustomerHealthMindset*而不是反过来（在这种特定情况下，从行为角度来看这并不太合理，但请忍耐），导致了[图5-10](#what_the_second_block_would_look_like_w)中所代表的关系。
- en: '![What the second block would look like with an error](Images/BEDA_0510.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![第二块如果有错误会是什么样子](Images/BEDA_0510.png)'
- en: Figure 5-10\. What the second block would look like with an error
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-10\. 第二个块如果有错误会是什么样子
- en: In that case, the BC would lead us to mistakenly believe there is confounding
    at play, and to include *SodaSales* in our regression, introducing confounding
    where there had been none.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，BC会让我们错误地认为有混杂因素在起作用，并在我们的回归中包括*SodaSales*，引入了在此之前没有的混杂因素。
- en: To recap, the BC identified two potential avenues for confounding, through the
    two direct causes of *IceCreamSales*. By including *NumberOfCustomers* in our
    regression, we take care of all potential confounding paths through it. On the
    other hand, by *not* including *SodaSales*, we leave alone a collider that takes
    care of any confounding through *AverageCustomerAge*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，BC识别出通过两个直接导致*IceCreamSales*的原因有两条潜在的混杂途径。通过在我们的回归中包括*NumberOfCustomers*，我们处理了所有可能通过它产生的混杂路径。另一方面，通过*不*包括*SodaSales*，我们放过了一个碰撞器，通过*AverageCustomerAge*来处理任何通过*IceCreamSales*的混杂因素。
- en: Conclusion
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: Deconfounding causal relationships is one of the core issues of behavioral data
    analysis, and the solution to the “correlation is not causation” quagmire. In
    this chapter, we saw two deconfounding rules, the *disjunctive cause criterion*
    and the *backdoor criterion*. The first one takes the stance of including all
    direct causes of our variables of interest (except mediators). The second one
    is more surgical in its application and gets to the very mechanism of confounding
    but is less intuitive and less robust to errors in a CD.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 揭示因果关系的混淆是行为数据分析的核心问题之一，也是解决“相关不等于因果”的泥潭的办法。在本章中，我们看到了两条混淆规则，*分离因素准则* 和 *背门准则*。第一条准则采取的立场是包括我们感兴趣变量的所有直接原因（除了中介因素）。第二条准则在应用中更为精准，直接针对混淆的机制，但在处理中错误容忍度较低。
