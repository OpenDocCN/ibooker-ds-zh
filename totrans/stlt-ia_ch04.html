<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>chapter-5</title>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
 </head>
 <body>
  <div class="readable-text " id="p1"> 
   <h1 class=" readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">5</span></span> Sharing your apps with the world</h1>
  </div>
  <div class="introduction-summary"> 
   <h3>This chapter covers</h3>
   <ul> 
    <li class="readable-text" id="p2">The various options available to share your app with users</li>
    <li class="readable-text" id="p3">Deploying an app to Streamlit Community Cloud for free</li>
    <li class="readable-text" id="p4">Connecting an app to an external service like an API</li>
    <li class="readable-text" id="p5">Safeguarding your API keys and other secrets in production</li>
    <li class="readable-text" id="p6">Managing your app's dependencies</li>
   </ul>
  </div>
  <div class="readable-text " id="p7"> 
   <p>The moment you first successfully run an app you've built from scratch is magical—it's when all the hours spent designing, developing, and refining finally pay off. You've guided it through multiple iterations, squashed bugs, and fine-tuned every feature.</p>
  </div>
  <div class="readable-text  intended-text" id="p8"> 
   <p>But what's next? Do you keep it hidden away on your local machine? Unless you've built something solely for your own use, the answer is probably no. To make your app truly useful, you need to get your app in the hands of your intended audience.</p>
  </div>
  <div class="readable-text  intended-text" id="p9"> 
   <p>This chapter is about making the leap from local development to global deployment. We'll briefly discuss the various paths you have available for sharing your apps. We'll then settle on one of them and walk through putting your app in production for the world to experience.</p>
  </div>
  <div class="readable-text  intended-text" id="p10"> 
   <p>Along the way, we'll cover key considerations involved in making your app public, such as safeguarding confidential information like API keys and managing your code's dependencies. As always, we'll take a practical approach through all of this, giving you direct hands-on experience with everything we discuss.</p>
  </div>
  <div class="readable-text" id="p11"> 
   <h2 class=" readable-text-h2">5.1 Deploying your apps</h2>
  </div>
  <div class="readable-text " id="p12"> 
   <p>We've come a long way since we started out with Streamlit. Over the last three chapters, you've created three fully functional—dare I even say, <em>useful</em>—applications. However, you've been hiding your light under the proverbial bushel; no one else has experienced your craft. It's time to change that!</p>
  </div>
  <div class="readable-text" id="p13"> 
   <h3 class=" readable-text-h3">5.1.1 What is deployment?</h3>
  </div>
  <div class="readable-text " id="p14"> 
   <p>Deploying an app loosely means making it available for other people to use. More specifically, it means hosting your application somewhere that your intended users can readily access.</p>
  </div>
  <div class="readable-text  intended-text" id="p15"> 
   <p>Recall from Chapter 4 that a Streamlit app consists of a backend server and a frontend that runs on a web browser. While the frontend makes requests to the server and shows you the results, it's the server that really runs the show.</p>
  </div>
  <div class="readable-text  intended-text" id="p16"> 
   <p>To set up the connection between the frontend and the server and thus load an app, the user has to navigate to the URL and port where the server is running. You've experienced this before; when you start an app with the <kbd>streamlit run</kbd> command, this is what the command actually does at the end—it opens up a web browser for you and navigates to a URL like "<kbd>https://localhost:8501</kbd>".</p>
  </div>
  <div class="readable-text  intended-text" id="p17"> 
   <p>You could have done this manually, too. In fact, as long as your Streamlit server is running, opening the URL in a new browser tab or window creates a new connection to the server and a new instance of your app.</p>
  </div>
  <div class="readable-text  intended-text" id="p18"> 
   <p>Deploying your app, then, involves starting and keeping a Streamlit server running, ready to accept new connections. Only, rather than you accessing your own app through the <kbd>localhost</kbd> URL, it'll be other people accessing it through a different URL.</p>
  </div>
  <div class="readable-text  intended-text" id="p19"> 
   <p>There are several approaches by which you can deploy an app. We'll discuss these briefly in the next section.</p>
  </div>
  <div class="readable-text" id="p20"> 
   <h3 class=" readable-text-h3">5.1.2 Options for deployment</h3>
  </div>
  <div class="readable-text " id="p21"> 
   <p>Depending on your requirements, how much money you're willing to spend, and how much effort you're willing to put in, there are multiple options you might consider for deployment. Let's consider some of them briefly:</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p22"> 
   <h4 class=" readable-text-h4">Running a server over your local network</h4>
  </div>
  <div class="readable-text " id="p23"> 
   <p>The simplest way to deploy your app is something you've already done each time you've run a Streamlit app. Recall that when you do this using the <kbd>streamlit run</kbd> command, a Streamlit server starts, and you can see output similar to the following in your terminal window:</p>
  </div>
  <div class="browsable-container listing-container" id="p24"> 
   <div class="code-area-container"> 
    <pre class="code-area">You can now view your Streamlit app in your browser.
 
  Local URL: http://localhost:8502
  Network URL: http://192.168.50.68:8502</pre>
   </div>
  </div>
  <div class="readable-text " id="p25"> 
   <p>As we've seen many times at this point, the "local URL" here lets <em>you</em> access your app from the computer it's running on.</p>
  </div>
  <div class="readable-text  intended-text" id="p26"> 
   <p>But if your machine is connected to a local network or even your home Wifi, other devices on the network can access it through the <em>network URL</em>.</p>
  </div>
  <div class="readable-text  intended-text" id="p27"> 
   <p>Go ahead and try it out! If you're on Wifi (or a LAN) and have another device—like a smartphone or another computer—that's connected to the same Wifi / LAN, try running one of the apps you've created, note the network URL, and open it in the second device's web browser.</p>
  </div>
  <div class="readable-text  intended-text" id="p28"> 
   <p>For instance, figure 5.1 shows what I saw when I opened my todo-list app from my phone connected to the same Wifi network:</p>
  </div>
  <div class="browsable-container figure-container" id="p29">  
   <img src="../Images/05__image001.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 5.1 Using the network URL of your Streamlit app to access it from a different device connected to the same network</h5>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p30"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p31"> 
    <p>Getting this to work depends on how your network is set up. For instance, your firewall may block incoming traffic from other devices, thus preventing it from reaching your Streamlit server, or there may be other similar rules in place. Fixing such issues is outside the scope of this book, but you should be able to figure it out with some Googling or help from your network administrator.</p>
   </div>
  </div>
  <div class="readable-text " id="p32"> 
   <p>One advantage of this method of deployment is that making changes and having them be visible to your users is as easy as editing your code; there are no extra steps!</p>
  </div>
  <div class="readable-text  intended-text" id="p33"> 
   <p>There are some obvious limitations, however:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p34">It only works while the computer where you're running the Streamlit server is on and connected to the network.</li>
   <li class="readable-text" id="p35">It only allows devices connected to your local network to access your app, not the general public.</li>
  </ul>
  <div class="readable-text " id="p36"> 
   <p>Still, it can come in handy in a bunch of places. You could create apps for your household, for example, and share the link with your family. You could even use this type of deployment for basic non-business-critical apps at your workplace depending on how lenient your networking and security policies are.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p37"> 
   <h4 class=" readable-text-h4">Setting up a dedicated server</h4>
  </div>
  <div class="readable-text " id="p38"> 
   <p>If you're looking to make your Streamlit app available to a broader audience, setting up a dedicated server <em>may</em> be a logical step beyond local deployment. This involves using a separate physical or virtual machine that runs independently of your personal computer. By doing this, you can ensure your app is available around the clock and accessible to users outside your local network.</p>
  </div>
  <div class="readable-text  intended-text" id="p39"> 
   <p>In this setup, you start by selecting a suitable server—this could be a repurposed extra computer you own or a new machine set up specifically for this purpose. After choosing a server-~-and installing Python and Streamlit on it-~-you would launch the Streamlit server for your app, and expose the correct port (e.g., port 8501) to external traffic. You'll also need to handle network configuration to allow access, such as setting up port forwarding on your router if the server is behind a firewall.</p>
  </div>
  <div class="readable-text  intended-text" id="p40"> 
   <p>Operating a dedicated server can be a daunting undertaking that comes with many responsibilities, especially related to security. You would be responsible for configuring firewalls, maintaining and updating your server's operating system and software, etc.</p>
  </div>
  <div class="readable-text  intended-text" id="p41"> 
   <p>The advantage of going this route is that you'll have complete control over your deployment, but on the flip side, it requires a lot of technical knowhow and probably more importantly, a big portion of your time.</p>
  </div>
  <div class="readable-text  intended-text" id="p42"> 
   <p>If you simply want to let the general public use the app you've developed, I would recommend one of the remaining options that we'll discuss.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p43"> 
   <h4 class=" readable-text-h4">Deploying to the cloud</h4>
  </div>
  <div class="readable-text " id="p44"> 
   <p>For greater scalability, reliability, and ease of access, you can use a cloud-based platform to deploy your app. This approach leverages the infrastructure of public cloud service providers—such as Amazon Web Services (AWS), Microsoft Azure, or Google Cloud—allowing you to host your app without the need for physical hardware. It provides numerous benefits, including automatic scaling to handle varying levels of traffic, robust security measures to protect your data, and high availability to ensure your app is accessible at all times.</p>
  </div>
  <div class="readable-text  intended-text" id="p45"> 
   <p>The key benefit of cloud deployment is that your cloud provider manages much of the infrastructure-related responsibilities associated with maintaining your application. This includes server maintenance and security updates, allowing you to focus on the development and improvement of your app.</p>
  </div>
  <div class="readable-text  intended-text" id="p46"> 
   <p>Many companies have already migrated, or are in the process of migrating, their internal applications to the cloud. If you're considering making your app available to users within your organization or to a broader audience, cloud deployment can be an efficient and effective solution. Collaborating with your cloud administrator or IT team will help ensure a smooth setup and integration process.</p>
  </div>
  <div class="readable-text  intended-text" id="p47"> 
   <p>However, it's important to note that using a cloud provider can be expensive as your app gets popular, since costs are usually based on the resources your app uses, which increases with the number of users accessing it.</p>
  </div>
  <div class="readable-text  intended-text" id="p48"> 
   <p>Chapter 13 will discuss in detail how to deploy your app to public cloud platforms such as AWS and Google Cloud.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p49"> 
   <h4 class=" readable-text-h4">Streamlit Community Cloud</h4>
  </div>
  <div class="readable-text " id="p50"> 
   <p>That leaves us with the option we'll be using for most of this book—Streamlit Community Cloud, a way to publish your apps to anyone who cares to use them, c<em>ompletely free of charge</em>.</p>
  </div>
  <div class="readable-text  intended-text" id="p51"> 
   <p>Streamlit Community Cloud is run by Snowflake, the company that owns Streamlit. It prioritizes ease-of-use, and as the name suggests, is custom-built to run Streamlit apps.</p>
  </div>
  <div class="readable-text  intended-text" id="p52"> 
   <p>Community Cloud does come with resource limitations, such as how much computational power, memory, and storage your app can use. If you cross those limits—say, if your app blows up in popularity—you may need to look at a different option, such as deployment to a paid cloud provider (see Chapter 13).</p>
  </div>
  <div class="readable-text  intended-text" id="p53"> 
   <p>However, given that we're in the process of learning Streamlit, Community Cloud is ideal for our purposes. In the rest of this chapter, we'll go through how to deploy an app to it.</p>
  </div>
  <div class="readable-text" id="p54"> 
   <h2 class=" readable-text-h2">5.2 Deploying our to-do list app to Streamlit Community Cloud</h2>
  </div>
  <div class="readable-text " id="p55"> 
   <p>As discussed in the previous section, Streamlit Community Cloud serves our deployment needs perfectly, since it's free, custom-built for Streamlit, and incredibly easy to use.</p>
  </div>
  <div class="readable-text " id="p56"> 
   <p>In this section, we'll deploy one of the apps we built previously—our to-do list app from Chapter 4—to Community Cloud, making it so that anyone with an internet connection can use it.</p>
  </div>
  <div class="readable-text" id="p57"> 
   <h3 class=" readable-text-h3">5.2.1 Prerequisites</h3>
  </div>
  <div class="readable-text " id="p58"> 
   <p>In addition to Python and Streamlit itself, deploying an app to Streamlit Community Cloud requires the following:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p59"><kbd>git</kbd>, the popular version control tool that we discussed briefly in Chapter 2</li>
   <li class="readable-text" id="p60">A GitHub account</li>
   <li class="readable-text" id="p61">A Streamlit Community Cloud account</li>
   <li class="readable-text" id="p62">Connecting your GitHub account to Community Cloud</li>
  </ul>
  <div class="readable-text " id="p63"> 
   <p>If you've never used <kbd>git</kbd> before and want to get acquainted with it, head over to Appendix B, which touches upon how to use it.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p64"> 
   <h4 class=" readable-text-h4">Creating and setting up a GitHub account</h4>
  </div>
  <div class="readable-text " id="p65"> 
   <p>You may have heard of GitHub, a web-based platform used for version control and collaborative software development. It uses <kbd>git</kbd>, a distributed version control system, to help developers track changes in their code, collaborate on projects, and manage versions of their software.</p>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p66"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p67"> 
    <p>GitHub and git are not to be confused with each other. git is the name of the version control system. and Git<em>Hub</em> is the most popular platform for hosting repositories created using git. You can use git with other hosting platforms, such as Bitbucket, though Streamlit Community Cloud does require GitHub.</p>
   </div>
  </div>
  <div class="readable-text " id="p68"> 
   <p>A link to a GitHub account is a pretty standard fixture on most developers' resume these days. Importantly for us, Streamlit Community Cloud expects that your app's code will be stored in a GitHub <em>repository</em>, which consists of a collection of files and directories along with their revision history.</p>
  </div>
  <div class="readable-text  intended-text" id="p69"> 
   <p>Begin by going to<kbd> github.com</kbd> and signing up for a new account. The sign-up process is pretty similar to what you would expect on other websites—you'll have to enter your email and verify it, create a username, and select a strong password.</p>
  </div>
  <div class="readable-text  intended-text" id="p70"> 
   <p>Once you've created your account, you'll need to enable your command-line to authenticate and push code to any repositories you make. There are several ways to do this, but we'll use Personal Access Tokens (PATs), which are alternatives to passwords meant for accessing GitHub through the command-line or an API.</p>
  </div>
  <div class="readable-text  intended-text" id="p71"> 
   <p>At the time of writing, to get to the PAT creation screen, you can follow these steps:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p72">Click on your profile picture and then "Settings"</li>
   <li class="readable-text" id="p73">Find and click on "Developer settings" in the side panel</li>
   <li class="readable-text" id="p74">Click "Personal access tokens" &gt; "Tokens (classic)"</li>
   <li class="readable-text" id="p75">Select "Generate new token"</li>
  </ul>
  <div class="readable-text " id="p76"> 
   <p>Figure 5.2 shows this path visually (though of course GitHub may change how it's configured).</p>
  </div>
  <div class="browsable-container figure-container" id="p77">  
   <img src="../Images/05__image002.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 5.2 How to get to the Personal Access Token generation page on GitHub</h5>
  </div>
  <div class="readable-text " id="p78"> 
   <p>In the screen that opens up, make sure to select the "repo" scope, which gives you full control of repositories.</p>
  </div>
  <div class="readable-text  intended-text" id="p79"> 
   <p>You'll also need to enter a note describing what the token is for (feel free to enter something like "Token to push Streamlit code") and an expiration.</p>
  </div>
  <div class="readable-text  intended-text" id="p80"> 
   <p>Once a PAT expires, you won't be able to use it any more and will need to create another one, so choose accordingly. A shorter expiry is more secure-~-as it'll be valid for a smaller period if compromised-~-but also means you'll have to change it more frequently.</p>
  </div>
  <div class="readable-text  intended-text" id="p81"> 
   <p>Figure 5.3 shows the selections you could make.</p>
  </div>
  <div class="browsable-container figure-container" id="p82">  
   <img src="../Images/05__image003.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 5.3 The PAT creation screen on GitHub; make sure to select the "repo" scope</h5>
  </div>
  <div class="readable-text " id="p83"> 
   <p>Click "Generate token" to actually create it. GitHub will now show you the token you created. Copy it and store it somewhere safe, because you'll never be able to see it again!</p>
  </div>
  <div class="readable-text  intended-text" id="p84"> 
   <p>We'll use the PAT later when we're pushing our code.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p85"> 
   <h4 class=" readable-text-h4">Creating a Streamlit Community Cloud account</h4>
  </div>
  <div class="readable-text " id="p86"> 
   <p>To create a Community Cloud account, go to the Streamlit website,<kbd> https://streamlit.io/</kbd>, click "Sign up", and follow the instructions. I recommend siging up with your GitHub account.</p>
  </div>
  <div class="readable-text  intended-text" id="p87"> 
   <p>Once you're done, it should take you to a "dashboard" page.</p>
  </div>
  <div class="readable-text  intended-text" id="p88"> 
   <p>If you didn't sign up with your GitHub account, you'll see an exclamation point next to "Workspaces" on the top left.</p>
  </div>
  <div class="readable-text  intended-text" id="p89"> 
   <p>If this is the case, you'll need to separately connect your GitHub account to Community Cloud. As of the time of writing, you can do this by clicking "Workspaces" and then "Connect GitHub account".</p>
  </div>
  <div class="readable-text  intended-text" id="p90"> 
   <p>If you're already logged in to GitHub, you won't need to do anything else. If you aren't, you'll need to enter your GitHub account credentials.</p>
  </div>
  <div class="readable-text" id="p91"> 
   <h3 class=" readable-text-h3">5.2.2 Deployment steps</h3>
  </div>
  <div class="readable-text " id="p92"> 
   <p>Now that you've got your accounts set up, deploying your app is a three-step process:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p93">Creating a GitHub repo</li>
   <li class="readable-text" id="p94">Pushing your code to GitHub</li>
   <li class="readable-text" id="p95">Telling Community Cloud where to look for it</li>
  </ul>
  <div class="readable-text " id="p96"> 
   <p>If your app needs to connect to an external service, or if it needs specialized libraries, there are a couple more steps that we'll explore later in the chapter, but the above steps will work for the existing to-do list app that we built in Chapter 4.</p>
  </div>
  <div class="readable-text  intended-text" id="p97"> 
   <p>If you've already made <kbd>git</kbd> a part of your regular workflow as a developer (as we recommended in Chapter 2), you may already have created a repo and pushed your code into it, and can therefore skip ahead to the section "Telling Community Cloud where to find your app.”</p>
  </div>
  <div class="readable-text  intended-text" id="p98"> 
   <p>If not, read the sections below in order.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p99"> 
   <h4 class=" readable-text-h4">Creating a GitHub repo</h4>
  </div>
  <div class="readable-text " id="p100"> 
   <p>To start, sign in to your GitHub account. The button to create a new repo should be fairly obvious. If you've never created one before in this account, you should see a "Create repository" button as shown on the left of figure 5.4. If you do have some repos already, it should instead display a list of your top repos and you can create a new one by clicking "New", as shown on the right.</p>
  </div>
  <div class="browsable-container figure-container" id="p101">  
   <img src="../Images/05__image004.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 5.4 Buttons to create a new repo on GitHub</h5>
  </div>
  <div class="readable-text " id="p102"> 
   <p>This should lead you to a page that asks you about the details of your new repo (see figure 5.5)</p>
  </div>
  <div class="browsable-container figure-container" id="p103">  
   <img src="../Images/05__image005.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 5.5 The repository creation screen on GitHub</h5>
  </div>
  <div class="readable-text " id="p104"> 
   <p>You can ignore most settings here—just make sure you give the repo a memorable name and choose "Public" for the visibility.</p>
  </div>
  <div class="readable-text  intended-text" id="p105"> 
   <p>When you're done, click "Create repository.” You'll be taken to a screen with some instructions and importantly, the URL of your repo, as seen in figure 5.6.</p>
  </div>
  <div class="browsable-container figure-container" id="p106">  
   <img src="../Images/05__image006.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 5.6 Your repo URL</h5>
  </div>
  <div class="readable-text " id="p107"> 
   <p>Make a note of this URL as you'll need it in the next section. If you need to, you can find this URL again later by navigating to your repo.</p>
  </div>
  <div class="readable-text  intended-text" id="p108"> 
   <p>Your repository is now ready for you to put some code in!</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p109"> 
   <h4 class=" readable-text-h4">Pushing your code to GitHub</h4>
  </div>
  <div class="readable-text " id="p110"> 
   <p>At this juncture, you have a <em>remote</em> GitHub repo, but your Streamlit app code is stored <em>locally</em>, on your computer. We'll now make this code available in your remote repo, a process called <em>pushing</em> your code.</p>
  </div>
  <div class="readable-text  intended-text" id="p111"> 
   <p>Open a terminal window and navigate to the directory that contains your to-do list app from Chapter 4, which consists of two files: <kbd>todo_list.py</kbd> and <kbd>task.py</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p112"> 
   <p>Enter the following command to initialize this directory as a <em>local</em> Git repository (as opposed to the remote one on GitHub):</p>
  </div>
  <div class="browsable-container listing-container" id="p113"> 
   <div class="code-area-container"> 
    <pre class="code-area">git init</pre>
   </div>
  </div>
  <div class="readable-text " id="p114"> 
   <p>The <kbd>git init</kbd> command creates an empty Git repo, setting up all the required files in a hidden subdirectory called <kbd>.git</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p115"> 
   <p>Next, type in:</p>
  </div>
  <div class="browsable-container listing-container" id="p116"> 
   <div class="code-area-container"> 
    <pre class="code-area">git add .</pre>
   </div>
  </div>
  <div class="readable-text " id="p117"> 
   <p>This adds the contents of the current directory to Git's <em>staging area</em>, which is a temporary holding place for changes you make to your code. You use the staging area to prepare the exact snapshot of the code you want to save.</p>
  </div>
  <div class="readable-text  intended-text" id="p118"> 
   <p>It's time to <em>commit</em> your changes, so enter:</p>
  </div>
  <div class="browsable-container listing-container" id="p119"> 
   <div class="code-area-container"> 
    <pre class="code-area">git commit -m "Commit Streamlit to-do list app"</pre>
   </div>
  </div>
  <div class="readable-text " id="p120"> 
   <p>This command captures a snapshot of your code's current state, saving it in the local repository with a descriptive message about the changes.</p>
  </div>
  <div class="readable-text  intended-text" id="p121"> 
   <p>The last step here is to actually copy your code to GitHub. For this, we'll first need to make your local Git repo aware of your remote repo on GitHub.</p>
  </div>
  <div class="readable-text  intended-text" id="p122"> 
   <p>Fetch the PAT you created in section 5.1.1 as well as the URL to your remote repo, and combine them to create a PAT-embedded GitHub URL:</p>
  </div>
  <div class="browsable-container listing-container" id="p123"> 
   <div class="code-area-container"> 
    <pre class="code-area">https://&lt;Your PAT&gt;@&lt;Repo URL without the https://&gt;</pre>
   </div>
  </div>
  <div class="readable-text " id="p124"> 
   <p>For example, if your PAT is<kbd> ghp_fLbbSwjMlw3gUs7fgRux8Ha3PIlG9w3ZY3zY</kbd> (not a real one) and your repo is<kbd> https://github.com/omnom-code2/streamlit-todo-list-app.git</kbd>, your PAT-embedded URL will be:</p>
  </div>
  <div class="browsable-container listing-container" id="p125"> 
   <div class="code-area-container"> 
    <pre class="code-area">https://ghp_fLbbSwjMlw3gUs7fgRux8Ha3PIlG9w3ZY3zY@github.com/omnom-code2/streamlit-todo-list-app.git</pre>
   </div>
  </div>
  <div class="readable-text " id="p126"> 
   <p>You can now add this URL as a <em>remote</em> to your local repo by typing:</p>
  </div>
  <div class="browsable-container listing-container" id="p127"> 
   <div class="code-area-container"> 
    <pre class="code-area">git remote add origin &lt;PAT-embedded URL&gt;</pre>
   </div>
  </div>
  <div class="readable-text " id="p128"> 
   <p>or in our example:</p>
  </div>
  <div class="browsable-container listing-container" id="p129"> 
   <div class="code-area-container"> 
    <pre class="code-area">git remote add origin https://ghp_fLbbSwjMlw3gUs7fgRux8Ha3PIlG9w3ZY3zY@github.com/omnom-code2/streamlit-todo-list-app.git</pre>
   </div>
  </div>
  <div class="readable-text " id="p130"> 
   <p>This tells Git to add a remote repository with the alias "origin" to your local Git configuration, associating it with the specified PAT-embedded URL. This allows you to interact with the remote repository using that alias in future Git commands, and automatically uses the PAT for authentication.</p>
  </div>
  <div class="readable-text  intended-text" id="p131"> 
   <p>Finally, run the following command to perform the code push:</p>
  </div>
  <div class="browsable-container listing-container" id="p132"> 
   <div class="code-area-container"> 
    <pre class="code-area">git push -u origin master</pre>
   </div>
  </div>
  <div class="readable-text " id="p133"> 
   <p>This does two things:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p134">Pushes the local branch you're currently in (called "master" by default) to the remote repo you designated as "origin,” thus making your code available in the "master" branch of the remote repo.</li>
   <li class="readable-text" id="p135">Sets the default <em>upstream branch</em> (<kbd>-u</kbd> is shorthand for<kbd> -–set-upstream</kbd>) of your local repo to the "master" branch on the remote repo, so that in the future you can push your code with just<kbd> git push </kbd>without the<kbd> -u origin main</kbd>.</li>
  </ul>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p136"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p137"> 
    <p>We're assuming here that the default branch that Git creates in your repo is called "master.” Some versions of Git use the name "main" instead. If you get an error when you use "master,” try replacing it with "main.” Your command would then become: "git push -u origin main". Alternatively, you can determine the name of the branch you're on by typing "git branch" (your current branch will be highlighted), and use that.</p>
   </div>
  </div>
  <div class="readable-text " id="p138"> 
   <p>If you navigate to the repo you created on GitHub, you should now be able to see your code, as displayed in figure 5.7</p>
  </div>
  <div class="browsable-container figure-container" id="p139">  
   <img src="../Images/05__image007.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 5.7 Your repo in GitHub, after pushing your code</h5>
  </div>
  <div class="readable-text " id="p140"> 
   <p>Git can be quite a complex tool to work with. What I just described in this section is really only the bare minimum of Git you need to know to deploy your code to Streamlit Community Cloud, but ideally, you should be using it as part of your regular development workflow, committing your code each time you complete a meaningful piece of work. This requires you to be familiar with the various Git commands and options. If you'd like to develop a good mental model for working with Git, check out the tutorial in Appendix B.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p141"> 
   <h4 class=" readable-text-h4">Telling Community Cloud where to find your code</h4>
  </div>
  <div class="readable-text " id="p142"> 
   <p>We've set up our Streamlit code on GitHub. All we need now is to tell Streamlit Community Cloud where to look for it.</p>
  </div>
  <div class="readable-text  intended-text" id="p143"> 
   <p>Log in to your Community Cloud account at<kbd> streamlit.io</kbd> and click the "Create an app" button on the top right. If it asks you whether you already have an app, select the option that says you do.</p>
  </div>
  <div class="readable-text  intended-text" id="p144"> 
   <p>This should take you to the "Deploy an app" page shown in figure 5.8.</p>
  </div>
  <div class="browsable-container figure-container" id="p145">  
   <img src="../Images/05__image008.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 5.8 The app deployment screen on Streamlit Community Cloud</h5>
  </div>
  <div class="readable-text " id="p146"> 
   <p>Fill out the details of where you pushed your code, including:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p147">the GitHub repository you created</li>
   <li class="readable-text" id="p148">the branch you pushed your code to (e.g.<kbd> master</kbd> from<kbd> git push -u origin master</kbd>)</li>
   <li class="readable-text" id="p149">the path to your app (this would be<kbd> todo_list.py</kbd> since that's the file you use in the<kbd> streamlit run</kbd> command, and it's located in the root directory of your repo)</li>
  </ul>
  <div class="readable-text " id="p150"> 
   <p>In the App URL field, you can choose the address that people can use to access your app. Streamlit will suggest a default URL, but you can override it to something more meaningful. In figure 5.8, I chose <kbd>stmlit-todo-list-app-1.streamlit.app</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p151"> 
   <p>There are some advanced settings available that we'll take a look at later in the chapter, but ignore them for now.</p>
  </div>
  <div class="readable-text  intended-text" id="p152"> 
   <p>That's it! Go ahead and click the "Deploy!" button.</p>
  </div>
  <div class="readable-text  intended-text" id="p153"> 
   <p>After a minute or so, your app should be ready! Anyone with an internet connection can now visit the address you chose (<kbd>https://stmlit-todo-list-app-1.streamlit.app/ </kbd>in this case) to run your to-do list app and get their life in order. You difference-maker, you!</p>
  </div>
  <div class="readable-text" id="p154"> 
   <h2 class=" readable-text-h2">5.3 Deploying an app that uses an external service</h2>
  </div>
  <div class="readable-text " id="p155"> 
   <p>As we saw in the last section, deploying a simple app to Streamlit Community Cloud follows a logical path and is quite straightforward. Our to-do list app is "simple" in the sense that it is fairly self-contained.</p>
  </div>
  <div class="readable-text  intended-text" id="p156"> 
   <p>For one thing, other than Streamlit and Python itself, it has no other libraries or software that it depends on. For another, it does not interact with any external service or API.</p>
  </div>
  <div class="readable-text  intended-text" id="p157"> 
   <p>This is not going to be true for most practical apps you create. In the real world, you'll build software on top of software built by other people. Therefore, it's quite likely that your business logic will need third-party libraries that don't come pre-installed with Python.</p>
  </div>
  <div class="readable-text  intended-text" id="p158"> 
   <p>You will also find that, often, your app needs to reach out to services on the internet to do something useful. In fact, it's almost inevitable. At some point, your app will need access to an English dictionary to check if a word entered by a user is valid, or currency exchange rates to show a price in a different currency, or news headlines from around the globe. In these cases, you'll usually need to sign up for and connect to some kind of Application Programming Interface (API) that provides the specific service you need.</p>
  </div>
  <div class="readable-text  intended-text" id="p159"> 
   <p>In this section, we'll add some of this complexity to our existing to-do list app and see how to deploy the changes correctly.</p>
  </div>
  <div class="readable-text" id="p160"> 
   <h3 class=" readable-text-h3">5.3.1 A quote-of-the-day to inspire users</h3>
  </div>
  <div class="readable-text " id="p161"> 
   <p>Imagine a user of your to-do list app starting their day. The sky is clear, the birds are chirping, and they have a clean slate in front of them. The <em>diem</em> is theirs to <em>carpe</em>. So, humming the spring portion of Vivaldi's <em>Four Seasons</em>, they begin adding their tasks.</p>
  </div>
  <div class="readable-text  intended-text" id="p162"> 
   <p>Fast forward five minutes, and they've added the eighteenth thing they just remembered has to be done <em>today</em>. Shoulders sagging, your user is now vaguely humming the Darth Vader tune from Star Wars in their head, slowly realizing how much of an uphill climb the day is going to be.</p>
  </div>
  <div class="readable-text  intended-text" id="p163"> 
   <p>Well, we can't have that! What if our app could provide a word of comfort to the user in their time of need, a quote to motivate them? Might we not find a choice piece of wisdom to share with them—something like <em>"The secret of getting ahead is getting started"</em>—to inspire them to rise to the occasion?</p>
  </div>
  <div class="readable-text  intended-text" id="p164"> 
   <p>Of course, some of your more cynical users will just throw their coffee mugs at the screen, but hey, you can't please everyone.</p>
  </div>
  <div class="readable-text  intended-text" id="p165"> 
   <p>Regardless, let's think about what adding a quote-of-the-day to our app will entail. We could hardcode a bunch of quotes in our code, but that seems wasteful and not very scalable. Instead, we'll use a public API to obtain the quotes.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p166"> 
   <h4 class=" readable-text-h4">APIs and how to call them</h4>
  </div>
  <div class="readable-text " id="p167"> 
   <p>An API is really just a fancy term for a set of instructions that lets different pieces of software talk to each other. You might remember that in Chapter 3, we defined an "API" for the backend of our unit conversion app which was a <em>contract</em> that defined how our frontend was allowed to interact with it.</p>
  </div>
  <div class="readable-text  intended-text" id="p168"> 
   <p>In general parlance, "API" means pretty much the same thing, except that rather than the contract between two parts of the same application, we're referring to the contract that defines how any piece of software is allowed to interact with a particular external service.</p>
  </div>
  <div class="readable-text  intended-text" id="p169"> 
   <p>An API can be structured however its developer wants and the only perfect way to understand how to use it is to read the documentation. That said, there are some common <em>conventional</em> API patterns you'll encounter quite frequently.</p>
  </div>
  <div class="readable-text  intended-text" id="p170"> 
   <p>Generally speaking, you can <em>call</em> this type of API by sending an HTTP (or web) request to a URL that takes the following form:</p>
  </div>
  <div class="browsable-container listing-container" id="p171"> 
   <div class="code-area-container"> 
    <pre class="code-area">https://&lt;base address&gt;/&lt;endpoint&gt;</pre>
   </div>
  </div>
  <div class="readable-text " id="p172"> 
   <p>The base address is a common address that's part of every request sent to the API, whereas the endpoint is specific to the type of request you're making. For instance, a weather-related API might have<kbd> api.weathersite.com</kbd> as the base address, and <kbd>forecast</kbd> and <kbd>history</kbd> as the endpoints for weather predictions and past weather data respectively.</p>
  </div>
  <div class="readable-text  intended-text" id="p173"> 
   <p>You would normally customize your API request by passing key-value parameters either in the URL (in the case of a GET request) or as a request payload (in a POST request). You may also need to pass additional information, such as an API key, as HTTP headers. See the sidebar to learn more about how HTTP works.</p>
  </div>
  <div class="readable-text  intended-text" id="p174"> 
   <p>In our weather example above, we might want to pass a date as a URL parameter to the API to get the forecast for that date, so that the URL becomes:</p>
  </div>
  <div class="browsable-container listing-container" id="p175"> 
   <div class="code-area-container"> 
    <pre class="code-area">https://api.weathersite.com/forecast?date=2024-08-01</pre>
   </div>
  </div>
  <div class="readable-text " id="p176"> 
   <p>The API would then return a response, often in a format called JSON (JavaScript Object Notation) that you can parse in your code to make sense of it.</p>
  </div>
  <div class="readable-text  intended-text" id="p177"> 
   <p>In our example, the response might be something like:</p>
  </div>
  <div class="browsable-container listing-container" id="p178"> 
   <div class="code-area-container"> 
    <pre class="code-area">{
  "high_temp": 72,
  "low_temp": 60,
  "forecast_text": "Nice and sunny, a good day for the park"
}</pre>
   </div>
  </div>
  <div class="callout-container sidebar-container"> 
   <div class="readable-text" id="p179"> 
    <h5 class=" callout-container-h5 readable-text-h5">Sidebar: How HTTP requests work</h5>
   </div>
   <div class="readable-text" id="p180"> 
    <p>HTTP, which stands for HyperText Transfer Protocol, is the set of rules that define how messages are sent across the web. Think of it as the grammatical structure that computers use when they communicate over the web.</p>
   </div>
   <div class="readable-text" id="p181"> 
    <p>To communicate using HTTP (e.g. when a web browser wants to talk to a web server to retrieve a web page), an HTTP <em>client—</em>like a browser<em>—</em>sends properly formed HTTP <em>requests</em> to a web server. The server then returns an HTTP <em>response</em>, which may consist of an HTML file, or an image, or just some text, or pretty much anything else.</p>
   </div>
   <div class="readable-text" id="p182"> 
    <p>HTTP requests consist of:</p>
   </div>
   <ul> 
    <li class="readable-text" id="p183">a request line (for our purposes, let's just think of this as a URL)</li>
    <li class="readable-text" id="p184">some HTTP headers, which are key-value pairs providing additional information about how to handle the request</li>
    <li class="readable-text" id="p185">an optional body, which contains data that the client wants to send to the server</li>
   </ul>
   <div class="readable-text" id="p186"> 
    <p>There are several different types of HTTP requests, but by far the most common are GET and POST.</p>
   </div>
   <div class="readable-text" id="p187"> 
    <p>Loosely speaking, GET requests are "lightweight" requests that don't have a body. All of the information about the request is contained within the URL. Any data that needs to be sent to the server is encoded as key-value pairs and attached to the end of the URL like this: <kbd>?param1=value1&amp;param2=value2...</kbd></p>
   </div>
   <div class="readable-text" id="p188"> 
    <p>When you enter a query in a search engine, that's usually a GET request. In fact, when you type a URL in your browser's address bar and press return, you're sending a GET request to that URL.</p>
   </div>
   <div class="readable-text" id="p189"> 
    <p>POST requests <em>do</em> have a body that contains additional information. This body is often called a <em>payload</em>, and may contain things like information entered into a web form, or an uploaded file.</p>
   </div>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p190"> 
   <h4 class=" readable-text-h4">The API Ninjas Quotes API</h4>
  </div>
  <div class="readable-text " id="p191"> 
   <p>The API we'll be using is from a website called API Ninjas <kbd>(https://api-ninjas.com/)</kbd>. API Ninjas offers free APIs for a variety of services, such as real-time commodity prices, exchange rates, URL information lookups, face-detection in images, and much more.</p>
  </div>
  <div class="readable-text  intended-text" id="p192"> 
   <p>They make money off the paid version of their APIs, which you have to use if you issue more than 10,000 calls a month. Since we're just learning, we can make do with much less than that, so we'll just use the free version. Specifically, we're interested in their Quotes API, which—according to their documentation—"provides a nearly endless amount of quotes from famous people throughout history."</p>
  </div>
  <div class="readable-text  intended-text" id="p193"> 
   <p>To access it, you'll need to make an account with them. Head on over to <kbd>https://api-ninjas.com/</kbd> and sign up. As usual, you'll need to provide and verify your email and create a password.</p>
  </div>
  <div class="readable-text  intended-text" id="p194"> 
   <p>Once you're signed in, find your API key (you'll have one key that can access all their APIs), which is a set of characters that identifies you when you connect to the API. As I write this, there's a "Show API Key" button under "My Account". Make a note of the key.</p>
  </div>
  <div class="readable-text  intended-text" id="p195"> 
   <p>Check the documentation at<kbd> https://api-ninjas.com/api/quotes</kbd> to get a sense of how to connect to the Quotes API.</p>
  </div>
  <div class="readable-text  intended-text" id="p196"> 
   <p>The base URL here is <kbd>api.api-ninjas.com</kbd>, a common one shared across all of their APIs. The endpoint for the Quotes API is <kbd>/v1/quotes</kbd>, which "returns one (or more) random quotes".</p>
  </div>
  <div class="readable-text  intended-text" id="p197"> 
   <p>The documentation also mentions that you can pass a category parameter that gives you a quote from a specific listed category. There's also a limit parameter that lets you specify how many quotes you want, but that's a paid feature that we won't use. By default, the API will return one quote which is all we need.</p>
  </div>
  <div class="readable-text  intended-text" id="p198"> 
   <p>Let's say we want a quote from the category "friendship". We would send a GET request to the URL</p>
  </div>
  <div class="browsable-container listing-container" id="p199"> 
   <div class="code-area-container"> 
    <pre class="code-area">https://api.api-ninjas.com/v1/quotes?category=friendship</pre>
   </div>
  </div>
  <div class="readable-text " id="p200"> 
   <p>As an experiment, try going to this URL in your browser (which, as the sidebar on HTTP requests mentions, sends a GET request). If everything's working as intended, you should get an authentication error message:</p>
  </div>
  <div class="browsable-container listing-container" id="p201"> 
   <div class="code-area-container"> 
    <pre class="code-area">{"error": "Missing API Key."}</pre>
   </div>
  </div>
  <div class="readable-text " id="p202"> 
   <p>That's because we also need to provide the API key we noted earlier. The documentation mentions that this needs to be passed as an HTTP header by the name <kbd>X-Api-Key</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p203"> 
   <p>To do this, we'll use a Python library called <kbd>requests</kbd>.</p>
  </div>
  <div class="readable-text" id="p204"> 
   <h3 class=" readable-text-h3">5.3.2 Using the <kbd>requests</kbd> library to connect to an API</h3>
  </div>
  <div class="readable-text " id="p205"> 
   <p>As we've seen, the API we'll be using to generate inspirational quotes is a web-based one, where calling it requires our code to send and receive messages via HTTP.</p>
  </div>
  <div class="readable-text " id="p206"> 
   <p>We <em>could</em> do this with vanilla Python, but we'll instead use <kbd>requests</kbd>, which is the Python world's go-to library for HTTP communication. <kbd>requests</kbd> provides a lot of built-in functionality around handling HTTP <kbd>requests</kbd>, and has a more user-friendly set of tools than the alternatives.</p>
  </div>
  <div class="readable-text  intended-text" id="p207"> 
   <p>First, you'll need to install <kbd>requests</kbd> using the following command:</p>
  </div>
  <div class="browsable-container listing-container" id="p208"> 
   <div class="code-area-container"> 
    <pre class="code-area">pip install requests</pre>
   </div>
  </div>
  <div class="readable-text " id="p209"> 
   <p>Once that's done, verify that it's installed using<kbd> pip show requests</kbd>, which should display the version of <kbd>requests</kbd> you have, along with some other information.</p>
  </div>
  <div class="readable-text  intended-text" id="p210"> 
   <p>Sending an HTTP request using the <kbd>requests</kbd> module is quite easy: there are simple <kbd>get</kbd> and <kbd>post</kbd> methods we can use.</p>
  </div>
  <div class="readable-text  intended-text" id="p211"> 
   <p>To give this a shot, open up a Python shell (enter <kbd>python</kbd> or <kbd>python3</kbd> in the command line) and try the following:</p>
  </div>
  <div class="browsable-container listing-container" id="p212"> 
   <div class="code-area-container"> 
    <pre class="code-area">&gt;&gt;&gt; import requests
&gt;&gt;&gt; response = requests.get("https://api.api-ninjas.com/v1/quotes?category=friendship")
&gt;&gt;&gt; response
&lt;Response [400]&gt;
&gt;&gt;&gt; response.text
'{"error": "Missing API Key."}'
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p213"> 
   <p>Here we're simply using the <kbd>requests.get</kbd> method to send the same request we sent through the browser earlier. This method returns an instance of the <kbd>Response</kbd> class, which encapsulates the HTTP server's response to our request.</p>
  </div>
  <div class="readable-text  intended-text" id="p214"> 
   <p>We then access the <kbd>text</kbd> property of <kbd>response</kbd>, which gets the body of the response as a string. As you can see, the string is exactly what we got before in the browser.</p>
  </div>
  <div class="readable-text  intended-text" id="p215"> 
   <p>As we learned from the docs, we can pass our API key using the<kbd> X-Api-Key</kbd> header. The <kbd>requests.get</kbd> method accepts an argument called <kbd>headers</kbd> in the form of a regular Python dictionary, so let's get that set up:</p>
  </div>
  <div class="browsable-container listing-container" id="p216"> 
   <div class="code-area-container"> 
    <pre class="code-area">&gt;&gt;&gt; headers={"X-Api-Key": "+4VJR..."}   #A
&gt;&gt;&gt; response = requests.get("https://api.api-ninjas.com/v1/quotes?category=friendship", headers=headers)
&gt;&gt;&gt; response.text
'[{"quote": "People come in and out of our lives, and the true test of friendship is whether you can pick back up right where you left off the last time you saw each other.", "author": "Lisa See", "category": "friendship"}]'</pre>
    <div class="code-annotations-overlay-container">
     #A Replace the "+4VJR…" with the API key you noted down earlier
     <br/>
    </div>
   </div>
  </div>
  <div class="readable-text " id="p217"> 
   <p>Looks like it's working now! When we passed along the API key we obtained from API Ninjas in the<kbd> X-Api-Key</kbd> header, we got back an actual quote from the API!</p>
  </div>
  <div class="readable-text  intended-text" id="p218"> 
   <p>There's a lot more to the <kbd>requests</kbd> library than this. We'll encounter the module quite a few times in the remainder of this book, but if you'd like to learn more, check out the documentation at<kbd> https://requests.readthedocs.io/</kbd>.</p>
  </div>
  <div class="readable-text" id="p219"> 
   <h3 class=" readable-text-h3">5.3.3 Incorporating quotes in our app</h3>
  </div>
  <div class="readable-text " id="p220"> 
   <p>We now have everything we need to add a quote-of-the-day feature to our to-do list app. Since this is quite a bit different from the core functionality of managing your to-dos, it probably makes sense to create a new file, <kbd>quotes.py</kbd>, for this.</p>
  </div>
  <div class="readable-text  intended-text" id="p221"> 
   <p>Specifically, we need a function, say <kbd>generate_quote</kbd>, that takes an API key and pulls a quote from the Quotes API.</p>
  </div>
  <div class="readable-text  intended-text" id="p222"> 
   <p>Listing 5.1 shows what<kbd> quotes.py</kbd> might look like.</p>
  </div>
  <div class="browsable-container listing-container" id="p223"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 5.1 quotes.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import requests
 
API_URL = "https://api.api-ninjas.com/v1/quotes"
QUOTE_CATEGORY = "inspirational"
 
def generate_quote(api_key):
    params = {"category": QUOTE_CATEGORY}
    headers = {"X-Api-Key": api_key}
    response = requests.get(API_URL, params=params, headers=headers)
    quote_obj = response.json()[0]
    if response.status_code == requests.codes.ok:
        return f"{quote_obj['quote']} -- {quote_obj['author']}"
    return f"Just do it! -- Shia LaBeouf"
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p224"> 
   <p>We place <kbd>API_URL</kbd> and <kbd>CATEGORY</kbd> (set to "inspirational", which is one of the categories the API Ninjas documentation tells us we can use) at the top of the file as easily configurable constants so that if anyone needs to change them later, it's easy to do so without modifying the function itself.</p>
  </div>
  <div class="readable-text  intended-text" id="p225"> 
   <p>Within the function, you may notice that instead of passing the category directly in the URL using the<kbd> ?category=</kbd> notation, we're doing something different; we're creating a dictionary like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p226"> 
   <div class="code-area-container"> 
    <pre class="code-area">params = {"category": QUOTE_CATEGORY}</pre>
   </div>
  </div>
  <div class="readable-text " id="p227"> 
   <p>and passing that dictionary in the <kbd>params</kbd> argument of<kbd> requests.get</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p228"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">response = requests.get(API_URL, <b>params=params</b>, headers=headers)</pre>
   </div>
  </div>
  <div class="readable-text " id="p229"> 
   <p>The other way works just as well, but this is more readable. Besides, if we ever need to send a POST request (using<kbd> requests.post</kbd>) instead, the <kbd>params</kbd> argument works there too, while you can't use the URL method.</p>
  </div>
  <div class="readable-text  intended-text" id="p230"> 
   <p>Next, rather than using<kbd> response.text</kbd> as we did in the Python shell earlier, we're using <kbd>response.json()</kbd>. That's because, from our earlier experiment in the shell, we know that the response from the API is in JSON format:</p>
  </div>
  <div class="browsable-container listing-container" id="p231"> 
   <div class="code-area-container"> 
    <pre class="code-area">&gt;&gt;&gt; response.text
'[{"quote": "People come in and out of our lives, and the true test of friendship is whether you can pick back up right where you left off the last time you saw each other.", "author": "Lisa See", "category": "friendship"}]'</pre>
   </div>
  </div>
  <div class="readable-text " id="p232"> 
   <p>JSON is a format that lets you create arbitrary hierarchies of data using text. It's actually pretty easy for Python developers to read a blob of JSON data since the way you'd store the data in JSON is almost identical to the way you would encode that same data in a Python literal.</p>
  </div>
  <div class="readable-text  intended-text" id="p233"> 
   <p>So in the above value of <kbd>response.text</kbd>, you can probably tell that the data is encoded as a list (because of the square brackets) that contains one element: a dictionary with three keys: "quote", "author" and "category".</p>
  </div>
  <div class="readable-text  intended-text" id="p234"> 
   <p><kbd>response.text</kbd>, however, is a string. To be able to access the data easily in Python, we need to parse it into a Python object. That's what the<kbd> response.json()</kbd> method does: it parses the textual body of the response into a Python object, assuming the text is JSON.</p>
  </div>
  <div class="browsable-container listing-container" id="p235"> 
   <div class="code-area-container"> 
    <pre class="code-area">quote_obj = response.json()[0]</pre>
   </div>
  </div>
  <div class="readable-text  intended-text" id="p236"> 
   <p>Once we have the result of <kbd>response.json()</kbd>, we can treat it as a normal Python object. In this case, we know the data is a single-element list, so we use<kbd> response.json()[0]</kbd> to obtain the only element of the list, which is our three-key dictionary.</p>
  </div>
  <div class="readable-text  intended-text" id="p237"> 
   <p>The next portion checks if the request went through fine:</p>
  </div>
  <div class="browsable-container listing-container" id="p238"> 
   <div class="code-area-container"> 
    <pre class="code-area">if response.status_code == requests.codes.ok:
        return f"{quote_obj['quote']} -- {quote_obj['author']}"</pre>
   </div>
  </div>
  <div class="readable-text " id="p239"> 
   <p>Every HTTP response comes with a status code that classifies the result of the request. You may have seen these before. A status code of 200 means "OK", the code 404 means "Not found" etc.</p>
  </div>
  <div class="readable-text  intended-text" id="p240"> 
   <p>In the above snippet, the <kbd>if</kbd> statement verifies that the status code corresponds to a successful result, or in this case, that a quote was returned. <kbd>requests.codes</kbd> provides a more readable way to refer to specific HTTP status codes. <kbd>requests.codes.ok</kbd> just means the code 200.</p>
  </div>
  <div class="readable-text  intended-text" id="p241"> 
   <p>If everything's fine, we construct a string with the quote itself, as well as the author, separated by "--". We use<kbd> quote_obj['quote']</kbd> and<kbd> quote_obj['author']</kbd> to extract these from the <kbd>quote_obj</kbd> dictionary we parsed the JSON result into.</p>
  </div>
  <div class="browsable-container listing-container" id="p242"> 
   <div class="code-area-container"> 
    <pre class="code-area">return f"Just do it! -- Shia LaBeouf"
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p243"> 
   <p>Finally, if anything went wrong with the API call and the status code was <em>not </em>200, we fail gracefully by returning an evergreen motivational quote from Shia LaBeouf, one of the great philosophers of our time.</p>
  </div>
  <div class="readable-text  intended-text" id="p244"> 
   <p>Once<kbd> quotes.py</kbd> is complete, using it to create a quote to display in our main app is pretty simple. In<kbd> todo_list.py</kbd>, import the <kbd>generate_quotes</kbd> function at the top:</p>
  </div>
  <div class="browsable-container listing-container" id="p245"> 
   <div class="code-area-container"> 
    <pre class="code-area">from quotes import generate_quote</pre>
   </div>
  </div>
  <div class="readable-text " id="p246"> 
   <p>Then, to display the quote, call <kbd>generate_quote</kbd> with your API key right above where you're showing the task completion metric, and put the result in an st.info box:</p>
  </div>
  <div class="browsable-container listing-container" id="p247"> 
   <div class="code-area-container"> 
    <pre class="code-area">st.info(generate_quote("+4VJR..."))</pre>
   </div>
  </div>
  <div class="readable-text " id="p248"> 
   <p>As before, don't forget to replace the argument to <kbd>generate_quote</kbd> with your actual API key.</p>
  </div>
  <div class="readable-text  intended-text" id="p249"> 
   <p>If you<kbd> streamlit run</kbd> your app at this point, you should see your quote-of-the-day show up as in figure 5.9.</p>
  </div>
  <div class="browsable-container figure-container" id="p250">  
   <img src="../Images/05__image009.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 5.9 Quote-of-the-day in our to-do list app</h5>
  </div>
  <div class="readable-text " id="p251"> 
   <p>Great! That seems like our API call is working exactly as we intended! We can rest assured that if our user feels like giving up in the middle of organizing their day, they'll have a daily motivational quote to inspire them to stay strong.</p>
  </div>
  <div class="readable-text  intended-text" id="p252"> 
   <p>But wait! Recall that Streamlit reruns your <em>entire</em> code each time any interaction takes place. That includes making an API call through <kbd>generate_quote</kbd>. Basically, each time your user adds a task, or marks something done, or basically does anything in the app, an API call is made and a new quote is generated. Forget quote-of-the-day, we're dealing with quote-of-the-click here.</p>
  </div>
  <div class="readable-text  intended-text" id="p253"> 
   <p>Normally, you might be forgiven for wanting to chalk that up as "a feature, not a bug". But remember that we only have 10,000 free API calls available per month. If we keep pulling a quote every time the user clicks on anything, we'll burn through even that hefty quota pretty quickly.</p>
  </div>
  <div class="readable-text  intended-text" id="p254"> 
   <p>Instead, let's make use of our old friend<kbd> st.session_state</kbd> from Chapter 4. Just as we saved our task list so it doesn't get reset with every run, we'll also save our quote so we only call the API once:</p>
  </div>
  <div class="browsable-container listing-container" id="p255"> 
   <div class="code-area-container"> 
    <pre class="code-area">if "quote" not in st.session_state:
    st.session_state.quote = generate_quote("+4VJR...")    #A</pre>
    <div class="code-annotations-overlay-container">
     #A Again, replace the "+4VJR…" with the API key you noted down earlier
     <br/>
    </div>
   </div>
  </div>
  <div class="readable-text " id="p256"> 
   <p>We can now replace our earlier st.info line with this:</p>
  </div>
  <div class="browsable-container listing-container" id="p257"> 
   <div class="code-area-container"> 
    <pre class="code-area">st.info(st.session_state.quote)</pre>
   </div>
  </div>
  <div class="readable-text " id="p258"> 
   <p>If you try the app now, you'll see that the quote doesn't change when you add a task or do anything else in the app, only when you refresh the page.</p>
  </div>
  <div class="readable-text  intended-text" id="p259"> 
   <p>So are we done? Well, not quite...</p>
  </div>
  <div class="readable-text" id="p260"> 
   <h3 class=" readable-text-h3">5.3.4 Accessing your API key safely with st.secrets</h3>
  </div>
  <div class="readable-text " id="p261"> 
   <p>Our app works just fine now, but it has a glaring security flaw. We just embedded our API key directly in the code.</p>
  </div>
  <div class="readable-text  intended-text" id="p262"> 
   <p>If we now commit this code to a public GitHub repository, anyone will be able to see it and therefore find our API key! In this instance, with a free API, the stakes are pretty low, but imagine if you were paying for the API—either because you exhausted your free quota, or because you're using a different API that costs money!</p>
  </div>
  <div class="readable-text  intended-text" id="p263"> 
   <p>Anyone who accesses your GitHub repo might—unwittingly or with malicious intent—set themselves loose on your API account, costing you hundreds or maybe even thousands of dollars.</p>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p264"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p265"> 
    <p>It's worth internalizing this rule right now: never store any secret information, whether it's an API key or a password, or any other kind of credential, in your code—especially if the code is going to be publicly accessible.</p>
   </div>
  </div>
  <div class="readable-text " id="p266"> 
   <p>What's the alternative then? How do we give our app access to our API key if we can't put it in code? Generally speaking, there are a few ways to do this: you could put your key in an environment variable that's stored securely on the server where your app is running. Another option is to use a secrets management service like AWS Secrets Manager or HashiCorp Vault which allow you to retrieve confidential info securely.</p>
  </div>
  <div class="readable-text  intended-text" id="p267"> 
   <p>Fortunately, Streamlit provides an easy way to keep your secrets safe:<kbd> st.secrets</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p268"> 
   <p>Like<kbd> st.session_state</kbd>,<kbd> st.secrets</kbd> is a dictionary-like structure that you can use to store secret information as key-value pairs.</p>
  </div>
  <div class="readable-text  intended-text" id="p269"> 
   <p>To make a value available to<kbd> st.secrets</kbd>, you put it in a special file called<kbd> secrets.toml</kbd>. While you're developing locally, Streamlit will pull values from the<kbd> secrets.toml</kbd> file. When you push your code, you take care to <em>not</em> push the<kbd> secrets.toml</kbd> file.</p>
  </div>
  <div class="readable-text  intended-text" id="p270"> 
   <p>Instead, you would configure the information directly into Streamlit Community Cloud, so that your deployed app can access it in production.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p271"> 
   <h4 class=" readable-text-h4">The secrets.toml file</h4>
  </div>
  <div class="readable-text " id="p272"> 
   <p>In the root folder of your local repository (where you ran<kbd> git init</kbd> earlier), create an empty directory called<kbd> .streamlit</kbd>, and under it, an empty text file called<kbd> secrets.toml</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p273"> 
   <p>Next enter your API key in the file as shown in listing 5.2.</p>
  </div>
  <div class="browsable-container listing-container" id="p274"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 5.2 secrets.toml</h5>
   <div class="code-area-container"> 
    <pre class="code-area">[quotes_api]
api_key = "+4VJR..."</pre>
   </div>
  </div>
  <div class="readable-text " id="p275"> 
   <p>As before, use your actual API key here.</p>
  </div>
  <div class="readable-text  intended-text" id="p276"> 
   <p>The<kbd> .toml</kbd> format may be new to you. TOML stands for Tom's Obvious Minimal Language. It's a format for configuration files designed to be concise and easily readable by humans, and was originally created by a guy named—believe it or not—Tom.</p>
  </div>
  <div class="readable-text  intended-text" id="p277"> 
   <p><kbd>.toml</kbd> files mostly consist of key-value pairs and support a range of simple and complex data types, including arrays and tables. They can be divided into sections denoted by square brackets.</p>
  </div>
  <div class="readable-text  intended-text" id="p278"> 
   <p>The file shown in listing 5.2 has a single section, <kbd>quotes_api</kbd>, with a single key-value pair (with the key being <kbd>api_key</kbd>).</p>
  </div>
  <div class="readable-text  intended-text" id="p279"> 
   <p>If we were to read it in Python (outside of Streamlit, you would usually do this using the <kbd>toml</kbd> module), it would map to the following nested dictionary:</p>
  </div>
  <div class="browsable-container listing-container" id="p280"> 
   <div class="code-area-container"> 
    <pre class="code-area">{'quotes_api': {'api_key': '+4VJR...'}}</pre>
   </div>
  </div>
  <div class="readable-text " id="p281"> 
   <p>In Streamlit, this is more or less what<kbd> st.secrets</kbd> would also contain.</p>
  </div>
  <div class="readable-text  intended-text" id="p282"> 
   <p>We can therefore now replace the part of<kbd> todo_list.py</kbd> that calls <kbd>generate_quote</kbd> with this:</p>
  </div>
  <div class="browsable-container listing-container" id="p283"> 
   <div class="code-area-container"> 
    <pre class="code-area">if "quote" not in st.session_state:
    api_key = st.secrets["quotes_api"]["api_key"]
    st.session_state.quote = generate_quote(api_key)</pre>
   </div>
  </div>
  <div class="readable-text " id="p284"> 
   <p>At runtime, Streamlit will read our<kbd> secrets.toml</kbd> file to populate<kbd> st.secrets</kbd> as shown above, and we can use<kbd> st.secrets["quotes_api"]["api_key"]</kbd> to refer to the API key. Try it out—you'll see that your app is still able to fetch a quote from the API.</p>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p285"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p286"> 
    <p>Technically, the .streamlit directory should be located in the directory that you run the command "streamlit run &lt;file_path&gt;" from. For instance, if you're currently in a directory called "apps", your actual code is located in a folder called "todo_list_app", and the command you use to run your app is "streamlit run todo_list_app/todo_list.py", then the .streamlit folder should located in the "apps" folder, not in the "todo_list_app" folder. When you deploy your code to Streamlit Community Cloud, "streamlit run" will effectively be run from your repo root, which is why I suggested placing .streamlit there. While developing locally, if your local repo root is different from the folder you usually execute "streamlit run" from, you'll probably need to "cd" into the repo root to get this to work.</p>
   </div>
  </div>
  <div class="readable-text " id="p287"> 
   <p>At the end of this, your<kbd> todo_list.py</kbd> file should be as shown in listing 5.3</p>
  </div>
  <div class="browsable-container listing-container" id="p288"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 5.3 The final state of todo_list.py</h5>
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">import streamlit as st
from task import Task
<b>from quotes import generate_quote</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
if "task_list" not in st.session_state:
    st.session_state.task_list = []
task_list = st.session_state.task_list
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
<b>if "quote" not in st.session_state:</b>
<b>    api_key = st.secrets["quotes_api"]["api_key"]</b>
<b>    st.session_state.quote = generate_quote(api_key)</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
def add_task(task_name: str):
    task_list.append(Task(task_name))
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
def delete_task(idx: int):
    del task_list[idx]
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
def mark_done(task: Task):
    task.is_done = True
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
def mark_not_done(task: Task):
    task.is_done = False
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
with st.sidebar:
    task = st.text_input("Enter a task")
    if st.button("Add task", type="primary"):
        add_task(task)
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
<b>st.info(st.session_state.quote)</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
total_tasks = len(task_list)
completed_tasks = sum(1 for task in task_list if task.is_done)
metric_display = f"{completed_tasks}/{total_tasks} done"
st.metric("Task completion", metric_display, delta=None)
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
st.header("Today's to-dos:", divider="gray")
for idx, task in enumerate(task_list):
    task_col, delete_col = st.columns([0.8, 0.2])
    label = f"~~{task.name}~~" if task.is_done else task.name
    checked = task_col.checkbox(label, task.is_done, key=f"task_{idx}")
    if checked and not task.is_done:
        mark_done(task)
        st.rerun()
    elif not checked and task.is_done:
        mark_not_done(task)
        st.rerun()
    if delete_col.button("Delete", key=f"delete_{idx}"):
        delete_task(idx)
        st.rerun()</pre>
   </div>
  </div>
  <div class="readable-text" id="p289"> 
   <h2 class=" readable-text-h2">5.4 Deploying our changes to Streamlit Community Cloud</h2>
  </div>
  <div class="readable-text " id="p290"> 
   <p>Generally speaking, making changes to an already-deployed Streamlit app is simple. All you need to do is to commit your changes and use<kbd> git push</kbd> to push them to your GitHub repo, and Streamlit Community Cloud will automatically pick them up.</p>
  </div>
  <div class="readable-text  intended-text" id="p291"> 
   <p>However, given the most recent changes we've made to our app, in our case this process will be slightly more complicated. There are three complicating factors:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p292">We're now using an additional third-party library, requests, and we have to make sure the right version is installed in production</li>
   <li class="readable-text" id="p293">We need to make sure we don't ever push<kbd> secrets.toml</kbd> to GitHub, even by accident</li>
   <li class="readable-text" id="p294">Since we're not going to store our API key in the GitHub repo, we need to configure it in Community Cloud directly</li>
  </ul>
  <div class="readable-text" id="p295"> 
   <h3 class=" readable-text-h3">5.4.1 Using a <kbd>requirements.txt</kbd> file to manage Python dependencies</h3>
  </div>
  <div class="readable-text " id="p296"> 
   <p>One of the things that can trip you up when you first start to publish your apps to the world is that you now have two <em>environments</em> to manage: your development environment (often simply called <em>dev</em>), which is in your laptop or whatever computer you're using to code your app, and your production environment (called <em>prod</em>), which is in Streamlit Community Cloud.</p>
  </div>
  <div class="readable-text  intended-text" id="p297"> 
   <p>To make sure the app that you've coded in dev works as expected in prod, you have to make sure that two two environments are configured in exactly the same way, or at least that <em>any differences between dev and prod are not relevant to your app</em>.</p>
  </div>
  <div class="readable-text  intended-text" id="p298"> 
   <p>Obviously, this means that your Python code that runs in prod should be exactly the same as what's running on your computer in dev, but that's not enough; your Python code may rely on software you didn't write yourself, such as the <kbd>requests</kbd> module in the case of our to-do list app, or indeed, Streamlit itself—this means that we also need to make sure that these <em>dependencies </em>of your app are the same in prod and dev, or at least that they don't differ in any ways that matter to your app's functionality.</p>
  </div>
  <div class="readable-text  intended-text" id="p299"> 
   <p>For instance, if you use a feature of the requests library that was introduced in requests version 2.1.1 but the version of <kbd>requests</kbd> you have installed in prod is version 2.0.5, your app will run into errors in prod. To be sure your code won't break, you need to install <kbd>requests</kbd> version 2.1.1 or higher in prod. Technically, to be really sure your code won't break, you need to install exactly the version 2.1.1, as there's always a small possibility that the feature you used may be deprecated or removed in a future version.</p>
  </div>
  <div class="readable-text  intended-text" id="p300"> 
   <p>In the Python world, we conventionally use a file called<kbd> requirements.txt</kbd> to prevent these kinds of discrepancies. The premise of<kbd> requirements.txt</kbd> is simple: each line in it represents a Python module and a string that specifies a version or a range of versions of that module that is compatible with your code.</p>
  </div>
  <div class="readable-text  intended-text" id="p301"> 
   <p>When fed into the<kbd> pip install</kbd> command (as<kbd> pip install -r requirements.txt</kbd>), <kbd>pip</kbd> will automatically go through the file and install the right versions of every module in it.</p>
  </div>
  <div class="readable-text  intended-text" id="p302"> 
   <p>Streamlit Community Cloud knows what to do with a<kbd> requirements.txt</kbd> file, so if you add one to your GitHub repo, it will automatically install the libraries you need to make your app work.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p303"> 
   <h4 class=" readable-text-h4">Creating a <kbd>requirements.txt</kbd> file</h4>
  </div>
  <div class="readable-text " id="p304"> 
   <p>Our app only has two outside dependencies—<kbd>streamlit</kbd> and <kbd>requests</kbd> (you can determine this by examining the import statements in all of your<kbd> .py</kbd> files). The contents of our <kbd>requirements.txt</kbd> file can therefore be quite simple as shown in listing 5.4</p>
  </div>
  <div class="browsable-container listing-container" id="p305"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 5.4 A simple requirements.txt</h5>
   <div class="code-area-container"> 
    <pre class="code-area">requests
streamlit
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p306"> 
   <p>While this is a valid <kbd>requirements.txt</kbd>, it doesn't say anything about what versions we want installed.</p>
  </div>
  <div class="readable-text  intended-text" id="p307"> 
   <p>One safe way to handle this would be to determine the versions of these libraries we have installed in dev and specify those exact versions in <kbd>requirements.txt</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p308"> 
   <p>There are a couple of ways to do this:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p309">you could type <kbd>pip show streamlit</kbd> and <kbd>pip show requests </kbd>to see (among other information) the versions of each library you have.</li>
   <li class="readable-text" id="p310">you could also enter the command <kbd>pip freeze &gt; requirements.txt </kbd>to automatically create the <kbd>requirements.txt</kbd> file from the modules you have installed in dev—this, however, will include <em>every</em> module you have installed, regardless of whether you're importing them in your code. If you go this way, it might make sense to delete all the lines from the file except those that correspond to <kbd>streamlit</kbd> or <kbd>requests</kbd>.</li>
  </ul>
  <div class="readable-text " id="p311"> 
   <p>Either way, once you've determined the right versions using<kbd> pip show</kbd> or already created the file using<kbd> pip freeze</kbd>, your<kbd> requirements.txt</kbd> file should look something like listing 5.5.</p>
  </div>
  <div class="browsable-container listing-container" id="p312"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 5.5 A strict requirements.txt</h5>
   <div class="code-area-container"> 
    <pre class="code-area">requests==2.31.0
streamlit==1.34.0
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p313"> 
   <p>We don't <em>have</em> to be this strict with the versions. We could instead allow any version of these libraries that are the same or higher than the ones we have installed. That way, we could allow our app to benefit from any under-the-hood improvements these libraries may make in the future, while still being <em>reasonably</em> sure it won't break. In this case, our file may look like listing 5.6.</p>
  </div>
  <div class="browsable-container listing-container" id="p314"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 5.6 A this-version-or-higher requirements.txt</h5>
   <div class="code-area-container"> 
    <pre class="code-area">requests&gt;=2.31.0
streamlit&gt;=1.34.0
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p315"> 
   <p>Once you've got your file ready, save it to the root of your local Git repo.</p>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p316"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p317"> 
    <p>You may notice that your app works fine in production even if you <em>don't</em> create a requirements.txt file. That's because Streamlit Community Cloud pre-installs the two libraries we're using here, i.e. streamlit and requests. Obviously the streamlit library is required for any app to function. Since the streamlit module actually depends on the requests module internally, requests is pre-installed too! Still, you'll undoubtedly encounter situations in the future where you need libraries other than those two, and you'll need a requirements.txt then. Even in the current case, you'll need this file to restrict the exact versions of these modules that are installed in prod.</p>
   </div>
  </div>
  <div class="readable-text" id="p318"> 
   <h3 class=" readable-text-h3">5.4.2 Using .gitignore to protect secrets.toml</h3>
  </div>
  <div class="readable-text " id="p319"> 
   <p>You may be wondering about how using a<kbd> secrets.toml</kbd> file actually protects your API key from prying eyes—the key may not technically be in your Python code any more but it's still stored in a file next to your actual code. Well, the point is to keep<kbd> secrets.toml</kbd> around locally but to never commit it to our Git repo.</p>
  </div>
  <div class="readable-text  intended-text" id="p320"> 
   <p>To make certain that we don't accidentally commit the <kbd>secrets.toml</kbd> file, we'll use a file called <kbd>.gitignore</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p321"> 
   <p><kbd>.gitignore</kbd> is a simple text file located in the root of your repository that tells Git to ignore certain files and never commit them.</p>
  </div>
  <div class="readable-text  intended-text" id="p322"> 
   <p>If the file doesn't already exist, create an empty text file called<kbd> .gitignore</kbd> in the repo root. Then append the path to your<kbd> .streamlit</kbd> folder. Since the<kbd> .streamlit</kbd> folder should also be in the repo root, you would simply add the following to<kbd> .gitignore</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p323"> 
   <div class="code-area-container"> 
    <pre class="code-area">.streamlit/</pre>
   </div>
  </div>
  <div class="readable-text " id="p324"> 
   <p>If you now do a<kbd> git add</kbd> or<kbd> git commit</kbd>, your<kbd> secrets.toml </kbd>file (and indeed, any file in the<kbd> .streamlit</kbd> directory) won't be committed.</p>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p325"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p326"> 
    <p>Git may already be tracking your .streamlit folder from before you added it to .gitignore. In this case, to remove it from Git's index, you may have to enter this command:</p>
   </div>
   <div class="readable-text" id="p327"> 
    <p>git rm -r --cached .streamlit/</p>
   </div>
  </div>
  <div class="readable-text " id="p328"> 
   <p>At this point, your directory structure should look like the following:</p>
  </div>
  <div class="browsable-container listing-container" id="p329"> 
   <div class="code-area-container"> 
    <pre class="code-area">Root of your Git repo
├── .streamlit (folder)
│   └── secrets.toml
├── .gitignore
├── requirements.txt
├── quotes.py
├── task.py
└── todo_list.py</pre>
   </div>
  </div>
  <div class="readable-text " id="p330"> 
   <p>Add your changes to Git, commit them with a message, and then push them to GitHub. You could use the following commands:</p>
  </div>
  <div class="browsable-container listing-container" id="p331"> 
   <div class="code-area-container"> 
    <pre class="code-area">git add .
git commit -m "Add quote-of-the-day functionality"
git push
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p332"> 
   <p>Note that you can use the simple<kbd> git push</kbd> command above since you set the upstream of your branch to your remote repo earlier using<kbd> git push -u</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p333"> 
   <p>Your changes should now be reflected in your production Streamlit app. Or should it? Navigate to your app's public URL now to see what's shown in figure 5.10.</p>
  </div>
  <div class="browsable-container figure-container" id="p334">  
   <img src="../Images/05__image010.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 5.10 Our app throws an error since it's unable to access an API key</h5>
  </div>
  <div class="readable-text " id="p335"> 
   <p>Looks like there's a final bit of configuration we have to do before your app works okay.</p>
  </div>
  <div class="readable-text" id="p336"> 
   <h3 class=" readable-text-h3">5.4.3 Configuring secrets in Community Cloud</h3>
  </div>
  <div class="readable-text " id="p337"> 
   <p>We've taken pains to keep our API key secret but our app still needs it while it's running in prod. To enable this, we need to configure it in Streamlit Community Cloud where we've deployed our app.</p>
  </div>
  <div class="readable-text  intended-text" id="p338"> 
   <p>We can do this in the <em>App settings</em> screen on Community Cloud. You can access this screen in two ways:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p339">When you're on your deployed app's public URL, click "Manage app" on the bottom right (you can see it in figure 5.11), click the three vertical dots and then "Settings"</li>
   <li class="readable-text" id="p340">When logged in to Community Cloud on streamlit.io, click the three vertical dots next to your app in the list of apps, and click "Settings" from there.</li>
  </ul>
  <div class="readable-text " id="p341"> 
   <p>Either way, once you have your App settings page open, click "Secrets" on the side panel to get to the screen shown in figure 5.11.</p>
  </div>
  <div class="browsable-container figure-container" id="p342">  
   <img src="../Images/05__image011.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 5.11 The secrets configuration screen on Streamlit Community Cloud</h5>
  </div>
  <div class="readable-text " id="p343"> 
   <p>In the textbox under "Secrets", simply copy and paste whatever you have in your <kbd>secrets.toml</kbd> file on your dev machine, and click "Save".</p>
  </div>
  <div class="readable-text  intended-text" id="p344"> 
   <p>With that, you're all done! Go to your app's public URL again. It should now be fully functional, as seen in figure 5.12.</p>
  </div>
  <div class="browsable-container figure-container" id="p345">  
   <img src="../Images/05__image012.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 5.12 Your fully-functional app, deployed to production</h5>
  </div>
  <div class="readable-text " id="p346"> 
   <p>By now, you should be equipped to build and share useful Streamlit apps with a public audience. In the next chapter, we'll explore a more advanced app focused on working with data.</p>
  </div>
  <div class="readable-text" id="p347"> 
   <h2 class=" readable-text-h2">5.5 Summary</h2>
  </div>
  <ul> 
   <li class="readable-text" id="p348">Deployment is the process of hosting and setting up your app so your intended users can access it.</li>
   <li class="readable-text" id="p349">There are multiple ways to deploy an app—you could simply run a server over your local network, set up a dedicated server, or use a cloud provider.</li>
   <li class="readable-text" id="p350">You can deploy an unlimited number of apps to Streamlit Community Cloud for free, subject to some resource usage limits.</li>
   <li class="readable-text" id="p351">Deploying to Community Cloud involves creating a GitHub account, pushing your local code to a remote GitHub repo, and telling Community Cloud where to find your code.</li>
   <li class="readable-text" id="p352">You can connect to external services through the HTTP protocol using a library called <kbd>requests</kbd>.</li>
   <li class="readable-text" id="p353">In conjunction with a<kbd> secrets.toml</kbd> file located within a<kbd> .streamlit</kbd> folder, <kbd>st.secrets</kbd> can be used to keep your credentials safe.</li>
   <li class="readable-text" id="p354">Make sure to never commit your<kbd> secrets.toml</kbd> file—prevent accidents by adding it to<kbd> .gitignore</kbd>. Instead, use the App settings page on Streamlit Community Cloud to hold in production the information you store in<kbd> secrets.toml</kbd> locally.</li>
   <li class="readable-text" id="p355">You can use a<kbd> requirements.txt</kbd> file to specify the versions of various Python libraries your app depends on.</li>
   <li class="readable-text" id="p356">Deploying any changes you make to an already-deployed app on Community Cloud is as simple as pushing the changes to your remote GitHub repo.</li>
  </ul>
</body>
</html>