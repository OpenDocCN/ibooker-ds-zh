["```py\n$ cp solution1_kmers_imperative.py lcsm.py\n$ ./lcsm.py -h\nusage: lcsm.py [-h] FILE\n\nLongest Common Substring\n\npositional arguments:\n  FILE        Input FASTA\n\noptional arguments:\n  -h, --help  show this help message and exit\n```", "```py\n$ cat tests/inputs/1.fa\n>Rosalind_1\nGATTACA\n>Rosalind_2\nTAGACCA\n>Rosalind_3\nATACA\n```", "```py\n$ ./lcsm.py tests/inputs/1.fa\nCA\n```", "```py\n$ time ./lcsm.py tests/inputs/2.fa\nGCCTTTTGATTTTAACGTTTATCGGGTGTAGTAAGATTGCGCGCTAATTCCAATAAACGTATGGAGGACATTCCCCGT\n\nreal\t0m39.244s\nuser\t0m33.708s\nsys\t0m6.202s\n```", "```py\n$ ./lcsm.py tests/inputs/none.fa\nNo common subsequence.\n```", "```py\n$ new.py -fp 'Longest Common Substring' lcsm.py\nDone, see new script \"lcsm.py\".\n```", "```py\nclass Args(NamedTuple): ![1](assets/1.png)\n    \"\"\" Command-line arguments \"\"\"\n    file: TextIO\n\ndef get_args() -> Args:\n    \"\"\" Get command-line arguments \"\"\"\n\n    parser = argparse.ArgumentParser(\n        description='Longest Common Substring',\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n\n    parser.add_argument('file', ![2](assets/2.png)\n                        help='Input FASTA',\n                        metavar='FILE',\n                        type=argparse.FileType('rt'))\n\n    args = parser.parse_args()\n\n    return Args(args.file) ![3](assets/3.png)\n```", "```py\ndef main() -> None:\n    args = get_args()\n    print(args.file.name)\n```", "```py\n$ ./lcsm.py tests/inputs/1.fa\ntests/inputs/1.fa\n```", "```py\n>>> from Bio import SeqIO\n>>> fh = open('./tests/inputs/1.fa')\n>>> recs = SeqIO.parse(fh, 'fasta')\n>>> type(recs)\n<class 'Bio.SeqIO.FastaIO.FastaIterator'>\n```", "```py\n>>> rec = next(recs)\n>>> type(rec)\n<class 'Bio.SeqRecord.SeqRecord'>\n```", "```py\n>>> rec\nSeqRecord(seq=Seq('GATTACA'),\n          id='Rosalind_1',\n          name='Rosalind_1',\n          description='Rosalind_1',\n          dbxrefs=[])\n```", "```py\n>>> str(rec.seq)\n'GATTACA'\n```", "```py\n>>> fh = open('./tests/inputs/1.fa') ![1](assets/1.png)\n>>> seqs = [str(rec.seq) for rec in SeqIO.parse(fh, 'fasta')] ![2](assets/2.png)\n>>> seqs\n['GATTACA', 'TAGACCA', 'ATACA']\n```", "```py\n>>> fh = open('./tests/inputs/1.fa')\n>>> seqs = list(map(lambda rec: str(rec.seq), SeqIO.parse(fh, 'fasta')))\n>>> seqs\n['GATTACA', 'TAGACCA', 'ATACA']\n```", "```py\n>>> [len(seq) for seq in seqs]\n[7, 7, 5]\n```", "```py\n>>> list(map(len, seqs))\n[7, 7, 5]\n```", "```py\n>>> min(map(len, seqs))\n5\n>>> max(map(len, seqs))\n7\n```", "```py\n>>> shortest = min(map(len, seqs))\n>>> shortest\n5\n```", "```py\ndef find_kmers(seq: str, k: int) -> List[str]:\n    \"\"\" Find k-mers in string \"\"\"\n\n    n = len(seq) - k + 1\n    return [] if n < 1 else [seq[i:i + k] for i in range(n)]\n\ndef test_find_kmers() -> None:\n    \"\"\" Test find_kmers \"\"\"\n\n    assert find_kmers('', 1) == []\n    assert find_kmers('ACTG', 1) == ['A', 'C', 'T', 'G']\n    assert find_kmers('ACTG', 2) == ['AC', 'CT', 'TG']\n    assert find_kmers('ACTG', 3) == ['ACT', 'CTG']\n    assert find_kmers('ACTG', 4) == ['ACTG']\n    assert find_kmers('ACTG', 5) == []\n```", "```py\n>>> list(range(shortest, 0))\n[]\n```", "```py\n>>> list(range(shortest, 0, -1))\n[5, 4, 3, 2, 1]\n```", "```py\n>>> list(reversed(range(1, shortest + 1)))\n[5, 4, 3, 2, 1]\n```", "```py\n>>> from lcsm import find_kmers\n>>> from pprint import pprint\n>>> for k in range(shortest, 0, -1):\n...     print(f'==> {k} <==')\n...     pprint([set(find_kmers(s, k)) for s in seqs])\n...\n==> 5 <==\n[{'TTACA', 'GATTA', 'ATTAC'}, {'TAGAC', 'AGACC', 'GACCA'}, {'ATACA'}]\n==> 4 <==\n[{'ATTA', 'TTAC', 'TACA', 'GATT'},\n {'GACC', 'AGAC', 'TAGA', 'ACCA'},\n {'TACA', 'ATAC'}]\n==> 3 <==\n[{'ACA', 'TAC', 'GAT', 'ATT', 'TTA'},\n {'AGA', 'TAG', 'CCA', 'ACC', 'GAC'},\n {'ACA', 'ATA', 'TAC'}]\n==> 2 <==\n[{'AC', 'AT', 'CA', 'TA', 'TT', 'GA'},\n {'AC', 'CA', 'CC', 'TA', 'AG', 'GA'},\n {'AC', 'AT', 'CA', 'TA'}]\n==> 1 <==\n[{'G', 'C', 'T', 'A'}, {'G', 'C', 'T', 'A'}, {'C', 'T', 'A'}]\n```", "```py\n>>> fh = open('./tests/inputs/1.fa')\n>>> seqs = [str(rec.seq) for rec in SeqIO.parse(fh, 'fasta')]\n>>> shortest = min(map(len, seqs))\n>>> kmers = [set(find_kmers(seq, shortest)) for seq in seqs]\n>>> kmers\n[{'TTACA', 'GATTA', 'ATTAC'}, {'TAGAC', 'AGACC', 'GACCA'}, {'ATACA'}]\n```", "```py\n>>> from collections import Counter\n>>> counts = Counter()\n```", "```py\n>>> for group in kmers:\n...     counts.update(group)\n...\n>>> pprint(counts)\nCounter({'TTACA': 1,\n         'GATTA': 1,\n         'ATTAC': 1,\n         'TAGAC': 1,\n         'AGACC': 1,\n         'GACCA': 1,\n         'ATACA': 1})\n```", "```py\n>>> from itertools import chain\n>>> list(chain.from_iterable(kmers))\n['TTACA', 'GATTA', 'ATTAC', 'TAGAC', 'AGACC', 'GACCA', 'ATACA']\n```", "```py\n>>> counts = Counter(chain.from_iterable(kmers))\n>>> pprint(counts)\nCounter({'TTACA': 1,\n         'GATTA': 1,\n         'ATTAC': 1,\n         'TAGAC': 1,\n         'AGACC': 1,\n         'GACCA': 1,\n         'ATACA': 1})\n```", "```py\n>>> n = len(seqs)\n>>> candidates = []\n>>> for kmer, count in counts.items():\n...     if count == n:\n...         candidates.append(kmer)\n...\n>>> candidates\n[]\n```", "```py\n>>> k = 2\n>>> kmers = [set(find_kmers(seq, k)) for seq in seqs]\n>>> counts = Counter(chain.from_iterable(kmers))\n>>> pprint(counts)\nCounter({'CA': 3,\n         'AC': 3,\n         'TA': 3,\n         'GA': 2,\n         'AT': 2,\n         'TT': 1,\n         'AG': 1,\n         'CC': 1})\n```", "```py\n>>> candidates = []\n>>> for kmer, count in counts.items():\n...     if count == n:\n...         candidates.append(kmer)\n...\n>>> candidates\n['CA', 'AC', 'TA']\n```", "```py\n>>> import random\n>>> random.choice(candidates)\n'AC'\n```", "```py\ndef common_kmers(seqs: List[str], k: int) -> List[str]:\n    \"\"\" Find k-mers common to all sequences \"\"\"\n\n    kmers = [set(find_kmers(seq, k)) for seq in seqs]\n    counts = Counter(chain.from_iterable(kmers))\n    n = len(seqs) ![1](assets/1.png)\n    return [kmer for kmer, freq in counts.items() if freq == n] ![2](assets/2.png)\n```", "```py\nimport random\nimport sys\n\ndef main() -> None:\n    args = get_args()\n    seqs = [str(rec.seq) for rec in SeqIO.parse(args.file, 'fasta')] ![1](assets/1.png)\n    shortest = min(map(len, seqs)) ![2](assets/2.png)\n\n    for k in range(shortest, 0, -1): ![3](assets/3.png)\n        if kmers := common_kmers(seqs, k): ![4](assets/4.png)\n            print(random.choice(kmers)) ![5](assets/5.png)\n            sys.exit(0) ![6](assets/6.png)\n\n    print('No common subsequence.') ![7](assets/7.png)\n```", "```py\nkmers = common_kmers(seqs, k)\nif kmers:\n    print(random.choice(kmers))\n```", "```py\n$ ./binsearch.py -h\nusage: binsearch.py [-h] -n int -m int\n\nBinary Search\n\noptional arguments:\n  -h, --help         show this help message and exit\n  -n int, --num int  The number to guess (default: None)\n  -m int, --max int  The maximum range (default: None)\n```", "```py\ndef main() -> None:\n    args = get_args()\n    nums = list(range(args.maximum + 1))\n    pos = binary_search(args.num, nums, 0, args.maximum)\n    print(f'Found {args.num}!' if pos > 0 else f'{args.num} not present.')\n\ndef binary_search(x: int, xs: List[int], low: int, high: int) -> int:\n    print(f'{low:4} {high:4}', file=sys.stderr)\n\n    if high >= low: ![1](assets/1.png)\n        mid = (high + low) // 2 ![2](assets/2.png)\n\n        if xs[mid] == x: ![3](assets/3.png)\n            return mid\n\n        if xs[mid] > x: ![4](assets/4.png)\n            return binary_search(x, xs, low, mid - 1) ![5](assets/5.png)\n\n        return binary_search(x, xs, mid + 1, high) ![6](assets/6.png)\n\n    return -1 ![7](assets/7.png)\n```", "```py\n$ ./binsearch.py -n 453 -m 1000\n   0 1000\n   0  499\n 250  499\n 375  499\n 438  499\n 438  467\n 453  467\n 453  459\n 453  455\n 453  453\nFound 453!\n```", "```py\n$ ./binsearch.py -n 453 -m 100\n   0  100\n  51  100\n  76  100\n  89  100\n  95  100\n  98  100\n 100  100\n 101  100\n453 not present.\n```", "```py\n$ cat tests/inputs/none.fa\n>Rosalind_1\nGGGGGGG\n>Rosalind_2\nAAAAAAAA\n>Rosalind_3\nCCCC\n>Rosalind_4\nTTTTTTTT\n```", "```py\ndef main() -> None:\n    args = get_args()\n    seqs = [str(rec.seq) for rec in SeqIO.parse(args.file, 'fasta')] ![1](assets/1.png)\n    shortest = min(map(len, seqs)) ![2](assets/2.png)\n    common = partial(common_kmers, seqs) ![3](assets/3.png)\n    start = binary_search(common, 1, shortest) ![4](assets/4.png)\n\n    if start >= 0: ![5](assets/5.png)\n        candidates = [] ![6](assets/6.png)\n        for k in range(start, shortest + 1): ![7](assets/7.png)\n            if kmers := common(k): ![8](assets/8.png)\n                candidates.append(random.choice(kmers)) ![9](assets/9.png)\n            else:\n                break ![10](assets/10.png)\n\n        print(max(candidates, key=len)) ![11](assets/11.png)\n    else:\n        print('No common subsequence.') ![12](assets/12.png)\n```", "```py\n>>> max([4, 2, 8, 1])\n8\n```", "```py\n>>> seqs = ['A', 'CC', 'GGGG', 'TTT']\n>>> list(map(len, seqs))\n[1, 2, 4, 3]\n```", "```py\n>>> max(seqs, key=len)\n'GGGG'\n```", "```py\ndef binary_search(f: Callable, low: int, high: int) -> int: ![1](assets/1.png)\n    \"\"\" Binary search \"\"\"\n\n    hi, lo = f(high), f(low) ![2](assets/2.png)\n    mid = (high + low) // 2 ![3](assets/3.png)\n\n    if hi and lo: ![4](assets/4.png)\n        return high\n\n    if lo and not hi: ![5](assets/5.png)\n        return binary_search(f, low, mid)\n\n    if hi and not lo: ![6](assets/6.png)\n        return binary_search(f, mid, high)\n\n    return -1 ![7](assets/7.png)\n```", "```py\ndef test_binary_search() -> None:\n    \"\"\" Test binary_search \"\"\"\n\n    seqs1 = ['GATTACA', 'TAGACCA', 'ATACA'] ![1](assets/1.png)\n    f1 = partial(common_kmers, seqs1) ![2](assets/2.png)\n    assert binary_search(f1, 1, 5) == 2 ![3](assets/3.png)\n\n    seqs2 = ['GATTACTA', 'TAGACTCA', 'ATACTA'] ![4](assets/4.png)\n    f2 = partial(common_kmers, seqs2)\n    assert binary_search(f2, 1, 6) == 3 ![5](assets/5.png)\n```", "```py\n$ ./solution2_binary_search.py tests/inputs/none.fa\nNo common subsequence.\n```", "```py\n$ hyperfine -L prg ./solution1_kmers_functional.py,./solution2_binary_search.py\\\n  '{prg} tests/inputs/2.fa'\nBenchmark #1: ./solution1_kmers_functional.py tests/inputs/2.fa\n  Time (mean ± σ):     40.686 s ±  0.443 s    [User: 35.208 s, System: 6.042 s]\n  Range (min … max):   40.165 s … 41.349 s    10 runs\n\nBenchmark #2: ./solution2_binary_search.py tests/inputs/2.fa\n  Time (mean ± σ):      1.441 s ±  0.037 s    [User: 1.903 s, System: 0.255 s]\n  Range (min … max):    1.378 s …  1.492 s    10 runs\n\nSummary\n  './solution2_binary_search.py tests/inputs/2.fa' ran\n   28.24 ± 0.79 times faster than './solution1_kmers_functional.py\n   tests/inputs/2.fa'\n```"]