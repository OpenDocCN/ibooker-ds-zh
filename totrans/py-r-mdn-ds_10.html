<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 6. Using the Two Languages Synergistically"><div class="chapter" id="ch07">
<h1><span class="label">Chapter 6. </span>Using the Two Languages Synergistically</h1>


<p class="byline">Rick J. Scavetta</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45127449041224">
<h5>A note for Early Release readers</h5>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>
</div></aside>

<p>Interoperability, the ability for different programming languages to work together, is a cornerstone of computing. Ideally objects can be shared directly between the two languages. As you can imagine, this can be problematic for a variety of reasons, like memory usage and incompatible data storage structures to name just two. Although there have been several attempts to implement this smoothly between Python and R, it’s only been in the past couple of years that a reasonably functional kit had come to fruition. I’ll discuss this in <a data-type="xref" href="#interOp">“Interoperability”</a>. But it’s useful to first return to the basics. This will not only give context to appreciate smooth interoperability later on, but you a basic solution may already meet your needs. Nonetheless, if you want to get started with interoperability, you can skip the next section.</p>






<section data-type="sect1" data-pdf-bookmark="Faux-operability"><div class="sect1" id="fauxOp">
<h1>Faux-operability</h1>

<p>The most basic type of interoperability, which we’ll call cross-talk, is more of a faux-operability. Here, we execute pre-defined scripts across languages, passing information between them using files as intermediaries. Imagine the following situation, which I’ve diagramed in <a data-type="xref" href="#crosstalk">Figure 6-1</a>.</p>

<figure><div id="crosstalk" class="figure">
<img src="Images/prds_0601.png" alt="" width="5261" height="3041"/>
<h6><span class="label">Figure 6-1. </span>An example of cross-talk to facilate interoperability.</h6>
</div></figure>

<p>In R, after performing some necessary work on an object, e.g. <code>PlantGrowth</code>, we execute:</p>

<pre data-type="programlisting" data-code-language="r"><code class="c1"># (Previous interesting and complicated steps omitted)</code>

<code class="c1"># Write a data.frame of interest to a file ...</code>
<code class="n">rio</code><code class="o">::</code><code class="nf">export</code><code class="p">(</code><code class="n">PlantGrowth</code><code class="p">,</code> <code class="s">"pg.csv"</code><code class="p">)</code>

<code class="c1"># ... which is then processed by a Python script</code>
<code class="nf">system</code><code class="p">(</code><code class="s">'~/.venv/bin/python3 myScript_2.py &lt; "pg.csv"'</code><code class="p">)</code></pre>

<p>The <code>system()</code> function executes a system command, provided as a character argument. The command is made up of four parts.</p>

<p>First, <code>~/.venv/bin/python3</code> is the location of the Python executable within our virtual environment, assuming that you’ve created one. We could have also included this in the scripts <em>shebang</em> first line as <code>#!/.venv/bin/env python3</code>. This ensures that the script is executed in the environment in which it was created. See <a data-type="xref" href="ch03.xhtml#pyvenv">“Virtual environments”</a> if this sounds strange to you.</p>

<p>Second, <code>myScript_2.py</code> is the name of the Python file that contains the commands we want to execute.</p>

<p>Third, <code>&lt;</code> allow us to redirect <code>stdin</code> from the rhs to the file on the lhs<sup><a data-type="noteref" id="idm45127448988616-marker" href="ch06.xhtml#idm45127448988616">1</a></sup>.</p>

<p>Fourth, <code>"pg.csv"</code> is the <code>stdin</code>. You may recall that there are three standard <em>channels</em>, or <em>streams</em>, for command line functions. <code>stdin</code> for the <em>standard input</em>, <code>stdout</code> for the <em>standard output</em> and <code>stderr</code> for the <code>standard error</code>. Here, <code>stdin</code> is hardcoded. It’s a character string which corresponds to a file: <code>"pg.csv"</code>, which was exported in the previous command. Hard-coding should be avoided for the most part and we’re sure you can imagine many ways to make this dynamic. That’s not really our focus here; the point is to feed some input into a Python script.</p>

<p>Thus, we’re executing a Python script that takes <code>stdin</code> from within an R script, and that <code>stdin</code> in itself a product of the R script. Let’s take a look at the minimal components of this Python script.</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">sys</code>
<code class="kn">import</code> <code class="nn">pandas</code> <code class="kn">as</code> <code class="nn">pd</code>

<code class="c1"># import the file specified by the standard input</code>
<code class="n">myFile</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">read_csv</code><code class="p">(</code><code class="n">sys</code><code class="o">.</code><code class="n">stdin</code><code class="p">)</code>

<code class="c1"># (Fantastically complex and very Pythonic code omitted)</code>

<code class="c1"># Write the first four lines to a file</code>
<code class="n">myFile</code><code class="o">.</code><code class="n">head</code><code class="p">(</code><code class="mi">4</code><code class="p">)</code><code class="o">.</code><code class="n">to_csv</code><code class="p">(</code><code class="s2">"pg_small.csv"</code><code class="p">)</code></pre>

<p>First we need the <code>sys</code> module to handle <code>stdin</code> (<code>sys.stdin</code>). We import the file, represented by <code>sys.stdin</code> using pandas and after our Python script works it’s magic we export some other output using the <code>to_csv()</code> method.</p>

<p>There are a lot of things wrong with this method, and we’ll get to them soon. But the point is that it works, and sometimes, it’s exactly what you need. Working in a research laboratory I often had to provide results to colleagues quickly. I mean this literally, since very expensive cell cultures would die and a week’s worth of work would be wasted if the results were not ready. Pre-processing of proprietary raw data and access to a secure server prohibited my colleagues from executing automated R scripts. My solution was to first process the machine-generated proprietary data with software specialized for the task. Then I was able to use a Mac OS Automator service to execute a Perl script on that output, which was now my <code>stdin</code>. This Perl script then called an R script that produced a file of a plot with all the relevant information clearly displayed in the title. It wasn’t the most open or elegant solution, but it worked and I got my plots with one mouse click in about half a second without any extra web-sites or logins. Life was good, so what’s the problem?</p>

<p>Well, there are several problems. Let’s consider three.</p>

<p>First, in retrospect, I could have probably executed the entire workflow in R (excluding the proprietary pre-processing). It’s necessary to consider simplifying a workflow and having a good reason to use multiple languages. Deciding when and why to combine Python &amp; R has come up throughout this book.</p>

<p>Second, there are a lot of moving parts. We have several files and we’re even producing additional intermediate ones. This increases the chance for error and confusion. That’s not terrible, but we better take care to keep things organized.</p>

<p>Third, in many cases, this workflow works well when we can export an R <code>data.frame</code> as a csv file, which <code>pandas</code> can easily import. For more complex data structures, you can export 1 or more R objects as an <code>RData</code> or <code>Rds</code> format file. The python <code>pyreadr</code> package provides functions to import these files and provide access to each object stored in a <code>dict</code>.</p>

<p>Cross-talk is great, but true interoperability smooths out the wrinkles in this process quite nicely. There are two widely-used frameworks, the choice of which to use will depend on which language is your starting point.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Interoperability"><div class="sect1" id="interOp">
<h1>Interoperability</h1>

<p>If you’re primarily using R and want access to Python, then the R package <code>reticulate</code> is the way to go. Conversely, if you’re primarily using Python and want access to R, then the Python module <code>rpy2</code> is the tool for you. We can summarize this in <a data-type="xref" href="#ret_table">Table 6-1</a> and <a data-type="xref" href="#rpy2_table">Table 6-2</a><sup><a data-type="noteref" id="idm45127448806536-marker" href="ch06.xhtml#idm45127448806536">2</a></sup>. In each table, read each line as a sentence beginning with the column headers.</p>
<table id="ret_table">
<caption><span class="label">Table 6-1. </span>Interoperability granted by reticulate.</caption>
<thead>
<tr>
<th>Access</th>
<th>Using command</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Python Functions</p></td>
<td><p>in R, <code>pd &lt;- library(pandas)</code>; <code>pd$read_csv()</code></p></td>
</tr>
<tr>
<td><p>Python Objects</p></td>
<td><p>in R,  <code>py$objName</code></p></td>
</tr>
<tr>
<td><p>R Objects</p></td>
<td><p>in Python, <code>r.objName</code> in Python</p></td>
</tr>
</tbody>
</table>
<table id="rpy2_table">
<caption><span class="label">Table 6-2. </span>Interoperability granted by rpy2 when writing in Python.</caption>
<thead>
<tr>
<th>Access</th>
<th>Using command</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>R Functions</p></td>
<td><p>in Python, <code>import rpy2.robjects.lib.ggplot2 as ggplot2</code></p></td>
</tr>
<tr>
<td><p>R Packages</p></td>
<td><p>in Python, <code>r_cluster = importr('cluster')</code></p></td>
</tr>
<tr>
<td><p>R Objects</p></td>
<td><p>in Python, <code>foo_py = robjects.r['foo_r']</code></p></td>
</tr>
</tbody>
</table>

<p>The commands in <a data-type="xref" href="#ret_table">Table 6-1</a> and <a data-type="xref" href="#rpy2_table">Table 6-2</a> reveal how to access all variety of objects from one language directly from the other. In addition, we can also directly call functions. This is a real milestone since it relieves us of having to force one language to do tasks that it doesn’t excel at and means that we don’t need to reinvent the wheel, introducing redundancy between the languages. At the time of writing it was not possible to access R functions from within Python in  <code>reticulate</code>. You may attempt to use <code>reticulate</code> for this task, but it would be easier to pass an object back to R and execute R commands natively.</p>








<section data-type="sect2" data-pdf-bookmark="Up and running with reticulate"><div class="sect2" id="idm45127448783400">
<h2>Up and running with reticulate</h2>

<p><code>reticulate</code> first appeared on CRAN in 2017, and has recently gained in popularity as it matured. This package is developed by RStudio, and is well-integrated into the RStudio IDE itself, which is pretty convenient. However, at the time of writing, there are some troublesome features (bugs?) that require some finesse (see the warning box <a data-type="xref" href="#state_reticulate">“State of reticulate”</a>). A good first step is to ensure you are using the latest public release of RStudio and the latest version of the <code>reticulate</code> package and any associated packages, such as <code>knitr</code>.</p>
<div data-type="warning" epub:type="warning" id="state_reticulate"><h1>State of <code>reticulate</code></h1>
<p><code>reticulate</code> is well-supported and stable enough to be used in production. Nonetheless, you may encounter issues depending on your system, and software versions. Since this tool combines technologies, it can also be difficult to debug, and documentation is still somewhat scarce. Stay up-to-date with new versions as they are released. If you encounter issues on your local machine, call up our <a href="https://rstudio.cloud/project/2534578">RStudio Cloud</a> project.</p>
</div>

<p>In this section we’ll begin with two scripts, listed in <a data-type="xref" href="#ret_table_start">Table 6-3</a>. You’ll find these in this chapter’s folder in the book’s <a href="https://github.com/moderndatadesign/PyR4MDS">repository</a>.</p>
<table id="ret_table_start">
<caption><span class="label">Table 6-3. </span>Up and running with reticulate.</caption>
<thead>
<tr>
<th>File</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>0 - Setup.Rmd</code></p></td>
<td><p>Setting up reticulate and virtual environments</p></td>
</tr>
<tr>
<td><p><code>1 - Activate.R</code></p></td>
<td><p>Activating a Python virtual environment</p></td>
</tr>
</tbody>
</table>

<p>Let’s begin with the R script, <code>0 - Setup.R</code>. Make sure you’ve installed <code>reticulate</code> and have initialized it in your environment:</p>

<pre data-type="programlisting" data-code-language="r"><code class="nf">library</code><code class="p">(</code><code class="n">reticulate</code><code class="p">)</code></pre>

<p>First, we need to specify which build of Python we’ll use. You can let R use your system default, or set the specific build of Python you want to use by going to <code>tools &gt;  Project options</code> and selecting the Python icon.</p>

<figure><div id="PyRTimeline_6" class="figure">
<img src="Images/prds_0602.png" alt="" width="2196" height="1650"/>
<h6><span class="label">Figure 6-2. </span>Selecting a specific Python version and build to use.</h6>
</div></figure>

<p>Let’s check to see the version we’re using:</p>

<pre data-type="programlisting" data-code-language="r"><code class="n">reticulate</code><code class="o">::</code><code class="nf">py_config</code><code class="p">()</code></pre>

<pre data-type="programlisting" data-code-language="r"><code class="n">python</code><code class="o">:</code>         <code class="o">/</code><code class="n">usr</code><code class="o">/</code><code class="n">local</code><code class="o">/</code><code class="n">bin</code><code class="o">/</code><code class="n">python3.8</code>
<code class="n">libpython</code><code class="o">:</code>      <code class="o">/</code><code class="n">Library</code><code class="o">/</code><code class="n">Frameworks</code><code class="o">/</code><code class="n">Python.framework</code><code class="o">/</code><code class="n">Versions</code><code class="o">/</code><code class="m">3.8</code><code class="kc">...</code>
<code class="n">pythonhome</code><code class="o">:</code>     <code class="o">/</code><code class="n">Library</code><code class="o">/</code><code class="n">Frameworks</code><code class="o">/</code><code class="n">Python.framework</code><code class="o">/</code><code class="n">Versions</code><code class="o">/</code><code class="m">3.8</code><code class="kc">...</code>
<code class="n">version</code><code class="o">:</code>        <code class="m">3.8.6</code> <code class="p">(</code><code class="n">v3.8.6</code><code class="o">:</code><code class="n">db455296be</code><code class="p">,</code> <code class="n">Sep</code> <code class="m">23</code> <code class="m">2020</code><code class="p">,</code> <code class="m">13</code><code class="o">:</code><code class="m">31</code><code class="o">:</code><code class="m">39</code><code class="p">)</code> <code class="kc">...</code>
<code class="n">numpy</code><code class="o">:</code>           <code class="p">[</code><code class="n">NOT</code> <code class="n">FOUND</code><code class="p">]</code>
<code class="n">sys</code><code class="o">:</code>            <code class="p">[</code><code class="n">builtin</code> <code class="n">module</code><code class="p">]</code></pre>

<p>To be clear, we don’t need to use RStudio to set the Python version. This is just a convenience feature. We could have executed:</p>

<pre data-type="programlisting" data-code-language="r"><code class="nf">use_python</code><code class="p">(</code><code class="s">"/usr/local/bin/python3.8"</code><code class="p">,</code> <code class="n">required</code> <code class="o">=</code> <code class="kc">TRUE</code><code class="p">)</code></pre>

<p>Note that this function just makes a <em>suggestion</em> and doesn’t result in an error if the desired build is not found unless the <code>required</code> argument is set to <code>TRUE</code>.</p>

<p>Before we proceed, we’ll want to establish a virtual environment. If you’re on Windows you’ll have to use a <code>conda</code> environment, which we’ll get to in a minute. For everyone else, use the following command to create a virtual environment called <code>modern_data</code>:</p>

<pre data-type="programlisting" data-code-language="r"><code class="nf">virtualenv_create</code><code class="p">(</code><code class="s">"modern_data"</code><code class="p">)</code></pre>

<p>Previously, when we used the <code>venv</code> package in Python, the virtual environment was stored as a hidden directory (typically called <code>.venv</code> in the project directory). So where are the Python virtual environments now? We can have a look with the following command:</p>

<pre data-type="programlisting" data-code-language="r"><code class="nf">virtualenv_root</code><code class="p">()</code></pre>

<pre data-type="programlisting">[1] "~/.virtualenvs"</pre>

<p>They are all stored in a hidden folder in the <em>root</em> directory. We can see all our virtual environment using the following command:</p>

<pre data-type="programlisting" data-code-language="r"><code class="nf">virtualenv_list</code><code class="p">()</code></pre>
<div data-type="tip"><h1>The reticulate cheat sheet</h1>
<p>As is the case for most popular data science packages, there is a cheat sheet available for <code>reticulate</code>. You can download it directly from <a href="https://raw.githubusercontent.com/rstudio/cheatsheets/master/reticulate.pdf">here</a>.</p>
</div>

<p>This is a departure from what we saw with virtual environments in Python, where they were stored within the project directory. Nonetheless, it’s convenient, since we can easily reuse a good environment for many projects.</p>

<p>Note that to remove a virtual environment, we need to pass the path, as such: <code>virtualenv_remove("~/modern_data")</code>.</p>

<p>The next step is to install the appropriate packages.</p>

<pre data-type="programlisting" data-code-language="r"><code class="nf">virtualenv_install</code><code class="p">(</code><code class="s">"modern_data"</code><code class="p">,</code> <code class="s">"pandas"</code><code class="p">)</code></pre>

<p>Alternatively, you can use the tidyverse <code>purrr::map()</code> function to install many packages:</p>

<pre data-type="programlisting" data-code-language="r"><code class="nf">library</code><code class="p">(</code><code class="n">tidyverse</code><code class="p">)</code>
<code class="nf">c</code><code class="p">(</code><code class="s">"scikit-learn"</code><code class="p">,</code> <code class="s">"pandas"</code><code class="p">,</code> <code class="s">"seaborn"</code><code class="p">)</code> <code class="o">%&gt;%</code>
  <code class="nf">map</code><code class="p">(</code><code class="o">~</code> <code class="nf">virtualenv_install</code><code class="p">(</code><code class="s">"modern_data"</code><code class="p">,</code> <code class="n">.)</code><code class="p">)</code></pre>

<p>If you’re on Windows, use the following commands:</p>

<pre data-type="programlisting" data-code-language="r"><code class="c1"># For windows users:</code>
<code class="c1"># Install a minimal version of conda</code>
<code class="nf">install_miniconda</code><code class="p">()</code>

<code class="c1"># List your conda virtual environments</code>
<code class="nf">conda_list</code><code class="p">()</code>

<code class="c1"># Creata a new virtual environment</code>
<code class="nf">conda_create</code><code class="p">(</code><code class="s">"modern_data"</code><code class="p">)</code>

<code class="c1"># Install a single...</code>
<code class="nf">conda_install</code><code class="p">(</code><code class="s">"modern_data"</code><code class="p">,</code> <code class="s">"scikit-learn"</code><code class="p">)</code>

<code class="c1">#...or multiple packages:</code>
<code class="nf">library</code><code class="p">(</code><code class="n">tidyverse</code><code class="p">)</code>
<code class="nf">c</code><code class="p">(</code><code class="s">"scikit-learn"</code><code class="p">,</code> <code class="s">"pandas"</code><code class="p">,</code> <code class="s">"seaborn"</code><code class="p">)</code> <code class="o">%&gt;%</code>
  <code class="nf">map</code><code class="p">(</code><code class="o">~</code> <code class="nf">conda_install</code><code class="p">(</code><code class="s">"modern_data"</code><code class="p">,</code> <code class="n">.)</code><code class="p">)</code></pre>

<p>The final step is to activate our virtual environment. This seems to be an area under rapid development. Different error messages, or none at all are produced depending on your versions of <code>reticulate</code> and RStudio, making them harder to debug. From my experience, your safest bet is to (i) make sure all your R packages, as well as RStudio, are up to date, and (ii) restart R before activating your virtual environment. You can do this in the RStudio menu <code>Session &gt; Restart R</code>, the keyboard shortcut <code>shift + cmd/ctrl + F10</code> or executing the command <code>.rs.restartR()</code>. You can also literally close and restart RStudio. This ensures that there is no Python build in active use and we can establish one from scratch. Thus, we have one R script for setup, where we create a virtual environment and install packages, and another with our actual analysis, where we load <code>reticulate</code> and activate our virtual environment.</p>

<pre data-type="programlisting" data-code-language="r"><code class="nf">library</code><code class="p">(</code><code class="n">reticulate</code><code class="p">)</code>
<code class="nf">use_virtualenv</code><code class="p">(</code><code class="s">"modern_data"</code><code class="p">,</code> <code class="n">required</code> <code class="o">=</code> <code class="kc">TRUE</code><code class="p">)</code>

<code class="c1"># Alternatively, for miniconda:</code>
<code class="c1"># use_miniconda("modern_data")</code></pre>

<p>And finally we can confirm which build we have using:</p>

<pre data-type="programlisting" data-code-language="r"><code class="nf">py_config</code><code class="p">()</code></pre>

<p>You should see the following output. Importantly, make sure that the path to your virtual environment is stated in the first line: <code>/.virtualenvs/modern_data/bin/python</code>.</p>

<pre data-type="programlisting" data-code-language="r"><code class="n">python</code><code class="o">:</code>         <code class="o">/</code><code class="n">Users</code><code class="o">/</code><code class="n">user_name</code><code class="o">/</code><code class="n">.virtualenvs</code><code class="o">/</code><code class="n">modern_data</code><code class="o">/</code><code class="n">bin</code><code class="o">/</code><code class="n">python</code>
<code class="n">libpython</code><code class="o">:</code>      <code class="o">/</code><code class="n">Library</code><code class="o">/</code><code class="n">Frameworks</code><code class="o">/</code><code class="n">Python.framework</code><code class="o">/</code><code class="n">Versions</code><code class="o">/</code><code class="m">3.8</code><code class="kc">...</code>
<code class="n">pythonhome</code><code class="o">:</code>     <code class="o">/</code><code class="n">Users</code><code class="o">/</code><code class="n">user_name</code><code class="o">/</code><code class="n">.virtualenvs</code><code class="o">/</code><code class="n">modern_data...</code>
<code class="n">version</code><code class="o">:</code>        <code class="m">3.8.6</code> <code class="p">(</code><code class="n">v3.8.6</code><code class="o">:</code><code class="n">db455296be</code><code class="p">,</code> <code class="n">Sep</code> <code class="m">23</code> <code class="m">2020</code><code class="p">,</code> <code class="m">13</code><code class="o">:</code><code class="m">31</code><code class="o">:</code><code class="m">39</code><code class="p">)</code>
<code class="n">numpy</code><code class="o">:</code>          <code class="o">/</code><code class="n">Users</code><code class="o">/</code><code class="n">user_name</code><code class="o">/</code><code class="n">.virtualenvs</code><code class="o">/</code><code class="n">modern_data</code><code class="o">/</code><code class="n">lib</code><code class="o">/</code><code class="n">python3.8</code><code class="o">/</code><code class="n">site</code><code class="o">-</code><code class="n">packages</code><code class="o">/</code><code class="n">numpy</code>
<code class="n">numpy_version</code><code class="o">:</code>  <code class="m">1.20.1</code></pre>

<p>If you see something like <code>/usr/local/bin/python3.8</code> then RStudio is still directed to use the Python version you defined at the beginning of the chapter and not a virtual environment. This may serve you well, but it is preferable to use a virtual environment.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Going deeper"><div class="sect1" id="idm45127449036376">
<h1>Going deeper</h1>

<p>At this point, we’ve created a virtual environment, installed some packages in it, restarted R and have activated the virtual environment. These step are covered in the the scripts <code>0 - Setup.R</code> and <code>1 - Activate.R</code>. For the rest of this section I’ll cover ways to pass information between R and Python, which I’ve summarized in <a data-type="xref" href="#ret_table">Table 6-1</a>.</p>
<table id="ret_table_desc">
<caption><span class="label">Table 6-4. </span>Interoperability granted by reticulate.</caption>
<thead>
<tr>
<th>File</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>2 - Passing objects.Rmd</code></p></td>
<td><p>Pass objects between R and Python in an RMarkdown document</p></td>
</tr>
<tr>
<td><p><code>3 - Using functions.Rmd</code></p></td>
<td><p>Call Python in an RMarkdown document</p></td>
</tr>
<tr>
<td><p><code>4 - Calling scripts.Rmd</code></p></td>
<td><p>Call Python by sourcing a Python script</p></td>
</tr>
<tr>
<td><p><code>5 - Interactive mode.R</code></p></td>
<td><p>Call Python using a Python REPL console</p></td>
</tr>
<tr>
<td><p><code>6 - Interactive document.Rmd</code></p></td>
<td><p>Call Python with dynamic input in an interactive document</p></td>
</tr>
</tbody>
</table>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Why “reticulate”? The reticulated python is a species of python found in Southeast Asia. They are the world’s longest snakes and longest reptiles. The species name, <em>Malayopython reticulatus</em>, is Latin meaning “net-like”, or reticulated, and is a reference to the complex colour pattern.</p>
</div>

<p>I’ll consider the scenarios in <a data-type="xref" href="#ret_table">Table 6-1</a> in the subsections below. To follow along with these examples, please ensure that you have followed the setup and activation instructions found in  <code>0 - Setup.R</code> and <code>1 - Activate.R</code> (both in the book code <a href="https://github.com/moderndatadesign/PyR4MDS">repository</a>). You’ll need to have the modern_data virtual environment and the above list of packages installed. If you’re using <code>miniconda</code>, be sure to use the correct command given in each file to activate your virtual environment.</p>








<section data-type="sect2" data-pdf-bookmark="Pass objects between R and Python in an RMarkdown document"><div class="sect2" id="idm45127448170264">
<h2>Pass objects between R and Python in an RMarkdown document</h2>

<p>The following commands can be found in the file <code>2 - Passing objects.Rmd</code>. To access an R object in python use the <code>r</code> object, and to access a Python in R, use the <code>py</code> object. Consider the following chunks found in an RMarkdown document:</p>

<pre data-type="programlisting" data-code-language="markdown">```{python}
a = 3.14
a
```</pre>

<pre data-type="programlisting" data-code-language="markdown">```{r}
py$a
```</pre>

<p>The python object <code>a</code> is accessed in the R object <code>py</code> using the <code>$</code> notation. In the opposite direction:</p>

<pre data-type="programlisting" data-code-language="markdown">```{r}
b &lt;- 42
b
```</pre>

<pre data-type="programlisting" data-code-language="markdown">```{python}
r.b
```</pre>

<p>In Python, call the <code>r</code> object and use <code>.</code> notation to access R objects by name. These are scalars, or simple vectors, but of course we can pass more complex items directly between the two languages. <code>reticulate</code> will take care of object conversion for us. Consider the following case:</p>

<pre data-type="programlisting" data-code-language="markdown">```{r}
<code class="gh">#</code> A build-in data frame
head(PlantGrowth)
```</pre>

<pre data-type="programlisting" data-code-language="markdown">```{python}
r.PlantGrowth.head()
```</pre>

<p>An R <code>data.frame</code> is accessed as a Python <code>pandas.DataFrame</code>. However, if you don’t have pandas installed you’ll see a <code>dict</code> object, a Python dictionary.</p>

<p>A Python <code>NumPy</code> <code>ndarray</code> will be converted to an R `matrix`<sup><a data-type="noteref" id="idm45127448026744-marker" href="ch06.xhtml#idm45127448026744">3</a></sup>:</p>

<pre data-type="programlisting" data-code-language="markdown">```{python eval = TRUE}
from sklearn.datasets import load_iris

iris = load_iris()
iris.data[:6]
```</pre>

<p>A Python NumPy <code>ndarray</code> as an R <code>matrix</code>:</p>

<pre data-type="programlisting" data-code-language="markdown">```{r eval = TRUE}
head(py$iris$data)
```</pre>

<p>Notice how the <code>.</code> notation in Python, <code>iris.data</code> is automatically accessible using the <code>$</code> notation in R: <code>py$iris$data</code>. This holds true for nested objects, methods and attributes, just as they would in Python,</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Call Python in an RMarkdown document"><div class="sect2" id="idm45127448169640">
<h2>Call Python in an RMarkdown document</h2>

<p>The following commands can be found in the file <code>3 - Using functions.Rmd</code>. We’ll continue to use the classic iris dataset that we accessed in Python in the previous section. Inside an RMarkdown document, we’ll access a Python function, which allows us to access the trained support vector machine  classifier to predict classification on new values. This is a very naïve machine learning workflow and is not intended to produce a valuable model. The point is to demonstrate how to access a model from Python in R.</p>

<p>The entire model configuration is defined here:</p>

<pre data-type="programlisting" data-code-language="markdown">```{python}
<code class="gh">#</code> import modules
from sklearn import datasets
from sklearn.svm import SVC

<code class="gh">#</code> load the data:
iris = datasets.load_iris()

<code class="gh">#</code> Create an instance of the SVC, _Support Vector Classification_, class.
clf = SVC()

<code class="gh">#</code> Train the model by calling the fit method on the target data, using target names
clf.fit(iris.data, iris.target_names[iris.target])

<code class="gh">#</code> Predict the class of new values, here the first three
clf.predict(iris.data[:3])
```</pre>

<p>The method <code>clf.predict()</code> takes an <code>ndarray</code> as input and returns the named classification. To access this function in R, we can once again use the <code>py</code> object, as in <code>py$clf$predict()</code>. The <code>iris</code> dataset in R is a <code>data.frame</code>, where the 5th column is the classification. We must convert this to a Python object using <code>r_to_py()</code>, in this case excluding the 5th column.</p>

<pre data-type="programlisting" data-code-language="markdown">```{r}
py$clf$predict(r_to_py(iris[-5]))
```</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Call Python by sourcing a Python script"><div class="sect2" id="idm45127448131640">
<h2>Call Python by sourcing a Python script</h2>

<p>The following commands can be found in the file <code>4 - Calling scripts.Rmd</code> and <code>4b - Calling scripts.R</code>. In this scenario we’ll execute an entire Python script and access all object and functions available therein. To do this we can call:</p>

<pre data-type="programlisting" data-code-language="r"><code class="nf">source_python</code><code class="p">(</code><code class="s">"SVC_iris.py"</code><code class="p">)</code></pre>

<p>This works just as well in an RMarkdown document as in a script.</p>

<p>Although this appears very similar to the previous section, there is a very important distinction. Python environments activated in this manner provide functions and objects directly. Thus we can call:</p>

<pre data-type="programlisting" data-code-language="r"><code class="n">clf</code><code class="o">$</code><code class="nf">predict</code><code class="p">(</code><code class="nf">r_to_py</code><code class="p">(</code><code class="n">iris</code><code class="p">[</code><code class="m">-5</code><code class="p">]))</code></pre>

<p>This is convenient, but also disconcerting. Not only has the syntax changes, i.e. no need for <code>py$</code>, but objects loaded in the R environment may conflict. Python objects will mask R objects, so be very careful about naming conflicts! You’ll notice that in <code>SVC_iris.py</code> we’ve renamed the Python <code>iris</code> dataset to <code>iris_py</code> to avoid problems when calling <code>iris</code> in R.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Call Python using the REPL"><div class="sect2" id="idm45127447889016">
<h2>Call Python using the REPL</h2>

<p>The following commands can be found in the file <code>5 - Interactive mode.R</code>. In this scenario we’ll start up a Python REPL console, using the following command:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">repl_python</code><code class="p">()</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>REPL stands for Read-eval-print loop. It is a common feature in many languages where the user can experiment in an interactive way, as opposed to writing a script that needs to be run.</p>
</div>

<p>This will allow you to directly execute Python commands in an interpreter. For example, try executing the commands we saw in the last example:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code> <code class="nn">sklearn</code> <code class="kn">import</code> <code class="n">datasets</code>
<code class="kn">from</code> <code class="nn">sklearn.svm</code> <code class="kn">import</code> <code class="n">SVC</code>
<code class="n">iris</code> <code class="o">=</code> <code class="n">datasets</code><code class="o">.</code><code class="n">load_iris</code><code class="p">()</code>
<code class="n">clf</code> <code class="o">=</code> <code class="n">SVC</code><code class="p">()</code>
<code class="n">clf</code><code class="o">.</code><code class="n">fit</code><code class="p">(</code><code class="n">iris</code><code class="o">.</code><code class="n">data</code><code class="p">,</code> <code class="n">iris</code><code class="o">.</code><code class="n">target_names</code><code class="p">[</code><code class="n">iris</code><code class="o">.</code><code class="n">target</code><code class="p">])</code>
<code class="n">clf</code><code class="o">.</code><code class="n">predict</code><code class="p">(</code><code class="n">iris</code><code class="o">.</code><code class="n">data</code><code class="p">[:</code><code class="mi">3</code><code class="p">])</code></pre>

<p>We can exit the interpreter by executing the Python <code>exit</code> command.</p>

<pre data-type="programlisting" data-code-language="python"><code class="nb">exit</code></pre>

<p>Just like we’ve seen before, the functions and objects in this Python environment can be accessed in R. This is truly interactive programming, since we’re executing commands directly in the console. Although we present this scenario for the sake of completeness, <code>repl_python()</code> is not really meant to be used in everyday practice. Actually, it’s what is called when an RMarkdown chunk uses a Python kernel. So although you can do this, be cautious! This presents a considerable problem in reproducibility and automation, but you may find it useful for quickly checking some commands.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Call Python with dynamic input in an interactive document"><div class="sect2" id="idm45127447773000">
<h2>Call Python with dynamic input in an interactive document</h2>

<p>The following commands can be found in the file <code>6 - Interactive document.Rmd</code>.</p>

<p>By now we’ve see all the core functionality of reticulate. Here we’ll go beyond that and show a very simple way to introduce interactivity using a <code>shiny</code> runtime in an RMarkdown document. To see the interactivity, make sure you have the <code>shiny</code> package installed and the you render the document to HTML. In RStudio, you can do this by clicking on the “Run Document” button when the file is open.</p>

<p>First, in the header of our document we need to specify this new runtime environment:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nn">---</code>
<code class="nt">title</code><code class="p">:</code> <code class="s">"Python</code><code class="nv"> </code><code class="s">&amp;</code><code class="nv"> </code><code class="s">R</code><code class="nv"> </code><code class="s">for</code><code class="nv"> </code><code class="s">the</code><code class="nv"> </code><code class="s">Modern</code><code class="nv"> </code><code class="s">Data</code><code class="nv"> </code><code class="s">Scientist"</code>
<code class="nt">subtitle</code><code class="p">:</code> <code class="s">"A</code><code class="nv"> </code><code class="s">bilingual</code><code class="nv"> </code><code class="s">case</code><code class="nv"> </code><code class="s">study"</code>
<code class="nt">runtime</code><code class="p">:</code> <code class="l-Scalar-Plain">shiny</code>
<code class="nn">---</code></pre>

<p>The following Python code, which we’ve seen above, is executed in a Python chunk:</p>

<pre data-type="programlisting" data-code-language="markdown">```{python}
from sklearn import datasets
from sklearn.svm import SVC
iris = datasets.load_iris()

clf = SVC()
clf.fit(iris.data, iris.target_names[iris.target])
```</pre>

<p>In the final two chunks we use functions from the <code>shiny</code> package to (i) produce sliders for each of the four features, and (ii) render the output from <code>py$clf$predict()</code> as HTML text, e.g.:</p>

<pre data-type="programlisting" data-code-language="r"><code class="nf">sliderInput</code><code class="p">(</code><code class="s">"sl"</code><code class="p">,</code> <code class="n">label</code> <code class="o">=</code> <code class="s">"Sepal length:"</code><code class="p">,</code>
            <code class="n">min</code> <code class="o">=</code> <code class="m">4.3</code><code class="p">,</code> <code class="n">max</code> <code class="o">=</code> <code class="m">7.9</code><code class="p">,</code> <code class="n">value</code> <code class="o">=</code> <code class="m">4.5</code><code class="p">,</code> <code class="n">step</code> <code class="o">=</code> <code class="m">0.1</code><code class="p">)</code></pre>

<p>and…
n</p>

<pre data-type="programlisting" data-code-language="r"><code class="n">prediction</code> <code class="o">&lt;-</code> <code class="nf">renderText</code><code class="p">({</code>
  <code class="n">py</code><code class="o">$</code><code class="n">clf</code><code class="o">$</code><code class="nf">predict</code><code class="p">(</code>
    <code class="nf">r_to_py</code><code class="p">(</code>
      <code class="nf">data.frame</code><code class="p">(</code>
        <code class="n">sl</code> <code class="o">=</code> <code class="n">input</code><code class="o">$</code><code class="n">sl</code><code class="p">,</code>
        <code class="n">sw</code> <code class="o">=</code> <code class="n">input</code><code class="o">$</code><code class="n">sw</code><code class="p">,</code>
        <code class="n">pl</code> <code class="o">=</code> <code class="n">input</code><code class="o">$</code><code class="n">pl</code><code class="p">,</code>
        <code class="n">pw</code> <code class="o">=</code> <code class="n">input</code><code class="o">$</code><code class="n">pw</code><code class="p">)</code>
    <code class="p">)</code>
  <code class="p">)</code>
<code class="p">})</code></pre>

<p>Finally, we call the R object <code>prediction</code> as an in-line command, <code>r prediction</code> to print the result to the screen as a sentence.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Final thoughts"><div class="sect1" id="idm45127448190632">
<h1>Final thoughts</h1>

<p>In this chapter we’ve covered the core components of the <code>reticulate</code> package, progressing from the essential setup to the basics and finally a simple yet powerful implementation that showcases the strengths R, Python and <code>reticulate</code>. Using this knowledge we’ll continue onto a larger case study in the last chapter.</p>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm45127448988616"><sup><a href="ch06.xhtml#idm45127448988616-marker">1</a></sup> Recall that rhs is the <em>right-hand side</em> and lhs is the <em>left-hand side</em> when calling operators, in this case <code>&lt;</code></p><p data-type="footnote" id="idm45127448806536"><sup><a href="ch06.xhtml#idm45127448806536-marker">2</a></sup> In these tables we make a distinction between functions and objects. Recall that functions are themselves just objects, but we don’t need to worry about these details at the moment.</p><p data-type="footnote" id="idm45127448026744"><sup><a href="ch06.xhtml#idm45127448026744-marker">3</a></sup> Refer the Appendix A for a summary of data structures.</p></div></div></section></div></body></html>