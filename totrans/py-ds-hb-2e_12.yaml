- en: Chapter 10\. Fancy Indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapters discussed how to access and modify portions of arrays
    using simple indices (e.g., `arr[0]`), slices (e.g., `arr[:5]`), and Boolean masks
    (e.g., `arr[arr > 0]`). In this chapter, we’ll look at another style of array
    indexing, known as *fancy* or *vectorized* indexing, in which we pass arrays of
    indices in place of single scalars. This allows us to very quickly access and
    modify complicated subsets of an array’s values.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Fancy Indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fancy indexing is conceptually simple: it means passing an array of indices
    to access multiple array elements at once. For example, consider the following
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we want to access three different elements. We could do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can pass a single list or array of indices to obtain the
    same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When using arrays of indices, the shape of the result reflects the shape of
    the *index arrays* rather than the shape of the *array being indexed*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Fancy indexing also works in multiple dimensions. Consider the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Like with standard indexing, the first index refers to the row, and the second
    to the column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the first value in the result is `X[0, 2]`, the second is `X[1,
    1]`, and the third is `X[2, 3]`. The pairing of indices in fancy indexing follows
    all the broadcasting rules that were mentioned in [Chapter 8](ch08.xhtml#section-0205-computation-on-arrays-broadcasting).
    So, for example, if we combine a column vector and a row vector within the indices,
    we get a two-dimensional result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, each row value is matched with each column vector, exactly as we saw
    in broadcasting of arithmetic operations. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It is always important to remember with fancy indexing that the return value
    reflects the *broadcasted shape of the indices*, rather than the shape of the
    array being indexed.
  prefs: []
  type: TYPE_NORMAL
- en: Combined Indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For even more powerful operations, fancy indexing can be combined with the
    other indexing schemes we’ve seen. For example, given the array `X`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine fancy and simple indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also combine fancy indexing with slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can combine fancy indexing with masking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: All of these indexing options combined lead to a very flexible set of operations
    for efficiently accessing and modifying array values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Selecting Random Points'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One common use of fancy indexing is the selection of subsets of rows from a
    matrix. For example, we might have an <math alttext="upper N"><mi>N</mi></math>
    × <math alttext="upper D"><mi>D</mi></math> matrix representing <math alttext="upper
    N"><mi>N</mi></math> points in <math alttext="upper D"><mi>D</mi></math> dimensions,
    such as the following points drawn from a two-dimensional normal distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using the plotting tools we will discuss in [Part IV](part04.xhtml#section-0400-introduction-to-matplotlib),
    we can visualize these points as a scatter plot ([Figure 10-1](#fig_0207-fancy-indexing_files_in_output_31_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![output 31 0](assets/output_31_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1\. Normally distributed points
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s use fancy indexing to select 20 random points. We’ll do this by first
    choosing 20 random indices with no repeats, and using these indices to select
    a portion of the original array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now to see which points were selected, let’s overplot large circles at the locations
    of the selected points (see [Figure 10-2](#fig_0207-fancy-indexing_files_in_output_36_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![output 36 0](assets/output_36_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2\. Random selection among points
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This sort of strategy is often used to quickly partition datasets, as is often
    needed in train/test splitting for validation of statistical models (see [Chapter 39](ch39.xhtml#section-0503-hyperparameters-and-model-validation)),
    and in sampling approaches to answering statistical questions.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying Values with Fancy Indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as fancy indexing can be used to access parts of an array, it can also
    be used to modify parts of an array. For example, imagine we have an array of
    indices and we’d like to set the corresponding items in an array to some value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use any assignment-type operator for this. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice, though, that repeated indices with these operations can cause some
    potentially unexpected results. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Where did the 4 go? This operation first assigns `x[0] = 4`, followed by `x[0]
    = 6`. The result, of course, is that `x[0]` contains the value 6.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fair enough, but consider this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You might expect that `x[3]` would contain the value 2 and `x[4]` would contain
    the value 3, as this is how many times each index is repeated. Why is this not
    the case? Conceptually, this is because `x[i] += 1` is meant as a shorthand of
    `x[i] = x[i] + 1`. `x[i] + 1` is evaluated, and then the result is assigned to
    the indices in `x`. With this in mind, it is not the augmentation that happens
    multiple times, but the assignment, which leads to the rather nonintuitive results.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what if you want the other behavior where the operation is repeated? For
    this, you can use the `at` method of ufuncs and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `at` method does an in-place application of the given operator at the specified
    indices (here, `i`) with the specified value (here, 1). Another method that is
    similar in spirit is the `reduceat` method of ufuncs, which you can read about
    in the [NumPy documentation](https://oreil.ly/7ys9D).
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Binning Data'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You could use these ideas to efficiently do custom binned computations on data.
    For example, imagine we have 100 values and would like to quickly find where they
    fall within an array of bins. We could compute this using `ufunc.at` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The counts now reflect the number of points within each bin—in other words,
    a histogram (see [Figure 10-3](#fig_0207-fancy-indexing_files_in_output_52_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![output 52 0](assets/output_52_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-3\. A histogram computed by hand
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Of course, it would be inconvenient to have to do this each time you want to
    plot a histogram. This is why Matplotlib provides the `plt.hist` routine, which
    does the same in a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will create a nearly identical plot to the one just shown. To
    compute the binning, Matplotlib uses the `np.histogram` function, which does a
    very similar computation to what we did before. Let’s compare the two here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Our own one-line algorithm is twice as fast as the optimized algorithm in NumPy!
    How can this be? If you dig into the `np.histogram` source code (you can do this
    in IPython by typing `np.histogram??`), you’ll see that it’s quite a bit more
    involved than the simple search-and-count that we’ve done; this is because NumPy’s
    algorithm is more flexible, and particularly is designed for better performance
    when the number of data points becomes large:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'What this comparison shows is that algorithmic efficiency is almost never a
    simple question. An algorithm efficient for large datasets will not always be
    the best choice for small datasets, and vice versa (see [Chapter 11](ch11.xhtml#section-0208-sorting)).
    But the advantage of coding this algorithm yourself is that with an understanding
    of these basic methods, the sky is the limit: you’re no longer constrained to
    built-in routines, but can create your own approaches to exploring the data. Key
    to efficiently using Python in data-intensive applications is not only knowing
    about general convenience routines like `np.histogram` and when they’re appropriate,
    but also knowing how to make use of lower-level functionality when you need more
    pointed behavior.'
  prefs: []
  type: TYPE_NORMAL
