- en: Appendix A. D3’s enter/exit Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As shown in [“Updating the DOM with Data”](ch17.xhtml#d3bar_update), D3 now
    has a more user-friendly `join` method to replace the old implementation of data-joining
    using patterns based around the `enter`, `exit`, and `remove` methods. The `join`
    method is a great addition to D3, but there are thousands of examples online using
    the old data-joining patterns. In order to use/convert these it helps to know
    a little bit more about what’s going on under the hood when D3 joins data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to demonstrate D3’s data joining, let’s look under the hood when D3
    joins data. Let’s start with our bar-less chart, with SVG canvas and chart group
    in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to join data with D3, we first need some data in the right form. Generally
    that will be an array of objects, like our bar chart’s `nobelData`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A D3 data-join is made in two stages. First, we add the data to be joined using
    the `data` method then we perform the join using the `join` method.
  prefs: []
  type: TYPE_NORMAL
- en: To add our Nobel data to a group of bars, we do the following. First, we select
    a container for our bars, in this case our SVG group of class `chart`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we define the container, in this case a CSS selector of class `bar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We now come to a slightly counterintuitive aspect of D3’s `data` method. Our
    first `select` returned the `chart` group in our `nobel-bar` SVG canvas, but the
    second `selectAll` returned all elements with class `bars`, of which there are
    none. If there are no bars, what exactly are we binding the data to? The answer
    is that behind the scenes, D3 is keeping the books and that the `bars` object
    returned by `data` knows which DOM elements have been bound to the `nobelData`
    and, just as crucially, which haven’t. We’ll now see how to make use of this fact
    using the fundamental `enter` method.
  prefs: []
  type: TYPE_NORMAL
- en: The enter Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: D3’s [`enter` method](https://oreil.ly/veBF9) (and its sibling, `exit`) is both
    the basis for D3’s superb power and expressiveness and also the root of much confusion.
    Although, as mentioned, the newish `join` method simplifies things, it’s worth
    coming to grips with `enter` if you really want your D3 skills to grow. Let’s
    introduce it now, with a very simple and slow demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start with a canonically simple little demonstration, adding a bar rectangle
    for each member of our Nobel Prize data. We’ll use the first six Nobel Prize–winning
    countries as our bound data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With our dataset in hand, let’s first use D3 to grab the chart group, saving
    it to an `svg` variable. We’ll use that to make a selection of all elements of
    class `bar` (none at the moment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now although the `bars` selection is empty, behind the scenes D3 has kept a
    record of the data we’ve just bound to it. At this point, we can use that fact
    and the `enter` method to create a few bars with our data. Calling `enter` on
    our `bars` selection returns a subselection of all the data (`nobelData`, in this
    case) that was not bound to a bar. Since there were no bars in the original selection
    (our chart being empty), all the data is unbound, so `enter` returns an enter
    election (essentially placeholder nodes for all the unbound data) of size six:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the placeholder nodes in `bars` to create some DOM elements—in our
    case, a few bars. We won’t bother with trying to put them the right way up (the
    y-axis being down from the top of the screen by convention), but we will use the
    data values and indices to set the position and height of the bars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_d3__8217_s_enter_exit_pattern_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you provide a callback function to D3’s setter methods (`attr`, `style`,
    etc.), then the first and second arguments provided are the value of the individual
    data object (e.g., `d == {key: ''United States'', value: 200}`) and its index
    (`i`).'
  prefs: []
  type: TYPE_NORMAL
- en: Using the callback functions to set height and the x position (allowing a padding
    of 2 px) of the bars and calling `append` on our six node selection produces [Figure A-1](#d3bar_enter_full).
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 aa01](assets/dpj2_aa01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A-1\. Producing some bars with D3’s `enter` method
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I’d encourage you generally to use Chrome’s (or equivalent) Elements tab to
    investigate the HTML your D3 is producing. Investigating our mini–bar chart with
    Elements shows [Figure A-2](#d3bar_enter_elements).
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 aa02](assets/dpj2_aa02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A-2\. Using the Elements tab to see the HTML generated by `enter` and
    `append`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: So we’ve seen what happens when we call `enter` on an empty selection. But what
    happens when we already have a few bars, which we would have in an interactive
    chart with a user-driven, changing dataset?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a couple of `bar` class rectangles to our starting HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now perform the same data binding and entering as before, on calling
    `data` on our selection, the two placeholder rectangles bind to the first two
    members of our `nobelData` array (i.e., `[{key: ''United States'', value: 200},
    {key: ''United Kingdom'', value:80}]`). This means that `enter`, which returns
    only unbound data placeholders, now returns only four placeholders, associated
    with the last four elements of the `nobelData` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If we now call `append` on the entered `bars`, as before, we get the result
    shown in [Figure A-3](#d3bar_enter_part), showing the last four bars (note that
    they preserve their index `i`, used to set their x positions) rendered.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 aa03](assets/dpj2_aa03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A-3\. Calling `enter` and `append` with existing bars
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure A-4](#d3bar_enter_elements_part) shows the HTML generated for the last
    four bars. As we’ll see, the data from the first two elements is now bound to
    the two dummy nodes we added to the initial bar group. We just haven’t used it
    yet to adjust those rectangles’ attributes. Updating old bars with new data is
    the one of the key elements of the update pattern we’ll see shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 aa04](assets/dpj2_aa04.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A-4\. Using the Elements tab to see the HTML generated by `enter` and
    `append` on a partial selection
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To emphasize, coming to grips with `enter` and `exit` (and `remove`) is vital
    to healthy progress with D3\. Play around a bit, inspect the HTML you’re producing,
    enter a bit of data, and generally get a bit messy, learning the ins and outs.
    Let’s have a little look at accessing the bound data before moving on to the D3’s
    nexus, the update pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Bound Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good way to see what’s happening to the DOM is to use your browser’s HTML
    inspector and console to track D3’s changes. In [Figure A-1](#d3bar_enter_full),
    we use Chrome’s console to look at the `rect` element representing the first bar
    in [Figure A-3](#d3bar_enter_part), before data has been bound and after the `nobelData`
    has been bound to the bars using the `data` method. As you can see, D3 has added
    a `__data__` object to the `rect` element with which to store its bound data—in
    this case, the first member of our `nobelData` list. The `__data__` object is
    used by D3’s internal bookkeeping and, fundamentally, the data in it is made available
    to functions supplied to update methods such as `attr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a little example of using the data in an element’s `__data__`
    object to set its `name` attribute. The `name` attribute can be useful for making
    specific D3 selections. For example, if the user selects a particular country,
    we can now use D3 to get all its named components and adjust their style if needed.
    We’ll use the bar with bound data in [Figure A-5](#d3bar_console_db) and set the
    name using the `key` property of its bound data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_d3__8217_s_enter_exit_pattern_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: All D3 setter methods can take a function as their second argument. This function
    receives the data (`d`) bound to the selected element and its position in the
    data array (`i`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_d3__8217_s_enter_exit_pattern_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We use a regular expression (regex) to replace all spaces in the key with underscores
    (e.g., United States → United_States).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_d3__8217_s_enter_exit_pattern_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This will set the bar’s `name` attribute to `'bar__United_States'`.
  prefs: []
  type: TYPE_NORMAL
- en: All the setter methods listed in [Figure 17-3](ch17.xhtml#d3bar_selects) (`attr`,
    `style`, `text`, etc.) can take a function as a second argument, which will receive
    data bound to the element and the element’s array index. The return of this function
    is used to set the value of the property. As we’ll see, interactive visualizations’
    changes to the visualized dataset will be reflected when we bind the new data
    and then use these functional setters to adapt attributes, styles, and properties
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 aa05](assets/dpj2_aa05.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A-5\. Using the Chrome console to show the addition of a `__data__` object
    after data binding using D3’s `data` method
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
