<html><head></head><body><section data-pdf-bookmark="Chapter 12. Inferring mRNA from Protein: Products and Reductions of Lists" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch12">&#13;
<h1><span class="label">Chapter 12. </span>Inferring mRNA from Protein: <span class="keep-together">Products and Reductions of Lists</span></h1>&#13;
&#13;
&#13;
<p>As described in <a href="https://oreil.ly/ZYelo">the Rosalind mRNA challenge</a>, the goal of this program is to find the number of mRNA strings that could produce a given protein sequence.<a data-primary="proteins" data-secondary="mRNA strings inferred from" data-tertiary="about" data-type="indexterm" id="idm45963629860184"/><a data-primary="mRNA" data-secondary="inferring mRNA strings from protein" data-tertiary="about" data-type="indexterm" id="idm45963629858952"/>&#13;
You’ll see that this number can become exceedingly large, so the final answer will be the remainder after dividing by a given value.&#13;
I hope to show that I can turn the tables on regular expressions by trying to generate all the strings that could be matched by a particular pattern.&#13;
I’ll also show how to create the products of numbers and lists as well as how to <em>reduce</em> any list of values to a single value, and along the way I’ll talk about some memory issues that can cause problems.</p>&#13;
&#13;
<p>You will learn:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>How to use the <code>functools.reduce()</code> function to create a mathematical <span class="keep-together"><code>product()</code></span> function for multiplying numbers</p>&#13;
</li>&#13;
<li>&#13;
<p>How to use Python’s modulo (<code>%</code>) operator</p>&#13;
</li>&#13;
<li>&#13;
<p>About buffer overflow problems</p>&#13;
</li>&#13;
<li>&#13;
<p>What monoids are</p>&#13;
</li>&#13;
<li>&#13;
<p>How to reverse a dictionary by flipping the keys and values</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Getting Started" data-type="sect1"><div class="sect1" id="idm45963629849272">&#13;
<h1>Getting Started</h1>&#13;
&#13;
<p>You should work in the <em>12_mrna</em> directory of the repository.<a data-primary="proteins" data-secondary="mRNA strings inferred from" data-tertiary="getting started" data-type="indexterm" id="idm45963629847512"/><a data-primary="mRNA" data-secondary="inferring mRNA strings from protein" data-tertiary="getting started" data-type="indexterm" id="idm45963629846280"/>&#13;
Begin by copying the first solution to the program <code>mrna.py</code>:</p>&#13;
&#13;
<pre data-type="programlisting">$ cd 12_mrna/&#13;
$ cp solution1_dict.py mrna.py</pre>&#13;
&#13;
<p>As usual, inspect the usage first:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./mrna.py -h&#13;
usage: mrna.py [-h] [-m int] protein&#13;
&#13;
Inferring mRNA from Protein&#13;
&#13;
positional arguments:&#13;
  protein               Input protein or file <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO1-1" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO1-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
optional arguments:&#13;
  -h, --help            show this help message and exit&#13;
  -m int, --modulo int  Modulo value (default: 1000000) <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO1-2" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO1-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO1-1" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The required positional argument is a protein sequence or a file containing a protein sequence.</p></dd>&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO1-2" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The <code>--modulo</code> option defaults to 1,000,000.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Run the program with the Rosalind example of <em>MA</em> and verify that it prints <code>12</code>, the number of possible mRNA sequences modulo 1,000,000 that could encode this protein sequence:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./mrna.py MA&#13;
12</pre>&#13;
&#13;
<p>The program will also read an input file for the sequence.&#13;
The first input file has a sequence that is 998 residues long, and the result should be <code>448832</code>:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./mrna.py tests/inputs/1.txt&#13;
448832</pre>&#13;
&#13;
<p>Run the program with other inputs and also execute the tests with <strong><code>make test</code></strong>.&#13;
When you are satisfied you understand how the program should work, start over:</p>&#13;
&#13;
<pre data-type="programlisting">$ new.py -fp 'Infer mRNA from Protein' mrna.py&#13;
Done, see new script "mrna.py".</pre>&#13;
&#13;
<p>Define the parameters as described in the usage.&#13;
The protein may be a string or a filename, but I chose to model the parameter as a string.&#13;
If the user provides a file, I will read the contents and pass this to the program as I first demonstrated in <a data-type="xref" href="ch03.html#ch03">Chapter 3</a>:</p>&#13;
&#13;
<pre data-type="programlisting">class Args(NamedTuple):&#13;
    """ Command-line arguments """&#13;
    protein: str <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-1" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-1"><img alt="1" src="assets/1.png"/></a>&#13;
    modulo: int <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-2" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-2"><img alt="2" src="assets/2.png"/></a>&#13;
&#13;
&#13;
def get_args() -&gt; Args:&#13;
    """ Get command-line arguments """&#13;
&#13;
    parser = argparse.ArgumentParser(&#13;
        description='Infer mRNA from Protein',&#13;
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)&#13;
&#13;
    parser.add_argument('protein', <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-1" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-3"><img alt="1" src="assets/1.png"/></a>&#13;
                        metavar='protein',&#13;
                        type=str,&#13;
                        help='Input protein or file')&#13;
&#13;
    parser.add_argument('-m', <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-2" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-4"><img alt="2" src="assets/2.png"/></a>&#13;
                        '--modulo',&#13;
                        metavar='int',&#13;
                        type=int,&#13;
                        default=1000000,&#13;
                        help='Modulo value')&#13;
&#13;
    args = parser.parse_args()&#13;
&#13;
    if os.path.isfile(args.protein): <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-3" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-5"><img alt="3" src="assets/3.png"/></a>&#13;
        args.protein = open(args.protein).read().rstrip()&#13;
&#13;
    return Args(args.protein, args.modulo)</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-1" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The required <code>protein</code> argument should be a string which may be a filename.</p></dd>&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-2" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The <code>modulo</code> option is an integer that will default to <code>1000000</code>.</p></dd>&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-5" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>If the <code>protein</code> argument names an existing file, read the protein sequence from the file.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Change your <code>main()</code> to print the protein sequence:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    print(args.protein)</pre>&#13;
&#13;
<p>Verify that your program prints the protein both from the command line and a file:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./mrna.py MA&#13;
MA&#13;
$ ./mrna.py tests/inputs/1.txt | wc -c <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO3-1" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO3-1"><img alt="1" src="assets/1.png"/></a>&#13;
  998</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO3-1" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The <code>-c</code> option to <code>wc</code> indicates I only want a count of the number of <em>characters</em> in the input.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Your program should pass the first two tests and fail the third.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating the Product of Lists" data-type="sect2"><div class="sect2" id="idm45963629791432">&#13;
<h2>Creating the Product of Lists</h2>&#13;
&#13;
<p>When the input is <em>MA</em>, the program should print the response <code>12</code>, which is the number of possible mRNA strings that could have produced this protein sequence, as shown in <a data-type="xref" href="#fig_12.1">Figure 12-1</a>.<a data-primary="proteins" data-secondary="mRNA strings inferred from" data-tertiary="product of codon–amino acid lists" data-type="indexterm" id="ch12-prodobj"/><a data-primary="lists" data-secondary="product of" data-type="indexterm" id="ch12-prodobj2"/><a data-primary="mRNA" data-secondary="inferring mRNA strings from protein" data-tertiary="product of codon–amino acid lists" data-type="indexterm" id="ch12-prodobj3"/>&#13;
Using the same RNA encoding table from <a data-type="xref" href="ch07.html#ch07">Chapter 7</a>, I see that the amino acid methionine (<em>M</em>) is encoded by the mRNA codon sequence <em>AUG</em>,<sup><a data-type="noteref" href="ch12.html#idm45963629782024" id="idm45963629782024-marker">1</a></sup> alanine (<em>A</em>) has four possible codons (<em>GCA</em>, <em>GCC</em>, <em>GCG</em>, <em>GCU</em>), and the stop codon has three (<em>UAA</em>, <em>UAG</em>, <em>UGA</em>).&#13;
The product of these three groups is 1 × 4 × 3 = 12.</p>&#13;
&#13;
<figure><div class="figure" id="fig_12.1">&#13;
<img alt="mpfb 1201" src="assets/mpfb_1201.png"/>&#13;
<h6><span class="label">Figure 12-1. </span>The Cartesian product of all the codons that encode the protein sequence MA results in 12 mRNA sequences</h6>&#13;
</div></figure>&#13;
&#13;
<p>In <a data-type="xref" href="ch09.html#ch09">Chapter 9</a>, I introduced the <code>itertools.product()</code> function that will generate the Cartesian product from lists of values.<a data-primary="product() function" data-type="indexterm" id="idm45963629773624"/>&#13;
I can produce all possible combinations of the 12 codons in the REPL like so:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from itertools import product&#13;
&gt;&gt;&gt; from pprint import pprint&#13;
&gt;&gt;&gt; combos = product(*codons)</pre>&#13;
&#13;
<p>If you try printing <code>combos</code> to see the contents, you’ll see it’s not a list of values but a <em>product object</em>.<a data-primary="product object" data-type="indexterm" id="idm45963629770536"/><a data-primary="lazy object product object" data-type="indexterm" id="idm45963629769864"/>&#13;
That is, this is another lazy object that will wait to produce the values until you need them:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; pprint(combos)&#13;
&lt;itertools.product object at 0x7fbdd822dac0&gt;</pre>&#13;
&#13;
<p>I can use the <code>list()</code> function to coerce the values:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; pprint(list(combos))&#13;
[('AUG', 'GCA', 'UAA'),&#13;
 ('AUG', 'GCA', 'UAG'),&#13;
 ('AUG', 'GCA', 'UGA'),&#13;
 ('AUG', 'GCC', 'UAA'),&#13;
 ('AUG', 'GCC', 'UAG'),&#13;
 ('AUG', 'GCC', 'UGA'),&#13;
 ('AUG', 'GCG', 'UAA'),&#13;
 ('AUG', 'GCG', 'UAG'),&#13;
 ('AUG', 'GCG', 'UGA'),&#13;
 ('AUG', 'GCU', 'UAA'),&#13;
 ('AUG', 'GCU', 'UAG'),&#13;
 ('AUG', 'GCU', 'UGA')]</pre>&#13;
&#13;
<p>I want to show you a sneaky little bug waiting for you.&#13;
Try printing the combos again:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; pprint(list(combos))&#13;
[]</pre>&#13;
&#13;
<p>This product object, like a generator, will yield the values only once and then will be exhausted.&#13;
All subsequent calls will produce an empty list.&#13;
To save the results, I need to save the coerced list to a variable:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; combos = list(product(*codons))</pre>&#13;
&#13;
<p>The length of this product is <code>12</code>, meaning there are 12 ways to combine those amino acids to produce the sequence <em>MA</em>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; len(combos)&#13;
12</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Avoiding Overflow with Modular Multiplication" data-type="sect2"><div class="sect2" id="idm45963629761144">&#13;
<h2>Avoiding Overflow with Modular Multiplication</h2>&#13;
&#13;
<p>As the length of the input protein sequence grows, the number of possible combinations will grow extremely large.<a data-primary="proteins" data-secondary="mRNA strings inferred from" data-tertiary="modular multiplication" data-type="indexterm" id="idm45963629759720"/><a data-primary="modular multiplication" data-type="indexterm" id="idm45963629758488"/><a data-primary="memory issues" data-secondary="protein sequences" data-type="indexterm" id="idm45963629757816"/><a data-primary="proteins" data-secondary="mRNA strings inferred from" data-tertiary="memory issues" data-type="indexterm" id="idm45963629756872"/><a data-primary="integers (int)" data-secondary="limits" data-tertiary="modular multiplication" data-type="indexterm" id="idm45963629755640"/><a data-primary="memory issues" data-secondary="numpy.prod() should be avoided" data-type="indexterm" id="idm45963629754424"/><a data-primary="mRNA" data-secondary="inferring mRNA strings from protein" data-tertiary="memory issues" data-type="indexterm" id="idm45963629753464"/><a data-primary="mRNA" data-secondary="inferring mRNA strings from protein" data-tertiary="modular multiplication" data-type="indexterm" id="idm45963629752232"/>&#13;
For example, the second test uses a protein with a file of 998 residues, resulting in approximately 8.98 × 10<sup>29</sup> putative mRNA sequences.&#13;
The Rosalind challenge notes:</p>&#13;
<blockquote>&#13;
<p>Because of memory considerations, most data formats that are built into languages have upper bounds on how large an integer can be: in some versions of Python, an <code>int</code> variable may be required to be no larger than 2<sup>31</sup>−1, or 2,147,483,647.<a data-primary="Python" data-secondary="integer limit" data-type="indexterm" id="idm45963629748456"/><a data-primary="integers (int)" data-secondary="limits" data-type="indexterm" id="idm45963629747512"/> As a result, to deal with very large numbers in Rosalind, we need to devise a system that allows us to manipulate large numbers without actually having to store large numbers.</p></blockquote>&#13;
&#13;
<p>Very large numbers pose the risk of exceeding the memory limitations for the size of an integer, especially on older 32-bit systems.&#13;
To avoid this, the final answer should be the number of combinations <em>modulo</em> 1,000,000.<a data-primary="modulo (%)" data-type="indexterm" id="idm45963629745160"/><a data-primary="% (modulo)" data-primary-sortas="# modulo" data-type="indexterm" id="idm45963629744488"/>&#13;
The modulo operation returns the remainder when one number is divided by another.&#13;
For example, 5 modulo 2 = 1 because 5 divided by 2 is 2 with a remainder of 1.&#13;
Python has the <code>%</code> operator to compute the modulo:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; 5 % 2&#13;
1</pre>&#13;
&#13;
<p>The answer for the 998-residue protein is 448,832, which is the remainder after dividing 8.98 × 10<sup>29</sup> by 1,000,000:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./mrna.py tests/inputs/1.txt&#13;
448832</pre>&#13;
&#13;
<p>In <a data-type="xref" href="ch05.html#ch05">Chapter 5</a>, I introduce the NumPy module for mathematical operations.&#13;
As you might expect, there is a <code>numpy.prod()</code> function that will compute the product of a list of numbers.<a data-primary="NumPy module" data-secondary="product of list of numbers" data-type="indexterm" id="idm45963629738472"/><a data-primary="prod() function" data-secondary="numpy.prod() should be avoided" data-type="indexterm" id="idm45963629737512"/><a data-primary="NumPy module" data-secondary="prod() should be avoided" data-type="indexterm" id="idm45963629736552"/>&#13;
Unfortunately, it can quietly fail and return <code>0</code> when I try to compute something as large as the factorial of 1,000:<a data-primary="NumPy module" data-secondary="product of list of numbers" data-tertiary="buffer overflow" data-type="indexterm" id="idm45963629734904"/><a data-primary="errors" data-secondary="buffer overflow" data-type="indexterm" id="idm45963629733672"/><a data-primary="buffer overflow error" data-type="indexterm" id="idm45963629732728"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import numpy as np&#13;
&gt;&gt;&gt; np.prod(range(1, 1001))&#13;
0</pre>&#13;
&#13;
<p>The problem here is that NumPy is implemented in C, which is faster than Python, and the C code tries to store a larger number than will fit into the memory available for an integer.&#13;
The unfortunate result is <code>0</code>.&#13;
It’s common to call this type of error a <em>buffer overflow</em>, where here the buffer is an integer variable but it could be a string, floating-point number, list, or any other container.&#13;
Generally speaking, Python programmers don’t have to worry about memory allocations the way programmers do in other languages, but here I must be aware of the limitations of the underlying library.&#13;
Because the maximum size of an <code>int</code> can differ depending on the machine, <code>numpy.prod()</code> is an unreliable solution and should be avoided.</p>&#13;
&#13;
<p>Since Python 3.8, there exists a <code>math.prod()</code> function that can calculate incredibly large products such as the factorial of 1,000.<a data-primary="prod() function" data-secondary="math.prod() handles large numbers" data-type="indexterm" id="idm45963629727480"/>&#13;
This is because all the computation happens inside Python, and integers in Python are virtually <em>unbounded</em>, meaning they are limited only by the available memory on your machine.&#13;
Try running this on your computer:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import math&#13;
&gt;&gt;&gt; math.prod(range(1, 1001))</pre>&#13;
&#13;
<p>Notice, however, the result is <code>0</code> when I apply the modulo operation:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; math.prod(range(1, 1001)) % 1000000&#13;
0</pre>&#13;
&#13;
<p>Once again, I’ve bumped up against an overflow that quietly fails, this one due to Python’s use of a <code>float</code> in the division operation, which is a bounded type.&#13;
For the provided tests, you should not encounter a problem if you use <code>math.prod()</code> and modulo the results.<a data-startref="ch12-prodobj" data-type="indexterm" id="idm45963629721736"/><a data-startref="ch12-prodobj2" data-type="indexterm" id="idm45963629721064"/><a data-startref="ch12-prodobj3" data-type="indexterm" id="idm45963629720392"/>&#13;
In the solutions, I will show a way to compute the product of an arbitrarily large set of numbers using the modulo operation to avoid integer overflow.&#13;
This should be enough for you to solve the problem.&#13;
Keep working until your program passes all the tests.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solutions" data-type="sect1"><div class="sect1" id="idm45963629718840">&#13;
<h1>Solutions</h1>&#13;
&#13;
<p>I present three solutions that mostly differ in the structure of a dictionary used to represent the RNA translation information and in how to compute the mathematical product of a list of numbers.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 1: Using a Dictionary for the RNA Codon Table" data-type="sect2"><div class="sect2" id="idm45963629717208">&#13;
<h2>Solution 1: Using a Dictionary for the RNA Codon Table</h2>&#13;
&#13;
<p>For my first solution, I used the RNA codon table from <a data-type="xref" href="ch07.html#ch07">Chapter 7</a> to find the number of codons for each residue:<a data-primary="proteins" data-secondary="mRNA strings inferred from" data-tertiary="solution 1 mRNA codon table" data-type="indexterm" id="ch12-dict"/><a data-primary="mRNA" data-secondary="amino acid–codon table" data-type="indexterm" id="ch12-dict2"/><a data-primary="mRNA" data-secondary="codons" data-tertiary="amino acid–codon table" data-type="indexterm" id="ch12-dict3"/><a data-primary="mRNA" data-secondary="inferring mRNA strings from protein" data-tertiary="solution 1 mRNA codon table" data-type="indexterm" id="ch12-dict4"/><a data-primary="proteins" data-secondary="amino acid–codon table" data-type="indexterm" id="ch12-dict5"/><a data-primary="amino acid–codon table" data-type="indexterm" id="ch12-dict6"/><a data-primary="codons" data-secondary="amino acid–codon table" data-type="indexterm" id="ch12-dict7"/><a data-primary="translating mRNA into protein" data-secondary="codons" data-tertiary="amino acids from" data-type="indexterm" id="ch12-dict8"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; c2aa = {&#13;
...     'AAA': 'K', 'AAC': 'N', 'AAG': 'K', 'AAU': 'N', 'ACA': 'T',&#13;
...     'ACC': 'T', 'ACG': 'T', 'ACU': 'T', 'AGA': 'R', 'AGC': 'S',&#13;
...     'AGG': 'R', 'AGU': 'S', 'AUA': 'I', 'AUC': 'I', 'AUG': 'M',&#13;
...     'AUU': 'I', 'CAA': 'Q', 'CAC': 'H', 'CAG': 'Q', 'CAU': 'H',&#13;
...     'CCA': 'P', 'CCC': 'P', 'CCG': 'P', 'CCU': 'P', 'CGA': 'R',&#13;
...     'CGC': 'R', 'CGG': 'R', 'CGU': 'R', 'CUA': 'L', 'CUC': 'L',&#13;
...     'CUG': 'L', 'CUU': 'L', 'GAA': 'E', 'GAC': 'D', 'GAG': 'E',&#13;
...     'GAU': 'D', 'GCA': 'A', 'GCC': 'A', 'GCG': 'A', 'GCU': 'A',&#13;
...     'GGA': 'G', 'GGC': 'G', 'GGG': 'G', 'GGU': 'G', 'GUA': 'V',&#13;
...     'GUC': 'V', 'GUG': 'V', 'GUU': 'V', 'UAC': 'Y', 'UAU': 'Y',&#13;
...     'UCA': 'S', 'UCC': 'S', 'UCG': 'S', 'UCU': 'S', 'UGC': 'C',&#13;
...     'UGG': 'W', 'UGU': 'C', 'UUA': 'L', 'UUC': 'F', 'UUG': 'L',&#13;
...     'UUU': 'F', 'UAA': '*', 'UAG': '*', 'UGA': '*',&#13;
... }</pre>&#13;
&#13;
<p>I want to iterate over each amino acid in the protein sequence <em>MA</em> plus the stop codon to find all the encoding codons.&#13;
Note that sequences from Rosalind do not terminate with the stop codon, so I must append <code>*</code>.&#13;
I can use a list comprehension with a guard to express this:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; protein = 'MA'&#13;
&gt;&gt;&gt; for aa in protein + '*':&#13;
...     print(aa, [c for c, res in c2aa.items() if res == aa])&#13;
...&#13;
M ['AUG']&#13;
A ['GCA', 'GCC', 'GCG', 'GCU']&#13;
* ['UAA', 'UAG', 'UGA']</pre>&#13;
&#13;
<p>I don’t need the actual list of codons that encode a given residue, only the number which I can find using the <code>len()</code> function:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; possible = [&#13;
...     len([c for c, res in c2aa.items() if res == aa])&#13;
...     for aa in protein + '*'&#13;
... ]&#13;
&gt;&gt;&gt;&#13;
&gt;&gt;&gt; possible&#13;
[1, 4, 3]</pre>&#13;
&#13;
<p>The answer lies in multiplying these values.&#13;
In the previous section, I suggested you could use the <code>math.prod()</code> function:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import math&#13;
&gt;&gt;&gt; math.prod(possible)&#13;
12</pre>&#13;
&#13;
<p>Although this will work perfectly well, I’d like to take this opportunity to talk about <em>reducing</em> a sequence of values to a single value.<a data-primary="reducing sequence of values to single value" data-type="indexterm" id="idm45963629695656"/>&#13;
In <a data-type="xref" href="ch05.html#ch05">Chapter 5</a>, I introduced the <code>sum()</code> function that will add the numbers 1, 4, and 3 to create the result 8:<a data-primary="sum() function" data-type="indexterm" id="idm45963629693464"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; sum(possible)&#13;
8</pre>&#13;
&#13;
<p>It does this in pairs, first adding 1 + 4 to get 5, then adding 5 + 3 to get 8.&#13;
If I change the <code>+</code> operator to <code>*</code>, then I get a product and the result is 12, as shown in <a data-type="xref" href="#fig_12.2">Figure 12-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig_12.2">&#13;
<img alt="mpfb 1202" src="assets/mpfb_1202.png"/>&#13;
<h6><span class="label">Figure 12-2. </span>Reducing a list of numbers using addition and multiplication</h6>&#13;
</div></figure>&#13;
&#13;
<p>This is the idea behind reducing a list of values, and it’s precisely what the <span class="keep-together"><code>functools.reduce()</code></span> function helps us to do.&#13;
This is another higher-order function, like <code>filter()</code> and <code>map()</code> and others I’ve used throughout the book, but with an important difference: the <code>lambda</code> function will receive <em>two</em> arguments instead of only one.&#13;
The documentation shows how to write <code>sum()</code>:</p>&#13;
&#13;
<pre data-type="programlisting">reduce(...)&#13;
    reduce(function, sequence[, initial]) -&gt; value&#13;
&#13;
    Apply a function of two arguments cumulatively to the items of a sequence,&#13;
    from left to right, so as to reduce the sequence to a single value.&#13;
    For example, <strong>reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates&#13;
    ((((1+2)+3)+4)+5)</strong>.  If initial is present, it is placed before the items&#13;
    of the sequence in the calculation, and serves as a default when the&#13;
    sequence is empty.</pre>&#13;
&#13;
<p>Here is how I could use this to write my own version of <code>sum()</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from functools import reduce&#13;
&gt;&gt;&gt; reduce(lambda x, y: x + y, possible)&#13;
8</pre>&#13;
&#13;
<p>To create a product, I can change the addition to multiplication:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; reduce(lambda x, y: x * y, possible)&#13;
12</pre>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45963629679192">&#13;
<h5>Monoids</h5>&#13;
<p>For what it’s worth, a homogeneous list of numbers or strings could be thought of as a <em>monoid</em>, <a data-primary="monoids" data-type="indexterm" id="idm45963629677368"/><a data-primary="lists" data-secondary="monoids" data-type="indexterm" id="idm45963629676696"/><a data-primary="identity element" data-type="indexterm" id="idm45963629675752"/>which is an algebraic structure with a single associative binary operation and an identity element.&#13;
For a list of numbers under addition, the binary operation is <code>+</code>, and the identity element is 0.&#13;
The <em>identity element</em>, or <em>neutral element</em>, is a special value you could combine with another element under the binary operation that leaves the element unchanged.&#13;
Since 0 + <em>n</em> = <em>n</em>, then 0 is the identity element for addition and is the appropriate value for the <em>initial</em> argument to <code>reduce()</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; reduce(lambda x, y: x + y, [1, 2, 3, 4], 0)&#13;
10</pre>&#13;
&#13;
<p>It’s also the appropriate return value when adding an empty list of numbers:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; reduce(lambda x, y: x + y, [], 0)&#13;
0</pre>&#13;
&#13;
<p>Under multiplication, the operator is <code>*</code> and the identity element is 1 because 1 * <em>n</em> = <em>n</em>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; reduce(lambda x, y: x * y, [1, 2, 3, 4], 1)&#13;
24</pre>&#13;
&#13;
<p>The product of an empty list is 1, so this is the correct initial value for <code>reduce()</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; reduce(lambda x, y: x * y, [], 1)&#13;
1</pre>&#13;
&#13;
<p>A list of strings under concatenation would also use <code>+</code>, and the result is a new string:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; reduce(lambda x, y: x + y, ['M', 'A'], '')&#13;
'MA'</pre>&#13;
&#13;
<p>The identity element for strings is the empty string:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; reduce(lambda x, y: x + y, [], '')&#13;
''</pre>&#13;
&#13;
<p>This is the same value returned when passing the empty list to <code>str.join()</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; ''.join([])&#13;
''</pre>&#13;
&#13;
<p>Even lists themselves are monoids.&#13;
They can be combined using the <code>+</code> operator or <code>operator.concat()</code>, and the identity value is the empty list:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; reduce(operator.concat, [['A'], ['list', 'of'], ['values']], [])&#13;
['A', 'list', 'of', 'values']</pre>&#13;
&#13;
<p>These identity values are the defaults for <code>collections.defaultdict()</code>.&#13;
That is, a <code>defaultdict(int)</code> initializes to <code>0</code>, <code>defaultdict(str)</code> uses the empty string, and <code>defaultdict(list)</code> uses the empty list.</p>&#13;
&#13;
<p>Monoids such as these can be reduced to a single value by progressively applying the <em>associative binary operation</em>, hence the name of the <code>reduce()</code> function.&#13;
If you find this kind of theory interesting, you might be interested to learn more about the Haskell programming language and category theory.</p>&#13;
&#13;
<p>Note that Python has an <code>id()</code> function that will “return the identity of an object,” <a data-primary="id() function" data-type="indexterm" id="idm45963629653048"/>which is a unique numerical representation of a value in Python, akin to a memory address, and so is not at all like monoidal identity.</p>&#13;
</div></aside>&#13;
&#13;
<p>I can use <code>functools.reduce()</code> to write my own <code>product()</code> function:</p>&#13;
&#13;
<pre data-type="programlisting">def product(xs: List[int]) -&gt; int: <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO4-1" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO4-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Return the product """&#13;
&#13;
    return reduce(lambda x, y: x * y, xs, 1) <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO4-2" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO4-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO4-1" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Return the product of a list of integers.</p></dd>&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO4-2" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Use the <code>functools.reduce()</code> function to progressively multiply the values. Use <code>1</code> for the initial result to ensure that an empty list returns <code>1</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Why would I do this?&#13;
Intellectual curiosity, for one, but I also want to show how I could use this to write a function that works without relying on Python’s unbounded integers, which this version does.&#13;
To avoid overflowing in any step of the reduction, I need to incorporate the modulo operation into the function itself rather than applying it to the end result.&#13;
Given that I’m not a math wizard, I didn’t know how to write such a function.&#13;
I searched the internet and found some code which I modified into this:</p>&#13;
&#13;
<pre data-type="programlisting">def mulmod(a: int, b: int, mod: int) -&gt; int: <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-1" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Multiplication with modulo """&#13;
&#13;
    def maybemod(x): <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-2" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-2"><img alt="2" src="assets/2.png"/></a>&#13;
        ret = (x % mod) if mod &gt; 1 and x &gt; mod else x&#13;
        return ret or x <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-3" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-3"><img alt="3" src="assets/3.png"/></a>&#13;
&#13;
    res = 0 <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-4" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-4"><img alt="4" src="assets/4.png"/></a>&#13;
    a = maybemod(a) <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-5" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-5"><img alt="5" src="assets/5.png"/></a>&#13;
    while b &gt; 0: <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-6" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-6"><img alt="6" src="assets/6.png"/></a>&#13;
        if b % 2 == 1: <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-7" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-7"><img alt="7" src="assets/7.png"/></a>&#13;
            res = maybemod(res + a) <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-8" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-8"><img alt="8" src="assets/8.png"/></a>&#13;
&#13;
        a = maybemod(a * 2) <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-9" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-9"><img alt="9" src="assets/9.png"/></a>&#13;
        b //= 2 <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-10" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-10"><img alt="10" src="assets/10.png"/></a>&#13;
&#13;
    return res</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-1" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The <code>mulmod()</code> function accepts two integers <code>a</code> and <code>b</code> to multiply with an integer modulo value <code>mod</code>.</p></dd>&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-2" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>This is a closure around the <code>mod</code> value to possibly return a value modulo <code>mod</code>.</p></dd>&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-3" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>If the result is <code>0</code>, return the original value; otherwise, return the computed value.</p></dd>&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-4" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Initialize the result.</p></dd>&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-5" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Possibly reduce the size of <code>a</code>.</p></dd>&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-6" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Loop while <code>b</code> is greater than <code>0</code>.</p></dd>&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-7" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Check if <code>b</code> is an odd number.</p></dd>&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-8" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Add <code>a</code> to the result and possibly modulo the result.</p></dd>&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-9" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-9"><img alt="9" src="assets/9.png"/></a></dt>&#13;
<dd><p>Double <code>a</code> and possibly modulo the value.</p></dd>&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-10" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO5-10"><img alt="10" src="assets/10.png"/></a></dt>&#13;
<dd><p>Halve <code>b</code> using floor division, eventually resulting in <code>0</code> and terminating the loop.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Following is the test I wrote:</p>&#13;
&#13;
<pre data-type="programlisting">def test_mulmod() -&gt; None:&#13;
    """ Text mulmod """&#13;
&#13;
    assert mulmod(2, 4, 3) == 2&#13;
    assert mulmod(9223372036854775807, 9223372036854775807, 1000000) == 501249</pre>&#13;
&#13;
<p>I chose those large numbers because they are the <code>sys.maxsize</code> on my machine:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import sys&#13;
&gt;&gt;&gt; sys.maxsize&#13;
9223372036854775807</pre>&#13;
&#13;
<p>Note that this is the same answer that I can get from <code>math.prod()</code>, but my version does not rely on Python’s dynamic integer sizing and is not tied (as much) to the available memory on my machine:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import math&#13;
&gt;&gt;&gt; math.prod([9223372036854775807, 9223372036854775807]) % 1000000&#13;
501249</pre>&#13;
&#13;
<p>To integrate this, I wrote a <code>modprod()</code> function and added a test as follows:</p>&#13;
&#13;
<pre data-type="programlisting">def modprod(xs: List[int], modulo: int) -&gt; int:&#13;
    """ Return the product modulo a value """&#13;
&#13;
    return reduce(lambda x, y: mulmod(x, y, modulo), xs, 1)&#13;
&#13;
&#13;
def test_modprod() -&gt; None:&#13;
    """ Test modprod """&#13;
&#13;
    assert modprod([], 3) == 1&#13;
    assert modprod([1, 4, 3], 1000000) == 12&#13;
    n = 9223372036854775807&#13;
    assert modprod([n, n], 1000000) == 501249</pre>&#13;
&#13;
<p>Note that it can handle the earlier example of the factorial of 1,000.&#13;
The answer to this is still too large to print, but the point is that the answer is not <code>0</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; modprod(range(1, 1001), 1000000)</pre>&#13;
&#13;
<p>The final answer is the products of these numbers modulo the given argument.&#13;
Here is how I put it all together:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    codon_to_aa = { <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-1" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-1"><img alt="1" src="assets/1.png"/></a>&#13;
        'AAA': 'K', 'AAC': 'N', 'AAG': 'K', 'AAU': 'N', 'ACA': 'T',&#13;
        'ACC': 'T', 'ACG': 'T', 'ACU': 'T', 'AGA': 'R', 'AGC': 'S',&#13;
        'AGG': 'R', 'AGU': 'S', 'AUA': 'I', 'AUC': 'I', 'AUG': 'M',&#13;
        'AUU': 'I', 'CAA': 'Q', 'CAC': 'H', 'CAG': 'Q', 'CAU': 'H',&#13;
        'CCA': 'P', 'CCC': 'P', 'CCG': 'P', 'CCU': 'P', 'CGA': 'R',&#13;
        'CGC': 'R', 'CGG': 'R', 'CGU': 'R', 'CUA': 'L', 'CUC': 'L',&#13;
        'CUG': 'L', 'CUU': 'L', 'GAA': 'E', 'GAC': 'D', 'GAG': 'E',&#13;
        'GAU': 'D', 'GCA': 'A', 'GCC': 'A', 'GCG': 'A', 'GCU': 'A',&#13;
        'GGA': 'G', 'GGC': 'G', 'GGG': 'G', 'GGU': 'G', 'GUA': 'V',&#13;
        'GUC': 'V', 'GUG': 'V', 'GUU': 'V', 'UAC': 'Y', 'UAU': 'Y',&#13;
        'UCA': 'S', 'UCC': 'S', 'UCG': 'S', 'UCU': 'S', 'UGC': 'C',&#13;
        'UGG': 'W', 'UGU': 'C', 'UUA': 'L', 'UUC': 'F', 'UUG': 'L',&#13;
        'UUU': 'F', 'UAA': '*', 'UAG': '*', 'UGA': '*',&#13;
    }&#13;
&#13;
    possible = [ <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-2" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-2"><img alt="2" src="assets/2.png"/></a>&#13;
        len([c for c, res in codon_to_aa.items() if res == aa])&#13;
        for aa in args.protein + '*'&#13;
    ]&#13;
    print(modprod(possible, args.modulo)) <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-3" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-1" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>A dictionary encoding RNA codons to amino acids.</p></dd>&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-2" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Iterate through the residues of the protein plus the stop codon, then find the number of codons matching the given amino acid.</p></dd>&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-3" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO6-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Print the product of the possibilities modulo the given value.<a data-startref="ch12-dict" data-type="indexterm" id="idm45963629555640"/><a data-startref="ch12-dict2" data-type="indexterm" id="idm45963629554968"/><a data-startref="ch12-dict3" data-type="indexterm" id="idm45963629554296"/><a data-startref="ch12-dict4" data-type="indexterm" id="idm45963629553624"/><a data-startref="ch12-dict5" data-type="indexterm" id="idm45963629552952"/><a data-startref="ch12-dict6" data-type="indexterm" id="idm45963629552280"/><a data-startref="ch12-dict7" data-type="indexterm" id="idm45963629551608"/><a data-startref="ch12-dict8" data-type="indexterm" id="idm45963629550936"/></p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 2: Turn the Beat Around" data-type="sect2"><div class="sect2" id="idm45963629549784">&#13;
<h2>Solution 2: Turn the Beat Around</h2>&#13;
&#13;
<p>For this next solution, I decided to reverse the keys and values of the RNA codons dictionary so that the unique amino acids form the keys and the values are the lists of codons.<a data-primary="proteins" data-secondary="mRNA strings inferred from" data-tertiary="solution 2 dictionary flipping" data-type="indexterm" id="idm45963629548312"/><a data-primary="mRNA" data-secondary="inferring mRNA strings from protein" data-tertiary="solution 2 dictionary flipping" data-type="indexterm" id="idm45963629547064"/><a data-primary="dictionaries" data-secondary="flipping key and values" data-type="indexterm" id="idm45963629545816"/>&#13;
It’s handy to know how to flip a dictionary like this, but it only works if the values are unique.<a data-primary="dictionaries" data-secondary="flipping key and values" data-tertiary="values must be unique" data-type="indexterm" id="idm45963629544632"/>&#13;
For instance, I can create a lookup table to go from DNA bases like <em>A</em> or <em>T</em> to their names:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; base_to_name = dict(A='adenine', G='guanine', C='cytosine', T='thymine')&#13;
&gt;&gt;&gt; base_to_name['A']&#13;
'adenine'</pre>&#13;
&#13;
<p>To turn that around so I could go from the name to the base, I can use <code>dict.items()</code> to get the key/value pairs:<a data-primary="dictionaries" data-secondary="items() method" data-type="indexterm" id="idm45963629540536"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(base_to_name.items())&#13;
[('A', 'adenine'), ('G', 'guanine'), ('C', 'cytosine'), ('T', 'thymine')]</pre>&#13;
&#13;
<p>I then <code>map()</code> those through <code>reversed()</code> to flip them, and finally pass the result to the <code>dict()</code> function to create a dictionary:<a data-primary="map() function transforming" data-secondary="flipping dictionary keys and values" data-type="indexterm" id="idm45963629536936"/><a data-primary="reversed() function" data-secondary="flipping dictionary keys and values" data-type="indexterm" id="idm45963629535960"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; dict(map(reversed, base_to_name.items()))&#13;
{'adenine': 'A', 'guanine': 'G', 'cytosine': 'C', 'thymine': 'T'}</pre>&#13;
&#13;
<p>If I try that on the RNA codons table from the first solution, however, I’ll get this:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; pprint(dict(map(reversed, c2aa.items())))&#13;
{'*': 'UGA',&#13;
 'A': 'GCU',&#13;
 'C': 'UGU',&#13;
 'D': 'GAU',&#13;
 'E': 'GAG',&#13;
 'F': 'UUU',&#13;
 'G': 'GGU',&#13;
 'H': 'CAU',&#13;
 'I': 'AUU',&#13;
 'K': 'AAG',&#13;
 'L': 'UUG',&#13;
 'M': 'AUG',&#13;
 'N': 'AAU',&#13;
 'P': 'CCU',&#13;
 'Q': 'CAG',&#13;
 'R': 'CGU',&#13;
 'S': 'UCU',&#13;
 'T': 'ACU',&#13;
 'V': 'GUU',&#13;
 'W': 'UGG',&#13;
 'Y': 'UAU'}</pre>&#13;
&#13;
<p>You can see that I’m missing most of the codons.&#13;
Only <em>M</em> and <em>W</em> have just one codon.&#13;
What happened to the rest?&#13;
When creating the dictionary, Python overwrote any existing values for a key with the newest value.&#13;
In the original table, for instance, <em>UUG</em> was the last value indicated for <em>L</em>, so that was the value that was left standing.&#13;
Just remember this trick for reversing dictionary key/values and ensure that the values are unique.<a data-primary="dictionaries" data-secondary="flipping key and values" data-tertiary="values must be unique" data-type="indexterm" id="idm45963629530024"/> For what it’s worth, if I needed to do this, I would use the <code>collections.defaultdict()</code> function:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from collections import defaultdict&#13;
&gt;&gt;&gt; aa2codon = defaultdict(list)&#13;
&gt;&gt;&gt; for k, v in c2aa.items():&#13;
...     aa2codon[v].append(k)&#13;
...&#13;
&gt;&gt;&gt; pprint(aa2codon)&#13;
defaultdict(&lt;class 'list'&gt;,&#13;
            {'*': ['UAA', 'UAG', 'UGA'],&#13;
             'A': ['GCA', 'GCC', 'GCG', 'GCU'],&#13;
             'C': ['UGC', 'UGU'],&#13;
             'D': ['GAC', 'GAU'],&#13;
             'E': ['GAA', 'GAG'],&#13;
             'F': ['UUC', 'UUU'],&#13;
             'G': ['GGA', 'GGC', 'GGG', 'GGU'],&#13;
             'H': ['CAC', 'CAU'],&#13;
             'I': ['AUA', 'AUC', 'AUU'],&#13;
             'K': ['AAA', 'AAG'],&#13;
             'L': ['CUA', 'CUC', 'CUG', 'CUU', 'UUA', 'UUG'],&#13;
             'M': ['AUG'],&#13;
             'N': ['AAC', 'AAU'],&#13;
             'P': ['CCA', 'CCC', 'CCG', 'CCU'],&#13;
             'Q': ['CAA', 'CAG'],&#13;
             'R': ['AGA', 'AGG', 'CGA', 'CGC', 'CGG', 'CGU'],&#13;
             'S': ['AGC', 'AGU', 'UCA', 'UCC', 'UCG', 'UCU'],&#13;
             'T': ['ACA', 'ACC', 'ACG', 'ACU'],&#13;
             'V': ['GUA', 'GUC', 'GUG', 'GUU'],&#13;
             'W': ['UGG'],&#13;
             'Y': ['UAC', 'UAU']})</pre>&#13;
&#13;
<p>This is the data structure I used in the following solution.&#13;
I also show how to use the <code>math.prod()</code> function rather than rolling my own:</p>&#13;
&#13;
<pre data-type="programlisting">def main():&#13;
    args = get_args()&#13;
    aa_to_codon = { <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-1" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-1"><img alt="1" src="assets/1.png"/></a>&#13;
        'A': ['GCA', 'GCC', 'GCG', 'GCU'],&#13;
        'C': ['UGC', 'UGU'],&#13;
        'D': ['GAC', 'GAU'],&#13;
        'E': ['GAA', 'GAG'],&#13;
        'F': ['UUC', 'UUU']&#13;
        'G': ['GGA', 'GGC', 'GGG', 'GGU'],&#13;
        'H': ['CAC', 'CAU'],&#13;
        'I': ['AUA', 'AUC', 'AUU'],&#13;
        'K': ['AAA', 'AAG'],&#13;
        'L': ['CUA', 'CUC', 'CUG', 'CUU', 'UUA', 'UUG'],&#13;
        'M': ['AUG'],&#13;
        'N': ['AAC', 'AAU'],&#13;
        'P': ['CCA', 'CCC', 'CCG', 'CCU'],&#13;
        'Q': ['CAA', 'CAG'],&#13;
        'R': ['AGA', 'AGG', 'CGA', 'CGC', 'CGG', 'CGU'],&#13;
        'S': ['AGC', 'AGU', 'UCA', 'UCC', 'UCG', 'UCU'],&#13;
        'T': ['ACA', 'ACC', 'ACG', 'ACU'],&#13;
        'V': ['GUA', 'GUC', 'GUG', 'GUU'],&#13;
        'W': ['UGG'],&#13;
        'Y': ['UAC', 'UAU'],&#13;
        '*': ['UAA', 'UAG', 'UGA'],&#13;
    }&#13;
&#13;
    possible = [len(aa_to_codon[aa]) for aa in args.protein + '*'] <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-2" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-2"><img alt="2" src="assets/2.png"/></a>&#13;
    print(math.prod(possible) % args.modulo) <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-3" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-1" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Represent the dictionary using the residues as the keys and the codons for the values.</p></dd>&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-2" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Find the number of codons encoding each amino acid in the protein sequence plus the stop codon.</p></dd>&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-3" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO7-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Use <code>math.prod()</code> to calculate the product, then apply the modulo operator.</p></dd>&#13;
</dl>&#13;
&#13;
<p>This version is much shorter and assumes that the machine will have enough memory to compute the product.&#13;
(Python will handle the memory requirements to represent astronomically large numbers.)<a data-primary="memory issues" data-secondary="astronomically large numbers" data-type="indexterm" id="idm45963629507752"/>&#13;
For all the datasets given to me by Rosalind, this was true, but you may one day encounter the need to use something like the <span class="keep-together"><code>mulmod()</code></span> function in your travels.<a data-primary="mulmod() function" data-type="indexterm" id="idm45963629505656"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 3: Encoding the Minimal Information" data-type="sect2"><div class="sect2" id="idm45963629504664">&#13;
<h2>Solution 3: Encoding the Minimal Information</h2>&#13;
&#13;
<p>The previous solution encoded more information than was necessary to find the solution.<a data-primary="proteins" data-secondary="mRNA strings inferred from" data-tertiary="solution 3 lookup table" data-type="indexterm" id="idm45963629503272"/><a data-primary="mRNA" data-secondary="inferring mRNA strings from protein" data-tertiary="solution 3 lookup table" data-type="indexterm" id="idm45963629502040"/>&#13;
Since I only need the <em>number</em> of codons that encode a given amino acid, not the actual list, I could instead create this lookup table:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; codons = {&#13;
...     'A': 4, 'C': 2, 'D': 2, 'E': 2, 'F': 2, 'G': 4, 'H': 2, 'I': 3,&#13;
...     'K': 2, 'L': 6, 'M': 1, 'N': 2, 'P': 4, 'Q': 2, 'R': 6, 'S': 6,&#13;
...     'T': 4, 'V': 4, 'W': 1, 'Y': 2, '*': 3,&#13;
... }</pre>&#13;
&#13;
<p>A list comprehension will return the numbers needed for the product.&#13;
I will use <code>1</code> for the default argument to <code>dict.get()</code> here in case I find a residue not present in my dictionary:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; [codons.get(aa, 1) for aa in 'MA*']&#13;
[1, 4, 3]</pre>&#13;
&#13;
<p>Leading to this code:</p>&#13;
&#13;
<pre data-type="programlisting">def main():&#13;
    args = get_args()&#13;
    codons = { <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-1" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-1"><img alt="1" src="assets/1.png"/></a>&#13;
        'A': 4, 'C': 2, 'D': 2, 'E': 2, 'F': 2, 'G': 4, 'H': 2, 'I': 3,&#13;
        'K': 2, 'L': 6, 'M': 1, 'N': 2, 'P': 4, 'Q': 2, 'R': 6, 'S': 6,&#13;
        'T': 4, 'V': 4, 'W': 1, 'Y': 2, '*': 3,&#13;
    }&#13;
    nums = [codons.get(aa, 1) for aa in args.protein + '*'] <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-2" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-2"><img alt="2" src="assets/2.png"/></a>&#13;
    print(math.prod(nums) % args.modulo) <a class="co" href="#callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-3" id="co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-1" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Encode the number of codons for each amino acid.</p></dd>&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-2" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Find the number of codons for each amino acid plus the stop.</p></dd>&#13;
<dt><a class="co" href="#co_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-3" id="callout_inferring_mrna_from_protein___span_class__keep_together__products_and_reductions_of_lists__span__CO8-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Print the product of the combinations modulo the given value.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Going Further" data-type="sect1"><div class="sect1" id="idm45963629480120">&#13;
<h1>Going Further</h1>&#13;
&#13;
<p>In a sense, I’ve reversed the idea of a regular expression match by creating all the possible strings for a match.&#13;
That is, the 12 patterns that could produce the protein <em>MA</em> are as follows:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./show_patterns.py MA&#13;
    1: AUGGCAUAA&#13;
    2: AUGGCAUAG&#13;
    3: AUGGCAUGA&#13;
    4: AUGGCCUAA&#13;
    5: AUGGCCUAG&#13;
    6: AUGGCCUGA&#13;
    7: AUGGCGUAA&#13;
    8: AUGGCGUAG&#13;
    9: AUGGCGUGA&#13;
   10: AUGGCUUAA&#13;
   11: AUGGCUUAG&#13;
   12: AUGGCUUGA</pre>&#13;
&#13;
<p>Essentially, I could try to use this information to create a single unified regular expression.&#13;
That might not be easy or even possible, but it’s an idea that might help me find a genomic source for a protein.&#13;
For example, the first two sequences differ by their last base.&#13;
The alternation between <em>A</em> and <em>G</em> can be expressed with the character class <code>[AG]</code>:</p>&#13;
<pre>  AUGGCAUAA&#13;
+ AUGGCAUAG&#13;
  ---------&#13;
  AUGGCAUA[AG]</pre>&#13;
&#13;
<p>Could you write a tool that would combine many regular expression patterns into a single one?</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review" data-type="sect1"><div class="sect1" id="idm45963629473848">&#13;
<h1>Review</h1>&#13;
&#13;
<p>Key points from this chapter:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The <code>itertools.product()</code> function will create the Cartesian product of a list of iterables.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>functools.reduce()</code> is a higher-order function that provides a way to combine progressive pairs of elements from an iterable.</p>&#13;
</li>&#13;
<li>&#13;
<p>Python’s <code>%</code> (modulo) operator will return the remainder after division.</p>&#13;
</li>&#13;
<li>&#13;
<p>Homogeneous lists of numbers and strings can be reduced under monoidal operations like addition, multiplication, and concatenation to a single value.</p>&#13;
</li>&#13;
<li>&#13;
<p>A dictionary with unique values can be reversed by flipping the keys and values.</p>&#13;
</li>&#13;
<li>&#13;
<p>The size of integer values in Python is limited only by the available memory.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45963629782024"><sup><a href="ch12.html#idm45963629782024-marker">1</a></sup> While there are other possible start codons, this is the only one considered by the Rosalind problem.</p></div></div></section></body></html>