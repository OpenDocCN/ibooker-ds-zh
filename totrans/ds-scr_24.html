<html><head></head><body><section data-pdf-bookmark="Chapter 23. Recommender Systems" data-type="chapter" epub:type="chapter"><div class="chapter" id="recommender_systems">&#13;
<h1><span class="label">Chapter 23. </span>Recommender Systems</h1>&#13;
&#13;
<blockquote data-type="epigraph" epub:type="epigraph">&#13;
    <p>O nature, nature, why art thou so dishonest, as ever to send men with these false recommendations into the world!</p>&#13;
    <p data-type="attribution">Henry Fielding</p>&#13;
</blockquote>&#13;
&#13;
<p>Another common data problem is producing <em>recommendations</em> of some sort.&#13;
Netflix recommends movies you might want to watch.&#13;
Amazon recommends products you might want to buy.&#13;
Twitter recommends users you might want to follow.&#13;
In this chapter, we’ll look at several ways to use data to make recommendations.</p>&#13;
&#13;
<p>In<a data-primary="recommender systems" data-secondary="dataset of users_interests" data-type="indexterm" id="idm45635712541544"/> particular, we’ll look at the dataset of <code>users_interests</code> that we’ve used before:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">users_interests</code> <code class="o">=</code> <code class="p">[</code>&#13;
    <code class="p">[</code><code class="s2">"Hadoop"</code><code class="p">,</code> <code class="s2">"Big Data"</code><code class="p">,</code> <code class="s2">"HBase"</code><code class="p">,</code> <code class="s2">"Java"</code><code class="p">,</code> <code class="s2">"Spark"</code><code class="p">,</code> <code class="s2">"Storm"</code><code class="p">,</code> <code class="s2">"Cassandra"</code><code class="p">],</code>&#13;
    <code class="p">[</code><code class="s2">"NoSQL"</code><code class="p">,</code> <code class="s2">"MongoDB"</code><code class="p">,</code> <code class="s2">"Cassandra"</code><code class="p">,</code> <code class="s2">"HBase"</code><code class="p">,</code> <code class="s2">"Postgres"</code><code class="p">],</code>&#13;
    <code class="p">[</code><code class="s2">"Python"</code><code class="p">,</code> <code class="s2">"scikit-learn"</code><code class="p">,</code> <code class="s2">"scipy"</code><code class="p">,</code> <code class="s2">"numpy"</code><code class="p">,</code> <code class="s2">"statsmodels"</code><code class="p">,</code> <code class="s2">"pandas"</code><code class="p">],</code>&#13;
    <code class="p">[</code><code class="s2">"R"</code><code class="p">,</code> <code class="s2">"Python"</code><code class="p">,</code> <code class="s2">"statistics"</code><code class="p">,</code> <code class="s2">"regression"</code><code class="p">,</code> <code class="s2">"probability"</code><code class="p">],</code>&#13;
    <code class="p">[</code><code class="s2">"machine learning"</code><code class="p">,</code> <code class="s2">"regression"</code><code class="p">,</code> <code class="s2">"decision trees"</code><code class="p">,</code> <code class="s2">"libsvm"</code><code class="p">],</code>&#13;
    <code class="p">[</code><code class="s2">"Python"</code><code class="p">,</code> <code class="s2">"R"</code><code class="p">,</code> <code class="s2">"Java"</code><code class="p">,</code> <code class="s2">"C++"</code><code class="p">,</code> <code class="s2">"Haskell"</code><code class="p">,</code> <code class="s2">"programming languages"</code><code class="p">],</code>&#13;
    <code class="p">[</code><code class="s2">"statistics"</code><code class="p">,</code> <code class="s2">"probability"</code><code class="p">,</code> <code class="s2">"mathematics"</code><code class="p">,</code> <code class="s2">"theory"</code><code class="p">],</code>&#13;
    <code class="p">[</code><code class="s2">"machine learning"</code><code class="p">,</code> <code class="s2">"scikit-learn"</code><code class="p">,</code> <code class="s2">"Mahout"</code><code class="p">,</code> <code class="s2">"neural networks"</code><code class="p">],</code>&#13;
    <code class="p">[</code><code class="s2">"neural networks"</code><code class="p">,</code> <code class="s2">"deep learning"</code><code class="p">,</code> <code class="s2">"Big Data"</code><code class="p">,</code> <code class="s2">"artificial intelligence"</code><code class="p">],</code>&#13;
    <code class="p">[</code><code class="s2">"Hadoop"</code><code class="p">,</code> <code class="s2">"Java"</code><code class="p">,</code> <code class="s2">"MapReduce"</code><code class="p">,</code> <code class="s2">"Big Data"</code><code class="p">],</code>&#13;
    <code class="p">[</code><code class="s2">"statistics"</code><code class="p">,</code> <code class="s2">"R"</code><code class="p">,</code> <code class="s2">"statsmodels"</code><code class="p">],</code>&#13;
    <code class="p">[</code><code class="s2">"C++"</code><code class="p">,</code> <code class="s2">"deep learning"</code><code class="p">,</code> <code class="s2">"artificial intelligence"</code><code class="p">,</code> <code class="s2">"probability"</code><code class="p">],</code>&#13;
    <code class="p">[</code><code class="s2">"pandas"</code><code class="p">,</code> <code class="s2">"R"</code><code class="p">,</code> <code class="s2">"Python"</code><code class="p">],</code>&#13;
    <code class="p">[</code><code class="s2">"databases"</code><code class="p">,</code> <code class="s2">"HBase"</code><code class="p">,</code> <code class="s2">"Postgres"</code><code class="p">,</code> <code class="s2">"MySQL"</code><code class="p">,</code> <code class="s2">"MongoDB"</code><code class="p">],</code>&#13;
    <code class="p">[</code><code class="s2">"libsvm"</code><code class="p">,</code> <code class="s2">"regression"</code><code class="p">,</code> <code class="s2">"support vector machines"</code><code class="p">]</code>&#13;
<code class="p">]</code></pre>&#13;
&#13;
<p>And we’ll think about the problem of recommending new interests to a user based on her currently specified interests.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Manual Curation" data-type="sect1"><div class="sect1" id="idm45635712644728">&#13;
<h1>Manual Curation</h1>&#13;
&#13;
<p>Before<a data-primary="recommender systems" data-secondary="manual curation" data-type="indexterm" id="idm45635712643560"/> the internet, when you needed book recommendations you would go to the library,&#13;
where a librarian was available to suggest books that were relevant to your interests&#13;
or similar to books you liked.</p>&#13;
&#13;
<p>Given DataSciencester’s limited number of users and interests, it would be easy for you to spend an afternoon manually recommending interests for each user.  But this  method doesn’t scale particularly well, and it’s limited by your personal knowledge and imagination. (Not that I’m suggesting that your personal knowledge and imagination are limited.) So let’s think about what we can do with <em>data</em>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Recommending What’s Popular" data-type="sect1"><div class="sect1" id="idm45635712363608">&#13;
<h1>Recommending What’s Popular</h1>&#13;
&#13;
<p>One<a data-primary="recommender systems" data-secondary="popularity-based" data-type="indexterm" id="idm45635712361880"/><a data-primary="popularity-based recommender systems" data-type="indexterm" id="idm45635712360872"/> easy approach is to simply recommend what’s popular:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">collections</code> <code class="kn">import</code> <code class="n">Counter</code>&#13;
&#13;
<code class="n">popular_interests</code> <code class="o">=</code> <code class="n">Counter</code><code class="p">(</code><code class="n">interest</code>&#13;
                            <code class="k">for</code> <code class="n">user_interests</code> <code class="ow">in</code> <code class="n">users_interests</code>&#13;
                            <code class="k">for</code> <code class="n">interest</code> <code class="ow">in</code> <code class="n">user_interests</code><code class="p">)</code></pre>&#13;
&#13;
<p>which looks like:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="p">[(</code><code class="s1">'Python'</code><code class="p">,</code> <code class="mi">4</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'R'</code><code class="p">,</code> <code class="mi">4</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'Java'</code><code class="p">,</code> <code class="mi">3</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'regression'</code><code class="p">,</code> <code class="mi">3</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'statistics'</code><code class="p">,</code> <code class="mi">3</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'probability'</code><code class="p">,</code> <code class="mi">3</code><code class="p">),</code>&#13;
 <code class="c1"># ...</code>&#13;
<code class="p">]</code></pre>&#13;
&#13;
<p>Having computed this, we can just suggest to a user the most popular interests&#13;
that he’s not already interested in:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">List</code><code class="p">,</code> <code class="n">Tuple</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">most_popular_new_interests</code><code class="p">(</code>&#13;
        <code class="n">user_interests</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="nb">str</code><code class="p">],</code>&#13;
        <code class="n">max_results</code><code class="p">:</code> <code class="nb">int</code> <code class="o">=</code> <code class="mi">5</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">List</code><code class="p">[</code><code class="n">Tuple</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code> <code class="nb">int</code><code class="p">]]:</code>&#13;
    <code class="n">suggestions</code> <code class="o">=</code> <code class="p">[(</code><code class="n">interest</code><code class="p">,</code> <code class="n">frequency</code><code class="p">)</code>&#13;
                   <code class="k">for</code> <code class="n">interest</code><code class="p">,</code> <code class="n">frequency</code> <code class="ow">in</code> <code class="n">popular_interests</code><code class="o">.</code><code class="n">most_common</code><code class="p">()</code>&#13;
                   <code class="k">if</code> <code class="n">interest</code> <code class="ow">not</code> <code class="ow">in</code> <code class="n">user_interests</code><code class="p">]</code>&#13;
    <code class="k">return</code> <code class="n">suggestions</code><code class="p">[:</code><code class="n">max_results</code><code class="p">]</code></pre>&#13;
&#13;
<p>So, if you are user 1, with interests:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="p">[</code><code class="s2">"NoSQL"</code><code class="p">,</code> <code class="s2">"MongoDB"</code><code class="p">,</code> <code class="s2">"Cassandra"</code><code class="p">,</code> <code class="s2">"HBase"</code><code class="p">,</code> <code class="s2">"Postgres"</code><code class="p">]</code></pre>&#13;
&#13;
<p>then we’d recommend you:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="p">[(</code><code class="s1">'Python'</code><code class="p">,</code> <code class="mi">4</code><code class="p">),</code> <code class="p">(</code><code class="s1">'R'</code><code class="p">,</code> <code class="mi">4</code><code class="p">),</code> <code class="p">(</code><code class="s1">'Java'</code><code class="p">,</code> <code class="mi">3</code><code class="p">),</code> <code class="p">(</code><code class="s1">'regression'</code><code class="p">,</code> <code class="mi">3</code><code class="p">),</code> <code class="p">(</code><code class="s1">'statistics'</code><code class="p">,</code> <code class="mi">3</code><code class="p">)]</code></pre>&#13;
&#13;
<p>If you are user 3, who’s already interested in many of those things, you’d instead get:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="p">[(</code><code class="s1">'Java'</code><code class="p">,</code> <code class="mi">3</code><code class="p">),</code> <code class="p">(</code><code class="s1">'HBase'</code><code class="p">,</code> <code class="mi">3</code><code class="p">),</code> <code class="p">(</code><code class="s1">'Big Data'</code><code class="p">,</code> <code class="mi">3</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'neural networks'</code><code class="p">,</code> <code class="mi">2</code><code class="p">),</code> <code class="p">(</code><code class="s1">'Hadoop'</code><code class="p">,</code> <code class="mi">2</code><code class="p">)]</code></pre>&#13;
&#13;
<p>Of course, “lots of people are interested in Python, so maybe you should be too” is not the most compelling sales pitch.  If someone is brand new to our site and we don’t know anything about them, that’s possibly the best we can do.&#13;
Let’s see how we can do better by basing each user’s recommendations on her existing interests.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="User-Based Collaborative Filtering" data-type="sect1"><div class="sect1" id="idm45635712362952">&#13;
<h1>User-Based Collaborative Filtering</h1>&#13;
&#13;
<p>One<a data-primary="recommender systems" data-secondary="user-based collaborative filtering" data-type="indexterm" id="idm45635712022760"/><a data-primary="user-based collaborative filtering" data-type="indexterm" id="idm45635712021784"/> way of taking a user’s interests into account is to look for users who are somehow <em>similar</em> to her, and then suggest the things that those users are interested in.</p>&#13;
&#13;
<p>In order to do that, we’ll need a way to measure how similar two users are.&#13;
Here we’ll use cosine similarity, which we used in <a data-type="xref" href="ch21.html#natural_language_processing">Chapter 21</a>&#13;
to measure how similar two word vectors were.</p>&#13;
&#13;
<p>We’ll apply this to vectors of 0s and 1s, each vector <code>v</code> representing one user’s interests.  <code>v[i]</code> will be 1 if the user specified the <em>i</em>th interest, and 0 otherwise.  Accordingly, “similar users” will mean “users whose interest vectors most nearly point in the same direction.”  Users with identical interests will have similarity 1.  Users with no identical interests will have similarity 0.  Otherwise, the similarity will fall in between, with numbers closer to 1 indicating “very similar” and numbers closer to 0 indicating “not very similar.”</p>&#13;
&#13;
<p>A good place to start is collecting the known interests and (implicitly) assigning indices to them.  We can do this by using a set comprehension to find the unique interests, and then sorting them into a list.  The first interest in the resulting list will be interest 0, and so on:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">unique_interests</code> <code class="o">=</code> <code class="nb">sorted</code><code class="p">({</code><code class="n">interest</code>&#13;
                           <code class="k">for</code> <code class="n">user_interests</code> <code class="ow">in</code> <code class="n">users_interests</code>&#13;
                           <code class="k">for</code> <code class="n">interest</code> <code class="ow">in</code> <code class="n">user_interests</code><code class="p">})</code></pre>&#13;
&#13;
<p>This gives us a list that starts:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">assert</code> <code class="n">unique_interests</code><code class="p">[:</code><code class="mi">6</code><code class="p">]</code> <code class="o">==</code> <code class="p">[</code>&#13;
    <code class="s1">'Big Data'</code><code class="p">,</code>&#13;
    <code class="s1">'C++'</code><code class="p">,</code>&#13;
    <code class="s1">'Cassandra'</code><code class="p">,</code>&#13;
    <code class="s1">'HBase'</code><code class="p">,</code>&#13;
    <code class="s1">'Hadoop'</code><code class="p">,</code>&#13;
    <code class="s1">'Haskell'</code><code class="p">,</code>&#13;
    <code class="c1"># ...</code>&#13;
<code class="p">]</code></pre>&#13;
&#13;
<p>Next we want to produce an “interest” vector of 0s and 1s for each user.&#13;
We just need to iterate over the <code>unique_interests</code> list, substituting a 1 if the user has each interest, and a 0 if not:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">def</code> <code class="nf">make_user_interest_vector</code><code class="p">(</code><code class="n">user_interests</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="nb">str</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="n">List</code><code class="p">[</code><code class="nb">int</code><code class="p">]:</code>&#13;
    <code class="sd">"""</code>&#13;
<code class="sd">    Given a list of interests, produce a vector whose ith element is 1</code>&#13;
<code class="sd">    if unique_interests[i] is in the list, 0 otherwise</code>&#13;
<code class="sd">    """</code>&#13;
    <code class="k">return</code> <code class="p">[</code><code class="mi">1</code> <code class="k">if</code> <code class="n">interest</code> <code class="ow">in</code> <code class="n">user_interests</code> <code class="k">else</code> <code class="mi">0</code>&#13;
            <code class="k">for</code> <code class="n">interest</code> <code class="ow">in</code> <code class="n">unique_interests</code><code class="p">]</code></pre>&#13;
&#13;
<p>And now we can make a list of user interest vectors:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">user_interest_vectors</code> <code class="o">=</code> <code class="p">[</code><code class="n">make_user_interest_vector</code><code class="p">(</code><code class="n">user_interests</code><code class="p">)</code>&#13;
                         <code class="k">for</code> <code class="n">user_interests</code> <code class="ow">in</code> <code class="n">users_interests</code><code class="p">]</code></pre>&#13;
&#13;
<p>Now <code>user_interest_vectors[i][j]</code> equals 1 if user <code>i</code> specified interest <code>j</code>, and 0 otherwise.</p>&#13;
&#13;
<p>Because we have a small dataset, it’s no problem to compute the pairwise similarities between all of our users:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">scratch.nlp</code> <code class="kn">import</code> <code class="n">cosine_similarity</code>&#13;
&#13;
<code class="n">user_similarities</code> <code class="o">=</code> <code class="p">[[</code><code class="n">cosine_similarity</code><code class="p">(</code><code class="n">interest_vector_i</code><code class="p">,</code> <code class="n">interest_vector_j</code><code class="p">)</code>&#13;
                      <code class="k">for</code> <code class="n">interest_vector_j</code> <code class="ow">in</code> <code class="n">user_interest_vectors</code><code class="p">]</code>&#13;
                     <code class="k">for</code> <code class="n">interest_vector_i</code> <code class="ow">in</code> <code class="n">user_interest_vectors</code><code class="p">]</code></pre>&#13;
&#13;
<p>after which <code>user_similarities[i][j]</code> gives us the similarity between users <code>i</code> and <code>j</code>:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="c1"># Users 0 and 9 share interests in Hadoop, Java, and Big Data</code>&#13;
<code class="k">assert</code> <code class="mf">0.56</code> <code class="o">&lt;</code> <code class="n">user_similarities</code><code class="p">[</code><code class="mi">0</code><code class="p">][</code><code class="mi">9</code><code class="p">]</code> <code class="o">&lt;</code> <code class="mf">0.58</code><code class="p">,</code> <code class="s2">"several shared interests"</code>&#13;
&#13;
<code class="c1"># Users 0 and 8 share only one interest: Big Data</code>&#13;
<code class="k">assert</code> <code class="mf">0.18</code> <code class="o">&lt;</code> <code class="n">user_similarities</code><code class="p">[</code><code class="mi">0</code><code class="p">][</code><code class="mi">8</code><code class="p">]</code> <code class="o">&lt;</code> <code class="mf">0.20</code><code class="p">,</code> <code class="s2">"only one shared interest"</code></pre>&#13;
&#13;
<p>In particular, <code>user_similarities[i]</code> is the vector of user <code>i</code>’s similarities to every other user.&#13;
We can use this to write a function that finds the most similar users to a given user.  We’ll make sure&#13;
not to include the user herself, nor any users with zero similarity.  And we’ll sort the results from most similar to least similar:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">def</code> <code class="nf">most_similar_users_to</code><code class="p">(</code><code class="n">user_id</code><code class="p">:</code> <code class="nb">int</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">List</code><code class="p">[</code><code class="n">Tuple</code><code class="p">[</code><code class="nb">int</code><code class="p">,</code> <code class="nb">float</code><code class="p">]]:</code>&#13;
    <code class="n">pairs</code> <code class="o">=</code> <code class="p">[(</code><code class="n">other_user_id</code><code class="p">,</code> <code class="n">similarity</code><code class="p">)</code>                      <code class="c1"># Find other</code>&#13;
             <code class="k">for</code> <code class="n">other_user_id</code><code class="p">,</code> <code class="n">similarity</code> <code class="ow">in</code>                 <code class="c1"># users with</code>&#13;
                <code class="nb">enumerate</code><code class="p">(</code><code class="n">user_similarities</code><code class="p">[</code><code class="n">user_id</code><code class="p">])</code>         <code class="c1"># nonzero</code>&#13;
             <code class="k">if</code> <code class="n">user_id</code> <code class="o">!=</code> <code class="n">other_user_id</code> <code class="ow">and</code> <code class="n">similarity</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">]</code>  <code class="c1"># similarity.</code>&#13;
&#13;
    <code class="k">return</code> <code class="nb">sorted</code><code class="p">(</code><code class="n">pairs</code><code class="p">,</code>                                      <code class="c1"># Sort them</code>&#13;
                  <code class="n">key</code><code class="o">=</code><code class="k">lambda</code> <code class="n">pair</code><code class="p">:</code> <code class="n">pair</code><code class="p">[</code><code class="o">-</code><code class="mi">1</code><code class="p">],</code>                  <code class="c1"># most similar</code>&#13;
                  <code class="n">reverse</code><code class="o">=</code><code class="bp">True</code><code class="p">)</code>                               <code class="c1"># first.</code></pre>&#13;
&#13;
<p>For instance, if we call <code>most_similar_users_to(0)</code> we get:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="p">[(</code><code class="mi">9</code><code class="p">,</code> <code class="mf">0.5669467095138409</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mf">0.3380617018914066</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="mi">8</code><code class="p">,</code> <code class="mf">0.1889822365046136</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="mi">13</code><code class="p">,</code> <code class="mf">0.1690308509457033</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="mi">5</code><code class="p">,</code> <code class="mf">0.1543033499620919</code><code class="p">)]</code></pre>&#13;
&#13;
<p>How do we use this to suggest new interests to a user?&#13;
For each interest, we can just add up the user similarities&#13;
of the other users interested in it:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">collections</code> <code class="kn">import</code> <code class="n">defaultdict</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">user_based_suggestions</code><code class="p">(</code><code class="n">user_id</code><code class="p">:</code> <code class="nb">int</code><code class="p">,</code>&#13;
                           <code class="n">include_current_interests</code><code class="p">:</code> <code class="nb">bool</code> <code class="o">=</code> <code class="bp">False</code><code class="p">):</code>&#13;
    <code class="c1"># Sum up the similarities</code>&#13;
    <code class="n">suggestions</code><code class="p">:</code> <code class="n">Dict</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code> <code class="nb">float</code><code class="p">]</code> <code class="o">=</code> <code class="n">defaultdict</code><code class="p">(</code><code class="nb">float</code><code class="p">)</code>&#13;
    <code class="k">for</code> <code class="n">other_user_id</code><code class="p">,</code> <code class="n">similarity</code> <code class="ow">in</code> <code class="n">most_similar_users_to</code><code class="p">(</code><code class="n">user_id</code><code class="p">):</code>&#13;
        <code class="k">for</code> <code class="n">interest</code> <code class="ow">in</code> <code class="n">users_interests</code><code class="p">[</code><code class="n">other_user_id</code><code class="p">]:</code>&#13;
            <code class="n">suggestions</code><code class="p">[</code><code class="n">interest</code><code class="p">]</code> <code class="o">+=</code> <code class="n">similarity</code>&#13;
&#13;
    <code class="c1"># Convert them to a sorted list</code>&#13;
    <code class="n">suggestions</code> <code class="o">=</code> <code class="nb">sorted</code><code class="p">(</code><code class="n">suggestions</code><code class="o">.</code><code class="n">items</code><code class="p">(),</code>&#13;
                         <code class="n">key</code><code class="o">=</code><code class="k">lambda</code> <code class="n">pair</code><code class="p">:</code> <code class="n">pair</code><code class="p">[</code><code class="o">-</code><code class="mi">1</code><code class="p">],</code>  <code class="c1"># weight</code>&#13;
                         <code class="n">reverse</code><code class="o">=</code><code class="bp">True</code><code class="p">)</code>&#13;
&#13;
    <code class="c1"># And (maybe) exclude already interests</code>&#13;
    <code class="k">if</code> <code class="n">include_current_interests</code><code class="p">:</code>&#13;
        <code class="k">return</code> <code class="n">suggestions</code>&#13;
    <code class="k">else</code><code class="p">:</code>&#13;
        <code class="k">return</code> <code class="p">[(</code><code class="n">suggestion</code><code class="p">,</code> <code class="n">weight</code><code class="p">)</code>&#13;
                <code class="k">for</code> <code class="n">suggestion</code><code class="p">,</code> <code class="n">weight</code> <code class="ow">in</code> <code class="n">suggestions</code>&#13;
                <code class="k">if</code> <code class="n">suggestion</code> <code class="ow">not</code> <code class="ow">in</code> <code class="n">users_interests</code><code class="p">[</code><code class="n">user_id</code><code class="p">]]</code></pre>&#13;
&#13;
<p>If we call <code>user_based_suggestions(0)</code>, the first several suggested interests are:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="p">[(</code><code class="s1">'MapReduce'</code><code class="p">,</code> <code class="mf">0.5669467095138409</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'MongoDB'</code><code class="p">,</code> <code class="mf">0.50709255283711</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'Postgres'</code><code class="p">,</code> <code class="mf">0.50709255283711</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'NoSQL'</code><code class="p">,</code> <code class="mf">0.3380617018914066</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'neural networks'</code><code class="p">,</code> <code class="mf">0.1889822365046136</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'deep learning'</code><code class="p">,</code> <code class="mf">0.1889822365046136</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'artificial intelligence'</code><code class="p">,</code> <code class="mf">0.1889822365046136</code><code class="p">),</code>&#13;
 <code class="c1">#...</code>&#13;
<code class="p">]</code></pre>&#13;
&#13;
<p>These seem like pretty decent suggestions for someone whose stated interests are “Big Data” and database-related. (The weights aren’t intrinsically meaningful; we just use them for ordering.)</p>&#13;
&#13;
<p>This approach doesn’t work as well when the number of items gets very large.  Recall the curse of dimensionality from <a data-type="xref" href="ch12.html#nearest_neighbors">Chapter 12</a>—in large-dimensional vector spaces most vectors are very far apart (and also point in very different directions).  That is, when there are a large number of interests the “most similar users” to a given user might not be similar at all.</p>&#13;
&#13;
<p>Imagine a site like Amazon.com, from which I’ve bought thousands of items over the last couple of decades.  You could attempt to identify similar users to me based on buying patterns, but most likely in all the world there’s no one whose purchase history looks even remotely like mine.  Whoever my “most similar” shopper is, he’s probably not similar to me at all, and his purchases would almost certainly make for lousy recommendations.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Item-Based Collaborative Filtering" data-type="sect1"><div class="sect1" id="idm45635712060536">&#13;
<h1>Item-Based Collaborative Filtering</h1>&#13;
&#13;
<p>An<a data-primary="item-based collaborative filtering" data-type="indexterm" id="idm45635711361976"/><a data-primary="recommender systems" data-secondary="item-based collaborative filtering" data-type="indexterm" id="idm45635711361272"/> alternative approach is to compute similarities between interests directly.&#13;
We can then generate suggestions for each user by aggregating interests&#13;
that are similar to her current interests.</p>&#13;
&#13;
<p>To start with, we’ll want to <em>transpose</em> our user-interest matrix so that rows correspond to interests and columns correspond to users:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">interest_user_matrix</code> <code class="o">=</code> <code class="p">[[</code><code class="n">user_interest_vector</code><code class="p">[</code><code class="n">j</code><code class="p">]</code>&#13;
                         <code class="k">for</code> <code class="n">user_interest_vector</code> <code class="ow">in</code> <code class="n">user_interest_vectors</code><code class="p">]</code>&#13;
                        <code class="k">for</code> <code class="n">j</code><code class="p">,</code> <code class="n">_</code> <code class="ow">in</code> <code class="nb">enumerate</code><code class="p">(</code><code class="n">unique_interests</code><code class="p">)]</code></pre>&#13;
&#13;
<p>What does this look like?  Row <code>j</code> of <code>interest_user_matrix</code> is column <code>j</code> of <code>user_interest_matrix</code>.  That is, it has 1 for each user with that interest and 0 for each user without that interest.</p>&#13;
&#13;
<p>For example, <code>unique_interests[0]</code> is Big Data, and so <code>interest_user_matrix[0]</code> is:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">]</code></pre>&#13;
&#13;
<p>because users 0, 8, and 9 indicated interest in Big Data.</p>&#13;
&#13;
<p>We can now use cosine similarity again. If precisely the same users are interested in two topics, their similarity will be 1.  If no two users are interested in both topics, their similarity will be 0:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">interest_similarities</code> <code class="o">=</code> <code class="p">[[</code><code class="n">cosine_similarity</code><code class="p">(</code><code class="n">user_vector_i</code><code class="p">,</code> <code class="n">user_vector_j</code><code class="p">)</code>&#13;
                          <code class="k">for</code> <code class="n">user_vector_j</code> <code class="ow">in</code> <code class="n">interest_user_matrix</code><code class="p">]</code>&#13;
                         <code class="k">for</code> <code class="n">user_vector_i</code> <code class="ow">in</code> <code class="n">interest_user_matrix</code><code class="p">]</code></pre>&#13;
&#13;
<p>For example, we can find the interests most similar to Big Data (interest 0) using:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">def</code> <code class="nf">most_similar_interests_to</code><code class="p">(</code><code class="n">interest_id</code><code class="p">:</code> <code class="nb">int</code><code class="p">):</code>&#13;
    <code class="n">similarities</code> <code class="o">=</code> <code class="n">interest_similarities</code><code class="p">[</code><code class="n">interest_id</code><code class="p">]</code>&#13;
    <code class="n">pairs</code> <code class="o">=</code> <code class="p">[(</code><code class="n">unique_interests</code><code class="p">[</code><code class="n">other_interest_id</code><code class="p">],</code> <code class="n">similarity</code><code class="p">)</code>&#13;
             <code class="k">for</code> <code class="n">other_interest_id</code><code class="p">,</code> <code class="n">similarity</code> <code class="ow">in</code> <code class="nb">enumerate</code><code class="p">(</code><code class="n">similarities</code><code class="p">)</code>&#13;
             <code class="k">if</code> <code class="n">interest_id</code> <code class="o">!=</code> <code class="n">other_interest_id</code> <code class="ow">and</code> <code class="n">similarity</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">]</code>&#13;
    <code class="k">return</code> <code class="nb">sorted</code><code class="p">(</code><code class="n">pairs</code><code class="p">,</code>&#13;
                  <code class="n">key</code><code class="o">=</code><code class="k">lambda</code> <code class="n">pair</code><code class="p">:</code> <code class="n">pair</code><code class="p">[</code><code class="o">-</code><code class="mi">1</code><code class="p">],</code>&#13;
                  <code class="n">reverse</code><code class="o">=</code><code class="bp">True</code><code class="p">)</code></pre>&#13;
&#13;
<p>which suggests the following similar interests:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="p">[(</code><code class="s1">'Hadoop'</code><code class="p">,</code> <code class="mf">0.8164965809277261</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'Java'</code><code class="p">,</code> <code class="mf">0.6666666666666666</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'MapReduce'</code><code class="p">,</code> <code class="mf">0.5773502691896258</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'Spark'</code><code class="p">,</code> <code class="mf">0.5773502691896258</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'Storm'</code><code class="p">,</code> <code class="mf">0.5773502691896258</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'Cassandra'</code><code class="p">,</code> <code class="mf">0.4082482904638631</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'artificial intelligence'</code><code class="p">,</code> <code class="mf">0.4082482904638631</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'deep learning'</code><code class="p">,</code> <code class="mf">0.4082482904638631</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'neural networks'</code><code class="p">,</code> <code class="mf">0.4082482904638631</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'HBase'</code><code class="p">,</code> <code class="mf">0.3333333333333333</code><code class="p">)]</code></pre>&#13;
&#13;
<p>Now we can create recommendations for a user by summing up the similarities of the interests similar to his:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">def</code> <code class="nf">item_based_suggestions</code><code class="p">(</code><code class="n">user_id</code><code class="p">:</code> <code class="nb">int</code><code class="p">,</code>&#13;
                           <code class="n">include_current_interests</code><code class="p">:</code> <code class="nb">bool</code> <code class="o">=</code> <code class="bp">False</code><code class="p">):</code>&#13;
    <code class="c1"># Add up the similar interests</code>&#13;
    <code class="n">suggestions</code> <code class="o">=</code> <code class="n">defaultdict</code><code class="p">(</code><code class="nb">float</code><code class="p">)</code>&#13;
    <code class="n">user_interest_vector</code> <code class="o">=</code> <code class="n">user_interest_vectors</code><code class="p">[</code><code class="n">user_id</code><code class="p">]</code>&#13;
    <code class="k">for</code> <code class="n">interest_id</code><code class="p">,</code> <code class="n">is_interested</code> <code class="ow">in</code> <code class="nb">enumerate</code><code class="p">(</code><code class="n">user_interest_vector</code><code class="p">):</code>&#13;
        <code class="k">if</code> <code class="n">is_interested</code> <code class="o">==</code> <code class="mi">1</code><code class="p">:</code>&#13;
            <code class="n">similar_interests</code> <code class="o">=</code> <code class="n">most_similar_interests_to</code><code class="p">(</code><code class="n">interest_id</code><code class="p">)</code>&#13;
            <code class="k">for</code> <code class="n">interest</code><code class="p">,</code> <code class="n">similarity</code> <code class="ow">in</code> <code class="n">similar_interests</code><code class="p">:</code>&#13;
                <code class="n">suggestions</code><code class="p">[</code><code class="n">interest</code><code class="p">]</code> <code class="o">+=</code> <code class="n">similarity</code>&#13;
&#13;
    <code class="c1"># Sort them by weight</code>&#13;
    <code class="n">suggestions</code> <code class="o">=</code> <code class="nb">sorted</code><code class="p">(</code><code class="n">suggestions</code><code class="o">.</code><code class="n">items</code><code class="p">(),</code>&#13;
                         <code class="n">key</code><code class="o">=</code><code class="k">lambda</code> <code class="n">pair</code><code class="p">:</code> <code class="n">pair</code><code class="p">[</code><code class="o">-</code><code class="mi">1</code><code class="p">],</code>&#13;
                         <code class="n">reverse</code><code class="o">=</code><code class="bp">True</code><code class="p">)</code>&#13;
&#13;
    <code class="k">if</code> <code class="n">include_current_interests</code><code class="p">:</code>&#13;
        <code class="k">return</code> <code class="n">suggestions</code>&#13;
    <code class="k">else</code><code class="p">:</code>&#13;
        <code class="k">return</code> <code class="p">[(</code><code class="n">suggestion</code><code class="p">,</code> <code class="n">weight</code><code class="p">)</code>&#13;
                <code class="k">for</code> <code class="n">suggestion</code><code class="p">,</code> <code class="n">weight</code> <code class="ow">in</code> <code class="n">suggestions</code>&#13;
                <code class="k">if</code> <code class="n">suggestion</code> <code class="ow">not</code> <code class="ow">in</code> <code class="n">users_interests</code><code class="p">[</code><code class="n">user_id</code><code class="p">]]</code></pre>&#13;
&#13;
<p>For user 0, this generates the following (seemingly reasonable) recommendations:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="p">[(</code><code class="s1">'MapReduce'</code><code class="p">,</code> <code class="mf">1.861807319565799</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'Postgres'</code><code class="p">,</code> <code class="mf">1.3164965809277263</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'MongoDB'</code><code class="p">,</code> <code class="mf">1.3164965809277263</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'NoSQL'</code><code class="p">,</code> <code class="mf">1.2844570503761732</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'programming languages'</code><code class="p">,</code> <code class="mf">0.5773502691896258</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'MySQL'</code><code class="p">,</code> <code class="mf">0.5773502691896258</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'Haskell'</code><code class="p">,</code> <code class="mf">0.5773502691896258</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'databases'</code><code class="p">,</code> <code class="mf">0.5773502691896258</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'neural networks'</code><code class="p">,</code> <code class="mf">0.4082482904638631</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'deep learning'</code><code class="p">,</code> <code class="mf">0.4082482904638631</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'C++'</code><code class="p">,</code> <code class="mf">0.4082482904638631</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'artificial intelligence'</code><code class="p">,</code> <code class="mf">0.4082482904638631</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'Python'</code><code class="p">,</code> <code class="mf">0.2886751345948129</code><code class="p">),</code>&#13;
 <code class="p">(</code><code class="s1">'R'</code><code class="p">,</code> <code class="mf">0.2886751345948129</code><code class="p">)]</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Matrix Factorization" data-type="sect1"><div class="sect1" id="idm45635711363048">&#13;
<h1>Matrix Factorization</h1>&#13;
&#13;
<p>As<a data-primary="recommender systems" data-secondary="matrix factorization" data-type="indexterm" id="RSmatrix23"/><a data-primary="matrix factorization" data-type="indexterm" id="mat23"/> we’ve seen, we can represent our users’ preferences as a&#13;
<code>[num_users, num_items]</code> matrix of 0s and 1s, where the 1s&#13;
represent liked items and the 0s unliked items.</p>&#13;
&#13;
<p>Sometimes you might actually have numeric <em>ratings</em>;&#13;
for example, when you write an Amazon review you&#13;
assign the item a score ranging from 1 to 5 stars.&#13;
You could still represent these by numbers in a&#13;
<code>[num_users, num_items]</code> matrix&#13;
(ignoring for now the problem of what to do about unrated items).</p>&#13;
&#13;
<p>In this section we’ll assume we have such ratings data&#13;
and try to learn a model that can predict the rating&#13;
for a given user and item.</p>&#13;
&#13;
<p>One way of approaching the problem is to assume that every&#13;
user has some latent “type,” which can be represented as a vector&#13;
of numbers, and that each item similarly has some latent “type.”</p>&#13;
&#13;
<p>If the user types are represented as a <code>[num_users, dim]</code> matrix,&#13;
and the transpose of the item types is represented as a&#13;
<code>[dim, num_items]</code> matrix, their product is a&#13;
<code>[num_users, num_items]</code> matrix. Accordingly, one way of&#13;
building such a model is by “factoring” the preferences matrix&#13;
into the product of a user matrix and an item matrix.</p>&#13;
&#13;
<p>(Possibly this idea of latent types reminds you of the word embeddings&#13;
we developed in <a data-type="xref" href="ch21.html#natural_language_processing">Chapter 21</a>. Hold on to that idea.)</p>&#13;
&#13;
<p>Rather than working with our made-up 10-user dataset, we’ll work with<a data-primary="Movie-Lens 100k dataset" data-type="indexterm" id="idm45635710712616"/> the MovieLens 100k dataset, which contains ratings from 0 to 5 for many movies from many users. Each user has only rated a small subset of the movies.&#13;
We’ll use this to try to build a system that can predict the rating&#13;
for any given (user, movie) pair. We’ll train it to predict well&#13;
on the movies each user has rated; hopefully then it will generalize&#13;
to movies the user hasn’t rated.</p>&#13;
&#13;
<p>To start with, let’s acquire the dataset. You can download&#13;
it from <a href="http://files.grouplens.org/datasets/movielens/ml-100k.zip"><em>http://files.grouplens.org/datasets/movielens/ml-100k.zip</em></a>.</p>&#13;
&#13;
<p>Unzip it and extract the files; we’ll only use two of them:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="c1"># This points to the current directory, modify if your files are elsewhere.</code>&#13;
<code class="n">MOVIES</code> <code class="o">=</code> <code class="s2">"u.item"</code>   <code class="c1"># pipe-delimited: movie_id|title|...</code>&#13;
<code class="n">RATINGS</code> <code class="o">=</code> <code class="s2">"u.data"</code>  <code class="c1"># tab-delimited: user_id, movie_id, rating, timestamp</code></pre>&#13;
&#13;
<p>As is often the case, we’ll introduce a <code>NamedTuple</code> to make things&#13;
easier to work with:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">NamedTuple</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">Rating</code><code class="p">(</code><code class="n">NamedTuple</code><code class="p">):</code>&#13;
    <code class="n">user_id</code><code class="p">:</code> <code class="nb">str</code>&#13;
    <code class="n">movie_id</code><code class="p">:</code> <code class="nb">str</code>&#13;
    <code class="n">rating</code><code class="p">:</code> <code class="nb">float</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The movie ID and user IDs are actually integers, but they’re not consecutive, which means if we worked with them as integers we’d end up with a lot of wasted dimensions (unless we renumbered everything). So to keep it simpler we’ll just treat them as strings.</p>&#13;
</div>&#13;
&#13;
<p>Now let’s read in the data and explore it. The movies file is pipe-delimited and has many columns. We only care about the first two, which are the ID and the title:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">import</code> <code class="nn">csv</code>&#13;
<code class="c1"># We specify this encoding to avoid a UnicodeDecodeError.</code>&#13;
<code class="c1"># See: https://stackoverflow.com/a/53136168/1076346.</code>&#13;
<code class="k">with</code> <code class="nb">open</code><code class="p">(</code><code class="n">MOVIES</code><code class="p">,</code> <code class="n">encoding</code><code class="o">=</code><code class="s2">"iso-8859-1"</code><code class="p">)</code> <code class="k">as</code> <code class="n">f</code><code class="p">:</code>&#13;
    <code class="n">reader</code> <code class="o">=</code> <code class="n">csv</code><code class="o">.</code><code class="n">reader</code><code class="p">(</code><code class="n">f</code><code class="p">,</code> <code class="n">delimiter</code><code class="o">=</code><code class="s2">"|"</code><code class="p">)</code>&#13;
    <code class="n">movies</code> <code class="o">=</code> <code class="p">{</code><code class="n">movie_id</code><code class="p">:</code> <code class="n">title</code> <code class="k">for</code> <code class="n">movie_id</code><code class="p">,</code> <code class="n">title</code><code class="p">,</code> <code class="o">*</code><code class="n">_</code> <code class="ow">in</code> <code class="n">reader</code><code class="p">}</code></pre>&#13;
&#13;
<p>The ratings file is tab-delimited and contains four columns for <code>user_id</code>, <code>movie_id</code>, <code>rating</code> (1 to 5), and <code>timestamp</code>. We’ll ignore the timestamp, as we don’t need it:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="c1"># Create a list of [Rating]</code>&#13;
<code class="k">with</code> <code class="nb">open</code><code class="p">(</code><code class="n">RATINGS</code><code class="p">,</code> <code class="n">encoding</code><code class="o">=</code><code class="s2">"iso-8859-1"</code><code class="p">)</code> <code class="k">as</code> <code class="n">f</code><code class="p">:</code>&#13;
    <code class="n">reader</code> <code class="o">=</code> <code class="n">csv</code><code class="o">.</code><code class="n">reader</code><code class="p">(</code><code class="n">f</code><code class="p">,</code> <code class="n">delimiter</code><code class="o">=</code><code class="s2">"</code><code class="se">\t</code><code class="s2">"</code><code class="p">)</code>&#13;
    <code class="n">ratings</code> <code class="o">=</code> <code class="p">[</code><code class="n">Rating</code><code class="p">(</code><code class="n">user_id</code><code class="p">,</code> <code class="n">movie_id</code><code class="p">,</code> <code class="nb">float</code><code class="p">(</code><code class="n">rating</code><code class="p">))</code>&#13;
               <code class="k">for</code> <code class="n">user_id</code><code class="p">,</code> <code class="n">movie_id</code><code class="p">,</code> <code class="n">rating</code><code class="p">,</code> <code class="n">_</code> <code class="ow">in</code> <code class="n">reader</code><code class="p">]</code>&#13;
&#13;
<code class="c1"># 1682 movies rated by 943 users</code>&#13;
<code class="k">assert</code> <code class="nb">len</code><code class="p">(</code><code class="n">movies</code><code class="p">)</code> <code class="o">==</code> <code class="mi">1682</code>&#13;
<code class="k">assert</code> <code class="nb">len</code><code class="p">(</code><code class="nb">list</code><code class="p">({</code><code class="n">rating</code><code class="o">.</code><code class="n">user_id</code> <code class="k">for</code> <code class="n">rating</code> <code class="ow">in</code> <code class="n">ratings</code><code class="p">}))</code> <code class="o">==</code> <code class="mi">943</code></pre>&#13;
&#13;
<p>There’s a lot of interesting exploratory analysis you can do&#13;
on this data; for instance, you might be interested in the average&#13;
ratings for <em>Star Wars</em> movies (the dataset is from 1998, which means it predates <em>The Phantom Menace</em> by a year):</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">import</code> <code class="nn">re</code>&#13;
&#13;
<code class="c1"># Data structure for accumulating ratings by movie_id</code>&#13;
<code class="n">star_wars_ratings</code> <code class="o">=</code> <code class="p">{</code><code class="n">movie_id</code><code class="p">:</code> <code class="p">[]</code>&#13;
                     <code class="k">for</code> <code class="n">movie_id</code><code class="p">,</code> <code class="n">title</code> <code class="ow">in</code> <code class="n">movies</code><code class="o">.</code><code class="n">items</code><code class="p">()</code>&#13;
                     <code class="k">if</code> <code class="n">re</code><code class="o">.</code><code class="n">search</code><code class="p">(</code><code class="s2">"Star Wars|Empire Strikes|Jedi"</code><code class="p">,</code> <code class="n">title</code><code class="p">)}</code>&#13;
&#13;
<code class="c1"># Iterate over ratings, accumulating the Star Wars ones</code>&#13;
<code class="k">for</code> <code class="n">rating</code> <code class="ow">in</code> <code class="n">ratings</code><code class="p">:</code>&#13;
    <code class="k">if</code> <code class="n">rating</code><code class="o">.</code><code class="n">movie_id</code> <code class="ow">in</code> <code class="n">star_wars_ratings</code><code class="p">:</code>&#13;
        <code class="n">star_wars_ratings</code><code class="p">[</code><code class="n">rating</code><code class="o">.</code><code class="n">movie_id</code><code class="p">]</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">rating</code><code class="o">.</code><code class="n">rating</code><code class="p">)</code>&#13;
&#13;
<code class="c1"># Compute the average rating for each movie</code>&#13;
<code class="n">avg_ratings</code> <code class="o">=</code> <code class="p">[(</code><code class="nb">sum</code><code class="p">(</code><code class="n">title_ratings</code><code class="p">)</code> <code class="o">/</code> <code class="nb">len</code><code class="p">(</code><code class="n">title_ratings</code><code class="p">),</code> <code class="n">movie_id</code><code class="p">)</code>&#13;
               <code class="k">for</code> <code class="n">movie_id</code><code class="p">,</code> <code class="n">title_ratings</code> <code class="ow">in</code> <code class="n">star_wars_ratings</code><code class="o">.</code><code class="n">items</code><code class="p">()]</code>&#13;
&#13;
<code class="c1"># And then print them in order</code>&#13;
<code class="k">for</code> <code class="n">avg_rating</code><code class="p">,</code> <code class="n">movie_id</code> <code class="ow">in</code> <code class="nb">sorted</code><code class="p">(</code><code class="n">avg_ratings</code><code class="p">,</code> <code class="n">reverse</code><code class="o">=</code><code class="bp">True</code><code class="p">):</code>&#13;
    <code class="k">print</code><code class="p">(</code><code class="n">f</code><code class="s2">"{avg_rating:.2f} {movies[movie_id]}"</code><code class="p">)</code></pre>&#13;
&#13;
<p>They’re all pretty highly rated:</p>&#13;
&#13;
<pre data-type="programlisting">4.36 Star Wars (1977)&#13;
4.20 Empire Strikes Back, The (1980)&#13;
4.01 Return of the Jedi (1983)</pre>&#13;
&#13;
<p>So let’s try to come up with a model to predict these ratings.&#13;
As a first step, let’s split the ratings data into train,&#13;
validation, and test sets:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">import</code> <code class="nn">random</code>&#13;
<code class="n">random</code><code class="o">.</code><code class="n">seed</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>&#13;
<code class="n">random</code><code class="o">.</code><code class="n">shuffle</code><code class="p">(</code><code class="n">ratings</code><code class="p">)</code>&#13;
&#13;
<code class="n">split1</code> <code class="o">=</code> <code class="nb">int</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">ratings</code><code class="p">)</code> <code class="o">*</code> <code class="mf">0.7</code><code class="p">)</code>&#13;
<code class="n">split2</code> <code class="o">=</code> <code class="nb">int</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">ratings</code><code class="p">)</code> <code class="o">*</code> <code class="mf">0.85</code><code class="p">)</code>&#13;
&#13;
<code class="n">train</code> <code class="o">=</code> <code class="n">ratings</code><code class="p">[:</code><code class="n">split1</code><code class="p">]</code>              <code class="c1"># 70% of the data</code>&#13;
<code class="n">validation</code> <code class="o">=</code> <code class="n">ratings</code><code class="p">[</code><code class="n">split1</code><code class="p">:</code><code class="n">split2</code><code class="p">]</code>   <code class="c1"># 15% of the data</code>&#13;
<code class="n">test</code> <code class="o">=</code> <code class="n">ratings</code><code class="p">[</code><code class="n">split2</code><code class="p">:]</code>               <code class="c1"># 15% of the data</code></pre>&#13;
&#13;
<p>It’s always good to have a simple baseline model&#13;
and make sure that ours does better than that. Here a simple&#13;
baseline model might be “predict the average rating.” We’ll be using mean squared error as our metric, so let’s&#13;
see how the baseline does on our test set:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">avg_rating</code> <code class="o">=</code> <code class="nb">sum</code><code class="p">(</code><code class="n">rating</code><code class="o">.</code><code class="n">rating</code> <code class="k">for</code> <code class="n">rating</code> <code class="ow">in</code> <code class="n">train</code><code class="p">)</code> <code class="o">/</code> <code class="nb">len</code><code class="p">(</code><code class="n">train</code><code class="p">)</code>&#13;
<code class="n">baseline_error</code> <code class="o">=</code> <code class="nb">sum</code><code class="p">((</code><code class="n">rating</code><code class="o">.</code><code class="n">rating</code> <code class="o">-</code> <code class="n">avg_rating</code><code class="p">)</code> <code class="o">**</code> <code class="mi">2</code>&#13;
                     <code class="k">for</code> <code class="n">rating</code> <code class="ow">in</code> <code class="n">test</code><code class="p">)</code> <code class="o">/</code> <code class="nb">len</code><code class="p">(</code><code class="n">test</code><code class="p">)</code>&#13;
&#13;
<code class="c1"># This is what we hope to do better than</code>&#13;
<code class="k">assert</code> <code class="mf">1.26</code> <code class="o">&lt;</code> <code class="n">baseline_error</code> <code class="o">&lt;</code> <code class="mf">1.27</code></pre>&#13;
&#13;
<p>Given our embeddings, the predicted ratings are given by&#13;
the matrix product of the user embeddings and the movie embeddings.&#13;
For a given user and movie, that value is just the dot product&#13;
of the corresponding embeddings.</p>&#13;
&#13;
<p>So let’s start by creating the embeddings.&#13;
We’ll represent them as <code>dict</code>s where the keys are IDs&#13;
and the values are vectors, which will allow us to easily&#13;
retrieve the embedding for a given ID:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">scratch.deep_learning</code> <code class="kn">import</code> <code class="n">random_tensor</code>&#13;
&#13;
<code class="n">EMBEDDING_DIM</code> <code class="o">=</code> <code class="mi">2</code>&#13;
&#13;
<code class="c1"># Find unique ids</code>&#13;
<code class="n">user_ids</code> <code class="o">=</code> <code class="p">{</code><code class="n">rating</code><code class="o">.</code><code class="n">user_id</code> <code class="k">for</code> <code class="n">rating</code> <code class="ow">in</code> <code class="n">ratings</code><code class="p">}</code>&#13;
<code class="n">movie_ids</code> <code class="o">=</code> <code class="p">{</code><code class="n">rating</code><code class="o">.</code><code class="n">movie_id</code> <code class="k">for</code> <code class="n">rating</code> <code class="ow">in</code> <code class="n">ratings</code><code class="p">}</code>&#13;
&#13;
<code class="c1"># Then create a random vector per id</code>&#13;
<code class="n">user_vectors</code> <code class="o">=</code> <code class="p">{</code><code class="n">user_id</code><code class="p">:</code> <code class="n">random_tensor</code><code class="p">(</code><code class="n">EMBEDDING_DIM</code><code class="p">)</code>&#13;
                <code class="k">for</code> <code class="n">user_id</code> <code class="ow">in</code> <code class="n">user_ids</code><code class="p">}</code>&#13;
<code class="n">movie_vectors</code> <code class="o">=</code> <code class="p">{</code><code class="n">movie_id</code><code class="p">:</code> <code class="n">random_tensor</code><code class="p">(</code><code class="n">EMBEDDING_DIM</code><code class="p">)</code>&#13;
                 <code class="k">for</code> <code class="n">movie_id</code> <code class="ow">in</code> <code class="n">movie_ids</code><code class="p">}</code></pre>&#13;
&#13;
<p>By now we should be pretty expert at writing training loops:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">List</code>&#13;
<code class="kn">import</code> <code class="nn">tqdm</code>&#13;
<code class="kn">from</code> <code class="nn">scratch.linear_algebra</code> <code class="kn">import</code> <code class="n">dot</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">loop</code><code class="p">(</code><code class="n">dataset</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">Rating</code><code class="p">],</code>&#13;
         <code class="n">learning_rate</code><code class="p">:</code> <code class="nb">float</code> <code class="o">=</code> <code class="bp">None</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="bp">None</code><code class="p">:</code>&#13;
    <code class="k">with</code> <code class="n">tqdm</code><code class="o">.</code><code class="n">tqdm</code><code class="p">(</code><code class="n">dataset</code><code class="p">)</code> <code class="k">as</code> <code class="n">t</code><code class="p">:</code>&#13;
        <code class="n">loss</code> <code class="o">=</code> <code class="mf">0.0</code>&#13;
        <code class="k">for</code> <code class="n">i</code><code class="p">,</code> <code class="n">rating</code> <code class="ow">in</code> <code class="nb">enumerate</code><code class="p">(</code><code class="n">t</code><code class="p">):</code>&#13;
            <code class="n">movie_vector</code> <code class="o">=</code> <code class="n">movie_vectors</code><code class="p">[</code><code class="n">rating</code><code class="o">.</code><code class="n">movie_id</code><code class="p">]</code>&#13;
            <code class="n">user_vector</code> <code class="o">=</code> <code class="n">user_vectors</code><code class="p">[</code><code class="n">rating</code><code class="o">.</code><code class="n">user_id</code><code class="p">]</code>&#13;
            <code class="n">predicted</code> <code class="o">=</code> <code class="n">dot</code><code class="p">(</code><code class="n">user_vector</code><code class="p">,</code> <code class="n">movie_vector</code><code class="p">)</code>&#13;
            <code class="n">error</code> <code class="o">=</code> <code class="n">predicted</code> <code class="o">-</code> <code class="n">rating</code><code class="o">.</code><code class="n">rating</code>&#13;
            <code class="n">loss</code> <code class="o">+=</code> <code class="n">error</code> <code class="o">**</code> <code class="mi">2</code>&#13;
&#13;
            <code class="k">if</code> <code class="n">learning_rate</code> <code class="ow">is</code> <code class="ow">not</code> <code class="bp">None</code><code class="p">:</code>&#13;
                <code class="c1">#     predicted = m_0 * u_0 + ... + m_k * u_k</code>&#13;
                <code class="c1"># So each u_j enters output with coefficent m_j</code>&#13;
                <code class="c1"># and each m_j enters output with coefficient u_j</code>&#13;
                <code class="n">user_gradient</code> <code class="o">=</code> <code class="p">[</code><code class="n">error</code> <code class="o">*</code> <code class="n">m_j</code> <code class="k">for</code> <code class="n">m_j</code> <code class="ow">in</code> <code class="n">movie_vector</code><code class="p">]</code>&#13;
                <code class="n">movie_gradient</code> <code class="o">=</code> <code class="p">[</code><code class="n">error</code> <code class="o">*</code> <code class="n">u_j</code> <code class="k">for</code> <code class="n">u_j</code> <code class="ow">in</code> <code class="n">user_vector</code><code class="p">]</code>&#13;
&#13;
                <code class="c1"># Take gradient steps</code>&#13;
                <code class="k">for</code> <code class="n">j</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="n">EMBEDDING_DIM</code><code class="p">):</code>&#13;
                    <code class="n">user_vector</code><code class="p">[</code><code class="n">j</code><code class="p">]</code> <code class="o">-=</code> <code class="n">learning_rate</code> <code class="o">*</code> <code class="n">user_gradient</code><code class="p">[</code><code class="n">j</code><code class="p">]</code>&#13;
                    <code class="n">movie_vector</code><code class="p">[</code><code class="n">j</code><code class="p">]</code> <code class="o">-=</code> <code class="n">learning_rate</code> <code class="o">*</code> <code class="n">movie_gradient</code><code class="p">[</code><code class="n">j</code><code class="p">]</code>&#13;
&#13;
            <code class="n">t</code><code class="o">.</code><code class="n">set_description</code><code class="p">(</code><code class="n">f</code><code class="s2">"avg loss: {loss / (i + 1)}"</code><code class="p">)</code></pre>&#13;
&#13;
<p>And now we can train our model (that is, find the optimal embeddings).&#13;
For me it worked best if I decreased the learning rate a little&#13;
each epoch:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">learning_rate</code> <code class="o">=</code> <code class="mf">0.05</code>&#13;
<code class="k">for</code> <code class="n">epoch</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="mi">20</code><code class="p">):</code>&#13;
    <code class="n">learning_rate</code> <code class="o">*=</code> <code class="mf">0.9</code>&#13;
    <code class="k">print</code><code class="p">(</code><code class="n">epoch</code><code class="p">,</code> <code class="n">learning_rate</code><code class="p">)</code>&#13;
    <code class="n">loop</code><code class="p">(</code><code class="n">train</code><code class="p">,</code> <code class="n">learning_rate</code><code class="o">=</code><code class="n">learning_rate</code><code class="p">)</code>&#13;
    <code class="n">loop</code><code class="p">(</code><code class="n">validation</code><code class="p">)</code>&#13;
<code class="n">loop</code><code class="p">(</code><code class="n">test</code><code class="p">)</code></pre>&#13;
&#13;
<p>This model is pretty apt to overfit the training set.&#13;
I got the best results with <code>EMBEDDING_DIM=2</code>,&#13;
which got me an average loss on the test set of about 0.89.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you wanted higher-dimensional embeddings, you could try&#13;
regularization like we used in <a data-type="xref" href="ch15.html#regularization">“Regularization”</a>. In particular,&#13;
at each gradient update you could shrink the weights toward 0.&#13;
I was not able to get any better results that way.</p>&#13;
</div>&#13;
&#13;
<p>Now, inspect the learned vectors. There’s no reason to expect&#13;
the two components to be particularly meaningful, so we’ll use&#13;
principal component analysis:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">scratch.working_with_data</code> <code class="kn">import</code> <code class="n">pca</code><code class="p">,</code> <code class="n">transform</code>&#13;
&#13;
<code class="n">original_vectors</code> <code class="o">=</code> <code class="p">[</code><code class="n">vector</code> <code class="k">for</code> <code class="n">vector</code> <code class="ow">in</code> <code class="n">movie_vectors</code><code class="o">.</code><code class="n">values</code><code class="p">()]</code>&#13;
<code class="n">components</code> <code class="o">=</code> <code class="n">pca</code><code class="p">(</code><code class="n">original_vectors</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code></pre>&#13;
&#13;
<p>Let’s transform our vectors to represent the principal components&#13;
and join in the movie IDs and average ratings:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">ratings_by_movie</code> <code class="o">=</code> <code class="n">defaultdict</code><code class="p">(</code><code class="nb">list</code><code class="p">)</code>&#13;
<code class="k">for</code> <code class="n">rating</code> <code class="ow">in</code> <code class="n">ratings</code><code class="p">:</code>&#13;
    <code class="n">ratings_by_movie</code><code class="p">[</code><code class="n">rating</code><code class="o">.</code><code class="n">movie_id</code><code class="p">]</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">rating</code><code class="o">.</code><code class="n">rating</code><code class="p">)</code>&#13;
&#13;
<code class="n">vectors</code> <code class="o">=</code> <code class="p">[</code>&#13;
    <code class="p">(</code><code class="n">movie_id</code><code class="p">,</code>&#13;
     <code class="nb">sum</code><code class="p">(</code><code class="n">ratings_by_movie</code><code class="p">[</code><code class="n">movie_id</code><code class="p">])</code> <code class="o">/</code> <code class="nb">len</code><code class="p">(</code><code class="n">ratings_by_movie</code><code class="p">[</code><code class="n">movie_id</code><code class="p">]),</code>&#13;
     <code class="n">movies</code><code class="p">[</code><code class="n">movie_id</code><code class="p">],</code>&#13;
     <code class="n">vector</code><code class="p">)</code>&#13;
    <code class="k">for</code> <code class="n">movie_id</code><code class="p">,</code> <code class="n">vector</code> <code class="ow">in</code> <code class="nb">zip</code><code class="p">(</code><code class="n">movie_vectors</code><code class="o">.</code><code class="n">keys</code><code class="p">(),</code>&#13;
                                <code class="n">transform</code><code class="p">(</code><code class="n">original_vectors</code><code class="p">,</code> <code class="n">components</code><code class="p">))</code>&#13;
<code class="p">]</code>&#13;
&#13;
<code class="c1"># Print top 25 and bottom 25 by first principal component</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="nb">sorted</code><code class="p">(</code><code class="n">vectors</code><code class="p">,</code> <code class="n">key</code><code class="o">=</code><code class="k">lambda</code> <code class="n">v</code><code class="p">:</code> <code class="n">v</code><code class="p">[</code><code class="o">-</code><code class="mi">1</code><code class="p">][</code><code class="mi">0</code><code class="p">])[:</code><code class="mi">25</code><code class="p">])</code>&#13;
<code class="k">print</code><code class="p">(</code><code class="nb">sorted</code><code class="p">(</code><code class="n">vectors</code><code class="p">,</code> <code class="n">key</code><code class="o">=</code><code class="k">lambda</code> <code class="n">v</code><code class="p">:</code> <code class="n">v</code><code class="p">[</code><code class="o">-</code><code class="mi">1</code><code class="p">][</code><code class="mi">0</code><code class="p">])[</code><code class="o">-</code><code class="mi">25</code><code class="p">:])</code></pre>&#13;
&#13;
<p>The top 25 are all highly rated, while the bottom 25 are mostly low-rated&#13;
(or unrated in the training data), which suggests that the first principal&#13;
component is mostly capturing “how good is this movie?”</p>&#13;
&#13;
<p>It’s hard for me to make much sense of the second component; and, indeed the two-dimensional embeddings performed only slightly better than the one-dimensional embeddings, suggesting that whatever the second component captured is possibly very subtle. (Presumably one of the larger MovieLens datasets would have more interesting things going on.)<a data-primary="" data-startref="RSmatrix23" data-type="indexterm" id="idm45635709510088"/><a data-primary="" data-startref="mat23" data-type="indexterm" id="idm45635709509240"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before" data-pdf-bookmark="For Further Exploration" data-type="sect1"><div class="sect1" id="idm45635710832872">&#13;
<h1>For Further Exploration</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="http://surpriselib.com/">Surprise</a> is a Python<a data-primary="recommender systems" data-secondary="tools for" data-type="indexterm" id="idm45635709506520"/><a data-primary="Surprise" data-type="indexterm" id="idm45635709505512"/> library for “building and analyzing recommender systems” that seems reasonably popular and up-to-date.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <a href="http://www.netflixprize.com">Netflix Prize</a> was a<a data-primary="Netflix Prize" data-type="indexterm" id="idm45635709503064"/> somewhat famous competition to build a better system to recommend movies to Netflix users.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>