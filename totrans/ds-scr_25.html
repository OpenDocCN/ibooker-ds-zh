<html><head></head><body><section data-pdf-bookmark="Chapter 24. Databases and SQL" data-type="chapter" epub:type="chapter"><div class="chapter" id="databases">&#13;
<h1><span class="label">Chapter 24. </span>Databases and SQL</h1>&#13;
&#13;
<blockquote data-type="epigraph" epub:type="epigraph">&#13;
    <p>Memory is man’s greatest friend and worst enemy.</p>&#13;
    <p data-type="attribution">Gilbert Parker</p>&#13;
</blockquote>&#13;
&#13;
<p>The data you need will often live in <em>databases</em>,&#13;
systems designed for efficiently storing and querying data.&#13;
The<a data-primary="relational databases" data-type="indexterm" id="idm45635709497512"/><a data-primary="Structured Query Language (SQL)" data-type="indexterm" id="idm45635709496808"/><a data-primary="Structured Query Language (SQL)" data-see="also databases and SQL" data-type="indexterm" id="idm45635709496168"/> bulk of these are <em>relational</em> databases, such as PostgreSQL, MySQL, and SQL Server,&#13;
which store data in <em>tables</em> and are typically queried using Structured Query Language (SQL),&#13;
a declarative language for manipulating data.</p>&#13;
&#13;
<p>SQL is a pretty essential part of the data scientist’s toolkit.&#13;
In this chapter, we’ll create NotQuiteABase,&#13;
a Python implementation of something that’s not quite a database.&#13;
We’ll also cover the basics of SQL while showing how they work in our&#13;
not-quite database,&#13;
which is the most “from scratch” way I could think of&#13;
to help you understand what they’re doing.&#13;
My hope is that solving problems in NotQuiteABase will give you a good sense&#13;
of how you might solve the same problems using SQL.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="CREATE TABLE and INSERT" data-type="sect1"><div class="sect1" id="idm45635709493224">&#13;
<h1>CREATE TABLE and INSERT</h1>&#13;
&#13;
<p>A<a data-primary="databases and SQL" data-secondary="CREATE TABLE and INSERT" data-type="indexterm" id="idm45635709491176"/><a data-primary="CREATE TABLE statement" data-type="indexterm" id="idm45635709490168"/><a data-primary="INSERT statement" data-type="indexterm" id="idm45635709489496"/> relational database is a collection of tables, and of relationships among them.&#13;
A table is simply a collection of rows, not unlike some of the matrices we’ve been working with.&#13;
However, a table also has associated with it a fixed <em>schema</em> consisting of&#13;
column names and column types.</p>&#13;
&#13;
<p>For example, imagine a <code>users</code> dataset containing for each user her <code>user_id</code>, <code>name</code>, and <code>num_friends</code>:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">users</code> <code class="o">=</code> <code class="p">[[</code><code class="mi">0</code><code class="p">,</code> <code class="s2">"Hero"</code><code class="p">,</code> <code class="mi">0</code><code class="p">],</code>&#13;
         <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="s2">"Dunn"</code><code class="p">,</code> <code class="mi">2</code><code class="p">],</code>&#13;
         <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="s2">"Sue"</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code>&#13;
         <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="s2">"Chi"</code><code class="p">,</code> <code class="mi">3</code><code class="p">]]</code></pre>&#13;
&#13;
<p>In SQL, we might create this table with:</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="n">users</code> <code class="p">(</code>&#13;
    <code class="n">user_id</code> <code class="nb">INT</code> <code class="k">NOT</code> <code class="k">NULL</code><code class="p">,</code>&#13;
    <code class="n">name</code> <code class="nb">VARCHAR</code><code class="p">(</code><code class="mi">200</code><code class="p">),</code>&#13;
    <code class="n">num_friends</code> <code class="nb">INT</code><code class="p">);</code></pre>&#13;
&#13;
<p>Notice that we specified that the <code>user_id</code> and <code>num_friends</code> must be integers (and that <code>user_id</code> isn’t allowed to be <code>NULL</code>, which indicates a missing value and is sort of like our <code>None</code>) and that the name should be a string of length 200 or less.&#13;
We’ll use Python types in a similar way.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>SQL is almost completely case and indentation insensitive.&#13;
The capitalization and indentation style here is my preferred style.&#13;
If you start learning SQL, you will surely encounter other examples&#13;
styled differently.</p>&#13;
</div>&#13;
&#13;
<p>You can insert the rows with <code>INSERT</code> statements:</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">INSERT</code> <code class="k">INTO</code> <code class="n">users</code> <code class="p">(</code><code class="n">user_id</code><code class="p">,</code> <code class="n">name</code><code class="p">,</code> <code class="n">num_friends</code><code class="p">)</code> <code class="k">VALUES</code> <code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="s1">'Hero'</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code></pre>&#13;
&#13;
<p>Notice also that SQL statements need to end with semicolons, and&#13;
that SQL requires single quotes for its strings.</p>&#13;
&#13;
<p>In NotQuiteABase, you’ll create a <code>Table</code> by specifying a similar schema.&#13;
Then to insert a row, you’ll use the table’s <code>insert</code> method, which takes a <code>list</code> of&#13;
row values that need to be in the same order as the table’s column names.</p>&#13;
&#13;
<p>Behind the scenes, we’ll store each row as a <code>dict</code> from column names to values.&#13;
A real database would never use such a space-wasting representation,&#13;
but doing so will make NotQuiteABase much easier to work with.</p>&#13;
&#13;
<p>We’ll implement the NotQuiteABase <code>Table</code> as a giant class, which we’ll implement&#13;
one method at a time. Let’s start by getting out of the way some imports and&#13;
type aliases:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">Tuple</code><code class="p">,</code> <code class="n">Sequence</code><code class="p">,</code> <code class="n">List</code><code class="p">,</code> <code class="n">Any</code><code class="p">,</code> <code class="n">Callable</code><code class="p">,</code> <code class="n">Dict</code><code class="p">,</code> <code class="n">Iterator</code>&#13;
<code class="kn">from</code> <code class="nn">collections</code> <code class="kn">import</code> <code class="n">defaultdict</code>&#13;
&#13;
<code class="c1"># A few type aliases we'll use later</code>&#13;
<code class="n">Row</code> <code class="o">=</code> <code class="n">Dict</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code> <code class="n">Any</code><code class="p">]</code>                        <code class="c1"># A database row</code>&#13;
<code class="n">WhereClause</code> <code class="o">=</code> <code class="n">Callable</code><code class="p">[[</code><code class="n">Row</code><code class="p">],</code> <code class="nb">bool</code><code class="p">]</code>         <code class="c1"># Predicate for a single row</code>&#13;
<code class="n">HavingClause</code> <code class="o">=</code> <code class="n">Callable</code><code class="p">[[</code><code class="n">List</code><code class="p">[</code><code class="n">Row</code><code class="p">]],</code> <code class="nb">bool</code><code class="p">]</code>  <code class="c1"># Predicate over multiple rows</code></pre>&#13;
&#13;
<p>Let’s start with the constructor.&#13;
To create a NotQuiteABase table, we’ll need to pass in a list of column names,&#13;
and a list of column types, just as you would if you were creating a table&#13;
in a SQL database:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">class</code> <code class="nc">Table</code><code class="p">:</code>&#13;
    <code class="k">def</code> <code class="nf-Magic">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">columns</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="nb">str</code><code class="p">],</code> <code class="n">types</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="nb">type</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="bp">None</code><code class="p">:</code>&#13;
        <code class="k">assert</code> <code class="nb">len</code><code class="p">(</code><code class="n">columns</code><code class="p">)</code> <code class="o">==</code> <code class="nb">len</code><code class="p">(</code><code class="n">types</code><code class="p">),</code> <code class="s2">"# of columns must == # of types"</code>&#13;
&#13;
        <code class="bp">self</code><code class="o">.</code><code class="n">columns</code> <code class="o">=</code> <code class="n">columns</code>         <code class="c1"># Names of columns</code>&#13;
        <code class="bp">self</code><code class="o">.</code><code class="n">types</code> <code class="o">=</code> <code class="n">types</code>             <code class="c1"># Data types of columns</code>&#13;
        <code class="bp">self</code><code class="o">.</code><code class="n">rows</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">Row</code><code class="p">]</code> <code class="o">=</code> <code class="p">[]</code>      <code class="c1"># (no data yet)</code></pre>&#13;
&#13;
<p>We’ll add a helper method to get the type of a column:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting">    <code class="k">def</code> <code class="nf">col2type</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">col</code><code class="p">:</code> <code class="nb">str</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">type</code><code class="p">:</code>&#13;
        <code class="n">idx</code> <code class="o">=</code> <code class="bp">self</code><code class="o">.</code><code class="n">columns</code><code class="o">.</code><code class="n">index</code><code class="p">(</code><code class="n">col</code><code class="p">)</code>      <code class="c1"># Find the index of the column,</code>&#13;
        <code class="k">return</code> <code class="bp">self</code><code class="o">.</code><code class="n">types</code><code class="p">[</code><code class="n">idx</code><code class="p">]</code>             <code class="c1"># and return its type.</code></pre>&#13;
&#13;
<p>And we’ll add an <code>insert</code> method that checks that the values&#13;
you’re inserting are valid. In particular, you have to provide&#13;
the correct number of values, and each has to be the correct type&#13;
(or <code>None</code>):</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting">    <code class="k">def</code> <code class="nf">insert</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">values</code><code class="p">:</code> <code class="nb">list</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="bp">None</code><code class="p">:</code>&#13;
        <code class="c1"># Check for right # of values</code>&#13;
        <code class="k">if</code> <code class="nb">len</code><code class="p">(</code><code class="n">values</code><code class="p">)</code> <code class="o">!=</code> <code class="nb">len</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">types</code><code class="p">):</code>&#13;
            <code class="k">raise</code> <code class="ne">ValueError</code><code class="p">(</code><code class="n">f</code><code class="s2">"You need to provide {len(self.types)} values"</code><code class="p">)</code>&#13;
&#13;
        <code class="c1"># Check for right types of values</code>&#13;
        <code class="k">for</code> <code class="n">value</code><code class="p">,</code> <code class="n">typ3</code> <code class="ow">in</code> <code class="nb">zip</code><code class="p">(</code><code class="n">values</code><code class="p">,</code> <code class="bp">self</code><code class="o">.</code><code class="n">types</code><code class="p">):</code>&#13;
            <code class="k">if</code> <code class="ow">not</code> <code class="nb">isinstance</code><code class="p">(</code><code class="n">value</code><code class="p">,</code> <code class="n">typ3</code><code class="p">)</code> <code class="ow">and</code> <code class="n">value</code> <code class="ow">is</code> <code class="ow">not</code> <code class="bp">None</code><code class="p">:</code>&#13;
                <code class="k">raise</code> <code class="ne">TypeError</code><code class="p">(</code><code class="n">f</code><code class="s2">"Expected type {typ3} but got {value}"</code><code class="p">)</code>&#13;
&#13;
        <code class="c1"># Add the corresponding dict as a "row"</code>&#13;
        <code class="bp">self</code><code class="o">.</code><code class="n">rows</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="nb">dict</code><code class="p">(</code><code class="nb">zip</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">columns</code><code class="p">,</code> <code class="n">values</code><code class="p">)))</code></pre>&#13;
&#13;
<p>In an actual SQL database you’d explicitly specify whether any given&#13;
column was allowed to contain null (<code>None</code>) values; to make our lives&#13;
simpler we’ll just say that any column can.</p>&#13;
&#13;
<p>We’ll also introduce a few dunder methods that allow us to treat a table&#13;
like a <code>List[Row]</code>, which we’ll mostly use for testing our code:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting">    <code class="k">def</code> <code class="nf-Magic">__getitem__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">idx</code><code class="p">:</code> <code class="nb">int</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Row</code><code class="p">:</code>&#13;
        <code class="k">return</code> <code class="bp">self</code><code class="o">.</code><code class="n">rows</code><code class="p">[</code><code class="n">idx</code><code class="p">]</code>&#13;
&#13;
    <code class="k">def</code> <code class="nf-Magic">__iter__</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Iterator</code><code class="p">[</code><code class="n">Row</code><code class="p">]:</code>&#13;
        <code class="k">return</code> <code class="nb">iter</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">rows</code><code class="p">)</code>&#13;
&#13;
    <code class="k">def</code> <code class="nf-Magic">__len__</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">int</code><code class="p">:</code>&#13;
        <code class="k">return</code> <code class="nb">len</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">rows</code><code class="p">)</code></pre>&#13;
&#13;
<p>And we’ll add a method to pretty-print our table:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting">    <code class="k">def</code> <code class="nf-Magic">__repr__</code><code class="p">(</code><code class="bp">self</code><code class="p">):</code>&#13;
        <code class="sd">"""Pretty representation of the table: columns then rows"""</code>&#13;
        <code class="n">rows</code> <code class="o">=</code> <code class="s2">"</code><code class="se">\n</code><code class="s2">"</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="nb">str</code><code class="p">(</code><code class="n">row</code><code class="p">)</code> <code class="k">for</code> <code class="n">row</code> <code class="ow">in</code> <code class="bp">self</code><code class="o">.</code><code class="n">rows</code><code class="p">)</code>&#13;
&#13;
        <code class="k">return</code> <code class="n">f</code><code class="s2">"{self.columns}</code><code class="se">\n</code><code class="s2">{rows}"</code></pre>&#13;
&#13;
<p>Now we can create our <code>Users</code> table:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="c1"># Constructor requires column names and types</code>&#13;
<code class="n">users</code> <code class="o">=</code> <code class="n">Table</code><code class="p">([</code><code class="s1">'user_id'</code><code class="p">,</code> <code class="s1">'name'</code><code class="p">,</code> <code class="s1">'num_friends'</code><code class="p">],</code> <code class="p">[</code><code class="nb">int</code><code class="p">,</code> <code class="nb">str</code><code class="p">,</code> <code class="nb">int</code><code class="p">])</code>&#13;
<code class="n">users</code><code class="o">.</code><code class="n">insert</code><code class="p">([</code><code class="mi">0</code><code class="p">,</code> <code class="s2">"Hero"</code><code class="p">,</code> <code class="mi">0</code><code class="p">])</code>&#13;
<code class="n">users</code><code class="o">.</code><code class="n">insert</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="s2">"Dunn"</code><code class="p">,</code> <code class="mi">2</code><code class="p">])</code>&#13;
<code class="n">users</code><code class="o">.</code><code class="n">insert</code><code class="p">([</code><code class="mi">2</code><code class="p">,</code> <code class="s2">"Sue"</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code>&#13;
<code class="n">users</code><code class="o">.</code><code class="n">insert</code><code class="p">([</code><code class="mi">3</code><code class="p">,</code> <code class="s2">"Chi"</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code>&#13;
<code class="n">users</code><code class="o">.</code><code class="n">insert</code><code class="p">([</code><code class="mi">4</code><code class="p">,</code> <code class="s2">"Thor"</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code>&#13;
<code class="n">users</code><code class="o">.</code><code class="n">insert</code><code class="p">([</code><code class="mi">5</code><code class="p">,</code> <code class="s2">"Clive"</code><code class="p">,</code> <code class="mi">2</code><code class="p">])</code>&#13;
<code class="n">users</code><code class="o">.</code><code class="n">insert</code><code class="p">([</code><code class="mi">6</code><code class="p">,</code> <code class="s2">"Hicks"</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code>&#13;
<code class="n">users</code><code class="o">.</code><code class="n">insert</code><code class="p">([</code><code class="mi">7</code><code class="p">,</code> <code class="s2">"Devin"</code><code class="p">,</code> <code class="mi">2</code><code class="p">])</code>&#13;
<code class="n">users</code><code class="o">.</code><code class="n">insert</code><code class="p">([</code><code class="mi">8</code><code class="p">,</code> <code class="s2">"Kate"</code><code class="p">,</code> <code class="mi">2</code><code class="p">])</code>&#13;
<code class="n">users</code><code class="o">.</code><code class="n">insert</code><code class="p">([</code><code class="mi">9</code><code class="p">,</code> <code class="s2">"Klein"</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code>&#13;
<code class="n">users</code><code class="o">.</code><code class="n">insert</code><code class="p">([</code><code class="mi">10</code><code class="p">,</code> <code class="s2">"Jen"</code><code class="p">,</code> <code class="mi">1</code><code class="p">])</code></pre>&#13;
&#13;
<p>If you now <code>print(users)</code>, you’ll see:</p>&#13;
&#13;
<pre data-type="programlisting">['user_id', 'name', 'num_friends']&#13;
{'user_id': 0, 'name': 'Hero', 'num_friends': 0}&#13;
{'user_id': 1, 'name': 'Dunn', 'num_friends': 2}&#13;
{'user_id': 2, 'name': 'Sue', 'num_friends': 3}&#13;
...</pre>&#13;
&#13;
<p>The list-like API makes it easy to write tests:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">assert</code> <code class="nb">len</code><code class="p">(</code><code class="n">users</code><code class="p">)</code> <code class="o">==</code> <code class="mi">11</code>&#13;
<code class="k">assert</code> <code class="n">users</code><code class="p">[</code><code class="mi">1</code><code class="p">][</code><code class="s1">'name'</code><code class="p">]</code> <code class="o">==</code> <code class="s1">'Dunn'</code></pre>&#13;
&#13;
<p>We’ve got a lot more functionality to add.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="UPDATE" data-type="sect1"><div class="sect1" id="idm45635709492280">&#13;
<h1>UPDATE</h1>&#13;
&#13;
<p>Sometimes<a data-primary="databases and SQL" data-secondary="UPDATE" data-type="indexterm" id="idm45635708559160"/><a data-primary="UPDATE statement" data-type="indexterm" id="idm45635708558152"/> you need to update the data that’s already in the database.  For instance, if Dunn acquires another friend, you might need to do this:</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">UPDATE</code> <code class="n">users</code>&#13;
<code class="k">SET</code> <code class="n">num_friends</code> <code class="o">=</code> <code class="mi">3</code>&#13;
<code class="k">WHERE</code> <code class="n">user_id</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code></pre>&#13;
&#13;
<p>The key features are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>What table to update</p>&#13;
</li>&#13;
<li>&#13;
<p>Which rows to update</p>&#13;
</li>&#13;
<li>&#13;
<p>Which fields to update</p>&#13;
</li>&#13;
<li>&#13;
<p>What their new values should be</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>We’ll add a similar <code>update</code> method to NotQuiteABase.  Its first argument will be a <code>dict</code> whose keys are the columns to update and whose values are the new values for those fields.  Its second (optional) argument should be a <code>predicate</code> that returns <code>True</code> for rows that should be updated, and <code>False</code> otherwise:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting">    <code class="k">def</code> <code class="nf">update</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code>&#13;
               <code class="n">updates</code><code class="p">:</code> <code class="n">Dict</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code> <code class="n">Any</code><code class="p">],</code>&#13;
               <code class="n">predicate</code><code class="p">:</code> <code class="n">WhereClause</code> <code class="o">=</code> <code class="k">lambda</code> <code class="n">row</code><code class="p">:</code> <code class="bp">True</code><code class="p">):</code>&#13;
        <code class="c1"># First make sure the updates have valid names and types</code>&#13;
        <code class="k">for</code> <code class="n">column</code><code class="p">,</code> <code class="n">new_value</code> <code class="ow">in</code> <code class="n">updates</code><code class="o">.</code><code class="n">items</code><code class="p">():</code>&#13;
            <code class="k">if</code> <code class="n">column</code> <code class="ow">not</code> <code class="ow">in</code> <code class="bp">self</code><code class="o">.</code><code class="n">columns</code><code class="p">:</code>&#13;
                <code class="k">raise</code> <code class="ne">ValueError</code><code class="p">(</code><code class="n">f</code><code class="s2">"invalid column: {column}"</code><code class="p">)</code>&#13;
&#13;
            <code class="n">typ3</code> <code class="o">=</code> <code class="bp">self</code><code class="o">.</code><code class="n">col2type</code><code class="p">(</code><code class="n">column</code><code class="p">)</code>&#13;
            <code class="k">if</code> <code class="ow">not</code> <code class="nb">isinstance</code><code class="p">(</code><code class="n">new_value</code><code class="p">,</code> <code class="n">typ3</code><code class="p">)</code> <code class="ow">and</code> <code class="n">new_value</code> <code class="ow">is</code> <code class="ow">not</code> <code class="bp">None</code><code class="p">:</code>&#13;
                <code class="k">raise</code> <code class="ne">TypeError</code><code class="p">(</code><code class="n">f</code><code class="s2">"expected type {typ3}, but got {new_value}"</code><code class="p">)</code>&#13;
&#13;
        <code class="c1"># Now update</code>&#13;
        <code class="k">for</code> <code class="n">row</code> <code class="ow">in</code> <code class="bp">self</code><code class="o">.</code><code class="n">rows</code><code class="p">:</code>&#13;
            <code class="k">if</code> <code class="n">predicate</code><code class="p">(</code><code class="n">row</code><code class="p">):</code>&#13;
                <code class="k">for</code> <code class="n">column</code><code class="p">,</code> <code class="n">new_value</code> <code class="ow">in</code> <code class="n">updates</code><code class="o">.</code><code class="n">items</code><code class="p">():</code>&#13;
                    <code class="n">row</code><code class="p">[</code><code class="n">column</code><code class="p">]</code> <code class="o">=</code> <code class="n">new_value</code></pre>&#13;
&#13;
<p>after which we can simply do this:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">assert</code> <code class="n">users</code><code class="p">[</code><code class="mi">1</code><code class="p">][</code><code class="s1">'num_friends'</code><code class="p">]</code> <code class="o">==</code> <code class="mi">2</code>             <code class="c1"># Original value</code>&#13;
&#13;
<code class="n">users</code><code class="o">.</code><code class="n">update</code><code class="p">({</code><code class="s1">'num_friends'</code> <code class="p">:</code> <code class="mi">3</code><code class="p">},</code>               <code class="c1"># Set num_friends = 3</code>&#13;
             <code class="k">lambda</code> <code class="n">row</code><code class="p">:</code> <code class="n">row</code><code class="p">[</code><code class="s1">'user_id'</code><code class="p">]</code> <code class="o">==</code> <code class="mi">1</code><code class="p">)</code>   <code class="c1"># in rows where user_id == 1</code>&#13;
&#13;
<code class="k">assert</code> <code class="n">users</code><code class="p">[</code><code class="mi">1</code><code class="p">][</code><code class="s1">'num_friends'</code><code class="p">]</code> <code class="o">==</code> <code class="mi">3</code>             <code class="c1"># Updated value</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="DELETE" data-type="sect1"><div class="sect1" id="idm45635708364280">&#13;
<h1>DELETE</h1>&#13;
&#13;
<p>There<a data-primary="databases and SQL" data-secondary="DELETE" data-type="indexterm" id="idm45635708325768"/><a data-primary="DELETE statement" data-type="indexterm" id="idm45635708324760"/> are two ways to delete rows from a table in SQL.  The dangerous way deletes every row from a table:</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">DELETE</code> <code class="k">FROM</code> <code class="n">users</code><code class="p">;</code></pre>&#13;
&#13;
<p>The less dangerous way adds a <code>WHERE</code> clause and deletes only rows that&#13;
match a certain condition:</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">DELETE</code> <code class="k">FROM</code> <code class="n">users</code> <code class="k">WHERE</code> <code class="n">user_id</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code></pre>&#13;
&#13;
<p>It’s easy to add this functionality to our <code>Table</code>:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting">    <code class="k">def</code> <code class="nf">delete</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">predicate</code><code class="p">:</code> <code class="n">WhereClause</code> <code class="o">=</code> <code class="k">lambda</code> <code class="n">row</code><code class="p">:</code> <code class="bp">True</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="bp">None</code><code class="p">:</code>&#13;
        <code class="sd">"""Delete all rows matching predicate"""</code>&#13;
        <code class="bp">self</code><code class="o">.</code><code class="n">rows</code> <code class="o">=</code> <code class="p">[</code><code class="n">row</code> <code class="k">for</code> <code class="n">row</code> <code class="ow">in</code> <code class="bp">self</code><code class="o">.</code><code class="n">rows</code> <code class="k">if</code> <code class="ow">not</code> <code class="n">predicate</code><code class="p">(</code><code class="n">row</code><code class="p">)]</code></pre>&#13;
&#13;
<p>If you supply a <code>predicate</code> function (i.e., a <code>WHERE</code> clause), this deletes&#13;
only the rows that satisfy it.  If you don’t supply one, the default&#13;
<code>predicate</code> always returns <code>True</code>, and you will delete every row.</p>&#13;
&#13;
<p>For example:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="c1"># We're not actually going to run these</code>&#13;
<code class="n">users</code><code class="o">.</code><code class="n">delete</code><code class="p">(</code><code class="k">lambda</code> <code class="n">row</code><code class="p">:</code> <code class="n">row</code><code class="p">[</code><code class="s2">"user_id"</code><code class="p">]</code> <code class="o">==</code> <code class="mi">1</code><code class="p">)</code>  <code class="c1"># Deletes rows with user_id == 1</code>&#13;
<code class="n">users</code><code class="o">.</code><code class="n">delete</code><code class="p">()</code>                                 <code class="c1"># Deletes every row</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="SELECT" data-type="sect1"><div class="sect1" id="idm45635708131000">&#13;
<h1>SELECT</h1>&#13;
&#13;
<p>Typically<a data-primary="databases and SQL" data-secondary="SELECT" data-type="indexterm" id="idm45635708125944"/><a data-primary="SELECT statement" data-type="indexterm" id="idm45635708124936"/> you don’t inspect SQL tables directly. Instead you query them&#13;
with a <code>SELECT</code> statement:</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">SELECT</code> <code class="o">*</code> <code class="k">FROM</code> <code class="n">users</code><code class="p">;</code>                            <code class="c1">-- get the entire contents</code>&#13;
<code class="k">SELECT</code> <code class="o">*</code> <code class="k">FROM</code> <code class="n">users</code> <code class="k">LIMIT</code> <code class="mi">2</code><code class="p">;</code>                    <code class="c1">-- get the first two rows</code>&#13;
<code class="k">SELECT</code> <code class="n">user_id</code> <code class="k">FROM</code> <code class="n">users</code><code class="p">;</code>                      <code class="c1">-- only get specific columns</code>&#13;
<code class="k">SELECT</code> <code class="n">user_id</code> <code class="k">FROM</code> <code class="n">users</code> <code class="k">WHERE</code> <code class="n">name</code> <code class="o">=</code> <code class="s1">'Dunn'</code><code class="p">;</code>  <code class="c1">-- only get specific rows</code></pre>&#13;
&#13;
<p>You can also use <code>SELECT</code> statements to calculate fields:</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">SELECT</code> <code class="k">LENGTH</code><code class="p">(</code><code class="n">name</code><code class="p">)</code> <code class="k">AS</code> <code class="n">name_length</code> <code class="k">FROM</code> <code class="n">users</code><code class="p">;</code></pre>&#13;
&#13;
<p>We’ll give our <code>Table</code> class a <code>select</code> method that returns a new <code>Table</code>.&#13;
The method accepts two optional arguments:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>keep_columns</code> specifies the names of the columns you want to keep in the result.&#13;
If you don’t supply it, the result contains all the columns.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>additional_columns</code> is a dictionary whose keys are new column names&#13;
and whose values are functions specifying how to compute the values&#13;
of the new columns. We’ll peek at the type annotations of those functions&#13;
to figure out the types of the new columns, so the functions will need&#13;
to have annotated return types.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>If you were to supply neither of them, you’d simply get back a copy of the table:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting">    <code class="k">def</code> <code class="nf">select</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code>&#13;
               <code class="n">keep_columns</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="nb">str</code><code class="p">]</code> <code class="o">=</code> <code class="bp">None</code><code class="p">,</code>&#13;
               <code class="n">additional_columns</code><code class="p">:</code> <code class="n">Dict</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code> <code class="n">Callable</code><code class="p">]</code> <code class="o">=</code> <code class="bp">None</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="s1">'Table'</code><code class="p">:</code>&#13;
&#13;
        <code class="k">if</code> <code class="n">keep_columns</code> <code class="ow">is</code> <code class="bp">None</code><code class="p">:</code>         <code class="c1"># If no columns specified,</code>&#13;
            <code class="n">keep_columns</code> <code class="o">=</code> <code class="bp">self</code><code class="o">.</code><code class="n">columns</code>  <code class="c1"># return all columns</code>&#13;
&#13;
        <code class="k">if</code> <code class="n">additional_columns</code> <code class="ow">is</code> <code class="bp">None</code><code class="p">:</code>&#13;
            <code class="n">additional_columns</code> <code class="o">=</code> <code class="p">{}</code>&#13;
&#13;
        <code class="c1"># New column names and types</code>&#13;
        <code class="n">new_columns</code> <code class="o">=</code> <code class="n">keep_columns</code> <code class="o">+</code> <code class="nb">list</code><code class="p">(</code><code class="n">additional_columns</code><code class="o">.</code><code class="n">keys</code><code class="p">())</code>&#13;
        <code class="n">keep_types</code> <code class="o">=</code> <code class="p">[</code><code class="bp">self</code><code class="o">.</code><code class="n">col2type</code><code class="p">(</code><code class="n">col</code><code class="p">)</code> <code class="k">for</code> <code class="n">col</code> <code class="ow">in</code> <code class="n">keep_columns</code><code class="p">]</code>&#13;
&#13;
        <code class="c1"># This is how to get the return type from a type annotation.</code>&#13;
        <code class="c1"># It will crash if `calculation` doesn't have a return type.</code>&#13;
        <code class="n">add_types</code> <code class="o">=</code> <code class="p">[</code><code class="n">calculation</code><code class="o">.</code><code class="n">__annotations__</code><code class="p">[</code><code class="s1">'return'</code><code class="p">]</code>&#13;
                     <code class="k">for</code> <code class="n">calculation</code> <code class="ow">in</code> <code class="n">additional_columns</code><code class="o">.</code><code class="n">values</code><code class="p">()]</code>&#13;
&#13;
        <code class="c1"># Create a new table for results</code>&#13;
        <code class="n">new_table</code> <code class="o">=</code> <code class="n">Table</code><code class="p">(</code><code class="n">new_columns</code><code class="p">,</code> <code class="n">keep_types</code> <code class="o">+</code> <code class="n">add_types</code><code class="p">)</code>&#13;
&#13;
        <code class="k">for</code> <code class="n">row</code> <code class="ow">in</code> <code class="bp">self</code><code class="o">.</code><code class="n">rows</code><code class="p">:</code>&#13;
            <code class="n">new_row</code> <code class="o">=</code> <code class="p">[</code><code class="n">row</code><code class="p">[</code><code class="n">column</code><code class="p">]</code> <code class="k">for</code> <code class="n">column</code> <code class="ow">in</code> <code class="n">keep_columns</code><code class="p">]</code>&#13;
            <code class="k">for</code> <code class="n">column_name</code><code class="p">,</code> <code class="n">calculation</code> <code class="ow">in</code> <code class="n">additional_columns</code><code class="o">.</code><code class="n">items</code><code class="p">():</code>&#13;
                <code class="n">new_row</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">calculation</code><code class="p">(</code><code class="n">row</code><code class="p">))</code>&#13;
            <code class="n">new_table</code><code class="o">.</code><code class="n">insert</code><code class="p">(</code><code class="n">new_row</code><code class="p">)</code>&#13;
&#13;
        <code class="k">return</code> <code class="n">new_table</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Remember way back in <a data-type="xref" href="ch02.html#python">Chapter 2</a> when we said that type annotations&#13;
don’t actually do anything? Well, here’s the counterexample.&#13;
But look at the convoluted procedure we have to go through to get at them.</p>&#13;
</div>&#13;
&#13;
<p>Our <code>select</code> returns a new <code>Table</code>, while the typical SQL&#13;
<code>SELECT</code> just produces some sort of transient result set (unless you explicitly&#13;
insert the results into a table).</p>&#13;
&#13;
<p>We’ll also need <code>where</code> and <code>limit</code> methods.  Both are pretty simple:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting">    <code class="k">def</code> <code class="nf">where</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">predicate</code><code class="p">:</code> <code class="n">WhereClause</code> <code class="o">=</code> <code class="k">lambda</code> <code class="n">row</code><code class="p">:</code> <code class="bp">True</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="s1">'Table'</code><code class="p">:</code>&#13;
        <code class="sd">"""Return only the rows that satisfy the supplied predicate"""</code>&#13;
        <code class="n">where_table</code> <code class="o">=</code> <code class="n">Table</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">columns</code><code class="p">,</code> <code class="bp">self</code><code class="o">.</code><code class="n">types</code><code class="p">)</code>&#13;
        <code class="k">for</code> <code class="n">row</code> <code class="ow">in</code> <code class="bp">self</code><code class="o">.</code><code class="n">rows</code><code class="p">:</code>&#13;
            <code class="k">if</code> <code class="n">predicate</code><code class="p">(</code><code class="n">row</code><code class="p">):</code>&#13;
                <code class="n">values</code> <code class="o">=</code> <code class="p">[</code><code class="n">row</code><code class="p">[</code><code class="n">column</code><code class="p">]</code> <code class="k">for</code> <code class="n">column</code> <code class="ow">in</code> <code class="bp">self</code><code class="o">.</code><code class="n">columns</code><code class="p">]</code>&#13;
                <code class="n">where_table</code><code class="o">.</code><code class="n">insert</code><code class="p">(</code><code class="n">values</code><code class="p">)</code>&#13;
        <code class="k">return</code> <code class="n">where_table</code>&#13;
&#13;
    <code class="k">def</code> <code class="nf">limit</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">num_rows</code><code class="p">:</code> <code class="nb">int</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="s1">'Table'</code><code class="p">:</code>&#13;
        <code class="sd">"""Return only the first `num_rows` rows"""</code>&#13;
        <code class="n">limit_table</code> <code class="o">=</code> <code class="n">Table</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">columns</code><code class="p">,</code> <code class="bp">self</code><code class="o">.</code><code class="n">types</code><code class="p">)</code>&#13;
        <code class="k">for</code> <code class="n">i</code><code class="p">,</code> <code class="n">row</code> <code class="ow">in</code> <code class="nb">enumerate</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">rows</code><code class="p">):</code>&#13;
            <code class="k">if</code> <code class="n">i</code> <code class="o">&gt;=</code> <code class="n">num_rows</code><code class="p">:</code>&#13;
                <code class="k">break</code>&#13;
            <code class="n">values</code> <code class="o">=</code> <code class="p">[</code><code class="n">row</code><code class="p">[</code><code class="n">column</code><code class="p">]</code> <code class="k">for</code> <code class="n">column</code> <code class="ow">in</code> <code class="bp">self</code><code class="o">.</code><code class="n">columns</code><code class="p">]</code>&#13;
            <code class="n">limit_table</code><code class="o">.</code><code class="n">insert</code><code class="p">(</code><code class="n">values</code><code class="p">)</code>&#13;
        <code class="k">return</code> <code class="n">limit_table</code></pre>&#13;
&#13;
<p>after which we can easily construct NotQuiteABase equivalents to&#13;
the preceding SQL statements:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="c1"># SELECT * FROM users;</code>&#13;
<code class="n">all_users</code> <code class="o">=</code> <code class="n">users</code><code class="o">.</code><code class="n">select</code><code class="p">()</code>&#13;
<code class="k">assert</code> <code class="nb">len</code><code class="p">(</code><code class="n">all_users</code><code class="p">)</code> <code class="o">==</code> <code class="mi">11</code>&#13;
&#13;
<code class="c1"># SELECT * FROM users LIMIT 2;</code>&#13;
<code class="n">two_users</code> <code class="o">=</code> <code class="n">users</code><code class="o">.</code><code class="n">limit</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>&#13;
<code class="k">assert</code> <code class="nb">len</code><code class="p">(</code><code class="n">two_users</code><code class="p">)</code> <code class="o">==</code> <code class="mi">2</code>&#13;
&#13;
<code class="c1"># SELECT user_id FROM users;</code>&#13;
<code class="n">just_ids</code> <code class="o">=</code> <code class="n">users</code><code class="o">.</code><code class="n">select</code><code class="p">(</code><code class="n">keep_columns</code><code class="o">=</code><code class="p">[</code><code class="s2">"user_id"</code><code class="p">])</code>&#13;
<code class="k">assert</code> <code class="n">just_ids</code><code class="o">.</code><code class="n">columns</code> <code class="o">==</code> <code class="p">[</code><code class="s1">'user_id'</code><code class="p">]</code>&#13;
&#13;
<code class="c1"># SELECT user_id FROM users WHERE name = 'Dunn';</code>&#13;
<code class="n">dunn_ids</code> <code class="o">=</code> <code class="p">(</code>&#13;
    <code class="n">users</code>&#13;
    <code class="o">.</code><code class="n">where</code><code class="p">(</code><code class="k">lambda</code> <code class="n">row</code><code class="p">:</code> <code class="n">row</code><code class="p">[</code><code class="s2">"name"</code><code class="p">]</code> <code class="o">==</code> <code class="s2">"Dunn"</code><code class="p">)</code>&#13;
    <code class="o">.</code><code class="n">select</code><code class="p">(</code><code class="n">keep_columns</code><code class="o">=</code><code class="p">[</code><code class="s2">"user_id"</code><code class="p">])</code>&#13;
<code class="p">)</code>&#13;
<code class="k">assert</code> <code class="nb">len</code><code class="p">(</code><code class="n">dunn_ids</code><code class="p">)</code> <code class="o">==</code> <code class="mi">1</code>&#13;
<code class="k">assert</code> <code class="n">dunn_ids</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">==</code> <code class="p">{</code><code class="s2">"user_id"</code><code class="p">:</code> <code class="mi">1</code><code class="p">}</code>&#13;
&#13;
<code class="c1"># SELECT LENGTH(name) AS name_length FROM users;</code>&#13;
<code class="k">def</code> <code class="nf">name_length</code><code class="p">(</code><code class="n">row</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">int</code><code class="p">:</code> <code class="k">return</code> <code class="nb">len</code><code class="p">(</code><code class="n">row</code><code class="p">[</code><code class="s2">"name"</code><code class="p">])</code>&#13;
&#13;
<code class="n">name_lengths</code> <code class="o">=</code> <code class="n">users</code><code class="o">.</code><code class="n">select</code><code class="p">(</code><code class="n">keep_columns</code><code class="o">=</code><code class="p">[],</code>&#13;
                            <code class="n">additional_columns</code> <code class="o">=</code> <code class="p">{</code><code class="s2">"name_length"</code><code class="p">:</code> <code class="n">name_length</code><code class="p">})</code>&#13;
<code class="k">assert</code> <code class="n">name_lengths</code><code class="p">[</code><code class="mi">0</code><code class="p">][</code><code class="s1">'name_length'</code><code class="p">]</code> <code class="o">==</code> <code class="nb">len</code><code class="p">(</code><code class="s2">"Hero"</code><code class="p">)</code></pre>&#13;
&#13;
<p>Notice that for the multiline “fluent” queries we have to wrap the whole query in parentheses.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="GROUP BY" data-type="sect1"><div class="sect1" id="idm45635708102248">&#13;
<h1>GROUP BY</h1>&#13;
&#13;
<p>Another<a data-primary="databases and SQL" data-secondary="GROUP BY" data-type="indexterm" id="idm45635707573320"/><a data-primary="GROUP BY statement" data-type="indexterm" id="idm45635707390504"/> common SQL operation is <code>GROUP BY</code>, which groups together&#13;
rows with identical values in specified columns and produces&#13;
aggregate values like <code>MIN</code> and <code>MAX</code> and <code>COUNT</code> and <code>SUM</code>.</p>&#13;
&#13;
<p>For example, you might want to find the number of users and the&#13;
smallest <code>user_id</code> for each possible name length:</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">SELECT</code> <code class="k">LENGTH</code><code class="p">(</code><code class="n">name</code><code class="p">)</code> <code class="k">as</code> <code class="n">name_length</code><code class="p">,</code>&#13;
 <code class="k">MIN</code><code class="p">(</code><code class="n">user_id</code><code class="p">)</code> <code class="k">AS</code> <code class="n">min_user_id</code><code class="p">,</code>&#13;
 <code class="k">COUNT</code><code class="p">(</code><code class="o">*</code><code class="p">)</code> <code class="k">AS</code> <code class="n">num_users</code>&#13;
<code class="k">FROM</code> <code class="n">users</code>&#13;
<code class="k">GROUP</code> <code class="k">BY</code> <code class="k">LENGTH</code><code class="p">(</code><code class="n">name</code><code class="p">);</code></pre>&#13;
&#13;
<p>Every field we <code>SELECT</code> needs to be either in the <code>GROUP BY</code> clause&#13;
(which <code>name_length</code> is)&#13;
or an aggregate computation&#13;
(which <code>min_user_id</code> and <code>num_users</code> are).</p>&#13;
&#13;
<p>SQL also supports a <code>HAVING</code> clause that behaves similarly to a <code>WHERE</code> clause, except that its filter is applied to the aggregates&#13;
(whereas a <code>WHERE</code> would filter out rows before aggregation even took place).</p>&#13;
&#13;
<p>You might want to know the average number of friends for users&#13;
whose names start with specific letters but see only the results&#13;
for letters whose corresponding average is greater than 1. (Yes, some of these examples are contrived.)</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">SELECT</code> <code class="n">SUBSTR</code><code class="p">(</code><code class="n">name</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code> <code class="k">AS</code> <code class="n">first_letter</code><code class="p">,</code>&#13;
 <code class="k">AVG</code><code class="p">(</code><code class="n">num_friends</code><code class="p">)</code> <code class="k">AS</code> <code class="n">avg_num_friends</code>&#13;
<code class="k">FROM</code> <code class="n">users</code>&#13;
<code class="k">GROUP</code> <code class="k">BY</code> <code class="n">SUBSTR</code><code class="p">(</code><code class="n">name</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code>&#13;
<code class="k">HAVING</code> <code class="k">AVG</code><code class="p">(</code><code class="n">num_friends</code><code class="p">)</code> <code class="o">&gt;</code> <code class="mi">1</code><code class="p">;</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Functions for working with strings vary across SQL implementations;&#13;
some databases might instead use <code>SUBSTRING</code> or something else.</p>&#13;
</div>&#13;
&#13;
<p>You can also compute overall aggregates.&#13;
In that case, you leave off the <code>GROUP BY</code>:</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">SELECT</code> <code class="k">SUM</code><code class="p">(</code><code class="n">user_id</code><code class="p">)</code> <code class="k">as</code> <code class="n">user_id_sum</code>&#13;
<code class="k">FROM</code> <code class="n">users</code>&#13;
<code class="k">WHERE</code> <code class="n">user_id</code> <code class="o">&gt;</code> <code class="mi">1</code><code class="p">;</code></pre>&#13;
&#13;
<p>To add this functionality to NotQuiteABase <code>Table</code>s,&#13;
we’ll add a <code>group_by</code> method.  It takes the names of the&#13;
columns you want to group by, a dictionary of the aggregation functions&#13;
you want to run over each group, and an optional predicate called <code>having</code> that operates on multiple rows.</p>&#13;
&#13;
<p>Then it does the following steps:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Creates a <code>defaultdict</code> to map <code>tuple</code>s (of the group-by values) to&#13;
rows (containing the group-by values). Recall that you can’t use lists as <code>dict</code> keys; you have to use tuples.</p>&#13;
</li>&#13;
<li>&#13;
<p>Iterates over the rows of the table, populating the <code>defaultdict</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Creates a new table with the correct output columns.</p>&#13;
</li>&#13;
<li>&#13;
<p>Iterates over the <code>defaultdict</code> and populates the output table, applying the <code>having</code> filter, if any.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting">    <code class="k">def</code> <code class="nf">group_by</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code>&#13;
                 <code class="n">group_by_columns</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="nb">str</code><code class="p">],</code>&#13;
                 <code class="n">aggregates</code><code class="p">:</code> <code class="n">Dict</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code> <code class="n">Callable</code><code class="p">],</code>&#13;
                 <code class="n">having</code><code class="p">:</code> <code class="n">HavingClause</code> <code class="o">=</code> <code class="k">lambda</code> <code class="n">group</code><code class="p">:</code> <code class="bp">True</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="s1">'Table'</code><code class="p">:</code>&#13;
&#13;
        <code class="n">grouped_rows</code> <code class="o">=</code> <code class="n">defaultdict</code><code class="p">(</code><code class="nb">list</code><code class="p">)</code>&#13;
&#13;
        <code class="c1"># Populate groups</code>&#13;
        <code class="k">for</code> <code class="n">row</code> <code class="ow">in</code> <code class="bp">self</code><code class="o">.</code><code class="n">rows</code><code class="p">:</code>&#13;
            <code class="n">key</code> <code class="o">=</code> <code class="nb">tuple</code><code class="p">(</code><code class="n">row</code><code class="p">[</code><code class="n">column</code><code class="p">]</code> <code class="k">for</code> <code class="n">column</code> <code class="ow">in</code> <code class="n">group_by_columns</code><code class="p">)</code>&#13;
            <code class="n">grouped_rows</code><code class="p">[</code><code class="n">key</code><code class="p">]</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">row</code><code class="p">)</code>&#13;
&#13;
        <code class="c1"># Result table consists of group_by columns and aggregates</code>&#13;
        <code class="n">new_columns</code> <code class="o">=</code> <code class="n">group_by_columns</code> <code class="o">+</code> <code class="nb">list</code><code class="p">(</code><code class="n">aggregates</code><code class="o">.</code><code class="n">keys</code><code class="p">())</code>&#13;
        <code class="n">group_by_types</code> <code class="o">=</code> <code class="p">[</code><code class="bp">self</code><code class="o">.</code><code class="n">col2type</code><code class="p">(</code><code class="n">col</code><code class="p">)</code> <code class="k">for</code> <code class="n">col</code> <code class="ow">in</code> <code class="n">group_by_columns</code><code class="p">]</code>&#13;
        <code class="n">aggregate_types</code> <code class="o">=</code> <code class="p">[</code><code class="n">agg</code><code class="o">.</code><code class="n">__annotations__</code><code class="p">[</code><code class="s1">'return'</code><code class="p">]</code>&#13;
                           <code class="k">for</code> <code class="n">agg</code> <code class="ow">in</code> <code class="n">aggregates</code><code class="o">.</code><code class="n">values</code><code class="p">()]</code>&#13;
        <code class="n">result_table</code> <code class="o">=</code> <code class="n">Table</code><code class="p">(</code><code class="n">new_columns</code><code class="p">,</code> <code class="n">group_by_types</code> <code class="o">+</code> <code class="n">aggregate_types</code><code class="p">)</code>&#13;
&#13;
        <code class="k">for</code> <code class="n">key</code><code class="p">,</code> <code class="n">rows</code> <code class="ow">in</code> <code class="n">grouped_rows</code><code class="o">.</code><code class="n">items</code><code class="p">():</code>&#13;
            <code class="k">if</code> <code class="n">having</code><code class="p">(</code><code class="n">rows</code><code class="p">):</code>&#13;
                <code class="n">new_row</code> <code class="o">=</code> <code class="nb">list</code><code class="p">(</code><code class="n">key</code><code class="p">)</code>&#13;
                <code class="k">for</code> <code class="n">aggregate_name</code><code class="p">,</code> <code class="n">aggregate_fn</code> <code class="ow">in</code> <code class="n">aggregates</code><code class="o">.</code><code class="n">items</code><code class="p">():</code>&#13;
                    <code class="n">new_row</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">aggregate_fn</code><code class="p">(</code><code class="n">rows</code><code class="p">))</code>&#13;
                <code class="n">result_table</code><code class="o">.</code><code class="n">insert</code><code class="p">(</code><code class="n">new_row</code><code class="p">)</code>&#13;
&#13;
        <code class="k">return</code> <code class="n">result_table</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>An actual database would almost certainly do this in a more efficient manner.)</p>&#13;
</div>&#13;
&#13;
<p>Again, let’s see how we would do the equivalent of the preceding SQL statements. The <code>name_length</code> metrics are:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">def</code> <code class="nf">min_user_id</code><code class="p">(</code><code class="n">rows</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">int</code><code class="p">:</code>&#13;
    <code class="k">return</code> <code class="nb">min</code><code class="p">(</code><code class="n">row</code><code class="p">[</code><code class="s2">"user_id"</code><code class="p">]</code> <code class="k">for</code> <code class="n">row</code> <code class="ow">in</code> <code class="n">rows</code><code class="p">)</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">length</code><code class="p">(</code><code class="n">rows</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">int</code><code class="p">:</code>&#13;
    <code class="k">return</code> <code class="nb">len</code><code class="p">(</code><code class="n">rows</code><code class="p">)</code>&#13;
&#13;
<code class="n">stats_by_length</code> <code class="o">=</code> <code class="p">(</code>&#13;
    <code class="n">users</code>&#13;
    <code class="o">.</code><code class="n">select</code><code class="p">(</code><code class="n">additional_columns</code><code class="o">=</code><code class="p">{</code><code class="s2">"name_length"</code> <code class="p">:</code> <code class="n">name_length</code><code class="p">})</code>&#13;
    <code class="o">.</code><code class="n">group_by</code><code class="p">(</code><code class="n">group_by_columns</code><code class="o">=</code><code class="p">[</code><code class="s2">"name_length"</code><code class="p">],</code>&#13;
              <code class="n">aggregates</code><code class="o">=</code><code class="p">{</code><code class="s2">"min_user_id"</code> <code class="p">:</code> <code class="n">min_user_id</code><code class="p">,</code>&#13;
                          <code class="s2">"num_users"</code> <code class="p">:</code> <code class="n">length</code><code class="p">})</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>The <code>first_letter</code> metrics:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">def</code> <code class="nf">first_letter_of_name</code><code class="p">(</code><code class="n">row</code><code class="p">:</code> <code class="n">Row</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">str</code><code class="p">:</code>&#13;
    <code class="k">return</code> <code class="n">row</code><code class="p">[</code><code class="s2">"name"</code><code class="p">][</code><code class="mi">0</code><code class="p">]</code> <code class="k">if</code> <code class="n">row</code><code class="p">[</code><code class="s2">"name"</code><code class="p">]</code> <code class="k">else</code> <code class="s2">""</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">average_num_friends</code><code class="p">(</code><code class="n">rows</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">Row</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="nb">float</code><code class="p">:</code>&#13;
    <code class="k">return</code> <code class="nb">sum</code><code class="p">(</code><code class="n">row</code><code class="p">[</code><code class="s2">"num_friends"</code><code class="p">]</code> <code class="k">for</code> <code class="n">row</code> <code class="ow">in</code> <code class="n">rows</code><code class="p">)</code> <code class="o">/</code> <code class="nb">len</code><code class="p">(</code><code class="n">rows</code><code class="p">)</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">enough_friends</code><code class="p">(</code><code class="n">rows</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">Row</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="nb">bool</code><code class="p">:</code>&#13;
    <code class="k">return</code> <code class="n">average_num_friends</code><code class="p">(</code><code class="n">rows</code><code class="p">)</code> <code class="o">&gt;</code> <code class="mi">1</code>&#13;
&#13;
<code class="n">avg_friends_by_letter</code> <code class="o">=</code> <code class="p">(</code>&#13;
    <code class="n">users</code>&#13;
    <code class="o">.</code><code class="n">select</code><code class="p">(</code><code class="n">additional_columns</code><code class="o">=</code><code class="p">{</code><code class="s1">'first_letter'</code> <code class="p">:</code> <code class="n">first_letter_of_name</code><code class="p">})</code>&#13;
    <code class="o">.</code><code class="n">group_by</code><code class="p">(</code><code class="n">group_by_columns</code><code class="o">=</code><code class="p">[</code><code class="s1">'first_letter'</code><code class="p">],</code>&#13;
              <code class="n">aggregates</code><code class="o">=</code><code class="p">{</code><code class="s2">"avg_num_friends"</code> <code class="p">:</code> <code class="n">average_num_friends</code><code class="p">},</code>&#13;
              <code class="n">having</code><code class="o">=</code><code class="n">enough_friends</code><code class="p">)</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>and the <code>user_id_sum</code> is:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">def</code> <code class="nf">sum_user_ids</code><code class="p">(</code><code class="n">rows</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">Row</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="nb">int</code><code class="p">:</code>&#13;
    <code class="k">return</code> <code class="nb">sum</code><code class="p">(</code><code class="n">row</code><code class="p">[</code><code class="s2">"user_id"</code><code class="p">]</code> <code class="k">for</code> <code class="n">row</code> <code class="ow">in</code> <code class="n">rows</code><code class="p">)</code>&#13;
&#13;
<code class="n">user_id_sum</code> <code class="o">=</code> <code class="p">(</code>&#13;
    <code class="n">users</code>&#13;
    <code class="o">.</code><code class="n">where</code><code class="p">(</code><code class="k">lambda</code> <code class="n">row</code><code class="p">:</code> <code class="n">row</code><code class="p">[</code><code class="s2">"user_id"</code><code class="p">]</code> <code class="o">&gt;</code> <code class="mi">1</code><code class="p">)</code>&#13;
    <code class="o">.</code><code class="n">group_by</code><code class="p">(</code><code class="n">group_by_columns</code><code class="o">=</code><code class="p">[],</code>&#13;
              <code class="n">aggregates</code><code class="o">=</code><code class="p">{</code> <code class="s2">"user_id_sum"</code> <code class="p">:</code> <code class="n">sum_user_ids</code> <code class="p">})</code>&#13;
<code class="p">)</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="ORDER BY" data-type="sect1"><div class="sect1" id="idm45635707574456">&#13;
<h1>ORDER BY</h1>&#13;
&#13;
<p>Frequently, you’ll<a data-primary="databases and SQL" data-secondary="ORDER BY" data-type="indexterm" id="idm45635706568888"/><a data-primary="ORDER BY statement" data-type="indexterm" id="idm45635706571656"/> want to sort your results.  For example, you might want to know the (alphabetically) first two names of your users:</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">SELECT</code> <code class="o">*</code> <code class="k">FROM</code> <code class="n">users</code>&#13;
<code class="k">ORDER</code> <code class="k">BY</code> <code class="n">name</code>&#13;
<code class="k">LIMIT</code> <code class="mi">2</code><code class="p">;</code></pre>&#13;
&#13;
<p>This is easy to implement by giving our <code>Table</code> an <code>order_by</code>&#13;
method that takes an <code>order</code> function:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting">    <code class="k">def</code> <code class="nf">order_by</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">order</code><code class="p">:</code> <code class="n">Callable</code><code class="p">[[</code><code class="n">Row</code><code class="p">],</code> <code class="n">Any</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="s1">'Table'</code><code class="p">:</code>&#13;
        <code class="n">new_table</code> <code class="o">=</code> <code class="bp">self</code><code class="o">.</code><code class="n">select</code><code class="p">()</code>       <code class="c1"># make a copy</code>&#13;
        <code class="n">new_table</code><code class="o">.</code><code class="n">rows</code><code class="o">.</code><code class="n">sort</code><code class="p">(</code><code class="n">key</code><code class="o">=</code><code class="n">order</code><code class="p">)</code>&#13;
        <code class="k">return</code> <code class="n">new_table</code></pre>&#13;
&#13;
<p>which we can then use as follows:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">friendliest_letters</code> <code class="o">=</code> <code class="p">(</code>&#13;
    <code class="n">avg_friends_by_letter</code>&#13;
    <code class="o">.</code><code class="n">order_by</code><code class="p">(</code><code class="k">lambda</code> <code class="n">row</code><code class="p">:</code> <code class="o">-</code><code class="n">row</code><code class="p">[</code><code class="s2">"avg_num_friends"</code><code class="p">])</code>&#13;
    <code class="o">.</code><code class="n">limit</code><code class="p">(</code><code class="mi">4</code><code class="p">)</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>The SQL <code>ORDER BY</code> lets you&#13;
specify <code>ASC</code> (ascending) or <code>DESC</code> (descending) for each sort field;&#13;
here we’d have to bake that into our <code>order</code> function.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="JOIN" data-type="sect1"><div class="sect1" id="idm45635706441848">&#13;
<h1>JOIN</h1>&#13;
&#13;
<p>Relational database<a data-primary="databases and SQL" data-secondary="JOIN" data-type="indexterm" id="idm45635706499384"/><a data-primary="JOIN statement" data-type="indexterm" id="idm45635706498488"/> tables are often <em>normalized</em>, which means that&#13;
they’re organized to minimize redundancy.  For example, when we work with&#13;
our users’ interests in Python, we can just give each user a <code>list</code>&#13;
containing his interests.</p>&#13;
&#13;
<p>SQL tables can’t typically contain lists, so the typical solution is to create a second table called <code>user_interests</code> containing the one-to-many relationship between <code>user_id</code>s and <code>interest</code>s. In SQL you might do:</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="n">user_interests</code> <code class="p">(</code>&#13;
    <code class="n">user_id</code> <code class="nb">INT</code> <code class="k">NOT</code> <code class="k">NULL</code><code class="p">,</code>&#13;
    <code class="n">interest</code> <code class="nb">VARCHAR</code><code class="p">(</code><code class="mi">100</code><code class="p">)</code> <code class="k">NOT</code> <code class="k">NULL</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>whereas in NotQuiteABase you’d create the table:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">user_interests</code> <code class="o">=</code> <code class="n">Table</code><code class="p">([</code><code class="s1">'user_id'</code><code class="p">,</code> <code class="s1">'interest'</code><code class="p">],</code> <code class="p">[</code><code class="nb">int</code><code class="p">,</code> <code class="nb">str</code><code class="p">])</code>&#13;
<code class="n">user_interests</code><code class="o">.</code><code class="n">insert</code><code class="p">([</code><code class="mi">0</code><code class="p">,</code> <code class="s2">"SQL"</code><code class="p">])</code>&#13;
<code class="n">user_interests</code><code class="o">.</code><code class="n">insert</code><code class="p">([</code><code class="mi">0</code><code class="p">,</code> <code class="s2">"NoSQL"</code><code class="p">])</code>&#13;
<code class="n">user_interests</code><code class="o">.</code><code class="n">insert</code><code class="p">([</code><code class="mi">2</code><code class="p">,</code> <code class="s2">"SQL"</code><code class="p">])</code>&#13;
<code class="n">user_interests</code><code class="o">.</code><code class="n">insert</code><code class="p">([</code><code class="mi">2</code><code class="p">,</code> <code class="s2">"MySQL"</code><code class="p">])</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>There’s still plenty of redundancy—the interest “SQL” is stored in two&#13;
different places.  In a real database you might store <code>user_id</code> and <code>interest_id</code> in the <code>user_interests</code> table and then create a third table, <code>interests</code>, mapping <code>interest_id</code> to <code>interest</code> so you could&#13;
store the interest names only once each.  Here that would just make&#13;
our examples more complicated than they need to be.</p>&#13;
</div>&#13;
&#13;
<p>When our data lives across different tables, how do we analyze it?  By <code>JOIN</code>ing the tables together.  A <code>JOIN</code> combines rows in the left table with corresponding rows in the right table, where the meaning of&#13;
“corresponding” is based on how we specify the join.</p>&#13;
&#13;
<p>For example, to find the users interested in SQL you’d query:</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">SELECT</code> <code class="n">users</code><code class="p">.</code><code class="n">name</code>&#13;
<code class="k">FROM</code> <code class="n">users</code>&#13;
<code class="k">JOIN</code> <code class="n">user_interests</code>&#13;
<code class="k">ON</code> <code class="n">users</code><code class="p">.</code><code class="n">user_id</code> <code class="o">=</code> <code class="n">user_interests</code><code class="p">.</code><code class="n">user_id</code>&#13;
<code class="k">WHERE</code> <code class="n">user_interests</code><code class="p">.</code><code class="n">interest</code> <code class="o">=</code> <code class="s1">'SQL'</code></pre>&#13;
&#13;
<p>The <code>JOIN</code> says that, for each row in <code>users</code>, we should look at the <code>user_id</code> and associate that row with every row in <code>user_interests</code> containing the same <code>user_id</code>.</p>&#13;
&#13;
<p>Notice we had to specify which tables to <code>JOIN</code> and also which columns to&#13;
join <code>ON</code>.  This is an <code>INNER JOIN</code>, which returns the combinations of rows&#13;
(and only the combinations of rows) that match according to the specified join criteria.</p>&#13;
&#13;
<p>There is also a <code>LEFT JOIN</code>, which—in addition to the combinations of matching rows—returns a row for each left-table row with no matching rows (in which case, the fields that would have come from the right table are all <code>NULL</code>).</p>&#13;
&#13;
<p>Using a <code>LEFT JOIN</code>, it’s easy to count the number of interests each user has:</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">SELECT</code> <code class="n">users</code><code class="p">.</code><code class="n">id</code><code class="p">,</code> <code class="k">COUNT</code><code class="p">(</code><code class="n">user_interests</code><code class="p">.</code><code class="n">interest</code><code class="p">)</code> <code class="k">AS</code> <code class="n">num_interests</code>&#13;
<code class="k">FROM</code> <code class="n">users</code>&#13;
<code class="k">LEFT</code> <code class="k">JOIN</code> <code class="n">user_interests</code>&#13;
<code class="k">ON</code> <code class="n">users</code><code class="p">.</code><code class="n">user_id</code> <code class="o">=</code> <code class="n">user_interests</code><code class="p">.</code><code class="n">user_id</code></pre>&#13;
&#13;
<p>The <code>LEFT JOIN</code> ensures that users with no interests will still&#13;
have rows in the joined dataset (with <code>NULL</code> values for the fields coming from <code>user_interests</code>), and <code>COUNT</code> counts only values that are non-<code>NULL</code>.</p>&#13;
&#13;
<p>The NotQuiteABase <code>join</code> implementation will be more restrictive—it simply joins two tables on whatever columns they have in common.  Even so, it’s not trivial to write:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting">    <code class="k">def</code> <code class="nf">join</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">other_table</code><code class="p">:</code> <code class="s1">'Table'</code><code class="p">,</code> <code class="n">left_join</code><code class="p">:</code> <code class="nb">bool</code> <code class="o">=</code> <code class="bp">False</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="s1">'Table'</code><code class="p">:</code>&#13;
&#13;
        <code class="n">join_on_columns</code> <code class="o">=</code> <code class="p">[</code><code class="n">c</code> <code class="k">for</code> <code class="n">c</code> <code class="ow">in</code> <code class="bp">self</code><code class="o">.</code><code class="n">columns</code>           <code class="c1"># columns in</code>&#13;
                           <code class="k">if</code> <code class="n">c</code> <code class="ow">in</code> <code class="n">other_table</code><code class="o">.</code><code class="n">columns</code><code class="p">]</code>      <code class="c1"># both tables</code>&#13;
&#13;
        <code class="n">additional_columns</code> <code class="o">=</code> <code class="p">[</code><code class="n">c</code> <code class="k">for</code> <code class="n">c</code> <code class="ow">in</code> <code class="n">other_table</code><code class="o">.</code><code class="n">columns</code> <code class="c1"># columns only</code>&#13;
                              <code class="k">if</code> <code class="n">c</code> <code class="ow">not</code> <code class="ow">in</code> <code class="n">join_on_columns</code><code class="p">]</code>   <code class="c1"># in right table</code>&#13;
&#13;
        <code class="c1"># all columns from left table + additional_columns from right table</code>&#13;
        <code class="n">new_columns</code> <code class="o">=</code> <code class="bp">self</code><code class="o">.</code><code class="n">columns</code> <code class="o">+</code> <code class="n">additional_columns</code>&#13;
        <code class="n">new_types</code> <code class="o">=</code> <code class="bp">self</code><code class="o">.</code><code class="n">types</code> <code class="o">+</code> <code class="p">[</code><code class="n">other_table</code><code class="o">.</code><code class="n">col2type</code><code class="p">(</code><code class="n">col</code><code class="p">)</code>&#13;
                                  <code class="k">for</code> <code class="n">col</code> <code class="ow">in</code> <code class="n">additional_columns</code><code class="p">]</code>&#13;
&#13;
        <code class="n">join_table</code> <code class="o">=</code> <code class="n">Table</code><code class="p">(</code><code class="n">new_columns</code><code class="p">,</code> <code class="n">new_types</code><code class="p">)</code>&#13;
&#13;
        <code class="k">for</code> <code class="n">row</code> <code class="ow">in</code> <code class="bp">self</code><code class="o">.</code><code class="n">rows</code><code class="p">:</code>&#13;
            <code class="k">def</code> <code class="nf">is_join</code><code class="p">(</code><code class="n">other_row</code><code class="p">):</code>&#13;
                <code class="k">return</code> <code class="nb">all</code><code class="p">(</code><code class="n">other_row</code><code class="p">[</code><code class="n">c</code><code class="p">]</code> <code class="o">==</code> <code class="n">row</code><code class="p">[</code><code class="n">c</code><code class="p">]</code> <code class="k">for</code> <code class="n">c</code> <code class="ow">in</code> <code class="n">join_on_columns</code><code class="p">)</code>&#13;
&#13;
            <code class="n">other_rows</code> <code class="o">=</code> <code class="n">other_table</code><code class="o">.</code><code class="n">where</code><code class="p">(</code><code class="n">is_join</code><code class="p">)</code><code class="o">.</code><code class="n">rows</code>&#13;
&#13;
            <code class="c1"># Each other row that matches this one produces a result row.</code>&#13;
            <code class="k">for</code> <code class="n">other_row</code> <code class="ow">in</code> <code class="n">other_rows</code><code class="p">:</code>&#13;
                <code class="n">join_table</code><code class="o">.</code><code class="n">insert</code><code class="p">([</code><code class="n">row</code><code class="p">[</code><code class="n">c</code><code class="p">]</code> <code class="k">for</code> <code class="n">c</code> <code class="ow">in</code> <code class="bp">self</code><code class="o">.</code><code class="n">columns</code><code class="p">]</code> <code class="o">+</code>&#13;
                                  <code class="p">[</code><code class="n">other_row</code><code class="p">[</code><code class="n">c</code><code class="p">]</code> <code class="k">for</code> <code class="n">c</code> <code class="ow">in</code> <code class="n">additional_columns</code><code class="p">])</code>&#13;
&#13;
            <code class="c1"># If no rows match and it's a left join, output with Nones.</code>&#13;
            <code class="k">if</code> <code class="n">left_join</code> <code class="ow">and</code> <code class="ow">not</code> <code class="n">other_rows</code><code class="p">:</code>&#13;
                <code class="n">join_table</code><code class="o">.</code><code class="n">insert</code><code class="p">([</code><code class="n">row</code><code class="p">[</code><code class="n">c</code><code class="p">]</code> <code class="k">for</code> <code class="n">c</code> <code class="ow">in</code> <code class="bp">self</code><code class="o">.</code><code class="n">columns</code><code class="p">]</code> <code class="o">+</code>&#13;
                                  <code class="p">[</code><code class="bp">None</code> <code class="k">for</code> <code class="n">c</code> <code class="ow">in</code> <code class="n">additional_columns</code><code class="p">])</code>&#13;
&#13;
        <code class="k">return</code> <code class="n">join_table</code></pre>&#13;
&#13;
<p>So, we could find users interested in SQL with:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">sql_users</code> <code class="o">=</code> <code class="p">(</code>&#13;
    <code class="n">users</code>&#13;
    <code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="n">user_interests</code><code class="p">)</code>&#13;
    <code class="o">.</code><code class="n">where</code><code class="p">(</code><code class="k">lambda</code> <code class="n">row</code><code class="p">:</code> <code class="n">row</code><code class="p">[</code><code class="s2">"interest"</code><code class="p">]</code> <code class="o">==</code> <code class="s2">"SQL"</code><code class="p">)</code>&#13;
    <code class="o">.</code><code class="n">select</code><code class="p">(</code><code class="n">keep_columns</code><code class="o">=</code><code class="p">[</code><code class="s2">"name"</code><code class="p">])</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>And we could get the interest counts with:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">def</code> <code class="nf">count_interests</code><code class="p">(</code><code class="n">rows</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">Row</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="nb">int</code><code class="p">:</code>&#13;
    <code class="sd">"""counts how many rows have non-None interests"""</code>&#13;
    <code class="k">return</code> <code class="nb">len</code><code class="p">([</code><code class="n">row</code> <code class="k">for</code> <code class="n">row</code> <code class="ow">in</code> <code class="n">rows</code> <code class="k">if</code> <code class="n">row</code><code class="p">[</code><code class="s2">"interest"</code><code class="p">]</code> <code class="ow">is</code> <code class="ow">not</code> <code class="bp">None</code><code class="p">])</code>&#13;
&#13;
<code class="n">user_interest_counts</code> <code class="o">=</code> <code class="p">(</code>&#13;
    <code class="n">users</code>&#13;
    <code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="n">user_interests</code><code class="p">,</code> <code class="n">left_join</code><code class="o">=</code><code class="bp">True</code><code class="p">)</code>&#13;
    <code class="o">.</code><code class="n">group_by</code><code class="p">(</code><code class="n">group_by_columns</code><code class="o">=</code><code class="p">[</code><code class="s2">"user_id"</code><code class="p">],</code>&#13;
              <code class="n">aggregates</code><code class="o">=</code><code class="p">{</code><code class="s2">"num_interests"</code> <code class="p">:</code> <code class="n">count_interests</code> <code class="p">})</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>In SQL, there is also a <code>RIGHT JOIN</code>, which keeps rows from the right&#13;
table that have no matches, and a <code>FULL OUTER JOIN</code>, which keeps rows&#13;
from both tables that have no matches.  We won’t implement either of those.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Subqueries" data-type="sect1"><div class="sect1" id="idm45635706500232">&#13;
<h1>Subqueries</h1>&#13;
&#13;
<p>In<a data-primary="databases and SQL" data-secondary="subqueries" data-type="indexterm" id="idm45635705756584"/> SQL, you can <code>SELECT</code> from (and <code>JOIN</code>) the results of queries as if they were tables. So, if you wanted to find the smallest <code>user_id</code> of anyone interested in SQL, you could use a subquery. (Of course, you could do the same calculation using a <code>JOIN</code>, but that wouldn’t illustrate subqueries.)</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">SELECT</code> <code class="k">MIN</code><code class="p">(</code><code class="n">user_id</code><code class="p">)</code> <code class="k">AS</code> <code class="n">min_user_id</code> <code class="k">FROM</code>&#13;
<code class="p">(</code><code class="k">SELECT</code> <code class="n">user_id</code> <code class="k">FROM</code> <code class="n">user_interests</code> <code class="k">WHERE</code> <code class="n">interest</code> <code class="o">=</code> <code class="s1">'SQL'</code><code class="p">)</code> <code class="n">sql_interests</code><code class="p">;</code></pre>&#13;
&#13;
<p>Given the way we’ve designed NotQuiteABase, we get this for free.&#13;
(Our query results are actual tables.)</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">likes_sql_user_ids</code> <code class="o">=</code> <code class="p">(</code>&#13;
    <code class="n">user_interests</code>&#13;
    <code class="o">.</code><code class="n">where</code><code class="p">(</code><code class="k">lambda</code> <code class="n">row</code><code class="p">:</code> <code class="n">row</code><code class="p">[</code><code class="s2">"interest"</code><code class="p">]</code> <code class="o">==</code> <code class="s2">"SQL"</code><code class="p">)</code>&#13;
    <code class="o">.</code><code class="n">select</code><code class="p">(</code><code class="n">keep_columns</code><code class="o">=</code><code class="p">[</code><code class="s1">'user_id'</code><code class="p">])</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="n">likes_sql_user_ids</code><code class="o">.</code><code class="n">group_by</code><code class="p">(</code><code class="n">group_by_columns</code><code class="o">=</code><code class="p">[],</code>&#13;
                            <code class="n">aggregates</code><code class="o">=</code><code class="p">{</code> <code class="s2">"min_user_id"</code> <code class="p">:</code> <code class="n">min_user_id</code> <code class="p">})</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Indexes" data-type="sect1"><div class="sect1" id="idm45635705637352">&#13;
<h1>Indexes</h1>&#13;
&#13;
<p>To<a data-primary="databases and SQL" data-secondary="indexes" data-type="indexterm" id="idm45635705680248"/> find rows containing a specific value (say, where <code>name</code> is “Hero”),&#13;
NotQuiteABase has to inspect every row in the table.  If the table has a lot&#13;
of rows, this can take a very long time.</p>&#13;
&#13;
<p>Similarly, our <code>join</code> algorithm is extremely inefficient.  For each row in the left table, it inspects every row in the right table to see if it’s a match. With two large tables this could take approximately forever.</p>&#13;
&#13;
<p>Also, you’d often like to apply constraints to some of your columns.&#13;
For example, in your <code>users</code> table you probably don’t want to allow&#13;
two different users to have the same <code>user_id</code>.</p>&#13;
&#13;
<p>Indexes solve all these problems.  If the <code>user_interests</code> table&#13;
had an index on <code>user_id</code>, a smart <code>join</code> algorithm could find matches directly&#13;
rather than scanning the whole table.  If the <code>users</code> table had a “unique” index&#13;
on <code>user_id</code>, you’d get an error if you tried to insert a duplicate.</p>&#13;
&#13;
<p>Each table in a database can have one or more indexes, which allow&#13;
you to quickly look up rows by key columns, efficiently join tables together,&#13;
and enforce unique constraints on columns or combinations of columns.</p>&#13;
&#13;
<p>Designing and using indexes well is something of a black art&#13;
(which varies somewhat depending on the specific database),&#13;
but if you end up doing a lot of database work it’s worth learning about.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Query Optimization" data-type="sect1"><div class="sect1" id="idm45635705672072">&#13;
<h1>Query Optimization</h1>&#13;
&#13;
<p>Recall<a data-primary="databases and SQL" data-secondary="query optimization" data-type="indexterm" id="idm45635705670504"/> the query to find all users who are interested in SQL:</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">SELECT</code> <code class="n">users</code><code class="p">.</code><code class="n">name</code>&#13;
<code class="k">FROM</code> <code class="n">users</code>&#13;
<code class="k">JOIN</code> <code class="n">user_interests</code>&#13;
<code class="k">ON</code> <code class="n">users</code><code class="p">.</code><code class="n">user_id</code> <code class="o">=</code> <code class="n">user_interests</code><code class="p">.</code><code class="n">user_id</code>&#13;
<code class="k">WHERE</code> <code class="n">user_interests</code><code class="p">.</code><code class="n">interest</code> <code class="o">=</code> <code class="s1">'SQL'</code></pre>&#13;
&#13;
<p>In NotQuiteABase there are (at least) two different ways&#13;
to write this query. You could filter the <code>user_interests</code> table&#13;
before performing the join:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="p">(</code>&#13;
    <code class="n">user_interests</code>&#13;
    <code class="o">.</code><code class="n">where</code><code class="p">(</code><code class="k">lambda</code> <code class="n">row</code><code class="p">:</code> <code class="n">row</code><code class="p">[</code><code class="s2">"interest"</code><code class="p">]</code> <code class="o">==</code> <code class="s2">"SQL"</code><code class="p">)</code>&#13;
    <code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="n">users</code><code class="p">)</code>&#13;
    <code class="o">.</code><code class="n">select</code><code class="p">([</code><code class="s2">"name"</code><code class="p">])</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>Or you could filter the results of the join:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="p">(</code>&#13;
    <code class="n">user_interests</code>&#13;
    <code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="n">users</code><code class="p">)</code>&#13;
    <code class="o">.</code><code class="n">where</code><code class="p">(</code><code class="k">lambda</code> <code class="n">row</code><code class="p">:</code> <code class="n">row</code><code class="p">[</code><code class="s2">"interest"</code><code class="p">]</code> <code class="o">==</code> <code class="s2">"SQL"</code><code class="p">)</code>&#13;
    <code class="o">.</code><code class="n">select</code><code class="p">([</code><code class="s2">"name"</code><code class="p">])</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>You’ll end up with the same results either way, but filter-before-join&#13;
is almost certainly more efficient, since in that case <code>join</code> has many&#13;
fewer rows to operate on.</p>&#13;
&#13;
<p>In SQL, you generally wouldn’t worry about this.&#13;
You “declare” the results you want&#13;
and leave it up to the query engine to execute them&#13;
(and use indexes efficiently).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="NoSQL" data-type="sect1"><div class="sect1" id="idm45635705513400">&#13;
<h1>NoSQL</h1>&#13;
&#13;
<p>A<a data-primary="databases and SQL" data-secondary="NoSQL databases" data-type="indexterm" id="idm45635705512168"/><a data-primary="NoSQL databases" data-type="indexterm" id="idm45635705511160"/> recent trend in databases is toward nonrelational “NoSQL” databases,&#13;
which don’t represent data in tables.  For instance, MongoDB&#13;
is a popular schemaless database whose elements are arbitrarily complex&#13;
JSON documents rather than rows.</p>&#13;
&#13;
<p>There are column databases that store data in columns instead of&#13;
rows (good when data has many columns but queries need few of them),&#13;
key/value stores that are optimized for retrieving single (complex)&#13;
values by their keys, databases for storing and traversing graphs,&#13;
databases that are optimized to run across multiple datacenters,&#13;
databases that are designed to run in memory, databases for storing&#13;
time-series data, and hundreds more.</p>&#13;
&#13;
<p>Tomorrow’s flavor of the day might not&#13;
even exist now, so I can’t do much more than let you know that NoSQL&#13;
is a thing.  So now you know.  It’s a thing.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="For Further Exploration" data-type="sect1"><div class="sect1" id="idm45635705508424">&#13;
<h1>For Further Exploration</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If you’d like<a data-primary="databases and SQL" data-secondary="resources for learning about" data-type="indexterm" id="idm45635705506232"/><a data-primary="SQLite" data-type="indexterm" id="idm45635705505256"/><a data-primary="MySQL" data-type="indexterm" id="idm45635705504584"/><a data-primary="PostgreSQL" data-type="indexterm" id="idm45635705503912"/><a data-primary="databases and SQL" data-secondary="tools" data-type="indexterm" id="idm45635705503240"/> to download a relational database to play with,&#13;
<a href="http://www.sqlite.org">SQLite</a> is fast and tiny, while&#13;
<a href="http://www.mysql.com">MySQL</a> and&#13;
<a href="http://www.postgresql.org">PostgreSQL</a> are larger and featureful.&#13;
All are free and have lots of documentation.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you<a data-primary="MongoDB" data-type="indexterm" id="idm45635705499400"/> want to explore NoSQL, <a href="http://www.mongodb.org">MongoDB</a> is&#13;
very simple to get started with, which can be both a blessing&#13;
and somewhat of a curse. It also has pretty good documentation.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <a href="http://en.wikipedia.org/wiki/NoSQL">Wikipedia article on NoSQL</a>&#13;
almost certainly now contains links to databases that didn’t even exist&#13;
when this book was written.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>