<html><head></head><body><section data-pdf-bookmark="Chapter 7. Translating mRNA into Protein: More Functional Programming" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch07">&#13;
<h1><span class="label">Chapter 7. </span>Translating mRNA into Protein: <span class="keep-together">More Functional Programming</span></h1>&#13;
&#13;
&#13;
<p>According to the Central Dogma of molecular biology, <em>DNA makes mRNA, and mRNA makes protein</em>.<a data-primary="translating mRNA into protein" data-secondary="about" data-type="indexterm" id="idm45963633960744"/><a data-primary="DNA" data-secondary="mRNA into protein" data-see="translating mRNA into protein" data-type="indexterm" id="idm45963633959784"/><a data-primary="mRNA" data-secondary="translating into protein" data-see="translating mRNA into protein" data-type="indexterm" id="idm45963633958552"/>&#13;
In <a data-type="xref" href="ch02.html#ch02">Chapter 2</a>, I showed how to transcribe DNA to mRNA, so now it’s time to translate mRNA into protein sequences.&#13;
As described on <a href="https://oreil.ly/OgBcW">the Rosalind PROT page</a>, I now need to write a program that accepts a string of mRNA and produces an amino acid sequence.&#13;
I will show several solutions using lists, <code>for</code> loops, list comprehensions, dictionaries, and higher-order functions, but I confess I’ll end with a Biopython function.&#13;
Still, it will be tons of fun.</p>&#13;
&#13;
<p>Mostly I’m going to focus on how to write, test, and compose small functions to create solutions.&#13;
You’ll learn:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>How to extract codons/k-mers from a sequence using string slices</p>&#13;
</li>&#13;
<li>&#13;
<p>How to use a dictionary as a lookup table</p>&#13;
</li>&#13;
<li>&#13;
<p>How to translate a <code>for</code> loop into a list comprehension and a <code>map()</code> expression</p>&#13;
</li>&#13;
<li>&#13;
<p>How to use the <code>takewhile()</code> and <code>partial()</code> functions</p>&#13;
</li>&#13;
<li>&#13;
<p>How to use the <code>Bio.Seq</code> module to translate mRNA into proteins</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Getting Started" data-type="sect1"><div class="sect1" id="idm45963633946792">&#13;
<h1>Getting Started</h1>&#13;
&#13;
<p>You will need to work in the <em>07_prot</em> directory for this exercise.&#13;
I recommend you begin by copying the first solution to <code>prot.py</code> and asking for the usage:</p>&#13;
&#13;
<pre data-type="programlisting">$ cp solution1_for.py prot.py&#13;
$ ./prot.py -h&#13;
usage: prot.py [-h] RNA&#13;
&#13;
Translate RNA to proteins&#13;
&#13;
positional arguments:&#13;
  RNA         RNA sequence&#13;
&#13;
optional arguments:&#13;
  -h, --help  show this help message and exit</pre>&#13;
&#13;
<p>The program requires an RNA sequence as a single positional argument.&#13;
From here on, I’ll use the term <em>RNA</em>, but know that I mean <em>mRNA</em>.&#13;
Here’s the result using the example string from the Rosalind page:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./prot.py AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA&#13;
MAMAPRTEINSTRING</pre>&#13;
&#13;
<p>Run <strong><code>make test</code></strong> to ensure the program works properly.&#13;
When you feel you have a decent idea of how the program works, start from scratch:</p>&#13;
&#13;
<pre data-type="programlisting">$ new.py -fp 'Translate RNA to proteins' prot.py&#13;
Done, see new script "prot.py".</pre>&#13;
&#13;
<p>Here is how I define the parameters:</p>&#13;
&#13;
<pre data-type="programlisting">class Args(NamedTuple):&#13;
    """ Command-line arguments """&#13;
    rna: str <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO1-1" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO1-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
&#13;
def get_args() -&gt; Args:&#13;
    """Get command-line arguments"""&#13;
&#13;
    parser = argparse.ArgumentParser(&#13;
        description='Translate RNA to proteins',&#13;
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)&#13;
&#13;
    parser.add_argument('rna', type=str, metavar='RNA', help='RNA sequence') <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO1-2" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO1-2"><img alt="2" src="assets/2.png"/></a>&#13;
&#13;
    args = parser.parse_args()&#13;
&#13;
    return Args(args.rna)</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO1-1" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The only parameter is a string of mRNA.</p></dd>&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO1-2" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Define <code>rna</code> as a positional string.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Modify your arguments until the program will produce the correct usage, then modify your <code>main()</code> to print the incoming RNA string:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    print(args.rna)</pre>&#13;
&#13;
<p>Verify that it works:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./prot.py AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA&#13;
AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA</pre>&#13;
&#13;
<p>Run <strong><code>pytest</code></strong> or <strong><code>make test</code></strong> to see how you fare.&#13;
Your program should pass the first two tests and fail the third, where the output should be the protein translation.&#13;
If you think you can figure this out, go ahead with your solution.&#13;
It’s perfectly fine to struggle.&#13;
There’s no hurry, so take a few days if you need to.&#13;
Be sure to incorporate naps and walks (diffuse thinking time) in addition to your focused coding time.&#13;
If you need some help, read on.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="K-mers and Codons" data-type="sect2"><div class="sect2" id="idm45963633922024">&#13;
<h2>K-mers and Codons</h2>&#13;
&#13;
<p>So far you’ve seen many examples of how to iterate over the characters of a string, such as the bases of DNA.<a data-primary="translating mRNA into protein" data-secondary="codons" data-type="indexterm" id="idm45963633920632"/><a data-primary="codons" data-secondary="formed from RNA base sequences" data-type="indexterm" id="idm45963633919672"/><a data-primary="mRNA" data-secondary="codons" data-tertiary="formed from RNA base sequences" data-type="indexterm" id="idm45963633918712"/>&#13;
Here I need to group the bases of RNA into threes to read each <em>codon</em>, a sequence of three nucleotides that corresponds to an amino acid.&#13;
There are 64 codons, as shown in <a data-type="xref" href="#table_7.1">Table 7-1</a>.<a data-primary="codons" data-secondary="amino acid–codon table" data-type="indexterm" id="idm45963633915912"/><a data-primary="amino acid–codon table" data-type="indexterm" id="idm45963633914952"/><a data-primary="mRNA" data-secondary="amino acid–codon table" data-type="indexterm" id="idm45963633914264"/><a data-primary="mRNA" data-secondary="codons" data-tertiary="amino acid–codon table" data-type="indexterm" id="idm45963633913304"/><a data-primary="proteins" data-secondary="amino acid–codon table" data-type="indexterm" id="idm45963633912072"/><a data-primary="translating mRNA into protein" data-secondary="codons" data-tertiary="amino acids from" data-type="indexterm" id="idm45963633911112"/><a data-primary="codons" data-secondary="stop codons" data-type="indexterm" id="idm45963633909880"/><a data-primary="stop codons" data-type="indexterm" id="idm45963633908936"/></p>&#13;
<table id="table_7.1">&#13;
<caption><span class="label">Table 7-1. </span>The RNA codon table describes how 3-mers/codons of RNA encode the 22 amino acids</caption>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>AAA K</p></td>&#13;
<td><p>AAC N</p></td>&#13;
<td><p>AAG K</p></td>&#13;
<td><p>AAU N</p></td>&#13;
<td><p>ACA T</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>ACC T</p></td>&#13;
<td><p>ACG T</p></td>&#13;
<td><p>ACU T</p></td>&#13;
<td><p>AGA R</p></td>&#13;
<td><p>AGC S</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>AGG R</p></td>&#13;
<td><p>AGU S</p></td>&#13;
<td><p>AUA I</p></td>&#13;
<td><p>AUC I</p></td>&#13;
<td><p>AUG M</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>AUU I</p></td>&#13;
<td><p>CAA Q</p></td>&#13;
<td><p>CAC H</p></td>&#13;
<td><p>CAG Q</p></td>&#13;
<td><p>CAU H</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>CCA P</p></td>&#13;
<td><p>CCC P</p></td>&#13;
<td><p>CCG P</p></td>&#13;
<td><p>CCU P</p></td>&#13;
<td><p>CGA R</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>CGC R</p></td>&#13;
<td><p>CGG R</p></td>&#13;
<td><p>CGU R</p></td>&#13;
<td><p>CUA L</p></td>&#13;
<td><p>CUC L</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>CUG L</p></td>&#13;
<td><p>CUU L</p></td>&#13;
<td><p>GAA E</p></td>&#13;
<td><p>GAC D</p></td>&#13;
<td><p>GAG E</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>GAU D</p></td>&#13;
<td><p>GCA A</p></td>&#13;
<td><p>GCC A</p></td>&#13;
<td><p>GCG A</p></td>&#13;
<td><p>GCU A</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>GGA G</p></td>&#13;
<td><p>GGC G</p></td>&#13;
<td><p>GGG G</p></td>&#13;
<td><p>GGU G</p></td>&#13;
<td><p>GUA V</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>GUC V</p></td>&#13;
<td><p>GUG V</p></td>&#13;
<td><p>GUU V</p></td>&#13;
<td><p>UAC Y</p></td>&#13;
<td><p>UAU Y</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>UCA S</p></td>&#13;
<td><p>UCC S</p></td>&#13;
<td><p>UCG S</p></td>&#13;
<td><p>UCU S</p></td>&#13;
<td><p>UGC C</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>UGG W</p></td>&#13;
<td><p>UGU C</p></td>&#13;
<td><p>UUA L</p></td>&#13;
<td><p>UUC F</p></td>&#13;
<td><p>UUG L</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>UUU F</p></td>&#13;
<td><p>UAA Stop</p></td>&#13;
<td><p>UAG Stop</p></td>&#13;
<td><p>UGA Stop</p></td>&#13;
<td/>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Given some string of RNA:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; rna = 'AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA'</pre>&#13;
&#13;
<p>I want to read the first three bases, <em>AUG</em>.&#13;
As shown in <a data-type="xref" href="#fig_7.1">Figure 7-1</a>, I can use a string slice to manually grab the characters from indexes 0 to 3 (remembering that the upper bound is not inclusive):<a data-primary="strings (str)" data-secondary="slices to extract codons from mRNA" data-type="indexterm" id="idm45963633860520"/><a data-primary="codons" data-secondary="extracting from mRNA via string slices" data-type="indexterm" id="idm45963633859560"/><a data-primary="lists" data-secondary="string slices to extract codons" data-type="indexterm" id="idm45963633858600"/><a data-primary="mRNA" data-secondary="codons" data-tertiary="string slices to extract from mRNA" data-type="indexterm" id="idm45963633857640"/><a data-primary="translating mRNA into protein" data-secondary="codons" data-tertiary="extracting from mRNA via string slices" data-type="indexterm" id="idm45963633856408"/><a data-primary="k-mers" data-secondary="extracting 3-mers via string slices" data-type="indexterm" id="idm45963633855160"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; rna[0:3]&#13;
'AUG'</pre>&#13;
&#13;
<figure><div class="figure" id="fig_7.1">&#13;
<img alt="mpfb 0701" src="assets/mpfb_0701.png"/>&#13;
<h6><span class="label">Figure 7-1. </span>Extracting codons from RNA using string slices</h6>&#13;
</div></figure>&#13;
&#13;
<p>The next codon can be found by adding 3 to the start and stop positions:<a data-primary="codons" data-secondary="stop codons" data-type="indexterm" id="idm45963633850888"/><a data-primary="codons" data-secondary="start codons" data-type="indexterm" id="idm45963633849944"/><a data-primary="start codons" data-type="indexterm" id="idm45963633849000"/><a data-primary="stop codons" data-type="indexterm" id="idm45963633848328"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; rna[3:6]&#13;
'GCC'</pre>&#13;
&#13;
<p>Can you see a pattern emerging?&#13;
For the first number, I need to start at 0 and add 3.&#13;
For the second number, I need to add 3 to the first number (see <a data-type="xref" href="#fig_7.2">Figure 7-2</a>).</p>&#13;
&#13;
<figure><div class="figure" id="fig_7.2">&#13;
<img alt="mpfb 0702" src="assets/mpfb_0702.png"/>&#13;
<h6><span class="label">Figure 7-2. </span>Each slice is a function of the start positions of the codons, which can be found using the <code>range()</code> function</h6>&#13;
</div></figure>&#13;
&#13;
<p>I can handle the first part using the <code>range()</code> function, which can take one, two, or three arguments.&#13;
Given just one argument, it will produce all the numbers from 0 up to but not including the given value.&#13;
Note this is a lazy function which I’ll coerce with <code>list()</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(range(10))&#13;
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</pre>&#13;
&#13;
<p>Given two arguments, <code>range()</code> will assume the first is the start and the second is the stop:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(range(5, 10))&#13;
[5, 6, 7, 8, 9]</pre>&#13;
&#13;
<p>A third argument will be interpreted as the step size.&#13;
In <a data-type="xref" href="ch03.html#ch03">Chapter 3</a>, I used <code>range()</code> with no start or stop positions and a step size of <code>-1</code> to reverse a string.&#13;
In this case, I want to count from 0 up to the length of the RNA, stepping by 3.&#13;
These are the starting positions for the codons:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(range(0, len(rna), 3))&#13;
[0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48]</pre>&#13;
&#13;
<p>I can use a list comprehension to generate the start and stop values as tuples.&#13;
The stop positions are 3 more than the start positions.&#13;
I’ll show just the first five:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; [(n, n + 3) for n in range(0, len(rna), 3)][:5]&#13;
[(0, 3), (3, 6), (6, 9), (9, 12), (12, 15)]</pre>&#13;
&#13;
<p>I can use those values to take slices of the RNA:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; [rna[n:n + 3] for n in range(0, len(rna), 3)][:5]&#13;
['AUG', 'GCC', 'AUG', 'GCG', 'CCC']</pre>&#13;
&#13;
<p>The codons are subsequences of the RNA, and they are similar to <em>k-mers</em>.<a data-primary="k-mers" data-secondary="about" data-type="indexterm" id="idm45963633832152"/><a data-primary="mRNA" data-secondary="k-mers" data-type="indexterm" id="idm45963633831208"/>&#13;
The <em>k</em> is the size, here 3, and <em>mer</em> is <em>a share</em> as in the word <em>polymer</em>.&#13;
It’s common to refer to k-mers by their size, so here I might call these <em>3-mers</em>.&#13;
The k-mers overlap by one character, so the window shifts right by one base.&#13;
<a data-type="xref" href="#fig_7.3">Figure 7-3</a> shows the first seven 3-mers found in the first nine bases of the input RNA.</p>&#13;
&#13;
<figure><div class="figure" id="fig_7.3">&#13;
<img alt="mpfb 0703" src="assets/mpfb_0703.png"/>&#13;
<h6><span class="label">Figure 7-3. </span>All the 3-mers in the first nine bases of the RNA sequence</h6>&#13;
</div></figure>&#13;
&#13;
<p>The number <em>n</em> of k-mers in any sequence <em>s</em> is:</p>&#13;
<div data-type="equation">&#13;
<math alttext="n equals l e n left-parenthesis s right-parenthesis minus k plus 1" display="block">&#13;
  <mrow>&#13;
    <mi>n</mi>&#13;
    <mo>=</mo>&#13;
    <mi>l</mi>&#13;
    <mi>e</mi>&#13;
    <mi>n</mi>&#13;
    <mo>(</mo>&#13;
    <mi>s</mi>&#13;
    <mo>)</mo>&#13;
    <mo>-</mo>&#13;
    <mi>k</mi>&#13;
    <mo>+</mo>&#13;
    <mn>1</mn>&#13;
  </mrow>&#13;
</math>&#13;
</div>&#13;
&#13;
<p>The length of this RNA sequence is 51, so it contains 49 3-mers:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; len(rna) - k + 1&#13;
49</pre>&#13;
&#13;
<p>Except when considering multiframe translation, which I’ll show in <a data-type="xref" href="ch14.html#ch14">Chapter 14</a>, codons do not overlap and so shift 3 positions (see <a data-type="xref" href="#fig_7.4">Figure 7-4</a>), leaving 17 codons:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; len([rna[n:n + 3] for n in range(0, len(rna), 3)])&#13;
17</pre>&#13;
&#13;
<figure><div class="figure" id="fig_7.4">&#13;
<img alt="mpfb 0704" src="assets/mpfb_0704.png"/>&#13;
<h6><span class="label">Figure 7-4. </span>Codons are nonoverlapping 3-mers</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Translating Codons" data-type="sect2"><div class="sect2" id="idm45963633815336">&#13;
<h2>Translating Codons</h2>&#13;
&#13;
<p>Now that you know how to extract the codons from the RNA, let’s consider how to translate a codon into a protein.<a data-primary="codons" data-secondary="translating into protein" data-type="indexterm" id="idm45963633813944"/><a data-primary="proteins" data-secondary="codons translated into" data-seealso="translating mRNA into protein" data-type="indexterm" id="idm45963633812984"/><a data-primary="translating mRNA into protein" data-secondary="codons" data-tertiary="translating into protein" data-type="indexterm" id="idm45963633811752"/>&#13;
The Rosalind page provides the following translation table:</p>&#13;
&#13;
<pre data-type="programlisting">UUU F      CUU L      AUU I      GUU V&#13;
UUC F      CUC L      AUC I      GUC V&#13;
UUA L      CUA L      AUA I      GUA V&#13;
UUG L      CUG L      AUG M      GUG V&#13;
UCU S      CCU P      ACU T      GCU A&#13;
UCC S      CCC P      ACC T      GCC A&#13;
UCA S      CCA P      ACA T      GCA A&#13;
UCG S      CCG P      ACG T      GCG A&#13;
UAU Y      CAU H      AAU N      GAU D&#13;
UAC Y      CAC H      AAC N      GAC D&#13;
UAA Stop   CAA Q      AAA K      GAA E&#13;
UAG Stop   CAG Q      AAG K      GAG E&#13;
UGU C      CGU R      AGU S      GGU G&#13;
UGC C      CGC R      AGC S      GGC G&#13;
UGA Stop   CGA R      AGA R      GGA G&#13;
UGG W      CGG R      AGG R      GGG G</pre>&#13;
&#13;
<p>A dictionary would be a natural data structure to look up a string like <code>AUG</code> to find that it translates to the protein <code>M</code>, which happens to be the codon that indicates the beginning of a protein sequence.<a data-primary="dictionaries" data-secondary="codons translated into protein" data-type="indexterm" id="idm45963633807464"/>&#13;
I will leave it to you to incorporate this data into your program.&#13;
For what it’s worth, I changed <code>Stop</code> to <code>*</code> in my dictionary for the stop codon, which indicates the end of the protein sequence.<a data-primary="codons" data-secondary="stop codons" data-type="indexterm" id="idm45963633805304"/><a data-primary="stop codons" data-type="indexterm" id="idm45963633804360"/>&#13;
I called my dictionary <code>codon_to_aa</code>, and I can use it like so:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; rna = 'AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA'&#13;
&gt;&gt;&gt; aa = []&#13;
&gt;&gt;&gt; for codon in [rna[n:n + 3] for n in range(0, len(rna), 3)]:&#13;
...     aa.append(codon_to_aa[codon])&#13;
...&#13;
&gt;&gt;&gt; aa&#13;
['M', 'A', 'M', 'A', 'P', 'R', 'T', 'E', 'I', 'N', 'S', 'T', 'R', 'I',&#13;
 'N', 'G', '*']</pre>&#13;
&#13;
<p>The <code>*</code> codon indicates where the translation ends and is often shown so you know that a stop was found and the protein is complete.&#13;
For the purposes of passing the Rosalind tests, the stop should not be included in the output.&#13;
Note that the stop codon may occur before the end of the RNA string.&#13;
This should be enough hints for you to create a solution that passes the tests.&#13;
Be sure to run <strong><code>pytest</code></strong> and <strong><code>make test</code></strong> to ensure your program is logically and stylistically correct.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solutions" data-type="sect1"><div class="sect1" id="idm45963633799128">&#13;
<h1>Solutions</h1>&#13;
&#13;
<p>In this section, I will show five variations on how to translate RNA into protein, moving from wholly manual solutions where I encode the RNA codon table with a dictionary to a single line of code that uses a function from Biopython.&#13;
All solutions use the same <code>get_args()</code> as shown previously.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 1: Using a for Loop" data-type="sect2"><div class="sect2" id="idm45963633796984">&#13;
<h2>Solution 1: Using a for Loop</h2>&#13;
&#13;
<p>Here is the whole of my first solution, which uses a <code>for</code> loop to iterate the codons to translate them via a dictionary:<a data-primary="translating mRNA into protein" data-secondary="solution 1 for loop" data-type="indexterm" id="idm45963633795144"/></p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    rna = args.rna.upper() <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-1" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-1"><img alt="1" src="assets/1.png"/></a>&#13;
    codon_to_aa = { <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-2" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-2"><img alt="2" src="assets/2.png"/></a>&#13;
        'AAA': 'K', 'AAC': 'N', 'AAG': 'K', 'AAU': 'N', 'ACA': 'T',&#13;
        'ACC': 'T', 'ACG': 'T', 'ACU': 'T', 'AGA': 'R', 'AGC': 'S',&#13;
        'AGG': 'R', 'AGU': 'S', 'AUA': 'I', 'AUC': 'I', 'AUG': 'M',&#13;
        'AUU': 'I', 'CAA': 'Q', 'CAC': 'H', 'CAG': 'Q', 'CAU': 'H',&#13;
        'CCA': 'P', 'CCC': 'P', 'CCG': 'P', 'CCU': 'P', 'CGA': 'R',&#13;
        'CGC': 'R', 'CGG': 'R', 'CGU': 'R', 'CUA': 'L', 'CUC': 'L',&#13;
        'CUG': 'L', 'CUU': 'L', 'GAA': 'E', 'GAC': 'D', 'GAG': 'E',&#13;
        'GAU': 'D', 'GCA': 'A', 'GCC': 'A', 'GCG': 'A', 'GCU': 'A',&#13;
        'GGA': 'G', 'GGC': 'G', 'GGG': 'G', 'GGU': 'G', 'GUA': 'V',&#13;
        'GUC': 'V', 'GUG': 'V', 'GUU': 'V', 'UAC': 'Y', 'UAU': 'Y',&#13;
        'UCA': 'S', 'UCC': 'S', 'UCG': 'S', 'UCU': 'S', 'UGC': 'C',&#13;
        'UGG': 'W', 'UGU': 'C', 'UUA': 'L', 'UUC': 'F', 'UUG': 'L',&#13;
        'UUU': 'F', 'UAA': '*', 'UAG': '*', 'UGA': '*',&#13;
    }&#13;
&#13;
    k = 3 <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-3" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-3"><img alt="3" src="assets/3.png"/></a>&#13;
    protein = '' <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-4" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-4"><img alt="4" src="assets/4.png"/></a>&#13;
    for codon in [rna[i:i + k] for i in range(0, len(rna), k)]: <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-5" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-5"><img alt="5" src="assets/5.png"/></a>&#13;
        aa = codon_to_aa.get(codon, '-') <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-6" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-6"><img alt="6" src="assets/6.png"/></a>&#13;
        if aa == '*': <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-7" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-7"><img alt="7" src="assets/7.png"/></a>&#13;
            break <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-8" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-8"><img alt="8" src="assets/8.png"/></a>&#13;
        protein += aa <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-9" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-9"><img alt="9" src="assets/9.png"/></a>&#13;
&#13;
    print(protein) <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-10" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-10"><img alt="10" src="assets/10.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-1" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Copy the incoming RNA, forcing to uppercase.</p></dd>&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-2" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Create a codon/AA lookup table using a dictionary.</p></dd>&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-3" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Establish the size of <code>k</code> for finding k-mers.</p></dd>&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-4" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Initialize the protein sequence to the empty string.</p></dd>&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-5" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Iterate through the codons of the RNA.</p></dd>&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-6" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Use <code>dict.get()</code> to look up the amino acid for this codon, and return a dash if it is not found.</p></dd>&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-7" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Check if this is the stop codon.</p></dd>&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-8" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Break out of the <code>for</code> loop.</p></dd>&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-9" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-9"><img alt="9" src="assets/9.png"/></a></dt>&#13;
<dd><p>Append the amino acid to the protein sequence.</p></dd>&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-10" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-10"><img alt="10" src="assets/10.png"/></a></dt>&#13;
<dd><p>Print the protein sequence.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 2: Adding Unit Tests" data-type="sect2"><div class="sect2" id="idm45963633742936">&#13;
<h2>Solution 2: Adding Unit Tests</h2>&#13;
&#13;
<p>The first solution works adequately well and, for such a short program, has a decent organization.<a data-primary="translating mRNA into protein" data-secondary="solution 2 adding unit tests" data-type="indexterm" id="idm45963633741544"/><a data-primary="unit testing" data-secondary="translating mRNA into protein" data-type="indexterm" id="idm45963633740568"/>&#13;
The problem is that short programs usually become long programs.&#13;
It’s common to make functions longer and longer, so I’d like to show how I can break up the code in <code>main()</code> into a couple of smaller functions with tests.&#13;
Generally speaking, I like to see a function fit into 50 lines or fewer on the high end.&#13;
As for how short a function can be, I’m not opposed to a single line of code.</p>&#13;
&#13;
<p>My first intuition is to extract the code that finds the codons and make that into a function with a unit test.&#13;
I can start by defining a placeholder for the function with a type signature that helps me think about what the function accepts as arguments and will return as a result:</p>&#13;
&#13;
<pre data-type="programlisting">def codons(seq: str) -&gt; List[str]: <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO3-1" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO3-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Extract codons from a sequence """&#13;
&#13;
    return [] <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO3-2" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO3-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO3-1" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The function will accept a string and will return a list of strings.</p></dd>&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO3-2" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>For now, just return an empty list.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Next, I define a <code>test_codons()</code> function to imagine how it might work.&#13;
Whenever I have a string as a function parameter, I try passing the empty string.&#13;
(Whenever I have an integer as a function parameter, I try passing <code>0</code>.)&#13;
Then I try other possible values and imagine what the function ought to do.&#13;
As you can see, I’m making some judgment calls here by returning strings shorter than three bases.&#13;
I only expect the function to break a string into substrings of <em>at least</em> three bases.&#13;
There’s no reason to let perfect be the enemy of good enough here:</p>&#13;
&#13;
<pre data-type="programlisting">def test_codons() -&gt; None:&#13;
    """ Test codons """&#13;
&#13;
    assert codons('') == []&#13;
    assert codons('A') == ['A']&#13;
    assert codons('ABC') == ['ABC']&#13;
    assert codons('ABCDE') == ['ABC', 'DE']&#13;
    assert codons('ABCDEF') == ['ABC', 'DEF']</pre>&#13;
&#13;
<p>Now to write the function that will satisfy these tests.&#13;
If I move the relevant code from <code>main()</code> into the <code>codons()</code> function, I get this:</p>&#13;
&#13;
<pre data-type="programlisting">def codons(seq: str) -&gt; List[str]:&#13;
    """ Extract codons from a sequence """&#13;
&#13;
    k = 3&#13;
    ret = []&#13;
    for codon in [seq[i:i + k] for i in range(0, len(seq), k)]:&#13;
        ret.append(codon)&#13;
&#13;
    return ret</pre>&#13;
&#13;
<p>If I try running <code>pytest</code> on this program, I see it passes.&#13;
Huzzah!&#13;
Since the <code>for</code> loop <span class="keep-together">is being used</span> to build up a return list, it would be stylistically better to use a list <span class="keep-together">comprehension:</span></p>&#13;
&#13;
<pre data-type="programlisting">def codons(seq: str) -&gt; List[str]:&#13;
    """ Extract codons from a sequence """&#13;
&#13;
    k = 3&#13;
    return [seq[i:i + k] for i in range(0, len(seq), k)]</pre>&#13;
&#13;
<p>This is a nice little function that is documented and tested and which will make the rest of the code more readable:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    rna = args.rna.upper()&#13;
    codon_to_aa = {&#13;
        'AAA': 'K', 'AAC': 'N', 'AAG': 'K', 'AAU': 'N', 'ACA': 'T',&#13;
        'ACC': 'T', 'ACG': 'T', 'ACU': 'T', 'AGA': 'R', 'AGC': 'S',&#13;
        'AGG': 'R', 'AGU': 'S', 'AUA': 'I', 'AUC': 'I', 'AUG': 'M',&#13;
        'AUU': 'I', 'CAA': 'Q', 'CAC': 'H', 'CAG': 'Q', 'CAU': 'H',&#13;
        'CCA': 'P', 'CCC': 'P', 'CCG': 'P', 'CCU': 'P', 'CGA': 'R',&#13;
        'CGC': 'R', 'CGG': 'R', 'CGU': 'R', 'CUA': 'L', 'CUC': 'L',&#13;
        'CUG': 'L', 'CUU': 'L', 'GAA': 'E', 'GAC': 'D', 'GAG': 'E',&#13;
        'GAU': 'D', 'GCA': 'A', 'GCC': 'A', 'GCG': 'A', 'GCU': 'A',&#13;
        'GGA': 'G', 'GGC': 'G', 'GGG': 'G', 'GGU': 'G', 'GUA': 'V',&#13;
        'GUC': 'V', 'GUG': 'V', 'GUU': 'V', 'UAC': 'Y', 'UAU': 'Y',&#13;
        'UCA': 'S', 'UCC': 'S', 'UCG': 'S', 'UCU': 'S', 'UGC': 'C',&#13;
        'UGG': 'W', 'UGU': 'C', 'UUA': 'L', 'UUC': 'F', 'UUG': 'L',&#13;
        'UUU': 'F', 'UAA': '*', 'UAG': '*', 'UGA': '*',&#13;
    }&#13;
&#13;
    protein = ''&#13;
    for codon in codons(rna): <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO4-1" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO4-1"><img alt="1" src="assets/1.png"/></a>&#13;
        aa = codon_to_aa.get(codon, '-')&#13;
        if aa == '*':&#13;
            break&#13;
        protein += aa&#13;
&#13;
    print(protein)</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO4-1" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The complexity of finding the codons is hidden in a function.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Further, this function (and its test) will now be easier to incorporate into another program.&#13;
The simplest case would be to copy and paste these lines, but a better solution would be to share the function.&#13;
Let me demonstrate using the REPL.&#13;
If you have the <code>codons()</code> function in your <code>prot.py</code> program, then import the function:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from prot import codons</pre>&#13;
&#13;
<p>Now you can execute the <code>codons()</code> function:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; codons('AAACCCGGGTTT')&#13;
['AAA', 'CCC', 'GGG', 'TTT']</pre>&#13;
&#13;
<p>Or you can import the entire <code>prot</code> module and call the function like so:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import prot&#13;
&gt;&gt;&gt; prot.codons('AAACCCGGGTTT')&#13;
['AAA', 'CCC', 'GGG', 'TTT']</pre>&#13;
&#13;
<p>Python <em>programs</em> are also <em>modules</em> of reusable code.<a data-primary="Python" data-secondary="programs also modules" data-type="indexterm" id="idm45963633703096"/>&#13;
Sometimes you execute a source code file and it becomes a program, but there’s not a big distinction in Python between a program and a module.&#13;
This is the meaning of the couplet at the end of all the programs:</p>&#13;
&#13;
<pre data-type="programlisting">if __name__ == '__main__': <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO5-1" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO5-1"><img alt="1" src="assets/1.png"/></a>&#13;
    main() <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO5-2" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO5-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO5-1" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>When a Python program is being <em>executed</em> as a program, the value of <code>__name__</code> is <code>__main__</code>.<a data-primary="Python" data-secondary="programs also modules" data-tertiary="__name__" data-type="indexterm" id="idm45963633692584"/><a data-primary="__name__" data-primary-sortas="# name" data-type="indexterm" id="idm45963633691368"/></p></dd>&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO5-2" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Call the <code>main()</code> function to start the program.<a data-primary="main() function" data-type="indexterm" id="idm45963633687256"/><a data-primary="functions" data-secondary="main()" data-type="indexterm" id="idm45963633686584"/></p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note">&#13;
<p>When a Python module is being <em>imported</em> by another piece of code, then the <code>__name__</code> is the name of the module;<a data-primary="Python" data-secondary="program execution versus being imported" data-tertiary="__name__" data-type="indexterm" id="idm45963633683528"/> for example, <code>prot</code> in the case of <code>prot.py</code>. If you simply called <code>main()</code> at the end of the program without checking the <code>__name__</code>, then it would be executed whenever your module is imported, which is not good.</p>&#13;
</div>&#13;
&#13;
<p>As you write more and more Python, you’ll likely find you’re solving some of the same problems repeatedly. It would be far better to share common solutions by writing functions that you share across projects rather than copy-pasting bits of code. Python makes it pretty easy to put reusable functions into modules and import them into other programs.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 3: Another Function and a List Comprehension" data-type="sect2"><div class="sect2" id="idm45963633678984">&#13;
<h2>Solution 3: Another Function and a List Comprehension</h2>&#13;
&#13;
<p>The <code>codons()</code> function is tidy and useful and makes the <code>main()</code> function easier to understand; however, all the code that’s left in <code>main()</code> is concerned with translating the protein.<a data-primary="translating mRNA into protein" data-secondary="solution 3 list comprehension" data-type="indexterm" id="idm45963633676200"/><a data-primary="list comprehension" data-secondary="translating mRNA into protein" data-type="indexterm" id="idm45963633675224"/>&#13;
I’d like to hide this away in a <code>translate()</code> function, and here is the test I’d like to use:<a data-primary="translate() function for strings" data-secondary="translating mRNA into protein" data-type="indexterm" id="idm45963633673608"/><a data-primary="strings (str)" data-secondary="translate() function" data-type="indexterm" id="idm45963633672632"/></p>&#13;
&#13;
<pre data-type="programlisting">def test_translate() -&gt; None:&#13;
    """ Test translate """&#13;
&#13;
    assert translate('') == '' <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-1" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-1"><img alt="1" src="assets/1.png"/></a>&#13;
    assert translate('AUG') == 'M' <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-2" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-2"><img alt="2" src="assets/2.png"/></a>&#13;
    assert translate('AUGCCGUAAUCU') == 'MP' <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-3" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-3"><img alt="3" src="assets/3.png"/></a>&#13;
    assert translate('AUGGCCAUGGCGCCCAGAACUGAGAU' <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-4" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-4"><img alt="4" src="assets/4.png"/></a>&#13;
                     'CAAUAGUACCCGUAUUAACGGGUGA') == 'MAMAPRTEINSTRING' <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-5" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-5"><img alt="5" src="assets/5.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-1" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>I usually test string parameters with the empty string.</p></dd>&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-2" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Test for a single amino acid.</p></dd>&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-3" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Test using a stop codon before the end of the sequence.</p></dd>&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-4" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Notice that adjacent string literals are joined into a single string. This is a useful way to break long lines in source code.</p></dd>&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-5" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Test using the example from Rosalind.</p></dd>&#13;
</dl>&#13;
&#13;
<p>I move all the code from <code>main()</code> into this, changing the <code>for</code> loop to a list comprehension and using a list slice to truncate the protein at the stop codon:</p>&#13;
&#13;
<pre data-type="programlisting">def translate(rna: str) -&gt; str:&#13;
    """ Translate codon sequence """&#13;
&#13;
    codon_to_aa = {&#13;
        'AAA': 'K', 'AAC': 'N', 'AAG': 'K', 'AAU': 'N', 'ACA': 'T',&#13;
        'ACC': 'T', 'ACG': 'T', 'ACU': 'T', 'AGA': 'R', 'AGC': 'S',&#13;
        'AGG': 'R', 'AGU': 'S', 'AUA': 'I', 'AUC': 'I', 'AUG': 'M',&#13;
        'AUU': 'I', 'CAA': 'Q', 'CAC': 'H', 'CAG': 'Q', 'CAU': 'H',&#13;
        'CCA': 'P', 'CCC': 'P', 'CCG': 'P', 'CCU': 'P', 'CGA': 'R',&#13;
        'CGC': 'R', 'CGG': 'R', 'CGU': 'R', 'CUA': 'L', 'CUC': 'L',&#13;
        'CUG': 'L', 'CUU': 'L', 'GAA': 'E', 'GAC': 'D', 'GAG': 'E',&#13;
        'GAU': 'D', 'GCA': 'A', 'GCC': 'A', 'GCG': 'A', 'GCU': 'A',&#13;
        'GGA': 'G', 'GGC': 'G', 'GGG': 'G', 'GGU': 'G', 'GUA': 'V',&#13;
        'GUC': 'V', 'GUG': 'V', 'GUU': 'V', 'UAC': 'Y', 'UAU': 'Y',&#13;
        'UCA': 'S', 'UCC': 'S', 'UCG': 'S', 'UCU': 'S', 'UGC': 'C',&#13;
        'UGG': 'W', 'UGU': 'C', 'UUA': 'L', 'UUC': 'F', 'UUG': 'L',&#13;
        'UUU': 'F', 'UAA': '*', 'UAG': '*', 'UGA': '*',&#13;
    }&#13;
&#13;
    aa = [codon_to_aa.get(codon, '-') for codon in codons(rna)] <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-1" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-1"><img alt="1" src="assets/1.png"/></a>&#13;
    if '*' in aa: <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-2" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-2"><img alt="2" src="assets/2.png"/></a>&#13;
        aa = aa[:aa.index('*')] <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-3" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-3"><img alt="3" src="assets/3.png"/></a>&#13;
&#13;
    return ''.join(aa) <a class="co" href="#callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-4" id="co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-4"><img alt="4" src="assets/4.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-1" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Use a list comprehension to translate the list of codons to a list of amino acids.</p></dd>&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-2" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>See if the stop (<code>*</code>) codon is present in the list of amino acids.</p></dd>&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-3" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Overwrite the amino acids using a list slice up to the index of the stop codon.</p></dd>&#13;
<dt><a class="co" href="#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-4" id="callout_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Join the amino acids on the empty string and return the new protein sequence.</p></dd>&#13;
</dl>&#13;
&#13;
<p>To understand this, consider the following RNA sequence:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; rna = 'AUGCCGUAAUCU'</pre>&#13;
&#13;
<p>I can use the <code>codons()</code> function to get the codons:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from solution3_list_comp_slice import codons, translate&#13;
&gt;&gt;&gt; codons(rna)&#13;
['AUG', 'CCG', 'UAA', 'UCU']</pre>&#13;
&#13;
<p>And use a list comprehension to turn those into amino acids:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; codon_to_aa = {&#13;
...     'AAA': 'K', 'AAC': 'N', 'AAG': 'K', 'AAU': 'N', 'ACA': 'T',&#13;
...     'ACC': 'T', 'ACG': 'T', 'ACU': 'T', 'AGA': 'R', 'AGC': 'S',&#13;
...     'AGG': 'R', 'AGU': 'S', 'AUA': 'I', 'AUC': 'I', 'AUG': 'M',&#13;
...     'AUU': 'I', 'CAA': 'Q', 'CAC': 'H', 'CAG': 'Q', 'CAU': 'H',&#13;
...     'CCA': 'P', 'CCC': 'P', 'CCG': 'P', 'CCU': 'P', 'CGA': 'R',&#13;
...     'CGC': 'R', 'CGG': 'R', 'CGU': 'R', 'CUA': 'L', 'CUC': 'L',&#13;
...     'CUG': 'L', 'CUU': 'L', 'GAA': 'E', 'GAC': 'D', 'GAG': 'E',&#13;
...     'GAU': 'D', 'GCA': 'A', 'GCC': 'A', 'GCG': 'A', 'GCU': 'A',&#13;
...     'GGA': 'G', 'GGC': 'G', 'GGG': 'G', 'GGU': 'G', 'GUA': 'V',&#13;
...     'GUC': 'V', 'GUG': 'V', 'GUU': 'V', 'UAC': 'Y', 'UAU': 'Y',&#13;
...     'UCA': 'S', 'UCC': 'S', 'UCG': 'S', 'UCU': 'S', 'UGC': 'C',&#13;
...     'UGG': 'W', 'UGU': 'C', 'UUA': 'L', 'UUC': 'F', 'UUG': 'L',&#13;
...     'UUU': 'F', 'UAA': '*', 'UAG': '*', 'UGA': '*',&#13;
... }&#13;
&gt;&gt;&gt; aa = [codon_to_aa.get(c, '-') for c in codons(rna)]&#13;
&gt;&gt;&gt; aa&#13;
['M', 'P', '*', 'S']</pre>&#13;
&#13;
<p>I can see the stop codon is present:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; '*' in aa&#13;
True</pre>&#13;
&#13;
<p>and so the sequence needs to be truncated at index 2:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; aa.index('*')&#13;
2</pre>&#13;
&#13;
<p>I can use a list slice to select up to the position of the stop codon.&#13;
If no start position is supplied, then Python assumes the index 0:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; aa = aa[:aa.index('*')]&#13;
&gt;&gt;&gt; aa&#13;
['M', 'P']</pre>&#13;
&#13;
<p>Finally, this list needs to be joined on the empty string:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; ''.join(aa)&#13;
'MP'</pre>&#13;
&#13;
<p>The <code>main()</code> function incorporates the new function and makes for a very readable program:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    print(translate(args.rna.upper()))</pre>&#13;
&#13;
<p>This is another instance where the unit test almost duplicates the integration test that verifies the program translates RNA into protein.&#13;
The latter is still important as it ensures that the program works, produces documentation, handles the arguments, and so forth.&#13;
As overengineered as this solution may seem, I want you to focus on how to break programs into smaller <em>functions</em> that you can understand, test, compose, and share.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 4: Functional Programming with the map(), partial(), and takewhile() Functions" data-type="sect2"><div class="sect2" id="idm45963633609768">&#13;
<h2>Solution 4: Functional Programming with the map(), partial(), and takewhile() Functions</h2>&#13;
&#13;
<p>For this next solution, I want to show how to rewrite some of the logic using three HOFs, <code>map()</code>, <code>partial()</code>, and <code>takewhile()</code>.<a data-primary="translating mRNA into protein" data-secondary="solution 4 HOFs" data-type="indexterm" id="idm45963633606984"/><a data-primary="higher-order functions (HOFs)" data-secondary="translating mRNA into protein" data-type="indexterm" id="idm45963633606024"/><a data-primary="map() function transforming" data-secondary="translating mRNA into protein" data-type="indexterm" id="idm45963633605048"/><a data-primary="partial() to partially apply functions" data-secondary="translating mRNA into protein" data-type="indexterm" id="idm45963633604072"/><a data-primary="takewhile() higher-order function" data-type="indexterm" id="idm45963633603096"/>&#13;
<a data-type="xref" href="#fig_7.5">Figure 7-5</a> shows how the list comprehension can be rewritten as a <code>map()</code>.</p>&#13;
&#13;
<figure><div class="figure" id="fig_7.5">&#13;
<img alt="mpfb 0705" src="assets/mpfb_0705.png"/>&#13;
<h6><span class="label">Figure 7-5. </span>A list comprehension can be rewritten as a <code>map()</code></h6>&#13;
</div></figure>&#13;
&#13;
<p>I can use <code>map()</code> to get the amino acid sequence.&#13;
You may or may not feel this is easier to read than a list comprehension; the point is to understand that they are functionally equivalent, both transforming one list into a new list:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; aa = list(map(lambda codon: codon_to_aa.get(codon, '-'), codons(rna)))&#13;
&gt;&gt;&gt; aa&#13;
['M', 'P', '*', 'S']</pre>&#13;
&#13;
<p>The code to find the stop codon and slice the list can be rewritten using the <span class="keep-together"><code>itertools.takewhile()</code></span> function:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from itertools import takewhile</pre>&#13;
&#13;
<p>As the name implies, this function will <em>take</em> elements from a sequence <em>while</em> the predicate is met.&#13;
Once the predicate fails, the function stops producing values.&#13;
Here the condition is that the residue is not <code>*</code> (stop):</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(takewhile(lambda residue: residue != '*', aa))&#13;
['M', 'P']</pre>&#13;
&#13;
<p>If you like using these kinds of HOFs, you can take this even further by using the <code>functools.partial()</code> function I showed in <a data-type="xref" href="ch04.html#ch04">Chapter 4</a>.&#13;
Here I want to partially apply the <code>operator.ne()</code> (not equal) function:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from functools import partial&#13;
&gt;&gt;&gt; import operator&#13;
&gt;&gt;&gt; not_stop = partial(operator.ne, '*')</pre>&#13;
&#13;
<p>The <code>not_stop()</code> function needs one more string value before it can return a value:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; not_stop('F')&#13;
True&#13;
&gt;&gt;&gt; not_stop('*')&#13;
False</pre>&#13;
&#13;
<p>When I compose these functions, they almost read like an English sentence:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(takewhile(not_stop, aa))&#13;
['M', 'P']</pre>&#13;
&#13;
<p>Here is how I would write the <code>translate()</code> function with purely functional ideas:</p>&#13;
&#13;
<pre data-type="programlisting">def translate(rna: str) -&gt; str:&#13;
    """ Translate codon sequence """&#13;
&#13;
    codon_to_aa = {&#13;
        'AAA': 'K', 'AAC': 'N', 'AAG': 'K', 'AAU': 'N', 'ACA': 'T',&#13;
        'ACC': 'T', 'ACG': 'T', 'ACU': 'T', 'AGA': 'R', 'AGC': 'S',&#13;
        'AGG': 'R', 'AGU': 'S', 'AUA': 'I', 'AUC': 'I', 'AUG': 'M',&#13;
        'AUU': 'I', 'CAA': 'Q', 'CAC': 'H', 'CAG': 'Q', 'CAU': 'H',&#13;
        'CCA': 'P', 'CCC': 'P', 'CCG': 'P', 'CCU': 'P', 'CGA': 'R',&#13;
        'CGC': 'R', 'CGG': 'R', 'CGU': 'R', 'CUA': 'L', 'CUC': 'L',&#13;
        'CUG': 'L', 'CUU': 'L', 'GAA': 'E', 'GAC': 'D', 'GAG': 'E',&#13;
        'GAU': 'D', 'GCA': 'A', 'GCC': 'A', 'GCG': 'A', 'GCU': 'A',&#13;
        'GGA': 'G', 'GGC': 'G', 'GGG': 'G', 'GGU': 'G', 'GUA': 'V',&#13;
        'GUC': 'V', 'GUG': 'V', 'GUU': 'V', 'UAC': 'Y', 'UAU': 'Y',&#13;
        'UCA': 'S', 'UCC': 'S', 'UCG': 'S', 'UCU': 'S', 'UGC': 'C',&#13;
        'UGG': 'W', 'UGU': 'C', 'UUA': 'L', 'UUC': 'F', 'UUG': 'L',&#13;
        'UUU': 'F', 'UAA': '*', 'UAG': '*', 'UGA': '*',&#13;
    }&#13;
&#13;
    aa = map(lambda codon: codon_to_aa.get(codon, '-'), codons(rna))&#13;
    return ''.join(takewhile(partial(operator.ne, '*'), aa))</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 5: Using Bio.Seq.translate()" data-type="sect2"><div class="sect2" id="idm45963633582760">&#13;
<h2>Solution 5: Using Bio.Seq.translate()</h2>&#13;
&#13;
<p>As promised, the last solution uses Biopython.<a data-primary="translating mRNA into protein" data-secondary="solution 5 Bio.Seq" data-type="indexterm" id="idm45963633581416"/><a data-primary="Biopython library" data-secondary="Bio.Seq" data-tertiary="translating mRNA into protein" data-type="indexterm" id="idm45963633580456"/>&#13;
In <a data-type="xref" href="ch03.html#ch03">Chapter 3</a>, I used the <code>Bio.Seq.reverse_complement()</code> function, and here I can use <code>Bio.Seq.translate()</code>.&#13;
First, import the <code>Bio.Seq</code> class:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from Bio import Seq</pre>&#13;
&#13;
<p>Then call the <code>translate()</code> function.&#13;
Note that the stop codon is represented by <code>*</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; rna = 'AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA'&#13;
&gt;&gt;&gt; Seq.translate(rna)&#13;
'MAMAPRTEINSTRING*'</pre>&#13;
&#13;
<p>By default, this function does not stop translation at the stop codon:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; Seq.translate('AUGCCGUAAUCU')&#13;
'MP*S'</pre>&#13;
&#13;
<p>If you read <code>help(Seq.translate)</code> in the REPL, you’ll find the <code>to_stop</code> option to change this to the version expected by the Rosalind challenge:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; Seq.translate('AUGCCGUAAUCU', to_stop=True)&#13;
'MP'</pre>&#13;
&#13;
<p>Here is how I put it all together:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    print(Seq.translate(args.rna, to_stop=True))</pre>&#13;
&#13;
<p>This is the solution I would recommend because it relies on the widely used <span class="keep-together">Biopython module.</span>&#13;
While it was fun and enlightening to explore how to manually code a solution, it’s far better practice to use code that’s already been written and tested by a dedicated team of developers.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Benchmarking" data-type="sect1"><div class="sect1" id="idm45963633567368">&#13;
<h1>Benchmarking</h1>&#13;
&#13;
<p>Which is the fastest solution?<a data-primary="translating mRNA into protein" data-secondary="solutions benchmarked" data-type="indexterm" id="idm45963633566056"/><a data-primary="benchmarking the solutions" data-secondary="translating mRNA into protein" data-type="indexterm" id="idm45963633565096"/>&#13;
I can use the <code>hyperfine</code> benchmarking program I introduced in <a data-type="xref" href="ch04.html#ch04">Chapter 4</a>&#13;
to compare the runtimes of the programs.&#13;
Because this is such a short program, I decided to run each program at least 1,000 times, as documented in the <code>bench.sh</code> program in the repository.</p>&#13;
&#13;
<p>Although the second solution runs the fastest, perhaps as much at 1.5 times faster than the Biopython version, I’d still recommend using the latter because this is a thoroughly documented and tested module that is widely used in the community.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Going Further" data-type="sect1"><div class="sect1" id="idm45963633561064">&#13;
<h1>Going Further</h1>&#13;
&#13;
<p>Add a <code>--frame-shift</code> argument that defaults to <code>0</code> and allows values <code>0-2</code> (inclusive). Use the frameshift to start reading the RNA from an alternate position.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review" data-type="sect1"><div class="sect1" id="idm45963633558024">&#13;
<h1>Review</h1>&#13;
&#13;
<p>The focus of this chapter was really on how to write, test, and compose functions to solve the problem at hand.&#13;
I wrote functions to find codons in a sequence and translate RNA.&#13;
Then I showed how to use higher-order functions to compose other functions, and finally, I used an off-the-shelf function from Biopython.</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>K-mers are all the <em>k</em>-length subsequences of a sequence.</p>&#13;
</li>&#13;
<li>&#13;
<p>Codons are 3-mers that do not overlap in a particular frame.</p>&#13;
</li>&#13;
<li>&#13;
<p>Dictionaries are useful as lookup tables, such as for translating a codon to an amino acid.</p>&#13;
</li>&#13;
<li>&#13;
<p>A <code>for</code> loop, a list comprehension, and <code>map()</code> are all methods for transforming one sequence into another.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>takewhile()</code> function is similar to the <code>filter()</code> function in accepting values from a sequence based on a predicate or test of the values.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>partial()</code> function allows one to partially apply the arguments to a <span class="keep-together">function.</span></p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>Bio.Seq.translate()</code> function will translate an RNA sequence into a protein sequence.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>