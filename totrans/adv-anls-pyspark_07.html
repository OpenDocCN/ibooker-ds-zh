<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 7. Geospatial and Temporal Data Analysis &#10;on Taxi Trip Data" data-type="chapter" epub:type="chapter"><div class="chapter" id="geospatial_and_temporal_data_analysis_on_taxi_trip_data">
<h1><span class="label">Chapter 7. </span>Geospatial and Temporal Data Analysis 
<span class="keep-together">on Taxi Trip Data</span></h1>
<p>Geospatial data refers to data that<a data-primary="geospatial data analysis" data-secondary="about geospatial data" data-type="indexterm" id="idm46507970943664"/><a data-primary="taxi trip data analysis" data-secondary="about geospatial data" data-type="indexterm" id="idm46507970925376"/><a data-primary="data analysis" data-secondary="geospatial" data-see="geospatial data analysis" data-type="indexterm" id="idm46507970924432"/> has location information embedded in it in some form. Such data is being generated currently at a massive scale by billions of sources, such as mobile phones and sensors, every day. Data about movement of humans and machines, and from remote sensing, is significant for our economy and general well-being. Geospatial analytics can provide us with the tools and methods we need to make sense of all that data and put it to use in solving problems we face.</p>
<p>The PySpark and PyData ecosystems<a data-primary="PySpark API" data-secondary="geospatial data analysis" data-seealso="geospatial data analysis" data-type="indexterm" id="idm46507970922736"/><a data-primary="PyData ecosystem" data-secondary="geospatial data analysis" data-seealso="geospatial data analysis" data-type="indexterm" id="idm46507970921456"/> have evolved considerably over the last few years when it comes to geospatial analysis. They are being used across industries for handling location-rich data and, in turn, impacting our daily lives. One daily activity where geospatial data manifests itself in a visible way is local transport. The phenomenon of digital cab hailing services becoming popular over the last few years has led to us being more aware of geospatial technology. In this chapter, we’ll use our PySpark and data analysis skills in this domain as we work with a dataset containing information about trips taken by cabs in New York City.</p>
<p>One statistic that is important to understanding<a data-primary="taxi trip data analysis" data-secondary="about taxi utilization" data-type="indexterm" id="idm46507970919696"/><a data-primary="geospatial data analysis" data-secondary="about taxi utilization" data-type="indexterm" id="idm46507970918720"/><a data-primary="utilization metric of taxis" data-type="indexterm" id="idm46507970917760"/> the economics of taxis is <em>utilization</em>: the fraction of time that a cab is on the road and is occupied by one or more passengers. One factor that impacts utilization is the passenger’s destination: a cab that drops off passengers near Union Square at midday is much more likely to find its next fare in just a minute or two, whereas a cab that drops someone off at 2 A.M. on Staten Island may have to drive all the way back to Manhattan before it finds its next fare. <a data-primary="taxi trip data analysis" data-secondary="about problem to be solved" data-type="indexterm" id="idm46507970916560"/><a data-primary="geospatial data analysis" data-secondary="about problem to be solved" data-type="indexterm" id="idm46507970915520"/>We’d like to quantify these effects and find out the average time it takes for a cab to find its next fare as a
function of the borough in which it dropped its passengers off—Manhattan, Brooklyn, Queens, the Bronx, Staten Island, or none of the above (e.g., if it dropped the passenger off somewhere outside of the city, like Newark Liberty International Airport).</p>
<p>We’ll start by setting up our dataset, and then we’ll dive into geospatial analysis. We will learn about the GeoJSON format and use tools from the PyData ecosystem in combination with PySpark. We’ll use GeoPandas for working with <em>geospatial information</em>, like points of longitude and latitude and spatial boundaries. To wrap things up, we will work with temporal features of our data, such as date and time, by performing a type of analysis called sessionization. This will help us understand utilization of New York City cabs. PySpark’s DataFrame API provides out-of-the-box data types and methods to handle temporal data.</p>
<p>Let’s get going by downloading our dataset and exploring it using PySpark.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46507970913072">
<h5>Origin Story of the New York City Taxi Trip Dataset</h5>
<p>Residents of New York City have all kinds<a data-primary="taxi trip data analysis" data-secondary="dataset" data-tertiary="about" data-type="indexterm" id="idm46507970911776"/><a data-primary="geospatial data analysis" data-secondary="New York City dataset" data-tertiary="about" data-type="indexterm" id="idm46507970910528"/><a data-primary="datasets" data-secondary="New York City taxi trips (2013)" data-type="indexterm" id="idm46507970909296"/><a data-primary="New York City taxi trips" data-see="taxi trip data analysis" data-type="indexterm" id="idm46507970908336"/> of tips based on their anecdotal experiences about the best times and places to catch a cab, especially during rush hour and when it’s raining. But there is one time of day when everyone will recommend that you simply take the subway instead: during the shift change that happens between 4 and 5 P.M. every day. During this time, yellow taxis have to return to their dispatch centers (often in Queens) so that one driver can quit for the day and the next one can start, and drivers who are late to return have to pay fines.</p>
<p>In March of 2014, the New York City Taxi and Limousine Commission shared an infographic on its Twitter account, <a href="https://oreil.ly/MAA7t">@nyctaxi</a>, that showed the number of taxis on the road and the fraction of those taxis that was occupied at any given time. Sure enough, there was a noticeable dip of taxis on the road from 4 to 6 P.M., and two-thirds of the taxis that were driving were occupied.</p>
<p>This tweet caught the eye of self-described<a data-primary="Whong, Chris" data-type="indexterm" id="idm46507970905632"/> urbanist, mapmaker, and data junkie Chris Whong, who sent a tweet to the @nyctaxi  account to find out if the data it used in its infographic was publicly available. Chris gained access to all of the data on taxi rides from January 1 through December 31, 2013. Even better, he posted all of the fare data online, where it has been used as the basis for a number of beautiful visualizations of transportation in New York City. This is the dataset that we will leverage as well in this chapter.</p>
</div></aside>
<section data-pdf-bookmark="Preparing the Data" data-type="sect1"><div class="sect1" id="idm46507970904544">
<h1>Preparing the Data</h1>
<p>For this analysis, we’re only going to consider<a data-primary="geospatial data analysis" data-secondary="New York City dataset" data-tertiary="preparing the data" data-type="indexterm" id="ch07-prep"/><a data-primary="taxi trip data analysis" data-secondary="dataset" data-tertiary="preparing the data" data-type="indexterm" id="ch07-prep2"/><a data-primary="taxi trip data analysis" data-secondary="dataset" data-tertiary="download link" data-type="indexterm" id="idm46507970900000"/><a data-primary="geospatial data analysis" data-secondary="New York City dataset" data-tertiary="download link" data-type="indexterm" id="idm46507970898784"/><a data-primary="online resources" data-secondary="New York City taxi fares (2013)" data-type="indexterm" id="idm46507970897552"/> the fare data from January 2013, which will be about 2.5 GB of data after we uncompress it. You can access the <a href="https://oreil.ly/7m7Ki">data for each month of 2013</a>, and if you have a sufficiently large PySpark cluster at your disposal, you can re-create the following analysis against all of the data for the year. For now, let’s create a working directory on our client machine and take a look at the structure of the fare data:</p>
<pre data-code-language="shell" data-type="programlisting">$ mkdir taxidata
$ <code class="nb">cd</code> taxidata
$ curl -O https://storage.googleapis.com/aas-data-sets/trip_data_1.csv.zip
$ unzip trip_data_1.csv.zip
$ head -n <code class="m">5</code> trip_data_1.csv

...

medallion,hack_license,vendor_id,rate_code,store_and_fwd_flag,...
89D227B655E5C82AECF13C3F540D4CF4,BA96DE419E711691B9445D6A6307C170,CMT,1,...
0BD7C8F5BA12B88E0B67BED28BEA73D8,9FD8F69F0804BDB5549F40E9DA1BE472,CMT,1,...
0BD7C8F5BA12B88E0B67BED28BEA73D8,9FD8F69F0804BDB5549F40E9DA1BE472,CMT,1,...
DFD2202EE08F7A8DC9A57B02ACB81FE2,51EE87E3205C985EF8431D850C786310,CMT,1,...</pre>
<p>Each row of the file after the header represents a single taxi ride in CSV format. For each ride, we have some attributes of the cab (a hashed version of the medallion number) as well as the driver (a hashed version of the <em>hack license</em>, which is what a license to drive a taxi is called), some temporal information about when the trip started and ended, and the longitude/latitude coordinates for where the passengers were picked up and dropped off.</p>
<p>Let’s create a <em>taxidata</em> directory and<a data-primary="persistent storage" data-secondary="taxi fare data" data-type="indexterm" id="idm46507970893120"/> copy the trip data into the storage:</p>
<pre data-code-language="shell" data-type="programlisting">$ mkdir taxidata
$ mv trip_data_1.csv taxidata/</pre>
<p>We have used a local filesystem here, but this may not be the case for you. It’s more likely nowadays to use a cloud native filesystem such as AWS S3 or GCS. In such a scenario, you will upload the data to S3 or GCS, respectively.</p>
<p>Now start the PySpark shell:</p>
<pre data-code-language="shell" data-type="programlisting">$ pyspark</pre>
<p>Once the PySpark shell has loaded, we can create a dataset from the taxi data and examine the first few lines, just as we have in other chapters:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">taxi_raw</code> <code class="o">=</code> <code class="n">pyspark</code><code class="o">.</code><code class="n">read</code><code class="o">.</code><code class="n">option</code><code class="p">(</code><code class="s2">"header"</code><code class="p">,</code> <code class="s2">"true"</code><code class="p">)</code><code class="o">.</code><code class="n">csv</code><code class="p">(</code><code class="s2">"taxidata"</code><code class="p">)</code>
<code class="n">taxi_raw</code><code class="o">.</code><code class="n">show</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="n">vertical</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code>

<code class="o">...</code>

<code class="n">RECORD</code> <code class="mi">0</code><code class="o">----------------------------------</code>
 <code class="n">medallion</code>          <code class="o">|</code> <code class="mi">89</code><code class="n">D227B655E5C82AE</code><code class="o">...</code>
 <code class="n">hack_license</code>       <code class="o">|</code> <code class="n">BA96DE419E711691B</code><code class="o">...</code>
 <code class="n">vendor_id</code>          <code class="o">|</code> <code class="n">CMT</code>
 <code class="n">rate_code</code>          <code class="o">|</code> <code class="mi">1</code>
 <code class="n">store_and_fwd_flag</code> <code class="o">|</code> <code class="n">N</code>
 <code class="n">pickup_datetime</code>    <code class="o">|</code> <code class="mi">2013</code><code class="o">-</code><code class="mi">01</code><code class="o">-</code><code class="mi">01</code> <code class="mi">15</code><code class="p">:</code><code class="mi">11</code><code class="p">:</code><code class="mi">48</code>
 <code class="n">dropoff_datetime</code>   <code class="o">|</code> <code class="mi">2013</code><code class="o">-</code><code class="mi">01</code><code class="o">-</code><code class="mi">01</code> <code class="mi">15</code><code class="p">:</code><code class="mi">18</code><code class="p">:</code><code class="mi">10</code>
 <code class="n">passenger_count</code>    <code class="o">|</code> <code class="mi">4</code>
 <code class="n">trip_time_in_secs</code>  <code class="o">|</code> <code class="mi">382</code>
 <code class="n">trip_distance</code>      <code class="o">|</code> <code class="mf">1.0</code>
 <code class="n">pickup_longitude</code>   <code class="o">|</code> <code class="o">-</code><code class="mf">73.978165</code>
 <code class="n">pickup_latitude</code>    <code class="o">|</code> <code class="mf">40.757977</code>
 <code class="n">dropoff_longitude</code>  <code class="o">|</code> <code class="o">-</code><code class="mf">73.989838</code>
 <code class="n">dropoff_latitude</code>   <code class="o">|</code> <code class="mf">40.751171</code>
<code class="n">only</code> <code class="n">showing</code> <code class="n">top</code> <code class="mi">1</code> <code class="n">row</code>

<code class="o">...</code></pre>
<p>This looks like a well-formatted dataset at first glance.<a data-primary="dataframes" data-secondary="schemas" data-tertiary="New York City taxi fares" data-type="indexterm" id="idm46507970701264"/><a data-primary="schemas of dataframes" data-secondary="New York City taxi fares" data-type="indexterm" id="idm46507970761024"/> Let’s have a look at the DataFrame’s schema:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">taxi_raw</code><code class="o">.</code><code class="n">printSchema</code><code class="p">()</code>
<code class="o">...</code>
<code class="n">root</code>
 <code class="o">|--</code> <code class="n">medallion</code><code class="p">:</code> <code class="n">string</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">hack_license</code><code class="p">:</code> <code class="n">string</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">vendor_id</code><code class="p">:</code> <code class="n">string</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">rate_code</code><code class="p">:</code> <code class="n">integer</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">store_and_fwd_flag</code><code class="p">:</code> <code class="n">string</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">pickup_datetime</code><code class="p">:</code> <code class="n">string</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">dropoff_datetime</code><code class="p">:</code> <code class="n">string</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">passenger_count</code><code class="p">:</code> <code class="n">integer</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">trip_time_in_secs</code><code class="p">:</code> <code class="n">integer</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">trip_distance</code><code class="p">:</code> <code class="n">double</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">pickup_longitude</code><code class="p">:</code> <code class="n">double</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">pickup_latitude</code><code class="p">:</code> <code class="n">double</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">dropoff_longitude</code><code class="p">:</code> <code class="n">double</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">dropoff_latitude</code><code class="p">:</code> <code class="n">double</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">...</code></pre>
<p>We are representing the <code>pickup_datetime</code> and <code>dropoff_datetime</code> fields as <code>Strings</code> and storing the individual <code>(x,y)</code> coordinates of the pickup and drop-off locations in their own fields as <code>Doubles</code>. We want the datetime fields as timestamps since that will allow us to manipulate and analyze them conveniently.<a data-startref="ch07-prep" data-type="indexterm" id="idm46507970516624"/><a data-startref="ch07-prep2" data-type="indexterm" id="idm46507970516032"/></p>
<section data-pdf-bookmark="Converting Datetime Strings to Timestamps" data-type="sect2"><div class="sect2" id="idm46507970515360">
<h2>Converting Datetime Strings to Timestamps</h2>
<p>As mentioned previously, PySpark provides<a data-primary="taxi trip data analysis" data-secondary="dataset" data-tertiary="datetime strings to timestamps" data-type="indexterm" id="ch07-time"/><a data-primary="geospatial data analysis" data-secondary="New York City dataset" data-tertiary="datetime strings to timestamps" data-type="indexterm" id="ch07-time2"/><a data-primary="temporal data" data-secondary="datetime strings to timestamps" data-type="indexterm" id="ch07-time3"/><a data-primary="to_timestamp function" data-type="indexterm" id="ch07-time4"/><a data-primary="string data" data-secondary="datetime strings to timestamps" data-type="indexterm" id="ch07-time5"/> out-of-the-box methods for handling temporal data.</p>
<p>Specifically, we will use the <code>to_timestamp</code> function to parse the datetime strings and convert them into timestamps:</p>
<pre data-code-language="python" data-type="programlisting"><code class="kn">from</code> <code class="nn">pyspark.sql</code> <code class="kn">import</code> <code class="n">functions</code> <code class="k">as</code> <code class="n">fun</code>

<code class="n">taxi_raw</code> <code class="o">=</code> <code class="n">taxi_raw</code><code class="o">.</code><code class="n">withColumn</code><code class="p">(</code><code class="s1">'pickup_datetime'</code><code class="p">,</code>
                                <code class="n">fun</code><code class="o">.</code><code class="n">to_timestamp</code><code class="p">(</code><code class="n">fun</code><code class="o">.</code><code class="n">col</code><code class="p">(</code><code class="s1">'pickup_datetime'</code><code class="p">),</code>
                                                <code class="s2">"yyyy-MM-dd HH:mm:ss"</code><code class="p">))</code>
<code class="n">taxi_raw</code> <code class="o">=</code> <code class="n">taxi_raw</code><code class="o">.</code><code class="n">withColumn</code><code class="p">(</code><code class="s1">'dropoff_datetime'</code><code class="p">,</code>
                                <code class="n">fun</code><code class="o">.</code><code class="n">to_timestamp</code><code class="p">(</code><code class="n">fun</code><code class="o">.</code><code class="n">col</code><code class="p">(</code><code class="s1">'dropoff_datetime'</code><code class="p">),</code>
                                                <code class="s2">"yyyy-MM-dd HH:mm:ss"</code><code class="p">))</code></pre>
<p>Let’s have a look at the schema again:<a data-primary="schemas of dataframes" data-secondary="New York City taxi fares" data-type="indexterm" id="idm46507965505024"/><a data-primary="dataframes" data-secondary="schemas" data-tertiary="New York City taxi fares" data-type="indexterm" id="idm46507965483744"/></p>
<pre data-code-language="python" data-type="programlisting"><code class="n">taxi_raw</code><code class="o">.</code><code class="n">printSchema</code><code class="p">()</code>
<code class="o">...</code>

<code class="n">root</code>
 <code class="o">|--</code> <code class="n">medallion</code><code class="p">:</code> <code class="n">string</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">hack_license</code><code class="p">:</code> <code class="n">string</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">vendor_id</code><code class="p">:</code> <code class="n">string</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">rate_code</code><code class="p">:</code> <code class="n">integer</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">store_and_fwd_flag</code><code class="p">:</code> <code class="n">string</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">pickup_datetime</code><code class="p">:</code> <code class="n">timestamp</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">dropoff_datetime</code><code class="p">:</code> <code class="n">timestamp</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">passenger_count</code><code class="p">:</code> <code class="n">integer</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">trip_time_in_secs</code><code class="p">:</code> <code class="n">integer</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">trip_distance</code><code class="p">:</code> <code class="n">double</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">pickup_longitude</code><code class="p">:</code> <code class="n">double</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">pickup_latitude</code><code class="p">:</code> <code class="n">double</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">dropoff_longitude</code><code class="p">:</code> <code class="n">double</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>
 <code class="o">|--</code> <code class="n">dropoff_latitude</code><code class="p">:</code> <code class="n">double</code> <code class="p">(</code><code class="n">nullable</code> <code class="o">=</code> <code class="n">true</code><code class="p">)</code>

 <code class="o">...</code></pre>
<p>The <code>pickup_datetime</code> and <code>dropoff_datetime</code> fields are timestamps now. Well done!</p>
<p>We’d mentioned that this dataset contains trips from January 2013. Don’t just take our word for this, though. We can confirm this by sorting the <code>pickup_datetime</code> field to get the latest datetime in the data. For this, we use DataFrame’s <code>sort</code> method combined with PySpark column’s <code>desc</code> method:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">taxi_raw</code><code class="o">.</code><code class="n">sort</code><code class="p">(</code><code class="n">fun</code><code class="o">.</code><code class="n">col</code><code class="p">(</code><code class="s2">"pickup_datetime"</code><code class="p">)</code><code class="o">.</code><code class="n">desc</code><code class="p">())</code><code class="o">.</code><code class="n">show</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="n">vertical</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code>
<code class="o">...</code>

<code class="o">-</code><code class="n">RECORD</code> <code class="mi">0</code><code class="o">----------------------------------</code>
 <code class="n">medallion</code>          <code class="o">|</code> <code class="n">EA00A64CBDB68C77D</code><code class="o">...</code>
 <code class="n">hack_license</code>       <code class="o">|</code> <code class="mi">2045</code><code class="n">C77002FA0F2E0</code><code class="o">...</code>
 <code class="n">vendor_id</code>          <code class="o">|</code> <code class="n">CMT</code>
 <code class="n">rate_code</code>          <code class="o">|</code> <code class="mi">1</code>
 <code class="n">store_and_fwd_flag</code> <code class="o">|</code> <code class="n">N</code>
 <code class="n">pickup_datetime</code>    <code class="o">|</code> <code class="mi">2013</code><code class="o">-</code><code class="mi">01</code><code class="o">-</code><code class="mi">31</code> <code class="mi">23</code><code class="p">:</code><code class="mi">59</code><code class="p">:</code><code class="mi">59</code>
 <code class="n">dropoff_datetime</code>   <code class="o">|</code> <code class="mi">2013</code><code class="o">-</code><code class="mi">02</code><code class="o">-</code><code class="mi">01</code> <code class="mi">00</code><code class="p">:</code><code class="mi">08</code><code class="p">:</code><code class="mi">39</code>
 <code class="n">passenger_count</code>    <code class="o">|</code> <code class="mi">1</code>
 <code class="n">trip_time_in_secs</code>  <code class="o">|</code> <code class="mi">520</code>
 <code class="n">trip_distance</code>      <code class="o">|</code> <code class="mf">1.5</code>
 <code class="n">pickup_longitude</code>   <code class="o">|</code> <code class="o">-</code><code class="mf">73.970528</code>
 <code class="n">pickup_latitude</code>    <code class="o">|</code> <code class="mf">40.75502</code>
 <code class="n">dropoff_longitude</code>  <code class="o">|</code> <code class="o">-</code><code class="mf">73.981201</code>
 <code class="n">dropoff_latitude</code>   <code class="o">|</code> <code class="mf">40.769104</code>
<code class="o">-</code><code class="n">RECORD</code> <code class="mi">1</code><code class="o">----------------------------------</code>
 <code class="n">medallion</code>          <code class="o">|</code> <code class="n">E3F00BB3F4E710383</code><code class="o">...</code>
 <code class="n">hack_license</code>       <code class="o">|</code> <code class="mi">10</code><code class="n">A2B96DE39865918</code><code class="o">...</code>
 <code class="n">vendor_id</code>          <code class="o">|</code> <code class="n">CMT</code>
 <code class="n">rate_code</code>          <code class="o">|</code> <code class="mi">1</code>
 <code class="n">store_and_fwd_flag</code> <code class="o">|</code> <code class="n">N</code>
 <code class="n">pickup_datetime</code>    <code class="o">|</code> <code class="mi">2013</code><code class="o">-</code><code class="mi">01</code><code class="o">-</code><code class="mi">31</code> <code class="mi">23</code><code class="p">:</code><code class="mi">59</code><code class="p">:</code><code class="mi">59</code>
 <code class="n">dropoff_datetime</code>   <code class="o">|</code> <code class="mi">2013</code><code class="o">-</code><code class="mi">02</code><code class="o">-</code><code class="mi">01</code> <code class="mi">00</code><code class="p">:</code><code class="mi">05</code><code class="p">:</code><code class="mi">16</code>
 <code class="n">passenger_count</code>    <code class="o">|</code> <code class="mi">1</code>
 <code class="n">trip_time_in_secs</code>  <code class="o">|</code> <code class="mi">317</code>
 <code class="n">trip_distance</code>      <code class="o">|</code> <code class="mf">1.0</code>
 <code class="n">pickup_longitude</code>   <code class="o">|</code> <code class="o">-</code><code class="mf">73.990685</code>
 <code class="n">pickup_latitude</code>    <code class="o">|</code> <code class="mf">40.719158</code>
 <code class="n">dropoff_longitude</code>  <code class="o">|</code> <code class="o">-</code><code class="mf">74.003288</code>
 <code class="n">dropoff_latitude</code>   <code class="o">|</code> <code class="mf">40.71521</code>
<code class="o">-</code><code class="n">RECORD</code> <code class="mi">2</code><code class="o">----------------------------------</code>
 <code class="n">medallion</code>          <code class="o">|</code> <code class="mi">83</code><code class="n">D8E776A05EEF731</code><code class="o">...</code>
 <code class="n">hack_license</code>       <code class="o">|</code> <code class="n">E6D27C8729EF55D20</code><code class="o">...</code>
 <code class="n">vendor_id</code>          <code class="o">|</code> <code class="n">CMT</code>
 <code class="n">rate_code</code>          <code class="o">|</code> <code class="mi">1</code>
 <code class="n">store_and_fwd_flag</code> <code class="o">|</code> <code class="n">N</code>
 <code class="n">pickup_datetime</code>    <code class="o">|</code> <code class="mi">2013</code><code class="o">-</code><code class="mi">01</code><code class="o">-</code><code class="mi">31</code> <code class="mi">23</code><code class="p">:</code><code class="mi">59</code><code class="p">:</code><code class="mi">58</code>
 <code class="n">dropoff_datetime</code>   <code class="o">|</code> <code class="mi">2013</code><code class="o">-</code><code class="mi">02</code><code class="o">-</code><code class="mi">01</code> <code class="mi">00</code><code class="p">:</code><code class="mi">04</code><code class="p">:</code><code class="mi">19</code>
 <code class="n">passenger_count</code>    <code class="o">|</code> <code class="mi">1</code>
 <code class="n">trip_time_in_secs</code>  <code class="o">|</code> <code class="mi">260</code>
 <code class="n">trip_distance</code>      <code class="o">|</code> <code class="mf">0.8</code>
 <code class="n">pickup_longitude</code>   <code class="o">|</code> <code class="o">-</code><code class="mf">73.982452</code>
 <code class="n">pickup_latitude</code>    <code class="o">|</code> <code class="mf">40.77277</code>
 <code class="n">dropoff_longitude</code>  <code class="o">|</code> <code class="o">-</code><code class="mf">73.989227</code>
 <code class="n">dropoff_latitude</code>   <code class="o">|</code> <code class="mf">40.766754</code>
<code class="n">only</code> <code class="n">showing</code> <code class="n">top</code> <code class="mi">3</code> <code class="n">rows</code>
<code class="o">...</code></pre>
<p>With our data types in place, let’s check if there are any inconsistencies in our data.<a data-startref="ch07-time" data-type="indexterm" id="idm46507965270320"/><a data-startref="ch07-time2" data-type="indexterm" id="idm46507965269712"/><a data-startref="ch07-time3" data-type="indexterm" id="idm46507965269104"/><a data-startref="ch07-time4" data-type="indexterm" id="idm46507965268432"/><a data-startref="ch07-time5" data-type="indexterm" id="idm46507965267760"/></p>
</div></section>
<section data-pdf-bookmark="Handling Invalid Records" data-type="sect2"><div class="sect2" id="idm46507970514768">
<h2>Handling Invalid Records</h2>
<p>Anyone who has been working with large-scale,<a data-primary="taxi trip data analysis" data-secondary="dataset" data-tertiary="handling invalid records" data-type="indexterm" id="ch07-inval"/><a data-primary="geospatial data analysis" data-secondary="New York City dataset" data-tertiary="handling invalid records" data-type="indexterm" id="ch07-inval2"/><a data-primary="invalid record handling" data-type="indexterm" id="ch07-inval3"/><a data-primary="missing data values" data-secondary="handling invalid records" data-type="indexterm" id="ch07-inval4"/> real-world datasets knows that they invariably contain at least a few records
that do not conform to the expectations of the person who wrote the code to handle them. Many PySpark pipelines have failed because of invalid records that caused the parsing logic to throw an exception. When performing interactive analysis, we can get a sense of potential anomalies in the data by focusing on key variables.</p>
<p>In our case, variables containing geospatial and temporal information are worth looking at for inconsistencies. Presence of null values in these columns will definitely throw off our analysis.</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">geospatial_temporal_colnames</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"pickup_longitude"</code><code class="p">,</code> <code class="s2">"pickup_latitude"</code><code class="p">,</code> \
                                <code class="s2">"dropoff_longitude"</code><code class="p">,</code> <code class="s2">"dropoff_latitude"</code><code class="p">,</code> \
                                <code class="s2">"pickup_datetime"</code><code class="p">,</code> <code class="s2">"dropoff_datetime"</code><code class="p">]</code>
<code class="n">taxi_raw</code><code class="o">.</code><code class="n">select</code><code class="p">([</code><code class="n">fun</code><code class="o">.</code><code class="n">count</code><code class="p">(</code><code class="n">fun</code><code class="o">.</code><code class="n">when</code><code class="p">(</code><code class="n">fun</code><code class="o">.</code><code class="n">isnull</code><code class="p">(</code><code class="n">c</code><code class="p">),</code> <code class="n">c</code><code class="p">))</code><code class="o">.</code>\
                            <code class="n">alias</code><code class="p">(</code><code class="n">c</code><code class="p">)</code> <code class="k">for</code> <code class="n">c</code> <code class="ow">in</code> <code class="n">geospatial_temporal_colnames</code><code class="p">])</code><code class="o">.</code>\
                <code class="n">show</code><code class="p">()</code>
<code class="o">...</code>

<code class="o">+----------------+---------------+-----------------</code>
<code class="o">|</code><code class="n">pickup_longitude</code><code class="o">|</code><code class="n">pickup_latitude</code><code class="o">|</code><code class="n">dropoff_longitude</code>
<code class="o">+----------------+---------------+-----------------</code>
<code class="o">|</code>               <code class="mi">0</code><code class="o">|</code>              <code class="mi">0</code><code class="o">|</code>               <code class="mi">86</code>
<code class="o">+----------------+---------------+-----------------</code>
<code class="o">+----------------+---------------+----------------+</code>
<code class="o">|</code><code class="n">dropoff_latitude</code><code class="o">|</code><code class="n">pickup_datetime</code><code class="o">|</code><code class="n">dropoff_datetime</code><code class="o">|</code>
<code class="o">+----------------+---------------+----------------+</code>
<code class="o">|</code>              <code class="mi">86</code><code class="o">|</code>              <code class="mi">0</code><code class="o">|</code>               <code class="mi">0</code><code class="o">|</code>
<code class="o">+----------------+---------------+----------------+</code></pre>
<p>Let’s remove the null values from our data:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">taxi_raw</code> <code class="o">=</code> <code class="n">taxi_raw</code><code class="o">.</code><code class="n">na</code><code class="o">.</code><code class="n">drop</code><code class="p">(</code><code class="n">subset</code><code class="o">=</code><code class="n">geospatial_temporal_colnames</code><code class="p">)</code></pre>
<p>Another commonsense check that we can do is for latitude and longitude records where the values are zero. We know that for the region we’re concerned with, those would be invalid values:</p>
<pre data-code-language="python" data-type="programlisting"><code class="nb">print</code><code class="p">(</code><code class="s2">"</code><code class="s2">Count of zero dropoff, pickup latitude and longitude records</code><code class="s2">"</code><code class="p">)</code><code>
</code><code class="n">taxi_raw</code><code class="o">.</code><code class="n">groupBy</code><code class="p">(</code><code class="p">(</code><code class="n">fun</code><code class="o">.</code><code class="n">col</code><code class="p">(</code><code class="s2">"</code><code class="s2">dropoff_longitude</code><code class="s2">"</code><code class="p">)</code><code> </code><code class="o">==</code><code> </code><code class="mi">0</code><code class="p">)</code><code> </code><code class="o">|</code><code>
</code><code>  </code><code class="p">(</code><code class="n">fun</code><code class="o">.</code><code class="n">col</code><code class="p">(</code><code class="s2">"</code><code class="s2">dropoff_latitude</code><code class="s2">"</code><code class="p">)</code><code> </code><code class="o">==</code><code> </code><code class="mi">0</code><code class="p">)</code><code> </code><code class="o">|</code><code>
</code><code>  </code><code class="p">(</code><code class="n">fun</code><code class="o">.</code><code class="n">col</code><code class="p">(</code><code class="s2">"</code><code class="s2">pickup_longitude</code><code class="s2">"</code><code class="p">)</code><code> </code><code class="o">==</code><code> </code><code class="mi">0</code><code class="p">)</code><code> </code><code class="o">|</code><code>
</code><code>  </code><code class="p">(</code><code class="n">fun</code><code class="o">.</code><code class="n">col</code><code class="p">(</code><code class="s2">"</code><code class="s2">pickup_latitude</code><code class="s2">"</code><code class="p">)</code><code> </code><code class="o">==</code><code> </code><code class="mi">0</code><code class="p">)</code><code class="p">)</code><code class="o">.</code><code>\</code><code> </code><a class="co" href="#callout_geospatial_and_temporal_data_analysis___span_class__keep_together__on_taxi_trip_data__span__CO1-1" id="co_geospatial_and_temporal_data_analysis___span_class__keep_together__on_taxi_trip_data__span__CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code>    </code><code class="n">count</code><code class="p">(</code><code class="p">)</code><code class="o">.</code><code class="n">show</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code>
</code><code class="n">Count</code><code> </code><code class="n">of</code><code> </code><code class="n">zero</code><code> </code><code class="n">dropoff</code><code class="p">,</code><code> </code><code class="n">pickoff</code><code> </code><code class="n">latitude</code><code> </code><code class="ow">and</code><code> </code><code class="n">longitude</code><code> </code><code class="n">records</code><code>
</code><code class="o">+</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">+</code><code>
</code><code class="o">|</code><code> </code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>  </code><code class="o">|</code><code>   </code><code class="n">count</code><code class="o">|</code><code>
</code><code class="o">+</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">+</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">+</code><code>
</code><code class="o">|</code><code> </code><code class="n">true</code><code> </code><code class="o">|</code><code>  </code><code class="mi">285909</code><code class="o">|</code><code>
</code><code class="o">|</code><code> </code><code class="n">false</code><code class="o">|</code><code class="mi">14490620</code><code class="o">|</code><code>
</code><code class="o">+</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">-</code><code class="o">+</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_geospatial_and_temporal_data_analysis___span_class__keep_together__on_taxi_trip_data__span__CO1-1" id="callout_geospatial_and_temporal_data_analysis___span_class__keep_together__on_taxi_trip_data__span__CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Multiple <code>OR</code> conditions will be true if either of them evaluates to <code>True</code> for any record.</p></dd>
</dl>
<p>We have quite a few of these. If it looks as if a taxi took a passenger to the South Pole, we can be reasonably confident that the record is invalid and should be excluded from our analysis. We will not remove them but get back to them toward the end of the next section to see how they can affect our analysis.</p>
<p>In production settings, we handle these exceptions one at a time by checking the logs for the individual tasks, figuring out which line of code threw the exception, and then figuring out how to tweak the code to ignore or correct the invalid records. This is a tedious process, and it often feels like we’re playing whack-a-mole: just as we get one exception fixed, we discover another one on a record that came later within the partition.</p>
<p>One strategy that experienced data scientists deploy<a data-primary="try-except blocks for invalid records" data-type="indexterm" id="idm46507969027008"/> when working with a new dataset is to add a <code>try-except</code> block to their parsing code so that any invalid records can be written out to the logs without causing the entire job to fail. If there are only a handful of invalid records in the entire dataset, we might be okay with ignoring them and continuing with our analysis.<a data-startref="ch07-inval" data-type="indexterm" id="idm46507969025824"/><a data-startref="ch07-inval2" data-type="indexterm" id="idm46507969025120"/><a data-startref="ch07-inval3" data-type="indexterm" id="idm46507969024448"/><a data-startref="ch07-inval4" data-type="indexterm" id="idm46507969023776"/></p>
<p>Now that we have prepared our dataset, let’s get started with geospatial analysis.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Geospatial Analysis" data-type="sect1"><div class="sect1" id="idm46507970904080">
<h1>Geospatial Analysis</h1>
<p>There are two major kinds of geospatial data—vector and raster—and<a data-primary="taxi trip data analysis" data-secondary="geospatial analysis" data-tertiary="about" data-type="indexterm" id="idm46507969021536"/><a data-primary="geospatial data analysis" data-secondary="geospatial analysis" data-tertiary="about" data-type="indexterm" id="idm46507969020288"/> there are different tools for working with each type. In our case, we have latitude and longitude for our taxi trip records, and vector data stored in the GeoJSON format that represents the boundaries of the different boroughs of New York. We’ve looked at the latitude and longitude points. Let’s start by having a look at the GeoJSON data.</p>
<section data-pdf-bookmark="Intro to GeoJSON" data-type="sect2"><div class="sect2" id="idm46507968960320">
<h2>Intro to GeoJSON</h2>
<p>The data we’ll use for the boundaries<a data-primary="geospatial data analysis" data-secondary="geospatial analysis" data-tertiary="GeoJSON" data-type="indexterm" id="idm46507968958560"/><a data-primary="taxi trip data analysis" data-secondary="geospatial analysis" data-tertiary="GeoJSON" data-type="indexterm" id="idm46507968957344"/><a data-primary="GeoJSON" data-type="indexterm" id="idm46507968956128"/><a data-primary="features of GeoJSON" data-type="indexterm" id="idm46507968955456"/><a data-primary="geometry instance of GeoJSON features" data-type="indexterm" id="idm46507968954784"/><a data-primary="properties of GeoJSON features" data-type="indexterm" id="idm46507968954144"/> of boroughs in New York City comes written in a format called <em>GeoJSON</em>.  The core object in GeoJSON is called a <em>feature</em>, which is made up of a <em>geometry</em> instance and a set of key-value pairs called <em>properties</em>.  A geometry is a shape like a point, line, or polygon. <a data-primary="features of GeoJSON" data-secondary="FeatureCollection" data-type="indexterm" id="idm46507968951744"/>A set of features is called a <code>FeatureCollection</code>. Let’s pull down the GeoJSON data for the NYC borough maps and take a look at its structure.</p>
<p>In the <em>taxidata</em> directory on your client machine, download the data and rename the file to something a bit shorter:</p>
<pre data-code-language="shell" data-type="programlisting">$ <code class="nv">url</code><code class="o">=</code><code class="s2">"https://nycdatastables.s3.amazonaws.com/\</code>
<code class="s2">        2013-08-19T18:15:35.172Z/nyc-borough-boundaries-polygon.geojson"</code>
$ curl -O <code class="nv">$url</code>
$ mv nyc-borough-boundaries-polygon.geojson nyc-boroughs.geojson</pre>
<p>Open the file and look at a feature record. Note the properties and the geometry objects—in this case, a polygon representing the boundaries of the borough and the properties containing the name of the borough and other related information.</p>
<pre data-code-language="shell" data-type="programlisting">$ head -n <code class="m">7</code> data/trip_data_ch07/nyc-boroughs.geojson
...
<code class="o">{</code>
<code class="s2">"type"</code>: <code class="s2">"FeatureCollection"</code>,

<code class="s2">"features"</code>: <code class="o">[{</code> <code class="s2">"type"</code>: <code class="s2">"Feature"</code>, <code class="s2">"id"</code>: <code class="m">0</code>, <code class="s2">"properties"</code>: <code class="o">{</code> <code class="s2">"boroughCode"</code>: <code class="m">5</code>, ...
,
<code class="o">{</code> <code class="s2">"type"</code>: <code class="s2">"Feature"</code>, <code class="s2">"id"</code>: <code class="m">1</code>, <code class="s2">"properties"</code>: <code class="o">{</code> <code class="s2">"boroughCode"</code>: <code class="m">5</code>, ...</pre>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46507968906672">
<h5>Geospatial Data Formats</h5>
<p>There are different specialized geospatial formats.<a data-primary="geospatial data analysis" data-secondary="about geospatial data" data-tertiary="data formats" data-type="indexterm" id="idm46507968867952"/><a data-primary="taxi trip data analysis" data-secondary="about geospatial data" data-tertiary="data formats" data-type="indexterm" id="idm46507968866768"/> In addition, data sources such as geotagged logs and text data can also be used to harvest location data. These include:</p>
<ul>
<li>
<p>Vector formats such as GeoJSON, KML, shapefile, and WKT</p>
</li>
<li>
<p>Raster formats such as Esri grid, GeoTIFF, JPEG 2000, and NITF</p>
</li>
<li>
<p>Navigational standards such as used by AIS and GPS devices</p>
</li>
<li>
<p>Geodatabases accessible via JDBC/ODBC connections such as PostgreSQL/PostGIS</p>
</li>
<li>
<p>Remote sensor formats from hyperspectral, multispectral, lidar, and radar platforms</p>
</li>
<li>
<p>OGC web standards such as WCS, WFS, WMS, and WMTS</p>
</li>
<li>
<p>Geotagged logs, pictures, videos, and social media</p>
</li>
<li>
<p>Unstructured data with location references</p>
</li>
</ul>
</div></aside>
</div></section>
<section data-pdf-bookmark="GeoPandas" data-type="sect2"><div class="sect2" id="idm46507968935440">
<h2>GeoPandas</h2>
<p>The first thing you should consider when choosing<a data-primary="geospatial data analysis" data-secondary="geospatial analysis" data-tertiary="GeoPandas" data-type="indexterm" id="ch07-geop"/><a data-primary="taxi trip data analysis" data-secondary="geospatial analysis" data-tertiary="GeoPandas" data-type="indexterm" id="ch07-geop2"/><a data-primary="pandas" data-secondary="GeoPandas" data-type="indexterm" id="ch07-geop3"/><a data-primary="GeoPandas" data-type="indexterm" id="ch07-geop4"/> a library to perform geospatial analysis is determine what kind of data you will need to work with. We need a library that can parse GeoJSON data and can handle spatial relationships, like detecting whether a given longitude/latitude pair is contained inside a polygon that represents the boundaries of a particular borough. We will use the <a href="https://geopandas.org">GeoPandas library</a> for this task. GeoPandas is an open source project to make working with geospatial data in Python easier. It extends the data types used by the pandas library, which we used in previous chapters, to allow spatial operations on geometric data types.</p>
<p>Install the GeoPandas package using pip:<a data-primary="GeoPandas" data-secondary="installing" data-type="indexterm" id="idm46507968857296"/><a data-primary="installing GeoPandas" data-type="indexterm" id="idm46507968856320"/><a data-primary="pandas" data-secondary="GeoPandas" data-tertiary="installing" data-type="indexterm" id="idm46507968855648"/></p>
<pre data-code-language="shell" data-type="programlisting">pip3 install geopandas</pre>
<p>Let us now start examining the geospatial aspects of the taxi data. For each trip, we have longitude/latitude pairs representing where the passenger was picked up and dropped off. We would like to be able to determine which borough each of these longitude/latitude pairs belongs to, and identify any trips that did not start or end in any of the five boroughs. For example, if a taxi took passengers from Manhattan to Newark Liberty International Airport, that would be a valid ride that would be interesting to analyze, even though it would not end within one of the five boroughs.</p>
<p class="pagebreak-before">To perform our borough analysis, we need to load the GeoJSON data we downloaded earlier and stored in the <em>nyc-boroughs.geojson</em> file:</p>
<pre data-code-language="python" data-type="programlisting"><code class="kn">import</code> <code class="nn">geopandas</code> <code class="k">as</code> <code class="nn">gdp</code>

<code class="n">gdf</code> <code class="o">=</code> <code class="n">gdp</code><code class="o">.</code><code class="n">read_file</code><code class="p">(</code><code class="s2">"./data/trip_data_ch07/nyc-boroughs.geojson"</code><code class="p">)</code></pre>
<p>Before we use the GeoJSON features on the taxi trip data, we should take a moment to think about how to organize this geospatial data for maximum efficiency. One option would be to research data structures that are optimized for geospatial lookups, such as quad trees, and then find or write our own implementation. Instead, we will try to come up with a quick heuristic that will allow us to bypass that bit of work.</p>
<p>We will iterate through the <code>gdf</code> until we find a feature whose geometry contains a given <code>point</code> of longitude/latitude. Most taxi rides in NYC begin and end in Manhattan, so if the geospatial features that represent Manhattan are earlier in the sequence, our searches will end relatively quickly. We can use the fact that the <code>boroughCode</code> property of each feature can be used as a sorting key, with the code for Manhattan equal to 1 and the code for Staten Island equal to 5. Within the features for each borough, we want the features associated with the largest polygons to come before those associated with the smaller polygons, because most trips will be to and from the “major” region of each borough.</p>
<p>We will calculate area associated with each feature’s geometry and store it as a new column:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">gdf</code> <code class="o">=</code> <code class="n">gdf</code><code class="o">.</code><code class="n">to_crs</code><code class="p">(</code><code class="mi">3857</code><code class="p">)</code>

<code class="n">gdf</code><code class="p">[</code><code class="s1">'area'</code><code class="p">]</code> <code class="o">=</code> <code class="n">gdf</code><code class="o">.</code><code class="n">apply</code><code class="p">(</code><code class="k">lambda</code> <code class="n">x</code><code class="p">:</code> <code class="n">x</code><code class="p">[</code><code class="s1">'geometry'</code><code class="p">]</code><code class="o">.</code><code class="n">area</code><code class="p">,</code> <code class="n">axis</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code>
<code class="n">gdf</code><code class="o">.</code><code class="n">head</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code>
<code class="o">...</code>

    <code class="n">boroughCode</code>  <code class="n">borough</code>        <code class="nd">@id</code>     <code class="n">geometry</code>     <code class="n">area</code>
<code class="mi">0</code>   <code class="mi">5</code>            <code class="n">Staten</code> <code class="n">Island</code> 	<code class="n">http</code><code class="p">:</code><code class="o">//</code><code class="n">nyc</code><code class="o">.</code><code class="n">pediacities</code><code class="o">.</code><code class="n">com</code><code class="o">/</code><code class="n">Resource</code><code class="o">/</code><code class="n">Borough</code><code class="o">/</code><code class="n">St</code><code class="o">...</code>
<code class="mi">1</code>   <code class="mi">5</code>            <code class="n">Staten</code> <code class="n">Island</code> 	<code class="n">http</code><code class="p">:</code><code class="o">//</code><code class="n">nyc</code><code class="o">.</code><code class="n">pediacities</code><code class="o">.</code><code class="n">com</code><code class="o">/</code><code class="n">Resource</code><code class="o">/</code><code class="n">Borough</code><code class="o">/</code><code class="n">St</code><code class="o">...</code>
<code class="mi">2</code>   <code class="mi">5</code>            <code class="n">Staten</code> <code class="n">Island</code> 	<code class="n">http</code><code class="p">:</code><code class="o">//</code><code class="n">nyc</code><code class="o">.</code><code class="n">pediacities</code><code class="o">.</code><code class="n">com</code><code class="o">/</code><code class="n">Resource</code><code class="o">/</code><code class="n">Borough</code><code class="o">/</code><code class="n">St</code><code class="o">...</code>
<code class="mi">3</code>   <code class="mi">5</code>            <code class="n">Staten</code> <code class="n">Island</code> 	<code class="n">http</code><code class="p">:</code><code class="o">//</code><code class="n">nyc</code><code class="o">.</code><code class="n">pediacities</code><code class="o">.</code><code class="n">com</code><code class="o">/</code><code class="n">Resource</code><code class="o">/</code><code class="n">Borough</code><code class="o">/</code><code class="n">St</code><code class="o">...</code>
<code class="mi">4</code>   <code class="mi">4</code>            <code class="n">Queens</code>         <code class="n">http</code><code class="p">:</code><code class="o">//</code><code class="n">nyc</code><code class="o">.</code><code class="n">pediacities</code><code class="o">.</code><code class="n">com</code><code class="o">/</code><code class="n">Resource</code><code class="o">/</code><code class="n">Borough</code><code class="o">/</code><code class="n">Qu</code><code class="o">...</code></pre>
<p>Sorting the features by the combination of the borough code and the area of each feature’s geometry should do the trick:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">gdf</code> <code class="o">=</code> <code class="n">gdf</code><code class="o">.</code><code class="n">sort_values</code><code class="p">(</code><code class="n">by</code><code class="o">=</code><code class="p">[</code><code class="s1">'boroughCode'</code><code class="p">,</code> <code class="s1">'area'</code><code class="p">],</code> <code class="n">ascending</code><code class="o">=</code><code class="p">[</code><code class="kc">True</code><code class="p">,</code> <code class="kc">False</code><code class="p">])</code>
<code class="n">gdf</code><code class="o">.</code><code class="n">head</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code>
<code class="o">...</code>
    <code class="n">boroughCode</code>  <code class="n">borough</code>    <code class="nd">@id</code>     <code class="n">geometry</code>     <code class="n">area</code>
<code class="mi">72</code>  <code class="mi">1</code>            <code class="n">Manhattan</code>  <code class="n">http</code><code class="p">:</code><code class="o">//</code><code class="n">nyc</code><code class="o">.</code><code class="n">pediacities</code><code class="o">.</code><code class="n">com</code><code class="o">/</code><code class="n">Resource</code><code class="o">/</code><code class="n">Borough</code><code class="o">/</code><code class="n">Ma</code><code class="o">...</code>
<code class="mi">71</code>  <code class="mi">1</code>            <code class="n">Manhattan</code>  <code class="n">http</code><code class="p">:</code><code class="o">//</code><code class="n">nyc</code><code class="o">.</code><code class="n">pediacities</code><code class="o">.</code><code class="n">com</code><code class="o">/</code><code class="n">Resource</code><code class="o">/</code><code class="n">Borough</code><code class="o">/</code><code class="n">Ma</code><code class="o">...</code>
<code class="mi">51</code>  <code class="mi">1</code>            <code class="n">Manhattan</code>  <code class="n">http</code><code class="p">:</code><code class="o">//</code><code class="n">nyc</code><code class="o">.</code><code class="n">pediacities</code><code class="o">.</code><code class="n">com</code><code class="o">/</code><code class="n">Resource</code><code class="o">/</code><code class="n">Borough</code><code class="o">/</code><code class="n">Ma</code><code class="o">...</code>
<code class="mi">69</code>  <code class="mi">1</code>            <code class="n">Manhattan</code>  <code class="n">http</code><code class="p">:</code><code class="o">//</code><code class="n">nyc</code><code class="o">.</code><code class="n">pediacities</code><code class="o">.</code><code class="n">com</code><code class="o">/</code><code class="n">Resource</code><code class="o">/</code><code class="n">Borough</code><code class="o">/</code><code class="n">Ma</code><code class="o">...</code>
<code class="mi">73</code>  <code class="mi">1</code>            <code class="n">Manhattan</code>  <code class="n">http</code><code class="p">:</code><code class="o">//</code><code class="n">nyc</code><code class="o">.</code><code class="n">pediacities</code><code class="o">.</code><code class="n">com</code><code class="o">/</code><code class="n">Resource</code><code class="o">/</code><code class="n">Borough</code><code class="o">/</code><code class="n">Ma</code><code class="o">...</code></pre>
<p>Note that we’re sorting based on area value in descending order because we want the largest polygons to
come first, and <code>sort_values</code> sorts in ascending order by default.</p>
<p>Now we can broadcast the sorted features in the <code>gdf</code> GeoPandas DataFrame to the cluster and write a function that uses these features to find out in which of the five boroughs (if any) a particular trip ended:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">b_gdf</code> <code class="o">=</code> <code class="n">spark</code><code class="o">.</code><code class="n">sparkContext</code><code class="o">.</code><code class="n">broadcast</code><code class="p">(</code><code class="n">gdf</code><code class="p">)</code>

<code class="k">def</code> <code class="nf">find_borough</code><code class="p">(</code><code class="n">latitude</code><code class="p">,</code><code class="n">longitude</code><code class="p">):</code>
    <code class="n">mgdf</code> <code class="o">=</code> <code class="n">b_gdf</code><code class="o">.</code><code class="n">value</code><code class="o">.</code><code class="n">apply</code><code class="p">(</code><code class="k">lambda</code> <code class="n">x</code><code class="p">:</code> <code class="n">x</code><code class="p">[</code><code class="s1">'borough'</code><code class="p">]</code> <code class="k">if</code> \
                              <code class="n">x</code><code class="p">[</code><code class="s1">'geometry'</code><code class="p">]</code><code class="o">.</code>\
                              <code class="n">intersects</code><code class="p">(</code><code class="n">gdp</code><code class="o">.</code>\
                                        <code class="n">points_from_xy</code><code class="p">(</code>
                                            <code class="p">[</code><code class="n">longitude</code><code class="p">],</code> \
                                            <code class="p">[</code><code class="n">latitude</code><code class="p">])[</code><code class="mi">0</code><code class="p">])</code> \
                              <code class="k">else</code> <code class="kc">None</code><code class="p">,</code> <code class="n">axis</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code>
    <code class="n">idx</code> <code class="o">=</code> <code class="n">mgdf</code><code class="o">.</code><code class="n">first_valid_index</code><code class="p">()</code>
    <code class="k">return</code> <code class="n">mgdf</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="n">idx</code><code class="p">]</code> <code class="k">if</code> <code class="n">idx</code> <code class="ow">is</code> <code class="ow">not</code> <code class="kc">None</code> <code class="k">else</code> <code class="kc">None</code>

<code class="n">find_borough_udf</code> <code class="o">=</code> <code class="n">fun</code><code class="o">.</code><code class="n">udf</code><code class="p">(</code><code class="n">find_borough</code><code class="p">,</code> <code class="n">StringType</code><code class="p">())</code></pre>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46507968452352">
<h5>To UDF or Not to UDF?</h5>
<p>PySpark SQL makes it very easy<a data-primary="UDFs (user-defined functions) in pandas" data-secondary="to UDF or not to UDF" data-type="indexterm" id="idm46507968451216"/><a data-primary="pandas" data-secondary="user-defined functions" data-tertiary="to UDF or not to UDF" data-type="indexterm" id="idm46507968429440"/><a data-primary="Spark SQL module" data-secondary="UDFs and" data-type="indexterm" id="idm46507968284240"/> to convert business logic into functions as we did here with the <code>find_borough</code> function. Given this, you might think that it would be a good idea to move all of your business logic into UDFs to make it easy to reuse, test, and maintain. However, there are a few caveats for using UDFs that you should be mindful of before you start sprinkling them throughout your code:</p>
<ul>
<li>
<p>First, UDFs are opaque to PySpark’s SQL query planner and execution engine in a way that standard SQL query syntax is not, so moving logic into a UDF instead of using a literal SQL expression could hurt query performance.</p>
</li>
<li>
<p>Second, handling null values in PySpark SQL can get complicated quickly, especially for UDFs that take multiple arguments.</p>
</li>
</ul>
</div></aside>
<p>We can apply <code>find_borough</code> to the trips in the <code>taxi_raw</code> DataFrame to create a histogram of trips by borough:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df_with_boroughs</code> <code class="o">=</code> <code class="n">taxi_raw</code><code class="o">.</code>\
                    <code class="n">withColumn</code><code class="p">(</code><code class="s2">"dropoff_borough"</code><code class="p">,</code> \
                              <code class="n">find_borough_udf</code><code class="p">(</code>
                                <code class="n">fun</code><code class="o">.</code><code class="n">col</code><code class="p">(</code><code class="s2">"dropoff_latitude"</code><code class="p">),</code>\
                                <code class="n">fun</code><code class="o">.</code><code class="n">col</code><code class="p">(</code><code class="s1">'dropoff_longitude'</code><code class="p">)))</code>

<code class="n">df_with_boroughs</code><code class="o">.</code><code class="n">groupBy</code><code class="p">(</code><code class="n">fun</code><code class="o">.</code><code class="n">col</code><code class="p">(</code><code class="s2">"dropoff_borough"</code><code class="p">))</code><code class="o">.</code><code class="n">count</code><code class="p">()</code><code class="o">.</code><code class="n">show</code><code class="p">()</code>
<code class="o">...</code>
<code class="o">+-----------------------+--------+</code>
<code class="o">|</code>     <code class="n">dropoff_borough</code>   <code class="o">|</code>   <code class="n">count</code><code class="o">|</code>
<code class="o">+-----------------------+--------+</code>
<code class="o">|</code>                 <code class="n">Queens</code><code class="o">|</code>  <code class="mi">672192</code><code class="o">|</code>
<code class="o">|</code>                   <code class="n">null</code><code class="o">|</code> <code class="mi">7942421</code><code class="o">|</code>
<code class="o">|</code>               <code class="n">Brooklyn</code><code class="o">|</code>  <code class="mi">715252</code><code class="o">|</code>
<code class="o">|</code>          <code class="n">Staten</code> <code class="n">Island</code><code class="o">|</code>    <code class="mi">3338</code><code class="o">|</code>
<code class="o">|</code>              <code class="n">Manhattan</code><code class="o">|</code><code class="mi">12979047</code><code class="o">|</code>
<code class="o">|</code>                  <code class="n">Bronx</code><code class="o">|</code>   <code class="mi">67434</code><code class="o">|</code>
<code class="o">+-----------------------+--------+</code></pre>
<p>As we expected, the vast majority of trips end in the borough of Manhattan, while relatively few trips end in Staten Island.
One surprising observation is the number of trips that end outside of any borough; the number of <code>null</code> records is substantially larger than the number of taxi rides that end in the Bronx.</p>
<p>We had talked about handling such invalid records earlier but did not remove them. It is left as an exercise for you to remove such records and create a histogram from the cleaned-up data. Once done, you will notice a reduction in the number of <code>null</code> entries, leaving a much more reasonable number of observations that had drop-offs outside the city.</p>
<p>Having worked with the geospatial aspects of our data, let us now dig deeper into the temporal nature of our data by performing sessionization using PySpark.<a data-startref="ch07-geop" data-type="indexterm" id="idm46507968235728"/><a data-startref="ch07-geop2" data-type="indexterm" id="idm46507968235056"/><a data-startref="ch07-geop3" data-type="indexterm" id="idm46507968234384"/><a data-startref="ch07-geop4" data-type="indexterm" id="idm46507968233712"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Sessionization in PySpark" data-type="sect1"><div class="sect1" id="idm46507968864096">
<h1>Sessionization in PySpark</h1>
<p>The kind of analysis, in which we want to analyze<a data-primary="taxi trip data analysis" data-secondary="sessionization in PySpark" data-type="indexterm" id="idm46507968231376"/><a data-primary="geospatial data analysis" data-secondary="sessionization in PySpark" data-type="indexterm" id="idm46507968230432"/><a data-primary="temporal data" data-secondary="sessionization in PySpark" data-type="indexterm" id="idm46507968229456"/><a data-primary="sessionization in PySpark" data-type="indexterm" id="idm46507968228496"/><a data-primary="aggregation functions of dataframes" data-secondary="sessionization" data-type="indexterm" id="idm46507968227808"/><a data-primary="Window for sessionization" data-type="indexterm" id="idm46507968226848"/> a single entity as it executes a series of events over time, is called <em>sessionization</em>, and is commonly performed over web logs to analyze the behavior of the users of a website. PySpark provides <code>Window</code> and aggregation functions out of the box that can be used to perform such analysis. These allow us to focus on business logic instead of trying to implement complex data manipulation and calculation. We will use these in the next section to better understand utilization of taxi cabs in our dataset.</p>
<p>Sessionization can be a very powerful technique for uncovering insights in data and building new data products that can be used to help people make better decisions. <a data-primary="spell-correction engine sessionization" data-type="indexterm" id="idm46507968224816"/><a data-primary="Google spell correction sessionization" data-type="indexterm" id="idm46507968224144"/>For example, Google’s spell-correction engine is built on top of the sessions of user activity that Google builds each day from the logged records of every event (searches, clicks, maps visits, etc.) occurring on its web properties. To identify likely spell-correction candidates, Google processes those sessions looking for
situations where a user typed a query, didn’t click anything, typed a slightly different query a few seconds later, and then clicked a result and didn’t come back to Google. Then it counts how often this pattern occurs for any pair of queries. If it occurs frequently enough (e.g., if every time we see the query “untied stats,” it’s followed a few seconds later by the query “united states”), then we assume that the second query is a spell correction of the first.</p>
<p>This analysis takes advantage of the patterns of human behavior that are represented in the event logs to build a spell-correction engine from data that is more powerful than any engine that could be created from a dictionary. The engine can be used to perform spell correction in any language and can correct words that might not be included in any dictionary (e.g., the name of a new startup) or queries like “untied stats” where none of the words are misspelled! Google uses similar techniques to show recommended and related searches, as well as to decide which queries should return a OneBox result that gives the answer to a query on the search page itself, without requiring that the user click through to a different page. There are OneBoxes for weather, scores from sporting events, addresses, and lots of other kinds of queries.</p>
<p>So far, information about the set of events that occurs to each entity is spread out across the DataFrame’s partitions, so, for analysis, we need to place these relevant events next to each other and in chronological order.  In the next section, we will show how to efficiently construct and analyze sessions using advanced PySpark functionality.</p>
<section data-pdf-bookmark="Building Sessions: Secondary Sorts in PySpark" data-type="sect2"><div class="sect2" id="idm46507968142768">
<h2>Building Sessions: Secondary Sorts in PySpark</h2>
<p>The naive way to create sessions in PySpark<a data-primary="taxi trip data analysis" data-secondary="sessionization in PySpark" data-tertiary="building sessions" data-type="indexterm" id="ch07-sess"/><a data-primary="geospatial data analysis" data-secondary="sessionization in PySpark" data-tertiary="building sessions" data-type="indexterm" id="ch07-sess2"/><a data-primary="sessionization in PySpark" data-secondary="building sessions" data-type="indexterm" id="ch07-sess3"/><a data-primary="temporal data" data-secondary="sessionization in PySpark" data-tertiary="building sessions" data-type="indexterm" id="ch07-sess4"/><a data-primary="groupBy for sessionization" data-type="indexterm" id="ch07-sess5"/> is to perform a <code>groupBy</code> on the identifier we want to create sessions for and then sort the events post-shuffle by a timestamp identifier. If we only have a small number of events for each entity, this approach will work reasonably well. <a data-primary="scalability" data-secondary="sessionization in PySpark" data-type="indexterm" id="idm46507968133424"/>However, because this approach requires all the events for any particular entity to be in memory at the same time, it will not scale as the number of events for each entity gets larger and larger. We need a way of building sessions that does not require all of the events for a particular entity to be held in memory at the same time for sorting.</p>
<p>In MapReduce, we can build sessions<a data-primary="MapReduce versus Spark" data-secondary="sessions via secondary sort" data-type="indexterm" id="idm46507968132048"/><a data-primary="Hadoop (Apache)" data-secondary="MapReduce versus Spark" data-tertiary="sessions via secondary sort" data-type="indexterm" id="idm46507968131056"/><a data-primary="Window for sessionization" data-secondary="building sessions" data-type="indexterm" id="idm46507968129824"/><a data-primary="secondary sort to build sessions" data-type="indexterm" id="idm46507968128864"/> by performing a <em>secondary sort</em>, where we create a composite key made up of an identifier and a timestamp value, sort all of the records on the composite key, and then use a custom partitioner and grouping function to ensure that all of the records for the same identifier appear in the same output partition. Fortunately, PySpark can also support a similar pattern by using <code>Window</code> functions:</p>
<pre data-code-language="python" data-type="programlisting"><code class="kn">from</code> <code class="nn">pyspark.sql</code> <code class="kn">import</code> <code class="n">Window</code>

<code class="n">window_spec</code> <code class="o">=</code> <code class="n">Window</code><code class="o">.</code><code class="n">partitionBy</code><code class="p">(</code><code class="s2">"hack_license"</code><code class="p">)</code><code class="o">.</code>\
                      <code class="n">orderBy</code><code class="p">(</code><code class="n">fun</code><code class="o">.</code><code class="n">col</code><code class="p">(</code><code class="s2">"hack_license"</code><code class="p">),</code>
                              <code class="n">fun</code><code class="o">.</code><code class="n">col</code><code class="p">(</code><code class="s2">"pickup_datetime"</code><code class="p">))</code></pre>
<p>First, we use the <code>partitionBy</code> method<a data-primary="partitionBy method" data-type="indexterm" id="idm46507968120864"/> to ensure that all of the records that have the same value for the <code>license</code> column end up in the same partition. Then, within each of these partitions, we sort the records by their <code>license</code> value (so all trips by the same driver appear together) and then by their <code>pickupTime</code> so that the sequence of trips appears in sorted order within the partition. Now when we aggregate the trip records, we can be sure that the trips are ordered in a way that is optimal for sessions analysis. Because this operation triggers a shuffle and a fair bit of computation and we’ll need to use
the results more than once, we cache them:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">window_spec</code><code class="o">.</code><code class="n">cache</code><code class="p">()</code></pre>
<p>Executing a sessionization pipeline is an expensive operation, and the sessionized data is often useful for many different
analysis tasks that we might want to perform. <a data-primary="persistent storage" data-secondary="sessionized data" data-type="indexterm" id="idm46507968066576"/><a data-primary="filesystem" data-see="persistent storage" data-type="indexterm" id="idm46507968065728"/>In settings where one might want to pick up on the analysis later or collaborate
with other data scientists, it is a good idea to amortize the cost of sessionizing a large dataset by only performing the sessionization once and then writing the sessionized data to a filesystem such as S3 or HDFS so that it can be used to answer lots of different questions. Performing sessionization once is also a good way to enforce standard
rules for session definitions across the entire data science team, which has the same benefits for ensuring apples-to-apples
comparisons of results.</p>
<p>At this point, we are ready to analyze<a data-primary="taxi trip data analysis" data-secondary="about problem to be solved" data-tertiary="solution" data-type="indexterm" id="idm46507968064368"/><a data-primary="geospatial data analysis" data-secondary="about problem to be solved" data-tertiary="solution" data-type="indexterm" id="idm46507968063280"/> our sessions data to see how long it takes for a driver to find his next fare
after a drop-off in a particular borough. We will use the <code>lag</code> function along with the <code>window_spec</code> object created earlier to take two trips and compute the duration in seconds between the drop-off time of the first trip and the pickup time of the second:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df_</code> <code class="n">with_</code> <code class="n">borough_durations</code> <code class="o">=</code> <code class="n">df_with_boroughs</code><code class="o">.</code>\
            <code class="n">withColumn</code><code class="p">(</code><code class="s2">"trip_time_difference"</code><code class="p">,</code> \
            <code class="n">fun</code><code class="o">.</code><code class="n">col</code><code class="p">(</code><code class="s2">"pickup_datetime"</code><code class="p">)</code> <code class="o">-</code> <code class="n">fun</code><code class="o">.</code><code class="n">lag</code><code class="p">(</code><code class="n">fun</code><code class="o">.</code><code class="n">col</code><code class="p">(</code><code class="s2">"pickup_datetime"</code><code class="p">),</code>
                                          <code class="mi">1</code><code class="p">)</code><code class="o">.</code> \
            <code class="n">over</code><code class="p">(</code><code class="n">window_spec</code><code class="p">))</code><code class="o">.</code><code class="n">show</code><code class="p">(</code><code class="mi">50</code><code class="p">,</code> <code class="n">vertical</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code></pre>
<p>Now, we should do a validation check to ensure that most of the durations are nonnegative:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df_with_borough_durations</code><code class="o">.</code>
  <code class="n">selectExpr</code><code class="p">(</code><code class="s2">"floor(seconds / 3600) as hours"</code><code class="p">)</code><code class="o">.</code>
  <code class="n">groupBy</code><code class="p">(</code><code class="s2">"hours"</code><code class="p">)</code><code class="o">.</code>
  <code class="n">count</code><code class="p">()</code><code class="o">.</code>
  <code class="n">sort</code><code class="p">(</code><code class="s2">"hours"</code><code class="p">)</code><code class="o">.</code>
  <code class="n">show</code><code class="p">()</code>
<code class="o">...</code>
<code class="o">+-----+--------+</code>
<code class="o">|</code><code class="n">hours</code><code class="o">|</code>   <code class="n">count</code><code class="o">|</code>
<code class="o">+-----+--------+</code>
<code class="o">|</code>   <code class="o">-</code><code class="mi">3</code><code class="o">|</code>       <code class="mi">2</code><code class="o">|</code>
<code class="o">|</code>   <code class="o">-</code><code class="mi">2</code><code class="o">|</code>      <code class="mi">16</code><code class="o">|</code>
<code class="o">|</code>   <code class="o">-</code><code class="mi">1</code><code class="o">|</code>    <code class="mi">4253</code><code class="o">|</code>
<code class="o">|</code>    <code class="mi">0</code><code class="o">|</code><code class="mi">13359033</code><code class="o">|</code>
<code class="o">|</code>    <code class="mi">1</code><code class="o">|</code>  <code class="mi">347634</code><code class="o">|</code>
<code class="o">|</code>    <code class="mi">2</code><code class="o">|</code>   <code class="mi">76286</code><code class="o">|</code>
<code class="o">|</code>    <code class="mi">3</code><code class="o">|</code>   <code class="mi">24812</code><code class="o">|</code>
<code class="o">|</code>    <code class="mi">4</code><code class="o">|</code>   <code class="mi">10026</code><code class="o">|</code>
<code class="o">|</code>    <code class="mi">5</code><code class="o">|</code>    <code class="mi">4789</code><code class="o">|</code></pre>
<p>Only a few of the records have a negative duration, and when we examine them more closely, there don’t seem to
be any common patterns to them that we could use to understand the source of the erroneous data. If we exclude these negative duration records from our input dataset and look at the average and standard deviation of the pickup times by borough, we see this:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df_with_borough_durations</code><code class="o">.</code>
  <code class="n">where</code><code class="p">(</code><code class="s2">"seconds &gt; 0 AND seconds &lt; 60*60*4"</code><code class="p">)</code><code class="o">.</code>
  <code class="n">groupBy</code><code class="p">(</code><code class="s2">"borough"</code><code class="p">)</code><code class="o">.</code>
  <code class="n">agg</code><code class="p">(</code><code class="n">avg</code><code class="p">(</code><code class="s2">"seconds"</code><code class="p">),</code> <code class="n">stddev</code><code class="p">(</code><code class="s2">"seconds"</code><code class="p">))</code><code class="o">.</code>
  <code class="n">show</code><code class="p">()</code>
<code class="o">...</code>
<code class="o">+-------------+------------------+--------------------+</code>
<code class="o">|</code>      <code class="n">borough</code><code class="o">|</code>      <code class="n">avg</code><code class="p">(</code><code class="n">seconds</code><code class="p">)</code><code class="o">|</code><code class="n">stddev_samp</code><code class="p">(</code><code class="n">seconds</code><code class="p">)</code><code class="o">|</code>
<code class="o">+-------------+------------------+--------------------+</code>
<code class="o">|</code>       <code class="n">Queens</code><code class="o">|</code><code class="mf">2380.6603554494727</code><code class="o">|</code>  <code class="mf">2206.6572799118035</code><code class="o">|</code>
<code class="o">|</code>           <code class="n">NA</code><code class="o">|</code>  <code class="mf">2006.53571169866</code><code class="o">|</code>  <code class="mf">1997.0891370324784</code><code class="o">|</code>
<code class="o">|</code>     <code class="n">Brooklyn</code><code class="o">|</code> <code class="mf">1365.394576250576</code><code class="o">|</code>  <code class="mf">1612.9921698951398</code><code class="o">|</code>
<code class="o">|</code><code class="n">Staten</code> <code class="n">Island</code><code class="o">|</code>         <code class="mf">2723.5625</code><code class="o">|</code>  <code class="mf">2395.7745475546385</code><code class="o">|</code>
<code class="o">|</code>    <code class="n">Manhattan</code><code class="o">|</code> <code class="mf">631.8473780726746</code><code class="o">|</code>   <code class="mf">1042.919915477234</code><code class="o">|</code>
<code class="o">|</code>        <code class="n">Bronx</code><code class="o">|</code><code class="mf">1975.9209786770646</code><code class="o">|</code>   <code class="mf">1704.006452085683</code><code class="o">|</code>
<code class="o">+-------------+------------------+--------------------+</code></pre>
<p>As we would expect, the data shows that drop-offs in Manhattan have the shortest amount of downtime for drivers, at around 10 minutes. Taxi rides that end in Brooklyn have a downtime of more than twice that, and the relatively few rides that
end in Staten Island take drivers an average of almost 45 minutes to get to their next fare.</p>
<p>As the data demonstrates, taxi drivers have a major financial incentive to discriminate among passengers based on their final destination; drop-offs in Staten Island, in particular, involve an extensive amount of downtime for a driver. The NYC Taxi and Limousine Commission has made a major effort over the years to identify this discrimination and has fined drivers who have been caught rejecting passengers because of where they wanted to go. It would be interesting to attempt to examine the data for unusually short taxi rides that could be indicative of a dispute between the driver and the passenger about where the passenger wanted to be dropped off.<a data-startref="ch07-sess" data-type="indexterm" id="idm46507967799360"/><a data-startref="ch07-sess2" data-type="indexterm" id="idm46507967753952"/><a data-startref="ch07-sess3" data-type="indexterm" id="idm46507967753312"/><a data-startref="ch07-sess4" data-type="indexterm" id="idm46507967752640"/><a data-startref="ch07-sess5" data-type="indexterm" id="idm46507967751968"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Where to Go from Here" data-type="sect1"><div class="sect1" id="idm46507967751168">
<h1>Where to Go from Here</h1>
<p>In this chapter, we worked with both temporal and spatial features of a real-world dataset. The familiarity with geospatial analysis that you have gained so far can be used to dive into frameworks such as <a data-primary="Apache Sedona" data-type="indexterm" id="idm46507967749872"/><a data-primary="Sedona (Apache)" data-type="indexterm" id="idm46507967749168"/><a data-primary="GeoMesa" data-type="indexterm" id="idm46507967748496"/>Apache Sedona or GeoMesa. They will have a steeper learning curve compared to working with GeoPandas and UDFs but will be more efficient. There’s also a lot of scope for using data visualization with geospatial and temporal data.</p>
<p>Further, imagine using this same technique on the taxi data to build an application that could recommend the best place for a cab to go after a drop-off based on current traffic patterns and the historical record of next-best locations contained within this data. You could also look at the information from the perspective of someone trying to catch a cab: given the current time, place, and weather data, what is the probability that I will be able to hail a cab from the street within the next five minutes? This sort of information could be incorporated into applications like Google Maps to help travelers decide when to leave and which travel option they should take.</p>
</div></section>
</div></section></div></body></html>