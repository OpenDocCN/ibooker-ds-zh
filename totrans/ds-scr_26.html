<html><head></head><body><section data-pdf-bookmark="Chapter 25. MapReduce" data-type="chapter" epub:type="chapter"><div class="chapter" id="map_reduce">&#13;
<h1><span class="label">Chapter 25. </span>MapReduce</h1>&#13;
&#13;
<blockquote data-type="epigraph" epub:type="epigraph">&#13;
    <p>The future has already arrived. It’s just not evenly distributed yet.</p>&#13;
    <p data-type="attribution">William Gibson</p>&#13;
</blockquote>&#13;
&#13;
<p>MapReduce<a data-primary="MapReduce" data-secondary="uses for" data-type="indexterm" id="idm45635705491864"/> is a programming model for performing parallel processing on large datasets.  Although it is a powerful technique, its basics are relatively simple.</p>&#13;
&#13;
<p>Imagine we have a collection of items we’d like to process somehow.  For instance, the items might be website logs, the texts of various books, image files, or anything else.  A<a data-primary="MapReduce" data-secondary="basic algorithm" data-type="indexterm" id="idm45635705489992"/> basic version of the MapReduce algorithm consists of the following steps:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Use a <code>mapper</code> function to turn each item into zero or more key/value pairs.  (Often this is called the <code>map</code> function, but there is already a Python function called <code>map</code> and we don’t need to confuse the two.)</p>&#13;
</li>&#13;
<li>&#13;
<p>Collect together all the pairs with identical keys.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use a <code>reducer</code> function on each collection of grouped values to produce output values for the corresponding key.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>MapReduce is sort of passé, so much so that I considered removing this chapter from the second edition. But I decided it’s still an interesting topic, so I ended up leaving it in (obviously).</p>&#13;
</div>&#13;
&#13;
<p>This is all sort of abstract, so let’s look at a specific example.  There are few absolute rules of data science, but one of them is that your first MapReduce example has to involve counting words.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Example: Word Count" data-type="sect1"><div class="sect1" id="idm45635705457992">&#13;
<h1>Example: Word Count</h1>&#13;
&#13;
<p>DataSciencester<a data-primary="MapReduce" data-secondary="word count example" data-type="indexterm" id="idm45635705456328"/><a data-primary="word counting" data-type="indexterm" id="idm45635705455320"/> has grown to millions of users!  This is great for your&#13;
job security, but it makes routine analyses slightly more difficult.</p>&#13;
&#13;
<p>For example, your VP of Content wants to know what sorts of things&#13;
people are talking about in their status updates.  As a first attempt,&#13;
you decide to count the words that appear, so that you can prepare&#13;
a report on the most frequent ones.</p>&#13;
&#13;
<p>When you had a few hundred users, this was simple to do:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">List</code>&#13;
<code class="kn">from</code> <code class="nn">collections</code> <code class="kn">import</code> <code class="n">Counter</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">tokenize</code><code class="p">(</code><code class="n">document</code><code class="p">:</code> <code class="nb">str</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">List</code><code class="p">[</code><code class="nb">str</code><code class="p">]:</code>&#13;
    <code class="sd">"""Just split on whitespace"""</code>&#13;
    <code class="k">return</code> <code class="n">document</code><code class="o">.</code><code class="n">split</code><code class="p">()</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">word_count_old</code><code class="p">(</code><code class="n">documents</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="nb">str</code><code class="p">]):</code>&#13;
    <code class="sd">"""Word count not using MapReduce"""</code>&#13;
    <code class="k">return</code> <code class="n">Counter</code><code class="p">(</code><code class="n">word</code>&#13;
        <code class="k">for</code> <code class="n">document</code> <code class="ow">in</code> <code class="n">documents</code>&#13;
        <code class="k">for</code> <code class="n">word</code> <code class="ow">in</code> <code class="n">tokenize</code><code class="p">(</code><code class="n">document</code><code class="p">))</code></pre>&#13;
&#13;
<p>With millions of users the set of <code>documents</code> (status updates) is suddenly too&#13;
big to fit on your computer.  If you can just fit this into the MapReduce model,&#13;
you can use some “big data” infrastructure that your engineers have implemented.</p>&#13;
&#13;
<p>First, we need a function that turns a document into a sequence of key/value pairs. We’ll want our output to be grouped by word, which means that the keys should be words.  And for each word, we’ll just emit the value <code>1</code> to indicate that this pair corresponds to one occurrence of the word:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">Iterator</code><code class="p">,</code> <code class="n">Tuple</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">wc_mapper</code><code class="p">(</code><code class="n">document</code><code class="p">:</code> <code class="nb">str</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Iterator</code><code class="p">[</code><code class="n">Tuple</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code> <code class="nb">int</code><code class="p">]]:</code>&#13;
    <code class="sd">"""For each word in the document, emit (word, 1)"""</code>&#13;
    <code class="k">for</code> <code class="n">word</code> <code class="ow">in</code> <code class="n">tokenize</code><code class="p">(</code><code class="n">document</code><code class="p">):</code>&#13;
        <code class="k">yield</code> <code class="p">(</code><code class="n">word</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code></pre>&#13;
&#13;
<p>Skipping the “plumbing” step 2 for the moment, imagine that for some word we’ve collected a list of the corresponding counts we emitted. To produce the overall count for that word, then, we just need:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">Iterable</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">wc_reducer</code><code class="p">(</code><code class="n">word</code><code class="p">:</code> <code class="nb">str</code><code class="p">,</code>&#13;
               <code class="n">counts</code><code class="p">:</code> <code class="n">Iterable</code><code class="p">[</code><code class="nb">int</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="n">Iterator</code><code class="p">[</code><code class="n">Tuple</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code> <code class="nb">int</code><code class="p">]]:</code>&#13;
    <code class="sd">"""Sum up the counts for a word"""</code>&#13;
    <code class="k">yield</code> <code class="p">(</code><code class="n">word</code><code class="p">,</code> <code class="nb">sum</code><code class="p">(</code><code class="n">counts</code><code class="p">))</code></pre>&#13;
&#13;
<p>Returning to step 2, we now need to collect the results from <code>wc_mapper</code> and feed them to <code>wc_reducer</code>.  Let’s think about how we would do this on just one computer:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">collections</code> <code class="kn">import</code> <code class="n">defaultdict</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">word_count</code><code class="p">(</code><code class="n">documents</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="nb">str</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="n">List</code><code class="p">[</code><code class="n">Tuple</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code> <code class="nb">int</code><code class="p">]]:</code>&#13;
    <code class="sd">"""Count the words in the input documents using MapReduce"""</code>&#13;
&#13;
    <code class="n">collector</code> <code class="o">=</code> <code class="n">defaultdict</code><code class="p">(</code><code class="nb">list</code><code class="p">)</code>  <code class="c1"># To store grouped values</code>&#13;
&#13;
    <code class="k">for</code> <code class="n">document</code> <code class="ow">in</code> <code class="n">documents</code><code class="p">:</code>&#13;
        <code class="k">for</code> <code class="n">word</code><code class="p">,</code> <code class="n">count</code> <code class="ow">in</code> <code class="n">wc_mapper</code><code class="p">(</code><code class="n">document</code><code class="p">):</code>&#13;
            <code class="n">collector</code><code class="p">[</code><code class="n">word</code><code class="p">]</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">count</code><code class="p">)</code>&#13;
&#13;
    <code class="k">return</code> <code class="p">[</code><code class="n">output</code>&#13;
            <code class="k">for</code> <code class="n">word</code><code class="p">,</code> <code class="n">counts</code> <code class="ow">in</code> <code class="n">collector</code><code class="o">.</code><code class="n">items</code><code class="p">()</code>&#13;
            <code class="k">for</code> <code class="n">output</code> <code class="ow">in</code> <code class="n">wc_reducer</code><code class="p">(</code><code class="n">word</code><code class="p">,</code> <code class="n">counts</code><code class="p">)]</code></pre>&#13;
&#13;
<p>Imagine that we have three documents <code>["data science", "big data", "science fiction"]</code>.</p>&#13;
&#13;
<p>Then <code>wc_mapper</code> applied to the first document yields the two pairs <code>("data", 1)</code> and <code>("science", 1)</code>.  After we’ve gone through all three documents, the <code>collector</code> contains:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="p">{</code><code class="s2">"data"</code> <code class="p">:</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">],</code>&#13;
 <code class="s2">"science"</code> <code class="p">:</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">],</code>&#13;
 <code class="s2">"big"</code> <code class="p">:</code> <code class="p">[</code><code class="mi">1</code><code class="p">],</code>&#13;
 <code class="s2">"fiction"</code> <code class="p">:</code> <code class="p">[</code><code class="mi">1</code><code class="p">]}</code></pre>&#13;
&#13;
<p>Then <code>wc_reducer</code> produces the counts for each word:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="p">[(</code><code class="s2">"data"</code><code class="p">,</code> <code class="mi">2</code><code class="p">),</code> <code class="p">(</code><code class="s2">"science"</code><code class="p">,</code> <code class="mi">2</code><code class="p">),</code> <code class="p">(</code><code class="s2">"big"</code><code class="p">,</code> <code class="mi">1</code><code class="p">),</code> <code class="p">(</code><code class="s2">"fiction"</code><code class="p">,</code> <code class="mi">1</code><code class="p">)]</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Why MapReduce?" data-type="sect1"><div class="sect1" id="idm45635705111368">&#13;
<h1>Why MapReduce?</h1>&#13;
&#13;
<p>As<a data-primary="MapReduce" data-secondary="benefits of" data-type="indexterm" id="idm45635705118696"/> mentioned earlier, the primary benefit of MapReduce is that it allows us to distribute computations by moving the processing to the data.  Imagine we want to word-count across billions of documents.</p>&#13;
&#13;
<p>Our original (non-MapReduce) approach requires the machine doing the processing to have access to every document.  This means that the documents all need to either live on that machine or else be transferred to it during processing.  More important, it means that the machine can process only one document at a time.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Possibly it can process up to a few at a time if it has multiple cores&#13;
and if the code is rewritten to take advantage of them.  But even so, all the documents&#13;
still have to <em>get to</em> that machine.</p>&#13;
</div>&#13;
&#13;
<p>Imagine now that our billions of documents are scattered across 100 machines.  With the right infrastructure (and glossing over some of the details), we can do the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Have each machine run the mapper on its documents, producing lots of key/value pairs.</p>&#13;
</li>&#13;
<li>&#13;
<p>Distribute those key/value pairs to a number of “reducing” machines, making sure that the pairs corresponding to any given key all end up on the same machine.</p>&#13;
</li>&#13;
<li>&#13;
<p>Have each reducing machine group the pairs by key and then run the reducer on each set of values.</p>&#13;
</li>&#13;
<li>&#13;
<p>Return each (key, output) pair.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>What is amazing about this is that it scales horizontally.  If we double the number of machines, then (ignoring certain fixed costs of running a MapReduce system) our computation should run approximately twice as fast.  Each mapper machine will only need to do half as much work, and (assuming there are enough distinct keys to further distribute the reducer work) the same is true for the reducer machines.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="MapReduce More Generally" data-type="sect1"><div class="sect1" id="idm45635705026744">&#13;
<h1>MapReduce More Generally</h1>&#13;
&#13;
<p>If<a data-primary="MapReduce" data-secondary="generalizing map_reduce function" data-type="indexterm" id="idm45635705025048"/> you think about it for a minute, all of the word count–specific code in the previous example is contained in the <code>wc_mapper</code> and <code>wc_reducer</code> functions.  This means that with a couple of changes we have a much more general framework (that still runs on a single machine).</p>&#13;
&#13;
<p>We could use generic types to fully type-annotate&#13;
our <code>map_reduce</code> function, but it would end up being&#13;
kind of a mess pedagogically, so in this chapter&#13;
we’ll be much more casual about our type annotations:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">Callable</code><code class="p">,</code> <code class="n">Iterable</code><code class="p">,</code> <code class="n">Any</code><code class="p">,</code> <code class="n">Tuple</code>&#13;
&#13;
<code class="c1"># A key/value pair is just a 2-tuple</code>&#13;
<code class="n">KV</code> <code class="o">=</code> <code class="n">Tuple</code><code class="p">[</code><code class="n">Any</code><code class="p">,</code> <code class="n">Any</code><code class="p">]</code>&#13;
&#13;
<code class="c1"># A Mapper is a function that returns an Iterable of key/value pairs</code>&#13;
<code class="n">Mapper</code> <code class="o">=</code> <code class="n">Callable</code><code class="p">[</code><code class="o">...</code><code class="p">,</code> <code class="n">Iterable</code><code class="p">[</code><code class="n">KV</code><code class="p">]]</code>&#13;
&#13;
<code class="c1"># A Reducer is a function that takes a key and an iterable of values</code>&#13;
<code class="c1"># and returns a key/value pair</code>&#13;
<code class="n">Reducer</code> <code class="o">=</code> <code class="n">Callable</code><code class="p">[[</code><code class="n">Any</code><code class="p">,</code> <code class="n">Iterable</code><code class="p">],</code> <code class="n">KV</code><code class="p">]</code></pre>&#13;
&#13;
<p>Now we can write a general <code>map_reduce</code> function:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">def</code> <code class="nf">map_reduce</code><code class="p">(</code><code class="n">inputs</code><code class="p">:</code> <code class="n">Iterable</code><code class="p">,</code>&#13;
               <code class="n">mapper</code><code class="p">:</code> <code class="n">Mapper</code><code class="p">,</code>&#13;
               <code class="n">reducer</code><code class="p">:</code> <code class="n">Reducer</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">List</code><code class="p">[</code><code class="n">KV</code><code class="p">]:</code>&#13;
    <code class="sd">"""Run MapReduce on the inputs using mapper and reducer"""</code>&#13;
    <code class="n">collector</code> <code class="o">=</code> <code class="n">defaultdict</code><code class="p">(</code><code class="nb">list</code><code class="p">)</code>&#13;
&#13;
    <code class="k">for</code> <code class="nb">input</code> <code class="ow">in</code> <code class="n">inputs</code><code class="p">:</code>&#13;
        <code class="k">for</code> <code class="n">key</code><code class="p">,</code> <code class="n">value</code> <code class="ow">in</code> <code class="n">mapper</code><code class="p">(</code><code class="nb">input</code><code class="p">):</code>&#13;
            <code class="n">collector</code><code class="p">[</code><code class="n">key</code><code class="p">]</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">value</code><code class="p">)</code>&#13;
&#13;
    <code class="k">return</code> <code class="p">[</code><code class="n">output</code>&#13;
            <code class="k">for</code> <code class="n">key</code><code class="p">,</code> <code class="n">values</code> <code class="ow">in</code> <code class="n">collector</code><code class="o">.</code><code class="n">items</code><code class="p">()</code>&#13;
            <code class="k">for</code> <code class="n">output</code> <code class="ow">in</code> <code class="n">reducer</code><code class="p">(</code><code class="n">key</code><code class="p">,</code> <code class="n">values</code><code class="p">)]</code></pre>&#13;
&#13;
<p>Then we can count words simply by using:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">word_counts</code> <code class="o">=</code> <code class="n">map_reduce</code><code class="p">(</code><code class="n">documents</code><code class="p">,</code> <code class="n">wc_mapper</code><code class="p">,</code> <code class="n">wc_reducer</code><code class="p">)</code></pre>&#13;
&#13;
<p>This gives us the flexibility to solve a wide variety of problems.</p>&#13;
&#13;
<p>Before we proceed, notice that <code>wc_reducer</code> is just summing the values corresponding to each key.  This kind of aggregation is common enough that it’s worth abstracting it out:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">def</code> <code class="nf">values_reducer</code><code class="p">(</code><code class="n">values_fn</code><code class="p">:</code> <code class="n">Callable</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Reducer</code><code class="p">:</code>&#13;
    <code class="sd">"""Return a reducer that just applies values_fn to its values"""</code>&#13;
    <code class="k">def</code> <code class="nf">reduce</code><code class="p">(</code><code class="n">key</code><code class="p">,</code> <code class="n">values</code><code class="p">:</code> <code class="n">Iterable</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">KV</code><code class="p">:</code>&#13;
        <code class="k">return</code> <code class="p">(</code><code class="n">key</code><code class="p">,</code> <code class="n">values_fn</code><code class="p">(</code><code class="n">values</code><code class="p">))</code>&#13;
&#13;
    <code class="k">return</code> <code class="nb">reduce</code></pre>&#13;
&#13;
<p>After which we can easily create:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">sum_reducer</code> <code class="o">=</code> <code class="n">values_reducer</code><code class="p">(</code><code class="nb">sum</code><code class="p">)</code>&#13;
<code class="n">max_reducer</code> <code class="o">=</code> <code class="n">values_reducer</code><code class="p">(</code><code class="nb">max</code><code class="p">)</code>&#13;
<code class="n">min_reducer</code> <code class="o">=</code> <code class="n">values_reducer</code><code class="p">(</code><code class="nb">min</code><code class="p">)</code>&#13;
<code class="n">count_distinct_reducer</code> <code class="o">=</code> <code class="n">values_reducer</code><code class="p">(</code><code class="k">lambda</code> <code class="n">values</code><code class="p">:</code> <code class="nb">len</code><code class="p">(</code><code class="nb">set</code><code class="p">(</code><code class="n">values</code><code class="p">)))</code>&#13;
&#13;
<code class="k">assert</code> <code class="n">sum_reducer</code><code class="p">(</code><code class="s2">"key"</code><code class="p">,</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code> <code class="o">==</code> <code class="p">(</code><code class="s2">"key"</code><code class="p">,</code> <code class="mi">9</code><code class="p">)</code>&#13;
<code class="k">assert</code> <code class="n">min_reducer</code><code class="p">(</code><code class="s2">"key"</code><code class="p">,</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code> <code class="o">==</code> <code class="p">(</code><code class="s2">"key"</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code>&#13;
<code class="k">assert</code> <code class="n">max_reducer</code><code class="p">(</code><code class="s2">"key"</code><code class="p">,</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code> <code class="o">==</code> <code class="p">(</code><code class="s2">"key"</code><code class="p">,</code> <code class="mi">3</code><code class="p">)</code>&#13;
<code class="k">assert</code> <code class="n">count_distinct_reducer</code><code class="p">(</code><code class="s2">"key"</code><code class="p">,</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code> <code class="o">==</code> <code class="p">(</code><code class="s2">"key"</code><code class="p">,</code> <code class="mi">3</code><code class="p">)</code></pre>&#13;
&#13;
<p>and so on.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Example: Analyzing Status Updates" data-type="sect1"><div class="sect1" id="idm45635705026120">&#13;
<h1>Example: Analyzing Status Updates</h1>&#13;
&#13;
<p>The<a data-primary="MapReduce" data-secondary="analyzing status updates example" data-type="indexterm" id="idm45635704597176"/><a data-primary="status updates, analyzing" data-type="indexterm" id="idm45635704596312"/> content VP was impressed with the word counts and asks what else you can learn from people’s status updates. You manage to extract a dataset of status updates that look like:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">status_updates</code> <code class="o">=</code> <code class="p">[</code>&#13;
    <code class="p">{</code><code class="s2">"id"</code><code class="p">:</code> <code class="mi">2</code><code class="p">,</code>&#13;
     <code class="s2">"username"</code> <code class="p">:</code> <code class="s2">"joelgrus"</code><code class="p">,</code>&#13;
     <code class="s2">"text"</code> <code class="p">:</code> <code class="s2">"Should I write a second edition of my data science book?"</code><code class="p">,</code>&#13;
     <code class="s2">"created_at"</code> <code class="p">:</code> <code class="n">datetime</code><code class="o">.</code><code class="n">datetime</code><code class="p">(</code><code class="mi">2018</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">21</code><code class="p">,</code> <code class="mi">11</code><code class="p">,</code> <code class="mi">47</code><code class="p">,</code> <code class="mi">0</code><code class="p">),</code>&#13;
     <code class="s2">"liked_by"</code> <code class="p">:</code> <code class="p">[</code><code class="s2">"data_guy"</code><code class="p">,</code> <code class="s2">"data_gal"</code><code class="p">,</code> <code class="s2">"mike"</code><code class="p">]</code> <code class="p">},</code>&#13;
     <code class="c1"># ...</code>&#13;
<code class="p">]</code></pre>&#13;
&#13;
<p>Let’s say we need to figure out which day of the week people talk the most about data science.  In order to find this, we’ll just count how many data science updates there are on each day of the week.  This means we’ll need to group by the day of week, so that’s our key.  And if we emit a value of <code>1</code> for each update that contains “data science,” we can simply get the total number using <code>sum</code>:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">def</code> <code class="nf">data_science_day_mapper</code><code class="p">(</code><code class="n">status_update</code><code class="p">:</code> <code class="nb">dict</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Iterable</code><code class="p">:</code>&#13;
    <code class="sd">"""Yields (day_of_week, 1) if status_update contains "data science" """</code>&#13;
    <code class="k">if</code> <code class="s2">"data science"</code> <code class="ow">in</code> <code class="n">status_update</code><code class="p">[</code><code class="s2">"text"</code><code class="p">]</code><code class="o">.</code><code class="n">lower</code><code class="p">():</code>&#13;
        <code class="n">day_of_week</code> <code class="o">=</code> <code class="n">status_update</code><code class="p">[</code><code class="s2">"created_at"</code><code class="p">]</code><code class="o">.</code><code class="n">weekday</code><code class="p">()</code>&#13;
        <code class="k">yield</code> <code class="p">(</code><code class="n">day_of_week</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code>&#13;
&#13;
<code class="n">data_science_days</code> <code class="o">=</code> <code class="n">map_reduce</code><code class="p">(</code><code class="n">status_updates</code><code class="p">,</code>&#13;
                               <code class="n">data_science_day_mapper</code><code class="p">,</code>&#13;
                               <code class="n">sum_reducer</code><code class="p">)</code></pre>&#13;
&#13;
<p>As a slightly more complicated example, imagine we need to find out for each user the most common word that she puts in her status updates.  There are three possible approaches that spring to mind for the <code>mapper</code>:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Put the username in the key; put the words and counts in the values.</p>&#13;
</li>&#13;
<li>&#13;
<p>Put the word in the key; put the usernames and counts in the values.</p>&#13;
</li>&#13;
<li>&#13;
<p>Put the username and word in the key; put the counts in the values.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>If you think about it a bit more, we definitely want to group by <code>username</code>, because we want to consider each person’s words separately.  And we don’t want to group by <code>word</code>, since our reducer will need to see all the words for each person to find out which is the most popular.  This means that the first option is the right choice:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">def</code> <code class="nf">words_per_user_mapper</code><code class="p">(</code><code class="n">status_update</code><code class="p">:</code> <code class="nb">dict</code><code class="p">):</code>&#13;
    <code class="n">user</code> <code class="o">=</code> <code class="n">status_update</code><code class="p">[</code><code class="s2">"username"</code><code class="p">]</code>&#13;
    <code class="k">for</code> <code class="n">word</code> <code class="ow">in</code> <code class="n">tokenize</code><code class="p">(</code><code class="n">status_update</code><code class="p">[</code><code class="s2">"text"</code><code class="p">]):</code>&#13;
        <code class="k">yield</code> <code class="p">(</code><code class="n">user</code><code class="p">,</code> <code class="p">(</code><code class="n">word</code><code class="p">,</code> <code class="mi">1</code><code class="p">))</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">most_popular_word_reducer</code><code class="p">(</code><code class="n">user</code><code class="p">:</code> <code class="nb">str</code><code class="p">,</code>&#13;
                              <code class="n">words_and_counts</code><code class="p">:</code> <code class="n">Iterable</code><code class="p">[</code><code class="n">KV</code><code class="p">]):</code>&#13;
    <code class="sd">"""</code>&#13;
<code class="sd">    Given a sequence of (word, count) pairs,</code>&#13;
<code class="sd">    return the word with the highest total count</code>&#13;
<code class="sd">    """</code>&#13;
    <code class="n">word_counts</code> <code class="o">=</code> <code class="n">Counter</code><code class="p">()</code>&#13;
    <code class="k">for</code> <code class="n">word</code><code class="p">,</code> <code class="n">count</code> <code class="ow">in</code> <code class="n">words_and_counts</code><code class="p">:</code>&#13;
        <code class="n">word_counts</code><code class="p">[</code><code class="n">word</code><code class="p">]</code> <code class="o">+=</code> <code class="n">count</code>&#13;
&#13;
    <code class="n">word</code><code class="p">,</code> <code class="n">count</code> <code class="o">=</code> <code class="n">word_counts</code><code class="o">.</code><code class="n">most_common</code><code class="p">(</code><code class="mi">1</code><code class="p">)[</code><code class="mi">0</code><code class="p">]</code>&#13;
&#13;
    <code class="k">yield</code> <code class="p">(</code><code class="n">user</code><code class="p">,</code> <code class="p">(</code><code class="n">word</code><code class="p">,</code> <code class="n">count</code><code class="p">))</code>&#13;
&#13;
<code class="n">user_words</code> <code class="o">=</code> <code class="n">map_reduce</code><code class="p">(</code><code class="n">status_updates</code><code class="p">,</code>&#13;
                        <code class="n">words_per_user_mapper</code><code class="p">,</code>&#13;
                        <code class="n">most_popular_word_reducer</code><code class="p">)</code></pre>&#13;
&#13;
<p>Or we could find out the number of distinct status-likers for each user:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">def</code> <code class="nf">liker_mapper</code><code class="p">(</code><code class="n">status_update</code><code class="p">:</code> <code class="nb">dict</code><code class="p">):</code>&#13;
    <code class="n">user</code> <code class="o">=</code> <code class="n">status_update</code><code class="p">[</code><code class="s2">"username"</code><code class="p">]</code>&#13;
    <code class="k">for</code> <code class="n">liker</code> <code class="ow">in</code> <code class="n">status_update</code><code class="p">[</code><code class="s2">"liked_by"</code><code class="p">]:</code>&#13;
        <code class="k">yield</code> <code class="p">(</code><code class="n">user</code><code class="p">,</code> <code class="n">liker</code><code class="p">)</code>&#13;
&#13;
<code class="n">distinct_likers_per_user</code> <code class="o">=</code> <code class="n">map_reduce</code><code class="p">(</code><code class="n">status_updates</code><code class="p">,</code>&#13;
                                      <code class="n">liker_mapper</code><code class="p">,</code>&#13;
                                      <code class="n">count_distinct_reducer</code><code class="p">)</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Example: Matrix Multiplication" data-type="sect1"><div class="sect1" id="idm45635704738008">&#13;
<h1>Example: Matrix Multiplication</h1>&#13;
&#13;
<p>Recall<a data-primary="matrix multiplication" data-type="indexterm" id="idm45635704254280"/><a data-primary="MapReduce" data-secondary="matrix multiplication example" data-type="indexterm" id="idm45635704253192"/> from <a data-type="xref" href="ch22.html#matrix_multiplication">“Matrix Multiplication”</a> that given an <code>[n, m]</code> matrix <code>A</code> and an <code>[m, k]</code> matrix <code>B</code>, we can multiply them to form an <code>[n, k]</code> matrix <code>C</code>, where the element of <code>C</code> in row <code>i</code> and column <code>j</code> is given by:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">C</code><code class="p">[</code><code class="n">i</code><code class="p">][</code><code class="n">j</code><code class="p">]</code> <code class="o">=</code> <code class="nb">sum</code><code class="p">(</code><code class="n">A</code><code class="p">[</code><code class="n">i</code><code class="p">][</code><code class="n">x</code><code class="p">]</code> <code class="o">*</code> <code class="n">B</code><code class="p">[</code><code class="n">x</code><code class="p">][</code><code class="n">j</code><code class="p">]</code> <code class="k">for</code> <code class="n">x</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="n">m</code><code class="p">))</code></pre>&#13;
&#13;
<p>This works if we represent our matrices as lists of lists, as we’ve been doing.</p>&#13;
&#13;
<p>But large matrices are sometimes <em>sparse</em>, which means that most of their elements equal 0.  For large sparse matrices, a list of lists can be a very wasteful representation.&#13;
A more compact representation stores only the locations with nonzero values:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">NamedTuple</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">Entry</code><code class="p">(</code><code class="n">NamedTuple</code><code class="p">):</code>&#13;
    <code class="n">name</code><code class="p">:</code> <code class="nb">str</code>&#13;
    <code class="n">i</code><code class="p">:</code> <code class="nb">int</code>&#13;
    <code class="n">j</code><code class="p">:</code> <code class="nb">int</code>&#13;
    <code class="n">value</code><code class="p">:</code> <code class="nb">float</code></pre>&#13;
&#13;
<p>For example,  a 1 billion × 1 billion matrix has 1 <em>quintillion</em> entries, which would not be easy to store on a computer.  But if there are only a few nonzero entries in each row, this alternative representation is many orders of magnitude smaller.</p>&#13;
&#13;
<p>Given this sort of representation, it turns out that we can use MapReduce to&#13;
perform matrix multiplication in a distributed manner.</p>&#13;
&#13;
<p>To motivate our algorithm, notice that each element <code>A[i][j]</code> is only used to compute the elements of <code>C</code> in row <code>i</code>, and each element <code>B[i][j]</code> is only used to compute the elements of <code>C</code> in column <code>j</code>.  Our goal will be for each output of our <code>reducer</code> to be a single entry of <code>C</code>, which means we’ll need our mapper to emit keys identifying a single entry of <code>C</code>.  This suggests the following:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">def</code> <code class="nf">matrix_multiply_mapper</code><code class="p">(</code><code class="n">num_rows_a</code><code class="p">:</code> <code class="nb">int</code><code class="p">,</code> <code class="n">num_cols_b</code><code class="p">:</code> <code class="nb">int</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Mapper</code><code class="p">:</code>&#13;
    <code class="c1"># C[x][y] = A[x][0] * B[0][y] + ... + A[x][m] * B[m][y]</code>&#13;
    <code class="c1">#</code>&#13;
    <code class="c1"># so an element A[i][j] goes into every C[i][y] with coef B[j][y]</code>&#13;
    <code class="c1"># and an element B[i][j] goes into every C[x][j] with coef A[x][i]</code>&#13;
    <code class="k">def</code> <code class="nf">mapper</code><code class="p">(</code><code class="n">entry</code><code class="p">:</code> <code class="n">Entry</code><code class="p">):</code>&#13;
        <code class="k">if</code> <code class="n">entry</code><code class="o">.</code><code class="n">name</code> <code class="o">==</code> <code class="s2">"A"</code><code class="p">:</code>&#13;
            <code class="k">for</code> <code class="n">y</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="n">num_cols_b</code><code class="p">):</code>&#13;
                <code class="n">key</code> <code class="o">=</code> <code class="p">(</code><code class="n">entry</code><code class="o">.</code><code class="n">i</code><code class="p">,</code> <code class="n">y</code><code class="p">)</code>              <code class="c1"># which element of C</code>&#13;
                <code class="n">value</code> <code class="o">=</code> <code class="p">(</code><code class="n">entry</code><code class="o">.</code><code class="n">j</code><code class="p">,</code> <code class="n">entry</code><code class="o">.</code><code class="n">value</code><code class="p">)</code>  <code class="c1"># which entry in the sum</code>&#13;
                <code class="k">yield</code> <code class="p">(</code><code class="n">key</code><code class="p">,</code> <code class="n">value</code><code class="p">)</code>&#13;
        <code class="k">else</code><code class="p">:</code>&#13;
            <code class="k">for</code> <code class="n">x</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="n">num_rows_a</code><code class="p">):</code>&#13;
                <code class="n">key</code> <code class="o">=</code> <code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">entry</code><code class="o">.</code><code class="n">j</code><code class="p">)</code>              <code class="c1"># which element of C</code>&#13;
                <code class="n">value</code> <code class="o">=</code> <code class="p">(</code><code class="n">entry</code><code class="o">.</code><code class="n">i</code><code class="p">,</code> <code class="n">entry</code><code class="o">.</code><code class="n">value</code><code class="p">)</code>  <code class="c1"># which entry in the sum</code>&#13;
                <code class="k">yield</code> <code class="p">(</code><code class="n">key</code><code class="p">,</code> <code class="n">value</code><code class="p">)</code>&#13;
&#13;
    <code class="k">return</code> <code class="n">mapper</code></pre>&#13;
&#13;
<p>And then:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="k">def</code> <code class="nf">matrix_multiply_reducer</code><code class="p">(</code><code class="n">key</code><code class="p">:</code> <code class="n">Tuple</code><code class="p">[</code><code class="nb">int</code><code class="p">,</code> <code class="nb">int</code><code class="p">],</code>&#13;
                            <code class="n">indexed_values</code><code class="p">:</code> <code class="n">Iterable</code><code class="p">[</code><code class="n">Tuple</code><code class="p">[</code><code class="nb">int</code><code class="p">,</code> <code class="nb">int</code><code class="p">]]):</code>&#13;
    <code class="n">results_by_index</code> <code class="o">=</code> <code class="n">defaultdict</code><code class="p">(</code><code class="nb">list</code><code class="p">)</code>&#13;
&#13;
    <code class="k">for</code> <code class="n">index</code><code class="p">,</code> <code class="n">value</code> <code class="ow">in</code> <code class="n">indexed_values</code><code class="p">:</code>&#13;
        <code class="n">results_by_index</code><code class="p">[</code><code class="n">index</code><code class="p">]</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">value</code><code class="p">)</code>&#13;
&#13;
    <code class="c1"># Multiply the values for positions with two values</code>&#13;
    <code class="c1"># (one from A, and one from B) and sum them up.</code>&#13;
    <code class="n">sumproduct</code> <code class="o">=</code> <code class="nb">sum</code><code class="p">(</code><code class="n">values</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">*</code> <code class="n">values</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>&#13;
                     <code class="k">for</code> <code class="n">values</code> <code class="ow">in</code> <code class="n">results_by_index</code><code class="o">.</code><code class="n">values</code><code class="p">()</code>&#13;
                     <code class="k">if</code> <code class="nb">len</code><code class="p">(</code><code class="n">values</code><code class="p">)</code> <code class="o">==</code> <code class="mi">2</code><code class="p">)</code>&#13;
&#13;
    <code class="k">if</code> <code class="n">sumproduct</code> <code class="o">!=</code> <code class="mf">0.0</code><code class="p">:</code>&#13;
        <code class="k">yield</code> <code class="p">(</code><code class="n">key</code><code class="p">,</code> <code class="n">sumproduct</code><code class="p">)</code></pre>&#13;
&#13;
<p>For example, if you had these two matrices:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">A</code> <code class="o">=</code> <code class="p">[[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">0</code><code class="p">],</code>&#13;
     <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">]]</code>&#13;
&#13;
<code class="n">B</code> <code class="o">=</code> <code class="p">[[</code><code class="mi">4</code><code class="p">,</code> <code class="o">-</code><code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">],</code>&#13;
     <code class="p">[</code><code class="mi">10</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">],</code>&#13;
     <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">]]</code></pre>&#13;
&#13;
<p>you could rewrite them as tuples:</p>&#13;
&#13;
<pre data-code-language="py" data-type="programlisting"><code class="n">entries</code> <code class="o">=</code> <code class="p">[</code><code class="n">Entry</code><code class="p">(</code><code class="s2">"A"</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">3</code><code class="p">),</code> <code class="n">Entry</code><code class="p">(</code><code class="s2">"A"</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code>  <code class="mi">2</code><code class="p">),</code> <code class="n">Entry</code><code class="p">(</code><code class="s2">"B"</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">4</code><code class="p">),</code>&#13;
           <code class="n">Entry</code><code class="p">(</code><code class="s2">"B"</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="o">-</code><code class="mi">1</code><code class="p">),</code> <code class="n">Entry</code><code class="p">(</code><code class="s2">"B"</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">10</code><code class="p">)]</code>&#13;
&#13;
&#13;
<code class="n">mapper</code> <code class="o">=</code> <code class="n">matrix_multiply_mapper</code><code class="p">(</code><code class="n">num_rows_a</code><code class="o">=</code><code class="mi">2</code><code class="p">,</code> <code class="n">num_cols_b</code><code class="o">=</code><code class="mi">3</code><code class="p">)</code>&#13;
<code class="n">reducer</code> <code class="o">=</code> <code class="n">matrix_multiply_reducer</code>&#13;
&#13;
<code class="c1"># Product should be [[32, -3, 0], [0, 0, 0]].</code>&#13;
<code class="c1"># So it should have two entries.</code>&#13;
<code class="k">assert</code> <code class="p">(</code><code class="nb">set</code><code class="p">(</code><code class="n">map_reduce</code><code class="p">(</code><code class="n">entries</code><code class="p">,</code> <code class="n">mapper</code><code class="p">,</code> <code class="n">reducer</code><code class="p">))</code> <code class="o">==</code>&#13;
        <code class="p">{((</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">),</code> <code class="o">-</code><code class="mi">3</code><code class="p">),</code> <code class="p">((</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">),</code> <code class="mi">32</code><code class="p">)})</code></pre>&#13;
&#13;
<p>This isn’t terribly interesting on such small matrices,&#13;
but if you had millions of rows and millions of columns, it could help you a lot.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="An Aside: Combiners" data-type="sect1"><div class="sect1" id="idm45635704254872">&#13;
<h1>An Aside: Combiners</h1>&#13;
&#13;
<p>One thing you have probably noticed is that many of our mappers seem to include a bunch of extra information.  For example, when counting words, rather than emitting <code>(word, 1)</code> and summing over the values, we could have emitted <code>(word, None)</code> and just taken the length.</p>&#13;
&#13;
<p>One reason we didn’t do this is that, in the distributed setting, we sometimes want to use <em>combiners</em> to reduce the amount of data that has to be transferred around from machine to machine.  If one of our mapper machines sees the word <em>data</em> 500 times, we can tell it to combine the 500 instances of <code>("data", 1)</code> into a single <code>("data", 500)</code> before handing off to the reducing machine.  This results in a lot less data getting moved around, which can make our algorithm substantially faster still.</p>&#13;
&#13;
<p>Because of the way we wrote our reducer, it would handle this combined data correctly.  (If we’d written it using <code>len</code>, it would not have.)</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="For Further Exploration" data-type="sect1"><div class="sect1" id="idm45635703602232">&#13;
<h1>For Further Exploration</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Like I said, MapReduce feels a lot less popular now than it did when I wrote the first edition. It’s probably not worth investing a ton of your time.</p>&#13;
</li>&#13;
<li>&#13;
<p>That said, the most widely used MapReduce system is <a href="http://hadoop.apache.org">Hadoop</a>.&#13;
There are various commercial and noncommercial distributions and a huge ecosystem of Hadoop-related tools.</p>&#13;
</li>&#13;
<li>&#13;
<p>Amazon.com offers an <a href="http://aws.amazon.com/elasticmapreduce/">Elastic MapReduce</a> service that’s probably easier than setting up your own cluster.</p>&#13;
</li>&#13;
<li>&#13;
<p>Hadoop jobs are typically high-latency, which makes them a poor choice for “real-time” analytics. A popular choice for these workloads is <a href="http://spark.apache.org/">Spark</a>, which can be MapReduce-y.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>