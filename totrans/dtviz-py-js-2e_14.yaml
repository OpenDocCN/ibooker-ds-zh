- en: Chapter 10\. Visualizing Data with Matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a data visualizer, one of the best ways to come to grips with your data is
    to visualize it interactively, using the full range of charts and plots that have
    evolved to summarize and refine datasets. Conventionally, the fruits of this exploratory
    phase are then presented as static figures, but increasingly they are used to
    construct more engaging interactive web-based charts, such as the cool D3 visualizations
    you have probably seen (one of which we’ll be building in [Part V](part05.xhtml#part_viz)).
  prefs: []
  type: TYPE_NORMAL
- en: Python’s Matplotlib and its family of extensions (such as the statistically
    focused seaborn) form a mature and very customizable plotting ecosystem. Matplotlib
    plots can be used interactively by IPython (the Qt and notebook versions), providing
    a very powerful and intuitive way of finding interesting nuggets in your data.
    In this chapter, we’ll introduce Matplotlib and one of its great extensions, seaborn.
  prefs: []
  type: TYPE_NORMAL
- en: pyplot and Object-Oriented Matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Matplotlib can be more than a little confusing, especially if you start randomly
    sampling examples online. The main complicating factor is that there are two main
    ways to create plots, which are similar enough to be confused but different enough
    to lead to a lot of frustrating errors. The first way uses a global state machine
    to interact directly with Matplotlib’s `pyplot` module. The second, object-oriented
    approach uses the more familiar notion of figure and axes classes to provide a
    programmatic alternative. I’ll clarify their differences in the sections ahead,
    but as a rough rule of thumb, if you’re working interactively with single plots,
    `pyplot`’s global state is a convenient shortcut. For all other occasions, it
    makes sense to explicitly declare your figures and axes using the object-oriented
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Starting an Interactive Session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using a [Jupyter notebook](https://jupyter.org) for our interactive
    visualization. Use the following command to start a session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can then use one of the [Matplotlib magic commands](https://oreil.ly/KhWbX)
    within the IPython session to enable interactive Matplotlib. On its own, `%matplotlib`
    will use the default GUI backend to create a plotting window, but you can specify
    the backend directly. The following should work on standard and Qt console IPython:^([1](ch10.xhtml#idm45607769764064))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To get inline graphics in the notebook or Qt console, you can use the `inline`
    directive. Note that with inline plots, you can’t amend them after creation, unlike
    the standalone Matplotlib window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Whether you are using Matplotlib interactively or in Python programs, you’ll
    use similar imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You will find many examples of Matplotlib using `pylab`. `pylab` is a convenience
    module that bulk-imports `matplotlib.pyplot` (for plotting) and NumPy in a single
    namespace. `pylab` is pretty much deprecated now, but even were it not, I’d still
    recommend avoiding this namespace and merging and importing `pyplot` and `numpy`
    explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: While NumPy and pandas are not mandatory, Matplotlib is designed to play well
    with them, handling NumPy arrays and, by association, pandas Series.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ability to create inline plots is key to enjoyable interaction with Matplotlib,
    and we achieve this in IPython with the following “magic”^([2](ch10.xhtml#idm45607769728560))
    injunction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Your Matplotlib plots will now be inserted into your IPython workflow. This
    works with Qt and notebook versions. In notebooks, the plots are incorporated
    into the active cell.
  prefs: []
  type: TYPE_NORMAL
- en: Amending Plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In inline mode, after a Jupyter notebook cell or (multiline) input has been
    run, the drawing context is flushed. This means you cannot change the plot from
    a previous cell or input using the `gcf` (get current figure) method but have
    to repeat all the plot commands with any additions or amendments in a new input/cell.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive Plotting with pyplot’s Global State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pyplot` module provides a global state that you can manipulate interactively.^([3](ch10.xhtml#idm45607769721600))
    This is intended for use in interactive data exploration and is best when you
    are creating simple plots, usually containing single figures. `pyplot` is convenient
    and many of the examples you’ll see use it, but for more complex plotting Matplotlib’s
    object-oriented API (which we’ll see shortly) comes into its own. Before demoing
    use of the global plot, let’s create some random data to display, courtesy of
    pandas’s useful `period_range` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_data_with_matplotlib_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a pandas `datetime` index with 200 day (`d`) elements, starting from
    the current time (`datetime.now()`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_data_with_matplotlib_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Converts `datetime` index to Python `datetimes`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_visualizing_data_with_matplotlib_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates three 200-element random arrays summed along the 0 axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a y-axis with 200 time slots and three random arrays for the complementary
    x values. These are provided as separate arguments to the `(line)plot` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This gives us the not particularly inspiring chart shown in [Figure 10-1](#mpl_3lines_default).
    Note how Matplotlib deals naturally with a multidimensional NumPy line array.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1001](assets/dpj2_1001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1\. Default line plot
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although Matplotlib’s defaults are, by general consensus, less than ideal, one
    of its strengths is the sheer amount of customization you can perform. This is
    why there is a rich ecosystem of chart libraries that wrap Matplotlib with better
    defaults, more attractive color schemes, and more. Let’s see some of this customization
    in action by using vanilla Matplotlib to tailor our default plot.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Matplotlib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Matplotlib provides a wide range of [configurations](https://oreil.ly/IbgVA),
    which can be specified in a [`matplotlibrc` file](https://oreil.ly/knyiZ) or dynamically,
    through the dictionary-like `rcParams` variable. Here we change the width and
    default color of our plot lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can find a sample `matplotlibrc` file at the [main site](https://oreil.ly/LBqxb).
  prefs: []
  type: TYPE_NORMAL
- en: As well as using the `rcParams` variable, you can use the `gcf` (get current
    figure) method to grab the currently active figure and manipulate it directly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see a little example of configuration, setting the current figure’s size.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the Figure’s Size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If your plot’s default readability is poor or the width-to-height ratio suboptimal,
    you will want to change its size. By default, Matplotlib uses inches for its plotting
    size. This makes sense when you consider the many backends (often vector-graphic-based)
    that Matplotlib can save to. Here we show two ways to use `pyplot` to set the
    figure size to eight by four inches, using `rcParams` and `gcf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Points, Not Pixels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Matplotlib uses points, not pixels, to measure the size of its figures. This
    is the accepted measure for print-quality publications, and Matplotlib is used
    to deliver publication-quality images.
  prefs: []
  type: TYPE_NORMAL
- en: By default a point is approximately 1/72 of an inch wide, but Matplotlib allows
    you to adjust this by changing the dots-per-inch (dpi) for any figures generated.
    The higher this number, the better the quality of the image. For the purpose of
    the inline figures shown interactively during IPython sessions, the resolution
    is usually a product of the backend engine being used to generate the plots (e.g.,
    Qt, WxAgg, tkinter). See the [Matplotlib documentation](https://oreil.ly/4ENnG)
    for an explanation of backends.
  prefs: []
  type: TYPE_NORMAL
- en: Labels and Legends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Figure 10-1](#mpl_3lines_default) needs, among other things, to tell us what
    the lines mean. Matplotlib has a handy legend box for line labeling, which, like
    most things Matplotlib, is heavily configurable. Labeling our three lines involves
    a little indirection as the `plot` method only takes one label, which it applies
    to all lines generated. Usefully, the `plot` command returns all `Line2D` objects
    created. These can be used by the `legend` method to set individual labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because this plot will be appearing in black and white (if you’re reading the
    print version of this book), we need a way to distinguish the lines other than
    the default colors. The easiest way to do this with Matplotlib is to create the
    lines sequentially, specifying *x* and *y* values and a line style.^([4](ch10.xhtml#idm45607769467872))
    We’ll make our line styles solid (-), dashed (--), and dash-dotted (-.). Note
    the use of NumPy’s column indexing (see [Figure 7-1](ch07.xhtml#numpy_indexing)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`legend` method](https://oreil.ly/2hEMc) can set labels, suggest a location
    for the legend box, and configure a number of other things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_data_with_matplotlib_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the labels for our three plots.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_data_with_matplotlib_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `best` location should avoid obscuring lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_visualizing_data_with_matplotlib_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the legend’s transparency.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_visualizing_data_with_matplotlib_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Here we adjust the font properties of the legend.^([5](ch10.xhtml#idm45607769227712))
  prefs: []
  type: TYPE_NORMAL
- en: Titles and Axes Labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding a title and label for your axes is as easy as can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can add some text with the `figtext` method:^([6](ch10.xhtml#idm45607769200272))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_data_with_matplotlib_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The location of the text proportionate to figure size.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_data_with_matplotlib_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal (`ha`) and vertical (`va`) alignment.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code is shown in [Example 10-1](#mpl_3lines_custom_code) and the
    resulting chart in [Figure 10-2](#mpl_3lines_custom).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-1\. Customized line chart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_data_with_matplotlib_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This will add a dotted grid to the figure, marking the axis ticks.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_data_with_matplotlib_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The [`tight_layout` method](https://oreil.ly/roH2Z) should guarantee that all
    your plot elements are within the figure box. Otherwise, you might find tick-labels
    or legends truncated.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1002](assets/dpj2_1002.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2\. Customized line chart
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We used the `tight_layout` method in [Example 10-1](#mpl_3lines_custom_code)
    to prevent plot elements from being obscured or truncated. `tight_layout` has
    been known to cause problems with some systems, particularly macOS. If you have
    any problems, this [issue thread](https://oreil.ly/qGONZ) may help. As of now,
    the best advice is to use the `set_tight_layout` method on the current figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Saving Your Charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One area where Matplotlib shines is in saving your plots, providing many output
    formats.^([7](ch10.xhtml#idm45607768868400)) The available formats depend on the
    backends available, but generally PNG, PDF, PS, EPS, and SVG are supported. PNG
    stands for Portable Network Graphics and is the most popular format for distributing
    web images. The other formats are vector-based, which can scale smoothly without
    pixelation artifacts. For high-quality print work, this is probably what you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Saving is as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can set the format explicitly using `format="svg"`, but Matplotlib understands
    the *.svg* suffix. To avoid truncated labels, use the `tight_layout` method.^([8](ch10.xhtml#idm45607768834368))
  prefs: []
  type: TYPE_NORMAL
- en: Figures and Object-Oriented Matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As just shown, interactively manipulating `pyplot`’s global state works fine
    for quick data sketching and single-plot work. However, if you want to have more
    control over your charts, Matplotlib’s figure and axes Object-Oriented (OO) approach
    is the way to go. Most of the more advanced plotting demos you see will be done
    this way.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, with OO Matplotlib we are dealing with a figure, which you can think
    of as a drawing canvas with one or more axes (or plots) embedded in it. Both figures
    and axes have properties that can be independently specified. In this sense, the
    interactive `pyplot` route discussed earlier was plotting to a single axis of
    a global figure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a figure by using `pyplot`’s `figure` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, figures share a subset of properties with the global `pyplot`
    module. These can be set on creation of the figure or through similar methods
    (i.e., `fig.text()` as opposed to `plt.fig_text()`). Each figure can have multiple
    axes, each of which is analogous to the single, global plot state but with the
    considerable advantage that multiple axes can exist on one figure, each with independent
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Axes and Subplots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `figure.add_axes` method allows precise control over the position of axes
    within a figure (e.g., enabling you to embed a smaller plot within the main).
    Positioning of plot elements uses a 0 → 1 coordinate system, where 1 is the width
    or height of the figure. You can specify the position using a four-element list
    or tuple to set bottom-left and top-right bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10-2](#mpl_add_axes_code) shows the code needed to insert smaller
    axes into larger ones, using our random test data. The result is shown in [Figure 10-3](#mpl_add_axes).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-2\. A plot insert with `figure.add_axes`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_data_with_matplotlib_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This selects the first column of our random NumPy y-data.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_data_with_matplotlib_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Removes the x ticks and labels from our embedded plot.
  prefs: []
  type: TYPE_NORMAL
- en: Although `add_axes` gives us a lot of scope for fine-tuning the appearance of
    our charts, most of the time Matplotlib’s built-in grid-layout system makes life
    much easier.^([9](ch10.xhtml#idm45607768572320)) The simplest option is to use
    `figure.subplots`, which allows you to specify row-column layouts of equal-sized
    plots. If you want a grid with different-sized plots, the `gridspec` module is
    your go-to.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1003](assets/dpj2_1003.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-3\. Inserted plot with `figure.add_axes`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Calling `subplots` without arguments returns a figure with single axes. This
    is closest in use to using the `pyplot` state machine shown in [“Interactive Plotting
    with pyplot’s Global State”](#sect_pyplot_global). [Example 10-3](#mpl_3lines_custom_axes_code)
    shows the figure and axes equivalent to the `pyplot` demo in [Example 10-1](#mpl_3lines_custom_code),
    producing the chart in [Figure 10-2](#mpl_3lines_custom). Note the use of “setter”
    methods for figure and axes.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-3\. Plotting with single figure and axes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Calling `subplots` with arguments for number of rows (`nrows`) and columns (`ncols`)
    (as shown in [Example 10-4](#mpl_subplots_code)) allows multiple plots to be placed
    on a grid layout (see the results in [Figure 10-4](#mpl_subplots)). The call to
    `subplots` returns the figure and an array of axes, in row-column order. In the
    example, we specify one column so `axes` is a single array of three stacked axes.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-4\. Using subplots
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_data_with_matplotlib_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies a subplot grid of three rows by one column.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_data_with_matplotlib_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We want to share x- and y-axes, automatically adjusting limits for easy comparison.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_visualizing_data_with_matplotlib_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Switch y to row-column and zip the line data, labels, and line colors together.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_visualizing_data_with_matplotlib_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Labels the last of the shared x-axes.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1004](assets/dpj2_1004.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-4\. Three subplots
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We make use of Python’s handy `zip` method to produce three dictionaries with
    line data. [`zip`](https://oreil.ly/G8YGh) takes lists or tuples of length *n*
    and returns *n* lists, formed by matching the elements by order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the `for` loop, we use `enumerate` to supply an index `i`, which we use to
    select an axis by row, using our zipped `labelled_data` to provide the plot properties.
  prefs: []
  type: TYPE_NORMAL
- en: Note the shared x- and y-axes specified in the `subplots` call in [Example 10-4](#mpl_subplots_code)
    (2). This allows easy comparison of the three charts, particularly on the now
    normalized y-axis. To avoid redundant x labels, we only call `set_xlabel` on the
    last row, using Python’s handy negative indexing.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered the two ways in which IPython and Matplotlib engage interactively,
    using the global state (accessed through `plt`) and the object-oriented API, let’s
    look at a few of the common plot types you’ll use to explore your datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Plot Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As well as the line plot just demonstrated, Matplotlib has a number of plot
    types available. I’ll now demonstrate a few of the ones commonly used in exploratory
    data visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Bar Charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The humble bar chart is a staple for a lot of visual data exploration. As with
    most of Matplotlib charts, there’s a good deal of customization possible. We’ll
    now run through a few variants to give you the gist.
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Example 10-5](#mpl_barchart_code) produces the bar chart in [Figure 10-5](#mpl_barchart).
    Note that you have to specify your own bar and label locations. This kind of flexibility
    is beloved by hardcore Matplotlibbers and is pretty easy to get the hang of. Nevertheless,
    it’s the sort of thing that can get tedious. It’s trivial to write some helper
    methods here, and there are many libraries that wrap Matplotlib and make things
    a little more user-friendly. As we’ll see in [Chapter 11](ch11.xhtml#chapter_pandas_exploring),
    pandas’s built-in Matplotlib-based plots are quite a bit simpler to use.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-5\. A simple bar chart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_data_with_matplotlib_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Here we create the middle bar locations, two `bar_width`’s apart.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_data_with_matplotlib_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We’re hardcoding the x values for demonstration purposes—usually you will want
    to calculate ranges on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_visualizing_data_with_matplotlib_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This places tick labels at the middle of the bars.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1005](assets/dpj2_1005.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-5\. A simple bar chart
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Bar charts with multiple groups are particularly useful. In [Example 10-6](#mpl_barchart_multi_code),
    we add some more country data (for a mythical Barland) and use the `subplots`
    method to produce grouped bar charts (see [Figure 10-6](#mpl_barchart_multi)).
    Once again we specify the bar locations manually, adding two bar groups—this time
    with `ax.bar`. Note that our axes’ x-limits are automatically rescaled in a sensible
    fashion, at increments of 0.5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Use the respective setter methods (`set_xlim`, in this case) if autoscaling
    doesn’t achieve the desired look.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-6\. Creating a grouped bar chart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_data_with_matplotlib_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: With a width of `1` for our two-bar groups, this bar width gives 0.1 bar padding.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_data_with_matplotlib_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib supports standard HTML colors, taking hex values or a name.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_visualizing_data_with_matplotlib_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `pad` argument to specify padding around the figure as a fraction
    of the font size.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_visualizing_data_with_matplotlib_CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This saves the figure at the high resolution of 200 dots per inch.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1006](assets/dpj2_1006.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-6\. Grouped bar charts
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s often useful to use horizontal bars, particularly if there are a lot of
    them and/or you are using tick labels, which are likely to run into one another
    if placed on the same line. Turning [Figure 10-6](#mpl_barchart_multi) on its
    side is easy enough, requiring only that we replace the `bar` method with its
    horizontal counterpart `barh` and switch the axis labels and limits (see [Example 10-7](#mpl_barchart_multi_h_code)
    and the resulting chart [Figure 10-7](#mpl_barchart_multi_h)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-7\. Converting [Example 10-6](#mpl_barchart_multi_code) to horizontal
    bars
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_data_with_matplotlib_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: To create a horizontal bar chart, we use `barh` in place of `bar`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_data_with_matplotlib_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A horizontal chart necessitates swapping the horizontal and vertical axes.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1007](assets/dpj2_1007.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-7\. Turning the bars on their side
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Stacked bars are easy to achieve in Matplotlib.^([10](ch10.xhtml#idm45607767371344))
    [Example 10-8](#mpl_barchart_multi_stack_code) converts [Figure 10-6](#mpl_barchart_multi)
    to a stacked form; [Figure 10-8](#mpl_barchart_multi_stack) shows the result.
    The trick is to use the bottom argument to `bar` to set the bottom of the raised
    bars as the top of the previous group.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-8\. Converting [Example 10-6](#mpl_barchart_multi_code) to stacked
    bars
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_data_with_matplotlib_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `foo_data` and `bar_data` bar groups share the same x-locations.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_data_with_matplotlib_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The bottom of the `bar_data` group is the top of the `foo_data`, providing stacked
    bars.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1008](assets/dpj2_1008.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-8\. Stacked bar chart
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Scatter Plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another useful chart is the scatter plot, which takes 2D arrays of points with
    options for point size, color, and more.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 10-9](#mpl_scatter_code) shows the code for a quick scatter plot,
    using Matplotlib autoscaling for x and y limits. We create a noisy line by adding
    normally distributed random numbers (sigma of 10). [Figure 10-9](#mpl_scatterplot)
    shows the resulting chart.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-9\. A simple scatter plot
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_data_with_matplotlib_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`randn` gives normally distributed random numbers, which we scale to be within
    0 and 10 and to which we then add an x-dependent value.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_data_with_matplotlib_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The equally sized x and y arrays provide the point coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1009](assets/dpj2_1009.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-9\. A simple scatter plot
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can adjust the size and color of individual points by passing an array of
    marker sizes and color indices to the current default colormap. One thing to note,
    which can be confusing, is that we are specifying the area of the markers’ bounding
    boxes, not the circles’ diameters. This means if we want points to double the
    diameter of the circles, we must increase the size by a factor of four.^([11](ch10.xhtml#idm45607767082480))
    In [Example 10-10](#mpl_scatter_sc_code), we add size and color information to
    our simple scatter plot, producing [Figure 10-10](#mpl_scatter_sc).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-10\. Adjusting point size and color
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_data_with_matplotlib_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This produces 100 random color values between 0 and 1 for the default colormap.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_data_with_matplotlib_CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the power notation `**` to square values between 2 and 10, the width
    range for our markers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_visualizing_data_with_matplotlib_CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `alpha` argument to make our markers half-transparent.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1010](assets/dpj2_1010.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-10\. Adjusting point size and color
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Matplotlib Colormaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Matplotlib has a huge variety of colormaps available, the choice of which can
    significantly improve the quality of your visualization. See [the colormap docs](https://oreil.ly/g8Q9b)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a regression line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A regression line is a simple predictive model of the correlation between two
    variables, in this case the x and y coordinates of our scatter plot. The line
    is essentially a best fit through the points of the plot, and adding one to a
    scatter plot is a useful dataviz technique and a good way to demo Matplotlib and
    NumPy interaction.
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 10-11](#mpl_scatter_regression_code) NumPy’s very useful `polyfit`
    function is used to generate the gradient and constant of a best-fit line for
    the points defined by the x and y arrays. We then plot this line on the same axes
    as the scatter plot (see [Figure 10-11](#mpl_scatter_regression)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-11\. Scatter plot with regression line
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_data_with_matplotlib_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use NumPy’s `polyfit` in 1D to get a line gradient (`m`) and constant (`c`)
    for a best-fit line through our random points.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_data_with_matplotlib_CO13-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the gradient and constant to plot a line on the scatter plot’s axes (`y`
    = `mx` + `c`).
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1011](assets/dpj2_1011.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-11\. Scatter plot with regression line
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s generally a good idea to plot confidence intervals when doing line regression.
    This gives an idea of how reliable the line fit is, based on the number and distribution
    of the points. Confidence intervals can be achieved with Matplotlib and NumPy,
    but it is a little awkward. Luckily, there is a library built on Matplotlib that
    has extra, specialized functions for statistical analysis and data visualization
    and, in the opinion of many, looks a lot better than Matplotlib’s defaults. That
    library is seaborn, which we are going to take a quick look at now.
  prefs: []
  type: TYPE_NORMAL
- en: seaborn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of libraries that wrap the powerful plotting abilities of
    Matplotlib in a more user-friendly guise^([12](ch10.xhtml#idm45607766687440))
    and, as important for us data visualizers, play nicely with pandas.
  prefs: []
  type: TYPE_NORMAL
- en: '[Bokeh](https://bokeh.pydata.org/en/latest) is an interactive visualization
    library with the web in mind, producing browser-rendered output and therefore
    playing very nicely with IPython notebook. It’s a great achievement, with a design
    philosophy similar to D3’s.^([13](ch10.xhtml#idm45607766685872))'
  prefs: []
  type: TYPE_NORMAL
- en: But for the kind of interactive, exploratory dataviz necessary to get a feel
    for your data and suggest visualizations, I recommend [seaborn](https://oreil.ly/b2RpH).
    seaborn extends Matplotlib with some powerful statistical plots and is well integrated
    with the PyData stack, playing nicely with NumPy, pandas, and the statistical
    routines found in SciPy and [statsmodels](https://oreil.ly/peqqT).
  prefs: []
  type: TYPE_NORMAL
- en: One of the nice things about seaborn is that it doesn’t hide the Matplotlib
    API, allowing you to tweak your charts with Matplotlib’s extensive tools. In this
    sense, it’s not a replacement for Matplotlib and the relevant skills, but a very
    impressive extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with seaborn, simply extend your standard Matplotlib imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Matplotlib provides a number of plotting styles that can be invoked by calling
    a `use` method with a style key. Let’s set the current style to seaborn’s default,
    which will provide a subtle gray grid to the charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can check out all available styles and their visual effects in the [Matplotlib
    documentation](https://oreil.ly/9RTub).
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of seaborn’s functions are designed to accept a pandas DataFrame, allowing
    you to specify, for example, the column values describing 2D scattered points.
    Let’s take our existing x and y arrays from [Example 10-9](#mpl_scatter_code)
    and use them to make some dummy data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We now have some `data` with columns of x (`'dummy x'`) and y (`'dummy y'`)
    values. [Example 10-12](#mpl_scatter_seaborn_code) demonstrates the use of seaborn’s
    dedicated linear regression plot `lmplot`, which produces the chart in [Figure 10-12](#mpl_scatter_seaborn).
    Note that for some seaborn plots, to adjust figure size we pass a size (height)
    in inches and an aspect ratio (width/height). Note also that seaborn shares `pyplot`’s
    global context.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-12\. Linear regression plot with seaborn
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_data_with_matplotlib_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `x` and `y` arguments specify the column names of the DataFrame data that
    define the coordinates of the plot points.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_data_with_matplotlib_CO14-2)'
  prefs: []
  type: TYPE_NORMAL
- en: To set figure size, we provide the height in inches and an aspect ratio of width/height.
    Here we’ll use a ratio of two to better fit this book’s page format.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_visualizing_data_with_matplotlib_CO14-3)'
  prefs: []
  type: TYPE_NORMAL
- en: seaborn shares the `pyplot` global context, allowing you to save its plots as
    you would Matplotlib’s.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1012](assets/dpj2_1012.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-12\. Linear regression plot with seaborn
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As you would expect from a library that places an emphasis on attractive-looking
    plots, seaborn allows a lot of visual customization. Let’s make a few changes
    to the look of [Figure 10-12](#mpl_scatter_seaborn) and adjust the confidence
    interval to the [standard error](https://oreil.ly/gOLOo) estimate of 68% (see
    [Figure 10-13](#mpl_scatter_seaborn_custom) for the result):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_data_with_matplotlib_CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Provide the scatter plot component’s keyword arguments, setting our points’
    color to slate gray.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_data_with_matplotlib_CO15-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Provide the line plot component’s keyword arguments, setting line width and
    style.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_visualizing_data_with_matplotlib_CO15-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Set the plot markers to diamonds using Matplotlib marker code *D*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_visualizing_data_with_matplotlib_CO15-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We set a confidence interval of 68%, the standard error estimate.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1013](assets/dpj2_1013.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-13\. Customizing the seaborn scatter plot
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: seaborn offers a number of useful plots beyond Matplotlib’s basic set. Let’s
    take a look at one of the most interesting, using seaborn’s FacetGrid to plot
    reflections of multidimensional data.
  prefs: []
  type: TYPE_NORMAL
- en: FacetGrids
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often referred to as “lattice” or “trellis” plotting, the ability to draw multiple
    instances of the same plot on different subsets of your dataset is a good way
    to get a bird’s-eye view of your data. Large amounts of information can be presented
    in one plot, and relationships between the different dimensions can be quickly
    apprehended. This technique is related to the [small multiples](https://oreil.ly/Ck1fT)
    popularized by Edward Tufte.
  prefs: []
  type: TYPE_NORMAL
- en: FacetGrids require the data to be in the form of a pandas DataFrame (see [“The
    DataFrame”](ch08.xhtml#pandas_objects)) and in a form referred to by Hadley Wickham,
    creator of ggplot2, as “tidy,” meaning each column in the DataFrame should be
    a variable and each row an observation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use Tips, one of seaborn’s test datasets,^([14](ch10.xhtml#idm45607766287520))
    to show a FacetGrid in action. Tips is a small set of data showing the distribution
    of tips by various dimensions, such as day of the week or whether the customer
    was a smoker.^([15](ch10.xhtml#idm45607766286048)) First, let’s load our Tips
    dataset into a pandas DataFrame using the `load_dataset` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a FacetGrid, we specify the `tips` DataFrame and a column of interest,
    such as the smoking status of the customer. This column will be used to create
    our plot groups. There are two categories in the smoker column (`''smoker=Yes''`
    and `''smoker=No''`), which means there will be two charts in our facet-grid.
    We then use the grid’s `map` method to create multiple scatter plots of tip size
    against total bill:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_data_with_matplotlib_CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`map` takes a plot class, in this case `scatter`, and two (`tips`) dimensions
    required for this scatter plot.'
  prefs: []
  type: TYPE_NORMAL
- en: This produces the two scatter plots shown in [Figure 10-14](#mpl_facetgrid_1),
    one for each smoker status, with tips and total bills correlated.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1014](assets/dpj2_1014.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-14\. A seaborn FacetGrid using scatter plots
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can include another dimension of the `tips` data by specifying the marker
    to be used in our scatter plots. Let’s make it a red diamond for females and a
    blue square for males:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_data_with_matplotlib_CO17-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Adds a marker color (`hue`) for the `sex` dimension with diamond (`D`) and square
    (`s`) shapes, and uses our color palette (`pal`) to make them red and blue.
  prefs: []
  type: TYPE_NORMAL
- en: You can see the resulting FacetGrid in [Figure 10-15](#mpl_facetgrid_2).
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1015](assets/dpj2_1015.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-15\. Scatter plot with diamond and square markers for sex
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can use rows as well as columns to create subsets of the data by dimension.
    Combining the two allows, with the help of a `regplot`,^([16](ch10.xhtml#idm45607766007680))
    five dimensions to be explored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_data_with_matplotlib_CO18-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Adds a time row to separate tips by lunch and dinner.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-16](#mpl_facetgrid_tips3) shows four `regplot`s producing a linear-regression
    model fit with confidence intervals for female and male hue-groups. The plot titles
    show the data subset being used, each row having the same time and smoker status.'
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1016](assets/dpj2_1016.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-16\. Visualizing five dimensions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can achieve the same effect using the `lmplot` we saw in [Example 10-12](#mpl_scatter_seaborn_code),
    which wraps the functionality of FacetGrid and `regplot` for convenience. The
    following code produces [Figure 10-16](#mpl_facetgrid_tips3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_data_with_matplotlib_CO19-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Note the use of a `markers` keyword as opposed to the `kws_hue` dictionary we
    used with the FacetGrid plot.
  prefs: []
  type: TYPE_NORMAL
- en: '`lmplot` offers a nice shortcut to producing FacetGrid `regplot`s, but FacetGrid’s
    `map` allows you to use the full panoply of seaborn and Matplotlib charts to create
    plots on dimensional subsets. It’s a very powerful technique and a great way to
    drill down into your data.'
  prefs: []
  type: TYPE_NORMAL
- en: PairGrids
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PairGrids are another rather cool seaborn plot type that provide a way to quickly
    assess multidimensional data. Unlike with FacetGrids, you don’t divide the dataset
    into subsets that are then compared by designated dimensions. With PairGrids,
    the dataset’s dimensions are all compared pair-wise in a square grid. By default
    all dimensions are compared, but you can specify which ones get plotted by providing
    a list to the `vars` parameter when declaring the PairGrid.^([17](ch10.xhtml#idm45607765677072))
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s demonstrate the utility of this pair-wise comparison by using the classic
    Iris dataset, showing some vital statistics for a set containing members of three
    Iris species. First, we’ll load the example dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To capture the relationship between petal and sepal dimensions by species,
    we first create a `PairGrid` object, set its hue to `species`, and then use its
    mapping methods to create plots on and off the diagonal of the pair-wise grid,
    producing the charts in [Figure 10-17](#mpl_pairgrid_iris):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_visualizing_data_with_matplotlib_CO20-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Tweaks the font size using seaborn’s `set_theme` method (see [the documentation](https://oreil.ly/rSmrH)
    for the full list of available tweaks).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_visualizing_data_with_matplotlib_CO20-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the markers and subbars to be colored by species.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_visualizing_data_with_matplotlib_CO20-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Places histograms of the species’ dimensions on the grid’s diagonal.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_visualizing_data_with_matplotlib_CO20-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Uses standard scatter plots to compare the dimensions of the diagonal.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1017](assets/dpj2_1017.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-17\. PairGrid summation of Iris measures
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As you can see in [Figure 10-17](#mpl_pairgrid_iris), a few lines of seaborn
    go a long way in creating a richly informative set of plots correlating the different
    Iris metrics. This plot is known as a [scatter-plot matrix](https://oreil.ly/UAJ8T)
    and is a great way of finding linear correlations between pairs of variables in
    a multivariate set. As it stands, there is redundancy in the grid: for example,
    plots for `sepal_width-petal_length` and `petal_length-septal_width`. `PairGrid`
    gives you the opportunity to use the redundant plots above or below the main diagonal
    to provide a different reflection of the data. Check out some of the examples
    [at the seaborn docs](https://stanford.io/1YydS2V) for more info.^([18](ch10.xhtml#idm45607765484192))'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve covered a few of the seaborn plots in this section, and you’ll be seeing
    a few more when we explore our Nobel Prize dataset in the next chapter. But seaborn
    has a lot of other very handy and very powerful plotting tools, mainly of a statistical
    nature. For further investigation, I’d recommend starting with the [main seaborn
    documentation](https://stanford.io/28L8ezk). There are some nice examples, a well-documented
    API, and some good tutorials that should complement what you’ve learned in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced Matplotlib, Python’s plotting powerhouse. It’s a big,
    mature library with lots of documentation and an active community. If you have
    a particular customization in mind, chances are there’s an example out there somewhere.
    I’d recommend firing up a [Jupyter notebook](https://jupyter.org) and playing
    around with a dataset.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how seaborn extends Matplotlib with some useful statistical methods and
    that it has what many consider to be superior aesthetics. It also allows access
    to the Matplotlib figure and axes internals, allowing full customization if required.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll use Matplotlib along with pandas to explore our freshly
    scraped and cleaned Nobel dataset. We’ll use some of the plot types demonstrated
    in this chapter and see a few useful new ones.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch10.xhtml#idm45607769764064-marker)) If you have errors trying to start
    a GUI session, try changing the backend setting (e.g., if using macOS and `%matplotlib
    qt` doesn’t work, try `%matplotlib osx`).
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch10.xhtml#idm45607769728560-marker)) IPython has a large number of such
    functions to enable a whole slew of useful extras to the vanilla Python interpreter.
    Check them out [on the IPython website](https://oreil.ly/0gUSc).
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch10.xhtml#idm45607769721600-marker)) This was inspired by [MATLAB](https://oreil.ly/sw9KZ).
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch10.xhtml#idm45607769467872-marker)) You can find details of Matplotlib’s
    line styles in [its documentation](https://oreil.ly/iqlBE).
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch10.xhtml#idm45607769227712-marker)) See [the docs](https://oreil.ly/upz5A)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch10.xhtml#idm45607769200272-marker)) See [the Matplotlib website](https://oreil.ly/oD0lN)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch10.xhtml#idm45607768868400-marker)) As well as providing many formats,
    it also understands [LaTeX math mode](https://www.latex-project.org), which is
    a language that will allow you to use mathematical symbols in the titles, legends,
    and the like. This is one of the reasons Matplotlib is much beloved by academics,
    as it is quite capable of journal-quality images.
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch10.xhtml#idm45607768834368-marker)) More details are available on the
    [Matplotlib website](https://oreil.ly/GacYP).
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch10.xhtml#idm45607768572320-marker)) The handy `tight_layout` option
    assumes grid-layout subplots.
  prefs: []
  type: TYPE_NORMAL
- en: ^([10](ch10.xhtml#idm45607767371344-marker)) It’s questionable whether stacked
    bar charts are a particularly good way of appreciating groups of data. See [Solomon
    Messing’s blog](https://oreil.ly/nClO0) for a nice discussion and one example
    of “good” use.
  prefs: []
  type: TYPE_NORMAL
- en: ^([11](ch10.xhtml#idm45607767082480-marker)) Setting marker size, rather than
    width or radius, is actually a good default, making it proportional to whatever
    value we are trying to reflect.
  prefs: []
  type: TYPE_NORMAL
- en: ^([12](ch10.xhtml#idm45607766687440-marker)) It’s generally agreed that Matplotlib’s
    defaults aren’t that great and making them better is an easy win for any wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: ^([13](ch10.xhtml#idm45607766685872-marker)) Both D3 and Bokeh tip their hats
    to the classic visualization text, Leland Wilkinson’s *The Grammar of Graphics*
    (Springer).
  prefs: []
  type: TYPE_NORMAL
- en: ^([14](ch10.xhtml#idm45607766287520-marker)) seaborn has a number of handy datasets,
    which you can find [on GitHub](https://oreil.ly/clELR).
  prefs: []
  type: TYPE_NORMAL
- en: ^([15](ch10.xhtml#idm45607766286048-marker)) The Tips dataset uses sex as a
    category, whereas the datasets in this book have used gender. In the past these
    tended to be used interchangeably, but this is no longer the case. See this [Yale
    School of Medicine article](https://oreil.ly/P0zWt) for an explanation.
  prefs: []
  type: TYPE_NORMAL
- en: ^([16](ch10.xhtml#idm45607766007680-marker)) `regplot`, short for regression
    plot, is equivalent to `lmplot`, used in [Example 10-12](#mpl_scatter_seaborn_code).
    The latter combines `regplot` and FacetGrid for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: ^([17](ch10.xhtml#idm45607765677072-marker)) There are also `x_vars` and `y_vars`
    parameters enabling you to specify nonsquare grids.
  prefs: []
  type: TYPE_NORMAL
- en: ^([18](ch10.xhtml#idm45607765484192-marker)) For the curious, there’s a D3 example
    that builds a scatter-plot matrix at the [*bl.ocks.org* site](https://oreil.ly/ox8VW).
  prefs: []
  type: TYPE_NORMAL
