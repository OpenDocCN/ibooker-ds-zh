- en: 'Chapter 4\. Creating the Fibonacci Sequence: Writing, Testing, and Benchmarking
    Algorithms'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing an implementation of the Fibonacci sequence is another step in the
    hero’s journey to becoming a coder. [The Rosalind Fibonacci description](https://oreil.ly/7vkRw)
    notes that the genesis for the sequence was a mathematical simulation of breeding
    rabbits that relies on some important (and unrealistic) assumptions:'
  prefs: []
  type: TYPE_NORMAL
- en: The first month starts with a pair of newborn rabbits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rabbits can reproduce after one month.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every month, every rabbit of reproductive age mates with another rabbit of reproductive
    age.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exactly one month after two rabbits mate, they produce a litter of the same
    size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rabbits are immortal and never stop mating.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sequence always begins with the numbers 0 and 1. The subsequent numbers
    can be generated *ad infinitum* by adding the two immediately previous values
    in the list, as shown in [Figure 4-1](#fig_4.1).
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 0401](assets/mpfb_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. The first eight numbers of the Fibonacci sequence—after the initial
    0 and 1, subsequent numbers are created by adding the two previous numbers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you search the internet for solutions, you’ll find dozens of different ways
    to generate the sequence. I want to focus on three fairly different approaches.
    The first solution uses an *imperative* approach where the algorithm strictly
    defines every step. The next solution uses a *generator* function, and the last
    will focus on a *recursive* solution. Recursion, while interesting, slows drastically
    as I try to generate more of the sequence, but it turns out the performance problems
    can be solved using caching.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to manually validate arguments and throw errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use a list as a stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write a generator function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write a recursive function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why recursive functions can be slow and how to fix this with memoization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use function decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code and tests for this chapter are found in the *04_fib* directory. Start
    by copying the first solution to `fib.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Ask for the usage to see how the parameters are defined. You can use `n` and
    `k`, but I chose to use the names `generations` and `litter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be the first program to accept arguments that are not strings. The
    Rosalind challenge indicates that the program should accept two positive integer
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`n` ≤ 40 representing the number of generations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`k` ≤ 5 representing the litter size produced by mate pairs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Try to pass noninteger values and notice how the program fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can’t tell, but in addition to printing the brief usage and a helpful error
    message, the program also generated a nonzero exit value. On the Unix command
    line, an exit value of `0` indicates success. I think of this as “zero errors.”
    In the `bash` shell, I can inspect the `$?` variable to look at the exit status
    of the most recent process. For instance, the command `echo Hello` should exit
    with a value of `0`, and indeed it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Try the previously failing command again, and then inspect `$?`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That the exit status is `2` is not as important as the fact that the value is
    not zero. This is a well-behaved program because it rejects an invalid argument,
    prints a useful error message, and exits with a nonzero status. If this program
    were part of a pipeline of data processing steps (such as a *Makefile*, discussed
    in [Appendix A](app01.html#app1_makefiles)), a nonzero exit value would cause
    the entire process to stop, which is a good thing. Programs that silently accept
    invalid values and fail quietly or not at all can lead to unreproducible results.
    It’s vitally important that programs properly validate arguments and fail very
    convincingly when they cannot proceed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is very strict even about the type of number it accepts. The values
    must be integers. It will also repel any floating-point values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: All command-line arguments to the program are technically received as strings.
    Even though `5` on the command line looks like the *number* 5, it’s the *character*
    “5”. I am relying on `argparse` in this situation to attempt to convert the value
    from a string to an integer. When that fails, `argparse` generates these useful
    error messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the program rejects values for the `generations` and `litter`
    parameters that are not in the allowed ranges. Notice that the error message includes
    the name of the argument and the offending value to provide sufficient feedback
    to the user so you can fix it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `generations` argument of `-3` is not in the stated range of values.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `litter` argument of `10` is too high.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the first part of the solution to see how to make this work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `generations` field must be an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `litter` field must also be an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `gen` positional parameter is defined first, so it will receive the first
    positional value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `type=int` indicates the required class of the value. Notice that `int`
    indicates the class itself, not the name of the class.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `litter` positional parameter is defined second, so it will receive the
    second positional value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Attempt to parse the arguments. Any failure will result in error messages and
    the program exiting with a nonzero value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The `args.gen` value is now an actual `int` value, so it’s possible to perform
    numeric comparisons on it. Check if it is in the acceptable range.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `parser.error()` function to generate an error and exit the program.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Likewise check the value of the `args.litter` argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](assets/10.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-10)'
  prefs: []
  type: TYPE_NORMAL
- en: Generate an error that includes information the user needs to fix the problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[![11](assets/11.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-11)'
  prefs: []
  type: TYPE_NORMAL
- en: If the program makes it to this point, then the arguments are valid integer
    values in the accepted range, so return the `Args`.
  prefs: []
  type: TYPE_NORMAL
- en: I could check that the `generations` and `litter` values are in the correct
    ranges in the `main()` function, but I prefer to do as much argument validation
    as possible inside the `get_args()` function so that I can use the `parser.error()`
    function to generate useful messages and exit the program with a nonzero value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the `fib.py` program and start anew with **`new.py`** or your preferred
    method for creating a program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can replace the `get_args()` definition with the preceding code, then modify
    your `main()` function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your program with invalid inputs and verify that you see the kinds of error
    messages shown earlier. Try your program with acceptable values and verify that
    you see this kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run **`pytest`** to see what your program passes and fails. You should pass
    the first four tests and fail the fifth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The first failing test. Testing halts here because of the `-x` flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The program is run with `5` for the number of generations and `3` for the litter
    size.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The output should be `19`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This shows the two strings being compared are not equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The expected value was `19`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the output that was received.
  prefs: []
  type: TYPE_NORMAL
- en: The output from `pytest` is trying very hard to point out exactly what went
    wrong. It shows how the program was run and what was expected versus what was
    produced. The program is supposed to print 19, which is the fifth number of the
    Fibonacci sequence when using a litter size of 3. If you want to finish the program
    on your own, please jump right in. You should use **`pytest`** to verify that
    you are passing all the tests. Also, run **`make test`** to check your program
    using `pylint`, `flake8`, and `mypy`. If you want some guidance, I’ll cover the
    first approach I described.
  prefs: []
  type: TYPE_NORMAL
- en: An Imperative Approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Figure 4-2](#fig_4.2) depicts the growth of the Fibonacci sequence. The smaller
    rabbits indicate nonbreeding pairs that must mature into larger, breeding pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 0402](assets/mpfb_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. A visualization of the growth of the Fibonacci sequence as mating
    pairs of rabbits using a litter size of 1
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can see that to generate any number after the first two, I need to know
    the two previous numbers. I can use this formula to describe the value of any
    position *n* of the Fibonacci sequence (*F*):'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F Subscript n Baseline equals upper F Subscript n minus
    1 Baseline plus upper F Subscript n minus 2" display="block"><mrow><msub><mi>F</mi>
    <mi>n</mi></msub> <mo>=</mo> <msub><mi>F</mi> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>F</mi> <mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'What kind of a data structure in Python would allow me to keep a sequence of
    numbers in order and refer to them by their position? A list. I’ll start off with
    *F*[1] = 0 and *F*[2] = 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The *F*[3] value is *F*[2] + *F*[1] = 1 + 0 = 1. When generating the next number,
    I’ll always be referencing the *last two* elements of the sequence. It will be
    easiest to use negative indexing to indicate a position from the *end* of the
    list. The last value in a list is always at position `-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The penultimate value is at `-2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'I need to multiply this value by the litter size to calculate the number of
    offspring that generation created. To start, I’ll consider a litter size of 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'I want to add these two numbers together and append the result to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If I do this again, I can see that the correct sequence is emerging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'I need to repeat this action `generations` times. (Technically it will be `generations`-1
    times because Python uses 0-based indexing.) I can use Python’s `range()` function
    to generate a list of numbers from `0` up to but not including the end value.
    I’m calling this function solely for the side effect of iterating a particular
    number of times and so don’t need the values produced by the `range()` function.
    It’s common to use the underscore (`_`) variable to indicate one’s intent to ignore
    a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This should be enough for you to create a solution that passes the tests. In
    the next section, I’ll cover two other solutions that highlight some very interesting
    parts of Python.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the following solutions share the same `get_args()` shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 1: An Imperative Solution Using a List as a Stack'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is how I wrote my imperative solution. I’m using a list as a kind of *stack*
    to keep track of past values. I don’t need all the values, just the last two,
    but it’s pretty easy to keep growing the list and referring to the last two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Start with `0` and `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `range()` function to create the right number of loops.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Append the next value to the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the last number of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: I used the `_` variable name in the `for` loop to indicate that I don’t intend
    to use the variable. The underscore is a valid Python identifier, and it’s also
    a convention to use this to indicate a *throwaway* value. Linting tools, for instance,
    might see that I’ve assigned a variable some value but never used it, which would
    normally indicate a possible error. The underscore variable shows that I do not
    intend to use the value. In this case, I’m using the `range()` function purely
    for the side effect of creating the number of loops needed.
  prefs: []
  type: TYPE_NORMAL
- en: This is considered an *imperative* solution because the code directly encodes
    every instruction of the algorithm. When you read the recursive solution, you
    will see that the algorithm can be written in a more declarative manner, which
    also has unintended consequences that I must handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'A slight variation on this would be to place this code inside a function I’ll
    call `fib()`. Note that it’s possible in Python to declare a function inside another
    function, as here I’ll create `fib()` inside `main()`. I do this so I can reference
    the `args.litter` parameter, creating a *closure* because the function is capturing
    the runtime value of the litter size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a function called `fib()` that accepts an integer parameter `n` and returns
    an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the same code as before. Note this list is called `nums` so it doesn’t
    clash with the function name.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `range()` function to iterate the generations. Use `_` to ignore the
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The function references the `args.litter` parameter and so creates a closure.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `return` to send the final value back to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO5-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Call the `fib()` function with the `args.generations` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The scope of the `fib()` function in the preceding example is limited to the
    `main()` function. *Scope* refers to the part of the program where a particular
    function name or variable is visible or legal.
  prefs: []
  type: TYPE_NORMAL
- en: 'I don’t have to use a closure. Here is how I can express the same idea with
    a standard function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `fib()` function must be called with two arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The function requires both the number of generations and the litter size. The
    function body is essentially the same.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, you see that I must pass two arguments to `fib()`, whereas
    the closure required only one argument because the `litter` was captured. Binding
    values and reducing the number of parameters is a valid reason for creating a
    closure. Another reason to write a closure is to limit the scope of a function.
    The closure definition of `fib()` is valid only inside the `main()` function,
    but the preceding version is visible throughout the program. Hiding a function
    inside another function makes it harder to test. In this case, the `fib()` function
    is almost the entire program, so the tests have already been written in *tests/fib_test.py*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 2: Creating a Generator Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous solution, I generated the Fibonacci sequence up to the value
    requested and then stopped; however, the sequence is infinite. Could I create
    a function that could generate *all* the numbers of the sequence? Technically,
    yes, but it would never finish, what with being infinite and all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has a way to suspend a function that generates a possibly infinite sequence.
    I can use `yield` to return a value from a function, temporarily leaving the function
    later to resume at the same state when the next value is requested. This kind
    of function is called a *generator*, and here is how I can use it to generate
    the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The type signature indicates the function takes the parameter `k` (litter size),
    which must be an `int`. It returns a special function of the type `Generator`
    which yields `int` values and has no send or return types.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: I only ever need to track the last two generations, which I initialize to `0`
    and `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Yield the `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Create an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO7-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Yield the last generation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO7-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Set `x` (two generations back) to the current generation times the litter size.
    Set `y` (one generation back) to the sum of the two current generations.
  prefs: []
  type: TYPE_NORMAL
- en: A generator acts like an iterator, producing values as requested by the code
    until it is exhausted. Since this generator will only generate yield values, the
    send and return types are `None`. Otherwise, this code does exactly what the first
    version of the program did, only inside a fancy-pants generator function. See
    [Figure 4-3](#fig_4.3) to consider how the function works for two different litter
    sizes.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 0403](assets/mpfb_0403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. A depiction of how the `fib()` generator’s state changes over time
    (`n`=5) for two litter sizes (`k`=1 and `k`=3)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The type signature for `Generator` looks a little complicated since it defines
    types for yield, send, and return. I don’t need to dive into it further here,
    but I recommend you read the docs on [the `typing` module](https://oreil.ly/Oir3d).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `fib()` function takes the litter size as an argument and returns a generator.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `next()` function to retrieve the next value from a generator. Use a
    list comprehension to do this the correct number of times to generate the sequence
    up to the requested value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the last number in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The `range()` is function different because the first version already had the
    `0` and `1` in place. Here I have to call the generator two extra times to produce
    those values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although I prefer the list comprehension, I don’t need the entire list. I only
    care about the final value, so I could have written it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the answer to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create the correct number of loops.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the value for the current generation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it happens, it’s quite common to call a function repeatedly to generate
    a list, so there is a function to do this for us. The `itertools.islice()` function
    will “Make an iterator that returns selected elements from the iterable.” Here
    is how I can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to `islice()` is the function that will be called, and the
    second argument is the number of times to call it. The function is lazy, so I
    use `list()` to coerce the values.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the last value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since I only use the `seq` variable one time, I could eschew that assignment.
    If benchmarking proved the following to be the best-performing version, I might
    be willing to write a one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Clever code is fun but can become unreadable.^([1](ch04.html#idm45963635588216))
    You have been warned.
  prefs: []
  type: TYPE_NORMAL
- en: Generators are cool but more complex than generating a list. They are the appropriate
    way to generate a very large or potentially infinite sequence of values because
    they are lazy, only computing the next value when your code requires it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 3: Using Recursion and Memoization'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While there are many more fun ways to write an algorithm to produce an infinite
    series of numbers, I’ll show just one more using *recursion*, which is when a
    function calls itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Define a function called `fib()` that takes the number of the generation wanted
    as an `int` and returns an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: If the generation is `1` or `2`, return `1`. This is the all-important base
    case that does not make a recursive call.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: For all other cases, call the `fib()` function twice, once for two generations
    back and another for the previous generation. Factor in the litter size as before.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO11-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the results of the `fib()` function for the given generations.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s another instance where I define a `fib()` function as a closure *inside*
    the `main()` function so as to use the `args.litter` value inside the `fib()`
    function. This is to close around `args.litter`, effectively binding that value
    to the function. If I had defined the function outside the `main()` function,
    I would have had to pass the `args.litter` argument on the recursive calls.
  prefs: []
  type: TYPE_NORMAL
- en: This is a really elegant solution that gets taught in pretty much every introductory
    computer science class. It’s fun to study, but it turns out to be wicked slow
    because I end up calling the function so many times. That is, `fib(5)` needs to
    call `fib(4)` and `fib(3)` to add those values. In turn, `fib(4)` needs to call
    `fib(3)` and `fib(2)`, and so on. [Figure 4-4](#fig_4.4) shows that `fib(5)` results
    in 14 function calls to produce 5 distinct values. For instance, `fib(2)` is calculated
    three times, but we only need to calculate it once.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 0404](assets/mpfb_0404.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4\. The call stack for `fib(5)` results in many recursive calls to
    the function, with their number increasing approximately exponentially as the
    input value increases
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To illustrate the problem, I’ll take a sampling of how long this program takes
    to finish up to the maximum `n` of 40. Again, I’ll use a `for` loop in `bash`
    to show you how I would commonly benchmark such a program on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The jump from 0.29s for `n`=`30` to 31s for `n`=`40` is huge. Imagine going
    to 50 and beyond. I need to either find a way to speed this up or abandon all
    hope for recursion. The solution is to cache previously calculated results. This
    is called *memoization*, and there are many ways to implement this. The following
    is one method. Note you will need to import `typing.Callable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Define a function that takes a function (something that is *callable*) and returns
    a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use a dictionary to store cached values.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Define `memo()` as a closure around the cache. The function will take some parameter
    `x` when called.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO12-4)'
  prefs: []
  type: TYPE_NORMAL
- en: See if the argument value is in the cache.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO12-5)'
  prefs: []
  type: TYPE_NORMAL
- en: If not, call the function with the argument and set the cache for that argument
    value to the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO12-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Return the cached value for the argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO12-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Return the new function.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `memoize()` function returns a new function. In Python, functions
    are considered *first-class objects*, meaning they can be used like other kinds
    of variables—you can pass them as arguments and overwrite their definitions. The
    `memoize()` function is an example of a *higher-order function* (HOF) because
    it takes other functions as arguments. I’ll be using other HOFs, like `filter()`
    and `map()`, throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `memoize()` function, I will define `fib()` and then *redefine it*
    with the memoized version. If you run this, you will see an almost instantaneous
    result no matter how high `n` goes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Overwrite the existing `fib()` definition with the memoized function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A preferred method to accomplish this uses a *decorator*, which is a function
    that modifies another function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Decorate the `fib()` function with the `memoize()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'As fun as writing memoization functions is, it again turns out that this is
    such a common need that others have already solved it for us. I can remove the
    `memoize()` function and instead import the `functools.lru_cache` (least-recently-used
    cache) function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Decorate the `fib()` function with the `lru_cache()` function to get memoization
    with minimal distraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Memoize the `fib()` function via decoration with the `lru_cache()` function.
    Note that Python 3.6 requires the parentheses, but 3.8 and later versions do not.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking the Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Which is the fastest solution? I’ve shown you how to use a `for` loop in `bash`
    with the `time` command to compare the runtimes of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It would appear that the recursive solution using LRU caching is the fastest,
    but again I have very little data—just one run per program. Also, I have to eyeball
    this data and figure out which is the fastest.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a better way. I have installed a tool called [`hyperfine`](https://oreil.ly/shqOS)
    to run each command many times and compare the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It appears that `hyperfine` ran each command 60-66 times, averaged the results,
    and found that the `solution3_recursion_lru_cache.py` program is perhaps slightly
    faster. Another benchmarking tool you might find useful is [`bench`](https://oreil.ly/FKnmd),
    but you can search for other benchmarking tools on the internet that might suit
    your tastes more. Whatever tool you use, benchmarking along with testing is vital
    to challenging assumptions about your code.
  prefs: []
  type: TYPE_NORMAL
- en: I used the `--prepare` option to tell `hyperfine` to remove the *pycache* directory
    before running the commands. This is a directory created by Python to cache *bytecode*
    of the program. If a program’s source code hasn’t changed since the last time
    it was run, then Python can skip compilation and use the bytecode version that
    exists in the *pycache* directory. I needed to remove this as `hyperfine` detected
    statistical outliers when running the commands, probably due to caching effects.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Good, the Bad, and the Ugly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For every challenge, I hope you spend part of your time reading through the
    tests. Learning how to design and write tests is as important as anything else
    I’m showing you. As I mentioned before, my first tests check that the expected
    program exists and will produce usage statements on request. After that, I usually
    give invalid inputs to ensure the program fails. I would like to highlight the
    tests for bad `n` and `k` parameters. They are essentially the same, so I’ll just
    show the first one as it demonstrates how to randomly select an invalid integer
    value—one that is possibly negative or too high:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Join the two lists of invalid number ranges and randomly select one value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO16-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Select a random integer in the range from `1` to `5` (both bounds inclusive).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO16-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Run the program with the arguments and capture the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO16-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the program reported a failure (nonzero exit value).
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO16-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Check the output begins with a usage statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO16-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Look for an error message describing the problem with the `n` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'I often like to use randomly selected invalid values when testing. This partially
    comes from writing tests for students so that they won’t write programs that fail
    on a single bad input, but I also find it helps me to not accidentally code for
    a specific input value. I haven’t yet covered the `random` module, but it gives
    you a way to make pseudorandom choices. First, you need to import the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, you can use `random.randint()` to select a single integer from
    a given range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Or use the `random.choice()` function to randomly select a single value from
    some sequence. Here I wanted to construct a discontiguous range of negative numbers
    separated from a range of positive numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The tests that follow all provide good inputs to the program. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO17-1)'
  prefs: []
  type: TYPE_NORMAL
- en: These are values I was given while attempting to solve the Rosalind challenge.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO17-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The program should not fail on this input.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO17-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the correct answer per Rosalind.
  prefs: []
  type: TYPE_NORMAL
- en: Testing, like documentation, is a love letter to your future self. As tedious
    as testing may seem, you’ll appreciate failing tests when you try to add a feature
    and end up accidentally breaking something that previously worked. Assiduously
    writing and running tests can prevent you from deploying broken programs.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Test Suite on All the Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ve seen that in each chapter I write multiple solutions to explore various
    ways to solve the problems. I completely rely on my tests to ensure my programs
    are correct. You might be curious to see how I’ve automated the process of testing
    every single solution. Look at the *Makefile* and find the `all` target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `all_test.py` program will overwrite the `fib.py` program with each of the
    solutions before running the test suite. This could overwrite your solution. Be
    sure you commit your version to Git or at least make a copy before you run `make
    all` or you could lose your work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `all_test.py` program that is run by the `all` target.
    I’ll break it into two parts, starting with the first part up to `get_args()`.
    Most of this should be familiar by now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO18-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the program to test, which in this case is `fib.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO18-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A Boolean value of `True` or `False` to create more or less output.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO18-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The default type is `str`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO18-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `action='store_true'` makes this a Boolean flag. If the flag is present
    the value will be `True`, and it will be `False` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main()` function is where the testing happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the current working directory, which will be the *04_fib* directory if you
    are in that directory when running the command.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Find all the `solution*.py` files in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Both `filter()` and `partial()` are HOFs; I’ll explain them next.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The filenames will be in random order, so iterate through the sorted files.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `solution*.py` file to the testing filename.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Make the program executable.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `make test` command, and capture the return value and output.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-8)'
  prefs: []
  type: TYPE_NORMAL
- en: See if the return value is not `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Exit this program while printing the output from the testing and returning a
    nonzero value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](assets/10.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-10)'
  prefs: []
  type: TYPE_NORMAL
- en: Unless the program is supposed to be quiet, print the testing output.
  prefs: []
  type: TYPE_NORMAL
- en: '[![11](assets/11.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-11)'
  prefs: []
  type: TYPE_NORMAL
- en: Let the user know the program finishes normally.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, I’m using `sys.exit()` to immediately halt the program,
    print an error message, and return a nonzero exit value. If you consult the documentation,
    you’ll find you can invoke `sys.exit()` with no arguments, an integer value, or
    a object like a string, which is what I’m using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding program also uses the functions `filter()` or `partial()`, which
    I haven’t covered yet. Both of these are HOFs. I’ll explain how and why I’m using
    them. To start, the `os.listdir()` function will return the entire contents of
    a directory, including files and directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s a lot there, so I’ll import the `pprint()` function from the `pprint`
    module to *pretty-print* this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: I want to filter those to names that start with *solution* and end with *.py*.
    On the command line, I would match this pattern using a *file glob* like `solution*.py`,
    where the `*` means *zero or more of any character* and the `.` is a literal dot.
    A regular expression version of this pattern is the slightly more complicated
    `solution.*\.py`, where `.` (dot) is a regex metacharacter representing *any character*,
    and `*` (star or asterisk) means *zero or more* (see [Figure 4-5](#fig_4.5)).
    To indicate a literal dot, I need to escape it with a backslash (`\.`). Note that
    it’s prudent to use the r-string (*raw* string) to enclose this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 0405](assets/mpfb_0405.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-5\. A regular expression to find files matching the file glob `solution*.py`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When the match is successful, a `re.Match` object is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'When a match fails, the `None` value is returned. I have to use `type()` here
    because the `None` value is not displayed in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'I want to apply this match to all the files returned by `os.listdir()`. I can
    use `filter()` and the `lambda` keyword to create an *anonymous* function. Each
    filename in `files` is passed as the `name` argument used in the match. The `filter()`
    function will only return elements that return a truthy value from the given function,
    so those filenames that return `None` when they fail to match are excluded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You see that the `re.match()` function takes two arguments—a pattern and a
    string to match. The `partial()` function allows me to *partially apply* the function,
    and the result is a new function. For example, the `operator.add()` function expects
    two values and returns their sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'I can create a function that adds `1` to any value, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `succ()` function requires one argument, and will return the successor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, I can create a function `f()` that partially applies the `re.match()`
    function with its first argument, a regular expression pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `f()` function is waiting for a string to apply the match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If you call it without an argument, you will get an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'I can replace the `lambda` with the partially applied function as the first
    argument to `filter()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: My programming style leans heavily on purely functional programming ideas. I
    find this style to be like playing with LEGO bricks—small, well-defined, and tested
    functions can be composed into larger programs that work well.
  prefs: []
  type: TYPE_NORMAL
- en: Going Further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many different styles of programming, such as procedural, functional,
    object-oriented, and so forth. Even within an object-oriented language like Python,
    I can use very different approaches to writing code. The first solution could
    be considered a *dynamic programming* approach because you try to solve the larger
    problem by first solving smaller problems. If you find recursive functions interesting,
    the Tower of Hanoi problem is another classic exercise. Purely functional languages
    like Haskell mostly avoid constructs like `for` loops and rely heavily on recursion
    and higher-order functions. Both spoken and programming languages shape the way
    we think, and I encourage you to try solving this problem using other languages
    you know to see how you might write different solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Key points from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `get_args()` function, you can perform manual validation of arguments
    and use the `parser.error()` function to manually generate `argparse` errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use a list as a stack by pushing and popping elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `yield` in a function turns it into a generator. When the function yields
    a value, the value is returned and the state of the function is preserved until
    the next value is requested. Generators can be used to create a potentially infinite
    stream of values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A recursive function calls itself, and the recursion can cause serious performance
    issues. One solution is to use memoization to cache values and avoid recomputation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions are functions that take other functions as arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python’s function decorators apply HOFs to other functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarking is an important technique for determining the best-performing algorithm.
    The `hyperfine` and `bench` tools allow you to compare runtimes of commands over
    many iterations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `random` module offers many functions for the pseudorandom selection of
    values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch04.html#idm45963635588216-marker)) As the legendary David St. Hubbins
    and Nigel Tufnel observed, “It’s such a fine line between stupid and clever.”
  prefs: []
  type: TYPE_NORMAL
