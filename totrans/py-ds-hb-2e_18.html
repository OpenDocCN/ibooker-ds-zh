<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 15. Operating on Data in Pandas" data-type="chapter" epub:type="chapter"><div class="chapter" id="section-0303-operations-in-pandas">
<h1><span class="label">Chapter 15. </span>Operating on Data in Pandas</h1>
<p><a data-primary="Pandas" data-secondary="operating on data in" data-type="indexterm" id="ix_ch15-asciidoc0"/><a data-primary="universal functions (ufuncs)" data-secondary="operating on data in Pandas" data-type="indexterm" id="ix_ch15-asciidoc1"/>One of the strengths of NumPy is that it allows us to perform quick
element-wise operations, both with basic arithmetic (addition,
subtraction, multiplication, etc.) and with more complicated operations
(trigonometric functions, exponential and logarithmic functions, etc.).
Pandas inherits much of this functionality from NumPy, and the ufuncs
introduced in <a data-type="xref" href="ch06.xhtml#section-0203-computation-on-arrays-ufuncs">Chapter 6</a> are key to this.</p>
<p>Pandas includes a couple of useful twists, however: for unary operations
like negation and trigonometric functions, these ufuncs will <em>preserve
index and column labels</em> in the output, and for binary operations such
as addition and multiplication, Pandas will automatically <em>align
indices</em> when passing the objects to the ufunc. This means that keeping
the context of data and combining data from different sources—both
potentially error-prone tasks with raw NumPy arrays—become essentially
foolproof with Pandas. We will additionally see that there are
well-defined operations between one-dimensional <code>Series</code> structures and
two-dimensional <code>DataFrame</code> structures.</p>
<section data-pdf-bookmark="Ufuncs: Index Preservation" data-type="sect1"><div class="sect1" id="ch_0303-operations-in-pandas_ufuncs-index-preservation">
<h1>Ufuncs: Index Preservation</h1>
<p><a data-primary="universal functions (ufuncs)" data-secondary="index preservation" data-type="indexterm" id="idm45858787996336"/>Because Pandas is designed to work with NumPy, any NumPy ufunc will work
on Pandas <code>Series</code> and <code>DataFrame</code> objects. Let’s start by
defining a simple <code>Series</code> and <code>DataFrame</code> on which to demonstrate this:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>
        <code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="n">rng</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">default_rng</code><code class="p">(</code><code class="mi">42</code><code class="p">)</code>
        <code class="n">ser</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">(</code><code class="n">rng</code><code class="o">.</code><code class="n">integers</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">4</code><code class="p">))</code>
        <code class="n">ser</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="mi">0</code>    <code class="mi">0</code>
        <code class="mi">1</code>    <code class="mi">7</code>
        <code class="mi">2</code>    <code class="mi">6</code>
        <code class="mi">3</code>    <code class="mi">4</code>
        <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="n">df</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code><code class="n">rng</code><code class="o">.</code><code class="n">integers</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">)),</code>
                          <code class="n">columns</code><code class="o">=</code><code class="p">[</code><code class="s1">'A'</code><code class="p">,</code> <code class="s1">'B'</code><code class="p">,</code> <code class="s1">'C'</code><code class="p">,</code> <code class="s1">'D'</code><code class="p">])</code>
        <code class="n">df</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">3</code><code class="p">]:</code>    <code class="n">A</code>  <code class="n">B</code>  <code class="n">C</code>  <code class="n">D</code>
        <code class="mi">0</code>  <code class="mi">4</code>  <code class="mi">8</code>  <code class="mi">0</code>  <code class="mi">6</code>
        <code class="mi">1</code>  <code class="mi">2</code>  <code class="mi">0</code>  <code class="mi">5</code>  <code class="mi">9</code>
        <code class="mi">2</code>  <code class="mi">7</code>  <code class="mi">7</code>  <code class="mi">7</code>  <code class="mi">7</code></pre>
<p>If we apply a NumPy ufunc on either of these objects, the result will be
another Pandas object <em>with the indices preserved:</em></p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">exp</code><code class="p">(</code><code class="n">ser</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="mi">0</code>       <code class="mf">1.000000</code>
        <code class="mi">1</code>    <code class="mf">1096.633158</code>
        <code class="mi">2</code>     <code class="mf">403.428793</code>
        <code class="mi">3</code>      <code class="mf">54.598150</code>
        <code class="n">dtype</code><code class="p">:</code> <code class="n">float64</code></pre>
<p>This is true also for more involved sequences of operations:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">sin</code><code class="p">(</code><code class="n">df</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">pi</code> <code class="o">/</code> <code class="mi">4</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">5</code><code class="p">]:</code>               <code class="n">A</code>             <code class="n">B</code>         <code class="n">C</code>         <code class="n">D</code>
        <code class="mi">0</code>  <code class="mf">1.224647e-16</code> <code class="o">-</code><code class="mf">2.449294e-16</code>  <code class="mf">0.000000</code> <code class="o">-</code><code class="mf">1.000000</code>
        <code class="mi">1</code>  <code class="mf">1.000000e+00</code>  <code class="mf">0.000000e+00</code> <code class="o">-</code><code class="mf">0.707107</code>  <code class="mf">0.707107</code>
        <code class="mi">2</code> <code class="o">-</code><code class="mf">7.071068e-01</code> <code class="o">-</code><code class="mf">7.071068e-01</code> <code class="o">-</code><code class="mf">0.707107</code> <code class="o">-</code><code class="mf">0.707107</code></pre>
<p>Any of the ufuncs discussed in
<a data-type="xref" href="ch06.xhtml#section-0203-computation-on-arrays-ufuncs">Chapter 6</a> can be used in a similar manner.</p>
</div></section>
<section data-pdf-bookmark="Ufuncs: Index Alignment" data-type="sect1"><div class="sect1" id="ch_0303-operations-in-pandas_ufuncs-index-alignment">
<h1>Ufuncs: Index Alignment</h1>
<p><a data-primary="universal functions (ufuncs)" data-secondary="index alignment" data-type="indexterm" id="ix_ch15-asciidoc2"/>For binary operations on two <code>Series</code> or <code>DataFrame</code> objects, Pandas
will align indices in the process of performing the operation. This is
very convenient when working with incomplete data, as we’ll
see in some of the examples that follow.</p>
<section data-pdf-bookmark="Index Alignment in Series" data-type="sect2"><div class="sect2" id="ch_0303-operations-in-pandas_index-alignment-in-series">
<h2>Index Alignment in Series</h2>
<p><a data-primary="index alignment" data-secondary="in Series" data-type="indexterm" id="idm45858787645184"/><a data-primary="Series object (Pandas)" data-secondary="index alignment in" data-type="indexterm" id="idm45858787644208"/>As an example, suppose we are combining two different data sources and
wish to find only the top three US states by <em>area</em> and the top three US
states by <em>population</em>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">area</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">({</code><code class="s1">'Alaska'</code><code class="p">:</code> <code class="mi">1723337</code><code class="p">,</code> <code class="s1">'Texas'</code><code class="p">:</code> <code class="mi">695662</code><code class="p">,</code>
                          <code class="s1">'California'</code><code class="p">:</code> <code class="mi">423967</code><code class="p">},</code> <code class="n">name</code><code class="o">=</code><code class="s1">'area'</code><code class="p">)</code>
        <code class="n">population</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">({</code><code class="s1">'California'</code><code class="p">:</code> <code class="mi">39538223</code><code class="p">,</code> <code class="s1">'Texas'</code><code class="p">:</code> <code class="mi">29145505</code><code class="p">,</code>
                                <code class="s1">'Florida'</code><code class="p">:</code> <code class="mi">21538187</code><code class="p">},</code> <code class="n">name</code><code class="o">=</code><code class="s1">'population'</code><code class="p">)</code></pre>
<p>Let’s see what happens when we divide these to compute the
population density:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">population</code> <code class="o">/</code> <code class="n">area</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">Alaska</code>              <code class="n">NaN</code>
        <code class="n">California</code>    <code class="mf">93.257784</code>
        <code class="n">Florida</code>             <code class="n">NaN</code>
        <code class="n">Texas</code>         <code class="mf">41.896072</code>
        <code class="n">dtype</code><code class="p">:</code> <code class="n">float64</code></pre>
<p>The resulting array contains the <em>union</em> of indices of the two input
arrays, which could be determined directly from these indices:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">area</code><code class="o">.</code><code class="n">index</code><code class="o">.</code><code class="n">union</code><code class="p">(</code><code class="n">population</code><code class="o">.</code><code class="n">index</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">Index</code><code class="p">([</code><code class="s1">'Alaska'</code><code class="p">,</code> <code class="s1">'California'</code><code class="p">,</code> <code class="s1">'Florida'</code><code class="p">,</code> <code class="s1">'Texas'</code><code class="p">],</code> <code class="n">dtype</code><code class="o">=</code><code class="s1">'object'</code><code class="p">)</code></pre>
<p><a data-primary="NaN (Not a Number) value" data-type="indexterm" id="idm45858787489392"/>Any item for which one or the other does not have an entry is marked
with <code>NaN</code>, or “Not a Number,” which is how Pandas marks missing data
(see further discussion of missing data in
<a data-type="xref" href="ch16.xhtml#section-0304-missing-values">Chapter 16</a>). This index
matching is implemented this way for any of Python’s
built-in arithmetic expressions; any missing values are marked by <code>NaN</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">A</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">([</code><code class="mi">2</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">6</code><code class="p">],</code> <code class="n">index</code><code class="o">=</code><code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">])</code>
        <code class="n">B</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">5</code><code class="p">],</code> <code class="n">index</code><code class="o">=</code><code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code>
        <code class="n">A</code> <code class="o">+</code> <code class="n">B</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="mi">0</code>    <code class="n">NaN</code>
        <code class="mi">1</code>    <code class="mf">5.0</code>
        <code class="mi">2</code>    <code class="mf">9.0</code>
        <code class="mi">3</code>    <code class="n">NaN</code>
        <code class="n">dtype</code><code class="p">:</code> <code class="n">float64</code></pre>
<p>If using <code>NaN</code> values is not the desired behavior, the fill value can be
modified using appropriate object methods in place of the operators. For
example, calling <code>A.add(B)</code> is equivalent to calling <code>A + B</code>, but allows
optional explicit specification of the fill value for any elements in
<code>A</code> or <code>B</code> that might be missing:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">A</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">B</code><code class="p">,</code> <code class="n">fill_value</code><code class="o">=</code><code class="mi">0</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="mi">0</code>    <code class="mf">2.0</code>
         <code class="mi">1</code>    <code class="mf">5.0</code>
         <code class="mi">2</code>    <code class="mf">9.0</code>
         <code class="mi">3</code>    <code class="mf">5.0</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">float64</code></pre>
</div></section>
<section data-pdf-bookmark="Index Alignment in DataFrames" data-type="sect2"><div class="sect2" id="ch_0303-operations-in-pandas_index-alignment-in-dataframes">
<h2>Index Alignment in DataFrames</h2>
<p><a data-primary="DataFrame object (Pandas)" data-secondary="index alignment in" data-type="indexterm" id="idm45858787289216"/><a data-primary="index alignment" data-secondary="in DataFrame" data-type="indexterm" id="idm45858787288336"/>A similar type of alignment takes place for <em>both</em> columns and indices
when performing operations on <code>DataFrame</code> objects:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">A</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code><code class="n">rng</code><code class="o">.</code><code class="n">integers</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">20</code><code class="p">,</code> <code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="mi">2</code><code class="p">)),</code>
                          <code class="n">columns</code><code class="o">=</code><code class="p">[</code><code class="s1">'a'</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">])</code>
         <code class="n">A</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">11</code><code class="p">]:</code>     <code class="n">a</code>  <code class="n">b</code>
         <code class="mi">0</code>  <code class="mi">10</code>  <code class="mi">2</code>
         <code class="mi">1</code>  <code class="mi">16</code>  <code class="mi">9</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="n">B</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code><code class="n">rng</code><code class="o">.</code><code class="n">integers</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="mi">3</code><code class="p">)),</code>
                          <code class="n">columns</code><code class="o">=</code><code class="p">[</code><code class="s1">'b'</code><code class="p">,</code> <code class="s1">'a'</code><code class="p">,</code> <code class="s1">'c'</code><code class="p">])</code>
         <code class="n">B</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">12</code><code class="p">]:</code>    <code class="n">b</code>  <code class="n">a</code>  <code class="n">c</code>
         <code class="mi">0</code>  <code class="mi">5</code>  <code class="mi">3</code>  <code class="mi">1</code>
         <code class="mi">1</code>  <code class="mi">9</code>  <code class="mi">7</code>  <code class="mi">6</code>
         <code class="mi">2</code>  <code class="mi">4</code>  <code class="mi">8</code>  <code class="mi">5</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="n">A</code> <code class="o">+</code> <code class="n">B</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">12</code><code class="p">]:</code>       <code class="n">a</code>     <code class="n">b</code>   <code class="n">c</code>
         <code class="mi">0</code>  <code class="mf">13.0</code>   <code class="mf">7.0</code> <code class="n">NaN</code>
         <code class="mi">1</code>  <code class="mf">23.0</code>  <code class="mf">18.0</code> <code class="n">NaN</code>
         <code class="mi">2</code>   <code class="n">NaN</code>   <code class="n">NaN</code> <code class="n">NaN</code></pre>
<p>Notice that indices are aligned correctly irrespective of their order in
the two objects, and indices in the result are sorted. As was the case
with <code>Series</code>, we can use the associated object’s arithmetic
methods and pass any desired <code>fill_value</code> to be used in place of missing
entries. Here we’ll fill with the mean of all values in <code>A</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="n">A</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">B</code><code class="p">,</code> <code class="n">fill_value</code><code class="o">=</code><code class="n">A</code><code class="o">.</code><code class="n">values</code><code class="o">.</code><code class="n">mean</code><code class="p">())</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">14</code><code class="p">]:</code>        <code class="n">a</code>      <code class="n">b</code>      <code class="n">c</code>
         <code class="mi">0</code>  <code class="mf">13.00</code>   <code class="mf">7.00</code>  <code class="mf">10.25</code>
         <code class="mi">1</code>  <code class="mf">23.00</code>  <code class="mf">18.00</code>  <code class="mf">15.25</code>
         <code class="mi">2</code>  <code class="mf">17.25</code>  <code class="mf">13.25</code>  <code class="mf">14.25</code></pre>
<p><a data-type="xref" href="#table-15-1">Table 15-1</a> lists Python operators and their equivalent Pandas
object 
<span class="keep-together">methods</span>.<a data-startref="ix_ch15-asciidoc2" data-type="indexterm" id="idm45858787020864"/></p>
<table id="table-15-1">
<caption><span class="label">Table 15-1. </span>Mapping between Python operators and Pandas methods</caption>
<thead>
<tr>
<th>Python operator</th>
<th>Pandas method(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>+</code></p></td>
<td><p><code>add</code></p></td>
</tr>
<tr>
<td><p><code>-</code></p></td>
<td><p><code>sub</code>, <code>subtract</code></p></td>
</tr>
<tr>
<td><p><code>*</code></p></td>
<td><p><code>mul</code>, <code>multiply</code></p></td>
</tr>
<tr>
<td><p><code>/</code></p></td>
<td><p><code>truediv</code>, <code>div</code>, <code>divide</code></p></td>
</tr>
<tr>
<td><p><code>//</code></p></td>
<td><p><code>floordiv</code></p></td>
</tr>
<tr>
<td><p><code>%</code></p></td>
<td><p><code>mod</code></p></td>
</tr>
<tr>
<td><p><code>**</code></p></td>
<td><p><code>pow</code></p></td>
</tr>
</tbody>
</table>
</div></section>
</div></section>
<section data-pdf-bookmark="Ufuncs: Operations Between DataFrames and Series" data-type="sect1"><div class="sect1" id="ch_0303-operations-in-pandas_ufuncs-operations-between-dataframes-and-series">
<h1>Ufuncs: Operations Between DataFrames and Series</h1>
<p><a data-primary="DataFrame object (Pandas)" data-secondary="operations between Series object and" data-type="indexterm" id="idm45858786978928"/><a data-primary="Series object (Pandas)" data-secondary="operations between DataFrame and" data-type="indexterm" id="idm45858786978016"/><a data-primary="universal functions (ufuncs)" data-secondary="operations between DataFrame and Series" data-type="indexterm" id="idm45858786977104"/>When performing operations between a <code>DataFrame</code> and a <code>Series</code>, the
index and column alignment is similarly maintained, and the result is
similar to operations between a two-dimensional and one-dimensional
NumPy array. Consider one common operation, where we find the difference
of a two-dimensional array and one of its rows:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="n">A</code> <code class="o">=</code> <code class="n">rng</code><code class="o">.</code><code class="n">integers</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code> <code class="n">size</code><code class="o">=</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">))</code>
         <code class="n">A</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mi">4</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">0</code><code class="p">],</code>
                <code class="p">[</code><code class="mi">5</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">8</code><code class="p">],</code>
                <code class="p">[</code><code class="mi">8</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">1</code><code class="p">]])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="n">A</code> <code class="o">-</code> <code class="n">A</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code> <code class="mi">0</code><code class="p">,</code>  <code class="mi">0</code><code class="p">,</code>  <code class="mi">0</code><code class="p">,</code>  <code class="mi">0</code><code class="p">],</code>
                <code class="p">[</code> <code class="mi">1</code><code class="p">,</code>  <code class="mi">4</code><code class="p">,</code> <code class="o">-</code><code class="mi">2</code><code class="p">,</code>  <code class="mi">8</code><code class="p">],</code>
                <code class="p">[</code> <code class="mi">4</code><code class="p">,</code> <code class="o">-</code><code class="mi">2</code><code class="p">,</code>  <code class="mi">4</code><code class="p">,</code>  <code class="mi">1</code><code class="p">]])</code></pre>
<p>According to NumPy’s broadcasting rules (see
<a data-type="xref" href="ch08.xhtml#section-0205-computation-on-arrays-broadcasting">Chapter 8</a>), subtraction between a two-dimensional array and
one of its rows is applied row-wise.</p>
<p>In Pandas, the convention similarly operates row-wise by default:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="n">df</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code><code class="n">A</code><code class="p">,</code> <code class="n">columns</code><code class="o">=</code><code class="p">[</code><code class="s1">'Q'</code><code class="p">,</code> <code class="s1">'R'</code><code class="p">,</code> <code class="s1">'S'</code><code class="p">,</code> <code class="s1">'T'</code><code class="p">])</code>
         <code class="n">df</code> <code class="o">-</code> <code class="n">df</code><code class="o">.</code><code class="n">iloc</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">17</code><code class="p">]:</code>    <code class="n">Q</code>  <code class="n">R</code>  <code class="n">S</code>  <code class="n">T</code>
         <code class="mi">0</code>  <code class="mi">0</code>  <code class="mi">0</code>  <code class="mi">0</code>  <code class="mi">0</code>
         <code class="mi">1</code>  <code class="mi">1</code>  <code class="mi">4</code> <code class="o">-</code><code class="mi">2</code>  <code class="mi">8</code>
         <code class="mi">2</code>  <code class="mi">4</code> <code class="o">-</code><code class="mi">2</code>  <code class="mi">4</code>  <code class="mi">1</code></pre>
<p>If you would instead like to operate column-wise, you can use the object
methods mentioned earlier, while specifying the <code>axis</code> keyword:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">18</code><code class="p">]:</code> <code class="n">df</code><code class="o">.</code><code class="n">subtract</code><code class="p">(</code><code class="n">df</code><code class="p">[</code><code class="s1">'R'</code><code class="p">],</code> <code class="n">axis</code><code class="o">=</code><code class="mi">0</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">18</code><code class="p">]:</code>    <code class="n">Q</code>  <code class="n">R</code>  <code class="n">S</code>  <code class="n">T</code>
         <code class="mi">0</code>  <code class="mi">0</code>  <code class="mi">0</code> <code class="o">-</code><code class="mi">2</code> <code class="o">-</code><code class="mi">4</code>
         <code class="mi">1</code> <code class="o">-</code><code class="mi">3</code>  <code class="mi">0</code> <code class="o">-</code><code class="mi">8</code>  <code class="mi">0</code>
         <code class="mi">2</code>  <code class="mi">6</code>  <code class="mi">0</code>  <code class="mi">4</code> <code class="o">-</code><code class="mi">1</code></pre>
<p>Note that these <code>DataFrame</code>/<code>Series</code> operations, like the operations
discussed previously, will automatically align indices between the two
elements:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">19</code><code class="p">]:</code> <code class="n">halfrow</code> <code class="o">=</code> <code class="n">df</code><code class="o">.</code><code class="n">iloc</code><code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="p">::</code><code class="mi">2</code><code class="p">]</code>
         <code class="n">halfrow</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">19</code><code class="p">]:</code> <code class="n">Q</code>    <code class="mi">4</code>
         <code class="n">S</code>    <code class="mi">2</code>
         <code class="n">Name</code><code class="p">:</code> <code class="mi">0</code><code class="p">,</code> <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">20</code><code class="p">]:</code> <code class="n">df</code> <code class="o">-</code> <code class="n">halfrow</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">20</code><code class="p">]:</code>      <code class="n">Q</code>   <code class="n">R</code>    <code class="n">S</code>   <code class="n">T</code>
         <code class="mi">0</code>  <code class="mf">0.0</code> <code class="n">NaN</code>  <code class="mf">0.0</code> <code class="n">NaN</code>
         <code class="mi">1</code>  <code class="mf">1.0</code> <code class="n">NaN</code> <code class="o">-</code><code class="mf">2.0</code> <code class="n">NaN</code>
         <code class="mi">2</code>  <code class="mf">4.0</code> <code class="n">NaN</code>  <code class="mf">4.0</code> <code class="n">NaN</code></pre>
<p>This preservation and alignment of indices and columns means that
operations on data in Pandas will always maintain the data context,
which prevents the common errors that might arise when working with
heterogeneous and/or misaligned data in raw NumPy arrays.<a data-startref="ix_ch15-asciidoc1" data-type="indexterm" id="idm45858786552864"/><a data-startref="ix_ch15-asciidoc0" data-type="indexterm" id="idm45858786535296"/></p>
</div></section>
</div></section></div></body></html>