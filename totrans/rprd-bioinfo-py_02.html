<html><head></head><body><section data-pdf-bookmark="Chapter 1. Tetranucleotide Frequency: Counting Things" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch01">&#13;
<h1><span class="label">Chapter 1. </span>Tetranucleotide Frequency: <span class="keep-together">Counting Things</span></h1>&#13;
&#13;
&#13;
<p>Counting the bases in DNA is perhaps the “Hello, World!” of bioinformatics.<a data-primary="Hello World of bioinformatics" data-seealso="tetranucleotide frequency" data-type="indexterm" id="idm45963636772936"/><a data-primary="tetranucleotide frequency" data-secondary="about" data-type="indexterm" id="idm45963637142024"/><a data-primary="DNA" data-secondary="tetranucleotide frequency" data-see="tetranucleotide frequency" data-type="indexterm" id="idm45963637141064"/><a data-primary="nucleotide counts" data-see="GC content determination; open reading frames; tetranucleotide frequency" data-type="indexterm" id="idm45963637139816"/><a data-primary="counting things in strings" data-secondary="tetranucleotides" data-see="tetranucleotide frequency" data-type="indexterm" id="idm45963637138904"/><a data-primary="counting things in strings" data-secondary="GC content" data-see="GC content determination" data-type="indexterm" id="idm45963637137656"/>&#13;
<a href="https://oreil.ly/maR31">The Rosalind DNA challenge</a> describes a program that will take a sequence of DNA and print a count of how many <em>A</em>s, <em>C</em>s, <em>G</em>s, and <em>T</em>s are found.&#13;
There are surprisingly many ways to count things in Python, and I’ll explore what the language has to offer.&#13;
I’ll also demonstrate how to write a well-structured, documented program that validates its arguments as well as how to write and run tests to ensure the program works <span class="keep-together">correctly</span>.</p>&#13;
&#13;
<p>In this chapter, you’ll learn:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>How to start a new program using <code>new.py</code></p>&#13;
</li>&#13;
<li>&#13;
<p>How to define and validate command-line arguments using <code>argparse</code></p>&#13;
</li>&#13;
<li>&#13;
<p>How to run a test suite using <code>pytest</code></p>&#13;
</li>&#13;
<li>&#13;
<p>How to iterate the characters of a string</p>&#13;
</li>&#13;
<li>&#13;
<p>Ways to count elements in a collection</p>&#13;
</li>&#13;
<li>&#13;
<p>How to create a decision tree using <code>if</code>/<code>elif</code> statements</p>&#13;
</li>&#13;
<li>&#13;
<p>How to format strings</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before" data-pdf-bookmark="Getting Started" data-type="sect1"><div class="sect1" id="idm45963637123592">&#13;
<h1>Getting Started</h1>&#13;
&#13;
<p>Before you start, be sure you have read <a data-type="xref" href="preface01.html#gettingCodeandTests">“Getting the Code and Tests”</a> in the Preface.&#13;
Once you have a local copy of the code repository, change into the <em>01_dna</em> directory:<a data-primary="tetranucleotide frequency" data-secondary="getting started" data-type="indexterm" id="idm45963637120744"/></p>&#13;
&#13;
<pre data-type="programlisting">$ cd 01_dna</pre>&#13;
&#13;
<p>Here you’ll find several <code>solution*.py</code> programs along with tests and input data you can use to see if the programs work correctly.&#13;
To get an idea of how your program should work, start by copying the first solution to a program called <code>dna.py</code>:</p>&#13;
&#13;
<pre data-type="programlisting">$ cp solution1_iter.py dna.py</pre>&#13;
&#13;
<p>Now run the program with no arguments, or with the <code>-h</code> or <code>--help</code> flags.&#13;
It will print usage documentation (note that <em>usage</em> is the first word of the output):<a data-primary="documentation" data-secondary="program providing" data-type="indexterm" id="ch01-doc"/><a data-primary="reproducible programs" data-secondary="documentation provided by programs" data-type="indexterm" id="ch01-doc2"/><a data-primary="best practices" data-secondary="documentation provided by programs" data-type="indexterm" id="ch01-doc3"/><a data-primary="tetranucleotide frequency" data-secondary="documentation provided by programs" data-type="indexterm" id="ch01-doc4"/></p>&#13;
&#13;
<pre data-type="programlisting">$ ./dna.py&#13;
usage: dna.py [-h] DNA&#13;
dna.py: error: the following arguments are required: DNA</pre>&#13;
<div data-type="tip">&#13;
<p>If you get an error like “permission denied,” you <a data-primary="errors" data-secondary="permission denied" data-type="indexterm" id="idm45963637108152"/><a data-primary="permission denied" data-type="indexterm" id="idm45963637107208"/>may need to run <strong><code>chmod +x dna.py</code></strong> to change the mode of the program by adding the executable bit.</p>&#13;
</div>&#13;
&#13;
<p>This is one of the first elements of reproducibility.&#13;
<em>Programs should provide documentation on how they work.</em>&#13;
While it’s common to have something like a <em>README</em> file or even a paper to describe a program, the program itself must provide documentation on its parameters and outputs.&#13;
I’ll show you how to use the <code>argparse</code> module to define and validate the arguments as well as to generate the documentation, meaning that there is no possibility that the usage statement generated by the program could be incorrect.&#13;
Contrast this with how <em>README</em> files and change logs and the like can quickly fall out of sync with a program’s development, and I hope you’ll appreciate that this sort of documentation is quite effective.</p>&#13;
&#13;
<p>You can see from the usage line that the program expects something like <code>DNA</code> as an argument, so let’s give it a sequence.<a data-primary="input for program" data-secondary="command line or file" data-type="indexterm" id="idm45963637101928"/><a data-primary="tetranucleotide frequency" data-secondary="input for program" data-type="indexterm" id="idm45963637100984"/>&#13;
As described on the Rosalind page, the program prints the counts for each of the bases <em>A</em>, <em>C</em>, <em>G</em>, and <em>T</em>, in that order and separated by a single space each:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./dna.py ACCGGGTTTT&#13;
1 2 3 4</pre>&#13;
&#13;
<p>When you go to solve a challenge on the Rosalind.info website, the input for your program<a data-primary="Rosalind.info challenges" data-secondary="input for program" data-type="indexterm" id="idm45963637096696"/><a data-primary="input for program" data-secondary="Rosalind.info website" data-type="indexterm" id="idm45963637095736"/> will be provided as a downloaded file; therefore, I’ll write the program so that it will also read the contents of a file.&#13;
I can use the command <strong><code>cat</code></strong> (for <em>concatenate</em>) to print the contents of one of the files in the <em>tests/inputs</em> directory:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat tests/inputs/input2.txt&#13;
AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC</pre>&#13;
&#13;
<p>This is the same sequence shown in the example on the website.&#13;
Accordingly, I know that the output of the program should be this:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./dna.py tests/inputs/input2.txt&#13;
20 12 17 21</pre>&#13;
&#13;
<p>Throughout the book, I’ll use the <code>pytest</code> tool to run the tests that ensure programs work as expected.<a data-primary="pytest tool" data-secondary="about" data-type="indexterm" id="idm45963636864440"/><a data-primary="test-driven development (TDD)" data-secondary="pytest tool" data-type="indexterm" id="idm45963636863496"/><a data-primary="pytest tool" data-secondary="tetranucleotide frequency" data-type="indexterm" id="idm45963636862536"/><a data-primary="tetranucleotide frequency" data-secondary="testing" data-tertiary="pytest" data-type="indexterm" id="idm45963636861576"/>&#13;
When I run the command <strong><code>pytest</code></strong>, it will recursively search the current directory for tests and functions that look like tests.&#13;
Note that you may need to run <strong><code>python3 -m pytest</code></strong> or <strong><code>pytest.exe</code></strong> if you are on Windows.&#13;
Run this now, and you should see something like the following to indicate that the program passes all four of the tests found in the <em>tests/dna_test.py</em> file:</p>&#13;
&#13;
<pre data-type="programlisting">$ pytest&#13;
=========================== test session starts ===========================&#13;
...&#13;
collected 4 items&#13;
&#13;
tests/dna_test.py ....                                              [100%]&#13;
&#13;
============================ 4 passed in 0.41s ============================</pre>&#13;
<div data-type="note" epub:type="note">&#13;
<p>A key element to testing software is that you <em>run your program with known inputs and verify that it produces the correct output</em>.<a data-primary="test-driven development (TDD)" data-secondary="known inputs to verify outputs" data-type="indexterm" id="idm45963636855320"/>&#13;
While that may seem like an obvious idea, I’ve had to object to “testing” schemes that simply ran programs but never verified that they behaved correctly.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating the Program Using new.py" data-type="sect2"><div class="sect2" id="idm45963636853720">&#13;
<h2>Creating the Program Using new.py</h2>&#13;
&#13;
<p>If you copied one of the solutions, as shown in the preceding section, then delete that program so you can start from scratch:<a data-primary="tetranucleotide frequency" data-secondary="creating program via new.py" data-type="indexterm" id="ch01-new"/><a data-primary="new.py for new Python programs" data-secondary="creating program using" data-type="indexterm" id="ch01-new2"/></p>&#13;
&#13;
<pre data-type="programlisting">$ rm dna.py</pre>&#13;
&#13;
<p>Without looking at my solutions yet, I want you to try to solve this problem.&#13;
If you think you have all the information you need, feel free to jump ahead and write your own version of <code>dna.py</code>, using <code>pytest</code> to run the provided tests.&#13;
Keep reading if you want to go step-by-step with me to learn how to write the program and run the tests.</p>&#13;
&#13;
<p>Every program in this book will accept some command-line argument(s) and create some output, like text on the command line or new files.<a data-primary="new.py for new Python programs" data-secondary="about the process" data-type="indexterm" id="idm45963636846888"/><a data-primary="arguments" data-secondary="new.py for new Python programs" data-type="indexterm" id="idm45963636845928"/><a data-primary="arguments" data-secondary="tetranucleotide frequency" data-type="indexterm" id="ch01-thng"/><a data-primary="best practices" data-secondary="arguments defined" data-type="indexterm" id="idm45963636843736"/><a data-primary="reproducible programs" data-secondary="arguments defined" data-type="indexterm" id="idm45963636842792"/><a data-primary="Python" data-secondary="creating programs with new.py" data-type="indexterm" id="idm45963636841848"/><a data-primary="Python" data-secondary="downloading Python" data-tertiary="new.py for new programs" data-type="indexterm" id="idm45963636840888"/><a data-primary="installation" data-secondary="new.py for new programs" data-type="indexterm" id="idm45963636839672"/>&#13;
I’ll always use the <code>new.py</code> program described in the Preface to start, but this is not a requirement.&#13;
You can write your programs however you like, starting from whatever point you want, but your programs are expected to have the same features, such as generating usage statements and properly validating arguments.</p>&#13;
&#13;
<p>Create your <code>dna.py</code> program in the <em>01_dna</em> directory, as this contains the test files for the program.&#13;
Here is how I will start the <code>dna.py</code> program.&#13;
The <code>--purpose</code> argument will be used in the program’s documentation:</p>&#13;
&#13;
<pre data-type="programlisting">$ new.py --purpose 'Tetranucleotide frequency' dna.py&#13;
Done, see new script "dna.py."</pre>&#13;
&#13;
<p>If you run the new <code>dna.py</code> program, you will see that it defines many different types of arguments common to command-line programs:<a data-primary="strings (str)" data-secondary="arguments" data-type="indexterm" id="idm45963636833880"/></p>&#13;
&#13;
<pre data-type="programlisting">$ ./dna.py --help&#13;
usage: dna.py [-h] [-a str] [-i int] [-f FILE] [-o] str&#13;
&#13;
Tetranucleotide frequency <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
positional arguments:&#13;
  str                   A positional argument <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-2"><img alt="2" src="assets/2.png"/></a>&#13;
&#13;
optional arguments:&#13;
  -h, --help            show this help message and exit <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-3" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-3"><img alt="3" src="assets/3.png"/></a>&#13;
  -a str, --arg str     A named string argument (default: ) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-4" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-4"><img alt="4" src="assets/4.png"/></a>&#13;
  -i int, --int int     A named integer argument (default: 0) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-5" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-5"><img alt="5" src="assets/5.png"/></a>&#13;
  -f FILE, --file FILE  A readable file (default: None) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-6" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-6"><img alt="6" src="assets/6.png"/></a>&#13;
  -o, --on              A boolean flag (default: False) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-7" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-7"><img alt="7" src="assets/7.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The <code>--purpose</code> from <code>new.py</code> is used here to describe the program.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The program accepts a single positional string argument.<a data-primary="arguments" data-secondary="positional" data-type="indexterm" id="idm45963636813512"/><a data-primary="arguments" data-secondary="optional" data-type="indexterm" id="idm45963636812568"/></p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-3" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The <code>-h</code> and <code>--help</code> flags are automatically added by <code>argparse</code> and will trigger the usage.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-4" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>This is a named option with short (<code>-a</code>) and long (<code>--arg</code>) names for a string value.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-5" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>This is a named option with short (<code>-i</code>) and long (<code>--int</code>) names for an integer value.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-6" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>This is a named option with short (<code>-f</code>) and long (<code>--file</code>) names for a file <span class="keep-together">argument.</span></p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-7" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>This is a Boolean flag that will be <code>True</code> when either <code>-o</code> or <code>--on</code> is present and <code>False</code> when they are absent.</p></dd>&#13;
</dl>&#13;
&#13;
<p>This program only needs the <code>str</code> positional argument, and you can use <code>DNA</code> for the <code>metavar</code> value to give some indication to the user as to the meaning of the argument.&#13;
Delete all the other parameters.&#13;
Note that you never define the <code>-h</code> and <code>--help</code> flags, as <code>argparse</code> uses those internally to respond to usage requests.<a data-primary="new.py for new Python programs" data-secondary="argparse" data-tertiary="-h and --help flags" data-tertiary-sortas="h and help flags" data-type="indexterm" id="idm45963632886424"/><a data-primary="argparse" data-secondary="-h and --help flags" data-secondary-sortas="h and help flags" data-type="indexterm" id="idm45963632884920"/><a data-primary="help" data-secondary="argparse -h and --help flags" data-type="indexterm" id="idm45963632883704"/>&#13;
See if you can modify your program until it will produce the usage that follows&#13;
(if you can’t produce the usage just yet, don’t worry, I’ll show this in the next section):</p>&#13;
&#13;
<pre data-type="programlisting">$ ./dna.py -h&#13;
usage: dna.py [-h] DNA&#13;
&#13;
Tetranucleotide frequency&#13;
&#13;
positional arguments:&#13;
  DNA         Input DNA sequence&#13;
&#13;
optional arguments:&#13;
  -h, --help  show this help message and exit</pre>&#13;
&#13;
<p>If you can manage to get this working, I’d like to point out that this program will accept exactly one positional argument.&#13;
If you try running it with any other number of arguments, the program will immediately halt and print an error message:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./dna.py AACC GGTT&#13;
usage: dna.py [-h] DNA&#13;
dna.py: error: unrecognized arguments: GGTT</pre>&#13;
&#13;
<p>Likewise, the program will reject any unknown flags or options.&#13;
With very few lines of code, you have built a documented program that validates the arguments to the program.<a data-startref="ch01-doc" data-type="indexterm" id="idm45963632879560"/>&#13;
That’s a very basic and important step toward reproducibility.<a data-startref="ch01-new" data-type="indexterm" id="idm45963632878760"/><a data-startref="ch01-new2" data-type="indexterm" id="idm45963632878088"/><a data-startref="ch01-doc2" data-type="indexterm" id="idm45963632877416"/><a data-startref="ch01-doc3" data-type="indexterm" id="idm45963632876744"/><a data-startref="ch01-doc4" data-type="indexterm" id="idm45963632876072"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using argparse" data-type="sect2"><div class="sect2" id="idm45963632875080">&#13;
<h2>Using argparse</h2>&#13;
&#13;
<p>The program created by <code>new.py</code> uses the <code>argparse</code> module to define the program’s parameters, validate that the arguments are correct, and create the usage documentation for the user.<a data-primary="argparse" data-secondary="about" data-type="indexterm" id="idm45963632872776"/><a data-primary="argparse" data-secondary="using" data-type="indexterm" id="ch01-arg"/><a data-primary="new.py for new Python programs" data-secondary="argparse" data-tertiary="using" data-type="indexterm" id="ch01-arg2"/><a data-primary="tetranucleotide frequency" data-secondary="argparse" data-type="indexterm" id="ch01-arg3"/><a data-primary="arguments" data-secondary="new.py for new Python programs" data-tertiary="argparse" data-type="indexterm" id="ch01-arg4"/>&#13;
The <code>argparse</code> module is a <em>standard</em> Python module, which means it’s always present.<a data-primary="Python" data-secondary="argparse a standard module" data-type="indexterm" id="idm45963632865288"/>&#13;
Other modules can also do these things, and you are free to use any method you like to handle this aspect of your program.&#13;
Just be sure your programs can pass the tests.</p>&#13;
&#13;
<p>I wrote a version of <code>new.py</code> for <em>Tiny Python Projects</em> that you can find in <a href="https://oreil.ly/7romb">the <em>bin</em> directory of that book’s GitHub repo</a>.<a data-primary="new.py for new Python programs" data-secondary="simpler version to start" data-type="indexterm" id="idm45963632861480"/>&#13;
That version is somewhat simpler than the version I want you to use.&#13;
I’ll start by showing you a version of <code>dna.py</code> created using this earlier version of <code>new.py</code>:<a data-primary="#! (shebang)" data-primary-sortas="# shebang" data-type="indexterm" id="idm45963632859336"/><a data-primary="shebang (#!)" data-type="indexterm" id="idm45963632858392"/><a data-primary="environment variables" data-secondary="shebang (#!)" data-type="indexterm" id="idm45963632857720"/><a data-primary="Python" data-secondary="shebang (#!) for execution" data-type="indexterm" id="idm45963632856776"/><a data-primary="main() function" data-type="indexterm" id="idm45963632855816"/><a data-primary="functions" data-secondary="main()" data-type="indexterm" id="idm45963632855144"/><a data-primary="arguments" data-secondary="get_args() called by main()" data-type="indexterm" id="idm45963632854200"/><a data-primary="get_args()" data-secondary="main() calling" data-type="indexterm" id="idm45963632853240"/><a data-primary="functions" data-secondary="get_args()" data-seealso="get_args()" data-type="indexterm" id="idm45963632852296"/></p>&#13;
&#13;
<pre data-type="programlisting">#!/usr/bin/env python3 <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-1"><img alt="1" src="assets/1.png"/></a>&#13;
""" Tetranucleotide frequency """ <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-2"><img alt="2" src="assets/2.png"/></a>&#13;
&#13;
import argparse <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-3" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-3"><img alt="3" src="assets/3.png"/></a>&#13;
&#13;
&#13;
# --------------------------------------------------&#13;
def get_args(): <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-4" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-4"><img alt="4" src="assets/4.png"/></a>&#13;
    """ Get command-line arguments """ <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-5" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-5"><img alt="5" src="assets/5.png"/></a>&#13;
&#13;
    parser = argparse.ArgumentParser( <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-6" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-6"><img alt="6" src="assets/6.png"/></a>&#13;
        description='Tetranucleotide frequency',&#13;
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)&#13;
&#13;
    parser.add_argument('dna', metavar='DNA', help='Input DNA sequence') <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-7" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-7"><img alt="7" src="assets/7.png"/></a>&#13;
&#13;
    return parser.parse_args() <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-8" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-8"><img alt="8" src="assets/8.png"/></a>&#13;
&#13;
&#13;
# --------------------------------------------------&#13;
def main(): <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-9" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-9"><img alt="9" src="assets/9.png"/></a>&#13;
    """ Make a jazz noise here """&#13;
&#13;
    args = get_args() <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-10" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-10"><img alt="10" src="assets/10.png"/></a>&#13;
    print(args.dna)   <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-11" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-11"><img alt="11" src="assets/11.png"/></a>&#13;
&#13;
&#13;
# --------------------------------------------------&#13;
if __name__ == '__main__': <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-12" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-12"><img alt="12" src="assets/12.png"/></a>&#13;
    main()</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The colloquial <em>shebang</em> (<code>#!</code>) tells the operating system to use the <code>env</code> command (<em>environment</em>) to find <code>python3</code> to execute the rest of the program.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>This is a <em>docstring</em> (documentation string) for the program or module as a whole.<a data-primary="strings (str)" data-secondary="docstring (documentation string)" data-type="indexterm" id="idm45963636729576"/><a data-primary="documentation" data-secondary="docstring (documentation string)" data-type="indexterm" id="idm45963636728616"/></p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-3" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>I import the <code>argparse</code> module to handle command-line arguments.<a data-primary="import statements" data-secondary="argparse module" data-type="indexterm" id="idm45963636724504"/></p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-4" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>I always define a <code>get_args()</code> function to handle the <code>argparse</code> code.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-5" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>This is a docstring for a function.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-6" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>The <code>parser</code> object is used to define the program’s parameters.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-7" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>I define a <code>dna</code> argument, which will be positional because the name <code>dna</code> <em>does not</em> start with a dash. The <code>metavar</code> is a short description of the argument that will appear in the short usage. No other arguments are needed.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-8" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>The function returns the results of parsing the arguments. The help flags or any problems with the arguments will cause <code>argparse</code> to print a usage statement/error messages and exit the program.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-9" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-9"><img alt="9" src="assets/9.png"/></a></dt>&#13;
<dd><p>All programs in the book will always start in the <code>main()</code> function.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-10" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-10"><img alt="10" src="assets/10.png"/></a></dt>&#13;
<dd><p>The first step in <code>main()</code> will always be to call <code>get_args()</code>. If this call succeeds, then the arguments must have been valid.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-11" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-11"><img alt="11" src="assets/11.png"/></a></dt>&#13;
<dd><p>The <code>DNA</code> value is available in the <code>args.dna</code> attribute, as this is the name of the argument.<a data-primary="print() function" data-secondary="arguments" data-type="indexterm" id="idm45963636326728"/></p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-12" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-12"><img alt="12" src="assets/12.png"/></a></dt>&#13;
<dd><p>This is a common idiom in Python programs to detect when the program is being executed<a data-primary="Python" data-secondary="program execution versus being imported" data-type="indexterm" id="idm45963636323032"/> (as opposed to being imported) and to execute the <code>main()</code> function.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note">&#13;
<p>The shebang line is used by the Unix shell when the program is invoked as a program, like <code>./dna.py</code>. It does not work on Windows, where you are required to run <strong><code>python.exe dna.py</code></strong> to execute the program.<a data-primary="Windows" data-secondary="shebang for program execution" data-type="indexterm" id="idm45963636319096"/></p>&#13;
</div>&#13;
&#13;
<p>While this code works completely adequately, the value returned from <code>get_args()</code> is an <code>argparse.Namespace</code> object that is <em>dynamically generated</em> when the program runs.<a data-primary="get_args()" data-secondary="returned object dynamically generated" data-type="indexterm" id="idm45963636316136"/>&#13;
That is, I am using code like <code>parser.add_argument()</code> to modify the structure of this object <em>at runtime</em>, so Python is unable to know positively <em>at compile time</em> what attributes will be available in the parsed arguments or what their types would be.&#13;
While it may be obvious to you that there can only be a single, required string argument, there is not enough information in the code for Python to discern this.</p>&#13;
<div data-type="note" epub:type="note">&#13;
<p>To <em>compile</em> a program is to turn it into the machine code that a computer can execute.<a data-primary="compile defined" data-type="indexterm" id="idm45963636311832"/><a data-primary="Python" data-secondary="compilation" data-type="indexterm" id="idm45963636311160"/> Some languages, like C, must be compiled separately before they can be run. Python programs are often compiled and run in one step, but there is still a compilation phase. Some errors can be caught at compilation, and others don’t turn up until runtime. For instance, syntax errors will prevent compilation. It is preferable to have compile-time errors over runtime errors.</p>&#13;
</div>&#13;
&#13;
<p>To see why this could be a problem, I’ll alter the <code>main()</code> function to introduce a type error.<a data-primary="errors" data-secondary="type error" data-type="indexterm" id="idm45963636308584"/><a data-primary="type error" data-type="indexterm" id="idm45963636307640"/><a data-primary="arguments" data-secondary="type error" data-type="indexterm" id="idm45963636306968"/><a data-primary="strings (str)" data-secondary="type error" data-type="indexterm" id="idm45963636306024"/>&#13;
That is, I’ll intentionally misuse the <em>type</em> of the <code>args.dna</code> value.&#13;
Unless otherwise stated, all argument values returned from the command line by <code>argparse</code> are strings.&#13;
If I try to divide the string <code>args.dna</code> by the integer value 2, Python will raise an exception and crash the program at runtime:</p>&#13;
&#13;
<pre data-type="programlisting">def main():&#13;
    args = get_args()&#13;
    print(args.dna / 2) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO3-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO3-1"><img alt="1" src="assets/1.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO3-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Dividing a string by an integer will produce an exception.</p></dd>&#13;
</dl>&#13;
&#13;
<p>If I run the program, it crashes as expected:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./dna.py ACGT&#13;
Traceback (most recent call last):&#13;
  File "./dna.py", line 30, in &lt;module&gt;&#13;
    main()&#13;
  File "./dna.py", line 25, in main&#13;
    print(args.dna / 2)&#13;
TypeError: unsupported operand type(s) for /: 'str' and 'int'</pre>&#13;
&#13;
<p>Our big squishy brains know that this is an inevitable error waiting to happen, but Python can’t see the problem.&#13;
What I need is a <em>static</em> definition of the arguments that cannot be modified when the program is run.<a data-startref="ch01-thng" data-type="indexterm" id="idm45963636294424"/><a data-startref="ch01-arg" data-type="indexterm" id="idm45963636293752"/><a data-startref="ch01-arg2" data-type="indexterm" id="idm45963636293080"/><a data-startref="ch01-arg3" data-type="indexterm" id="idm45963636292408"/><a data-startref="ch01-arg4" data-type="indexterm" id="idm45963636291736"/>&#13;
Read on to see how type annotations and other tools can detect these sorts of bugs.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Tools for Finding Errors in the Code" data-type="sect2"><div class="sect2" id="idm45963636290520">&#13;
<h2>Tools for Finding Errors in the Code</h2>&#13;
&#13;
<p>The goal here is to write correct, reproducible programs in Python.<a data-primary="reproducible programs" data-secondary="tools for finding errors" data-type="indexterm" id="idm45963636289160"/><a data-primary="best practices" data-secondary="tools for finding errors" data-type="indexterm" id="idm45963636288200"/>&#13;
Are there ways to spot and avoid problems like misusing a string in a numeric operation?<a data-primary="errors" data-secondary="tools for finding" data-type="indexterm" id="idm45963636287000"/><a data-primary="strings (str)" data-secondary="type error" data-tertiary="tools for finding" data-type="indexterm" id="idm45963636286056"/>&#13;
The <code>python3</code> interpreter found no problems that prevented me from running the code.&#13;
That is, the program is syntactically correct, so the code in the preceding section produces a <em>runtime error</em> because the error happens only when I execute the program.<a data-primary="errors" data-secondary="runtime error" data-type="indexterm" id="idm45963636283592"/><a data-primary="runtime errors" data-type="indexterm" id="idm45963636282648"/>&#13;
Years back I worked in a group where we joked, “If it compiles, ship it!”&#13;
This is clearly a myopic approach when coding in Python.</p>&#13;
&#13;
<p>I can use tools like linters and type checkers to find some kinds of problems in code.<a data-primary="linters to catch errors in code" data-type="indexterm" id="idm45963636281192"/><a data-primary="Python" data-secondary="linter pylint" data-type="indexterm" id="idm45963636280504"/><a data-primary="resources" data-secondary="linter for Python" data-type="indexterm" id="idm45963636279560"/>&#13;
<em>Linters</em> are tools that check for program style and many kinds of errors beyond bad syntax.&#13;
The <a href="https://www.pylint.org"><code>pylint</code> tool</a> is a popular Python linter that I use almost every day.<a data-primary="pylint" data-type="indexterm" id="idm45963636276872"/>&#13;
Can it find this problem?&#13;
Apparently not, as it gives the biggest of thumbs-ups:</p>&#13;
&#13;
<pre data-type="programlisting">$ pylint dna.py&#13;
&#13;
-------------------------------------------------------------------&#13;
Your code has been rated at 10.00/10 (previous run: 9.78/10, +0.22)</pre>&#13;
&#13;
<p>The <a href="https://oreil.ly/b3Qtj"><code>flake8</code></a> tool is another linter that I often use in combination with <code>pylint</code>, as it will report different kinds of errors.<a data-primary="flake8 linter to catch errors" data-type="indexterm" id="idm45963636273288"/><a data-primary="pylint" data-secondary="flake8 in combination with" data-type="indexterm" id="idm45963636272600"/>&#13;
When I run <code>flake8 dna.py</code>, I get no output, which means it found no errors to report.</p>&#13;
&#13;
<p>The <a href="http://mypy-lang.org"><code>mypy</code></a> tool is a static <em>type checker</em> for Python, <a data-primary="mypy" data-secondary="about" data-type="indexterm" id="idm45963636269240"/><a data-primary="type error" data-secondary="mypy type checker tool" data-type="indexterm" id="idm45963636268296"/><a data-primary="errors" data-secondary="type error" data-tertiary="mypy type checker tool" data-type="indexterm" id="idm45963636267352"/>meaning it is designed to find misused types such as trying to divide a string by a number.&#13;
Neither <code>pylint</code> nor <code>flake8</code> is designed to catch type errors, so I cannot be legitimately surprised they missed the bug.&#13;
So what does <code>mypy</code> have to say?</p>&#13;
&#13;
<pre data-type="programlisting">$ mypy dna.py&#13;
Success: no issues found in 1 source file</pre>&#13;
&#13;
<p>Well, that’s just a little disappointing; however, you must understand that <code>mypy</code> is failing to report a problem <em>because there is no type information</em>.&#13;
That is, <code>mypy</code> has no information to say that dividing <code>args.dna</code> by 2 is wrong.&#13;
I’ll fix that shortly.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45963636261144">&#13;
<h5>Using Python’s Interactive Interpreter</h5>&#13;
<p>In the next section, I want to show you how to use Python’s interactive interpreter <code>python3</code> to run short pieces of code.<a data-primary="Python" data-secondary="interactive interpreter (REPL)" data-type="indexterm" id="idm45963636259288"/><a data-primary="REPL (Read-Evaluate-Print-Loop)" data-secondary="about" data-type="indexterm" id="idm45963636258328"/><a data-primary="tetranucleotide frequency" data-secondary="REPL interactive interpreter" data-type="indexterm" id="idm45963636257368"/>&#13;
This kind of interface is sometimes called a <em>REPL</em>, which stands for <em>Read-Evaluate-Print-Loop</em>, and I pronounce this so that it sort of rhymes with <em>pebble</em>.&#13;
Each time you enter code in the REPL, Python will immediately <em>read</em> and <em>evaluate</em> the expressions, <em>print</em> the results, and then <em>loop</em> back to wait for more input.</p>&#13;
&#13;
<p>Using a REPL may be new to you, so let’s take a moment to introduce the idea.&#13;
While I’ll demonstrate using <code>python3</code>, you may prefer to use <code>idle3</code>, <code>ipython</code>, a Jupyter Notebook, or a Python console inside an integrated development environment (IDE) like VS Code, as in <a data-type="xref" href="#fig_1.1">Figure 1-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig_1.1">&#13;
<img alt="mpfb 0101" src="assets/mpfb_0101.png"/>&#13;
<h6><span class="label">Figure 1-1. </span>You can run an interactive Python interpreter inside VS Code</h6>&#13;
</div></figure>&#13;
&#13;
<p>Regardless of your choice, I <em>highly</em> encourage you to type all the examples yourself.&#13;
You will learn so much from interacting with the Python interpreter.&#13;
To start the REPL, type <strong><code>python3</code></strong>, or possibly just <strong><code>python</code></strong> on your computer if that points to the latest version.&#13;
Here is what it looks like on my computer:</p>&#13;
&#13;
<pre data-type="programlisting">$ python3&#13;
Python 3.9.1 (v3.9.1:1e5d33e9b9, Dec  7 2020, 12:10:52)&#13;
[Clang 6.0 (clang-600.0.57)] on darwin&#13;
Type "help", "copyright", "credits" or "license" for more information.&#13;
&gt;&gt;&gt;</pre>&#13;
&#13;
<p>The standard <code>python3</code> REPL uses <code>&gt;&gt;&gt;</code> as a prompt.&#13;
Be sure you don’t type the <code>&gt;&gt;&gt;</code> prompt, only the text that it follows.&#13;
For example, if I demonstrate adding two numbers like this:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; 3 + 5&#13;
8</pre>&#13;
&#13;
<p>You should only type <strong><code>3 + 5&lt;Enter&gt;</code></strong>.&#13;
If you include the leading prompt, you will get an error:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; &gt;&gt;&gt; 3 + 5&#13;
  File "&lt;stdin&gt;", line 1&#13;
    &gt;&gt;&gt; 3 + 5&#13;
    ^&#13;
SyntaxError: invalid syntax</pre>&#13;
&#13;
<p>I especially like to use the REPL to read documentation.<a data-primary="REPL (Read-Evaluate-Print-Loop)" data-secondary="reading documentation" data-type="indexterm" id="idm45963636693240"/><a data-primary="documentation" data-secondary="REPL to read" data-type="indexterm" id="idm45963636692280"/><a data-primary="help" data-type="indexterm" id="idm45963636691336"/><a data-primary="documentation" data-secondary="help()" data-type="indexterm" id="idm45963636690664"/><a data-primary="classes" data-secondary="help(classname) for documentation" data-type="indexterm" id="idm45963636689720"/><a data-primary="strings (str)" data-secondary="help(str) for documentation" data-type="indexterm" id="idm45963636688760"/>&#13;
For instance, type <strong><code>help(str)</code></strong> to read about Python’s string class.&#13;
Inside the help documentation, you can move forward with the F key, Ctrl-F, or the space bar, and you can move backward with the B key or Ctrl-B.&#13;
Search by pressing the / key followed by a string and then Enter.&#13;
To leave the help, press Q.<a data-primary="help" data-secondary="Q to leave" data-type="indexterm" id="idm45963636686808"/>&#13;
To quit the REPL, type <strong><code>exit()</code></strong> or press Ctrl-D.<a data-primary="REPL (Read-Evaluate-Print-Loop)" data-secondary="quitting" data-type="indexterm" id="idm45963636685112"/></p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Introducing Named Tuples" data-type="sect2"><div class="sect2" id="idm45963636683672">&#13;
<h2>Introducing Named Tuples</h2>&#13;
&#13;
<p>To avoid the problems with dynamically generated objects, all of the programs in this book will use a named tuple data structure to statically define the arguments from <code>get_args()</code>.<a data-primary="named tuples data structure" data-type="indexterm" id="ch01-nt"/><a data-primary="tuples" data-secondary="about" data-type="indexterm" id="ch01-nt2"/><a data-primary="tetranucleotide frequency" data-secondary="named tuples" data-type="indexterm" id="ch01-nt3"/>&#13;
<em>Tuples</em> are essentially immutable lists, and they are often used to represent record-type data structures in Python.&#13;
There’s quite a bit to unpack with all that, so let’s step back to lists.</p>&#13;
&#13;
<p>To start, <em>lists</em> are ordered sequences of items.&#13;
The items can be heterogeneous; in theory, this means all the items can be of different types, but in practice, mixing types is often a bad idea.&#13;
I’ll use the <code>python3</code> REPL to demonstrate some aspects of lists.<a data-primary="REPL (Read-Evaluate-Print-Loop)" data-secondary="lists" data-type="indexterm" id="idm45963636676008"/>&#13;
I recommend you use <strong><code>help(list)</code></strong> to read the documentation.<a data-primary="lists" data-secondary="help(list) for documentation" data-type="indexterm" id="idm45963636674296"/></p>&#13;
&#13;
<p>Use empty square brackets (<code>[]</code>) to create an empty list that will hold some sequences:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seqs = []</pre>&#13;
&#13;
<p class="pagebreak-before">The <code>list()</code> function will also create a new, empty list:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seqs = list()</pre>&#13;
&#13;
<p>Verify that this is a list by using the <code>type()</code> function to return the variable’s type:<a data-primary="type() function" data-type="indexterm" id="idm45963636668776"/><a data-primary="functions" data-secondary="type()" data-type="indexterm" id="idm45963636668104"/><a data-primary="variables" data-secondary="type() function" data-type="indexterm" id="idm45963636667160"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; type(seqs)&#13;
&lt;class 'list'&gt;</pre>&#13;
&#13;
<p>Lists have methods that will add values to the end of the list, like <code>list.append()</code> to add one value:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seqs.append('ACT')&#13;
&gt;&gt;&gt; seqs&#13;
['ACT']</pre>&#13;
&#13;
<p>and <code>list.extend()</code> to add multiple values:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seqs.extend(['GCA', 'TTT'])&#13;
&gt;&gt;&gt; seqs&#13;
['ACT', 'GCA', 'TTT']</pre>&#13;
&#13;
<p>If you type the variable by itself in the REPL, it will be evaluated and stringified into a textual representation:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seqs&#13;
['ACT', 'GCA', 'TTT']</pre>&#13;
&#13;
<p>This is basically the same thing that happens when you <code>print()</code> a variable:<a data-primary="print() function" data-secondary="variables" data-type="indexterm" id="idm45963636659912"/><a data-primary="variables" data-secondary="printing" data-type="indexterm" id="idm45963636658968"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; print(seqs)&#13;
['ACT', 'GCA', 'TTT']</pre>&#13;
&#13;
<p>You can modify any of the values <em>in-place</em> using the index.&#13;
Remember that all indexing in Python is 0-based, so 0 is the first element.<a data-primary="Python" data-secondary="zero-based indexing" data-type="indexterm" id="idm45963636656296"/><a data-primary="lists" data-secondary="zero-based indexing" data-type="indexterm" id="idm45963636655352"/>&#13;
Change the first sequence to be <code>TCA</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seqs[0] = 'TCA'</pre>&#13;
&#13;
<p>Verify that it was changed:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seqs&#13;
['TCA', 'GCA', 'TTT']</pre>&#13;
&#13;
<p>Like lists, tuples are ordered sequences of possibly heterogeneous objects.&#13;
Whenever you put commas between items in a series, you are creating a tuple:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seqs = 'TCA', 'GCA', 'TTT'&#13;
&gt;&gt;&gt; type(seqs)&#13;
&lt;class 'tuple'&gt;</pre>&#13;
&#13;
<p>It’s typical to place parentheses around tuple values to make this more explicit:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seqs = ('TCA', 'GCA', 'TTT')&#13;
&gt;&gt;&gt; type(seqs)&#13;
&lt;class 'tuple'&gt;</pre>&#13;
&#13;
<p>Unlike lists, tuples cannot be changed once they are created.<a data-primary="tuples" data-secondary="cannot be changed" data-type="indexterm" id="idm45963636648728"/><a data-primary="errors" data-secondary="tuples cannot be changed" data-type="indexterm" id="idm45963636647784"/><a data-primary="named tuples data structure" data-secondary="tuples cannot be changed" data-type="indexterm" id="idm45963636646824"/>&#13;
If you read <code>help(tuple)</code>, you will see that a tuple is a <em>built-in immutable sequence</em>, so I cannot add values:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seqs.append('GGT')&#13;
Traceback (most recent call last):&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;&#13;
AttributeError: 'tuple' object has no attribute 'append'</pre>&#13;
&#13;
<p>or modify existing values:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seqs[0] = 'TCA'&#13;
Traceback (most recent call last):&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;&#13;
TypeError: 'tuple' object does not support item assignment</pre>&#13;
&#13;
<p>It’s fairly common in Python to use tuples to represent records.<a data-primary="Python" data-secondary="tuples to represent records" data-type="indexterm" id="idm45963636642072"/><a data-primary="tuples" data-secondary="records represented by" data-type="indexterm" id="idm45963636641112"/>&#13;
For instance, I might represent a <code>Sequence</code> having a unique ID and a string of bases:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq = ('CAM_0231669729', 'GTGTTTATTCAATGCTAG')</pre>&#13;
&#13;
<p>While it’s possible to use indexing to get the values from a tuple just as with lists, that’s awkward and error-prone.&#13;
<em>Named tuples</em> allow me to assign names to the fields, which makes them more ergonomic to use.<a data-primary="named tuples data structure" data-secondary="names assigned to tuple fields" data-type="indexterm" id="idm45963636637688"/><a data-primary="tuples" data-secondary="named tuples" data-type="indexterm" id="idm45963636636712"/><a data-primary="named tuples data structure" data-secondary="importing namedtuple function" data-type="indexterm" id="idm45963636635768"/><a data-startref="ch01-nt" data-type="indexterm" id="idm45963636634792"/><a data-startref="ch01-nt2" data-type="indexterm" id="idm45963636634120"/><a data-primary="named tuples data structure" data-secondary="about" data-type="indexterm" id="idm45963636633448"/>&#13;
To use named tuples, I can import the <code>namedtuple()</code> function from the <code>collections</code> module:<a data-primary="import statements" data-secondary="namedtuple from collections module" data-type="indexterm" id="idm45963636631416"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from collections import namedtuple</pre>&#13;
&#13;
<p>As shown in <a data-type="xref" href="#fig_1.2">Figure 1-2</a>, I use the <code>namedtuple()</code> function to create the idea of a <code>Sequence</code> that has fields for the <code>id</code> and the <code>seq</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; Sequence = namedtuple('Sequence', ['id', 'seq'])</pre>&#13;
&#13;
<figure><div class="figure" id="fig_1.2">&#13;
<img alt="mpfb 0102" src="assets/mpfb_0102.png" width="250"/>&#13;
<h6><span class="label">Figure 1-2. </span>The <code>namedtuple()</code> function generates a way to make objects of the class <code>Sequence</code> that have the fields <code>id</code> and <code>seq</code></h6>&#13;
</div></figure>&#13;
&#13;
<p>What exactly is <code>Sequence</code> here?</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; type(Sequence)&#13;
&lt;class 'type'&gt;</pre>&#13;
&#13;
<p>I’ve just created a new type.&#13;
You might call the <code>Sequence()</code> function a <em>factory</em> because it’s a function used to generate new objects of the class <code>Sequence</code>.<a data-primary="functions" data-secondary="factory functions" data-type="indexterm" id="idm45963636618328"/><a data-primary="factory functions" data-type="indexterm" id="idm45963636617384"/>&#13;
It’s a common naming convention for these factory functions and class names to be TitleCased to set them apart.<a data-primary="TitleCase for names" data-type="indexterm" id="idm45963636616456"/><a data-primary="functions" data-secondary="factory functions" data-tertiary="TitleCase for names" data-type="indexterm" id="idm45963636615784"/><a data-primary="classes" data-secondary="TitleCase for names" data-type="indexterm" id="idm45963636614568"/><a data-primary="functions" data-secondary="naming conventions lowercase" data-tertiary="TitleCase for factory functions" data-type="indexterm" id="idm45963636613624"/><a data-primary="Python" data-secondary="naming conventions" data-type="indexterm" id="idm45963636612376"/></p>&#13;
&#13;
<p>Just as I can use the <code>list()</code> function to create a new list, I can use the <code>Sequence()</code> function to create a new <code>Sequence</code> object.&#13;
I can pass the <code>id</code> and <code>seq</code> values <em>positionally</em> to match the order they are defined in the class:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq1 = Sequence('CAM_0231669729', 'GTGTTTATTCAATGCTAG')&#13;
&gt;&gt;&gt; type(seq1)&#13;
&lt;class '__main__.Sequence'&gt;</pre>&#13;
&#13;
<p>Or I can use the field names and pass them as key/value pairs in any order I like:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq2 = Sequence(seq='GTGTTTATTCAATGCTAG', id='CAM_0231669729')&#13;
&gt;&gt;&gt; seq2&#13;
Sequence(id='CAM_0231669729', seq='GTGTTTATTCAATGCTAG')</pre>&#13;
&#13;
<p>While it’s possible to use indexes to access the ID and sequence:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; 'ID = ' + seq1[0]&#13;
'ID = CAM_0231669729'&#13;
&gt;&gt;&gt; 'seq = ' + seq1[1]&#13;
'seq = GTGTTTATTCAATGCTAG'</pre>&#13;
&#13;
<p>…the whole point of named tuples is to use the field names:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; 'ID = ' + seq1.id&#13;
'ID = CAM_0231669729'&#13;
&gt;&gt;&gt; 'seq = ' + seq1.seq&#13;
'seq = GTGTTTATTCAATGCTAG'</pre>&#13;
&#13;
<p>The record’s values remain immutable:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq1.id = 'XXX'&#13;
Traceback (most recent call last):&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;&#13;
AttributeError: can't set attribute</pre>&#13;
&#13;
<p>I often want a guarantee that a value cannot be accidentally changed in my code.&#13;
Python doesn’t have a way to declare that a variable is <em>constant</em> or immutable.<a data-primary="variables" data-secondary="constant declaration absent" data-type="indexterm" id="idm45963636601144"/><a data-primary="constant declaration absent" data-type="indexterm" id="idm45963636600184"/><a data-primary="Python" data-secondary="constant declaration absent" data-type="indexterm" id="idm45963636599496"/>&#13;
Tuples are by default immutable, and I think it makes sense to represent the arguments to a program using a data structure that cannot be altered.<a data-primary="tuples" data-secondary="cannot be changed" data-type="indexterm" id="idm45963636598248"/><a data-primary="named tuples data structure" data-secondary="tuples cannot be changed" data-type="indexterm" id="idm45963636597304"/><a data-startref="ch01-nt3" data-type="indexterm" id="idm45963636596328"/>&#13;
The inputs are sacrosanct and should (almost) never be modified.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Adding Types to Named Tuples" data-type="sect2"><div class="sect2" id="idm45963636595128">&#13;
<h2>Adding Types to Named Tuples</h2>&#13;
&#13;
<p>As nice as <code>namedtuple()</code> is, I can make it even better by importing the <code>NamedTuple</code> class from the <code>typing</code> module to use as the base class for the <code>Sequence</code>.<a data-primary="named tuples data structure" data-secondary="types added to" data-type="indexterm" id="idm45963636591960"/><a data-primary="tuples" data-secondary="named tuples" data-tertiary="types added to" data-type="indexterm" id="idm45963636591000"/><a data-primary="tetranucleotide frequency" data-secondary="named tuples" data-tertiary="adding types to" data-type="indexterm" id="idm45963636589784"/>&#13;
Additionally, I can assign <em>types</em> to the fields using this syntax.&#13;
Note the need to use an empty line in the REPL to indicate that the block is complete:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from typing import NamedTuple&#13;
&gt;&gt;&gt; class Sequence(NamedTuple):&#13;
...     id: str&#13;
...     seq: str&#13;
...</pre>&#13;
<div data-type="note" epub:type="note">&#13;
<p>The <code>...</code> you see are line continuations. The REPL is showing that what’s been entered so far is not a complete expression. You need to enter a blank line to let the REPL know that you’re done with the code block.</p>&#13;
</div>&#13;
&#13;
<p>As with the <code>namedtuple()</code> method, <code>Sequence</code> is a new type:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; type(Sequence)&#13;
&lt;class 'type'&gt;</pre>&#13;
&#13;
<p>The code to instantiate a new <code>Sequence</code> object is the same:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq3 = Sequence('CAM_0231669729', 'GTGTTTATTCAATGCTAG')&#13;
&gt;&gt;&gt; type(seq3)&#13;
&lt;class '__main__.Sequence'&gt;</pre>&#13;
&#13;
<p>I can still access the fields by names:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq3.id, seq3.seq&#13;
('CAM_0231669729', 'GTGTTTATTCAATGCTAG')</pre>&#13;
&#13;
<p>Since I defined that both fields have <code>str</code> types, you might assume this would <em>not</em> work:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq4 = Sequence(id='CAM_0231669729', seq=3.14)</pre>&#13;
&#13;
<p>I’m sorry to tell you that Python itself ignores the type information.<a data-primary="type error" data-secondary="Python ignores type information" data-type="indexterm" id="idm45963636577544"/>&#13;
You can see the <code>seq</code> field that I hoped would be a <code>str</code> is actually a <code>float</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq4&#13;
Sequence(id='CAM_0231669729', seq=3.14)&#13;
&gt;&gt;&gt; type(seq4.seq)&#13;
&lt;class 'float'&gt;</pre>&#13;
&#13;
<p>So how does this help us?&#13;
It doesn’t help me in the REPL, but adding types to my source code will allow type-checking tools like <code>mypy</code> to find such errors.<a data-primary="mypy" data-secondary="typing named tuples" data-type="indexterm" id="idm45963636573272"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Representing the Arguments with a NamedTuple" data-type="sect2"><div class="sect2" id="idm45963636572008">&#13;
<h2>Representing the Arguments with a NamedTuple</h2>&#13;
&#13;
<p>I want the data structure that represents the program’s arguments to include type information.<a data-primary="named tuples data structure" data-secondary="arguments represented by" data-type="indexterm" id="ch01-targ"/><a data-primary="arguments" data-secondary="named tuples representing" data-type="indexterm" id="ch01-targ2"/><a data-primary="tuples" data-secondary="named tuples" data-tertiary="arguments represented by" data-type="indexterm" id="ch01-targ3"/><a data-primary="tetranucleotide frequency" data-secondary="named tuples" data-tertiary="arguments represented by" data-type="indexterm" id="idm45963636566616"/>&#13;
As with the <code>Sequence</code> class, I can define a class that is derived from the <code>NamedTuple</code> type where I can <em>statically define the data structure with types</em>.&#13;
I like to call this class <code>Args</code>, but you can call it whatever you like.&#13;
I know this probably seems like driving a finishing nail with a sledgehammer, but trust me, this kind of detail will pay off in the future.</p>&#13;
&#13;
<p>The latest <code>new.py</code> uses the <code>NamedTuple</code> class from the <code>typing</code> module.&#13;
Here is how I suggest you define and represent the arguments:</p>&#13;
&#13;
<pre data-type="programlisting">#!/usr/bin/env python3&#13;
"""Tetranucleotide frequency"""&#13;
&#13;
import argparse&#13;
from typing import NamedTuple <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
&#13;
class Args(NamedTuple): <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-2"><img alt="2" src="assets/2.png"/></a>&#13;
    """ Command-line arguments """&#13;
    dna: str <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-3" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-3"><img alt="3" src="assets/3.png"/></a>&#13;
&#13;
&#13;
# --------------------------------------------------&#13;
def get_args() -&gt; Args: <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-4" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-4"><img alt="4" src="assets/4.png"/></a>&#13;
    """ Get command-line arguments """&#13;
&#13;
    parser = argparse.ArgumentParser(&#13;
        description='Tetranucleotide frequency',&#13;
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)&#13;
&#13;
    parser.add_argument('dna', metavar='DNA', help='Input DNA sequence')&#13;
&#13;
    args = parser.parse_args() <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-5" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-5"><img alt="5" src="assets/5.png"/></a>&#13;
&#13;
    return Args(args.dna) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-6" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-6"><img alt="6" src="assets/6.png"/></a>&#13;
&#13;
&#13;
# --------------------------------------------------&#13;
def main() -&gt; None: <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-7" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-7"><img alt="7" src="assets/7.png"/></a>&#13;
    """ Make a jazz noise here """&#13;
&#13;
    args = get_args()&#13;
    print(args.dna / 2) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-8" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-8"><img alt="8" src="assets/8.png"/></a>&#13;
&#13;
&#13;
# --------------------------------------------------&#13;
if __name__ == '__main__':&#13;
    main()</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Import the <code>NamedTuple</code> class from the <code>typing</code> module.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Define a <code>class</code> for the arguments which is based on the <code>NamedTuple</code> class. See the following note.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-3" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The class has a single field called <code>dna</code> that has the type <code>str</code>.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-4" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>The type annotation on the <code>get_args()</code> function shows that it returns an object of the type <code>Args</code>.<a data-primary="-&gt; (return value)" data-primary-sortas="# return value" data-type="indexterm" id="idm45963636529224"/><a data-primary="return value (-&gt;)" data-type="indexterm" id="idm45963636528280"/><a data-primary="functions" data-secondary="return value sign (-&gt;)" data-type="indexterm" id="idm45963636527608"/></p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-5" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Parse the arguments as before.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-6" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Return a new <code>Args</code> object that contains the single value from <code>args.dna</code>.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-7" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>The <code>main()</code> function has no <code>return</code> statement, so it returns the default <code>None</code> value.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-8" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>This is the type error from the earlier program.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note">&#13;
<p>If you run <code>pylint</code> on this program, you may encounter the errors “Inheriting <em>NamedTuple</em>, which is not a class. (inherit-non-class)” and “Too few public methods (0/2) (too-few-public-methods).” <a data-primary="installation" data-secondary="pylint and mypy initialization files" data-type="indexterm" id="idm45963636511432"/><a data-primary="pylint" data-secondary="Inheriting X, which is not a class" data-type="indexterm" id="idm45963636510472"/><a data-primary="pylint" data-secondary="Too few public methods" data-type="indexterm" id="idm45963636509512"/><a data-primary="errors" data-secondary="pylint" data-tertiary="Too few public methods" data-type="indexterm" id="idm45963636508568"/><a data-primary="errors" data-secondary="pylint" data-tertiary="Inheriting X, which is not a class" data-type="indexterm" id="idm45963636507352"/>You can disable these warnings by adding “inherit-non-class” and “too-few-public-methods” to the “disable” section of your <em>pylintrc</em> file, or use the <em>pylintrc</em> file included in the root of the GitHub repository.</p>&#13;
</div>&#13;
&#13;
<p>If you run this program, you’ll see it still creates the same uncaught exception.&#13;
Both <code>flake8</code> and <code>pylint</code> will continue to report that the program looks fine, but see what <code>mypy</code> tells me now:<a data-primary="mypy" data-secondary="typing named tuples" data-type="indexterm" id="idm45963636502840"/><a data-primary="errors" data-secondary="type error" data-tertiary="mypy and typing named couples" data-type="indexterm" id="idm45963636501896"/></p>&#13;
&#13;
<pre data-type="programlisting">$ mypy dna.py&#13;
dna.py:32: error: Unsupported operand types for / ("str" and "int")&#13;
Found 1 error in 1 file (checked 1 source file)</pre>&#13;
&#13;
<p>The error message shows that there is a problem on line 32 with the operands, which are the arguments to the division (<code>/</code>) operator.&#13;
I’m mixing string and integer values.&#13;
Without the type annotations, <code>mypy</code> would be unable to find a bug.&#13;
Without this warning from <code>mypy</code>, I’d have to run my program to find it, being sure to exercise the branch of code that contains the error.&#13;
In this case, it’s all rather obvious and trivial, but in a much larger program with hundreds or thousands of lines of code (LOC) with many functions and logical branches (like <code>if</code>/<code>else</code>), I might not stumble upon this error.&#13;
I rely on types and programs like <code>mypy</code> (and <code>pylint</code> and <code>flake8</code> and so on) to correct these kinds of errors rather than relying solely on tests, or worse, waiting for users to report bugs.<a data-startref="ch01-targ" data-type="indexterm" id="idm45963636469128"/><a data-startref="ch01-targ2" data-type="indexterm" id="idm45963636468456"/><a data-startref="ch01-targ3" data-type="indexterm" id="idm45963636467784"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reading Input from the Command Line or a File" data-type="sect2"><div class="sect2" id="idm45963636466792">&#13;
<h2>Reading Input from the Command Line or a File</h2>&#13;
&#13;
<p>When you attempt to prove that your program works on the Rosalind.info website, you will download a data file containing the input to your program.<a data-primary="tetranucleotide frequency" data-secondary="input for program" data-type="indexterm" id="idm45963636465336"/><a data-primary="input for program" data-secondary="command line or file" data-type="indexterm" id="idm45963636464376"/><a data-primary="input for program" data-secondary="Rosalind.info website" data-type="indexterm" id="idm45963636463432"/><a data-primary="Rosalind.info challenges" data-secondary="input for program" data-type="indexterm" id="idm45963636462488"/>&#13;
Usually, this data will be much larger than the sample data described in the problem.&#13;
For instance, the example DNA string for this problem is 70 bases long, but the one I downloaded for one of my attempts was 910 bases.</p>&#13;
&#13;
<p>Let’s make the program read input both from the command line and from a text file so that you don’t have to copy and paste the contents from a downloaded file.&#13;
This is a common pattern I use, and I prefer to handle this option inside the <code>get_args()</code> function since this pertains to processing the command-line arguments.</p>&#13;
&#13;
<p>First, correct the program so that it prints the <code>args.dna</code> value without the division:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    print(args.dna) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO5-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO5-1"><img alt="1" src="assets/1.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO5-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Remove the division type error.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Check that it works:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./dna.py ACGT&#13;
ACGT</pre>&#13;
&#13;
<p>For this next part, you need to bring in the <code>os</code> module to interact with your operating system.<a data-primary="os module" data-secondary="reading input from file" data-type="indexterm" id="idm45963636451032"/><a data-primary="file input" data-secondary="tetranucleotide frequency" data-type="indexterm" id="idm45963636450088"/><a data-primary="open() function" data-secondary="small input file" data-type="indexterm" id="idm45963636449128"/><a data-primary="read() function for small files" data-type="indexterm" id="idm45963636448184"/><a data-primary="filehandle" data-secondary="open() function" data-type="indexterm" id="idm45963636447496"/>&#13;
Add <code>import os</code> to the other <code>import</code> statements at the top, then add these two lines to your <code>get_args()</code> function:</p>&#13;
&#13;
<pre data-type="programlisting">def get_args() -&gt; Args:&#13;
    """ Get command-line arguments """&#13;
&#13;
    parser = argparse.ArgumentParser(&#13;
        description='Tetranucleotide frequency',&#13;
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)&#13;
&#13;
    parser.add_argument('dna', metavar='DNA', help='Input DNA sequence')&#13;
&#13;
    args = parser.parse_args()&#13;
&#13;
    if os.path.isfile(args.dna):  <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO6-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO6-1"><img alt="1" src="assets/1.png"/></a>&#13;
        args.dna = open(args.dna).read().rstrip()   <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO6-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO6-2"><img alt="2" src="assets/2.png"/></a>&#13;
&#13;
    return Args(args.dna)</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO6-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Check if the <code>dna</code> value is a file.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO6-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Call <code>open()</code> to open a filehandle, then chain the <code>fh.read()</code> method to return a string, then chain the <code>str.rstrip()</code> method to remove trailing whitespace.<a data-primary="strings (str)" data-secondary="formatting" data-tertiary="removing trailing whitespace" data-type="indexterm" id="idm45963636432200"/><a data-primary="rstrip() function" data-type="indexterm" id="idm45963636430968"/><a data-primary="stripping white space from strings" data-type="indexterm" id="idm45963636430296"/></p></dd>&#13;
</dl>&#13;
<div data-type="warning" epub:type="warning">&#13;
<p>The <code>fh.read()</code> function will read an <em>entire</em> file into a variable. In this case, the<a data-primary="variables" data-secondary="read() entire file into" data-type="indexterm" id="idm45963636427512"/> input file is small and so this should be fine, but it’s very common in bioinformatics to process files that are gigabytes in size. Using <code>read()</code> on a large file could crash your program or even your entire computer. Later I will show you how to read a file line-by-line to avoid this.</p>&#13;
</div>&#13;
&#13;
<p class="pagebreak-before">Now run your program with a string value to ensure it works:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./dna.py ACGT&#13;
ACGT</pre>&#13;
&#13;
<p>and then use a text file as the argument:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./dna.py tests/inputs/input2.txt&#13;
AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC</pre>&#13;
&#13;
<p>Now you have a flexible program that reads input from two sources.&#13;
Run <strong><code>mypy dna.py</code></strong> to make sure there are no problems.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Testing Your Program" data-type="sect2"><div class="sect2" id="idm45963636421352">&#13;
<h2>Testing Your Program</h2>&#13;
&#13;
<p>You know from the Rosalind description that given the input <code>ACGT</code>, the program should print <code>1 1 1 1</code> since that is the number of <em>A</em>s, <em>C</em>s, <em>G</em>s, and <em>T</em>s, respectively.<a data-primary="tetranucleotide frequency" data-secondary="testing" data-tertiary="pytest" data-type="indexterm" id="ch01-pyt"/><a data-primary="test-driven development (TDD)" data-secondary="pytest tool" data-tertiary="tetranucleotide frequency" data-type="indexterm" id="ch01-pyt2"/><a data-primary="pytest tool" data-secondary="tetranucleotide frequency" data-type="indexterm" id="ch01-pyt3"/>&#13;
In the <em>01_dna/tests</em> directory, there is a file called <em>dna_test.py</em> that contains tests for the <code>dna.py</code> program.&#13;
I wrote these tests for you so you can see what it’s like to develop a program using a method to tell you with some certainty when your program is correct.&#13;
The tests are really basic—given an input string, the program should print the correct counts for the four nucleotides.&#13;
When the program reports the correct numbers, then it works.</p>&#13;
&#13;
<p>Inside the <em>01_dna</em> directory, I’d like you to run <strong><code>pytest</code></strong> (or <strong><code>python3 -m pytest</code></strong> or <strong><code>pytest.exe</code></strong> on Windows).&#13;
The program will recursively search for all files with names that start with <em>test_</em> or end with <em>_test.py</em>.&#13;
It will then run for any functions in these files that have names starting with <em>test_</em>.</p>&#13;
&#13;
<p>When you run <strong><code>pytest</code></strong>, you will see a lot of output, most of which is failing tests.&#13;
To understand why these tests are failing, let’s look at the <em>tests/dna_test.py</em> module:</p>&#13;
&#13;
<pre data-type="programlisting">""" Tests for dna.py """ <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
import os <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-2"><img alt="2" src="assets/2.png"/></a>&#13;
import platform <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-3" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-3"><img alt="3" src="assets/3.png"/></a>&#13;
from subprocess import getstatusoutput <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-4" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-4"><img alt="4" src="assets/4.png"/></a>&#13;
&#13;
PRG = './dna.py' <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-5" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-5"><img alt="5" src="assets/5.png"/></a>&#13;
RUN = f'python {PRG}' if platform.system() == 'Windows' else PRG <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-6" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-6"><img alt="6" src="assets/6.png"/></a>&#13;
TEST1 = ('./tests/inputs/input1.txt', '1 2 3 4') <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-7" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-7"><img alt="7" src="assets/7.png"/></a>&#13;
TEST2 = ('./tests/inputs/input2.txt', '20 12 17 21')&#13;
TEST3 = ('./tests/inputs/input3.txt', '196 231 237 246')</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>This is the docstring for the module.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The standard <code>os</code> module will interact with the operating system.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-3" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The <code>platform</code> module is used to determine if this is being run on Windows.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-4" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>From the <code>subprocess</code> module I import a function to run the <code>dna.py</code> program and capture the output and status.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-5" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>These following lines are global variables for the program. I tend to avoid globals except in my tests. Here I want to define some values that I’ll use in the functions. I like to use UPPERCASE_NAMES to highlight the global visibility.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-6" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>The <code>RUN</code> variable determines how to run the <code>dna.py</code> program. On Windows, the <code>python</code> command must be used to run a Python program, but on Unix platforms, the <code>dna.py</code> program can be directly executed.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-7" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>The <code>TEST*</code> variables are tuples that define a file containing a string of DNA and the expected output from the program for that string.</p></dd>&#13;
</dl>&#13;
&#13;
<p>The <code>pytest</code> module will run the test functions in the order in which they are defined in the test file.&#13;
I often structure my tests so that they progress from the simplest cases to more complex, so there’s usually no point in continuing after a failure.&#13;
For instance, the first test is always that the program to test exists.&#13;
If it doesn’t, then there’s no point in running more tests.&#13;
I recommend you run <code>pytest</code> with the <code>-x</code> flag to stop on the first failing test along with the <code>-v</code> flag for verbose output.<a data-primary="pytest tool" data-secondary="-x flag to stop on first failing test" data-secondary-sortas="x flag" data-type="indexterm" id="idm45963636364008"/><a data-primary="test-driven development (TDD)" data-secondary="pytest tool" data-tertiary="-x flag to stop on first failing test" data-tertiary-sortas="x flag" data-type="indexterm" id="idm45963636362776"/><a data-primary="test-driven development (TDD)" data-secondary="pytest tool" data-tertiary="-v flag for verbose output" data-tertiary-sortas="v flag" data-type="indexterm" id="idm45963636361256"/><a data-primary="pytest tool" data-secondary="-v flag for verbose output" data-secondary-sortas="v flag" data-type="indexterm" id="idm45963636359736"/></p>&#13;
&#13;
<p>Let’s look at the first test.&#13;
The function is called <code>test_exists()</code> so that <code>pytest</code> will find it.&#13;
In the body of the function, I use one or more <code>assert</code> statements to check if some condition is <em>truthy</em>.<sup><a data-type="noteref" href="ch01.html#idm45963636356152" id="idm45963636356152-marker">1</a></sup> Here I assert that the program <code>dna.py</code> exists.&#13;
This is why your program must exist in this directory—otherwise it wouldn’t be found by the test:</p>&#13;
&#13;
<pre data-type="programlisting">def test_exists(): <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO8-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO8-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Program exists """&#13;
&#13;
    assert os.path.exists(PRG) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO8-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO8-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO8-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO8-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The function name must start with <code>test_</code> to be found by <code>pytest</code>.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO8-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO8-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The <code>os.path.exists()</code> function returns <code>True</code> if the given argument is a file. If it returns <code>False</code>, then the assertion fails and this test will fail.</p></dd>&#13;
</dl>&#13;
&#13;
<p>The next test I write is always to check that the program will produce a usage statement for the <code>-h</code> and <code>--help</code> flags.&#13;
The <code>subprocess.getstatusoutput()</code> function will run the <code>dna.py</code> program with the short and long help flags.&#13;
In each case, I want to see that the program prints text starting with the word <em>usage:</em>. It’s not a perfect test.&#13;
It doesn’t check that the documentation is accurate, only that it appears to be something that might be a usage statement.&#13;
I don’t feel that every test needs to be completely exhaustive. Here’s the test:</p>&#13;
&#13;
<pre data-type="programlisting">def test_usage() -&gt; None:&#13;
    """ Prints usage """&#13;
&#13;
    for arg in ['-h', '--help']: <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-1"><img alt="1" src="assets/1.png"/></a>&#13;
        rv, out = getstatusoutput(f'{RUN} {arg}') <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-2"><img alt="2" src="assets/2.png"/></a>&#13;
        assert rv == 0 <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-3" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-3"><img alt="3" src="assets/3.png"/></a>&#13;
        assert out.lower().startswith('usage:') <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-4" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-4"><img alt="4" src="assets/4.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Iterate over the short and long help flags.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Run the program with the argument and capture the return value and output.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-3" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Verify that the program reports a successful exit value of 0.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-4" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Assert that the lowercased output of the program starts with the text <em>usage:</em>.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note">&#13;
<p>Command-line programs usually indicate an error to the operating system by returning a nonzero value. If the program runs successfully, it ought to return a <code>0</code>. Sometimes that nonzero value may correlate to some internal error code, but often it just means that something went wrong. The programs I write will, likewise, always strive to report <code>0</code> for successful runs and some nonzero value when there are errors.</p>&#13;
</div>&#13;
&#13;
<p>Next, I want to ensure that the program will die when given no arguments:<a data-primary="arguments" data-secondary="testing for no arguments" data-type="indexterm" id="idm45963625056328"/></p>&#13;
&#13;
<pre data-type="programlisting">def test_dies_no_args() -&gt; None:&#13;
    """ Dies with no arguments """&#13;
&#13;
    rv, out = getstatusoutput(RUN) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO10-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO10-1"><img alt="1" src="assets/1.png"/></a>&#13;
    assert rv != 0 <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO10-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO10-2"><img alt="2" src="assets/2.png"/></a>&#13;
    assert out.lower().startswith('usage:') <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO10-3" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO10-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO10-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO10-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Capture the return value and output from running the program with <span class="keep-together">no arguments.</span></p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO10-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO10-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Verify that the return value is a nonzero failure code.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO10-3" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO10-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Check that the output looks like a usage statement.</p></dd>&#13;
</dl>&#13;
&#13;
<p>At this point in testing, I know that I have a program with the correct name that can be run to produce documentation.&#13;
This means that the program is at least &#13;
<span class="keep-together">syntactically</span> correct, which is a decent place to start testing.&#13;
If your program has typographical errors, then you’ll be forced to correct those to even get to this point.<a data-startref="ch01-pyt" data-type="indexterm" id="idm45963625037864"/><a data-startref="ch01-pyt2" data-type="indexterm" id="idm45963625037192"/><a data-startref="ch01-pyt3" data-type="indexterm" id="idm45963625036520"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Running the Program to Test the Output" data-type="sect2"><div class="sect2" id="idm45963625035528">&#13;
<h2>Running the Program to Test the Output</h2>&#13;
&#13;
<p>Now I need to see if the program does what it’s supposed to do.<a data-primary="tetranucleotide frequency" data-secondary="testing" data-tertiary="running program to test output" data-type="indexterm" id="idm45963625034168"/><a data-primary="test-driven development (TDD)" data-secondary="running program to test output" data-type="indexterm" id="idm45963625032920"/><a data-primary="output from program" data-secondary="testing output" data-type="indexterm" id="ch01-txxx"/>&#13;
There are many ways to test programs, and I like to use two basic approaches I call <em>inside-out</em> and <em>outside-in</em>.&#13;
The inside-out approach starts at the level of testing individual functions inside a program.<a data-primary="functions" data-secondary="inside-out testing" data-type="indexterm" id="idm45963625029528"/><a data-primary="inside-out testing" data-type="indexterm" id="idm45963625028584"/>&#13;
This is often called <em>unit</em> testing, as functions might be considered a basic unit of computing, and I’ll get to this in the solutions section.<a data-primary="unit testing" data-secondary="about" data-type="indexterm" id="idm45963625027208"/>&#13;
I’ll start with the outside-in approach.<a data-primary="outside-in testing" data-type="indexterm" id="idm45963625026072"/>&#13;
This means that I will run the program from the command line just as the user will run it.&#13;
This is a holistic approach to check if the pieces of the code can work together to create the correct output, and so it’s sometimes called an <em>integration</em> test.<a data-primary="integration test" data-type="indexterm" id="idm45963625024568"/></p>&#13;
&#13;
<p>The first such test will pass the DNA string as a command-line argument and check if the program produces the right counts formatted in the correct string:</p>&#13;
&#13;
<pre data-type="programlisting">def test_arg():&#13;
    """ Uses command-line arg """&#13;
&#13;
    for file, expected in [TEST1, TEST2, TEST3]: <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-1"><img alt="1" src="assets/1.png"/></a>&#13;
        dna = open(file).read() <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-2"><img alt="2" src="assets/2.png"/></a>&#13;
        retval, out = getstatusoutput(f'{RUN} {dna}') <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-3" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-3"><img alt="3" src="assets/3.png"/></a>&#13;
        assert retval == 0 <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-4" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-4"><img alt="4" src="assets/4.png"/></a>&#13;
        assert out == expected <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-5" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-5"><img alt="5" src="assets/5.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Unpack the tuples into the <code>file</code> containing a string of DNA and the <code>expected</code> value from the program when run with this input.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Open the file and read the <code>dna</code> from the contents.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-3" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Run the program with the given DNA string using the function <span class="keep-together"><code>subprocess.getstatusoutput()</code></span>, which gives me both the return value from the program and the text output (also called <code>STDOUT</code>, which is pronounced <em>standard out</em>).</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-4" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Assert that the return value is <code>0</code>, which indicates success (or 0 errors).</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-5" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Assert that the output from the program is the string of numbers expected.</p></dd>&#13;
</dl>&#13;
&#13;
<p>The next test is almost identical, but this time I’ll pass the filename as the argument to the program to verify that it correctly reads the DNA from a file:</p>&#13;
&#13;
<pre data-type="programlisting">def test_file():&#13;
    """ Uses file arg """&#13;
&#13;
    for file, expected in [TEST1, TEST2, TEST3]:&#13;
        retval, out = getstatusoutput(f'{RUN} {file}') <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO12-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO12-1"><img alt="1" src="assets/1.png"/></a>&#13;
        assert retval == 0&#13;
        assert out == expected</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO12-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO12-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The only difference from the first test is that I pass the filename instead of the contents of the file.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Now that you’ve looked at the tests, go back and run the tests again.&#13;
This time, use <strong><code>pytest -xv</code></strong>, where the <code>-v</code> flag is for verbose output.<a data-primary="pytest tool" data-secondary="-v flag for verbose output" data-secondary-sortas="v flag" data-type="indexterm" id="idm45963624986200"/><a data-primary="test-driven development (TDD)" data-secondary="pytest tool" data-tertiary="-v flag for verbose output" data-tertiary-sortas="v flag" data-type="indexterm" id="idm45963624984968"/><a data-primary="pytest tool" data-secondary="tetranucleotide frequency" data-type="indexterm" id="idm45963624983448"/><a data-primary="test-driven development (TDD)" data-secondary="pytest tool" data-tertiary="tetranucleotide frequency" data-type="indexterm" id="idm45963624982488"/><a data-primary="pytest tool" data-secondary="-x flag to stop on first failing test" data-secondary-sortas="x flag" data-type="indexterm" id="idm45963624981240"/><a data-primary="test-driven development (TDD)" data-secondary="pytest tool" data-tertiary="-x flag to stop on first failing test" data-tertiary-sortas="x flag" data-type="indexterm" id="idm45963624980008"/>&#13;
Since both <code>-x</code> and <code>-v</code> are short flags, you can combine them like <code>-xv</code> or <code>-vx</code>.&#13;
Read the output closely and notice that it’s trying to tell you that the program is printing the DNA sequence but that the test is expecting a sequence of numbers:</p>&#13;
&#13;
<pre data-type="programlisting">$ pytest -xv&#13;
============================= test session starts ==============================&#13;
...&#13;
&#13;
tests/dna_test.py::test_exists PASSED                                    [ 25%]&#13;
tests/dna_test.py::test_usage PASSED                                     [ 50%]&#13;
tests/dna_test.py::test_arg FAILED                                       [ 75%]&#13;
&#13;
=================================== FAILURES ===================================&#13;
___________________________________ test_arg ___________________________________&#13;
&#13;
    def test_arg():&#13;
        """ Uses command-line arg """&#13;
&#13;
        for file, expected in [TEST1, TEST2, TEST3]:&#13;
            dna = open(file).read()&#13;
            retval, out = getstatusoutput(f'{RUN} {dna}')&#13;
            assert retval == 0&#13;
&gt;           assert out == expected  <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO13-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO13-1"><img alt="1" src="assets/1.png"/></a>&#13;
E           AssertionError: assert 'ACCGGGTTTT' == '1 2 3 4'  <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO13-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO13-2"><img alt="2" src="assets/2.png"/></a>&#13;
E             - 1 2 3 4&#13;
E             + ACCGGGTTTT&#13;
&#13;
tests/dna_test.py:36: AssertionError&#13;
=========================== short test summary info ============================&#13;
FAILED tests/dna_test.py::test_arg - AssertionError: assert 'ACCGGGTTTT' == '...&#13;
!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!&#13;
========================= 1 failed, 2 passed in 0.35s ==========================</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO13-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO13-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The <code>&gt;</code> at the beginning of this line shows that this is the source of the error.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO13-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO13-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The output from the program was the string <code>ACCGGGTTTT</code> but the expected value was <code>1 2 3 4</code>. Since these are not equal, an <code>AssertionError</code> exception is raised.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Let’s fix that.&#13;
If you think you know how to finish the program, please jump right into your solution.&#13;
First, perhaps try running your program to verify that it will report the correct number of <em>A</em>s:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./dna.py A&#13;
1 0 0 0</pre>&#13;
&#13;
<p>And then <em>C</em>s:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./dna.py C&#13;
0 1 0 0</pre>&#13;
&#13;
<p>and so forth with <em>G</em>s and <em>T</em>s.&#13;
Then run <strong><code>pytest</code></strong> to see if it passes all the tests.</p>&#13;
&#13;
<p>After you have a working version, consider trying to find as many different ways as you can to get the same answer.<a data-primary="refactoring programs" data-type="indexterm" id="idm45963624956584"/><a data-primary="tetranucleotide frequency" data-secondary="refactoring programs" data-type="indexterm" id="idm45963624955912"/>&#13;
This is called <em>refactoring</em> a program.&#13;
You need to start with something that works correctly, and then you try to improve it.&#13;
The improvements can be measured in many ways.&#13;
Perhaps you find a way to write the same idea using less code, or maybe you find a solution that runs faster.&#13;
No matter what metric you’re using, keep running <strong><code>pytest</code></strong> to ensure the program is correct.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 1: Iterating and Counting the Characters in a String" data-type="sect1"><div class="sect1" id="idm45963624952984">&#13;
<h1>Solution 1: Iterating and Counting the Characters <span class="keep-together">in a String</span></h1>&#13;
&#13;
<p>If you don’t know where to start, I’ll work through the first solution with you.<a data-primary="tetranucleotide frequency" data-secondary="solution 1 iterating through strings" data-type="indexterm" id="ch01-ctsol"/><a data-primary="strings (str)" data-secondary="iterating through" data-type="indexterm" id="ch01-ctsol2"/><a data-primary="strings (str)" data-secondary="counting characters in" data-type="indexterm" id="ch01-ctsol3"/><a data-primary="REPL (Read-Evaluate-Print-Loop)" data-secondary="iterating through strings" data-type="indexterm" id="ch01-ctsol4"/>&#13;
The goal is to travel through all the bases in the DNA string. So, first I need to create a variable called <code>dna</code> by assigning it some value in the REPL:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; dna = 'ACGT'</pre>&#13;
&#13;
<p>Note that any value enclosed in quotes, whether single or double, is a string.&#13;
Even a single character in Python is considered a string.&#13;
I will often use the <code>type()</code> function to verify the type of a variable, and here I see that <code>dna</code> is of the class <code>str</code> (string):<a data-primary="type() function" data-type="indexterm" id="idm45963624942664"/><a data-primary="functions" data-secondary="type()" data-type="indexterm" id="idm45963624941992"/><a data-primary="variables" data-secondary="type() function" data-type="indexterm" id="idm45963624941048"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; type(dna)&#13;
&lt;class 'str'&gt;</pre>&#13;
<div data-type="tip">&#13;
<p>Type <code>help(str)</code> in the REPL to see all the wonderful things you can do with strings.<a data-primary="strings (str)" data-secondary="help(str) for documentation" data-type="indexterm" id="idm45963624937864"/>&#13;
This data type is especially important in genomics, where strings comprise so much of the data.</p>&#13;
</div>&#13;
&#13;
<p>In the parlance of Python, I want to <em>iterate</em> through the characters of a string, which in this case are the nucleotides of DNA.<a data-primary="for loops" data-secondary="iterating through strings" data-type="indexterm" id="idm45963624935528"/>&#13;
A <code>for</code> loop will do that.&#13;
Python sees a string as an ordered sequence of characters, and a <code>for</code> loop will visit each character from beginning to end:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; for base in dna: <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO14-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO14-1"><img alt="1" src="assets/1.png"/></a>&#13;
...     print(base)  <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO14-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO14-2"><img alt="2" src="assets/2.png"/></a>&#13;
...&#13;
A&#13;
C&#13;
G&#13;
T</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO14-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO14-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Each character in the <code>dna</code> string will be copied into the <code>base</code> variable. You could call this <code>char</code>, or <code>c</code> for <em>character</em>, or whatever else you like.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO14-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO14-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Each call to <code>print()</code> will end with a newline, so you’ll see each base on a separate line.<a data-primary="print() function" data-secondary="newline at end" data-type="indexterm" id="idm45963624920040"/><a data-primary="newline at end" data-secondary="print() function adds" data-type="indexterm" id="idm45963632835208"/><a data-primary="print() function" data-secondary="variables" data-type="indexterm" id="idm45963632834264"/><a data-primary="variables" data-secondary="printing" data-type="indexterm" id="idm45963632833320"/></p></dd>&#13;
</dl>&#13;
&#13;
<p>Later you will see that <code>for</code> loops can be used with lists and dictionaries and sets and lines in a file—basically any iterable data structure.<a data-primary="iterables" data-secondary="for loops with" data-type="indexterm" id="idm45963632831208"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Counting the Nucleotides" data-type="sect2"><div class="sect2" id="idm45963632830104">&#13;
<h2>Counting the Nucleotides</h2>&#13;
&#13;
<p>Now that I know how to visit each base in the sequence, I need to count each base rather than printing it.&#13;
That means I’ll need some variables to keep track of the numbers for each of the four nucleotides.&#13;
One way to do this is to create four variables that hold integer counts, one for each base.&#13;
I will <em>initialize</em> four variables for counting by setting their initial values to <code>0</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; count_a = 0&#13;
&gt;&gt;&gt; count_c = 0&#13;
&gt;&gt;&gt; count_g = 0&#13;
&gt;&gt;&gt; count_t = 0</pre>&#13;
&#13;
<p>I could write this in one line by using the tuple unpacking syntax that I showed <span class="keep-together">earlier:</span></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; count_a, count_c, count_g, count_t = 0, 0, 0, 0</pre>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45963632824808">&#13;
<h5>Variable Naming Conventions</h5>&#13;
<p>I could have named my variables <code>countA</code> or <code>CountA</code> or <code>COUNTA</code> or <code>count_A</code> or any number of ways, but I always stick to the suggested <a data-primary="variables" data-secondary="naming convention lowercase" data-type="indexterm" id="idm45963632821640"/><a data-primary="functions" data-secondary="naming conventions lowercase" data-type="indexterm" id="idm45963632820680"/><a data-primary="Python" data-secondary="naming conventions" data-type="indexterm" id="idm45963632819720"/><a data-primary="resources" data-secondary="Python" data-tertiary="naming conventions" data-type="indexterm" id="idm45963632818776"/>naming conventions in the <a href="https://oreil.ly/UmUYt">“Style Guide for Python Code”</a>, also known as <em>PEP8</em>, which says that function and variable names “should be lowercase, with words separated by underscores as necessary to improve readability.”</p>&#13;
</div></aside>&#13;
&#13;
<p>I need to look at each base and determine which variable to <em>increment</em>, making its value increase by 1.&#13;
For instance, if the current <code>base</code> is a <em>C</em>, then I should increment the <code>count_c</code> variable.&#13;
I could write this:</p>&#13;
&#13;
<pre data-type="programlisting">for base in dna:&#13;
    if base == 'C': <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO15-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO15-1"><img alt="1" src="assets/1.png"/></a>&#13;
        count_c = count_c + 1 <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO15-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO15-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO15-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO15-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The <code>==</code> operator is used to compare two values for equality. Here I want to know if the current <code>base</code> is equal to the string <code>C</code>.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO15-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO15-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Set <code>count_c</code> equal to 1 greater than the current value.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note">&#13;
<p>The <code>==</code> operator is used to compare two values for equality. It works to compare two strings or two numbers.<a data-primary="== (compare for equality)" data-primary-sortas="# compare for equality" data-type="indexterm" id="idm45963632799464"/><a data-primary="comparing for equality (==)" data-type="indexterm" id="idm45963632798504"/><a data-primary="equal signs" data-secondary="== (compare for equality)" data-secondary-sortas="# compare for equality" data-type="indexterm" id="idm45963632797816"/> I showed earlier that division with <code>/</code> will raise an exception if you mix strings and numbers. What happens if you mix types with this operator, for example <code>'3' == 3</code>? Is this a safe operator to use without first comparing the types?</p>&#13;
</div>&#13;
&#13;
<p>As shown in <a data-type="xref" href="#fig_1.3">Figure 1-3</a>, a shorter way to increment a variable uses the <code>+=</code> operator <a data-primary="equal signs" data-secondary="+= (increment)" data-secondary-sortas="# increment" data-type="indexterm" id="idm45963632793448"/><a data-primary="+= (increment)" data-primary-sortas="# increment" data-type="indexterm" id="idm45963632792232"/><a data-primary="increment (+=)" data-type="indexterm" id="idm45963632791288"/>to add whatever is on the righthand side (often noted as RHS) of the expression to whatever is on the lefthand side (or LHS):</p>&#13;
&#13;
<figure><div class="figure" id="fig_1.3">&#13;
<img alt="mpfb 0103" src="assets/mpfb_0103.png" width="200"/>&#13;
<h6><span class="label">Figure 1-3. </span>The <code>+=</code> operator will add the value on the righthand side to the variable on the lefthand side</h6>&#13;
</div></figure>&#13;
&#13;
<p>Since I have four nucleotides to check, I need a way to combine three more <code>if</code> expressions.&#13;
The syntax in Python for this is to use <code>elif</code> for <em>else if</em> and <code>else</code> for any final or default case.&#13;
Here is a block of code I can enter in the program or the REPL that implements a simple decision tree:<a data-primary="decision trees" data-type="indexterm" id="idm45963632785064"/><a data-primary="if and elif decision tree" data-type="indexterm" id="idm45963632784392"/><a data-primary="elif decision tree" data-type="indexterm" id="idm45963632783704"/></p>&#13;
&#13;
<pre data-type="programlisting">dna = 'ACCGGGTTTT'&#13;
count_a, count_c, count_g, count_t = 0, 0, 0, 0&#13;
for base in dna:&#13;
    if base == 'A':&#13;
        count_a += 1&#13;
    elif base == 'C':&#13;
        count_c += 1&#13;
    elif base == 'G':&#13;
        count_g += 1&#13;
    elif base == 'T':&#13;
        count_t += 1</pre>&#13;
&#13;
<p>I should end up with counts of 1, 2, 3, and 4 for each of the sorted bases:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; count_a, count_c, count_g, count_t&#13;
(1, 2, 3, 4)</pre>&#13;
&#13;
<p>Now I need to report the outcome to the user:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; print(count_a, count_c, count_g, count_t)&#13;
1 2 3 4</pre>&#13;
&#13;
<p>That is the exact output the program expects.<a data-primary="print() function" data-secondary="multiple values separated by space" data-type="indexterm" id="idm45963632779096"/>&#13;
Notice that <code>print()</code> will accept multiple values to print, and it inserts a space between each value.&#13;
If you read <code>help(print)</code> in the REPL, you’ll find that you can change this with the <code>sep</code> argument:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; print(count_a, count_c, count_g, count_t, sep='::')&#13;
1::2::3::4</pre>&#13;
&#13;
<p>The <code>print()</code> function will also put a newline at the end of the output, and this can likewise be changed using the <code>end</code> option:<a data-startref="ch01-ctsol2" data-type="indexterm" id="idm45963632774312"/><a data-startref="ch01-ctsol3" data-type="indexterm" id="idm45963632773640"/><a data-startref="ch01-ctsol4" data-type="indexterm" id="idm45963632772968"/><a data-primary="print() function" data-secondary="newline at end" data-tertiary="end option to change" data-type="indexterm" id="idm45963632772296"/><a data-primary="print() function" data-secondary="end option" data-type="indexterm" id="idm45963632771080"/><a data-startref="ch01-txxx" data-type="indexterm" id="idm45963632770136"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; print(count_a, count_c, count_g, count_t, end='\n-30-\n')&#13;
1 2 3 4&#13;
-30-</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Writing and Verifying a Solution" data-type="sect2"><div class="sect2" id="idm45963632768360">&#13;
<h2>Writing and Verifying a Solution</h2>&#13;
&#13;
<p>Using the preceding code, you should be able to create a program that passes all the tests.&#13;
As you write, I would encourage you to regularly run <code>pylint</code>, <code>flake8</code>, and <code>mypy</code> to check your source code for potential errors.&#13;
I would even go further and suggest you install the <code>pytest</code> extensions for these so that you can routinely incorporate such tests:<a data-primary="pytest tool" data-secondary="extensions for pylint, flake8, mypy" data-type="indexterm" id="idm45963632765000"/><a data-primary="pylint" data-secondary="pytest extension for" data-type="indexterm" id="idm45963632764040"/><a data-primary="flake8 linter to catch errors" data-secondary="pytest extension for" data-type="indexterm" id="idm45963632763096"/><a data-primary="mypy" data-secondary="pytest extension for" data-type="indexterm" id="idm45963632762136"/></p>&#13;
&#13;
<pre data-type="programlisting">$ python3 -m pip install pytest-pylint pytest-flake8 pytest-mypy</pre>&#13;
&#13;
<p>Alternatively, I’ve placed a <em>requirements.txt</em> file in the root directory of the GitHub repo that lists various dependencies I’ll use throughout the book.&#13;
You can install all these modules with the following command:</p>&#13;
&#13;
<pre data-type="programlisting">$ python3 -m pip install -r requirements.txt</pre>&#13;
&#13;
<p>With those extensions, you can run the following command to run not only the tests defined in the <em>tests/dna_test.py</em> file but also tests for linting and type checking using these tools:</p>&#13;
&#13;
<pre data-type="programlisting">$ pytest -xv --pylint --flake8 --mypy tests/dna_test.py&#13;
========================== test session starts ===========================&#13;
...&#13;
collected 7 items&#13;
&#13;
tests/dna_test.py::FLAKE8 SKIPPED                                  [ 12%]&#13;
tests/dna_test.py::mypy PASSED                                     [ 25%]&#13;
tests/dna_test.py::test_exists PASSED                              [ 37%]&#13;
tests/dna_test.py::test_usage PASSED                               [ 50%]&#13;
tests/dna_test.py::test_dies_no_args PASSED                        [ 62%]&#13;
tests/dna_test.py::test_arg PASSED                                 [ 75%]&#13;
tests/dna_test.py::test_file PASSED                                [ 87%]&#13;
::mypy PASSED                                                      [100%]&#13;
================================== mypy ==================================&#13;
&#13;
Success: no issues found in 1 source file&#13;
====================== 7 passed, 1 skipped in 0.58s ======================</pre>&#13;
<div data-type="tip">&#13;
<p>Some tests are skipped when a cached version indicates nothing has changed since the last test. <a data-primary="pytest tool" data-secondary="---cache-clear option to force tests" data-secondary-sortas="cache-clear option" data-type="indexterm" id="idm45963632754840"/><a data-primary="linters to catch errors in code" data-secondary="formatting causing failure" data-type="indexterm" id="idm45963632753608"/><a data-primary="formatting code automatically" data-type="indexterm" id="idm45963632752632"/><a data-primary="errors" data-secondary="formatting causing linting failures" data-type="indexterm" id="idm45963632751944"/><a data-primary="yapf to auto format code" data-type="indexterm" id="idm45963632750984"/><a data-primary="black tool to auto format code" data-type="indexterm" id="idm45963632750296"/><a data-primary="IDEs (integrated development environments)" data-secondary="formatting code" data-type="indexterm" id="idm45963632749608"/>Run <code>pytest</code> with the <code>---cache-clear</code> option to force the tests to run. Also, you may find you fail linting tests if your code is not properly formatted or indented. You can automatically format your code using <code>yapf</code> or <code>black</code>. Most IDEs and editors will provide an auto-format option.</p>&#13;
</div>&#13;
&#13;
<p>That’s a lot to type, so I’ve created a shortcut for you in the form of a <em>Makefile</em> in the directory:<a data-primary="Makefiles" data-secondary="shortcuts for commands" data-tertiary="test shortcut" data-type="indexterm" id="idm45963632745352"/><a data-primary="test-driven development (TDD)" data-secondary="Makefile for testing" data-type="indexterm" id="idm45963632744136"/><a data-primary="automating" data-secondary="Makefiles" data-seealso="Makefiles" data-type="indexterm" id="idm45963632743176"/></p>&#13;
&#13;
<pre data-type="programlisting">$ cat Makefile&#13;
.PHONY: test&#13;
&#13;
test:&#13;
	python3 -m pytest -xv --flake8 --pylint --pylint-rcfile=../pylintrc \&#13;
    --mypy dna.py tests/dna_test.py&#13;
&#13;
all:&#13;
	../bin/all_test.py dna.py</pre>&#13;
&#13;
<p>You can learn more about these files by reading <a data-type="xref" href="app01.html#app1_makefiles">Appendix A</a>.&#13;
For now, it’s enough to understand that if you have <code>make</code> installed on your system, you can use the command <strong><code>make test</code></strong> to run the command in the <code>test</code> target of the <em>Makefile</em>.&#13;
If you don’t have <code>make</code> installed or you don’t want to use it, that’s fine too, but I suggest you explore how a <em>Makefile</em> can be used to document and automate processes.</p>&#13;
&#13;
<p>There are many ways to write a passing version of <code>dna.py</code>, and I’d like to encourage you to keep exploring before you read the solutions.<a data-primary="best practices" data-secondary="test-driven development" data-type="indexterm" id="idm45963632735752"/><a data-primary="test-driven development (TDD)" data-secondary="about" data-type="indexterm" id="idm45963632734808"/><a data-primary="reproducible programs" data-secondary="test-driven development" data-type="indexterm" id="idm45963632733848"/>&#13;
More than anything, I want to get you used to the idea of changing your program and then running the tests to see if it works.&#13;
This is the cycle of <em>test-driven development</em>, where I first create some metric to decide when the program works correctly.&#13;
In this instance, that is the <em>dna_test.py</em> program that is run by <code>pytest</code>.</p>&#13;
&#13;
<p>The tests ensure I don’t stray from the goal, and they also let me know when I’ve met the requirements of the program.&#13;
They are the specifications (also called <em>specs</em>) made incarnate as a program that I can execute.<a data-primary="test-driven development (TDD)" data-secondary="specifications made incarnate" data-type="indexterm" id="idm45963632730088"/><a data-primary="specifications made incarnate in tests" data-type="indexterm" id="idm45963632729112"/>&#13;
How else would I ever know when a &#13;
<span class="keep-together">program</span> worked or was finished? Or, as Louis Srygley puts it, “Without requirements or design, programming is the art of adding bugs to an empty text file.”<a data-primary="Srygley, Louis" data-type="indexterm" id="idm45963632727384"/></p>&#13;
&#13;
<p>Testing is essential to creating reproducible programs.&#13;
Unless you can absolutely and automatically prove the correctness and predictability of your program when run with both good and bad data, then you’re not writing good software.<a data-startref="ch01-ctsol" data-type="indexterm" id="idm45963632726040"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Additional Solutions" data-type="sect1"><div class="sect1" id="idm45963632724888">&#13;
<h1>Additional Solutions</h1>&#13;
&#13;
<p>The program I wrote earlier in this chapter is the <em>solution1_iter.py</em> version in the GitHub repo, so I won’t bother reviewing that version.&#13;
I would like to show you several alternate solutions that progress from simpler to more complex ideas.&#13;
Please do not take this to mean they progress from worse to better.&#13;
All versions pass the tests, so they are all equally valid.&#13;
The point is to explore what Python has to offer for solving common problems.&#13;
Note I will omit code they all have in common, such as the <code>get_args()</code> function.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 2: Creating a count() Function and Adding a Unit Test" data-type="sect2"><div class="sect2" id="idm45963632722072">&#13;
<h2>Solution 2: Creating a count() Function and Adding a Unit Test</h2>&#13;
&#13;
<p>The first variation I’d like to show will move all the code in the <code>main()</code> function that does the counting into a <code>count()</code> function.<a data-primary="unit testing" data-secondary="tetranucleotide frequency" data-type="indexterm" id="ch01-unts"/><a data-primary="functions" data-secondary="count() created" data-type="indexterm" id="ch01-unts2"/><a data-primary="count() function created" data-type="indexterm" id="ch01-unts3"/><a data-primary="tetranucleotide frequency" data-secondary="solution 2 creating count function" data-type="indexterm" id="ch01-unts4"/>&#13;
You can define this function anywhere in your program, but I generally like <code>get_args()</code> first, <code>main()</code> second, and then other functions after that but <em>before</em> the final couplet that calls <code>main()</code>.<a data-primary="functions" data-secondary="order of definition in program" data-type="indexterm" id="idm45963632713032"/><a data-primary="functional programming (FP)" data-secondary="order of functions in program" data-type="indexterm" id="idm45963632712072"/></p>&#13;
&#13;
<p>For the following function, you will also need to import the <code>typing.Tuple</code> value:</p>&#13;
&#13;
<pre data-type="programlisting">def count(dna: str) -&gt; Tuple[int, int, int, int]: <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO16-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO16-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Count bases in DNA """&#13;
&#13;
    count_a, count_c, count_g, count_t = 0, 0, 0, 0 <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO16-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO16-2"><img alt="2" src="assets/2.png"/></a>&#13;
    for base in dna:&#13;
        if base == 'A':&#13;
            count_a += 1&#13;
        elif base == 'C':&#13;
            count_c += 1&#13;
        elif base == 'G':&#13;
            count_g += 1&#13;
        elif base == 'T':&#13;
            count_t += 1&#13;
&#13;
    return (count_a, count_c, count_g, count_t) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO16-3" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO16-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO16-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO16-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The types show that the function takes a string and returns a tuple containing four integer values.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO16-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO16-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>This is the code from <code>main()</code> that did the counting.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO16-3" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO16-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Return a tuple of the four counts.</p></dd>&#13;
</dl>&#13;
&#13;
<p>There are many reasons to move this code into a function.<a data-primary="unit testing" data-secondary="about" data-type="indexterm" id="idm45963632693512"/>&#13;
To start, this is a <em>unit</em> of computation—given a string of DNA, return the tetranucleotide frequency—so it makes sense to encapsulate it.&#13;
This will make <code>main()</code> shorter and more readable, and it allows me to write a unit test for the function.&#13;
Since the function is called <code>count()</code>, I like to call the unit test <code>test_count()</code>.&#13;
I have placed this function inside the <code>dna.py</code> program just after the <code>count()</code> function rather than in the <code>dna_test.py</code> program just as a matter of convenience.&#13;
For short programs, I tend to put my functions and unit tests together in the source code, but as projects grow larger, I will segregate unit tests into a separate module. Here’s the test function:</p>&#13;
&#13;
<pre data-type="programlisting">def test_count() -&gt; None: <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO17-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO17-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Test count """&#13;
&#13;
    assert count('') == (0, 0, 0, 0) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO17-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO17-2"><img alt="2" src="assets/2.png"/></a>&#13;
    assert count('123XYZ') == (0, 0, 0, 0)&#13;
    assert count('A') == (1, 0, 0, 0) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO17-3" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO17-3"><img alt="3" src="assets/3.png"/></a>&#13;
    assert count('C') == (0, 1, 0, 0)&#13;
    assert count('G') == (0, 0, 1, 0)&#13;
    assert count('T') == (0, 0, 0, 1)&#13;
    assert count('ACCGGGTTTT') == (1, 2, 3, 4)</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO17-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO17-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The function name must start with <code>test_</code> to be found by <code>pytest</code>. The types here show that the test accepts no arguments and, because it has no <code>return</code> statement, returns the default <code>None</code> value.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO17-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO17-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>I like to test functions with both expected and unexpected values to ensure they return something reasonable. The empty string should return all zeros.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO17-3" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO17-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The rest of the tests ensure that each base is reported in the correct position.</p></dd>&#13;
</dl>&#13;
&#13;
<p>To verify that my function works, I can use <code>pytest</code> on the <code>dna.py</code> program:</p>&#13;
&#13;
<pre data-type="programlisting">$ pytest -xv dna.py&#13;
=========================== test session starts ===========================&#13;
...&#13;
&#13;
dna.py::test_count PASSED                                           [100%]&#13;
&#13;
============================ 1 passed in 0.01s ============================</pre>&#13;
&#13;
<p>The first test passes the empty string and expects to get all zeros for the counts.&#13;
This is a judgment call, honestly.&#13;
You might decide your program ought to complain to the user that there’s no input.&#13;
That is, it’s possible to run the program using the empty string as the input, and this version will report the following:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./dna.py ""&#13;
0 0 0 0</pre>&#13;
&#13;
<p>Likewise, if I passed an empty file, I’d get the same answer.&#13;
Use the <strong><code>touch</code></strong> command to create an empty file:</p>&#13;
&#13;
<pre data-type="programlisting">$ touch empty&#13;
$ ./dna.py empty&#13;
0 0 0 0</pre>&#13;
&#13;
<p>On Unix systems, <code>/dev/null</code> is a special filehandle that returns nothing:<a data-primary="Unix command line" data-secondary="/dev/null filehandle" data-secondary-sortas="dev-null filehandle" data-type="indexterm" id="idm45963632664408"/><a data-primary="/dev/null filehandle" data-primary-sortas="dev-null filehandle" data-type="indexterm" id="idm45963632663192"/><a data-primary="filehandle" data-secondary="/dev/null in Unix" data-secondary-sortas="dev-null in Unix" data-type="indexterm" id="idm45963632662248"/><a data-primary="input for program" data-secondary="/dev/null filehandle" data-secondary-sortas="dev-null filehandle" data-type="indexterm" id="idm45963632661032"/><a data-primary="command line (Unix)" data-secondary="/dev/null filehandle" data-secondary-sortas="dev-null filehandle" data-type="indexterm" id="idm45963632659816"/></p>&#13;
&#13;
<pre data-type="programlisting">$ ./dna.py /dev/null&#13;
0 0 0 0</pre>&#13;
&#13;
<p>You may feel that no input is an error and report it as such.&#13;
The important thing about the test is that it forces me to think about it.&#13;
For instance, should the <code>count()</code> function return zeros or raise an exception if it’s given an empty string?&#13;
Should the program crash on empty input and exit with a nonzero status?&#13;
These are decisions you will have to make for your programs.</p>&#13;
&#13;
<p>Now that I have a unit test in the <code>dna.py</code> code, I can run <code>pytest</code> on that file to see if it passes:</p>&#13;
&#13;
<pre data-type="programlisting">$ pytest -v dna.py&#13;
============================ test session starts =============================&#13;
...&#13;
collected 1 item&#13;
&#13;
dna.py::test_count PASSED                                              [100%]&#13;
&#13;
============================= 1 passed in 0.01s ==============================</pre>&#13;
&#13;
<p>When I’m writing code, I like to write functions that do just one limited thing with as few parameters as possible.<a data-primary="functions" data-secondary="one task, few parameters" data-type="indexterm" id="idm45963632653736"/>&#13;
Then I like to write a test with a name like <code>test_</code> plus the function name, usually right after the function in the source code.<a data-primary="functions" data-secondary="test for each function" data-type="indexterm" id="idm45963632652072"/><a data-primary="test-driven development (TDD)" data-secondary="test for each function" data-type="indexterm" id="idm45963632651128"/>&#13;
If I find I have many of these kinds of unit tests, I might decide to move them to a separate file and have <code>pytest</code> execute that file.</p>&#13;
&#13;
<p>To use this new function, modify <code>main()</code> like so:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    count_a, count_c, count_g, count_t = count(args.dna) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO18-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO18-1"><img alt="1" src="assets/1.png"/></a>&#13;
    print('{} {} {} {}'.format(count_a, count_c, count_g, count_t)) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO18-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO18-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO18-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO18-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Unpack the four values returned from <code>count()</code> into separate variables.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO18-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO18-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Use <code>str.format()</code> to create the output string.<a data-primary="strings (str)" data-secondary="formatting" data-tertiary="print() function" data-type="indexterm" id="idm45963632637048"/><a data-primary="print() function" data-secondary="formatted output" data-type="indexterm" id="idm45963632635832"/><a data-primary="format() function for strings" data-type="indexterm" id="idm45963632634888"/><a data-primary="{} (curly brackets for string formatting)" data-primary-sortas="# curly brackets" data-type="indexterm" id="idm45963632634200"/><a data-primary="curly brackets ({}) for string formatting" data-type="indexterm" id="idm45963632633224"/></p></dd>&#13;
</dl>&#13;
&#13;
<p>Let’s focus for a moment on Python’s <code>str.format()</code>.&#13;
As shown in <a data-type="xref" href="#fig_1.4">Figure 1-4</a>, the string <code>'{} {} {} {}'</code> is a template for the output I want to generate, <a data-primary="strings (str)" data-secondary="formatting" data-tertiary="templates" data-type="indexterm" id="idm45963632630120"/>and I’m calling the <code>str.format()</code> function <em>directly on a string literal</em>.&#13;
This is a common idiom in Python that you’ll also see with the <code>str.join()</code> function.<a data-primary="join() function for strings" data-type="indexterm" id="idm45963632627336"/><a data-primary="strings (str)" data-secondary="join() function" data-type="indexterm" id="idm45963632626648"/>&#13;
It’s important to remember that, in Python, even a literal string (one that literally exists inside your source code in quotes) is an <em>object</em> upon which you can call <em>methods</em>.</p>&#13;
&#13;
<figure><div class="figure" id="fig_1.4">&#13;
<img alt="mpfb 0104" src="assets/mpfb_0104.png"/>&#13;
<h6><span class="label">Figure 1-4. </span>The <code>str.format()</code> function uses a template containing curly brackets to define placeholders that are filled in with the values of the arguments</h6>&#13;
</div></figure>&#13;
&#13;
<p>Every <code>{}</code> in the string template is a placeholder for some value that is provided as an argument to the function.&#13;
When using this function, you need to ensure that you have the same number of placeholders as arguments.&#13;
The arguments are inserted in the order in which they are provided.&#13;
I’ll have much more to say about the <span class="keep-together"><code>str.format()</code></span> function later.</p>&#13;
&#13;
<p>I’m not required to unpack the tuple returned by the <code>count()</code> function.&#13;
I can pass the entire tuple as the argument to the <code>str.format()</code> function if I <em>splat</em> it by adding an asterisk (<code>*</code>) to the front.<a data-primary="splatting a tuple (*)" data-type="indexterm" id="idm45963632617512"/><a data-primary="tuples" data-secondary="splat (*) to expand tuple" data-type="indexterm" id="idm45963632616840"/><a data-primary="* (splat a tuple)" data-primary-sortas="# splat a tuple" data-type="indexterm" id="idm45963632615880"/>&#13;
This tells Python to expand the tuple into its values:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    counts = count(args.dna) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO19-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO19-1"><img alt="1" src="assets/1.png"/></a>&#13;
    print('{} {} {} {}'.format(*counts)) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO19-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO19-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO19-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO19-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The <code>counts</code> variable is a 4-tuple of the integer base counts.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO19-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO19-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The <code>*counts</code> syntax will expand the tuple into the four values needed by the format string; otherwise, the tuple would be interpreted as a single value.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Since I use the <code>counts</code> variable only once, I could skip the assignment and shrink this to one line:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    print('{} {} {} {}'.format(*count(args.dna))) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO20-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO20-1"><img alt="1" src="assets/1.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO20-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO20-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Pass the return value from <code>count()</code> directly to the <code>str.format()</code> method.</p></dd>&#13;
</dl>&#13;
&#13;
<p>The first solution is arguably easier to read and understand, and tools like <code>flake8</code> would be able to spot when the number of <code>{}</code> placeholders does not match the number of variables.&#13;
Simple, verbose, obvious code is often better than compact, clever code.&#13;
Still, it’s good to know about tuple unpacking and splatting variables as I’ll use these in ideas in later programs.<a data-startref="ch01-unts" data-type="indexterm" id="idm45963632593464"/><a data-startref="ch01-unts2" data-type="indexterm" id="idm45963632592792"/><a data-startref="ch01-unts3" data-type="indexterm" id="idm45963632592120"/><a data-startref="ch01-unts4" data-type="indexterm" id="idm45963632591448"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 3: Using str.count()" data-type="sect2"><div class="sect2" id="idm45963632590456">&#13;
<h2>Solution 3: Using str.count()</h2>&#13;
&#13;
<p>The previous <code>count()</code> function turns out to be quite verbose.&#13;
I can write the function using a single line of code using the <code>str.count()</code> method.<a data-primary="count() method for strings" data-type="indexterm" id="ch01-strct"/><a data-primary="strings (str)" data-secondary="count() method" data-type="indexterm" id="ch01-strct2"/><a data-primary="tetranucleotide frequency" data-secondary="solution 3 using str.count()" data-type="indexterm" id="ch01-strct3"/>&#13;
This function will count the number of times one string is found inside another string.&#13;
Let me show you in the REPL:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq = 'ACCGGGTTTT'&#13;
&gt;&gt;&gt; seq.count('A')&#13;
1&#13;
&gt;&gt;&gt; seq.count('C')&#13;
2</pre>&#13;
&#13;
<p>If the string is not found, it will report <code>0</code>, making this safe to count all four nucleotides even when the input sequence is missing one or more bases:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; 'AAA'.count('T')&#13;
0</pre>&#13;
&#13;
<p>Here is a new version of the <code>count()</code> function using this idea:</p>&#13;
&#13;
<pre data-type="programlisting">def count(dna: str) -&gt; Tuple[int, int, int, int]: <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO21-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO21-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Count bases in DNA """&#13;
&#13;
    return (dna.count('A'), dna.count('C'), dna.count('G'), dna.count('T')) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO21-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO21-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO21-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO21-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The signature is the same as before.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO21-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO21-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Call the <code>dna.count()</code> method for each of the four bases.</p></dd>&#13;
</dl>&#13;
&#13;
<p>This code is much more succinct, and I can use the same unit test to verify that it’s correct.&#13;
This is a key point: <em>functions should act like black boxes</em>.&#13;
That is, I do not know or care what happens inside the box.&#13;
Something goes in, an answer comes <span class="keep-together">out, and</span> I only really care that the answer is correct.&#13;
I am free to change what happens inside the box so long as the contract to the outside—the parameters and return <span class="keep-together">value—stays the same.</span></p>&#13;
&#13;
<p>Here’s another way to create the output string in the <code>main()</code> function using Python’s <span class="keep-together">f-string syntax:</span><a data-primary="strings (str)" data-secondary="formatting" data-tertiary="f-string" data-type="indexterm" id="idm45963632565800"/><a data-primary="print() function" data-secondary="formatted output" data-tertiary="f-string" data-type="indexterm" id="idm45963632564584"/><a data-primary="f-strings for formatted output" data-type="indexterm" id="idm45963632563368"/><a data-primary="output from program" data-secondary="print" data-see="print() function" data-type="indexterm" id="idm45963632562680"/></p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    count_a, count_c, count_g, count_t = count(args.dna) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO22-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO22-1"><img alt="1" src="assets/1.png"/></a>&#13;
    print(f'{count_a} {count_c} {count_g} {count_t}') <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO22-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO22-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO22-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO22-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Unpack the tuple into each of the four counts.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO22-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO22-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Use an f-string to perform variable interpolation.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note">&#13;
<p>It’s called an <em>f-string</em> because the <code>f</code> precedes the quotes. I use the mnemonic <em>format</em> to remind me this is to format a string. Python also has a <em>raw</em> string that is preceded with an <code>r</code>, which I’ll discuss later. All strings in Python—bare, f-, or r-strings—can be enclosed in single or double quotes. It makes no difference.</p>&#13;
</div>&#13;
&#13;
<p>With f-strings, the <code>{}</code> placeholders can perform <em>variable interpolation</em>, which is a 50-cent word that means turning a variable into its contents.&#13;
Those curlies can even execute code.&#13;
For instance, the <code>len()</code> function will return the length of a string and can be run inside the braces:<a data-primary="len() function for strings" data-type="indexterm" id="idm45963632545080"/><a data-primary="strings (str)" data-secondary="len() function" data-type="indexterm" id="idm45963632544392"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq = 'ACGT'&#13;
&gt;&gt;&gt; f'The sequence "{seq}" has {len(seq)} bases.'&#13;
'The sequence "ACGT" has 4 bases.'</pre>&#13;
&#13;
<p>I usually find f-strings easier to read than the equivalent code using <code>str.format()</code>.&#13;
Which you choose is mostly a stylistic decision.&#13;
I would recommend whichever makes your code more readable.<a data-startref="ch01-strct" data-type="indexterm" id="idm45963632541608"/><a data-startref="ch01-strct2" data-type="indexterm" id="idm45963632540936"/><a data-startref="ch01-strct3" data-type="indexterm" id="idm45963632540264"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 4: Using a Dictionary to Count All the Characters" data-type="sect2"><div class="sect2" id="idm45963632539272">&#13;
<h2>Solution 4: Using a Dictionary to Count All the Characters</h2>&#13;
&#13;
<p>So far I’ve discussed Python’s strings, lists, and tuples.&#13;
This next solution introduces <em>dictionaries</em>, which are key/value stores.<a data-primary="tetranucleotide frequency" data-secondary="solution 4 dictionary to count" data-type="indexterm" id="ch01-dict"/><a data-primary="dictionaries" data-secondary="counting characters" data-type="indexterm" id="ch01-dict2"/>&#13;
I’d like to show a version of the <code>count()</code> function that internally uses dictionaries so that I can hit on some important points to understand:</p>&#13;
&#13;
<pre data-type="programlisting">def count(dna: str) -&gt; Tuple[int, int, int, int]: <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Count bases in DNA """&#13;
&#13;
    counts = {} <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-2"><img alt="2" src="assets/2.png"/></a>&#13;
    for base in dna: <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-3" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-3"><img alt="3" src="assets/3.png"/></a>&#13;
        if base not in counts: <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-4" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-4"><img alt="4" src="assets/4.png"/></a>&#13;
            counts[base] = 0 <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-5" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-5"><img alt="5" src="assets/5.png"/></a>&#13;
        counts[base] += 1 <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-6" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-6"><img alt="6" src="assets/6.png"/></a>&#13;
&#13;
    return (counts.get('A', 0), <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-7" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-7"><img alt="7" src="assets/7.png"/></a>&#13;
            counts.get('C', 0),&#13;
            counts.get('G', 0),&#13;
            counts.get('T', 0))</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Internally I’ll use a dictionary, but nothing changes about the function signature.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Initialize an empty dictionary to hold the <code>counts</code>.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-3" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Use a <code>for</code> loop to iterate through the sequence.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-4" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Check if the base does not yet exist in the dictionary.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-5" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Initialize the value for this base to <code>0</code>.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-6" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Increment the count for this base by 1.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-7" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Use the <code>dict.get()</code> method to get each base’s count or the default of <code>0</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Again, the contract for this function—the type signature—hasn’t changed.&#13;
It’s still a string in and 4-tuple of integers out.&#13;
Inside the function, I’m going to use a dictionary that I’ll initialize using the empty curly brackets:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; counts = {}</pre>&#13;
&#13;
<p>I could also use the <code>dict()</code> function. Neither is preferable:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; counts = dict()</pre>&#13;
&#13;
<p>I can use the <code>type()</code> function to check that this is a dictionary:<a data-primary="type() function" data-type="indexterm" id="idm45963632493576"/><a data-primary="variables" data-secondary="type() function" data-type="indexterm" id="idm45963632492904"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; type(counts)&#13;
&lt;class 'dict'&gt;</pre>&#13;
&#13;
<p>The <code>isinstance()</code> function is another way to check the type of a variable:<a data-primary="variables" data-secondary="isinstance() function" data-type="indexterm" id="idm45963632490280"/><a data-primary="isinstance() function" data-type="indexterm" id="idm45963632489336"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; isinstance(counts, dict)&#13;
True</pre>&#13;
&#13;
<p>My goal is to create a dictionary that has each base as a <em>key</em> and the number of times it occurs as a <em>value</em>.&#13;
For example, given the sequence <code>ACCGGGTTT</code>, I want <code>counts</code> to look like this:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; counts&#13;
{'A': 1, 'C': 2, 'G': 3, 'T': 4}</pre>&#13;
&#13;
<p>I can access any of the values using square brackets and a key name like so:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; counts['G']&#13;
3</pre>&#13;
&#13;
<p>Python will raise a <code>KeyError</code> exception if I attempt to access a dictionary key that doesn’t exist:<a data-primary="errors" data-secondary="KeyError for dictionary" data-type="indexterm" id="idm45963632482648"/><a data-primary="KeyError for dictionary" data-type="indexterm" id="idm45963632481704"/><a data-primary="dictionaries" data-secondary="KeyError" data-type="indexterm" id="idm45963632481032"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; counts['N']&#13;
Traceback (most recent call last):&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;&#13;
KeyError: 'N'</pre>&#13;
&#13;
<p>I can use the <code>in</code> keyword to see if a key exists in a dictionary:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; 'N' in counts&#13;
False&#13;
&gt;&gt;&gt; 'T' in counts&#13;
True</pre>&#13;
&#13;
<p>As I am iterating through each of the bases in the sequence, I need to see if a base exists in the <code>counts</code> dictionary.&#13;
If it does not, I need to initialize it to <code>0</code>.&#13;
Then I can safely use the <code>+=</code> assignment to increment the count for a base by 1:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq = 'ACCGGGTTTT'&#13;
&gt;&gt;&gt; counts = {}&#13;
&gt;&gt;&gt; for base in seq:&#13;
...     if not base in counts:&#13;
...         counts[base] = 0&#13;
...     counts[base] += 1&#13;
...&#13;
&gt;&gt;&gt; counts&#13;
{'A': 1, 'C': 2, 'G': 3, 'T': 4}</pre>&#13;
&#13;
<p>Finally, I want to return a 4-tuple of the counts for each of the bases.&#13;
You might think this would work:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; counts['A'], counts['C'], counts['G'], counts['T']&#13;
(1, 2, 3, 4)</pre>&#13;
&#13;
<p>But ask yourself what would happen if one of the bases was missing from the sequence.&#13;
Would this pass the unit test I wrote?&#13;
Definitely not.&#13;
It would fail on the very first test using an empty string because it would generate a <code>KeyError</code> exception.&#13;
The safe way to ask a dictionary for a value is to use the <code>dict.get()</code> method.<a data-primary="dictionaries" data-secondary="get() method" data-type="indexterm" id="idm45963632471832"/><a data-primary="get() method for dictionary" data-type="indexterm" id="idm45963632470888"/>&#13;
If the key does not exist, then <code>None</code> will be returned:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; counts.get('T')&#13;
4&#13;
&gt;&gt;&gt; counts.get('N')</pre>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45963632468664">&#13;
<h5>Python’s None Value</h5>&#13;
<p>That second call looks like it does nothing because the REPL doesn’t show <code>None</code>.&#13;
I’ll use the <code>type()</code> function to check the return.&#13;
<code>NoneType</code> is the type for the <code>None</code> value:<a data-primary="type() function" data-secondary="NoneType" data-type="indexterm" id="idm45963632465496"/><a data-primary="NoneType for None value" data-type="indexterm" id="idm45963632464552"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; type(counts.get('N'))&#13;
&lt;class 'NoneType'&gt;</pre>&#13;
&#13;
<p>I can use the <code>==</code> operator to see if the return value is <code>None</code>:<a data-primary="== (compare for equality)" data-primary-sortas="# compare for equality" data-type="indexterm" id="idm45963632461752"/><a data-primary="comparing for equality (==)" data-type="indexterm" id="idm45963632460792"/><a data-primary="equal signs" data-secondary="== (compare for equality)" data-secondary-sortas="# compare for equality" data-type="indexterm" id="idm45963632460104"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; counts.get('N') == None&#13;
True</pre>&#13;
&#13;
<p>but PEP8 recommends “Comparisons to singletons like <code>None</code> should always be done with <code>is</code> or <code>is not</code>, never the equality operators.”&#13;
The following is the prescribed method to check if a value is <code>None</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; counts.get('N') is None&#13;
True</pre>&#13;
</div></aside>&#13;
&#13;
<p>The <code>dict.get()</code> method accepts an optional second argument that is the default value to return when the key does not exist, so this is the safest way to return a 4-tuple of the base counts:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; counts.get('A', 0), counts.get('C', 0), counts.get('G', 0),&#13;
    counts.get('T', 0)&#13;
(1, 2, 3, 4)</pre>&#13;
<div data-type="tip">&#13;
<p>No matter what you write inside your <code>count()</code> function, ensure that it will pass the <code>test_count()</code> unit test.<a data-startref="ch01-dict" data-type="indexterm" id="idm45963632451064"/><a data-startref="ch01-dict2" data-type="indexterm" id="idm45963632450392"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 5: Counting Only the Desired Bases" data-type="sect2"><div class="sect2" id="idm45963632449240">&#13;
<h2>Solution 5: Counting Only the Desired Bases</h2>&#13;
&#13;
<p>The previous solution will count every character in the input sequence, but what if I only want to count the four nucleotides?<a data-primary="tetranucleotide frequency" data-secondary="solution 5 only desired bases counted" data-type="indexterm" id="idm45963632447800"/>&#13;
In this solution, I will initialize a dictionary with values of <code>0</code> for the wanted bases.&#13;
I’ll need to also bring in <code>typing.Dict</code> to run this code:</p>&#13;
&#13;
<pre data-type="programlisting">def count(dna: str) -&gt; Dict[str, int]: <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Count bases in DNA """&#13;
&#13;
    counts = {'A': 0, 'C': 0, 'G': 0, 'T': 0} <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-2"><img alt="2" src="assets/2.png"/></a>&#13;
    for base in dna: <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-3" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-3"><img alt="3" src="assets/3.png"/></a>&#13;
        if base in counts: <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-4" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-4"><img alt="4" src="assets/4.png"/></a>&#13;
            counts[base] += 1 <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-5" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-5"><img alt="5" src="assets/5.png"/></a>&#13;
&#13;
    return counts <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-6" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-6"><img alt="6" src="assets/6.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The signature now indicates I’ll be returning a dictionary that has strings for the keys and integers for the values.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Initialize the <code>counts</code> dictionary with the four bases as keys and values of <code>0</code>.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-3" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Iterate through the bases.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-4" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Check if the base is found as a key in the <code>counts</code> dictionary.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-5" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>If so, increment the <code>counts</code> for this base by 1.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-6" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Return the <code>counts</code> dictionary.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Since the <code>count()</code> function is now returning a dictionary rather than a tuple, the <code>test_count()</code> function needs to change:</p>&#13;
&#13;
<pre data-type="programlisting">def test_count() -&gt; None:&#13;
    """ Test count """&#13;
&#13;
    assert count('') == {'A': 0, 'C': 0, 'G': 0, 'T': 0} <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO25-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO25-1"><img alt="1" src="assets/1.png"/></a>&#13;
    assert count('123XYZ') == {'A': 0, 'C': 0, 'G': 0, 'T': 0} <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO25-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO25-2"><img alt="2" src="assets/2.png"/></a>&#13;
    assert count('A') == {'A': 1, 'C': 0, 'G': 0, 'T': 0}&#13;
    assert count('C') == {'A': 0, 'C': 1, 'G': 0, 'T': 0}&#13;
    assert count('G') == {'A': 0, 'C': 0, 'G': 1, 'T': 0}&#13;
    assert count('T') == {'A': 0, 'C': 0, 'G': 0, 'T': 1}&#13;
    assert count('ACCGGGTTTT') == {'A': 1, 'C': 2, 'G': 3, 'T': 4}</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO25-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO25-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The returned dictionary will always have the keys <code>A</code>, <code>C</code>, <code>G</code>, and <code>T</code>. Even for the empty string, these keys will be present and set to <code>0</code>.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO25-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO25-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>All the other tests have the same inputs, but now I check that the answer comes back as a dictionary.</p></dd>&#13;
</dl>&#13;
&#13;
<p>When writing these tests, note that the order of the keys in the dictionaries is not important.&#13;
The two dictionaries in the following code have the same content even though they were defined differently:<a data-primary="test-driven development (TDD)" data-secondary="documentation provided by" data-type="indexterm" id="idm45963632398312"/><a data-primary="documentation" data-secondary="tests providing" data-type="indexterm" id="idm45963632397336"/><a data-primary="best practices" data-secondary="documentation provided by tests" data-type="indexterm" id="idm45963632396392"/><a data-primary="reproducible programs" data-secondary="documentation provided by tests" data-type="indexterm" id="idm45963632395432"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; counts1 = {'A': 1, 'C': 2, 'G': 3, 'T': 4}&#13;
&gt;&gt;&gt; counts2 = {'T': 4, 'G': 3, 'C': 2, 'A': 1}&#13;
&gt;&gt;&gt; counts1 == counts2&#13;
True</pre>&#13;
<div data-type="note" epub:type="note">&#13;
<p>I would point out that the <code>test_count()</code> function tests the function to ensure it’s correct and also serves as documentation.&#13;
Reading these tests helps me see the structure of the possible inputs and expected outputs from the function.</p>&#13;
</div>&#13;
&#13;
<p>Here’s how I need to change the <code>main()</code> function to use the returned dictionary:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    counts = count(args.dna) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO26-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO26-1"><img alt="1" src="assets/1.png"/></a>&#13;
    print('{} {} {} {}'.format(counts['A'], counts['C'], counts['G'], <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO26-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO26-2"><img alt="2" src="assets/2.png"/></a>&#13;
                               counts['T']))</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO26-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO26-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>counts</code> is now a dictionary.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO26-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO26-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Use the <code>str.format()</code> method to create the output using the values from the <span class="keep-together">dictionary.</span></p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 6: Using collections.defaultdict()" data-type="sect2"><div class="sect2" id="idm45963632378360">&#13;
<h2>Solution 6: Using collections.defaultdict()</h2>&#13;
&#13;
<p>I can rid my code of all the previous efforts to initialize dictionaries and check for keys and such by using the <code>defaultdict()</code> function from the <code>collections</code> module:<a data-primary="tetranucleotide frequency" data-secondary="solution 6 using collections.defaultdict" data-type="indexterm" id="idm45963632376040"/><a data-primary="dictionaries" data-secondary="counting characters" data-tertiary="collections.defaultdict" data-type="indexterm" id="idm45963632375048"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from collections import defaultdict</pre>&#13;
&#13;
<p>When I use the <code>defaultdict()</code> function to create a new dictionary, I tell it the default type for the values.<a data-primary="dictionaries" data-secondary="defaultdict for value default types" data-type="indexterm" id="idm45963632372136"/><a data-primary="variables" data-secondary="defaultdict defining default type" data-type="indexterm" id="idm45963632371176"/><a data-primary="type error" data-secondary="defaultdict defining default type" data-type="indexterm" id="idm45963632370216"/>&#13;
I no longer have to check for a key before using it because the <code>defaultdict</code> type will automatically create any key I reference using a representative value of the default type.&#13;
For the case of counting the nucleotides, I want to use the <code>int</code> type:<a data-primary="integers (int)" data-secondary="nucleotides represented as" data-type="indexterm" id="idm45963632368008"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; counts = defaultdict(int)</pre>&#13;
&#13;
<p>The default <code>int</code> value will be <code>0</code>.&#13;
Any reference to a nonexistent key will cause it to be created with a value of <code>0</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; counts['A']&#13;
0</pre>&#13;
&#13;
<p>This means I can instantiate and increment any base in one step:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; counts['C'] += 1&#13;
&gt;&gt;&gt; counts&#13;
defaultdict(&lt;class 'int'&gt;, {'A': 0, 'C': 1})</pre>&#13;
&#13;
<p>Here is how I could rewrite the <code>count()</code> function using this idea:</p>&#13;
&#13;
<pre data-type="programlisting">def count(dna: str) -&gt; Dict[str, int]:&#13;
    """ Count bases in DNA """&#13;
&#13;
    counts: Dict[str, int] = defaultdict(int) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO27-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO27-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
    for base in dna:&#13;
        counts[base] += 1 <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO27-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO27-2"><img alt="2" src="assets/2.png"/></a>&#13;
&#13;
    return counts</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO27-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO27-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The <code>counts</code> will be a <code>defaultdict</code> with integer values. The type annotation here is required by <code>mypy</code> so that it can be sure that the returned value is correct.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO27-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO27-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>I can safely increment the <code>counts</code> for this base.</p></dd>&#13;
</dl>&#13;
&#13;
<p>The <code>test_count()</code> function looks quite different.&#13;
I can see at a glance that the answers are very different from the previous versions:</p>&#13;
&#13;
<pre data-type="programlisting">def test_count() -&gt; None:&#13;
    """ Test count """&#13;
&#13;
    assert count('') == {} <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO28-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO28-1"><img alt="1" src="assets/1.png"/></a>&#13;
    assert count('123XYZ') == {'1': 1, '2': 1, '3': 1, 'X': 1, 'Y': 1, 'Z': 1} <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO28-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO28-2"><img alt="2" src="assets/2.png"/></a>&#13;
    assert count('A') == {'A': 1} <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO28-3" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO28-3"><img alt="3" src="assets/3.png"/></a>&#13;
    assert count('C') == {'C': 1}&#13;
    assert count('G') == {'G': 1}&#13;
    assert count('T') == {'T': 1}&#13;
    assert count('ACCGGGTTTT') == {'A': 1, 'C': 2, 'G': 3, 'T': 4}</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO28-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO28-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Given an empty string, an empty dictionary will be returned.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO28-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO28-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Notice that every character in the string is a key in the dictionary.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO28-3" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO28-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Only <code>A</code> is present, with a count of 1.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Given the fact that the returned dictionary may not contain all the bases, the code in <code>main()</code> needs to use the <code>count.get()</code> method to retrieve each base’s frequency:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    counts = count(args.dna) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO29-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO29-1"><img alt="1" src="assets/1.png"/></a>&#13;
    print(counts.get('A', 0), counts.get('C', 0), counts.get('G', 0), <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO29-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO29-2"><img alt="2" src="assets/2.png"/></a>&#13;
          counts.get('T', 0))</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO29-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO29-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The <code>counts</code> will be a dictionary that may not contain all of the nucleotides.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO29-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO29-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>It’s safest to use the <code>dict.get()</code> method with a default value of <code>0</code>.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 7: Using collections.Counter()" data-type="sect2"><div class="sect2" id="idm45963632317384">&#13;
<h2>Solution 7: Using collections.Counter()</h2>&#13;
<blockquote>&#13;
<p>Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away.<a data-primary="Saint-Exupéry, Antoine de" data-type="indexterm" id="idm45963632315688"/></p>&#13;
<p data-type="attribution">Antoine de Saint-Exupéry</p>&#13;
</blockquote>&#13;
&#13;
<p>I don’t actually like the last three solutions all that much, but I needed to step through how to use a dictionary both manually and with <code>defaultdict()</code> so that you can appreciate the simplicity of using <code>collections.Counter()</code>:<a data-primary="tetranucleotide frequency" data-secondary="solution 7 using collections.Counter" data-type="indexterm" id="idm45963632312600"/><a data-primary="Counter() function" data-type="indexterm" id="idm45963632311624"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from collections import Counter&#13;
&gt;&gt;&gt; Counter('ACCGGGTTT')&#13;
Counter({'G': 3, 'T': 3, 'C': 2, 'A': 1})</pre>&#13;
&#13;
<p>The best code is code you never write, and <code>Counter()</code> is a prepackaged function that will return a dictionary with the frequency of the items contained in the iterable you pass it.<a data-primary="dictionaries" data-secondary="Counter() returning" data-type="indexterm" id="idm45963632309112"/><a data-primary="iterables" data-secondary="Counter() acting on" data-type="indexterm" id="idm45963632308168"/>&#13;
You might also hear this called a <em>bag</em> or a <em>multiset</em>.<a data-primary="bag data structure" data-type="indexterm" id="idm45963632306152"/><a data-primary="multiset data structure" data-type="indexterm" id="idm45963632305480"/>&#13;
Here the iterable is a string composed of characters, and so I get back the same dictionary as in the last two solutions, but <em>having written no code</em>.</p>&#13;
&#13;
<p>It’s so simple that you could pretty much eschew the <code>count()</code> and <code>test_count()</code> functions and integrate it directly into your <code>main()</code>:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    counts = Counter(args.dna) <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO30-1" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO30-1"><img alt="1" src="assets/1.png"/></a>&#13;
    print(counts.get('A', 0), counts.get('C', 0), counts.get('G', 0), <a class="co" href="#callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO30-2" id="co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO30-2"><img alt="2" src="assets/2.png"/></a>&#13;
          counts.get('T', 0))</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO30-1" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO30-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The <code>counts</code> will be a dictionary containing the frequencies of the characters in <code>args.dna</code>.</p></dd>&#13;
<dt><a class="co" href="#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO30-2" id="callout_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO30-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>It is still safest to use <code>dict.get()</code> as I cannot be certain that all the bases are present.</p></dd>&#13;
</dl>&#13;
&#13;
<p>I could argue that this code belongs in a <code>count()</code> function and keep the tests, but the <code>Counter()</code> function is already tested and has a well-defined interface.&#13;
I think it makes more sense to use this function inline.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Going Further" data-type="sect1"><div class="sect1" id="idm45963632287944">&#13;
<h1>Going Further</h1>&#13;
&#13;
<p>The solutions here only handle DNA sequences provided as UPPERCASE TEXT.<a data-primary="tetranucleotide frequency" data-secondary="solutions only UPPERCASE" data-type="indexterm" id="idm45963632286584"/><a data-primary="strings (str)" data-secondary="upper- and lowercase capabilities" data-type="indexterm" id="idm45963632285608"/><a data-primary="uppercase and lowercase capabilities" data-type="indexterm" id="idm45963632284648"/><a data-primary="lowercase and uppercase capabilities" data-type="indexterm" id="idm45963632283960"/>&#13;
It’s not unusual to see these sequences provided as lowercase letters.&#13;
For instance, in plant genomics, it’s common to use lowercase bases to denote regions of repetitive DNA.&#13;
Modify your program to handle both uppercase and lowercase input by doing the following:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Add a new input file that mixes case.</p>&#13;
</li>&#13;
<li>&#13;
<p>Add a test to <em>tests/dna_test.py</em> that uses this new file and specifies the expected counts insensitive to case.</p>&#13;
</li>&#13;
<li>&#13;
<p>Run the new test and ensure your program fails.</p>&#13;
</li>&#13;
<li>&#13;
<p>Alter the program until it will pass the new test and all of the previous tests.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>The solutions that used dictionaries to count all available characters would appear to be more flexible.&#13;
That is, some of the tests only account for the bases <em>A</em>, <em>C</em>, <em>G</em>, and <em>T</em>, but if the input sequence were encoded using <a href="https://oreil.ly/qGfsO">IUPAC codes</a> to represent possible ambiguity in sequencing, then the program would have to be entirely rewritten.<a data-primary="IUPAC codes" data-type="indexterm" id="idm45963632274984"/>&#13;
A program hard-coded to look only at the four nucleotides would also be useless for protein sequences that use a different alphabet.&#13;
Consider writing a version of the program that will print two columns of output with each character that is found in the first column and the character’s frequency in the second.&#13;
Allow the user to sort ascending or descending by either column.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review" data-type="sect1"><div class="sect1" id="idm45963632273464">&#13;
<h1>Review</h1>&#13;
&#13;
<p>This was kind of a monster chapter.&#13;
The following chapters will be a bit shorter, as I’ll build upon many of the foundational ideas I’ve covered here:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>You can use the <code>new.py</code> program to create the basic structure of a Python program that accepts and validates command-line arguments using <code>argparse</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>pytest</code> module will run all functions with names starting with <code>test_</code> and will report the results of how many tests pass.</p>&#13;
</li>&#13;
<li>&#13;
<p>Unit tests are for functions, and integration tests check if a program works as a whole.</p>&#13;
</li>&#13;
<li>&#13;
<p>Programs like <code>pylint</code>, <code>flake8</code>, and <code>mypy</code> can find various kinds of errors in your code. You can also have <code>pytest</code> automatically run tests to see if your code passes these checks.</p>&#13;
</li>&#13;
<li>&#13;
<p>Complicated commands can be stored as a target in a <em>Makefile</em> and executed using the <code>make</code> command.</p>&#13;
</li>&#13;
<li>&#13;
<p>You can create a decision tree using a series of <code>if</code>/<code>else</code> statements.</p>&#13;
</li>&#13;
<li>&#13;
<p>There are many ways to count all the characters in a string. Using the <code>collections.Counter()</code> function is perhaps the simplest method to create a dictionary of letter frequencies.</p>&#13;
</li>&#13;
<li>&#13;
<p>You can annotate variables and functions with types, and use <code>mypy</code> to ensure the types are used correctly.</p>&#13;
</li>&#13;
<li>&#13;
<p>The Python REPL is an interactive tool for executing code examples and reading documentation.</p>&#13;
</li>&#13;
<li>&#13;
<p>The Python community generally follows style guidelines such as PEP8. Tools like <code>yapf</code> and <code>black</code> can automatically format code according to these suggestions, and tools like <code>pylint</code> and <code>flake8</code> will report deviations from the <span class="keep-together">guidelines.</span></p>&#13;
</li>&#13;
<li>&#13;
<p>Python strings, lists, tuples, and dictionaries are very powerful data structures, each with useful methods and copious documentation.</p>&#13;
</li>&#13;
<li>&#13;
<p>You can create a custom, immutable, typed <code>class</code> derived from named tuples.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>You may be wondering which is the best of the seven solutions.&#13;
As with many things in life, it depends.&#13;
Some programs are shorter to write and easier to understand but may fare poorly when confronting large datasets.&#13;
In <a data-type="xref" href="ch02.html#ch02">Chapter 2</a>, I’ll show you how to <em>benchmark</em> programs, pitting them against each other in multiple runs using large inputs to determine which performs the best.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45963636356152"><sup><a href="ch01.html#idm45963636356152-marker">1</a></sup> Boolean types are <code>True</code> or <code>False</code>, but many other data types are <em>truthy</em> or conversely <em>falsey</em>. The empty <code>str</code> (<code>""</code>) is falsey, so any nonempty string is truthy. The number <code>0</code> is falsey, so any nonzero value is truthy. An empty <code>list</code>, <code>set</code>, or <code>dict</code> is falsey, so any nonempty one of those is truthy.</p></div></div></section></body></html>