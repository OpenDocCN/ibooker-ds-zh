<html><head></head><body><section data-pdf-bookmark="Chapter 6. Company Matching" data-type="chapter" epub:type="chapter"><div class="chapter" id="chapter_6">&#13;
<h1><span class="label">Chapter 6. </span>Company Matching</h1>&#13;
&#13;
<p>In<a contenteditable="false" data-primary="company matching" data-secondary="overview of" data-type="indexterm" id="id469"/> <a data-type="xref" href="ch05.html#chapter_5">Chapter 5</a>, we examined the challenge of resolving a larger set of individual entities, matching on name and date of birth. In this chapter, we consider another typical scenario, resolving organization entities so that we can get a more complete picture of their business.</p>&#13;
&#13;
<p>We could perhaps use the date of incorporation of the organization as a discriminator, similar to the way we used date of birth to help identify unique individuals. However, this incorporation date information is not typically included in organization datasets; it is much more common for a company to be identified by its registered address.</p>&#13;
&#13;
<p>Therefore, in this chapter, we will use company address information, along with company names, to identify likely matches. We will then consider how to evaluate a new record for matches against the original data sources without having to undertake a time-consuming retrain of the model.</p>&#13;
&#13;
<section data-pdf-bookmark="Sample Problem" data-type="sect1"><div class="sect1" id="id252">&#13;
<h1>Sample Problem</h1>&#13;
&#13;
<p>In this chapter, we will resolve a list of company names that is published by the UK Maritime and Coastguard Agency (MCA) against basic organization details published in the Companies House register. This problem illustrates some of the challenges of identifying unique references to the same company, simply based on name and address data.</p>&#13;
&#13;
<p>UK Companies House provides a free downloadable data snapshot containing basic company data of live companies on the register. This data complements the “person with significant control” data we used in <a data-type="xref" href="ch05.html#chapter_5">Chapter 5</a>.</p>&#13;
&#13;
<p>The MCA publishes a list of recruitment and placement agencies approved under Regulation 1.4 of the Maritime Labour Convention (MLC) 2006.<sup><a data-type="noteref" href="ch06.html#id470" id="id470-marker">1</a></sup></p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Data Acquisition" data-type="sect1"><div class="sect1" id="id50">&#13;
<h1>Data Acquisition</h1>&#13;
&#13;
<p>To<a contenteditable="false" data-primary="company matching" data-secondary="data acquisition" data-type="indexterm" id="id471"/><a contenteditable="false" data-primary="data, acquiring" data-secondary="Maritime and Coastguard Agency (MCA) data" data-secondary-sortas="company matching" data-type="indexterm" id="id472"/><a contenteditable="false" data-primary="Maritime and Coastguard Agency (MCA) data" data-secondary="acquiring" data-type="indexterm" id="id473"/> acquire the datasets, we use the same approach we used in <a data-type="xref" href="ch05.html#chapter_5">Chapter 5</a>. The MCA data, published as a single comma-separated values (CSV) file, is downloaded and ingested into a DataFrame. The<a contenteditable="false" data-primary="data, acquiring" data-secondary="UK Companies House data" data-type="indexterm" id="id474"/><a contenteditable="false" data-primary="UK Companies House data" data-secondary="acquiring" data-type="indexterm" id="id475"/> Companies House snapshot data is downloaded as ZIP files, and the extracted JSON structure is then parsed into a DataFrame. Unwanted columns are then removed and the snapshot DataFrames are concatenated into a single composite DataFrame. Both raw datasets are then stored locally as CSV files for ease of reloading.</p>&#13;
&#13;
<p>The<a contenteditable="false" data-primary="code examples, obtaining and using" data-type="indexterm" id="id476"/> code is available as <em>Chapter6.ipynb</em> in the <a href="https://github.com/mshearer0/HandsOnEntityResolution">GitHub repository</a>.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Data Standardization" data-type="sect1"><div class="sect1" id="id51">&#13;
<h1>Data Standardization</h1>&#13;
&#13;
<p>To<a contenteditable="false" data-primary="company matching" data-secondary="data standardization" data-type="indexterm" id="CMdstand06"/><a contenteditable="false" data-primary="data standardization" data-secondary="address format and content" data-type="indexterm" id="DSaddress06"/><a contenteditable="false" data-primary="address format and content" data-type="indexterm" id="address06"/> match the MCA company list to the Companies House organization dataset, we need to standardize the name and address data into the same format. We have seen how to cleanse names. Addresses, however, pose more of a challenge.  Even within reasonably consistent data from same source, we often see considerable variation in address format and content.</p>&#13;
&#13;
<p>For<a contenteditable="false" data-primary="Maritime and Coastguard Agency (MCA) data" data-secondary="standardizing for company matching" data-type="indexterm" id="MCAcompmatch06"/> example, consider the first three records in the MCA list, as shown in <a data-type="xref" href="#table-6-1">Table 6-1</a>.</p>&#13;
&#13;
<table id="table-6-1">&#13;
	<caption><span class="label">Table 6-1. </span>MCA sample addresses</caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th scope="col">Address attribute</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td>48 Charlotte Street, London, W1T 2NS</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>4th Floor, 105 George Street, Glasgow, G2 1PB</td>&#13;
		</tr>&#13;
	&#13;
		<tr>&#13;
			<td>Unit 16, Beaverbank Business Park EH7 4HG</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<p>We can see the first address is made up of three comma-separated elements, the second record by four elements, and the third again by only two. In each case, the postcode is contained in the final element, but in the third record, it is grouped with part of the address itself. The building number is present in either the first element or the second element.</p>&#13;
&#13;
<p class="pagebreak-before">To view a histogram distribution of the number of address elements in the MCA list we can use:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
import matplotlib.pyplot as plt&#13;
plt.hist(df_m.apply(lambda row: len(row['ADDRESS &amp; CONTACT&#13;
   DETAILS'].split(',')), axis=1).tolist())</pre>&#13;
&#13;
<p>This gives us the distribution chart presented in <a data-type="xref" href="#fig-6-1">Figure 6-1</a>.</p>&#13;
&#13;
<figure class="width-75"><div class="figure" id="fig-6-1"><img class="iimagesch06ch06addresselementcountpng" src="assets/hoer_0601.png"/>&#13;
<h6><span class="label">Figure 6-1. </span>MCA address element count</h6>&#13;
</div></figure>&#13;
&#13;
<p>This lack of consistency makes parsing addresses consistently into the same discrete elements for matching quite difficult. Therefore, for this example, we will use just exact postcode matches to compare addresses. More advanced parsing and matching techniques, such as natural language processing and geocoding, are discussed in <a data-type="xref" href="ch11.html#chapter_11">Chapter 11</a>.<a contenteditable="false" data-primary="" data-startref="MCAcompmatch06" data-type="indexterm" id="id477"/></p>&#13;
&#13;
<section data-pdf-bookmark="Companies House Data" data-type="sect2"><div class="sect2" id="id52">&#13;
<h2>Companies House Data</h2>&#13;
&#13;
<p>In<a contenteditable="false" data-primary="UK Companies House data" data-secondary="standardizing for company matching" data-type="indexterm" id="id478"/> many jurisdictions companies are required to declare the nature of their incorporation at the end of their name, for example, adding “Limited” or “Ltd” if they are constituted as a limited liability company. These variable suffixes may not always be present, so standardization is challenging.</p>&#13;
&#13;
<p>To ensure a mismatch doesn’t unduly negatively interfere with the matching process, it is advisable to separate these lower-value terms from the name record as part of the standardization process. This will remove the chance of missing a potential match due to inconsistencies in suffix format, at the risk of declaring a false positive match between, say, a public limited company and a limited company with similar names.</p>&#13;
&#13;
<p>In addition to removing incorporation suffixes, it can also be helpful to remove common terms that don’t differentiate between companies and whose inclusion would otherwise exaggerate the similarity of our name matches.</p>&#13;
&#13;
<p>Although we choose to remove these terms, or<a contenteditable="false" data-primary="stopwords" data-type="indexterm" id="id479"/> <em>stopwords</em>, from the company name attribute, they do still contain some value that may be useful when the decision to declare a match is in the balance.</p>&#13;
&#13;
<p>The following helper function strips these stopwords, returning the cleansed company name and the removed terms:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
def strip_stopwords(raw_name):&#13;
   company_stopwords = { 'LIMITED', 'LTD', 'SERVICES', 'COMPANY',&#13;
      'GROUP', 'PROPERTIES', 'CONSULTING', 'HOLDINGS', 'UK',&#13;
      'TRADING', 'LTD.', 'PLC','LLP' }&#13;
   name_without_stopwords = []&#13;
   stopwords = []&#13;
   for raw_name_part in raw_name.split():&#13;
      if raw_name_part in company_stopwords:&#13;
         stopwords.append(raw_name_part)&#13;
      else:&#13;
         name_without_stopwords.append(raw_name_part)&#13;
   return(' '.join(name_without_stopwords),&#13;
          ' '.join(stopwords))</pre>&#13;
&#13;
<p>We can apply this function to the Company House data using:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
df_c[['CompanyName','Stopwords']] =  pd.DataFrame(&#13;
   zip(*df_c['CompanyName'].apply(strip_stopwords))).T</pre>&#13;
&#13;
<p>The <code>*</code> operator unzips the series of <a contenteditable="false" data-primary="tuples, unzipping" data-type="indexterm" id="id480"/>tuples (containing <code>CompanyName</code> and <code>Stopwords</code>) returned by the helper function. We<a contenteditable="false" data-primary="pandas DataFrames" data-secondary="transposing columns" data-type="indexterm" id="id481"/> assemble these value lists into a two-row DataFrame that we then transpose to columns so that we can add as new attributes. This approach is efficient as we only have to create a new DataFrame once as opposed to per row.</p>&#13;
&#13;
<p>Because<a contenteditable="false" data-primary="pandas DataFrames" data-secondary="standardizing column names" data-type="indexterm" id="id482"/> we already have a discrete column containing a discrete postcode, all that remains is to standardize the column name:</p>&#13;
&#13;
<pre>&#13;
df_c = df_c.rename(columns={"RegAddress.PostCode": "Postcode"})</pre>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Maritime and Coastguard Agency Data" data-type="sect2"><div class="sect2" id="id53">&#13;
<h2>Maritime and Coastguard Agency Data</h2>&#13;
&#13;
<p>To<a contenteditable="false" data-primary="Maritime and Coastguard Agency (MCA) data" data-secondary="standardizing for company matching" data-type="indexterm" id="id483"/> standardize the MCA company name, we first convert the name to<a contenteditable="false" data-primary="case sensitivity" data-type="indexterm" id="id484"/><a contenteditable="false" data-primary="upper case, converting to" data-type="indexterm" id="id485"/> uppercase:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
df_m['CompanyName'] = df_m['COMPANY'].str.upper()</pre>&#13;
&#13;
<p>We also remove the stopwords and then we need to extract the postcode from the address field. A convenient way to do this is to use a<a contenteditable="false" data-primary="regular expressions" data-type="indexterm" id="id486"/> <em>regular expression</em>.</p>&#13;
&#13;
<div data-type="note" epub:type="note">&#13;
<h1>Regular Expression</h1>&#13;
&#13;
<p>A regular expression is a sequence of characters that specifies a match pattern in text. Usually such patterns are used by string-searching algorithms for “find” or “find and replace” operations on strings, or for input validation.</p>&#13;
</div>&#13;
&#13;
<p>A<a contenteditable="false" data-primary="postcodes" data-type="indexterm" id="id487"/> UK postcode is made up of two parts. The first part compromises one or two capital letters followed by a single digit and then either a single digit or a single capital letter. After a space, the second part begins with a single digit followed by two capital letters (excluding CIKMOV). This can be encoded as:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
r'([A-Z]{1,2}[0-9][A-Z0-9]? [0-9][ABD-HJLNP-UW-Z]{2})'</pre>&#13;
&#13;
<p>We can construct a helper function to find, extract, and return a matching pattern of characters or return a null value if not found:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
import re&#13;
def extract_postcode(address):&#13;
   pattern = re.compile(r'([A-Z]{1,2}[0-9][A-Z0-9]?&#13;
      [0-9][ABD-HJLNP-UW-Z]{2})')&#13;
   postcode = pattern.search(address)&#13;
   if(postcode is not None):&#13;
   return postcode.group()&#13;
      else:&#13;
   return None</pre>&#13;
&#13;
<p>As before, we can apply this function to every<a contenteditable="false" data-primary="" data-startref="address06" data-type="indexterm" id="id488"/><a contenteditable="false" data-primary="" data-startref="DSaddress06" data-type="indexterm" id="id489"/><a contenteditable="false" data-primary="" data-startref="CMdstand06" data-type="indexterm" id="id490"/> row:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
df_m['Postcode'] = df_m.apply(lambda row:&#13;
   extract_postcode(row['ADDRESS &amp; CONTACT DETAILS']), axis=1)</pre>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Record Blocking and Attribute Comparison" data-type="sect1"><div class="sect1" id="id54">&#13;
<h1>Record Blocking and Attribute Comparison</h1>&#13;
&#13;
<p>As<a contenteditable="false" data-primary="company matching" data-secondary="record blocking and attribute comparison" data-type="indexterm" id="CMrclockatcomp06"/><a contenteditable="false" data-primary="attribute comparison" data-secondary="for record blocking" data-secondary-sortas="record blocking" data-type="indexterm" id="Acomp06"/><a contenteditable="false" data-primary="attribute comparison" data-secondary="for company matching" data-secondary-sortas="company matching" data-type="indexterm" id="ACcompmatch06"/> in the previous chapter, we will use the<a contenteditable="false" data-primary="Splink" data-secondary="record blocking for company matching" data-type="indexterm" id="Scompmatch06"/> Splink tool to perform the matching process. Let’s consider the settings that will allow us to do this.</p>&#13;
&#13;
<p>First, we can expect organizations with matching postcodes to be reasonable match candidates and similarly those with exactly equivalent names. We can use these conditions as our<a contenteditable="false" data-primary="blocking rules" data-secondary="configuring with Splink" data-type="indexterm" id="id491"/> blocking rules, only calculating predictions when either condition is fulfilled:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
 "blocking_rules_to_generate_predictions":&#13;
   ["l.Postcode = r.Postcode",&#13;
    "l.CompanyName = r.CompanyName", ],</pre>&#13;
&#13;
<p>Splink provides a handy visualization for us to see the volume of record pairs that will pass the blocking rules. As expected, there are a significant number of postcode matches and very few exact name matches, as shown in <a data-type="xref" href="#fig-6-2">Figure 6-2</a>.</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
linker.cumulative_num_comparisons_from_blocking_rules_chart()</pre>&#13;
&#13;
<figure><div class="figure" id="fig-6-2"><img alt="" class="iimagesch06ch06blockingrulespng" src="assets/hoer_0602.png"/>&#13;
<h6><span class="label">Figure 6-2. </span>Blocking rule comparisons</h6>&#13;
</div></figure>&#13;
&#13;
<p>Within that subset of potential combinations, we evaluate the similarity of the selected pair of <code>CompanyName</code> entries in four segments:</p>&#13;
&#13;
<ul>&#13;
	<li>Exact match</li>&#13;
	<li>Jaro-Winkler score of &gt;0.9</li>&#13;
	<li>Jaro-Winkler score between 0.8 and 0.9</li>&#13;
	<li>Jaro-Winkler score of &lt;0.8</li>&#13;
</ul>&#13;
&#13;
<p>We also evaluate the stopwords in a similar manner.</p>&#13;
&#13;
<p>The corresponding Splink settings are:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
"comparisons": [&#13;
   cl.jaro_winkler_at_thresholds("CompanyName", [0.9,0.8]),&#13;
   cl.jaro_winkler_at_thresholds("Stopwords",[0.9]),&#13;
], </pre>&#13;
&#13;
<p>Of course, those pairs that pass the blocking rule as exact name equivalents will be evaluated as exact matches, whereas those with only a postcode match will be evaluated as candidates for both exact and approximate name matching.</p>&#13;
&#13;
<p>Before we can apply the blocking rules and calculate our match probabilities, we need to train our model. The<a contenteditable="false" data-primary="pandas DataFrames" data-secondary="cross-product dataset" data-type="indexterm" id="id492"/> Cartesian product of the two DataFrames is &gt;500 million pairwise combinations, so we train the <em>u</em> value using random sampling over 50 million target rows to have a reasonable sample:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
linker.estimate_u_using_random_sampling(max_pairs=5e7)</pre>&#13;
&#13;
<p>As in <a data-type="xref" href="ch05.html#chapter_5">Chapter 5</a>, we use the<a contenteditable="false" data-primary="expectation-maximization (EM) algorithm" data-type="indexterm" id="id493"/><a contenteditable="false" data-primary="EM (expectation-maximization) model" data-secondary="algorithm" data-type="indexterm" id="id494"/> expectation-maximization algorithm to estimate the <em>m</em> values. Here we block on only matching postcodes because the tiny relative proportion of name matches has no beneficial effect on the parameter estimation:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
linker.estimate_parameters_using_expectation_maximisation(&#13;
   "l.Postcode = r.Postcode")</pre>&#13;
&#13;
<p>We can display the proportion of records in each segment that the trained model observes using:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
linker.match_weights_chart()</pre>&#13;
&#13;
<p>The record comparison chart, seen in <a data-type="xref" href="#fig-6-3">Figure 6-3</a>, shows a strong differentiation on <code>CompanyName</code> similarity between matching and nonmatching records. For the stopwords, there is only a marked differentiation between the approximately matching records at similarity threshold equal to or greater than 0.9, but not exact.</p>&#13;
&#13;
<figure><div class="figure" id="fig-6-3"><img alt="" class="iimagesch06ch06recordproportionpng" src="assets/hoer_0603.png"/>&#13;
<h6><span class="label">Figure 6-3. </span>Proportion of record comparisons by match status</h6>&#13;
</div></figure>&#13;
&#13;
<p>As expected, the parameters chart (as shown in <a data-type="xref" href="#fig-6-4">Figure 6-4</a>) shows that exact and approximate <code>CompanyName</code> matches have strong match weights:<a contenteditable="false" data-primary="" data-startref="CMrclockatcomp06" data-type="indexterm" id="id495"/><a contenteditable="false" data-primary="" data-startref="Scompmatch06" data-type="indexterm" id="id496"/><a contenteditable="false" data-primary="" data-startref="Acomp06" data-type="indexterm" id="id497"/><a contenteditable="false" data-primary="" data-startref="ACcompmatch06" data-type="indexterm" id="id498"/></p>&#13;
&#13;
<pre data-type="programlisting">&#13;
linker.m_u_parameters_chart()</pre>&#13;
&#13;
<figure><div class="figure" id="fig-6-4"><img alt="" class="iimagesch06ch06modelparameterspng" src="assets/hoer_0604.png"/>&#13;
<h6><span class="label">Figure 6-4. </span>Model parameters</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Match Classification" data-type="sect1"><div class="sect1" id="id55">&#13;
<h1>Match Classification</h1>&#13;
&#13;
<p>In<a contenteditable="false" data-primary="company matching" data-secondary="match classification" data-type="indexterm" id="CMcatchclass06"/><a contenteditable="false" data-primary="match classification" data-type="indexterm" id="mclass06"/><a contenteditable="false" data-primary="Maritime and Coastguard Agency (MCA) data" data-secondary="match classification" data-type="indexterm" id="MCAmclass06"/><a contenteditable="false" data-primary="UK Companies House data" data-secondary="match classification" data-type="indexterm" id="UKmatch06"/> this example, we expect to find a match for each of the MCA organizations in the Companies House dataset, so we set a low match threshold of 0.05 to make sure we surface as many potential matches as possible:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
df_pred = linker.predict(threshold_match_probability=0.05)&#13;
   .as_pandas_dataframe()</pre>&#13;
&#13;
<p>To identify the MCA entities where we failed to find at least one match, we can merge our predictions with the MCA dataset by <code>unique_id</code> and then select those results with a null match weight:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
results = df_m.merge(df_pred,left_on=['unique_id'], right_on=&#13;
   ['unique_id_r'],how='left', suffixes=('_m', '_p'))&#13;
results[results['match_weight'].isnull()]</pre>&#13;
&#13;
<p>As shown in <a data-type="xref" href="#fig-6-5">Figure 6-5</a>, this produces 11 records for which we didn’t find any match.</p>&#13;
&#13;
<figure><div class="figure" id="fig-6-5"><img alt="" class="iimagesch06ch06nomatchpng" src="assets/hoer_0605.png"/>&#13;
<h6><span class="label">Figure 6-5. </span>Unmatched records</h6>&#13;
</div></figure>&#13;
&#13;
<p>At the time of writing, a manual search of Companies House reveals that 7 of these 11 entities have candidate matches, but these candidates do not have exact matching postcodes or names and so were filtered out by our blocking rules. Two of these entities have candidates with exact match postcodes but significantly different names and so fall below our approximate similarity threshold. Finally, the two remaining candidates  have been dissolved and so are not included in our live companies snapshot.</p>&#13;
&#13;
<p>A convenient way to examine the predicted matches and the contribution that an attribute makes to the overall match score is to draw a match weight waterfall chart:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
linker.waterfall_chart(df_pred.to_dict(orient="records"))</pre>&#13;
&#13;
<p>In the example given in <a data-type="xref" href="#fig-6-6">Figure 6-6</a>, we can see that the prior match weight, a measure of the likelihood that two records chosen at random refer to the same entity, is –13.29. From this starting point, we add a match weight of 20.92 when we find an exact match of the <code>CompanyName</code> “Bespoke Crew.” This represents the degree to which it’s more likely to find exact equivalence on <code>CompanyName</code> within the <code>match</code> population than within the <code>notmatch</code> population.</p> &#13;
&#13;
<figure><div class="figure" id="fig-6-6"><img class="iimagesch06ch06matchweightspng" src="assets/hoer_0606.png"/>&#13;
<h6><span class="label">Figure 6-6. </span>Match weights waterfall chart</h6>&#13;
</div></figure>&#13;
&#13;
<p>However, we also need to subtract 0.45 due to the exact match on “Limited,” as an exact equivalent on stopwords is more likely to occur on <code>notmatch</code>es as opposed to <code>match</code>es. This gives us a final match weight of 7.19, which translates into a probability of almost 1.0.</p>&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Measuring Performance" data-type="sect1"><div class="sect1" id="id56">&#13;
<h1>Measuring Performance</h1>&#13;
&#13;
<p>After<a contenteditable="false" data-primary="" data-startref="CMcatchclass06" data-type="indexterm" id="id499"/><a contenteditable="false" data-primary="" data-startref="MCAmclass06" data-type="indexterm" id="id500"/><a contenteditable="false" data-primary="" data-startref="UKmatch06" data-type="indexterm" id="id501"/><a contenteditable="false" data-primary="company matching" data-secondary="measuring performance" data-type="indexterm" id="CMmperf06"/><a contenteditable="false" data-primary="performance, measuring" data-secondary="company matching" data-type="indexterm" id="PMcmatch06"/><a contenteditable="false" data-primary="Maritime and Coastguard Agency (MCA) data" data-secondary="low versus high match thresholds" data-type="indexterm" id="MCAlowthresh06"/> standardizing, the MCA data has 96 organizations.</p>&#13;
&#13;
<p>At a 0.05 match threshold, our results are shown in <a data-type="xref" href="#table-6-2">Table 6-2</a>.</p>&#13;
&#13;
<table id="table-6-2">&#13;
	<caption><span class="label">Table 6-2. </span>MCA match results—low threshold</caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th scope="col"><strong>Match threshold = 0.05</strong></th>&#13;
			<th scope="col"><strong>Number of matches</strong></th>&#13;
			<th scope="col"><strong>Unique entities matched</strong></th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td>Name and postcode match</td>&#13;
			<td>47</td>&#13;
			<td>45</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Name match only</td>&#13;
			<td>37</td>&#13;
			<td>31</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Postcode match only</td>&#13;
			<td>116</td>&#13;
			<td>27</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>Total matches</strong></td>&#13;
			<td><b>200</b></td>&#13;
			<td><strong>85 (deduped)</strong></td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Unmatched</td>&#13;
			<td> </td>&#13;
			<td>11 (of which 2 dissolved)</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>Total organizations</strong></td>&#13;
			<td> </td>&#13;
			<td><strong>96</strong></td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<p>If we assume the deduped unique matches are true positive matches, 9 of the 11 unmatched entities are false negatives, and the 2 dissolved entities are true negatives, then we can evaluate our performance as:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper T r u e p o s i t i v e m a t c h e s left-parenthesis upper T upper P right-parenthesis equals 85">&#13;
  <mrow>&#13;
    <mi>T</mi>&#13;
    <mi>r</mi>&#13;
    <mi>u</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mi>p</mi>&#13;
    <mi>o</mi>&#13;
    <mi>s</mi>&#13;
    <mi>i</mi>&#13;
    <mi>t</mi>&#13;
    <mi>i</mi>&#13;
    <mi>v</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mi>e</mi>&#13;
    <mi>s</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mo>(</mo>&#13;
    <mi>T</mi>&#13;
    <mi>P</mi>&#13;
    <mo>)</mo>&#13;
    <mo>=</mo>&#13;
    <mn>85</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper F a l s e p o s i t i v e m a t c h e s left-parenthesis upper F upper P right-parenthesis equals 200 minus 85 equals 115">&#13;
  <mrow>&#13;
    <mi>F</mi>&#13;
    <mi>a</mi>&#13;
    <mi>l</mi>&#13;
    <mi>s</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mi>p</mi>&#13;
    <mi>o</mi>&#13;
    <mi>s</mi>&#13;
    <mi>i</mi>&#13;
    <mi>t</mi>&#13;
    <mi>i</mi>&#13;
    <mi>v</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mi>e</mi>&#13;
    <mi>s</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mo>(</mo>&#13;
    <mi>F</mi>&#13;
    <mi>P</mi>&#13;
    <mo>)</mo>&#13;
    <mo>=</mo>&#13;
    <mn>200</mn>&#13;
    <mo>-</mo>&#13;
    <mn>85</mn>&#13;
    <mo>=</mo>&#13;
    <mn>115</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper F a l s e n e g a t i v e m a t c h e s left-parenthesis upper F upper N right-parenthesis equals 11 minus 2 equals 9">&#13;
  <mrow>&#13;
    <mi>F</mi>&#13;
    <mi>a</mi>&#13;
    <mi>l</mi>&#13;
    <mi>s</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mi>n</mi>&#13;
    <mi>e</mi>&#13;
    <mi>g</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>i</mi>&#13;
    <mi>v</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mi>e</mi>&#13;
    <mi>s</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mo>(</mo>&#13;
    <mi>F</mi>&#13;
    <mi>N</mi>&#13;
    <mo>)</mo>&#13;
    <mo>=</mo>&#13;
    <mn>11</mn>&#13;
    <mo>-</mo>&#13;
    <mn>2</mn>&#13;
    <mo>=</mo>&#13;
    <mn>9</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper T r u e n e g a t i v e s equals 2">&#13;
  <mrow>&#13;
    <mi>T</mi>&#13;
    <mi>r</mi>&#13;
    <mi>u</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>n</mi>&#13;
    <mi>e</mi>&#13;
    <mi>g</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>i</mi>&#13;
    <mi>v</mi>&#13;
    <mi>e</mi>&#13;
    <mi>s</mi>&#13;
    <mo>=</mo>&#13;
    <mn>2</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper P r e c i s i o n equals StartFraction upper T upper P Over left-parenthesis upper T upper P plus upper F upper P right-parenthesis EndFraction equals StartFraction 85 Over left-parenthesis 85 plus 115 right-parenthesis EndFraction almost-equals 42 percent-sign">&#13;
  <mrow>&#13;
    <mi>P</mi>&#13;
    <mi>r</mi>&#13;
    <mi>e</mi>&#13;
    <mi>c</mi>&#13;
    <mi>i</mi>&#13;
    <mi>s</mi>&#13;
    <mi>i</mi>&#13;
    <mi>o</mi>&#13;
    <mi>n</mi>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mi>T</mi><mi>P</mi></mrow> <mrow><mo>(</mo><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>P</mi><mo>)</mo></mrow></mfrac>&#13;
    <mo>=</mo>&#13;
    <mfrac><mn>85</mn> <mrow><mo>(</mo><mn>85</mn><mo>+</mo><mn>115</mn><mo>)</mo></mrow></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mn>42</mn>&#13;
    <mo>%</mo>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper R e c a l l equals StartFraction upper T upper P Over left-parenthesis upper T upper P plus upper F upper N right-parenthesis EndFraction equals StartFraction 85 Over left-parenthesis 85 plus 9 right-parenthesis EndFraction almost-equals 90 percent-sign">&#13;
  <mrow>&#13;
    <mi>R</mi>&#13;
    <mi>e</mi>&#13;
    <mi>c</mi>&#13;
    <mi>a</mi>&#13;
    <mi>l</mi>&#13;
    <mi>l</mi>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mi>T</mi><mi>P</mi></mrow> <mrow><mo>(</mo><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi><mo>)</mo></mrow></mfrac>&#13;
    <mo>=</mo>&#13;
    <mfrac><mn>85</mn> <mrow><mo>(</mo><mn>85</mn><mo>+</mo><mn>9</mn><mo>)</mo></mrow></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mn>90</mn>&#13;
    <mo>%</mo>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper A c c u r a c y equals StartFraction left-parenthesis upper T upper P plus upper T upper N right-parenthesis Over left-parenthesis upper T upper P plus upper T upper N plus upper F upper P plus upper F upper N right-parenthesis EndFraction equals StartFraction left-parenthesis 85 plus 2 right-parenthesis Over left-parenthesis 85 plus 2 plus 115 plus 9 right-parenthesis EndFraction almost-equals 41 percent-sign">&#13;
  <mrow>&#13;
    <mi>A</mi>&#13;
    <mi>c</mi>&#13;
    <mi>c</mi>&#13;
    <mi>u</mi>&#13;
    <mi>r</mi>&#13;
    <mi>a</mi>&#13;
    <mi>c</mi>&#13;
    <mi>y</mi>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mo>(</mo><mi>T</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>N</mi><mo>)</mo></mrow> <mrow><mo>(</mo><mi>T</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>N</mi><mo>+</mo><mi>F</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi><mo>)</mo></mrow></mfrac>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mo>(</mo><mn>85</mn><mo>+</mo><mn>2</mn><mo>)</mo></mrow> <mrow><mo>(</mo><mn>85</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>115</mn><mo>+</mo><mn>9</mn><mo>)</mo></mrow></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mn>41</mn>&#13;
    <mo>%</mo>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>Recalculating our predictions at a threshold of 0.9 removes postcode-only matches, giving us the results shown in <a data-type="xref" href="#table-6-3">Table 6-3</a>.</p>&#13;
&#13;
<table id="table-6-3">&#13;
	<caption><span class="label">Table 6-3. </span>MCA match result—high threshold</caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th scope="col"><strong>Match threshold = 0.9</strong></th>&#13;
			<th scope="col"><strong>Number of matches</strong></th>&#13;
			<th scope="col"><strong>Unique entities matched</strong></th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td>Name and postcode match</td>&#13;
			<td>47</td>&#13;
			<td>45</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Name match only</td>&#13;
			<td>37</td>&#13;
			<td>31</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Postcode match only</td>&#13;
			<td>3</td>&#13;
			<td>1</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>Total matches</strong></td>&#13;
			<td><b>87</b></td>&#13;
			<td><strong>73 (deduped)</strong></td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Unmatched</td>&#13;
			<td> </td>&#13;
			<td>23 (of which 2 dissolved)</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>Total organizations</strong></td>&#13;
			<td> </td>&#13;
			<td><strong>96</strong></td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<div class="pagebreak-before less_space" data-type="equation">&#13;
<p><math alttext="upper T r u e p o s i t i v e m a t c h e s left-parenthesis upper T upper P right-parenthesis equals 73">&#13;
  <mrow>&#13;
    <mi>T</mi>&#13;
    <mi>r</mi>&#13;
    <mi>u</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mi>p</mi>&#13;
    <mi>o</mi>&#13;
    <mi>s</mi>&#13;
    <mi>i</mi>&#13;
    <mi>t</mi>&#13;
    <mi>i</mi>&#13;
    <mi>v</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mi>e</mi>&#13;
    <mi>s</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mo>(</mo>&#13;
    <mi>T</mi>&#13;
    <mi>P</mi>&#13;
    <mo>)</mo>&#13;
    <mo>=</mo>&#13;
    <mn>73</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper F a l s e p o s i t i v e m a t c h e s left-parenthesis upper F upper P right-parenthesis equals 87 minus 73 equals 14">&#13;
  <mrow>&#13;
    <mi>F</mi>&#13;
    <mi>a</mi>&#13;
    <mi>l</mi>&#13;
    <mi>s</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mi>p</mi>&#13;
    <mi>o</mi>&#13;
    <mi>s</mi>&#13;
    <mi>i</mi>&#13;
    <mi>t</mi>&#13;
    <mi>i</mi>&#13;
    <mi>v</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mi>e</mi>&#13;
    <mi>s</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mo>(</mo>&#13;
    <mi>F</mi>&#13;
    <mi>P</mi>&#13;
    <mo>)</mo>&#13;
    <mo>=</mo>&#13;
    <mn>87</mn>&#13;
    <mo>-</mo>&#13;
    <mn>73</mn>&#13;
    <mo>=</mo>&#13;
    <mn>14</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper F a l s e n e g a t i v e m a t c h e s left-parenthesis upper F upper N right-parenthesis equals 23 minus 2 equals 21">&#13;
  <mrow>&#13;
    <mi>F</mi>&#13;
    <mi>a</mi>&#13;
    <mi>l</mi>&#13;
    <mi>s</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mi>n</mi>&#13;
    <mi>e</mi>&#13;
    <mi>g</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>i</mi>&#13;
    <mi>v</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mi>e</mi>&#13;
    <mi>s</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mo>(</mo>&#13;
    <mi>F</mi>&#13;
    <mi>N</mi>&#13;
    <mo>)</mo>&#13;
    <mo>=</mo>&#13;
    <mn>23</mn>&#13;
    <mo>-</mo>&#13;
    <mn>2</mn>&#13;
    <mo>=</mo>&#13;
    <mn>21</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper T r u e n e g a t i v e s equals 2">&#13;
  <mrow>&#13;
    <mi>T</mi>&#13;
    <mi>r</mi>&#13;
    <mi>u</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>n</mi>&#13;
    <mi>e</mi>&#13;
    <mi>g</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>i</mi>&#13;
    <mi>v</mi>&#13;
    <mi>e</mi>&#13;
    <mi>s</mi>&#13;
    <mo>=</mo>&#13;
    <mn>2</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper P r e c i s i o n equals StartFraction upper T upper P Over left-parenthesis upper T upper P plus upper F upper P right-parenthesis EndFraction equals StartFraction 73 Over left-parenthesis 73 plus 14 right-parenthesis EndFraction almost-equals 84 percent-sign">&#13;
  <mrow>&#13;
    <mi>P</mi>&#13;
    <mi>r</mi>&#13;
    <mi>e</mi>&#13;
    <mi>c</mi>&#13;
    <mi>i</mi>&#13;
    <mi>s</mi>&#13;
    <mi>i</mi>&#13;
    <mi>o</mi>&#13;
    <mi>n</mi>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mi>T</mi><mi>P</mi></mrow> <mrow><mo>(</mo><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>P</mi><mo>)</mo></mrow></mfrac>&#13;
    <mo>=</mo>&#13;
    <mfrac><mn>73</mn> <mrow><mo>(</mo><mn>73</mn><mo>+</mo><mn>14</mn><mo>)</mo></mrow></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mn>84</mn>&#13;
    <mo>%</mo>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper R e c a l l equals StartFraction upper T upper P Over left-parenthesis upper T upper P plus upper F upper N right-parenthesis EndFraction equals StartFraction 73 Over left-parenthesis 73 plus 21 right-parenthesis EndFraction almost-equals 78 percent-sign">&#13;
  <mrow>&#13;
    <mi>R</mi>&#13;
    <mi>e</mi>&#13;
    <mi>c</mi>&#13;
    <mi>a</mi>&#13;
    <mi>l</mi>&#13;
    <mi>l</mi>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mi>T</mi><mi>P</mi></mrow> <mrow><mo>(</mo><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi><mo>)</mo></mrow></mfrac>&#13;
    <mo>=</mo>&#13;
    <mfrac><mn>73</mn> <mrow><mo>(</mo><mn>73</mn><mo>+</mo><mn>21</mn><mo>)</mo></mrow></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mn>78</mn>&#13;
    <mo>%</mo>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper A c c u r a c y equals StartFraction left-parenthesis upper T upper P plus upper T upper N right-parenthesis Over left-parenthesis upper T upper P plus upper T upper N plus upper F upper P plus upper F upper N right-parenthesis EndFraction equals StartFraction left-parenthesis 73 plus 2 right-parenthesis Over left-parenthesis 73 plus 2 plus 14 plus 21 right-parenthesis EndFraction almost-equals 69 percent-sign">&#13;
  <mrow>&#13;
    <mi>A</mi>&#13;
    <mi>c</mi>&#13;
    <mi>c</mi>&#13;
    <mi>u</mi>&#13;
    <mi>r</mi>&#13;
    <mi>a</mi>&#13;
    <mi>c</mi>&#13;
    <mi>y</mi>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mo>(</mo><mi>T</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>N</mi><mo>)</mo></mrow> <mrow><mo>(</mo><mi>T</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>N</mi><mo>+</mo><mi>F</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi><mo>)</mo></mrow></mfrac>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mo>(</mo><mn>73</mn><mo>+</mo><mn>2</mn><mo>)</mo></mrow> <mrow><mo>(</mo><mn>73</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>14</mn><mo>+</mo><mn>21</mn><mo>)</mo></mrow></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mn>69</mn>&#13;
    <mo>%</mo>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>Therefore, as expected, we see that a higher match threshold increases our precision from 42% to 86%, but at the cost of missing nearly twice as many potential matches (up from 9 to 21 false negatives).</p>&#13;
&#13;
<p>Tuning an entity resolution solution requires a degree of trial and error, adjusting blocking rules, similarity thresholds, and overall match thresholds to find the optimum balance. This will depend heavily on the characteristics of your data and your risk appetite for failing to identify potential matches.<a contenteditable="false" data-primary="" data-startref="PMcmatch06" data-type="indexterm" id="id502"/><a contenteditable="false" data-primary="" data-startref="CMmperf06" data-type="indexterm" id="id503"/><a contenteditable="false" data-primary="" data-startref="MCAlowthresh06" data-type="indexterm" id="id504"/></p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Matching New Entities" data-type="sect1"><div class="sect1" id="id57">&#13;
<h1>Matching New Entities</h1>&#13;
&#13;
<p>As<a contenteditable="false" data-primary="company matching" data-secondary="matching new entities" data-type="indexterm" id="id505"/><a contenteditable="false" data-primary="new entities, matching" data-type="indexterm" id="id506"/> we have seen, model training is not a quick process. What if we have a new entity, say a new entry onto the MCA list, that we’d like to resolve against the Companies House data? Splink<a contenteditable="false" data-primary="Splink" data-secondary="matching new entities" data-type="indexterm" id="id507"/> provides the option to match new records against previously matched datasets without retraining. We can also use this feature to find all potential matches, without the constraint of blocking rules or match thresholds, to help us understand why those candidates weren’t identified. For example, if we take the last entity in our unmatched population:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
record = {&#13;
   'unique_id': 1,&#13;
   'Postcode': "BH15 4QE",&#13;
   'CompanyName':"VANTAGE YACHT RECRUITMENT",&#13;
   'Stopwords':""&#13;
}&#13;
&#13;
df_new = linker.find_matches_to_new_records([record],&#13;
   match_weight_threshold=0).as_pandas_dataframe()&#13;
df_new.sort_values("match_weight", ascending=False)</pre>&#13;
&#13;
<p>This results in a full list of candidate matches, the first four of which, with the highest match probabilities, are listed in <a data-type="xref" href="#fig-6-7">Figure 6-7</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig-6-7"><img alt="" class="iimagesch06ch06newmatchespng" src="assets/hoer_0607.png"/>&#13;
<h6><span class="label">Figure 6-7. </span>New potential matches</h6>&#13;
</div></figure>&#13;
&#13;
<p>The first entry in the table is the original record in the MCA dataset. The next three records, as candidates matches from the Companies House data, don’t have exact postcodes or name matches and so would have been excluded by our blocking rules. However, the second record does have a somewhat similar name and a close match on postcode and so looks like a good potential candidate.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="id253">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter, we used a combination of name and address matching to resolve company entities across two datasets. We separated stopwords from our organization names and employed a regular expression to extract postcodes for comparison.</p>&#13;
&#13;
<p>We used exact equivalence blocking rules and then calculated our match probabilities based on name similarity above a threshold. We evaluated our results by examining the trade-off between setting a low match threshold that produced a relatively large number of false positives and using a high threshold with the consequence that we missed some potentially promising match candidates.</p>&#13;
&#13;
<p>This chapter has also illustrated that, even employing blocking techniques, entity resolution at scale can become a time-consuming and compute-intensive task. In subsequent chapters we will examine how to leverage cloud computing infrastructure to distribute our matching workload across a number of machines in parallel.</p>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="id470"><sup><a href="ch06.html#id470-marker">1</a></sup> MLC 2006 regulates the operation of seafarer recruitment and placement services to inform seafarers seeking employment on ships flying flags other than those of their own countries.</p></div></div></section></body></html>