<html><head></head><body><section data-pdf-bookmark="Chapter 4. Probabilistic Matching" data-type="chapter" epub:type="chapter"><div class="chapter" id="chapter_4">&#13;
<h1><span class="label">Chapter 4. </span>Probabilistic Matching</h1>&#13;
&#13;
<p>In <a data-type="xref" href="ch03.html#chapter_3">Chapter 3</a>, we explored how to use approximate matching techniques to measure the degree of similarity between attribute values. We set a threshold above which we declared equivalence and then combined these matching features, with equal weight, to conclude that two records referred to the same entity when both were a match. We evaluated our performance against exact matches only.</p>&#13;
&#13;
<p>In this chapter, we will examine how to use<a contenteditable="false" data-primary="probabilistic matching" data-secondary="benefits of" data-type="indexterm" id="id415"/> probability-based techniques to calculate the optimum weighting for each equivalent attribute in calculating the likelihood of an overall entity match. This probability-based approach allows us to declare a match when the most statistically significant attributes are equivalent (either exact or approximate) but those with less significance are insufficiently similar. It also allows us to grade our confidence in the declaration of a match and apply appropriate match thresholds. The model that will be introduced in this section is known as the Fellegi-Sunter (FS) model.</p>&#13;
&#13;
<p>We will also introduce a probabilistic entity resolution framework, Splink, that we will use to help us calculate these metrics and resolve our entities together.</p>&#13;
&#13;
<section data-pdf-bookmark="Sample Problem" data-type="sect1"><div class="sect1" id="id114">&#13;
<h1>Sample Problem</h1>&#13;
&#13;
<p>Let’s return to our exact match results from the end of <a data-type="xref" href="ch02.html#chapter_2">Chapter 2</a>. Opening the <em>Chapter4.ipynb</em> notebook we reload the standardized datasets from the Wikipedia and TheyWorkForYou websites. As in <a data-type="xref" href="ch03.html#chapter_3">Chapter 3</a>, we start by<a contenteditable="false" data-primary="Wikipedia data" data-secondary="cross-product dataset" data-type="indexterm" id="id416"/><a contenteditable="false" data-primary="TheyWorkForYou data" data-secondary="cross-product dataset" data-type="indexterm" id="id417"/> calculating the Cartesian, or cross, product of the two datasets as:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
cross = df_w.merge(df_t, how='cross', suffixes=('_w', '_t'))</pre>&#13;
&#13;
<p>This gives us our total population of 650 × 650 = 422,500 record pairs—a pair for every name combination between the Wikipedia and TheyWorkForYou datasets.</p>&#13;
&#13;
<p>Throughout this chapter, we will be using exact matches between the <code>Firstname</code>, <code>Lastname</code>, and <code>Constituency</code> fields of each of these record pairs multiple times. Thus, it’s more efficient to calculate these matches once and store them as additional feature columns:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
cross['Fmatch']= (cross['Firstname_w']==cross['Firstname_t'])&#13;
cross['Lmatch']= (cross['Lastname_w']==cross['Lastname_t'])&#13;
cross['Cmatch']= (cross['Constituency_w']==cross['Constituency_t'])</pre>&#13;
&#13;
<p>We also calculate the total number of matching columns, which we will use later:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
cross['Tmatch'] =&#13;
    sum([cross['Fmatch'],cross['Lmatch'],cross['Cmatch']]) </pre>&#13;
&#13;
<p>Based on our exploration of the data in <a data-type="xref" href="ch02.html#chapter_2">Chapter 2</a>, we know that within our total population of 422,500 combinations we have 637 record pairs that have an exact match on constituency and either first name or last name. This is our <code>match</code> population:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
match = cross[cross['Cmatch'] &amp; (cross['Fmatch'] |&#13;
   cross['Lmatch'])]</pre>&#13;
&#13;
<p>The remainder, our <code>notmatch</code> population, is extracted as the inverse:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
notmatch = cross[(~cross['Cmatch']) | (~cross['Fmatch'] &amp;&#13;
    ~cross['Lmatch'])]</pre>&#13;
&#13;
<p>These combinations are summarized in <a data-type="xref" href="#table-4-1">Table 4-1</a>.</p>&#13;
&#13;
<table id="table-4-1">&#13;
	<caption><span class="label">Table 4-1. </span>Match and not match combinations</caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th scope="col">Match/not match population</th>&#13;
			<th scope="col">Constituency match</th>&#13;
			<th scope="col">First name match</th>&#13;
			<th scope="col">Last name match</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td>Not match</td>&#13;
			<td>No</td>&#13;
			<td>No</td>&#13;
			<td>No</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Not match</td>&#13;
			<td>No</td>&#13;
			<td>No</td>&#13;
			<td>Yes</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Not match</td>&#13;
			<td>No</td>&#13;
			<td>Yes</td>&#13;
			<td>No</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Not match</td>&#13;
			<td>No</td>&#13;
			<td>Yes</td>&#13;
			<td>Yes</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Not match</td>&#13;
			<td>Yes</td>&#13;
			<td>No</td>&#13;
			<td>No</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Match</td>&#13;
			<td>Yes</td>&#13;
			<td>No</td>&#13;
			<td>Yes</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Match</td>&#13;
			<td>Yes</td>&#13;
			<td>Yes</td>&#13;
			<td>No</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Match</td>&#13;
			<td>Yes</td>&#13;
			<td>Yes</td>&#13;
			<td>Yes</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<p>We will now examine how well first name and last name equivalence, both individually and together, can predict whether an individual record belongs in either the <code>match</code> or <code>notmatch</code> population.</p>&#13;
</div></section>&#13;
&#13;
<section class="pagebreak-before" data-pdf-bookmark="Single Attribute Match Probability" data-type="sect1"><div class="sect1" id="id32">&#13;
<h1 class="less_space">Single Attribute Match Probability</h1>&#13;
&#13;
<p>Let’s begin<a contenteditable="false" data-primary="probabilistic matching" data-secondary="single attribute match probability" data-type="indexterm" id="PMsingle04"/><a contenteditable="false" data-primary="attributes" data-secondary="single attribute match probability" data-type="indexterm" id="Asingle04"/> by considering whether first name equivalence alone is a good indicator that two entities within a record pair refer to the same person. We will examine both the <code>match</code> and <code>notmatch</code> populations and establish, within each of those subsets, how many first names match and how many do not.</p>&#13;
&#13;
<div data-type="note" epub:type="note">&#13;
<h1>Naming Convention</h1>&#13;
&#13;
<p>As<a contenteditable="false" data-primary="naming conventions, standardizing" data-type="indexterm" id="id418"/> we work through various subsets of these populations, it’s helpful to adopt a standard naming convention so that we can see at a glance how each population of records was selected. As we select records we add the selection criteria to the population name, right to left, e.g., <code>first_match</code> should be read as first selecting those records that are part of the <code>match</code> population and within that subset of the population further selecting only those rows where the first names are equivalent.</p>&#13;
</div>&#13;
&#13;
<section data-pdf-bookmark="First Name Match Probability" data-type="sect2"><div class="sect2" id="id247">&#13;
<h2>First Name Match Probability</h2>&#13;
&#13;
<p>Starting with the <code>match</code> population we can select those records where the first names are equivalent to give us our <code>first_match</code> population:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
first_match = match[match['Fmatch']]&#13;
&#13;
<strong>len(first_match)</strong>&#13;
632</pre>&#13;
&#13;
<p>Repeating this for the three other combinations of match/not match, and first name equivalence or not, we can draw up a population map, as shown in <a data-type="xref" href="#fig-4-1">Figure 4-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig-4-1"><img alt="" class="iimagesch04ch04firstnamepng" src="assets/hoer_0401.png"/>&#13;
<h6><span class="label">Figure 4-1. </span>First name population map</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">Therefore, based on first name equivalence only, we have:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper T r u e p o s i t i v e m a t c h e s left-parenthesis upper T upper P right-parenthesis equals 632">&#13;
  <mrow>&#13;
    <mi>T</mi>&#13;
    <mi>r</mi>&#13;
    <mi>u</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mi>p</mi>&#13;
    <mi>o</mi>&#13;
    <mi>s</mi>&#13;
    <mi>i</mi>&#13;
    <mi>t</mi>&#13;
    <mi>i</mi>&#13;
    <mi>v</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mi>e</mi>&#13;
    <mi>s</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mo>(</mo>&#13;
    <mi>T</mi>&#13;
    <mi>P</mi>&#13;
    <mo>)</mo>&#13;
    <mo>=</mo>&#13;
    <mn>632</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper F a l s e p o s i t i v e m a t c h e s left-parenthesis upper F upper P right-parenthesis equals 2052">&#13;
  <mrow>&#13;
    <mi>F</mi>&#13;
    <mi>a</mi>&#13;
    <mi>l</mi>&#13;
    <mi>s</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mi>p</mi>&#13;
    <mi>o</mi>&#13;
    <mi>s</mi>&#13;
    <mi>i</mi>&#13;
    <mi>t</mi>&#13;
    <mi>i</mi>&#13;
    <mi>v</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mi>e</mi>&#13;
    <mi>s</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mo>(</mo>&#13;
    <mi>F</mi>&#13;
    <mi>P</mi>&#13;
    <mo>)</mo>&#13;
    <mo>=</mo>&#13;
    <mn>2052</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper T r u e n e g a t i v e m a t c h e s left-parenthesis upper T upper N right-parenthesis equals 419811">&#13;
  <mrow>&#13;
    <mi>T</mi>&#13;
    <mi>r</mi>&#13;
    <mi>u</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mi>n</mi>&#13;
    <mi>e</mi>&#13;
    <mi>g</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>i</mi>&#13;
    <mi>v</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mi>e</mi>&#13;
    <mi>s</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mo>(</mo>&#13;
    <mi>T</mi>&#13;
    <mi>N</mi>&#13;
    <mo>)</mo>&#13;
    <mo>=</mo>&#13;
    <mn>419811</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper F a l s e n e g a t i v e m a t c h e s left-parenthesis upper F upper N right-parenthesis equals 5">&#13;
  <mrow>&#13;
    <mi>F</mi>&#13;
    <mi>a</mi>&#13;
    <mi>l</mi>&#13;
    <mi>s</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mi>n</mi>&#13;
    <mi>e</mi>&#13;
    <mi>g</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>i</mi>&#13;
    <mi>v</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mi>e</mi>&#13;
    <mi>s</mi>&#13;
    <mspace width="0.166667em"/>&#13;
    <mo>(</mo>&#13;
    <mi>F</mi>&#13;
    <mi>N</mi>&#13;
    <mo>)</mo>&#13;
    <mo>=</mo>&#13;
    <mn>5</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>Now we can calculate some probability values. First, the probability that a record pair whose first names are equivalent is actually a true positive match can be calculated as the number of pairs within the <code>match</code> population whose first names match divided by the number of pairs whose first names match across both the <code>match</code> and <code>notmatch</code> populations:</p>&#13;
&#13;
&#13;
<p><math alttext="p r o b normal bar m a t c h normal bar f i r s t equals StartFraction l e n left-parenthesis f i r s t normal bar m a t c h right-parenthesis Over left-parenthesis l e n left-parenthesis f i r s t normal bar m a t c h right-parenthesis plus l e n left-parenthesis f i r s t normal bar n o t m a t c h right-parenthesis right-parenthesis EndFraction equals StartFraction 632 Over left-parenthesis 632 plus 2052 right-parenthesis EndFraction almost-equals 0.2355">&#13;
  <mrow>&#13;
    <mi>p</mi>&#13;
    <mi>r</mi>&#13;
    <mi>o</mi>&#13;
    <mi>b</mi>&#13;
    <mo>_</mo>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mo>_</mo>&#13;
    <mi>f</mi>&#13;
    <mi>i</mi>&#13;
    <mi>r</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow> <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>)</mo></mrow></mfrac>&#13;
    <mo>=</mo>&#13;
    <mfrac><mn>632</mn> <mrow><mo>(</mo><mn>632</mn><mo>+</mo><mn>2052</mn><mo>)</mo></mrow></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mn>0</mn>&#13;
    <mo>.</mo>&#13;
    <mn>2355</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p>From this we can see that, at only about 23%, first name equivalence alone isn’t a great predictor of a match between two records. This value is a conditional probability, that is, it is the probability of a true positive match conditional on the first name being a match. This can be written as:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis">&#13;
  <mrow>&#13;
    <mi>P</mi>&#13;
    <mo>(</mo>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mo>|</mo>&#13;
    <mi>f</mi>&#13;
    <mi>i</mi>&#13;
    <mi>r</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mo>)</mo>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>where the pipe character (|) is read as “given that.”</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Last Name Match Probability" data-type="sect2"><div class="sect2" id="id33">&#13;
<h2>Last Name Match Probability</h2>&#13;
&#13;
<p>Applying the same calculations to the last name, we can draw a second population map, as shown in <a data-type="xref" href="#fig-4-2">Figure 4-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig-4-2"><img alt="" class="iimagesch04ch04lastnamepng" src="assets/hoer_0402.png"/>&#13;
<h6><span class="label">Figure 4-2. </span>Last name population map</h6>&#13;
</div></figure>&#13;
&#13;
<p>As for first name, the probability that a pair of records whose last names are equivalent is actually a match can be calculated as the number of pairs within the <code>match</code> population whose last names match divided by the number of pairs whose last names match across both the <code>match</code> and <code>notmatch</code> populations.</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="p r o b normal bar m a t c h normal bar l a s t equals StartFraction l e n left-parenthesis l a s t normal bar m a t c h right-parenthesis Over left-parenthesis l e n left-parenthesis l a s t normal bar m a t c h right-parenthesis plus l e n left-parenthesis l a s t normal bar n o t m a t c h right-parenthesis right-parenthesis EndFraction equals StartFraction 633 Over left-parenthesis 633 plus 349 right-parenthesis EndFraction almost-equals 0.6446">&#13;
  <mrow>&#13;
    <mi>p</mi>&#13;
    <mi>r</mi>&#13;
    <mi>o</mi>&#13;
    <mi>b</mi>&#13;
    <mo>_</mo>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mo>_</mo>&#13;
    <mi>l</mi>&#13;
    <mi>a</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow> <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>)</mo></mrow></mfrac>&#13;
    <mo>=</mo>&#13;
    <mfrac><mn>633</mn> <mrow><mo>(</mo><mn>633</mn><mo>+</mo><mn>349</mn><mo>)</mo></mrow></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mn>0</mn>&#13;
    <mo>.</mo>&#13;
    <mn>6446</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>For these records last name equivalence is clearly a better predictor of a true match than first name, which instinctively makes sense.</p>&#13;
&#13;
<p>Again, this can be written<a contenteditable="false" data-primary="" data-startref="Asingle04" data-type="indexterm" id="id419"/><a contenteditable="false" data-primary="" data-startref="PMsingle04" data-type="indexterm" id="id420"/> as:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper P left-parenthesis m a t c h vertical-bar l a s t right-parenthesis">&#13;
  <mrow>&#13;
    <mi>P</mi>&#13;
    <mo>(</mo>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mo>|</mo>&#13;
    <mi>l</mi>&#13;
    <mi>a</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mo>)</mo>&#13;
  </mrow>&#13;
</math></p></div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Multiple Attribute Match Probability" data-type="sect1"><div class="sect1" id="id115">&#13;
<h1>Multiple Attribute Match Probability</h1>&#13;
&#13;
<p>Now<a contenteditable="false" data-primary="probabilistic matching" data-secondary="multiple attribute match probability" data-type="indexterm" id="id421"/><a contenteditable="false" data-primary="attributes" data-secondary="multiple attribute match probability" data-type="indexterm" id="id422"/> if we consider both first name and last name equivalence we can further subdivide our population map. Starting with our first name map and further subdividing each first name category into last name equivalence, and not, we can view our population as shown in <a data-type="xref" href="#fig-4-3">Figure 4-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig-4-3"><img alt="" class="iimagesch04ch04firstnamelastnamepng" src="assets/hoer_0403.png"/>&#13;
<h6><span class="label">Figure 4-3. </span>First name, last name population map</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">Extending our calculation to both first name and last name exact matches, we can calculate the probability of a true positive match given both first name and last name equivalence as:</p>&#13;
&#13;
<p><math alttext="p r o b normal bar m a t c h normal bar l a s t normal bar f i r s t equals StartFraction l e n left-parenthesis l a s t normal bar f i r s t normal bar m a t c h right-parenthesis Over left-parenthesis l e n left-parenthesis l a s t normal bar f i r s t normal bar m a t c h right-parenthesis plus l e n left-parenthesis l a s t normal bar f i r s t normal bar n o t m a t c h right-parenthesis EndFraction equals StartFraction 628 Over left-parenthesis 628 plus 0 right-parenthesis EndFraction equals 1.0">&#13;
  <mrow>&#13;
    <mi>p</mi>&#13;
    <mi>r</mi>&#13;
    <mi>o</mi>&#13;
    <mi>b</mi>&#13;
    <mo>_</mo>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mo>_</mo>&#13;
    <mi>l</mi>&#13;
    <mi>a</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mo>_</mo>&#13;
    <mi>f</mi>&#13;
    <mi>i</mi>&#13;
    <mi>r</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow> <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow></mfrac>&#13;
    <mspace width="4.pt"/>&#13;
    <mo>=</mo>&#13;
    <mfrac><mn>628</mn> <mrow><mo>(</mo><mn>628</mn><mo>+</mo><mn>0</mn><mo>)</mo></mrow></mfrac>&#13;
    <mo>=</mo>&#13;
    <mn>1</mn>&#13;
    <mo>.</mo>&#13;
    <mn>0</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p>If the first name matches but last name doesn’t, what is the probability that it’s a match?</p>&#13;
&#13;
<p><math alttext="p r o b normal bar m a t c h normal bar n o t l a s t normal bar f i r s t equals StartFraction l e n left-parenthesis n o t l a s t normal bar f i r s t normal bar m a t c h right-parenthesis Over left-parenthesis l e n left-parenthesis n o t l a s t normal bar f i r s t normal bar m a t c h right-parenthesis plus l e n left-parenthesis n o t l a s t normal bar f i r s t normal bar n o t m a t c h right-parenthesis right-parenthesis EndFraction equals StartFraction 4 Over left-parenthesis 4 plus 2052 right-parenthesis EndFraction almost-equals 0.0019">&#13;
  <mrow>&#13;
    <mi>p</mi>&#13;
    <mi>r</mi>&#13;
    <mi>o</mi>&#13;
    <mi>b</mi>&#13;
    <mo>_</mo>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mo>_</mo>&#13;
    <mi>n</mi>&#13;
    <mi>o</mi>&#13;
    <mi>t</mi>&#13;
    <mi>l</mi>&#13;
    <mi>a</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mo>_</mo>&#13;
    <mi>f</mi>&#13;
    <mi>i</mi>&#13;
    <mi>r</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow> <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>)</mo></mrow></mfrac>&#13;
    <mo>=</mo>&#13;
    <mfrac><mn>4</mn> <mrow><mo>(</mo><mn>4</mn><mo>+</mo><mn>2052</mn><mo>)</mo></mrow></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mn>0</mn>&#13;
    <mo>.</mo>&#13;
    <mn>0019</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p>If the first name doesn’t match but the last name does, what is the probability that it’s a match?</p>&#13;
&#13;
<p><math alttext="p r o b normal bar m a t c h normal bar l a s t normal bar n o t f i r s t equals StartFraction l e n left-parenthesis l a s t normal bar n o t f i r s t normal bar m a t c h right-parenthesis Over left-parenthesis l e n left-parenthesis l a s t normal bar n o t f i r s t normal bar m a t c h right-parenthesis plus l e n left-parenthesis l a s t normal bar n o t f i r s t normal bar n o t m a t c h right-parenthesis right-parenthesis EndFraction equals StartFraction 5 Over left-parenthesis 5 plus 349 right-parenthesis EndFraction almost-equals 0.0141">&#13;
  <mrow>&#13;
    <mi>p</mi>&#13;
    <mi>r</mi>&#13;
    <mi>o</mi>&#13;
    <mi>b</mi>&#13;
    <mo>_</mo>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mo>_</mo>&#13;
    <mi>l</mi>&#13;
    <mi>a</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mo>_</mo>&#13;
    <mi>n</mi>&#13;
    <mi>o</mi>&#13;
    <mi>t</mi>&#13;
    <mi>f</mi>&#13;
    <mi>i</mi>&#13;
    <mi>r</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow> <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>)</mo></mrow></mfrac>&#13;
    <mo>=</mo>&#13;
    <mfrac><mn>5</mn> <mrow><mo>(</mo><mn>5</mn><mo>+</mo><mn>349</mn><mo>)</mo></mrow></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mn>0</mn>&#13;
    <mo>.</mo>&#13;
    <mn>0141</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p>As we expected, if either first name or last name isn’t an exact match, then the probability of a true positive match is low, but a last name match gives us more confidence than a first name one.</p>&#13;
&#13;
<p>If neither first name nor last name matches, the probability that it is a match is:</p>&#13;
&#13;
<p><math alttext="p r o b normal bar m a t c h normal bar n o t l a s t normal bar n o t f i r s t equals">&#13;
  <mrow>&#13;
    <mi>p</mi>&#13;
    <mi>r</mi>&#13;
    <mi>o</mi>&#13;
    <mi>b</mi>&#13;
    <mo>_</mo>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mo>_</mo>&#13;
    <mi>n</mi>&#13;
    <mi>o</mi>&#13;
    <mi>t</mi>&#13;
    <mi>l</mi>&#13;
    <mi>a</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mo>_</mo>&#13;
    <mi>n</mi>&#13;
    <mi>o</mi>&#13;
    <mi>t</mi>&#13;
    <mi>f</mi>&#13;
    <mi>i</mi>&#13;
    <mi>r</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mo>=</mo>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="StartFraction l e n left-parenthesis n o t l a s t normal bar n o t f i r s t normal bar m a t c h right-parenthesis Over left-parenthesis l e n left-parenthesis n o t l a s t normal bar n o t f i r s t normal bar m a t c h right-parenthesis plus l e n left-parenthesis n o t l a s t normal bar n o t f i r s t normal bar n o t m a t c h right-parenthesis right-parenthesis EndFraction equals StartFraction 0 Over left-parenthesis 0 plus 419462 right-parenthesis EndFraction equals 0">&#13;
  <mrow>&#13;
    <mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow> <mrow><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>)</mo></mrow></mfrac>&#13;
    <mo>=</mo>&#13;
    <mfrac><mn>0</mn> <mrow><mo>(</mo><mn>0</mn><mo>+</mo><mn>419462</mn><mo>)</mo></mrow></mfrac>&#13;
    <mo>=</mo>&#13;
    <mn>0</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p>This is not surprising given that we defined true positive matches as records with an exact match on constituency and either first name or last name.</p>&#13;
&#13;
<p>In conclusion, we can use these probabilities to inform our decision making on whether we are likely to have a true positive match or not. In this example, we would place more weight on a last name match than a first name one. This is an improvement on our method in <a data-type="xref" href="ch03.html#chapter_3">Chapter 3</a>, where we gave them the same weighting (and required them both to be equivalent) to declare a match.</p>&#13;
&#13;
<p>But wait, we have a problem. In the preceding example, we started with a known population of matches that we used to compute the probabilities that first name and last name equivalence equate to a match. However, in most situations we don’t have a known <code>match</code> population; otherwise we wouldn’t need to perform matching in the first place! How do we overcome this? To do so, we need to reframe our calculation a little and then employ some clever estimation techniques.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Probabilistic Models" data-type="sect1"><div class="sect1" id="probabilistic-models">&#13;
<h1>Probabilistic Models</h1>&#13;
&#13;
<p>In<a contenteditable="false" data-primary="probabilistic matching" data-secondary="models for" data-type="indexterm" id="PMmodels04"/> the previous section, we learned that some attributes are more informative than others; that is, they have more predictive power to help us decide whether a match is likely to be correct. In this section, we examine how to calculate these contributions and how to combine them to assess the overall likelihood of a match.</p>&#13;
&#13;
<p>We start with a little statistical theory (using first name equivalence as an example) before we generalize to model what we can deploy at scale.</p>&#13;
&#13;
<section data-pdf-bookmark="Bayes’ Theorem" data-type="sect2"><div class="sect2" id="id34">&#13;
<h2>Bayes’ Theorem</h2>&#13;
&#13;
<p><em>Bayes’ theorem</em>, named after<a contenteditable="false" data-primary="Bayes’ theorem" data-type="indexterm" id="id423"/> Thomas Bayes, states that the conditional probability of an event, based on the occurrence of another event, is equal to the probability of the second event given the first event, multiplied by the probability of the first event.</p>&#13;
&#13;
<p>Consider the probability that two records chosen at random are a true positive match, P(match), multiplied by the probability that within those matches the first names match, P (first|match):</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper P left-parenthesis f i r s t vertical-bar m a t c h right-parenthesis times upper P left-parenthesis m a t c h right-parenthesis">&#13;
  <mrow>&#13;
    <mi>P</mi>&#13;
    <mo>(</mo>&#13;
    <mi>f</mi>&#13;
    <mi>i</mi>&#13;
    <mi>r</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mo>|</mo>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mo>)</mo>&#13;
    <mo>×</mo>&#13;
    <mi>P</mi>&#13;
    <mo>(</mo>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mo>)</mo>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>Equally, we could calculate the same value in the reverse order, starting with the probability that the first name matches, P(first) multiplied by the probability that records within this population are a true positive match:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis times upper P left-parenthesis f i r s t right-parenthesis">&#13;
  <mrow>&#13;
    <mi>P</mi>&#13;
    <mo>(</mo>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mo>|</mo>&#13;
    <mi>f</mi>&#13;
    <mi>i</mi>&#13;
    <mi>r</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mo>)</mo>&#13;
    <mo>×</mo>&#13;
    <mi>P</mi>&#13;
    <mo>(</mo>&#13;
    <mi>f</mi>&#13;
    <mi>i</mi>&#13;
    <mi>r</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mo>)</mo>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>Equating these probabilities, we have:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis times upper P left-parenthesis f i r s t right-parenthesis equals upper P left-parenthesis f i r s t vertical-bar m a t c h right-parenthesis times upper P left-parenthesis m a t c h right-parenthesis">&#13;
  <mrow>&#13;
    <mi>P</mi>&#13;
    <mo>(</mo>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mo>|</mo>&#13;
    <mi>f</mi>&#13;
    <mi>i</mi>&#13;
    <mi>r</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mo>)</mo>&#13;
    <mo>×</mo>&#13;
    <mi>P</mi>&#13;
    <mo>(</mo>&#13;
    <mi>f</mi>&#13;
    <mi>i</mi>&#13;
    <mi>r</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mo>)</mo>&#13;
    <mo>=</mo>&#13;
    <mi>P</mi>&#13;
    <mo>(</mo>&#13;
    <mi>f</mi>&#13;
    <mi>i</mi>&#13;
    <mi>r</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mo>|</mo>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mo>)</mo>&#13;
    <mo>×</mo>&#13;
    <mi>P</mi>&#13;
    <mo>(</mo>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mo>)</mo>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>Rearranging we can calculate:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis equals StartFraction upper P left-parenthesis f i r s t vertical-bar m a t c h right-parenthesis times upper P left-parenthesis m a t c h right-parenthesis Over upper P left-parenthesis f i r s t right-parenthesis EndFraction">&#13;
  <mrow>&#13;
    <mi>P</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>|</mo>&#13;
      <mi>f</mi>&#13;
      <mi>i</mi>&#13;
      <mi>r</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>×</mo><mi>P</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow> <mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>)</mo></mrow></mfrac>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>We can calculate P(first) as the sum of the probabilities across both the <code>match</code> and <code>notmatch</code> populations:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p>&#13;
<math display="block">&#13;
  <mtable columnalign="right left" displaystyle="true">&#13;
    <mtr>&#13;
      <mtd class="tml-right" style="padding:0.7ex 0em 0.7ex 0em;">&#13;
        <mrow>&#13;
          <mi>P</mi>&#13;
          <mo form="prefix" stretchy="false">(</mo>&#13;
          <mi>f</mi>&#13;
          <mi>i</mi>&#13;
          <mi>r</mi>&#13;
          <mi>s</mi>&#13;
          <mi>t</mi>&#13;
          <mo form="postfix" stretchy="false">)</mo>&#13;
        </mrow>&#13;
      </mtd>&#13;
      <mtd class="tml-left" style="padding:0.7ex 0em 0.7ex 0em;">&#13;
        <mrow>&#13;
          <mo>=</mo>&#13;
          <mo form="prefix" stretchy="false">(</mo>&#13;
          <mi>P</mi>&#13;
          <mo form="prefix" stretchy="false">(</mo>&#13;
          <mi>f</mi>&#13;
          <mi>i</mi>&#13;
          <mi>r</mi>&#13;
          <mi>s</mi>&#13;
          <mi>t</mi>&#13;
          <mi>|</mi>&#13;
          <mi>m</mi>&#13;
          <mi>a</mi>&#13;
          <mi>t</mi>&#13;
          <mi>c</mi>&#13;
          <mi>h</mi>&#13;
          <mo form="postfix" stretchy="false">)</mo>&#13;
          <mo>×</mo>&#13;
          <mi>P</mi>&#13;
          <mo form="prefix" stretchy="false">(</mo>&#13;
          <mi>m</mi>&#13;
          <mi>a</mi>&#13;
          <mi>t</mi>&#13;
          <mi>c</mi>&#13;
          <mi>h</mi>&#13;
          <mo form="postfix" stretchy="false">)</mo>&#13;
        </mrow>&#13;
      </mtd>&#13;
    </mtr>&#13;
    <mtr>&#13;
      <mtd class="tml-right" style="padding:0.7ex 0em 0.7ex 0em;">&#13;
        <mrow/>&#13;
      </mtd>&#13;
      <mtd class="tml-left" style="padding:0.7ex 0em 0.7ex 0em;">&#13;
        <mrow>&#13;
          <mtext>&#13;
          </mtext>&#13;
          <mo>+</mo>&#13;
          <mi>P</mi>&#13;
          <mo form="prefix" stretchy="false">(</mo>&#13;
          <mi>f</mi>&#13;
          <mi>i</mi>&#13;
          <mi>r</mi>&#13;
          <mi>s</mi>&#13;
          <mi>t</mi>&#13;
          <mi>|</mi>&#13;
          <mi>n</mi>&#13;
          <mi>o</mi>&#13;
          <mi>t</mi>&#13;
          <mi>m</mi>&#13;
          <mi>a</mi>&#13;
          <mi>t</mi>&#13;
          <mi>c</mi>&#13;
          <mi>h</mi>&#13;
          <mo form="postfix" stretchy="false">)</mo>&#13;
          <mo>×</mo>&#13;
          <mi>P</mi>&#13;
          <mo form="prefix" stretchy="false">(</mo>&#13;
          <mi>n</mi>&#13;
          <mi>o</mi>&#13;
          <mi>t</mi>&#13;
          <mi>m</mi>&#13;
          <mi>a</mi>&#13;
          <mi>t</mi>&#13;
          <mi>c</mi>&#13;
          <mi>h</mi>&#13;
          <mo form="postfix" stretchy="false">)</mo>&#13;
          <mo form="postfix" stretchy="false">)</mo>&#13;
        </mrow>&#13;
      </mtd>&#13;
    </mtr>&#13;
  </mtable>&#13;
</math>&#13;
</p>&#13;
</div>&#13;
&#13;
&#13;
<p>Substituting in the preceding equation, we have:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis equals StartFraction upper P left-parenthesis f i r s t vertical-bar m a t c h right-parenthesis times upper P left-parenthesis m a t c h right-parenthesis Over upper P left-parenthesis f i r s t vertical-bar m a t c h right-parenthesis times upper P left-parenthesis m a t c h right-parenthesis plus upper P left-parenthesis f i r s t vertical-bar n o t m a t c h right-parenthesis times upper P left-parenthesis n o t m a t c h right-parenthesis EndFraction">&#13;
  <mrow>&#13;
    <mi>P</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>|</mo>&#13;
      <mi>f</mi>&#13;
      <mi>i</mi>&#13;
      <mi>r</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>×</mo><mi>P</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow> <mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>×</mo><mi>P</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>+</mo><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>×</mo><mi>P</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow></mfrac>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>Alternatively, we can rearrange this as:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis equals 1 minus left-parenthesis 1 plus StartFraction upper P left-parenthesis f i r s t vertical-bar m a t c h right-parenthesis Over upper P left-parenthesis f i r s t vertical-bar n o t m a t c h right-parenthesis EndFraction times StartFraction upper P left-parenthesis m a t c h right-parenthesis Over upper P left-parenthesis n o t m a t c h right-parenthesis EndFraction right-parenthesis Superscript negative 1">&#13;
  <mrow>&#13;
    <mi>P</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>|</mo>&#13;
      <mi>f</mi>&#13;
      <mi>i</mi>&#13;
      <mi>r</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>=</mo>&#13;
    <mn>1</mn>&#13;
    <mo>-</mo>&#13;
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow> <mrow><mi>P</mi><mo>(</mo><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo>|</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><mrow><mi>P</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow> <mrow><mi>P</mi><mo>(</mo><mi>n</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow> </msup>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>If we can estimate the values in this equation, we can determine the probability that if a first name is equivalent, then the record pair really is a match.</p>&#13;
&#13;
<p>Let’s examine these values in a little more detail, simplifying the notation as we go along.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="m Value" data-type="sect2"><div class="sect2" id="id35">&#13;
<h2>m Value</h2>&#13;
&#13;
<p>The<a contenteditable="false" data-primary="m value" data-type="indexterm" id="id424"/> conditional probability that an attribute will be equivalent within the overall <code>match</code> population is known as the <em>m value</em>. Using our <code>Firstname</code> example, we can denote this as:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="m Subscript f Baseline equals upper P left-parenthesis f i r s t vertical-bar m a t c h right-parenthesis">&#13;
  <mrow>&#13;
    <msub><mi>m</mi> <mi>f</mi> </msub>&#13;
    <mo>=</mo>&#13;
    <mi>P</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>f</mi>&#13;
      <mi>i</mi>&#13;
      <mi>r</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mo>|</mo>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>In a perfect dataset, all the first names within the <code>match</code> population would be exactly equivalent and the <em>m</em> value would be 1. This value can therefore be thought of as a measure of data quality, i.e., how much variability there is in how an attribute has been captured across the datasets. A higher value indicates a better-quality attribute.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="u Value" data-type="sect2"><div class="sect2" id="id36">&#13;
<h2>u Value</h2>&#13;
&#13;
<p>The<a contenteditable="false" data-primary="u value" data-type="indexterm" id="id425"/> conditional probability that an attribute will be equivalent within the overall <code>notmatch</code> population is known as the <em>u value</em>. Again, using our <code>Firstname</code> example, we can denote this as:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="u Subscript f Baseline equals upper P left-parenthesis f i r s t vertical-bar n o t m a t c h right-parenthesis">&#13;
  <mrow>&#13;
    <msub><mi>u</mi> <mi>f</mi> </msub>&#13;
    <mo>=</mo>&#13;
    <mi>P</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>f</mi>&#13;
      <mi>i</mi>&#13;
      <mi>r</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mo>|</mo>&#13;
      <mi>n</mi>&#13;
      <mi>o</mi>&#13;
      <mi>t</mi>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>This value reflects how much commonality there is in this attribute across the datasets. A lower value indicates a less common, more distinguishing attribute that, if found to be equivalent in a particular case, would lead us to question whether it belongs in the <code>notmatch</code> population and is really a match. Conversely, a higher <em>u</em> value tells us that this particular attribute is not as valuable for determining overall matches.</p>&#13;
&#13;
<p>A good example of <em>u</em> value is a month of birth attribute, which, assuming the population is equally distributed across the year, will have a <em>u</em> value of <math alttext="one-twelfth">&#13;
  <mfrac><mn>1</mn> <mn>12</mn></mfrac>&#13;
</math>.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Lambda (&#10;  λ&#10;) Value" data-type="sect2"><div class="sect2" id="id37">&#13;
<h2>Lambda (<math alttext="lamda">&#13;
  <mi>λ</mi>&#13;
</math>) Value</h2>&#13;
&#13;
<p>The<a contenteditable="false" data-primary="lambda value" data-type="indexterm" id="id426"/> <em>lambda value</em>, <math alttext="lamda">&#13;
  <mi>λ</mi>&#13;
</math>, also known as the prior, is the probability that two randomly chosen records match.</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="lamda equals upper P left-parenthesis m a t c h right-parenthesis">&#13;
  <mrow>&#13;
    <mi>λ</mi>&#13;
    <mo>=</mo>&#13;
    <mi>P</mi>&#13;
    <mo>(</mo>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mo>)</mo>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>In contrast with the <em>m</em> and <em>u</em> values, the <math alttext="lamda">&#13;
  <mi>λ</mi>&#13;
</math> value is a record-level value not associated with any particular attribute. This value is a measure of how much duplication there is in the dataset overall and is the starting point for our probability calculations.</p>&#13;
&#13;
<p>The inverse, the likelihood that two randomly chosen records are not a match, can be written as follows:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="1 minus lamda equals upper P left-parenthesis n o t m a t c h right-parenthesis">&#13;
  <mrow>&#13;
    <mn>1</mn>&#13;
    <mo>-</mo>&#13;
    <mi>λ</mi>&#13;
    <mo>=</mo>&#13;
    <mi>P</mi>&#13;
    <mo>(</mo>&#13;
    <mi>n</mi>&#13;
    <mi>o</mi>&#13;
    <mi>t</mi>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mo>)</mo>&#13;
  </mrow>&#13;
</math></p></div>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Bayes Factor" data-type="sect2"><div class="sect2" id="id38">&#13;
<h2>Bayes Factor</h2>&#13;
&#13;
<p>Substituting<a contenteditable="false" data-primary="Bayes factor" data-type="indexterm" id="id427"/> these compact notations can result in the following:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper P left-parenthesis m a t c h vertical-bar f i r s t right-parenthesis equals 1 minus left-parenthesis 1 plus StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis EndFraction right-parenthesis Superscript negative 1">&#13;
  <mrow>&#13;
    <mi>P</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>|</mo>&#13;
      <mi>f</mi>&#13;
      <mi>i</mi>&#13;
      <mi>r</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>=</mo>&#13;
    <mn>1</mn>&#13;
    <mo>-</mo>&#13;
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><msub><mi>m</mi> <mi>f</mi> </msub> <msub><mi>u</mi> <mi>f</mi> </msub></mfrac><mo>×</mo><mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow> </msup>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>The ratio <math alttext="StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction">&#13;
  <mfrac><msub><mi>m</mi> <mi>f</mi> </msub> <msub><mi>u</mi> <mi>f</mi> </msub></mfrac>&#13;
</math> is also known as the <em>Bayes factor</em>, in this case of the <code>Firstname</code> parameter. The Bayes factor, as a combination of both the <em>m</em> and <em>u</em> values, gives a measure of the significance we should attach to the fact that the <code>Firstname</code> values were equivalent.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Fellegi-Sunter Model" data-type="sect2"><div class="sect2" id="id39">&#13;
<h2>Fellegi-Sunter Model</h2>&#13;
&#13;
<p>The<a contenteditable="false" data-primary="Fellegi-Sunter (FS) model" data-type="indexterm" id="id428"/> <em>Fellegi-Sunter model</em>, named after Ivan P. Fellegi and Alan B. Sunter,<sup><a data-type="noteref" href="ch04.html#id429" id="id429-marker">1</a></sup> describes how we can extend our simple Bayesian approach, combining the contribution of multiple attributes, to calculate the overall likelihood of a match. It relies on the simplifying assumption of<a contenteditable="false" data-primary="independence assumption" data-type="indexterm" id="id430"/><a contenteditable="false" data-primary="conditional independence assumption" data-type="indexterm" id="id431"/> conditional independence between attributes, also known as<a contenteditable="false" data-primary="naive Bayes" data-type="indexterm" id="id432"/> <em>naive Bayes</em>.</p>&#13;
&#13;
<p>Using the FS model, we can combine the Bayes factors associated with each attribute in our record by simply multiplying them together. Taking our <code>Firstname</code> example and extending it to consider when the <code>Lastname</code> is also equivalent we have:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue l a s t EndAbsoluteValue f i r s t right-parenthesis equals 1 minus left-parenthesis 1 plus StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction times StartFraction m Subscript l Baseline Over u Subscript l Baseline EndFraction times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis EndFraction right-parenthesis Superscript negative 1">&#13;
  <mrow>&#13;
    <mi>P</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>|</mo>&#13;
      <mi>l</mi>&#13;
      <mi>a</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mo>|</mo>&#13;
      <mi>f</mi>&#13;
      <mi>i</mi>&#13;
      <mi>r</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>=</mo>&#13;
    <mn>1</mn>&#13;
    <mo>-</mo>&#13;
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><msub><mi>m</mi> <mi>f</mi> </msub> <msub><mi>u</mi> <mi>f</mi> </msub></mfrac><mo>×</mo><mfrac><msub><mi>m</mi> <mi>l</mi> </msub> <msub><mi>u</mi> <mi>l</mi> </msub></mfrac><mo>×</mo><mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow> </msup>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>When an attribute isn’t equivalent, the Bayes factor is calculated as the inverse, <math alttext="StartFraction left-parenthesis 1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript l Baseline right-parenthesis EndFraction">&#13;
  <mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi> <mi>l</mi> </msub><mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi> <mi>l</mi> </msub><mo>)</mo></mrow></mfrac>&#13;
</math>. Therefore when the <code>Firstname</code> is equivalent but the <code>Lastname</code> is not, we calculate the probability of an overall match as:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue n o t l a s t EndAbsoluteValue f i r s t right-parenthesis equals 1 minus left-parenthesis 1 plus StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction times StartFraction left-parenthesis 1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript l Baseline right-parenthesis EndFraction times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis EndFraction right-parenthesis Superscript negative 1">&#13;
  <mrow>&#13;
    <mi>P</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>|</mo>&#13;
      <mi>n</mi>&#13;
      <mi>o</mi>&#13;
      <mi>t</mi>&#13;
      <mi>l</mi>&#13;
      <mi>a</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mo>|</mo>&#13;
      <mi>f</mi>&#13;
      <mi>i</mi>&#13;
      <mi>r</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>=</mo>&#13;
    <mn>1</mn>&#13;
    <mo>-</mo>&#13;
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><msub><mi>m</mi> <mi>f</mi> </msub> <msub><mi>u</mi> <mi>f</mi> </msub></mfrac><mo>×</mo><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi> <mi>l</mi> </msub><mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi> <mi>l</mi> </msub><mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow> </msup>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>Once we can calculate the <em>m</em> and <em>u</em> values for each attribute, and the <math alttext="lamda">&#13;
  <mi>λ</mi>&#13;
</math> value for the overall dataset, we can easily calculate the probabilities for each record pair. We simply determine the equivalence of each attribute (either exact or approximate as appropriate), select the appropriate Bayes factors, and multiply them together using the preceding formula to calculate the overall probability for that record pair.</p>&#13;
&#13;
<p>For<a contenteditable="false" data-primary="match factor calculations" data-type="indexterm" id="id433"/> our simple example, our Bayes factors are therefore calculated as shown in <a data-type="xref" href="#table-4-2">Table 4-2</a>.</p>&#13;
&#13;
<table id="table-4-2">&#13;
	<caption><span class="label">Table 4-2. </span><code>Firstname</code>, <code>Lastname</code> match factor calculations</caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th scope="col"><code>Firstname</code> equivalence</th>&#13;
			<th scope="col"><code>Lastname</code> equivalence</th>&#13;
			<th scope="col"><code>Firstname</code> Bayes factor</th>&#13;
			<th scope="col"><code>Lastname</code> Bayes factor</th>&#13;
			<th scope="col">Combined Bayes factor</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td>No</td>&#13;
			<td>No</td>&#13;
			<td><math alttext="StartFraction left-parenthesis 1 minus m Subscript f Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript f Baseline right-parenthesis EndFraction">&#13;
  <mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi> <mi>f</mi> </msub><mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi> <mi>f</mi> </msub><mo>)</mo></mrow></mfrac>&#13;
</math></td>&#13;
			<td><math alttext="StartFraction left-parenthesis 1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript l Baseline right-parenthesis EndFraction">&#13;
  <mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi> <mi>l</mi> </msub><mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi> <mi>l</mi> </msub><mo>)</mo></mrow></mfrac>&#13;
</math></td>&#13;
			<td><math alttext="StartFraction left-parenthesis 1 minus m Subscript f Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript f Baseline right-parenthesis EndFraction times StartFraction left-parenthesis 1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript l Baseline right-parenthesis EndFraction">&#13;
  <mrow>&#13;
    <mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi> <mi>f</mi> </msub><mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi> <mi>f</mi> </msub><mo>)</mo></mrow></mfrac>&#13;
    <mo>×</mo>&#13;
    <mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi> <mi>l</mi> </msub><mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi> <mi>l</mi> </msub><mo>)</mo></mrow></mfrac>&#13;
  </mrow>&#13;
</math></td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>No</td>&#13;
			<td>Yes</td>&#13;
			<td><math alttext="StartFraction left-parenthesis 1 minus m Subscript f Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript f Baseline right-parenthesis EndFraction">&#13;
  <mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi> <mi>f</mi> </msub><mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi> <mi>f</mi> </msub><mo>)</mo></mrow></mfrac>&#13;
</math></td>&#13;
			<td><math alttext="StartFraction m Subscript l Baseline Over u Subscript l Baseline EndFraction">&#13;
  <mfrac><msub><mi>m</mi> <mi>l</mi> </msub> <msub><mi>u</mi> <mi>l</mi> </msub></mfrac>&#13;
</math></td>&#13;
			<td><math alttext="StartFraction left-parenthesis 1 minus m Subscript f Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript f Baseline right-parenthesis EndFraction times StartFraction m Subscript l Baseline Over u Subscript l Baseline EndFraction">&#13;
  <mrow>&#13;
    <mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi> <mi>f</mi> </msub><mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi> <mi>f</mi> </msub><mo>)</mo></mrow></mfrac>&#13;
    <mo>×</mo>&#13;
    <mfrac><msub><mi>m</mi> <mi>l</mi> </msub> <msub><mi>u</mi> <mi>l</mi> </msub></mfrac>&#13;
  </mrow>&#13;
</math></td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Yes</td>&#13;
			<td>No</td>&#13;
			<td><math alttext="StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction">&#13;
  <mfrac><msub><mi>m</mi> <mi>f</mi> </msub> <msub><mi>u</mi> <mi>f</mi> </msub></mfrac>&#13;
</math></td>&#13;
			<td><math alttext="StartFraction left-parenthesis 1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript l Baseline right-parenthesis EndFraction">&#13;
  <mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi> <mi>l</mi> </msub><mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi> <mi>l</mi> </msub><mo>)</mo></mrow></mfrac>&#13;
</math></td>&#13;
			<td><math alttext="StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction times StartFraction left-parenthesis 1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript l Baseline right-parenthesis EndFraction">&#13;
  <mrow>&#13;
    <mfrac><msub><mi>m</mi> <mi>f</mi> </msub> <msub><mi>u</mi> <mi>f</mi> </msub></mfrac>&#13;
    <mo>×</mo>&#13;
    <mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi> <mi>l</mi> </msub><mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi> <mi>l</mi> </msub><mo>)</mo></mrow></mfrac>&#13;
  </mrow>&#13;
</math></td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Yes</td>&#13;
			<td>Yes</td>&#13;
			<td><math alttext="StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction">&#13;
  <mfrac><msub><mi>m</mi> <mi>f</mi> </msub> <msub><mi>u</mi> <mi>f</mi> </msub></mfrac>&#13;
</math></td>&#13;
			<td><math alttext="StartFraction m Subscript l Baseline Over u Subscript l Baseline EndFraction">&#13;
  <mfrac><msub><mi>m</mi> <mi>l</mi> </msub> <msub><mi>u</mi> <mi>l</mi> </msub></mfrac>&#13;
</math></td>&#13;
			<td><math alttext="StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction times StartFraction m Subscript l Baseline Over u Subscript l Baseline EndFraction">&#13;
  <mrow>&#13;
    <mfrac><msub><mi>m</mi> <mi>f</mi> </msub> <msub><mi>u</mi> <mi>f</mi> </msub></mfrac>&#13;
    <mo>×</mo>&#13;
    <mfrac><msub><mi>m</mi> <mi>l</mi> </msub> <msub><mi>u</mi> <mi>l</mi> </msub></mfrac>&#13;
  </mrow>&#13;
</math></td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Match Weight" data-type="sect2"><div class="sect2" id="id40">&#13;
<h2>Match Weight</h2>&#13;
&#13;
<p>To<a contenteditable="false" data-primary="match weight" data-type="indexterm" id="id434"/> make overall match calculations more intuitive, the logarithm of the Bayes factors is sometimes used so that they can be added together rather than multiplied. In this way it is easy to visualize the relative contribution of each attribute to the overall score.</p>&#13;
&#13;
<p>For our simple first name and last name equivalence example, the logarithmic match weight might be calculated (using base 2) as:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper M a t c h upper W e i g h t equals l o g 2 StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction plus l o g 2 StartFraction m Subscript l Baseline Over u Subscript l Baseline EndFraction plus l o g 2 StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis EndFraction">&#13;
  <mrow>&#13;
    <mi>M</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mi>W</mi>&#13;
    <mi>e</mi>&#13;
    <mi>i</mi>&#13;
    <mi>g</mi>&#13;
    <mi>h</mi>&#13;
    <mi>t</mi>&#13;
    <mo>=</mo>&#13;
    <mi>l</mi>&#13;
    <mi>o</mi>&#13;
    <msub><mi>g</mi> <mn>2</mn> </msub>&#13;
    <mfrac><msub><mi>m</mi> <mi>f</mi> </msub> <msub><mi>u</mi> <mi>f</mi> </msub></mfrac>&#13;
    <mo>+</mo>&#13;
    <mi>l</mi>&#13;
    <mi>o</mi>&#13;
    <msub><mi>g</mi> <mn>2</mn> </msub>&#13;
    <mfrac><msub><mi>m</mi> <mi>l</mi> </msub> <msub><mi>u</mi> <mi>l</mi> </msub></mfrac>&#13;
    <mo>+</mo>&#13;
    <mi>l</mi>&#13;
    <mi>o</mi>&#13;
    <msub><mi>g</mi> <mn>2</mn> </msub>&#13;
    <mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>We can calculate probability from the match weight as:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper P r o b a b i l i t y equals 1 minus left-parenthesis 1 plus 2 Superscript upper M a t c h upper W e i g h t Baseline right-parenthesis Superscript negative 1">&#13;
  <mrow>&#13;
    <mi>P</mi>&#13;
    <mi>r</mi>&#13;
    <mi>o</mi>&#13;
    <mi>b</mi>&#13;
    <mi>a</mi>&#13;
    <mi>b</mi>&#13;
    <mi>i</mi>&#13;
    <mi>l</mi>&#13;
    <mi>i</mi>&#13;
    <mi>t</mi>&#13;
    <mi>y</mi>&#13;
    <mo>=</mo>&#13;
    <mn>1</mn>&#13;
    <mo>-</mo>&#13;
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><msup><mn>2</mn> <mrow><mi>M</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow> </msup><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow> </msup>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>Now that we understand how to combine our individual attribute probabilities, or match weights, together let’s consider how to estimate our <math alttext="lamda">&#13;
  <mi>λ</mi>&#13;
</math> value and our <em>m</em> and <em>u</em> values for each attribute when we don’t have a known <code>match</code> population.<a contenteditable="false" data-primary="" data-startref="PMmodels04" data-type="indexterm" id="id435"/> One technique that we can use is called the <a href="https://oreil.ly/kvWD3"><em>expectation-maximization (EM) algorithm</em></a>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Expectation-Maximization Algorithm" data-type="sect1"><div class="sect1" id="id117">&#13;
<h1>Expectation-Maximization Algorithm</h1>&#13;
&#13;
<p>The<a contenteditable="false" data-primary="probabilistic matching" data-secondary="expectation-maximization (EM) algorithm" data-type="indexterm" id="PMalgo04"/><a contenteditable="false" data-primary="EM (expectation-maximization) model" data-secondary="algorithm" data-type="indexterm" id="EMalg04"/> expectation-maximization algorithm uses an iterative approach to approximating the <math alttext="lamda">&#13;
  <mi>λ</mi>&#13;
</math> and <em>m</em> and <em>u</em> values. Let’s see a simplified form of this in action applied to our sample problem.</p>&#13;
&#13;
<section data-pdf-bookmark="Iteration 1" data-type="sect2"><div class="sect2" id="id41">&#13;
<h2>Iteration 1</h2>&#13;
&#13;
<p>For<a contenteditable="false" data-primary="expectation-maximization (EM) algorithm" data-type="indexterm" id="EMAone04"/> the first iteration we make the opening assumption that record pairs where the majority of the feature columns are equivalent are matches:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
it1_match = cross[cross['Tmatch']&gt;=2]&#13;
it1_notmatch = cross[cross['Tmatch']&lt;2]&#13;
&#13;
<strong>len(it1_match)</strong>&#13;
637</pre>&#13;
&#13;
<p>This gives us a pseudo <code>match</code> population, <code>it1_match</code>, of 637 records. In addition to the 628 perfect matches we found in <a data-type="xref" href="ch02.html#chapter_2">Chapter 2</a>, we also have 9 matches where either <code>Firstname</code> or <code>Lastname</code> (but not both) doesn’t match, as we see in <a data-type="xref" href="#fig-4-4">Figure 4-4</a>:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
it1_match[~it1_match['Fmatch'] | ~it1_match['Lmatch']]&#13;
   [['Constituency_w','Firstname_w','Firstname_t',&#13;
      'Lastname_w','Lastname_t']]</pre>&#13;
&#13;
<figure><div class="figure" id="fig-4-4"><img alt="" class="iimagesch04ch04emit1extramatchespng" src="assets/hoer_0404.png"/>&#13;
<h6><span class="label">Figure 4-4. </span>Expectation-maximization iteration 1 additional matches</h6>&#13;
</div></figure>&#13;
&#13;
<p>Our initial <math alttext="lamda">&#13;
  <mi>λ</mi>&#13;
</math> value is therefore:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="lamda 1 equals StartFraction 637 Over 650 times 650 EndFraction almost-equals 0.0015">&#13;
  <mrow>&#13;
    <msub><mi>λ</mi> <mn>1</mn> </msub>&#13;
    <mo>=</mo>&#13;
    <mfrac><mn>637</mn> <mrow><mn>650</mn><mo>×</mo><mn>650</mn></mrow></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mn>0</mn>&#13;
    <mo>.</mo>&#13;
    <mn>0015</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="left-parenthesis 1 minus lamda 1 right-parenthesis equals left-parenthesis 1 minus 0.0015 right-parenthesis almost-equals 0.9985">&#13;
  <mrow>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mn>1</mn>&#13;
      <mo>-</mo>&#13;
      <msub><mi>λ</mi> <mn>1</mn> </msub>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>=</mo>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mn>1</mn>&#13;
      <mo>-</mo>&#13;
      <mn>0</mn>&#13;
      <mo>.</mo>&#13;
      <mn>0015</mn>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>≈</mo>&#13;
    <mn>0</mn>&#13;
    <mo>.</mo>&#13;
    <mn>9985</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>Our initial prior match weight is therefore  <math alttext="l o g 2 StartFraction lamda 1 Over left-parenthesis 1 minus lamda 1 right-parenthesis EndFraction almost-equals negative 9.371">&#13;
  <mrow>&#13;
    <mrow>&#13;
      <mi>l</mi>&#13;
      <mi>o</mi>&#13;
      <msub><mi>g</mi> <mn>2</mn> </msub>&#13;
      <mfrac><msub><mi>λ</mi> <mn>1</mn> </msub> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>λ</mi> <mn>1</mn> </msub><mo>)</mo></mrow></mfrac>&#13;
    </mrow>&#13;
    <mo>≈</mo>&#13;
    <mo>-</mo>&#13;
    <mn>9</mn>&#13;
    <mo>.</mo>&#13;
    <mn>371</mn>&#13;
  </mrow>&#13;
</math>.</p>&#13;
&#13;
<p>As a starting point, it’s therefore extremely unlikely that two records are a match. Now let’s calculate our <em>m</em> and <em>u</em> values so that we can update our probability on a per-record basis.</p>&#13;
&#13;
<p>As we have a pseudo <code>match</code> and <code>notmatch</code> population, it’s straightforward to calculate our <em>m</em> and <em>u</em> values as the proportion of each population with an equivalent attribute. For <code>Firstname</code>, <code>Lastname</code>, and <code>Constituency</code> we use:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
mfi1 = len(it1_match[it1_match['Fmatch']])/len(it1_match)&#13;
mli1 = len(it1_match[it1_match['Lmatch']])/len(it1_match)&#13;
mci1 = len(it1_match[it1_match['Cmatch']])/len(it1_match)&#13;
&#13;
ufi1 = len(it1_notmatch[it1_notmatch['Fmatch']])/len(it1_notmatch)&#13;
uli1 = len(it1_notmatch[it1_notmatch['Lmatch']])/len(it1_notmatch)&#13;
uci1 = len(it1_notmatch[it1_notmatch['Cmatch']])/len(it1_notmatch)</pre>&#13;
&#13;
<p><a data-type="xref" href="#table-4-3">Table 4-3</a> shows these values and the resulting match weight values per attribute.</p>&#13;
&#13;
<table class="pagebreak-before less_space" id="table-4-3">&#13;
	<caption><span class="label">Table 4-3. </span>Iteration 1 <em>m</em> and <em>u</em> values</caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th scope="col">Attribute</th>&#13;
			<th scope="col"><em>m</em> value</th>&#13;
			<th scope="col"><em>u</em> value</th>&#13;
			<th scope="col">Match Bayes factor</th>&#13;
			<th scope="col">Match weight</th>&#13;
			<th scope="col">Not match Bayes factor</th>&#13;
			<th scope="col">Not match weight</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><code>Firstname</code></td>&#13;
			<td>0.9921</td>&#13;
			<td>0.0049</td>&#13;
			<td>203.97</td>&#13;
			<td>7.67</td>&#13;
			<td>0.0079</td>&#13;
			<td>–6.98</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><code>Lastname</code></td>&#13;
			<td>0.9937</td>&#13;
			<td>0.0008</td>&#13;
			<td>1201.19</td>&#13;
			<td>10.23</td>&#13;
			<td>0.0063</td>&#13;
			<td>–7.31</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><code>Constituency</code></td>&#13;
			<td>1.0</td>&#13;
			<td>0.0</td>&#13;
			<td><math alttext="normal infinity">&#13;
  <mi>∞</mi>&#13;
</math></td>&#13;
			<td><math alttext="normal infinity">&#13;
  <mi>∞</mi>&#13;
</math></td>&#13;
			<td>0</td>&#13;
			<td><math alttext="negative normal infinity">&#13;
  <mrow>&#13;
    <mo>-</mo>&#13;
    <mi>∞</mi>&#13;
  </mrow>&#13;
</math></td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<p>There are no record pairs where the constituency is equivalent in the <code>notmatch</code> population, so its <em>u</em> value is 0 and therefore its <code>match</code> weight is mathematically infinity and its <code>notmatch</code> weight is negative infinity.</p>&#13;
&#13;
<p>Now we can use these values in the Fellegi-Sunter model to calculate the match probability for every record pair in the full population. We use a helper function to calculate these probabilities based on the values of the <code>Constituency</code>, <code>Firstname</code>, and <code>Lastname</code> match features:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
def match_prb(Fmatch,Lmatch,Cmatch,mf1,ml1,mc1,uf1,ul1,uc1, lmbda):&#13;
    if (Fmatch==1):&#13;
        mf = mf1&#13;
        uf = uf1&#13;
    else:&#13;
        mf = (1-mf1)&#13;
        uf = (1-uf1)&#13;
    if (Lmatch==1):&#13;
        ml = ml1&#13;
        ul = ul1&#13;
    else:&#13;
        ml = (1-ml1)&#13;
        ul = (1-ul1)&#13;
    if (Cmatch==1):&#13;
        mc = mc1&#13;
        uc = uc1&#13;
    else:&#13;
        mc = (1-mc1)&#13;
        uc = (1-uc1)&#13;
    prob = (lmbda * ml * mf * mc) / (lmbda * ml * mf * mc +&#13;
           (1-lmbda) * ul * uf * uc)&#13;
    return(prob)</pre>&#13;
&#13;
<p>We apply this function to the whole population with:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
cross['prob'] = cross.apply(lambda x: match_prb(&#13;
      x.Fmatch,x.Lmatch,x.Cmatch,&#13;
      mfi1,mli1,mci1,&#13;
      ufi1,uli1,uci1,&#13;
      lmbda), axis=1)</pre>&#13;
&#13;
<p>Once we’ve calculated these values we can iterate again, resegmenting our population into <code>match</code> and <code>notmatch</code> populations based on the calculated match probabilities.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Iteration 2" data-type="sect2"><div class="sect2" id="id248">&#13;
<h2>Iteration 2</h2>&#13;
&#13;
<p>For illustration purposes, we use an overall match probability of greater than 0.99 to define our new assumed <code>match</code> population and assign any record with an equal or lower probability to our <code>notmatch</code> population:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
it2_match = cross[cross['prob']&gt;0.99]&#13;
it2_notmatch = cross[cross['prob']&lt;=0.99]&#13;
&#13;
<strong>len(it2_match)</strong>&#13;
633</pre>&#13;
&#13;
<p>Applying this 0.99 threshold gives us a slightly reduced <code>match</code> population of 633. Let’s see why. If we select the records just below the threshold we can see:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
it2_notmatch[it2_notmatch['prob']&gt;0.9]&#13;
   [['Constituency_w', 'Lastname_w','Lastname_t','prob']]</pre>&#13;
&#13;
<figure><div class="figure" id="fig-4-5"><img alt="" class="iimagesch04ch04iteration2bltpng" src="assets/hoer_0405.png"/>&#13;
<h6><span class="label">Figure 4-5. </span>Iteration 2 records with below-the-line match thresholds </h6>&#13;
</div></figure>&#13;
&#13;
<p>As we see in <a data-type="xref" href="#fig-4-5">Figure 4-5</a>, if the <code>Lastname</code> isn’t equivalent, the new match probability falls just below our 0.99 threshold. Using these new <code>match</code> and <code>notmatch</code> populations we can revise our <math alttext="lamda">&#13;
  <mi>λ</mi>&#13;
</math>, <em>m</em>, and <em>u</em> values and iterate again, recalculating the match probabilities for each record pair.</p>&#13;
&#13;
<p>In this case, our <math alttext="lamda">&#13;
  <mi>λ</mi>&#13;
</math> doesn’t materially change:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="lamda 2 equals StartFraction 633 Over 650 times 650 EndFraction almost-equals 0.0015">&#13;
  <mrow>&#13;
    <msub><mi>λ</mi> <mn>2</mn> </msub>&#13;
    <mo>=</mo>&#13;
    <mfrac><mn>633</mn> <mrow><mn>650</mn><mo>×</mo><mn>650</mn></mrow></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mn>0</mn>&#13;
    <mo>.</mo>&#13;
    <mn>0015</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>Only the <code>Lastname</code> values change slightly, as shown in <a data-type="xref" href="#table-4-4">Table 4-4</a>.</p>&#13;
&#13;
<table id="table-4-4">&#13;
	<caption><span class="label">Table 4-4. </span>Iteration 2 <em>m</em> and <em>u</em> values</caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th scope="col">Attribute</th>&#13;
			<th scope="col"><em>m</em> value</th>&#13;
			<th scope="col"><em>u</em> value</th>&#13;
			<th scope="col">Match Bayes factor</th>&#13;
			<th scope="col">Match weight</th>&#13;
			<th scope="col">Not match Bayes factor</th>&#13;
			<th scope="col">Not match weight</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><code>Firstname</code></td>&#13;
			<td>0.9921</td>&#13;
			<td>0.0049</td>&#13;
			<td>203.97</td>&#13;
			<td>7.67</td>&#13;
			<td>0.0079</td>&#13;
			<td>–6.98</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><em><code>Lastname</code></em></td>&#13;
			<td><em>1.0</em></td>&#13;
			<td><em>0.0008</em></td>&#13;
			<td><em>1208.79</em></td>&#13;
			<td><em>10.24</em></td>&#13;
			<td><em>0</em></td>&#13;
			<td><math alttext="negative normal infinity">&#13;
  <mrow>&#13;
    <mo>-</mo>&#13;
    <mi>∞</mi>&#13;
  </mrow>&#13;
</math></td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><code>Constituency</code></td>&#13;
			<td>1.0</td>&#13;
			<td>0.0</td>&#13;
			<td><math alttext="normal infinity">&#13;
  <mi>∞</mi>&#13;
</math></td>&#13;
			<td><math alttext="normal infinity">&#13;
  <mi>∞</mi>&#13;
</math></td>&#13;
			<td>0</td>&#13;
			<td><math alttext="negative normal infinity">&#13;
  <mrow>&#13;
    <mo>-</mo>&#13;
    <mi>∞</mi>&#13;
  </mrow>&#13;
</math></td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Iteration 3" data-type="sect2"><div class="sect2" id="id42">&#13;
<h2>Iteration 3</h2>&#13;
&#13;
<p>In this simple example, this next iteration doesn’t change the <code>match</code> population, which remains at 633, because the EM algorithm has already converged.</p>&#13;
&#13;
<p>This gives us our final parameter values of:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="lamda almost-equals 0.0015">&#13;
  <mrow>&#13;
    <mi>λ</mi>&#13;
    <mo>≈</mo>&#13;
    <mn>0</mn>&#13;
    <mo>.</mo>&#13;
    <mn>0015</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="m Subscript f Baseline equals upper P left-parenthesis f i r s t vertical-bar m a t c h right-parenthesis almost-equals 0.9921">&#13;
  <mrow>&#13;
    <msub><mi>m</mi> <mi>f</mi> </msub>&#13;
    <mo>=</mo>&#13;
    <mi>P</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>f</mi>&#13;
      <mi>i</mi>&#13;
      <mi>r</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mo>|</mo>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>≈</mo>&#13;
    <mn>0</mn>&#13;
    <mo>.</mo>&#13;
    <mn>9921</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="m Subscript l Baseline equals upper P left-parenthesis l a s t vertical-bar m a t c h right-parenthesis almost-equals 1.0">&#13;
  <mrow>&#13;
    <msub><mi>m</mi> <mi>l</mi> </msub>&#13;
    <mo>=</mo>&#13;
    <mi>P</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>l</mi>&#13;
      <mi>a</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mo>|</mo>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>≈</mo>&#13;
    <mn>1</mn>&#13;
    <mo>.</mo>&#13;
    <mn>0</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="m Subscript c Baseline equals upper P left-parenthesis c o n s t i t u e n c y vertical-bar m a t c h right-parenthesis almost-equals 1.0">&#13;
  <mrow>&#13;
    <msub><mi>m</mi> <mi>c</mi> </msub>&#13;
    <mo>=</mo>&#13;
    <mi>P</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>c</mi>&#13;
      <mi>o</mi>&#13;
      <mi>n</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mi>i</mi>&#13;
      <mi>t</mi>&#13;
      <mi>u</mi>&#13;
      <mi>e</mi>&#13;
      <mi>n</mi>&#13;
      <mi>c</mi>&#13;
      <mi>y</mi>&#13;
      <mo>|</mo>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>≈</mo>&#13;
    <mn>1</mn>&#13;
    <mo>.</mo>&#13;
    <mn>0</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="u Subscript f Baseline equals upper P left-parenthesis f i r s t vertical-bar n o t m a t c h right-parenthesis almost-equals 0.0049">&#13;
  <mrow>&#13;
    <msub><mi>u</mi> <mi>f</mi> </msub>&#13;
    <mo>=</mo>&#13;
    <mi>P</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>f</mi>&#13;
      <mi>i</mi>&#13;
      <mi>r</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mo>|</mo>&#13;
      <mi>n</mi>&#13;
      <mi>o</mi>&#13;
      <mi>t</mi>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>≈</mo>&#13;
    <mn>0</mn>&#13;
    <mo>.</mo>&#13;
    <mn>0049</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="u Subscript l Baseline equals upper P left-parenthesis l a s t vertical-bar n o t m a t c h right-parenthesis almost-equals 0.0008">&#13;
  <mrow>&#13;
    <msub><mi>u</mi> <mi>l</mi> </msub>&#13;
    <mo>=</mo>&#13;
    <mi>P</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>l</mi>&#13;
      <mi>a</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mo>|</mo>&#13;
      <mi>n</mi>&#13;
      <mi>o</mi>&#13;
      <mi>t</mi>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>≈</mo>&#13;
    <mn>0</mn>&#13;
    <mo>.</mo>&#13;
    <mn>0008</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="u Subscript c Baseline equals upper P left-parenthesis c o n s t i t u e n c y vertical-bar n o t m a t c h right-parenthesis almost-equals 0">&#13;
  <mrow>&#13;
    <msub><mi>u</mi> <mi>c</mi> </msub>&#13;
    <mo>=</mo>&#13;
    <mi>P</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>c</mi>&#13;
      <mi>o</mi>&#13;
      <mi>n</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mi>i</mi>&#13;
      <mi>t</mi>&#13;
      <mi>u</mi>&#13;
      <mi>e</mi>&#13;
      <mi>n</mi>&#13;
      <mi>c</mi>&#13;
      <mi>y</mi>&#13;
      <mo>|</mo>&#13;
      <mi>n</mi>&#13;
      <mi>o</mi>&#13;
      <mi>t</mi>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>≈</mo>&#13;
    <mn>0</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>This instinctively feels right. We know that a match will always have an equivalent constituency and either first name or last name will match, with last name slightly more likely to be equivalent than first name (five out of nine versus four out of nine in the preceding sample).</p>&#13;
&#13;
<p>Similarly, we know the constituency will never be the same in a <code>notmatch</code> record pair and it’s very unlikely that either the first name or last name will accidentally match either (with first name slightly more likely).</p>&#13;
&#13;
<p>We can turn these estimated values into match probabilities using the equations in the previous section:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue l a s t EndAbsoluteValue f i r s t right-parenthesis equals 1 minus left-parenthesis 1 plus StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction times StartFraction m Subscript l Baseline Over u Subscript l Baseline EndFraction times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis EndFraction right-parenthesis Superscript negative 1 Baseline equals 1.0">&#13;
  <mrow>&#13;
    <mi>P</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>|</mo>&#13;
      <mi>l</mi>&#13;
      <mi>a</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mo>|</mo>&#13;
      <mi>f</mi>&#13;
      <mi>i</mi>&#13;
      <mi>r</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>=</mo>&#13;
    <mn>1</mn>&#13;
    <mo>-</mo>&#13;
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><msub><mi>m</mi> <mi>f</mi> </msub> <msub><mi>u</mi> <mi>f</mi> </msub></mfrac><mo>×</mo><mfrac><msub><mi>m</mi> <mi>l</mi> </msub> <msub><mi>u</mi> <mi>l</mi> </msub></mfrac><mo>×</mo><mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow> </msup>&#13;
    <mo>=</mo>&#13;
    <mn>1</mn>&#13;
    <mo>.</mo>&#13;
    <mn>0</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue n o t l a s t EndAbsoluteValue f i r s t right-parenthesis equals 1 minus left-parenthesis 1 plus StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction times StartFraction left-parenthesis 1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript l Baseline right-parenthesis EndFraction times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis EndFraction right-parenthesis Superscript negative 1 Baseline almost-equals 0.0019">&#13;
  <mrow>&#13;
    <mi>P</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>|</mo>&#13;
      <mi>n</mi>&#13;
      <mi>o</mi>&#13;
      <mi>t</mi>&#13;
      <mi>l</mi>&#13;
      <mi>a</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mo>|</mo>&#13;
      <mi>f</mi>&#13;
      <mi>i</mi>&#13;
      <mi>r</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>=</mo>&#13;
    <mn>1</mn>&#13;
    <mo>-</mo>&#13;
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><msub><mi>m</mi> <mi>f</mi> </msub> <msub><mi>u</mi> <mi>f</mi> </msub></mfrac><mo>×</mo><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi> <mi>l</mi> </msub><mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi> <mi>l</mi> </msub><mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow> </msup>&#13;
    <mo>≈</mo>&#13;
    <mn>0</mn>&#13;
    <mo>.</mo>&#13;
    <mn>0019</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue n o t f i r s t EndAbsoluteValue l a s t right-parenthesis equals 1 minus left-parenthesis 1 plus StartFraction left-parenthesis 1 minus m Subscript f Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript f Baseline right-parenthesis EndFraction times StartFraction m Subscript l Baseline Over u Subscript l Baseline EndFraction times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis EndFraction right-parenthesis Superscript negative 1 Baseline almost-equals 0.0141">&#13;
  <mrow>&#13;
    <mi>P</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>|</mo>&#13;
      <mi>n</mi>&#13;
      <mi>o</mi>&#13;
      <mi>t</mi>&#13;
      <mi>f</mi>&#13;
      <mi>i</mi>&#13;
      <mi>r</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mo>|</mo>&#13;
      <mi>l</mi>&#13;
      <mi>a</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>=</mo>&#13;
    <mn>1</mn>&#13;
    <mo>-</mo>&#13;
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi> <mi>f</mi> </msub><mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi> <mi>f</mi> </msub><mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><msub><mi>m</mi> <mi>l</mi> </msub> <msub><mi>u</mi> <mi>l</mi> </msub></mfrac><mo>×</mo><mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow> </msup>&#13;
    <mo>≈</mo>&#13;
    <mn>0</mn>&#13;
    <mo>.</mo>&#13;
    <mn>0141</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper P left-parenthesis m a t c h StartAbsoluteValue n o t f i r s t EndAbsoluteValue n o t l a s t right-parenthesis equals 1 minus left-parenthesis 1 plus StartFraction left-parenthesis 1 minus m Subscript f Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript f Baseline right-parenthesis EndFraction times StartFraction left-parenthesis 1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript l Baseline right-parenthesis EndFraction times StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis EndFraction right-parenthesis Superscript negative 1 Baseline equals 0">&#13;
  <mrow>&#13;
    <mi>P</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>|</mo>&#13;
      <mi>n</mi>&#13;
      <mi>o</mi>&#13;
      <mi>t</mi>&#13;
      <mi>f</mi>&#13;
      <mi>i</mi>&#13;
      <mi>r</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mo>|</mo>&#13;
      <mi>n</mi>&#13;
      <mi>o</mi>&#13;
      <mi>t</mi>&#13;
      <mi>l</mi>&#13;
      <mi>a</mi>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>=</mo>&#13;
    <mn>1</mn>&#13;
    <mo>-</mo>&#13;
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi> <mi>f</mi> </msub><mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi> <mi>f</mi> </msub><mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi> <mi>l</mi> </msub><mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi> <mi>l</mi> </msub><mo>)</mo></mrow></mfrac><mo>×</mo><mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow> </msup>&#13;
    <mo>=</mo>&#13;
    <mn>0</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>As expected, these probabilities match the values we calculated using the probability maps in <a data-type="xref" href="#fig-4-3">Figure 4-3</a> when we knew the <code>match</code> and <code>notmatch</code> population upfront.</p>&#13;
&#13;
<p>In conclusion, we are now able to estimate match probabilities for all the different permutations of attribute equivalence without having to know the <code>match</code> population in advance. This probabilistic approach is both powerful and scalable to large datasets with multiple attributes. To help us apply these techniques more easily, we introduce a performant and easy-to-use open source library, Splink, in the next section.<a contenteditable="false" data-primary="" data-startref="PMalgo04" data-type="indexterm" id="id436"/><a contenteditable="false" data-primary="" data-startref="EMAone04" data-type="indexterm" id="id437"/><a contenteditable="false" data-primary="" data-startref="EMalg04" data-type="indexterm" id="id438"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Introducing Splink" data-type="sect1"><div class="sect1" id="id118">&#13;
<h1>Introducing Splink</h1>&#13;
&#13;
<p>Splink<a contenteditable="false" data-primary="Splink" data-secondary="basics of" data-type="indexterm" id="id439"/> is a Python package for probabilistic entity resolution. Splink implements the Fellegi-Sunter model and includes a variety of interactive outputs to help users understand models and diagnose linkage problems.</p>&#13;
&#13;
<p>Splink supports a number of backends to perform the matching calculations. To begin with, we will use DuckDB, an in-process SQL database management system, that we can run locally on our laptop.</p>&#13;
&#13;
<section data-pdf-bookmark="Configuring Splink" data-type="sect2"><div class="sect2" id="id43">&#13;
<h2>Configuring Splink</h2>&#13;
&#13;
<p>To<a contenteditable="false" data-primary="Splink" data-secondary="configuring" data-type="indexterm" id="Sconfig04"/> import Splink into our notebook, we use:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
import splink</pre>&#13;
&#13;
<p>Splink requires a unique ID column in each dataset, so we need to create these by copying their respective DataFrame indexes:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
df_w['unique_id'] = df_w.index&#13;
df_t['unique_id'] = df_t.index</pre>&#13;
&#13;
<p>Splink also needs the same columns to be present in both datasets. Therefore, we need to create blank columns where these are present in only one set of records and then remove unnecessary columns:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
df_w['Flink'] = None&#13;
df_t['Notes'] = None&#13;
&#13;
df_w = df_w[['Firstname','Lastname','Constituency','Flink','Notes',&#13;
   'unique_id']]&#13;
df_t = df_t[['Firstname','Lastname','Constituency','Flink','Notes',&#13;
   'unique_id']]</pre>&#13;
&#13;
<p class="pagebreak-before">Our next step is to configure Splink settings:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
from splink.duckdb.linker import DuckDBLinker&#13;
from splink.duckdb import comparison_library as cl&#13;
&#13;
settings = {&#13;
   "link_type": "link_only", "comparisons": [&#13;
       cl.exact_match("Firstname"),&#13;
       cl.exact_match("Lastname"),&#13;
       cl.exact_match("Constituency"),&#13;
   ],&#13;
}&#13;
linker = DuckDBLinker([df_w, df_t], settings)</pre>&#13;
&#13;
<p>Splink supports both deduplication of records within a single dataset and linking between one or more separate datasets. Here we set <code>link_type</code> to <code>link_only</code> to tell Splink that we want only to match, not deduplicate, between our two datasets. We also tell Splink the comparisons we wish to use, in this case exact matches across our three attributes. Lastly, we instantiate the linker with these settings and our source DataFrames.</p>&#13;
&#13;
<p>To help us understand our datasets, Splink provides a visualization of the distribution of the columns to be matched:</p>&#13;
&#13;
<pre>&#13;
linker.profile_columns(['Firstname','Lastname','Constituency'])</pre>&#13;
&#13;
&#13;
<p>The graphs we see in <a data-type="xref" href="#fig-4-6">Figure 4-6</a> show us the combined population across both datasets.</p>&#13;
&#13;
<p>Starting with distribution of first names we can see from the bottom right of the graph that, within the population of 352 distinct names, approximately 35% occur only twice, most probably once in each dataset. Then, moving right to left, we see a gradual increase in frequency to the most popular name, with 32 occurrences. Looking at the top 10 values by value count we see that John is the most popular name, followed by Andrew, David, etc. This tells us that <code>Firstname</code> is a reasonable attribute to match on, but used alone, it will result in some false positives.</p>&#13;
&#13;
<p>For last name the pattern is more stark, with a larger population of 574 distinct names, of which nearly 80% occur only twice. Looking at the top 10 values, the most common last names, Smith and Jones, occur 18 times, almost half as common as the most popular first name. As expected, this tells us that <code>Lastname</code> is a richer attribute than <code>Firstname</code> and therefore its equivalence is a better predictor of matching <span class="keep-together">entities</span>.</p>&#13;
&#13;
<p>As expected, constituencies are uniquely paired across the two datasets, so all values appear exactly twice.</p>&#13;
&#13;
<figure><div class="figure" id="fig-4-6"><img alt="" class="iimagesch04ch04splinkprofilecolumnspng" src="assets/hoer_0406.png"/>&#13;
<h6><span class="label">Figure 4-6. </span>Splink column profiles</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">For the purposes of this simple example, we’re going to ask Splink to calculate all the parameters of the model using the expectation-maximization algorithm we introduced earlier. The initial <code>True</code> parameter tells Splink to compare all the records across both datasets without blocking (we’ll see this in the next chapter). We also tell Splink to recalculate the <em>u</em> values at each iteration by setting <code>fix_u_probabilities</code> to <code>False</code>. Setting the <code>fix_probability_two_random_records_match</code> to <code>False</code> means the <math alttext="lamda">&#13;
  <mi>λ</mi>&#13;
</math> value (the overall match probability between the two datasets) will be recalculated at each iteration. Finally, we tell Splink to use the updated <math alttext="lamda">&#13;
  <mi>λ</mi>&#13;
</math> value when  calculating probabilities for record pairs.<a contenteditable="false" data-primary="" data-startref="Sconfig04" data-type="indexterm" id="id440"/>:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
em_session = linker.estimate_parameters_using_expectation_maximisation(&#13;
   'True',&#13;
   fix_u_probabilities=False,&#13;
   fix_probability_two_random_records_match=False,&#13;
   populate_probability_two_random_records_match_from_trained_values&#13;
     =True)</pre>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Splink Performance" data-type="sect2"><div class="sect2" id="id44">&#13;
<h2>Splink Performance</h2>&#13;
&#13;
<p>The<a contenteditable="false" data-primary="Splink" data-secondary="performance" data-type="indexterm" id="Sperf04"/><a contenteditable="false" data-primary="EM (expectation-maximization) model" data-secondary="Splink interactive chart" data-type="indexterm" id="id441"/> EM model converges after three iterations.  Splink produces an interactive chart showing the iterative progression of the relative match weights values:</p>&#13;
&#13;
<pre>&#13;
em_session.match_weights_interactive_history_chart()</pre>&#13;
&#13;
<figure><div class="figure" id="fig-4-7"><img alt="" class="iimagesch04ch04splinkmodelparaspng" src="assets/hoer_0407.png"/>&#13;
<h6><span class="label">Figure 4-7. </span>Splink match weights</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-type="xref" href="#fig-4-7">Figure 4-7</a> shows the final match weights that Splink has calculated after the third iteration. First, we have the prior (starting) match weight, which is a measure of how likely it is that two records chosen at random match. If you hover over the match weight bars you can see the calculated match weight value together with the underlying <em>m</em> and <em>u</em> parameters. These are calculated as follows:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper P r i o r left-parenthesis s t a r t i n g right-parenthesis m a t c h w e i g h t equals l o g 2 StartFraction lamda Over left-parenthesis 1 minus lamda right-parenthesis EndFraction almost-equals negative 9.38">&#13;
  <mrow>&#13;
    <mi>P</mi>&#13;
    <mi>r</mi>&#13;
    <mi>i</mi>&#13;
    <mi>o</mi>&#13;
    <mi>r</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>s</mi>&#13;
      <mi>t</mi>&#13;
      <mi>a</mi>&#13;
      <mi>r</mi>&#13;
      <mi>t</mi>&#13;
      <mi>i</mi>&#13;
      <mi>n</mi>&#13;
      <mi>g</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mspace width="4pt"/>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>w</mi>&#13;
    <mi>e</mi>&#13;
    <mi>i</mi>&#13;
    <mi>g</mi>&#13;
    <mi>h</mi>&#13;
    <mi>t</mi>&#13;
    <mo>=</mo>&#13;
    <mi>l</mi>&#13;
    <mi>o</mi>&#13;
    <msub><mi>g</mi> <mn>2</mn> </msub>&#13;
    <mfrac><mi>λ</mi> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><mi>λ</mi><mo>)</mo></mrow></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mo>-</mo>&#13;
    <mn>9</mn>&#13;
    <mo>.</mo>&#13;
    <mn>38</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper F i r s t n a m e m a t c h w e i g h t left-parenthesis e x a c t m a t c h right-parenthesis equals l o g 2 StartFraction m Subscript f Baseline Over u Subscript f Baseline EndFraction almost-equals 7.67">&#13;
  <mrow>&#13;
    <mi>F</mi>&#13;
    <mi>i</mi>&#13;
    <mi>r</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>n</mi>&#13;
    <mi>a</mi>&#13;
    <mi>m</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>w</mi>&#13;
    <mi>e</mi>&#13;
    <mi>i</mi>&#13;
    <mi>g</mi>&#13;
    <mi>h</mi>&#13;
    <mi>t</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>e</mi>&#13;
      <mi>x</mi>&#13;
      <mi>a</mi>&#13;
      <mi>c</mi>&#13;
      <mi>t</mi>&#13;
      <mspace width="4pt"/>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>=</mo>&#13;
    <mi>l</mi>&#13;
    <mi>o</mi>&#13;
    <msub><mi>g</mi> <mn>2</mn> </msub>&#13;
    <mfrac><msub><mi>m</mi> <mi>f</mi> </msub> <msub><mi>u</mi> <mi>f</mi> </msub></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mn>7</mn>&#13;
    <mo>.</mo>&#13;
    <mn>67</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper F i r s t n a m e m a t c h w e i g h t left-parenthesis n o t e x a c t m a t c h right-parenthesis equals l o g 2 StartFraction left-parenthesis 1 minus m Subscript f Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript f Baseline right-parenthesis EndFraction almost-equals negative 6.98">&#13;
  <mrow>&#13;
    <mi>F</mi>&#13;
    <mi>i</mi>&#13;
    <mi>r</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>n</mi>&#13;
    <mi>a</mi>&#13;
    <mi>m</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>w</mi>&#13;
    <mi>e</mi>&#13;
    <mi>i</mi>&#13;
    <mi>g</mi>&#13;
    <mi>h</mi>&#13;
    <mi>t</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>n</mi>&#13;
      <mi>o</mi>&#13;
      <mi>t</mi>&#13;
      <mspace width="4pt"/>&#13;
      <mi>e</mi>&#13;
      <mi>x</mi>&#13;
      <mi>a</mi>&#13;
      <mi>c</mi>&#13;
      <mi>t</mi>&#13;
      <mspace width="4pt"/>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>=</mo>&#13;
    <mi>l</mi>&#13;
    <mi>o</mi>&#13;
    <msub><mi>g</mi> <mn>2</mn> </msub>&#13;
    <mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi> <mi>f</mi> </msub><mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi> <mi>f</mi> </msub><mo>)</mo></mrow></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mo>-</mo>&#13;
    <mn>6</mn>&#13;
    <mo>.</mo>&#13;
    <mn>98</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper L a s t n a m e m a t c h w e i g h t left-parenthesis e x a c t m a t c h right-parenthesis equals l o g 2 StartFraction m Subscript l Baseline Over u Subscript l Baseline EndFraction almost-equals 10.23">&#13;
  <mrow>&#13;
    <mi>L</mi>&#13;
    <mi>a</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>n</mi>&#13;
    <mi>a</mi>&#13;
    <mi>m</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>w</mi>&#13;
    <mi>e</mi>&#13;
    <mi>i</mi>&#13;
    <mi>g</mi>&#13;
    <mi>h</mi>&#13;
    <mi>t</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>e</mi>&#13;
      <mi>x</mi>&#13;
      <mi>a</mi>&#13;
      <mi>c</mi>&#13;
      <mi>t</mi>&#13;
      <mspace width="4pt"/>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>=</mo>&#13;
    <mi>l</mi>&#13;
    <mi>o</mi>&#13;
    <msub><mi>g</mi> <mn>2</mn> </msub>&#13;
    <mfrac><msub><mi>m</mi> <mi>l</mi> </msub> <msub><mi>u</mi> <mi>l</mi> </msub></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mn>10</mn>&#13;
    <mo>.</mo>&#13;
    <mn>23</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper L a s t n a m e m a t c h w e i g h t left-parenthesis n o t e x a c t m a t c h right-parenthesis equals l o g 2 StartFraction left-parenthesis 1 minus m Subscript l Baseline right-parenthesis Over left-parenthesis 1 minus u Subscript l Baseline right-parenthesis EndFraction almost-equals negative 7.32">&#13;
  <mrow>&#13;
    <mi>L</mi>&#13;
    <mi>a</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>n</mi>&#13;
    <mi>a</mi>&#13;
    <mi>m</mi>&#13;
    <mi>e</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>w</mi>&#13;
    <mi>e</mi>&#13;
    <mi>i</mi>&#13;
    <mi>g</mi>&#13;
    <mi>h</mi>&#13;
    <mi>t</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>n</mi>&#13;
      <mi>o</mi>&#13;
      <mi>t</mi>&#13;
      <mspace width="4pt"/>&#13;
      <mi>e</mi>&#13;
      <mi>x</mi>&#13;
      <mi>a</mi>&#13;
      <mi>c</mi>&#13;
      <mi>t</mi>&#13;
      <mspace width="4pt"/>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>=</mo>&#13;
    <mi>l</mi>&#13;
    <mi>o</mi>&#13;
    <msub><mi>g</mi> <mn>2</mn> </msub>&#13;
    <mfrac><mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>m</mi> <mi>l</mi> </msub><mo>)</mo></mrow> <mrow><mo>(</mo><mn>1</mn><mo>-</mo><msub><mi>u</mi> <mi>l</mi> </msub><mo>)</mo></mrow></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mo>-</mo>&#13;
    <mn>7</mn>&#13;
    <mo>.</mo>&#13;
    <mn>32</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper C o n s t i t u e n c y m a t c h w e i g h t left-parenthesis e x a c t m a t c h right-parenthesis equals l o g 2 StartFraction m Subscript c Baseline Over u Subscript c Baseline EndFraction almost-equals 14.98">&#13;
  <mrow>&#13;
    <mi>C</mi>&#13;
    <mi>o</mi>&#13;
    <mi>n</mi>&#13;
    <mi>s</mi>&#13;
    <mi>t</mi>&#13;
    <mi>i</mi>&#13;
    <mi>t</mi>&#13;
    <mi>u</mi>&#13;
    <mi>e</mi>&#13;
    <mi>n</mi>&#13;
    <mi>c</mi>&#13;
    <mi>y</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>m</mi>&#13;
    <mi>a</mi>&#13;
    <mi>t</mi>&#13;
    <mi>c</mi>&#13;
    <mi>h</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mi>w</mi>&#13;
    <mi>e</mi>&#13;
    <mi>i</mi>&#13;
    <mi>g</mi>&#13;
    <mi>h</mi>&#13;
    <mi>t</mi>&#13;
    <mspace width="4pt"/>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>e</mi>&#13;
      <mi>x</mi>&#13;
      <mi>a</mi>&#13;
      <mi>c</mi>&#13;
      <mi>t</mi>&#13;
      <mspace width="4pt"/>&#13;
      <mi>m</mi>&#13;
      <mi>a</mi>&#13;
      <mi>t</mi>&#13;
      <mi>c</mi>&#13;
      <mi>h</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>=</mo>&#13;
    <mi>l</mi>&#13;
    <mi>o</mi>&#13;
    <msub><mi>g</mi> <mn>2</mn> </msub>&#13;
    <mfrac><msub><mi>m</mi> <mi>c</mi> </msub> <msub><mi>u</mi> <mi>c</mi> </msub></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mn>14</mn>&#13;
    <mo>.</mo>&#13;
    <mn>98</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>For illustration purposes, Splink approximates the <code>Constituency</code> not exact match weight as negative infinity and displays it in a different color. This is because there are no cases where the <code>Firstname</code> and <code>Lastname</code> attributes match but the <code>Constituency</code> does not.</p>&#13;
&#13;
<p>We can see the discrete values Splink has calculated using:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
linker.save_settings_to_json("Chapter4_Splink_Settings.json",&#13;
   overwrite=True)</pre>&#13;
&#13;
<pre>&#13;
{'link_type': 'link_only',&#13;
'comparisons': [{'output_column_name': 'Firstname',&#13;
   'comparison_levels': [{'sql_condition': '"Firstname_l" IS NULL OR&#13;
       "Firstname_r" IS NULL',&#13;
     'label_for_charts': 'Null',&#13;
     'is_null_level': True},&#13;
    {'sql_condition': '"Firstname_l" = "Firstname_r"',&#13;
     'label_for_charts': 'Exact match',&#13;
     'm_probability': 0.992118804074688,&#13;
     'u_probability': 0.004864290128404288},&#13;
    {'sql_condition': 'ELSE',&#13;
     'label_for_charts': 'All other comparisons',&#13;
     'm_probability': 0.007881195925311958,&#13;
     'u_probability': 0.9951357098715956}],&#13;
   'comparison_description': 'Exact match vs. anything else'},&#13;
  {'output_column_name': 'Lastname',&#13;
   'comparison_levels': [{'sql_condition': '"Lastname_l" IS NULL OR&#13;
       "Lastname_r" IS NULL',&#13;
     'label_for_charts': 'Null',&#13;
     'is_null_level': True},&#13;
    {'sql_condition': '"Lastname_l" = "Lastname_r"',&#13;
     'label_for_charts': 'Exact match',&#13;
     'm_probability': 0.9937726043638647,&#13;
     'u_probability': 0.00082730840955421},&#13;
    {'sql_condition': 'ELSE',&#13;
     'label_for_charts': 'All other comparisons',&#13;
     'm_probability': 0.006227395636135347,&#13;
     'u_probability': 0.9991726915904457}],&#13;
   'comparison_description': 'Exact match vs. anything else'},&#13;
  {'output_column_name': 'Constituency',&#13;
   'comparison_levels': [{'sql_condition': '"Constituency_l" IS NULL OR&#13;
       "Constituency_r" IS NULL',&#13;
     'label_for_charts': 'Null',&#13;
     'is_null_level': True},&#13;
    {'sql_condition': '"Constituency_l" = "Constituency_r"',&#13;
     'label_for_charts': 'Exact match',&#13;
     'm_probability': 0.9999999403661186,&#13;
     'u_probability': 3.092071473132138e-05},&#13;
    {'sql_condition': 'ELSE',&#13;
     'label_for_charts': 'All other comparisons',&#13;
     'm_probability': 5.963388147277392e-08,&#13;
     'u_probability': 0.9999690792852688}],&#13;
   'comparison_description': 'Exact match vs. anything else'}],&#13;
'retain_intermediate_calculation_columns': True,&#13;
'retain_matching_columns': True,&#13;
'sql_dialect': 'duckdb',&#13;
'linker_uid': 'adm20und',&#13;
'probability_two_random_records_match': 0.0015075875293170335}</pre>&#13;
&#13;
<p>The <em>m</em> and <em>u</em> probabilities match those we calculated manually using the expectation-maximization algorithm earlier in the chapter.</p>&#13;
&#13;
<p>Finally, as before, we apply a threshold match probability and select the record pair above the threshold:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
pres = linker.predict(threshold_match_probability =&#13;
   0.99).as_pandas_dataframe()&#13;
&#13;
<strong>len(pres)</strong>&#13;
633</pre>&#13;
&#13;
<p>Analysis of these predictions shows that all 633 are true positives, leaving the 13 by-election true negatives and 4 false negatives. We can view the 4 false negatives with:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
m_outer = match.merge(&#13;
   pres,&#13;
   left_on=['Constituency_t'],&#13;
   right_on=['Constituency_l'],&#13;
   how='outer')&#13;
&#13;
m_outer[m_outer['Constituency_t']!=m_outer['Constituency_l']]&#13;
   [['Constituency_w','Lastname_w','Lastname_t']]</pre>&#13;
&#13;
<p>The output, shown in <a data-type="xref" href="#fig-4-8">Figure 4-8</a>, shows that the mismatch on <code>Lastname</code> is the reason these entities fall below the match threshold.</p>&#13;
&#13;
<figure><div class="figure" id="fig-4-8"><img alt="" class="iimagesch04ch04splinknonmatchespng" src="assets/hoer_0408.png"/>&#13;
<h6><span class="label">Figure 4-8. </span>Splink below the threshold due to <code>Lastname</code> mismatch</h6>&#13;
</div></figure>&#13;
&#13;
<p>In comparison to the unweighted results in <a data-type="xref" href="ch03.html#chapter_3">Chapter 3</a>, Splink declares a match for “Liz Truss” versus “Elizabeth Truss,” but does not match “Anne Marie Morris” to “Anne Morris,” nor “Martin Docherty-Hughes” to “Martin Docherty.” This is because it is  more heavily influenced by a mismatch on <code>Lastname</code>, which is statistically a better negative predictor, than a mismatch on <code>Firstname</code>.<a contenteditable="false" data-primary="" data-startref="Sperf04" data-type="indexterm" id="id442"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="id249">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>To recap, we took two sets of records and combined them into a composite dataset containing every record pair combination. We then computed exact match features between equivalent fields and then combined those features, weighted according to how often they occurred in both the matching and nonmatching populations, to determine the overall likelihood of a match.</p>&#13;
&#13;
<p>We saw how to use probability theory to calculate the match weights using the iterative expectation-maximization algorithm when we don’t have known <code>match</code> populations.</p>&#13;
&#13;
<p>Finally, we introduced the probabilistic entity resolution framework Splink, which greatly simplified the calculations when combining multiple attributes and helped us visualize and understand our match results.</p>&#13;
&#13;
<p>Now that we have worked through a small-scale example, we will apply the techniques of approximate and probabilistic matching on a larger scale.</p>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="id429"><sup><a href="ch04.html#id429-marker">1</a></sup> The original paper is available <a href="https://oreil.ly/gcfWx">online</a>.</p></div></div></section></body></html>