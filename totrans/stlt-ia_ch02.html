<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>chapter-3</title>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
 </head>
 <body>
  <div class="readable-text " id="p1"> 
   <h1 class=" readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">3</span></span> Taking an app from concept to code</h1>
  </div>
  <div class="introduction-summary"> 
   <h3>This chapter covers</h3>
   <ul> 
    <li class="readable-text" id="p2">Defining the scope of an application</li>
    <li class="readable-text" id="p3">Designing the user interface</li>
    <li class="readable-text" id="p4">Organizing the code for an app</li>
    <li class="readable-text" id="p5">Streamlit's workhorse input widgets</li>
   </ul>
  </div>
  <div class="readable-text " id="p6"> 
   <p>In my beginning days as a software engineer, I was often surprised by how much of my time was spent on activities other than writing code. I'd spend multiple days or even weeks simply understanding the problem I was trying to solve and even more time in design, all before typing a single line of code.</p>
  </div>
  <div class="readable-text  intended-text" id="p7"> 
   <p>At the time, I felt anxious because I didn't feel <em>productive</em>. Scribbled meeting notes and design docs didn't <em>do </em>anything. With time, I realized that those days and weeks weren't actually wasted; they made the end-product better because of how deeply I'd thought about what I was trying to do.</p>
  </div>
  <div class="readable-text  intended-text" id="p8"> 
   <p>Likewise, this book is not <em>just</em> about teaching you to write Streamlit code. It's about helping you learn to develop apps in the real world. Planning and design are inescapable parts of this process.</p>
  </div>
  <div class="readable-text  intended-text" id="p9"> 
   <p>Though we don't have weeks to spend on these topics, this chapter will give you a taste of the end-to-end experience of developing an app.</p>
  </div>
  <div class="readable-text  intended-text" id="p10"> 
   <p>We'll start with the concept for an app and convert it into a set of requirements. We'll then come up with a design that meets those requirements, working backwards from the user experience, and also think about code organization.</p>
  </div>
  <div class="readable-text  intended-text" id="p11"> 
   <p>Finally, we'll walk through our code and logic, introducing some of Streamlit's most common widgets as we go. That's a lot to get done, so let's get started!</p>
  </div>
  <div class="readable-text" id="p12"> 
   <h2 class=" readable-text-h2">3.1 Concept to code: A six-step process</h2>
  </div>
  <div class="readable-text " id="p13"> 
   <p>Writing a piece of software can be an overwhelming task once you get past the initial spark of inspiration. There are so many things to consider! Where do you start? What features are you going to develop and how long will it take? How will users interact with your app? Should you start coding right away and figure it out as you go?</p>
  </div>
  <div class="readable-text  intended-text" id="p14"> 
   <p>To quote Desmond Tutu: "There is only one way to eat an elephant: a bite at a time.”</p>
  </div>
  <div class="readable-text  intended-text" id="p15"> 
   <p>In creating Streamlit apps, as in consuming large land mammals, the optimal approach is to break it down into smaller chunks. Figure 3.1 displays a simple, logical six-step process you can follow while developing an app, or really just about any piece of software:</p>
  </div>
  <div class="browsable-container figure-container" id="p16">  
   <img src="../Images/03__image001.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.1 The six-stage app development flow</h5>
  </div>
  <ol> 
   <li class="readable-text" id="p17"><strong>State the concept: </strong>To solve a problem—or to describe it to others—you first need to be able to state it succinctly at a high level.</li>
   <li class="readable-text" id="p18"><strong>Define the requirements: </strong>This is where you refine your concept and break it down into cold, hard requirements. Part of this is to define the scope of what your app will and—perhaps more importantly—<em>won't</em> do.</li>
   <li class="readable-text" id="p19"><strong>Visualize the user experience: </strong>Draw diagrams and mocks of what your envisioned user's experience will be when they use your app.</li>
   <li class="readable-text" id="p20"><strong>Brainstorm implementation: </strong>What components will your solution have, how will they integrate with each other, and what tradeoffs do you face?</li>
   <li class="readable-text" id="p21"><strong>Write code: </strong>Actually implement your app.</li>
   <li class="readable-text" id="p22"><strong>Iterate: </strong>Inspect your output and refine steps 1 through 5 as necessary.</li>
  </ol>
  <div class="readable-text " id="p23"> 
   <p>This may sound like a lot, and you may find yourself thinking: "Is this all really necessary? I'm not building enterprise software in a large team, I'm making a fairly small app for a handful of users."</p>
  </div>
  <div class="readable-text  intended-text" id="p24"> 
   <p>The beauty of the above steps is that you can adjust them to what makes sense for your project. If you're working on a large project, each of the above steps may take a long time since there's probably a lot of people that need to agree on the overall approach.</p>
  </div>
  <div class="readable-text  intended-text" id="p25"> 
   <p>But if you're building something small, you can scale each step down to something more reasonable. For instance, you can define the requirements in a quick bullet-point list that takes maybe five minutes to generate, and your visualization of the user experience can be a simple sketch.</p>
  </div>
  <div class="readable-text  intended-text" id="p26"> 
   <p>In the rest of this chapter, we'll go through each of these steps in the context of an example app.</p>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p27"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p28"> 
    <p>For much of this chapter, our attention is going to be on the end-to-end app development process; we'll only cover various Streamlit elements towards the end when we discuss the implementation of the frontend. This is by design, to reflect the real world, where your primary focus in developing a graphical app will be the app itself, not Streamlit. That actually explains the success of Streamlit: it <em>gets out of your way </em>so you can develop your app without worrying too much about how you're going to implement the UI.</p>
   </div>
  </div>
  <div class="readable-text " id="p29"> 
   <p>So even though you won't see a lot of discussion about Streamlit itself in the beginning parts of this chapter, hang in there! We'll get to it organically where it fits best!</p>
  </div>
  <div class="readable-text" id="p30"> 
   <h2 class=" readable-text-h2">3.2 Stating our concept: A unit converter</h2>
  </div>
  <div class="readable-text " id="p31"> 
   <p>Whether it's while studying physics, cooking a meal based on a recipe, or traveling internationally, I'm sure you've been in situations where you've had to convert between different units of measurement like cups to ounces, yards to meters, and so on. You may have had to look up the conversion factor online and then use a calculator to do the actual conversion.</p>
  </div>
  <div class="readable-text  intended-text" id="p32"> 
   <p>The app we'll be working on in this chapter will make this task easier and more streamlined.</p>
  </div>
  <div class="readable-text  intended-text" id="p33"> 
   <p>As we discussed in the last section, the first step in the development process is to "state the concept,” i.e., to express the problem we're trying to solve succinctly, preferably in a single sentence or line.</p>
  </div>
  <div class="readable-text  intended-text" id="p34"> 
   <p>Here's our concept:</p>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p35"> 
    <h5 class=" callout-container-h5 readable-text-h5">Concept</h5>
   </div>
   <div class="readable-text" id="p36"> 
    <p>A Streamlit app that allows users to effortlessly convert between different units of measurement like distance, mass, and time.</p>
   </div>
  </div>
  <div class="readable-text " id="p37"> 
   <p>Stating the concept uncovers the core of what you're trying to do and focuses your thinking, preventing it from wandering off in a dozen directions.</p>
  </div>
  <div class="readable-text  intended-text" id="p38"> 
   <p>As you're developing the app, you may hit upon various new possibilities and potential features to incorporate. The stated concept is there as a reference point to ensure that whatever changes you're considering still satisfy the core idea laid out in it.</p>
  </div>
  <div class="readable-text  intended-text" id="p39"> 
   <p>For instance, you might think, "Maybe I should make a unit overview page where I explain the history of the unit and what it was named after.” If you compare it to our one-line concept, you'll realize that such a page doesn't really help with our goal of having users convert between units effortlessly, so it's probably wise to drop it.</p>
  </div>
  <div class="readable-text  intended-text" id="p40"> 
   <p>Of course, this doesn't mean that the concept you've stated is set in stone. If you encounter an idea that significantly enriches the experience you could provide the user but it doesn't fit well with the concept, feel free to re-state the concept.</p>
  </div>
  <div class="readable-text  intended-text" id="p41"> 
   <p>Finally, stating the concept also has the benefit of giving you a one-line description that you can share with other people to help them understand your work. This can be especially valuable in helping you gain users or find collaborators to partner with.</p>
  </div>
  <div class="readable-text" id="p42"> 
   <h2 class=" readable-text-h2">3.3 Defining the requirements</h2>
  </div>
  <div class="readable-text " id="p43"> 
   <p>Your concept works great as a sort of mission statement for your app, but it's somewhat hand-wavy about the details. The next step then is to break the concept down into concrete <em>requirements</em> you can build towards.</p>
  </div>
  <div class="readable-text  intended-text" id="p44"> 
   <p>Think of these as the specific list of things your <em>stakeholders </em>(your users, teams that you work with, etc.,) would want the app to do.</p>
  </div>
  <div class="readable-text  intended-text" id="p45"> 
   <p>Requirements should:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p46">express a capability the app should have</li>
   <li class="readable-text" id="p47">be free of "implementation" language, e.g., it should not refer to any technology</li>
  </ul>
  <div class="readable-text " id="p48"> 
   <p>For an app you're building in real life, coming up with the list of requirements might involve interviewing people to understand their needs.</p>
  </div>
  <div class="readable-text  intended-text" id="p49"> 
   <p>For the purposes of our example, here's the list of requirements we want to center our app around:</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p50"> 
   <h4 class=" readable-text-h4">Requirements:</h4>
  </div>
  <ul> 
   <li class="readable-text" id="p51">The user should be able to enter a numeric quantity and the unit the quantity is in (the "from-unit").</li>
   <li class="readable-text" id="p52">The user should be able to select a unit to convert to (the "to-unit"), which must measure the same type of thing as the from-unit. No converting from pounds to yards, for instance.</li>
   <li class="readable-text" id="p53">The app should display the converted value as output.</li>
   <li class="readable-text" id="p54">The app should be able to handle conversions within the imperial or metric systems (e.g., feet to inches or meters to centimeters), and across metric systems (e.g., feet to meters).</li>
   <li class="readable-text" id="p55">Adding new units or quantities to the app should be straightforward.</li>
  </ul>
  <div class="readable-text " id="p56"> 
   <p>Notice how the above points are a lot more concrete than our initial concept. Also note how requirements don't just come from the user; they can also come from other people.</p>
  </div>
  <div class="readable-text  intended-text" id="p57"> 
   <p>To elaborate, the first four requirements listed above are things that the <em>user</em> wants, while the last one is something that makes life easier for the <em>developer</em> or <em>maintainer</em> as you'd want to minimize the time you spend in responding to common requests like adding another unit of measurement to the app.</p>
  </div>
  <div class="readable-text  intended-text" id="p58"> 
   <p>In an organizational setting, you can also imagine requirements from other stakeholders, such as the analytics team ("we should be able to monitor and track usage of the app") or the monetization tram ("the app should allow the user to subscribe for a monthly fee").</p>
  </div>
  <div class="readable-text  intended-text" id="p59"> 
   <p>You may have realized that the requirements don't mention anything about the <em>technology</em> used to accomplish them. For example, they don't say "the app should display a Streamlit button the user can click to perform the conversion.”</p>
  </div>
  <div class="readable-text  intended-text" id="p60"> 
   <p>This is intentional; requirements are about what stakeholders actually need. How you fulfill them is up to you, the developer.</p>
  </div>
  <div class="readable-text" id="p61"> 
   <h3 class=" readable-text-h3">3.3.1 Defining what the app won't do</h3>
  </div>
  <div class="readable-text " id="p62"> 
   <p>While listing the requirements is an important step that provides clear goals to accomplish, it can sometimes feel like you're spelling out the obvious. In practice, there's value in doing it even if that's the case because what's obvious to you may not be obvious to your users or your collaborators. It's quite common for people to form a picture in their head about what you're promising that bears no resemblance to reality.</p>
  </div>
  <div class="readable-text  intended-text" id="p63"> 
   <p>For that reason, it's vital—and possibly more enlightening—to also define what's <em>not </em>in your app's scope.</p>
  </div>
  <div class="readable-text  intended-text" id="p64"> 
   <p>For the unit conversion app in this chapter, we want to keep things as simple as possible because we don't want to spend too much time on it; we're mainly building it to get familiar with Streamlit.</p>
  </div>
  <div class="readable-text  intended-text" id="p65"> 
   <p>Any sort of auxiliary functionality that doesn't directly relate to the goal of unit conversion is then immediately out. We don't want to build any usage logging or fancy visualizations.</p>
  </div>
  <div class="readable-text  intended-text" id="p66"> 
   <p>We should also try to keep our conversion logic simple. Converting from pounds to kilograms is easy enough since you can bake the conversion factor into your app, but how about, say, currencies?</p>
  </div>
  <div class="readable-text  intended-text" id="p67"> 
   <p>Converting from dollars to euros is hard because the exchange rate changes from day to day, or even from hour to hour. To incorporate that, you'd need to read the exchange rates from somewhere, like an online API. We'll read from an API in later projects in this book, but for now, it's probably best to avoid the additional complexity. So currencies are out.</p>
  </div>
  <div class="readable-text  intended-text" id="p68"> 
   <p>To state it formally:</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p69"> 
   <h4 class=" readable-text-h4">What's out of scope</h4>
  </div>
  <ul> 
   <li class="readable-text" id="p70">Usage tracking, logging, visualizations etc., that do not directly relate to unit conversion</li>
   <li class="readable-text" id="p71">Conversions between units that don't share a simple, constant conversion factor, such as those between currencies</li>
  </ul>
  <div class="readable-text " id="p72"> 
   <p>This can be a useful tool for prioritization and phasing. Even if you're placing something out of scope at the moment, you may want to build it later on.</p>
  </div>
  <div class="readable-text  intended-text" id="p73"> 
   <p>Articulating the requirements and scope lets you express what features you consider to be priority and which ones you might want to push to a future version.</p>
  </div>
  <div class="readable-text  intended-text" id="p74"> 
   <p>If you have additional stakeholders, having these written down is a good way to elicit feedback and start a conversation about prioritization.</p>
  </div>
  <div class="readable-text" id="p75"> 
   <h2 class=" readable-text-h2">3.4 Visualizing the user experience</h2>
  </div>
  <div class="readable-text " id="p76"> 
   <p>So far, we've spent a fair amount of time thinking about the problem we want to solve; we've conceptualized what we'll be building, refined our understanding of what our app needs to do, and even articulated what it <em>won't</em> do.</p>
  </div>
  <div class="readable-text  intended-text" id="p77"> 
   <p>What we haven't done yet is to start designing a solution. That's what we'll do in this next step.</p>
  </div>
  <div class="readable-text  intended-text" id="p78"> 
   <p>When you start the process of actually developing an app, you may find yourself wondering what to do first. Do you simply start coding your Python app from top to bottom, figuring out your design as you go? Do you try to figure out what the basic components of your app are and how they'll fit together? Or maybe you work on what you think will be the hardest part of the problem to get it out of the way?</p>
  </div>
  <div class="readable-text  intended-text" id="p79"> 
   <p>Those are all valid approaches and there are arguments to be made in favor of each of them. One approach I've always found valuable, and the one we'll follow in this chapter, is to <em>work backwards from the user experience</em>.</p>
  </div>
  <div class="readable-text  intended-text" id="p80"> 
   <p>Beginning from the user experience is a good way of ensuring the quality of the end product, because it puts the user front and center, directly addressing their needs and preferences. It also helps identify and solve potential usability issues early on in the process.</p>
  </div>
  <div class="readable-text" id="p81"> 
   <h3 class=" readable-text-h3">3.4.1 Creating a mock</h3>
  </div>
  <div class="readable-text " id="p82"> 
   <p>So what experience do we want the users of our app to have? To answer that, let's create a mock or sketch of what the UI might look like.</p>
  </div>
  <div class="readable-text  intended-text" id="p83"> 
   <p>Looking back at the requirements we enumerated in section 3.3, at its core, the app needs to provide a way for users to input a numeric quantity and the units to convert from and to.</p>
  </div>
  <div class="readable-text  intended-text" id="p84"> 
   <p>Figure 3.2 shows a quick initial sketch.</p>
  </div>
  <div class="browsable-container figure-container" id="p85">  
   <img src="../Images/03__image002.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.2 An initial mock of the unit conversion app</h5>
  </div>
  <div class="readable-text " id="p86"> 
   <p>Figure 3.2 shows a first attempt at a UI design. It's quite simple: there's a box where you can type in the value to convert, and you can choose the from- and to- units from a select box. Once you're done you click a "Convert" button and the answer appears below.</p>
  </div>
  <div class="readable-text  intended-text" id="p87"> 
   <p>You can make a diagram like this with a pen and paper, a marker and whiteboard, or any graphics program you prefer. It doesn't really have to be elaborate or even particularly neat. The important thing is that it should show the end outcome you're trying to create, forcing you to think about your app from the user's perspective.</p>
  </div>
  <div class="readable-text" id="p88"> 
   <h3 class=" readable-text-h3">3.4.2 Getting the user experience right</h3>
  </div>
  <div class="readable-text " id="p89"> 
   <p>Let's take a closer look at our mock. There are select boxes to pick a from- unit and a to- unit, but what if the units aren't compatible? What if the user chooses "Pounds" (a unit of mass) as the from-unit and "Feet" (which measures length) as the to-unit and tries to convert between them (see figure 3.3)?</p>
  </div>
  <div class="browsable-container figure-container" id="p90">  
   <img src="../Images/03__image003.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.3 Our initial UI makes it possible for users to select incompatible units, like "Pounds" to "Feet"</h5>
  </div>
  <div class="readable-text " id="p91"> 
   <p>You could display an error message, of course. That would work, but it wouldn't be a great experience for the user. Users generally like their experience to be as frictionless as possible, and they <em>hate</em> getting errors. A better UI would render it impossible to make the mistake in the first place.</p>
  </div>
  <div class="readable-text  intended-text" id="p92"> 
   <p>For example, perhaps when the user selects "Pounds,” we could narrow the options in the to-unit dropdown to only units that are compatible with pounds (see figure 3.4).</p>
  </div>
  <div class="browsable-container figure-container" id="p93">  
   <img src="../Images/03__image004.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.4 We could update the to-unit dropdown to only show units compatible with the selected from-unit</h5>
  </div>
  <div class="readable-text " id="p94"> 
   <p>That solves the incompatible-units problem, but may introduce another issue. What if the user wants to select the <em>to-unit</em> first? We could potentially apply the reverse logic and update the from-unit list to only contain units compatible with the selected to-unit. Essentially, whatever unit is selected first, the other dropdown is restricted to units compatible with that one, as seen in figure 3.5.</p>
  </div>
  <div class="browsable-container figure-container" id="p95">  
   <img src="../Images/03__image005.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.5 Two-way restriction: When a unit is selected, the other dropdown updates to only show compatible units</h5>
  </div>
  <div class="readable-text " id="p96"> 
   <p>But what if the user <em>now</em> wants to do a conversion between units of a different quantity altogether, say a length conversion from feet to inches?</p>
  </div>
  <div class="readable-text  intended-text" id="p97"> 
   <p>When they try to select "Feet" in the from-unit list, they find it's not in the list any more, because the from-unit is artificially restricted to only units of mass by the selection in the to-unit dropdown, which says "Kilograms" (see figure 3.6).</p>
  </div>
  <div class="browsable-container figure-container" id="p98">  
   <img src="../Images/03__image006.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.6 Prior selections create a confusing experience because the user can't now select units from other quantities</h5>
  </div>
  <div class="readable-text " id="p99"> 
   <p>There are multiple ways to fix this.</p>
  </div>
  <div class="readable-text  intended-text" id="p100"> 
   <p>We could enforce a rule that the user has to select a from-unit first. This feels like a somewhat artificial restriction though, and not one that's inherent to the business problem.</p>
  </div>
  <div class="readable-text  intended-text" id="p101"> 
   <p>We could instead introduce a reset button for the user to click whenever they want to start a new conversion, resetting both dropdowns. This works and isn't <em>terrible </em>but it seems like a lot of work for the user.</p>
  </div>
  <div class="readable-text  intended-text" id="p102"> 
   <p>The most intuitive way to handle this would be to simply add another input for the type of quantity the user wants to convert. If the user selects "Mass" in this new dropdown, for example, the from- and to- units would only have units of mass as seen in figure 3.7. Thus, instead of restricting the dropdowns based on each other, we restrict them based on a third external selection.</p>
  </div>
  <div class="browsable-container figure-container" id="p103">  
   <img src="../Images/03__image007.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.7 Adding a quantity-type selector makes the app more intuitive</h5>
  </div>
  <div class="readable-text " id="p104"> 
   <p>This solves the issue much more elegantly while being quite intuitive to the user. It's obvious what the user needs to do here: pick a quantity, enter a value, pick the from- and to- units and click "Convert.”</p>
  </div>
  <div class="readable-text  intended-text" id="p105"> 
   <p>Note that while figure 3.7 shows radio buttons for the quantity type, we could have gone with a dropdown too. The radio button switches things up a bit and involves one less click than a dropdown, but the experience with a dropdown isn't significantly worse. In any case, when you actually get to the implementation using Streamlit, you may identify entirely new possibilities for how to present inputs.</p>
  </div>
  <div class="readable-text  intended-text" id="p106"> 
   <p>I hope this gives you an understanding of how to start designing a UI and some of the tradeoffs involved. There will, of course, always be more factors we <em>could</em> concern ourselves with—for example, does our user care about imperial vs metric system units and should our UI differentiate between them in some way?—but this is already a solid foundation we can feel comfortable with.</p>
  </div>
  <div class="readable-text  intended-text" id="p107"> 
   <p>We've done a fair amount of refinement to our UI, but you still shouldn't feel that it's necessarily final. As we dive deeper into implementation, you may find more optimizations you'd like to make. In fact, we'll encounter some of these in the following sections and iterate upon our design.</p>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p108"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p109"> 
    <p>Since you'll be implementing your UI design using Streamlit, a natural question that might arise while visualizing the user experience is whether you should keep in mind the various elements available in Streamlit so you don't design something you can't actually build.</p>
   </div>
  </div>
  <div class="readable-text " id="p110"> 
   <p>In my opinion, that's putting the cart before the horse. In the ideal world, you want to figure out the best experience for your users, and then <em>implement</em> it using Streamlit. You don't want to let Streamlit limit your thinking about what the ideal user experience looks like.</p>
  </div>
  <div class="readable-text  intended-text" id="p111"> 
   <p>Of course, this carries some risk; you may, on rare occasions, find that Streamlit doesn't have the exact elements that you were hoping for in your design, and need to adjust your implementation. But that will actually enrich your learning journey by making Streamlit's deficiencies clearer. It will also ensure your user experience won't be constrained by your preconceptions of Streamlit's feature set, which is expanding all the time.</p>
  </div>
  <div class="readable-text" id="p112"> 
   <h2 class=" readable-text-h2">3.5 Brainstorming the implementation</h2>
  </div>
  <div class="readable-text " id="p113"> 
   <p>We now know roughly what the end-user experience in our app will be like. Let's turn our attention to making that experience happen.</p>
  </div>
  <div class="readable-text  intended-text" id="p114"> 
   <p>In this step of the process, we'll enumerate the various parts of our solution, discuss how they fit together, and map out the flow of logic.</p>
  </div>
  <div class="readable-text  intended-text" id="p115"> 
   <p>There are two big parts to pretty much any application: a frontend and a backend. The frontend handles how the user interacts with your app, i.e., how we collect inputs and display outputs. The backend is the app's "brain" that takes inputs from the frontend, processes them, and hands the output to the frontend to display to the user.</p>
  </div>
  <div class="readable-text  intended-text" id="p116"> 
   <p>Based on the last section, we already have a fair idea of what the frontend of our app looks like; we just need to translate the UI to the corresponding elements available in Streamlit, which we'll do in our code walkthrough.</p>
  </div>
  <div class="readable-text  intended-text" id="p117"> 
   <p>We'll therefore turn our attention to the backend, starting with the actual unit conversion.</p>
  </div>
  <div class="readable-text" id="p118"> 
   <h3 class=" readable-text-h3">3.5.1 Performing the actual unit conversion</h3>
  </div>
  <div class="readable-text " id="p119"> 
   <p>Let's say we want to convert 5 pounds (lbs) to ounces (oz). From an online search (I grew up with the metric system), 1 pound equals 16 oz.</p>
  </div>
  <div class="readable-text  intended-text" id="p120"> 
   <p>Thus, to convert 5 lb to oz, we would multiply 16 by 5 to get 80 oz.</p>
  </div>
  <div class="readable-text  intended-text" id="p121"> 
   <p>We'll refer to the number 16 here as the <em>lb-to-oz conversion factor.</em></p>
  </div>
  <div class="readable-text  intended-text" id="p122"> 
   <p>Every pair of units has a similar conversion factor. For instance, 1 yard equals 3 feet, so the yard-to-foot conversion factor is 3. To take an imperial-to-metric example, 1 mile equals 1.609344 km, so the mile-to-km conversion factor is 1.609344.</p>
  </div>
  <div class="readable-text  intended-text" id="p123"> 
   <p>To state this generally, given any pair of units X and Y, to convert a given value expressed in X to Y,</p>
  </div>
  <div class="browsable-container equation-container" id="p124"> 
   <div>
     Value in unit Y = Value in unit X * X-to-Y conversion factor 
   </div>
  </div>
  <div class="readable-text " id="p125"> 
   <p>To do the reverse conversions (e.g., ounces to pounds), you can use a conversion factor calculated as 1 divided by the original conversion factor.</p>
  </div>
  <div class="readable-text  intended-text" id="p126"> 
   <p>So,</p>
  </div>
  <div class="browsable-container equation-container" id="p127"> 
   <div>
     1 yard = 3 feet; 1 foot = ⅓ yards; foot-to-yard conversion factor = ⅓ 
   </div>
  </div>
  <div class="browsable-container equation-container" id="p128"> 
   <div>
     1 mile = 1.609344 km; 1 km = 1/1.609344 = 0.621372 miles; km-to-mile conversion factor = 0.621372 
   </div>
  </div>
  <div class="readable-text " id="p129"> 
   <p>With this information, it seems like all we need to do is to collect the conversion factor for every pair of possible units within a quantity type, and apply the formula given above.</p>
  </div>
  <div class="readable-text  intended-text" id="p130"> 
   <p>But there's a problem: we could end up with a lot of conversion factors to keep track of.</p>
  </div>
  <div class="readable-text  intended-text" id="p131"> 
   <p>Let's say that we want users to be able to convert between 3 units: pounds, kilograms, and ounces</p>
  </div>
  <div class="readable-text  intended-text" id="p132"> 
   <p>There are 3 x (3-1) = 3 x 2 = 6 possible types of conversions that can be done: pounds to kilograms, kilograms to pounds, pounds to ounces, ounces to pounds, ounces to kilograms, and kilograms to ounces.</p>
  </div>
  <div class="readable-text  intended-text" id="p133"> 
   <p>This means we need to keep track of 6 conversion factors. From our discussion above, we've seen that if we know the X-to-Y conversion factor, then the Y-to-X conversion factor is simply 1 divided by the X-to-Y conversion factor. Using this, we can whittle down the number of conversion factors we need to keep track of from 6 to 6 / 2 = 3.</p>
  </div>
  <div class="readable-text  intended-text" id="p134"> 
   <p>In general, if you have n units, to be able to convert between any pair of them, we would need n (n-1) / 2 conversion factors.</p>
  </div>
  <div class="readable-text  intended-text" id="p135"> 
   <p>Our example above didn't seem too bad. But what if we have a lot more than 3 units of a particular quantity type? What if we have 20?</p>
  </div>
  <div class="readable-text  intended-text" id="p136"> 
   <p>In this scenario, we would need to keep track of 20 * (20-1) / 2 = 20 * 19 / 2 = 190 conversion factors. Whew! That's a <em>lot</em> of numbers to track in your code.</p>
  </div>
  <div class="readable-text  intended-text" id="p137"> 
   <p>But isn't 20 units for a single quantity type a little extreme? Not really. Take distance or length. If you count the metric system's prefixes that signify magnitude and include units used in astronomy or navigation, you'll come up with something like the following list:</p>
  </div>
  <div class="readable-text  intended-text" id="p138"> 
   <p>kilometers, meters, decimeters, centimeters, millimeters, micrometers, nanometers, angstroms, inches, feet, yards, miles, furlongs, astronomical units, parsecs, light years, nautical miles, fathoms, leagues, cubits, picometers, decameters, hectometers… you get the picture.</p>
  </div>
  <div class="readable-text  intended-text" id="p139"> 
   <p>Clearly, keeping track of conversion factors for every single pair of units is not sustainable.</p>
  </div>
  <div class="readable-text  intended-text" id="p140"> 
   <p>Instead, what we want to do is to designate one unit from each quantity as the <em>standard unit</em> for that quantity and only keep track of conversion factors to that unit from all the others.</p>
  </div>
  <div class="readable-text  intended-text" id="p141"> 
   <p>For instance, if we make meters the standard unit for distance, we would only keep track of the conversion factor from each unit to meters, i.e. "what is the value 1 in this unit in meters?"</p>
  </div>
  <div class="readable-text  intended-text" id="p142"> 
   <p>Then, to convert from unit X to unit Y, we could convert from unit X to meters and then from meters to unit Y.</p>
  </div>
  <div class="readable-text  intended-text" id="p143"> 
   <p>So if we want to convert 5 yards to centimeters:</p>
  </div>
  <ul> 
   <li class="readable-text buletless-item" style="list-style-type: none;" id="p144">Yard-to-meter conversion factor = 0.9144</li>
   <li class="readable-text buletless-item" style="list-style-type: none;" id="p145">Centimeter-to-meter conversion factor = 0.01</li>
  </ul>
  <div class="readable-text " id="p146"> 
   <p>We can then follow a two-step conversion process (see figure 3.8):</p>
  </div>
  <ol> 
   <li class="readable-text" id="p147">5 yards = 5 x 0.9144 meters = 4.572 meters</li>
   <li class="readable-text" id="p148">4.572 meters = 4.572 x 1 / 0.01 centimeters = 457.2 centimeters</li>
  </ol>
  <div class="browsable-container figure-container" id="p149">  
   <img src="../Images/03__image008.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.8 Converting from yards to centimeters using meters as a standard intermediate unit</h5>
  </div>
  <div class="readable-text " id="p150"> 
   <p>Notice that since we always store the conversion factor of a unit <em>to</em> meters, in step 2, we had to divide 1 by the factor to get the reverse conversion factor, i.e., meter-to-centimeter.</p>
  </div>
  <div class="readable-text " id="p151"> 
   <p>Putting this more generally, given a pair of units X and Y and a standard unit S, to convert a value expressed in X to Y,</p>
  </div>
  <div class="browsable-container equation-container" id="p152"> 
   <div>
     Value in unit S = Value in unit X * X-to-S conversion factor 
   </div>
  </div>
  <div class="browsable-container equation-container" id="p153"> 
   <div>
     Value in unit Y = Value in unit S * 1 / Y-to-S conversion factor 
   </div>
  </div>
  <div class="readable-text " id="p154"> 
   <p>We now end up with a much more manageable number of conversion factors: since we only care about how many standard units a given unit is, we can get away with storing just one factor per unit.</p>
  </div>
  <div class="readable-text" id="p155"> 
   <h3 class=" readable-text-h3">3.5.2 Tracking units and conversion factors</h3>
  </div>
  <div class="readable-text " id="p156"> 
   <p>Recall that one of our original requirements is that adding new units to the app must be straightforward.</p>
  </div>
  <div class="readable-text  intended-text" id="p157"> 
   <p>When we speak of "adding new units" here, we're referring to us updating the app to include more conversion units to convert between, not the user being able to dynamically add units themselves.</p>
  </div>
  <div class="readable-text  intended-text" id="p158"> 
   <p>This is an example of a <em>non-user requirement</em>. Our user presumably does not care about how easy it is for us to add new units; they care that the units are available for them to convert between. So who <em>does</em> care? The developer does. <em>We</em> do.</p>
  </div>
  <div class="readable-text  intended-text" id="p159"> 
   <p>As a developer, you're usually never done with a piece of software once you've launched it. If your app is used by enough people, you can count on a consistent stream of feedback, reported bugs, and requested features coming your way and eating up the time that you were planning to spend on other projects. Or worse, someone <em>else </em>will be tasked with maintaining your code, and they'll have no idea how it works.</p>
  </div>
  <div class="readable-text  intended-text" id="p160"> 
   <p>In this situation, if you haven't designed your app's implementation for ease of maintenance, someone will have to spend a significant amount of time digging through your code to figure out the right place to make a change and make sure there are no side-effects. Even if you're not feeling particularly charitable towards other developers, there's always the likelihood that the <em>someone </em>will be you. Speaking from personal experience, you'd be surprised at how little you'll remember about the code you wrote as recently as a month ago.</p>
  </div>
  <div class="readable-text  intended-text" id="p161"> 
   <p>Coming back to our unit converter, one of the most common maintenance tasks you might need to perform is to add new units, and we want to make that as simple as possible. Ideally, there should be exactly one place in the code where you'd need to add the unit and its conversion factor, and it should be the most obvious place.</p>
  </div>
  <div class="readable-text  intended-text" id="p162"> 
   <p>A good way to achieve this is to keep a master list of all quantities, units and conversion factors in a single configuration file. The file should have an obvious format, and adding a new unit should be as easy as appending a few lines in the file.</p>
  </div>
  <div class="readable-text  intended-text" id="p163"> 
   <p>Critically, this configuration file should be the <em>only</em> file that refers to any specific quantities. That means that no other places in the app should refer to specific quantities or units, like meters or pounds. That's because if they did, adding a new quantity or unit would require updating that part of the code too, which breaks our requirement of it being straightforward to update the code.</p>
  </div>
  <div class="readable-text  intended-text" id="p164"> 
   <p>This has an interesting implication: we can't hard-code quantities or units into our UI code at any point. Everything related to specific quantities or units needs to be pulled from the configuration file. The rest of our code needs to be independent of them.</p>
  </div>
  <div class="readable-text  intended-text" id="p165"> 
   <p>We'll see how to do this in our code walkthrough later in the chapter.</p>
  </div>
  <div class="readable-text" id="p166"> 
   <h3 class=" readable-text-h3">3.5.3 Mapping the flow of logic</h3>
  </div>
  <div class="readable-text " id="p167"> 
   <p>We now have a good understanding of all of the individual pieces of our app: the frontend, the conversion logic, and the configuration.</p>
  </div>
  <div class="readable-text  intended-text" id="p168"> 
   <p>Before we code them up, it's useful to have a mental model of how they fit together. Figure 3.9 shows the overall design of our app.</p>
  </div>
  <div class="browsable-container figure-container" id="p169">  
   <img src="../Images/03__image009.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.9 Overall design and logic flow for our unit conversion app</h5>
  </div>
  <div class="readable-text " id="p170"> 
   <p>The configuration file that we discussed in the previous section powers the quantity selector radio buttons from the UI we visualized earlier (figure 3.10).</p>
  </div>
  <div class="browsable-container figure-container" id="p171">  
   <img src="../Images/03__image010.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.10 Quantity selector radio buttons from our mocks</h5>
  </div>
  <div class="readable-text " id="p172"> 
   <p>Once the user has selected a quantity, the from- and to- unit dropdowns update based on the selected quantity (again powered by the configuration file).</p>
  </div>
  <div class="readable-text  intended-text" id="p173"> 
   <p>When the user has selected the from- and to- units and clicked the "Convert" button, all entries are sent to the backend where the conversion factors from the configuration are used to perform the two-step conversion outlined in section 3.5.1.</p>
  </div>
  <div class="readable-text  intended-text" id="p174"> 
   <p>The converted value is then returned to the frontend where the user can see it.</p>
  </div>
  <div class="readable-text" id="p175"> 
   <h3 class=" readable-text-h3">3.5.4 The backend API</h3>
  </div>
  <div class="readable-text " id="p176"> 
   <p>There's a key concept in software development called <em>separation of concerns</em>. In essence, this means that each building block in a piece of software should focus on one aspect of the overall system's functionality, and should be independent of the other building blocks. Where a block interacts with another, it should do so in strictly controlled ways as defined by a <em>contract</em>.</p>
  </div>
  <div class="readable-text  intended-text" id="p177"> 
   <p>To understand this better, consider how a drive-in fast food restaurant might operate. There's a person at the front taking orders from customers and a kitchen that prepares the food based on a menu. The order-taker doesn't care what ingredients the kitchen uses as long as it can make the items on the menu, and the kitchen doesn't care what language the order-taker speaks to the customer in, as long as the items ordered are from the menu.</p>
  </div>
  <div class="readable-text  intended-text" id="p178"> 
   <p>If the kitchen wants to hire new cooks or use different ingredients, it can do so without informing the order-taker, as long as the dishes prepared match the menu. If we want to replace the in-person order taker with someone on the phone, we can do that too, without affecting the kitchen.</p>
  </div>
  <div class="readable-text  intended-text" id="p179"> 
   <p>The thing that makes this possible is the menu, which is a common shared <em>contract</em> through which the order-taker and kitchen interact.</p>
  </div>
  <div class="readable-text  intended-text" id="p180"> 
   <p>Similarly, it's a good idea while developing an app to separate its components and have them interact exclusively through a contract called an <em>Application Programming Interface</em> (API for short). In the context of our app, we should maintain this separation between the frontend and the backend.</p>
  </div>
  <div class="readable-text  intended-text" id="p181"> 
   <p>This means that our frontend should only interact with the backend to ask it to perform any of a certain list of actions.</p>
  </div>
  <div class="readable-text  intended-text" id="p182"> 
   <p>What exactly are these actions? Let's revisit our logic flow diagram in figure 3.11. There are four arrows between the frontend and the backend:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p183">one where the frontend pulls in the quantities to show the user,</li>
   <li class="readable-text" id="p184">one where it pulls in the units corresponding to the quantity selected by the user,</li>
   <li class="readable-text" id="p185">one where the frontend provides the values to be converted, and</li>
   <li class="readable-text" id="p186">one where the backend returns the conversion value</li>
  </ul>
  <div class="browsable-container figure-container" id="p187">  
   <img src="../Images/03__image011.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.11 Flow diagram for our app with the API actions highlighted</h5>
  </div>
  <div class="readable-text " id="p188"> 
   <p>These can be boiled down into three interactions (the last two arrows are really two parts of the same interaction) that the frontend has with the backend:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p189"><strong>List-quantities: </strong>The frontend asks the backend to provide the list of quantities it supports.</li>
   <li class="readable-text" id="p190"><strong>List-units: </strong>The frontend gives the backend a quantity and asks it to list the units it knows how to convert between in that quantity.</li>
   <li class="readable-text" id="p191"><strong>Convert-value: </strong>The frontend gives the backend the value to convert and the units selected by the user, and asks it to do the conversion.</li>
  </ul>
  <div class="readable-text " id="p192"> 
   <p>The above actions form the menu or API of our backend. As in our fast food example, as long as the backend can fulfill these responsibilities, it's free to implement them however it wants. Perhaps at some point, we'll find a more efficient way to perform conversions. Or maybe want to hook up the backend to an external service to perform the conversion. In either case, we can change the backend implementation without touching the frontend code.</p>
  </div>
  <div class="readable-text  intended-text" id="p193"> 
   <p>Or maybe at some point we'll want to enable a command-line interface to our conversion app in addition to our graphical UI. In that instance, we can simply add it with no changes required to our existing frontend code.</p>
  </div>
  <div class="readable-text  intended-text" id="p194"> 
   <p>As you can see, separating concerns between the frontend and the backend gives us a lot of flexibility. Our app is simple enough that the benefits may not be obvious, but this is a good habit to develop as it'll help you in the real world when you develop more complex apps and need to switch out components easily.</p>
  </div>
  <div class="readable-text  intended-text" id="p195"> 
   <p>We'll see how to actually implement this API approach very soon.</p>
  </div>
  <div class="readable-text" id="p196"> 
   <h2 class=" readable-text-h2">3.6 Writing code</h2>
  </div>
  <div class="readable-text " id="p197"> 
   <p>At this point, we've spent enough time thinking about the design of our app that we're ready to write some code.</p>
  </div>
  <div class="readable-text  intended-text" id="p198"> 
   <p>In this section, we'll walk through the code for our app, starting with our configuration file, which plays a central role in our design. We'll define a <em>contract </em>or <em>API </em>between our frontend and backend, then make our backend fulfill that contract.</p>
  </div>
  <div class="readable-text  intended-text" id="p199"> 
   <p>Finally, we'll write our frontend, learning about the Streamlit elements that make our UI possible as we do so, and have it issue calls to the backend through our defined contract to close the loop.</p>
  </div>
  <div class="readable-text" id="p200"> 
   <h3 class=" readable-text-h3">3.6.1 Creating the configuration file</h3>
  </div>
  <div class="readable-text " id="p201"> 
   <p>Our configuration file is what holds information about the quantities and units our app understands.</p>
  </div>
  <div class="readable-text  intended-text" id="p202"> 
   <p>From our design, we know that the app needs to look up the units for a given quantity. Furthermore, given a unit, it needs to be able to look up its conversion factor with respect to the standard unit for that quantity.</p>
  </div>
  <div class="readable-text  intended-text" id="p203"> 
   <p>A Python dictionary sounds like it would be ideal for this task. Each key in this dictionary would be a quantity, and the associated values would be a list of units, or better yet, <em>another </em>dictionary where the keys are units and values are the corresponding conversion factors.</p>
  </div>
  <div class="readable-text  intended-text" id="p204"> 
   <p>One possible way to write this might be something like the following:</p>
  </div>
  <div class="browsable-container listing-container" id="p205"> 
   <div class="code-area-container"> 
    <pre class="code-area">unit_config = {
    "Mass": {
        "Kilograms": 1, # Standard unit
        "Grams": 0.001,
        "Pounds": 0.453592,
        # ...
    },
    "Length": {
        "Meters": 1,  # Standard unit
        "Centimeters": 0.01,
        # ...
    },
}</pre>
   </div>
  </div>
  <div class="readable-text " id="p206"> 
   <p>This certainly works, but it would be nice if we could also display the abbreviation for a unit (e.g., 'oz' for ounces or 'kg' for kilograms), and maybe we should store the standard unit for a quantity as well.</p>
  </div>
  <div class="readable-text  intended-text" id="p207"> 
   <p>We're getting to the point where units and quantities are well-defined "things" with their own attributes (a unit has an abbreviation and a conversion factor, a quantity has a bunch of units and one unit that's designated as the standard one). We <em>could</em> represent this complexity by expanding our dictionary to have more "layers,” but it would be better practice to define <em>classes</em> for units and quantities.</p>
  </div>
  <div class="readable-text  intended-text" id="p208"> 
   <p>So spin up your code editor and create a file called <kbd>unit.py</kbd> (see listing 3.1) to define the Unit class. We're going to use a <em>dataclass</em> here, which is a special type of class in Python, enabled through the <kbd>dataclasses</kbd> module, which is part of Python's standard library.</p>
  </div>
  <div class="browsable-container listing-container" id="p209"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 3.1 unit.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">from dataclasses import dataclass
 
@dataclass
class Unit:
    abbrev: str
    value_in_std_units: float</pre>
   </div>
  </div>
  <div class="readable-text " id="p210"> 
   <p>A dataclass is an easy way to create a class with some standard basic functionality. For instance, with dataclasses, you don't need to specify a <kbd>__init__</kbd> method as you would do with a normal class, and once you have an object of the dataclass, you can access its attributes with the dot-notation, like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p211"> 
   <div class="code-area-container"> 
    <pre class="code-area">gram = Unit(abbrev="g", value_in_std_units=0.001)
print(gram.abbrev) # Prints 'g'</pre>
   </div>
  </div>
  <div class="readable-text " id="p212"> 
   <p>To achieve the same functionality with a regular class, you would have had to write:</p>
  </div>
  <div class="browsable-container listing-container" id="p213"> 
   <div class="code-area-container"> 
    <pre class="code-area">class Unit:
    def __init__(self, abbrev, value_in_std_units):
        self.abbrev: str = abbrev
        self.value_in_std_units: float = value_in_std_units</pre>
   </div>
  </div>
  <div class="readable-text " id="p214"> 
   <p>With dataclasses, you can use the much more concise syntax from Listing 3.1 by including the <kbd>@dataclass</kbd> decorator above your class definition.</p>
  </div>
  <div class="readable-text  intended-text" id="p215"> 
   <p>Turning to the contents of the class, you can see that they're pretty simple; there's an <kbd>abbrev</kbd> string field that holds the abbreviation for the unit, and a <kbd>value_in_std_units</kbd>, a floating point number which represents the conversion factor we discussed in Section 3.5.1.</p>
  </div>
  <div class="readable-text  intended-text" id="p216"> 
   <p>The <kbd>: str</kbd> and <kbd>: float </kbd>from Listing 3.1 are called <em>type annotations</em>. They're used to specify the data type of a field. Type annotations are not strictly required, but it's a good practice to include them, since (among other things) they make your code easier to understand and allow your code editor or IDE to catch and highlight errors early on.</p>
  </div>
  <div class="readable-text  intended-text" id="p217"> 
   <p>You may have noticed that we haven't included a <kbd>name</kbd> field in the <kbd>Unit</kbd> class. We'll discuss why when we get to the configuration file.</p>
  </div>
  <div class="readable-text  intended-text" id="p218"> 
   <p>Let's also define a <kbd>Quantity</kbd> class in a new file, <kbd>quantity.py</kbd>.</p>
  </div>
  <div class="browsable-container listing-container" id="p219"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 3.2 quantity.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">from dataclasses import dataclass
from typing import Dict
 
from unit import Unit
 
@dataclass
class Quantity:
    std_unit: str
    units: Dict[str, Unit]
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p220"> 
   <p>Listing 3.2 shows the <kbd>Quantity</kbd> class. It contains two fields: <kbd>units</kbd> and <kbd>std_unit</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p221"> 
   <p><kbd>std_unit</kbd> here is the name of the standard unit for that quantity.</p>
  </div>
  <div class="readable-text  intended-text" id="p222"> 
   <p>Notice the more complex type annotation we're using for the <kbd>units</kbd> field. <kbd>Dict[str, Unit]</kbd> means that <kbd>units</kbd> is a dictionary where each key is a string (the name of the unit) and the corresponding value is an object of the <kbd>Unit</kbd> class. Annotations for some of the more advanced types need to be imported from the <kbd>typing</kbd> module.</p>
  </div>
  <div class="readable-text  intended-text" id="p223"> 
   <p>With that out of the way, we can now create our final configuration file (see Listing 3.3).</p>
  </div>
  <div class="browsable-container listing-container" id="p224"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 3.3 unit_config.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">from typing import Dict
 
from quantity import Quantity
from unit import Unit
 
unit_config: Dict[str, Quantity] = {
    "Mass": Quantity(
        std_unit="Kilograms",
        units={
            "Kilograms": Unit(abbrev="kg", value_in_std_units=1),
            "Grams": Unit(abbrev="g", value_in_std_units=0.001),
            "Pounds": Unit(abbrev="lb", value_in_std_units=0.453592),
            "Ounces": Unit(abbrev="oz", value_in_std_units=0.0283495),
            # Add more units here
        }
    ),
    "Length": Quantity(
        std_unit="Meters",
        units={
            "Meters": Unit(abbrev="m", value_in_std_units=1),
            "Centimeters": Unit(abbrev="cm", value_in_std_units=0.01),
            "Inches": Unit(abbrev="in", value_in_std_units=0.0254),
            "Feet": Unit(abbrev="ft", value_in_std_units=0.3048),
        }
    ),
    "Time": Quantity(
        std_unit="Seconds",
        units={
            "Seconds": Unit(abbrev="s", value_in_std_units=1),
            "Minutes": Unit(abbrev="min", value_in_std_units=60),
            "Hours": Unit(abbrev="hr", value_in_std_units=3600),
            "Days": Unit(abbrev="d", value_in_std_units=86400),
        }
    ),
    # Add more quantities here
}</pre>
   </div>
  </div>
  <div class="readable-text " id="p225"> 
   <p>Our configuration is still in the form of a dictionary, but each dictionary value is now an object of the <kbd>Quantity</kbd> class. Our file includes three quantities: mass, length, and time.</p>
  </div>
  <div class="readable-text  intended-text" id="p226"> 
   <p>Let's inspect one of these:</p>
  </div>
  <div class="browsable-container listing-container" id="p227"> 
   <div class="code-area-container"> 
    <pre class="code-area">"Mass": Quantity(
        std_unit="Kilograms",
        units={
            "Kilograms": Unit(abbrev="kg", value_in_std_units=1),
            "Grams": Unit(abbrev="g", value_in_std_units=0.001),
            "Pounds": Unit(abbrev="lb", value_in_std_units=0.453592),
            "Ounces": Unit(abbrev="oz", value_in_std_units=0.0283495),
            # Add more units here
        }
    )
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p228"> 
   <p>As you can see, this is quite readable. We're configuring a quantity named "Mass" as a <kbd>Quantity</kbd> object with a standard unit of "Kilograms.” The <kbd>units</kbd> dictionary has four entries, one for each unit, where the value is a <kbd>Unit</kbd> object with an abbreviation and conversion factor.</p>
  </div>
  <div class="readable-text  intended-text" id="p229"> 
   <p>Since "Kilograms" is the standard unit, its <kbd>value_in_std_units </kbd>is 1.</p>
  </div>
  <div class="readable-text  intended-text" id="p230"> 
   <p>You may now also realize why neither of the <kbd>Unit</kbd> and <kbd>Quantity</kbd> classes have a <kbd>name</kbd> field. Since the unit and quantity names are already incorporated into the dictionary keys in <kbd>unit_config.py</kbd>, also having it in the class is unnecessary and would make the configuration file longer and less readable.</p>
  </div>
  <div class="readable-text  intended-text" id="p231"> 
   <p>Adding more units is easy; you would just add new entries to the <kbd>units</kbd> dictionary within the <kbd>Quantity</kbd>. Similarly, adding new quantities simply requires appending to the <kbd>unit_config</kbd> dictionary, following the format of the previous entries.</p>
  </div>
  <div class="readable-text" id="p232"> 
   <h3 class=" readable-text-h3">3.6.2 Implementing the API</h3>
  </div>
  <div class="readable-text " id="p233"> 
   <p>Earlier in the chapter (section 3.5.4), we enumerated the actions we want the backend to be able to take:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p234">List-quantities</li>
   <li class="readable-text" id="p235">List-units</li>
   <li class="readable-text" id="p236">Convert-value</li>
  </ul>
  <div class="readable-text " id="p237"> 
   <p>Let's now actually implement these.</p>
  </div>
  <div class="readable-text  intended-text" id="p238"> 
   <p>We want each of the above actions to be a function in the backend. For each, we'll come up with the function signature first, and then implement it.</p>
  </div>
  <div class="readable-text  intended-text" id="p239"> 
   <p><strong>List-quantities </strong>is pretty simple; it asks the backend to list all the quantities it knows. There are no arguments required, and the output would probably be a list of strings. Thus:</p>
  </div>
  <div class="browsable-container listing-container" id="p240"> 
   <div class="code-area-container"> 
    <pre class="code-area">def list_quantities() -&gt; List[str]</pre>
   </div>
  </div>
  <div class="readable-text " id="p241"> 
   <p>How do we implement this? Well, the quantities we need are the keys of our configuration object from <kbd>unit_config.py</kbd> (in listing 3.3). So we can simply write:</p>
  </div>
  <div class="browsable-container listing-container" id="p242"> 
   <div class="code-area-container"> 
    <pre class="code-area">def list_quantities() -&gt; List[str]:
    return list(unit_config.keys())</pre>
   </div>
  </div>
  <div class="readable-text " id="p243"> 
   <p><strong>List-units</strong> <em>does</em> take an argument (the quantity to list the units of), and it would again return a list of strings. So we get:</p>
  </div>
  <div class="browsable-container listing-container" id="p244"> 
   <div class="code-area-container"> 
    <pre class="code-area">def list_units(quantity_name) -&gt; List[str]</pre>
   </div>
  </div>
  <div class="readable-text " id="p245"> 
   <p>Implementing this is also fairly straightforward. The list we need is composed of the keys of the <kbd>units</kbd> dictionary from the <kbd>Quantity</kbd> object corresponding to the <kbd>quantity_name</kbd> key in <kbd>unit_config</kbd>.</p>
  </div>
  <div class="browsable-container listing-container" id="p246"> 
   <div class="code-area-container"> 
    <pre class="code-area">def list_units(quantity_name) -&gt; List[str]:
    return list(unit_config[quantity_name].units.keys())</pre>
   </div>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p247"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p248"> 
    <p>You might realize that we're not handling the scenario where the provided <kbd>quantity_name</kbd> doesn't exist in <kbd>unit_config</kbd>. In the real world, we should absolutely do that, but for this chapter, I've excluded error handling to keep the code relatively concise. We'll tackle error handling in future chapters.</p>
   </div>
  </div>
  <div class="readable-text " id="p249"> 
   <p><strong>Convert-value </strong>takes four arguments: a quantity name, the from- and to- units, and a value to convert. We want to include the quantity name here due to the possibility that different quantities may have a unit that's called the same (though our example configuration doesn't have this).</p>
  </div>
  <div class="readable-text  intended-text" id="p250"> 
   <p>As for the return type, we <em>could</em> simply return the converted value, which would be a floating point number, and nothing else.</p>
  </div>
  <div class="readable-text  intended-text" id="p251"> 
   <p>Recall, however, that our configuration also has abbreviations for each unit. It would be nice if, on conversion, we were also able to give the frontend the appropriate abbreviations so it can display something like "15 ft = 5 yd."</p>
  </div>
  <div class="readable-text  intended-text" id="p252"> 
   <p>On the other hand, we don't want to be prescriptive about how the frontend <em>actually</em> displays the results; that's the frontend's business—remember <em>separation of concerns</em>? If the frontend wants to just show the converted number with no abbreviation, that's totally fine too.</p>
  </div>
  <div class="readable-text  intended-text" id="p253"> 
   <p>One approach would be to wrap any metadata the frontend might need in a dedicated <kbd>Result</kbd> class and let the frontend figure out what to do with it.</p>
  </div>
  <div class="readable-text  intended-text" id="p254"> 
   <p>Let's define the <kbd>Result</kbd> class in a new file called <kbd>result.py</kbd> (listing 3.4).</p>
  </div>
  <div class="browsable-container listing-container" id="p255"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 3.4 result.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">from dataclasses import dataclass
from unit import Unit
 
@dataclass
class Result:
    from_unit: Unit
    to_unit: Unit
    from_value: float
    to_value: float
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p256"> 
   <p>Note that rather than placing just the abbreviation for each unit in the result, we're including the entire <kbd>Unit</kbd>. If we decide to modify the <kbd>Unit</kbd> class later and add more properties to it, this code won't need to change.</p>
  </div>
  <div class="readable-text  intended-text" id="p257"> 
   <p>With that, we're ready to define the signature for <strong>Convert-value</strong>:</p>
  </div>
  <div class="browsable-container listing-container" id="p258"> 
   <div class="code-area-container"> 
    <pre class="code-area">def convert_value(
        quantity_name: str,
        from_unit_name: str,
        to_unit_name: str,
        value: float) -&gt; Result</pre>
   </div>
  </div>
  <div class="readable-text " id="p259"> 
   <p>We've already discussed how to implement the conversion, but here it is in code form:</p>
  </div>
  <div class="browsable-container listing-container" id="p260"> 
   <div class="code-area-container"> 
    <pre class="code-area">def convert_value(
        quantity_name: str,
        from_unit_name: str,
        to_unit_name: str,
        value: float) -&gt; Result:
    quantity = unit_config[quantity_name]
    from_unit = quantity.units[from_unit_name]
    to_unit = quantity.units[to_unit_name]
 
    # Two-step conversion: from-unit to standard unit, then to to-unit
    value_in_to_units = (value *
                         from_unit.value_in_std_units /
                         to_unit.value_in_std_units)
 
    return Result(from_unit, to_unit, value, value_in_to_units)
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p261"> 
   <p>Notice the two-step conversion we discussed earlier. <kbd>value * from_unit.value_in_std_units</kbd> gives the value in standard units, and the <kbd>/ to_unit.value_in_std_units</kbd> converts it to the to-unit.</p>
  </div>
  <div class="readable-text  intended-text" id="p262"> 
   <p>Listing 3.5 puts this all together in a single <kbd>backend.py</kbd> file.</p>
  </div>
  <div class="browsable-container listing-container" id="p263"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 3.5 backend.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">from unit_config import unit_config
from result import Result
from typing import List
 
def list_quantities() -&gt; List[str]:
    return list(unit_config.keys())
 
def list_units(quantity_name) -&gt; List[str]:
    return list(unit_config[quantity_name].units.keys())
 
def convert_value(
        quantity_name: str,
        from_unit_name: str,
        to_unit_name: str,
        value: float) -&gt; Result:
    quantity = unit_config[quantity_name]
    from_unit = quantity.units[from_unit_name]
    to_unit = quantity.units[to_unit_name]
 
    # Two-step conversion: from-unit to standard unit, then to to-unit
    value_in_to_units = (value *
                         from_unit.value_in_std_units /
                         to_unit.value_in_std_units)
 
    return Result(from_unit, to_unit, value, value_in_to_units)
 </pre>
   </div>
  </div>
  <div class="readable-text" id="p264"> 
   <h3 class=" readable-text-h3">3.6.3 Implementing the frontend</h3>
  </div>
  <div class="readable-text " id="p265"> 
   <p>We're finally in the portion of this chapter where you'll actually be using Streamlit!</p>
  </div>
  <div class="readable-text  intended-text" id="p266"> 
   <p>First we'll explore each of the features of Streamlit we'll be using, referring to our UI design from earlier (shown in figure 3.12), and then we'll use them to create our frontend.</p>
  </div>
  <div class="browsable-container figure-container" id="p267">  
   <img src="../Images/03__image007.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.12 The UI visualization for our unit converter app for reference</h5>
  </div>
  <div class="readable-text " id="p268"> 
   <p>We're going to be building our UI incrementally. To start, create a new Python file called <kbd>frontend.py</kbd> and add the imports we need (i.e., Streamlit itself, and the backend API functions we defined).</p>
  </div>
  <div class="browsable-container listing-container" id="p269"> 
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
from backend import convert_value, list_quantities, list_units
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p270"> 
   <p>Save your file and run the following in the terminal:</p>
  </div>
  <div class="browsable-container listing-container" id="p271"> 
   <div class="code-area-container"> 
    <pre class="code-area">streamlit run frontend.py
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p272"> 
   <p>or <kbd>streamlit run &lt;path to frontend.py&gt;</kbd> if your working directory is not the same one that contains <kbd>frontend.py.</kbd></p>
  </div>
  <div class="readable-text  intended-text" id="p273"> 
   <p>This will open a browser window with your app (currently just a blank screen). Each time you make a change, switch back to the browser window and click "Rerun" or "Always rerun" to see the results.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p274"> 
   <h4 class=" readable-text-h4">st.radio</h4>
  </div>
  <div class="readable-text " id="p275"> 
   <p>The first component of the UI we'll focus on is the quantity selector, which is a bunch of radio buttons set in a panel on the left.</p>
  </div>
  <div class="readable-text  intended-text" id="p276"> 
   <p>Radio buttons are a UI element that lets a user pick a single item out of a given list of items.</p>
  </div>
  <div class="readable-text  intended-text" id="p277"> 
   <p>For example, if you append the following to the <kbd>frontend.py</kbd> file you just created:</p>
  </div>
  <div class="browsable-container listing-container" id="p278"> 
   <div class="code-area-container"> 
    <pre class="code-area">quantity = st.radio("Select a quantity", ["Mass", "Force", "Pressure"])</pre>
   </div>
  </div>
  <div class="readable-text " id="p279"> 
   <p>Streamlit will display the question "Select a quantity" and a list of radio buttons with "Mass," "Force," and "Pressure" as options. Once the user has selected one, the variable <kbd>quantity</kbd> will contain the option that the user picked (i.e., the string "Mass," "Force," or "Pressure").</p>
  </div>
  <div class="readable-text  intended-text" id="p280"> 
   <p>In our case, our list of options will come from the backend where you'll recall that we have a function called <kbd>list_quantities</kbd> (listing 3.5). So we would instead write:</p>
  </div>
  <div class="browsable-container listing-container" id="p281"> 
   <div class="code-area-container"> 
    <pre class="code-area">quantity = st.radio("Select a quantity", list_quantities())</pre>
   </div>
  </div>
  <div class="readable-text " id="p282"> 
   <p>This gives us the output shown in figure 3.13. We now get "Mass," "Length," and "Time" as options because <kbd>list_quantities</kbd> fetches the keys of <kbd>unit_config</kbd> (from our configuration file) and returns them as a list that forms the second argument to <kbd>st.radio</kbd>.</p>
  </div>
  <div class="browsable-container figure-container" id="p283">  
   <img src="../Images/03__image012.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.13 An example output for st.radio</h5>
  </div>
  <div class="readable-text " id="p284"> 
   <p>The <kbd>quantity</kbd> variable will contain the item currently selected by the user (e.g., "Mass" in figure 3.8).</p>
  </div>
  <div class="readable-text  intended-text" id="p285"> 
   <p>Streamlit offers plenty of customization for <kbd>st.radio</kbd>. You can set the options horizontally instead of vertically, add a caption to each option, disable them altogether, and so on.</p>
  </div>
  <div class="readable-text  intended-text" id="p286"> 
   <p>You can find a complete list of customization possibilities in the Streamlit docs at <a href="https://docs.streamlit.io/develop/api-reference/widgets/st.radio">https://docs.streamlit.io/develop/api-reference/widgets/st.radio</a>.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p287"> 
   <h4 class=" readable-text-h4">st.sidebar</h4>
  </div>
  <div class="readable-text " id="p288"> 
   <p>We've created our radio buttons, but we now need them in a panel to the left as shown in figure 3.12.</p>
  </div>
  <div class="readable-text  intended-text" id="p289"> 
   <p>This kind of panel, in Streamlit terminology, is a <em>sidebar</em>. Sidebars are extremely useful when you want to create a bunch of links that lead to different pages in the app, provide some meta-information about your app, etc.</p>
  </div>
  <div class="readable-text  intended-text" id="p290"> 
   <p>To use <kbd>st.sidebar</kbd>, you need to put something within it. There are two ways to do this:</p>
  </div>
  <div class="readable-text  intended-text" id="p291"> 
   <p>You can use a context manager (i.e., Python <kbd>with</kbd> statement) like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p292"> 
   <div class="code-area-container"> 
    <pre class="code-area">with st.sidebar:
    quantity = st.radio("Select a quantity", list_quantities())</pre>
   </div>
  </div>
  <div class="readable-text " id="p293"> 
   <p>Any Streamlit element you place inside the <kbd>with</kbd> statement will be displayed in the sidebar.</p>
  </div>
  <div class="readable-text  intended-text" id="p294"> 
   <p>You can also use a dot notation and refer to an element you want to place inside the sidebar as a member of the sidebar, like so:</p>
  </div>
  <div class="browsable-container listing-container" id="p295"> 
   <div class="code-area-container"> 
    <pre class="code-area">quantity = st.sidebar.radio("Select a quantity", list_quantities())</pre>
   </div>
  </div>
  <div class="readable-text " id="p296"> 
   <p>Appending either of the above to <kbd>frontend.py</kbd> produces the output shown in figure 3.14.</p>
  </div>
  <div class="browsable-container figure-container" id="p297">  
   <img src="../Images/03__image013.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.14 st.sidebar in action with a set of radio buttons inside</h5>
  </div>
  <div class="readable-text " id="p298"> 
   <p>A sidebar is displayed with an 'X' icon that collapses it or a '&gt;' icon that expands a collapsed sidebar.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p299"> 
   <h4 class=" readable-text-h4">st.title</h4>
  </div>
  <div class="readable-text " id="p300"> 
   <p>With the sidebar in place, let's turn our attention to the main area of the app. Users need to know what the app is and what it does, so we'll add a title:</p>
  </div>
  <div class="browsable-container listing-container" id="p301"> 
   <div class="code-area-container"> 
    <pre class="code-area">st.title("Unit Converter")</pre>
   </div>
  </div>
  <div class="readable-text " id="p302"> 
   <p>This should be pretty self-explanatory, but just to state it explicitly, <kbd>st.title</kbd> writes any string passed to it as a title, i.e., in large bold font.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p303"> 
   <h4 class=" readable-text-h4">st.text_input</h4>
  </div>
  <div class="readable-text " id="p304"> 
   <p>Next, we need the user to enter the value they want to convert. Let's use a text input for this.</p>
  </div>
  <div class="readable-text  intended-text" id="p305"> 
   <p><kbd>st.text_input</kbd> is Streamlit's way of letting users enter single-line values. We can write:</p>
  </div>
  <div class="browsable-container listing-container" id="p306"> 
   <div class="code-area-container"> 
    <pre class="code-area">input_num = st.text_input("Value to convert", value="0")</pre>
   </div>
  </div>
  <div class="readable-text " id="p307"> 
   <p>to display a text input with the caption "Value to convert" and an initial value of "0.” Note that <kbd>st.text_input</kbd> returns a string, so <kbd>input_num</kbd> has the string "0.”</p>
  </div>
  <div class="readable-text  intended-text" id="p308"> 
   <p>We want to maintain this as a number, so we'll also cast the value to float:</p>
  </div>
  <div class="browsable-container listing-container" id="p309"> 
   <div class="code-area-container"> 
    <pre class="code-area">input_num = float(st.text_input("Value to convert", value="0"))</pre>
   </div>
  </div>
  <div class="readable-text " id="p310"> 
   <p>With the title and text input, our app should look like figure 3.15.</p>
  </div>
  <div class="browsable-container figure-container" id="p311">  
   <img src="../Images/03__image014.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.15 Unit Converter app after adding a title and text input</h5>
  </div>
  <div class="readable-text " id="p312"> 
   <p><kbd>st.text_input</kbd> has lots of customization options, such as placeholder text that's displayed when there's no entered value, an optional tooltip, and the ability to enter passwords (we encountered this in our password checker app in Chapter 2).</p>
  </div>
  <div class="readable-text  intended-text" id="p313"> 
   <p>Again, docs.streamlit.io has more detail on what's available.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p314"> 
   <h4 class=" readable-text-h4">st.selectbox</h4>
  </div>
  <div class="readable-text " id="p315"> 
   <p>We need dropdowns for the user to pick the from- and to- units, so let's create those next.</p>
  </div>
  <div class="readable-text " id="p316"> 
   <p><kbd>st.selectbox</kbd> is what we're looking for here. It displays a basic select widget with a label and a set of options.</p>
  </div>
  <div class="readable-text  intended-text" id="p317"> 
   <p>The arguments are similar to what you would pass to <kbd>st.radio</kbd>. For example, we could write:</p>
  </div>
  <div class="browsable-container listing-container" id="p318"> 
   <div class="code-area-container"> 
    <pre class="code-area">country = st.selectbox("Pick a country", ["United States", "Canada", "India"])</pre>
   </div>
  </div>
  <div class="readable-text " id="p319"> 
   <p>to display a country dropdown with the variable <kbd>country</kbd> containing the selected option. When the dropdown first renders, the first option ("United States" in this case) is selected by default.</p>
  </div>
  <div class="readable-text  intended-text" id="p320"> 
   <p>For our use case, we need to first collect the list of options to display. We can call <kbd>list_units</kbd> from our backend to fetch the units available for the quantity the user has selected:</p>
  </div>
  <div class="browsable-container listing-container" id="p321"> 
   <div class="code-area-container"> 
    <pre class="code-area">units = list_units(quantity)</pre>
   </div>
  </div>
  <div class="readable-text " id="p322"> 
   <p>We can then use this list to populate the options in our from- and to- unit dropdowns:</p>
  </div>
  <div class="browsable-container listing-container" id="p323"> 
   <div class="code-area-container"> 
    <pre class="code-area">from_unit = st.selectbox("From", units)
to_unit = st.selectbox("To", units, index=1)</pre>
   </div>
  </div>
  <div class="readable-text " id="p324"> 
   <p>The <kbd>index</kbd> parameter we've included in the second dropdown is used to set the default selected option. A value of '1' means the second option will be selected on the first render.</p>
  </div>
  <div class="readable-text  intended-text" id="p325"> 
   <p>We do this because we don't want both the from- and to- dropdowns to have the same default selected value, since that would almost never be useful (users wouldn't want to convert from kilograms to kilograms).</p>
  </div>
  <div class="readable-text  intended-text" id="p326"> 
   <p>At this point, our app looks like figure 3.16.</p>
  </div>
  <div class="browsable-container figure-container" id="p327">  
   <img src="../Images/03__image015.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.16 Unit Converter app after adding from- and to- unit dropdowns</h5>
  </div>
  <div class="readable-text " id="p328"> 
   <p>This is <em>fine</em>, but our design had the from- and to- dropdowns side by side, which seems more natural.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p329"> 
   <h4 class=" readable-text-h4">st.columns</h4>
  </div>
  <div class="readable-text " id="p330"> 
   <p>By default, Streamlit displays the UI elements from top-to-bottom in the same order that it encounters them in your code.</p>
  </div>
  <div class="readable-text  intended-text" id="p331"> 
   <p>Naturally, you don't always want this; sometimes you want things laid out side by side. We saw how to do this with <kbd>st.sidebar</kbd>, but an app can only have one sidebar, and it appears to the left of the overall UI; it can't be inline.</p>
  </div>
  <div class="readable-text  intended-text" id="p332"> 
   <p><kbd>st.columns</kbd> is the answer here. To use it, you would first create a list of columns, specifying the number of columns you want:</p>
  </div>
  <div class="browsable-container listing-container" id="p333"> 
   <div class="code-area-container"> 
    <pre class="code-area">from_unit_col, to_unit_col = st.columns(2)</pre>
   </div>
  </div>
  <div class="readable-text " id="p334"> 
   <p>Here, the call to <kbd>st.columns(2)</kbd> returns a list of two columns. The syntax we're using here is called <em>list unpacking</em>, and it assigns the individual items of a list to different variables. As you might imagine, here <kbd>from_unit_col</kbd> will contain the first column and <kbd>to_unit_col</kbd> will contain the second.</p>
  </div>
  <div class="readable-text  intended-text" id="p335"> 
   <p>As in the case of <kbd>st.sidebar</kbd>, there are two ways to put something in a column: using the <kbd>with</kbd> context manager or the dot notation. So we could write:</p>
  </div>
  <div class="browsable-container listing-container" id="p336"> 
   <div class="code-area-container"> 
    <pre class="code-area">with from_unit_col:
    from_unit = st.selectbox("From", units)
with to_unit_col:
    to_unit = st.selectbox("To", units, index=1)</pre>
   </div>
  </div>
  <div class="readable-text " id="p337"> 
   <p>or more concisely,</p>
  </div>
  <div class="browsable-container listing-container" id="p338"> 
   <div class="code-area-container"> 
    <pre class="code-area">from_unit = from_unit_col.selectbox("From", units)
to_unit = to_unit_col.selectbox("To", units, index=1)</pre>
   </div>
  </div>
  <div class="readable-text " id="p339"> 
   <p>Generally speaking, the <kbd>with</kbd> context manager makes more sense when you have multiple elements to display within a container (whether it's a sidebar, a column, or something else), while the dot notation works better when you only have a single item or when you want to display elements out of order. We'll see plenty of examples of these cases throughout this book.</p>
  </div>
  <div class="readable-text  intended-text" id="p340"> 
   <p>Figure 3.17 shows our app by this point:</p>
  </div>
  <div class="browsable-container figure-container" id="p341">  
   <img src="../Images/03__image016.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.17 Unit Converter app with side-by-side from- and to- unit dropdowns</h5>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p342"> 
   <h4 class=" readable-text-h4">st.button</h4>
  </div>
  <div class="readable-text " id="p343"> 
   <p>With all the inputs captured, we're ready to add our "Convert" button.</p>
  </div>
  <div class="readable-text  intended-text" id="p344"> 
   <p>I hope you remember <kbd>st.button</kbd> from Chapter 2, Streamlit's ol' faithful make-something-happen element.</p>
  </div>
  <div class="readable-text  intended-text" id="p345"> 
   <p>To add our button, we would write:</p>
  </div>
  <div class="browsable-container listing-container" id="p346"> 
   <div class="code-area-container"> 
    <pre class="code-area">if st.button("Convert"):
    # Statements to execute</pre>
   </div>
  </div>
  <div class="readable-text " id="p347"> 
   <p>This should be easy enough to understand. It says, "display a button that says 'Convert' and if/when the user clicks it, execute some statements.”</p>
  </div>
  <div class="readable-text  intended-text" id="p348"> 
   <p>Once we've written out what we want the button to do, this will render a barebones Streamlit red-on-white button with the functionality we've defined.</p>
  </div>
  <div class="readable-text  intended-text" id="p349"> 
   <p>So what do we actually want our button to do? Our backend has a <kbd>convert_value</kbd> function that performs the unit conversion, so let's start by calling that:</p>
  </div>
  <div class="browsable-container listing-container" id="p350"> 
   <div class="code-area-container"> 
    <pre class="code-area">if st.button("Convert"):
    result = convert_value(quantity, from_unit, to_unit, input_num)</pre>
   </div>
  </div>
  <div class="readable-text " id="p351"> 
   <p>Here, we're passing <kbd>convert_value</kbd> the user-selected quantity, the from- and to- units, and the value to convert. Recall that <kbd>convert_value</kbd> returns an object of the class <kbd>Result</kbd> (defined in <kbd>result.py</kbd>)</p>
  </div>
  <div class="readable-text  intended-text" id="p352"> 
   <p>The variable <kbd>result</kbd> thus has the result of our conversion, complete with the from- and to- values and abbreviations. All that remains is to display it on the screen. Enter…</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p353"> 
   <h4 class=" readable-text-h4">st.metric</h4>
  </div>
  <div class="readable-text " id="p354"> 
   <p>We could have displayed our result as plain old paragraph text, but this is the big outcome of our app we're talking about, the grand finale. We want something that packs more <em>punch</em>.</p>
  </div>
  <div class="readable-text  intended-text" id="p355"> 
   <p><kbd>st.metric</kbd> is a widget that's commonly used in dashboards to show important numbers—like the revenue of a company—and how they're trending as compared to a prior period.</p>
  </div>
  <div class="readable-text  intended-text" id="p356"> 
   <p>A single <kbd>st.metric</kbd> element is meant to represent a measure the user interested in, and it consists of three parts: a text label, the number itself displayed in large font, and a "delta indicator,” which is a value that shows how much the number has increased or decreased from a prior period.</p>
  </div>
  <div class="readable-text  intended-text" id="p357"> 
   <p>We're going to use <kbd>st.metric</kbd> to display the from- and to- values along with the abbreviations of the units, so let's first prepare these:</p>
  </div>
  <div class="browsable-container listing-container" id="p358"> 
   <div class="code-area-container"> 
    <pre class="code-area">from_display = f"{result.from_value} {result.from_unit.abbrev}"
to_display = f"{result.to_value} {result.to_unit.abbrev}"</pre>
   </div>
  </div>
  <div class="readable-text " id="p359"> 
   <p>Since result is an <kbd>Result</kbd> object, we form the display text by concatenating its <kbd>from_value</kbd> or <kbd>to_value</kbd> field and grabbing the abbreviation from <kbd>from_unit</kbd> or <kbd>to_unit</kbd>, which is itself an instance of <kbd>Unit</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p360"> 
   <p>To actually use <kbd>st.metric</kbd>, we write:</p>
  </div>
  <div class="browsable-container listing-container" id="p361"> 
   <div class="code-area-container"> 
    <pre class="code-area">st.metric("From", from_display, delta=None)
st.metric("To", to_display, delta=None)</pre>
   </div>
  </div>
  <div class="readable-text " id="p362"> 
   <p>The delta indicator in <kbd>st.metric</kbd> doesn't make sense for us, so we set it to <kbd>None</kbd> to hide it.</p>
  </div>
  <div class="readable-text  intended-text" id="p363"> 
   <p>The above will display the from- and to- results vertically, but we need them side-by-side, so let's use <kbd>st.columns</kbd> again:</p>
  </div>
  <div class="browsable-container listing-container" id="p364"> 
   <div class="code-area-container"> 
    <pre class="code-area">from_value_col, to_value_col = st.columns(2)
from_value_col.metric("From", from_display, delta=None)
to_value_col.metric("To", to_display, delta=None)</pre>
   </div>
  </div>
  <div class="readable-text " id="p365"> 
   <p>Figure 3.18 shows our completed app.</p>
  </div>
  <div class="browsable-container figure-container" id="p366">  
   <img src="../Images/03__image017.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.18 Our completed unit converter app</h5>
  </div>
  <div class="readable-text " id="p367"> 
   <p>Listing 3.6 shows the <kbd>frontend.py</kbd> file you should have ended up with if you've been following along.</p>
  </div>
  <div class="browsable-container listing-container" id="p368"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 3.6 frontend.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
from backend import convert_value, list_quantities, list_units
 
quantity = st.sidebar.radio("Select a quantity", list_quantities())
 
st.title("Unit Converter")
input_num = float(st.text_input("Value to convert", value="0"))
 
units = list_units(quantity)
from_unit_col, to_unit_col = st.columns(2)
from_unit = from_unit_col.selectbox("From", units)
to_unit = to_unit_col.selectbox("To", units, index=1)
 
if st.button("Convert"):
    result = convert_value(quantity, from_unit, to_unit, input_num)
    from_display = f"{result.from_value} {result.from_unit.abbrev}"
    to_display = f"{result.to_value} {result.to_unit.abbrev}"
 
    from_value_col, to_value_col = st.columns(2)
    from_value_col.metric("From", from_display, delta=None)
    to_value_col.metric("To", to_display, delta=None)</pre>
   </div>
  </div>
  <div class="readable-text" id="p369"> 
   <h2 class=" readable-text-h2">3.7 Iterating on our app</h2>
  </div>
  <div class="readable-text " id="p370"> 
   <p>Whew! We did it! We now have a fully functional app on our hands. In the real world, this would just be the <em>start</em> of your journey and you would now launch your app and show it to users.</p>
  </div>
  <div class="readable-text  intended-text" id="p371"> 
   <p>Users will often have very opinionated feedback about the experience you've built for them and can help you uncover usability issues and blind spots you may not have encountered in your testing.</p>
  </div>
  <div class="readable-text  intended-text" id="p372"> 
   <p>In this section, we'll simulate this process by using the app ourselves and identifying potential improvements we can make.</p>
  </div>
  <div class="readable-text" id="p373"> 
   <h3 class=" readable-text-h3">3.7.1 Rounding our conversion results</h3>
  </div>
  <div class="readable-text " id="p374"> 
   <p>Let's take our completed app for a spin. Figure 3.18 shows the example results of converting kilograms to grams.</p>
  </div>
  <div class="readable-text  intended-text" id="p375"> 
   <p>That looks mostly fine, but let's try a metric-to-imperial conversion now. Say we want to convert 4000 kilograms to pounds. We fire up our app, choose "Mass," enter our inputs and hit "Convert" to see figure 3.19.</p>
  </div>
  <div class="browsable-container figure-container" id="p376">  
   <img src="../Images/03__image018.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.19 A metric-to-imperial conversion that shows why we should be rounding</h5>
  </div>
  <div class="readable-text " id="p377"> 
   <p>The answer we got seems right, but that's an awful lot of decimal places. Most people probably don't need that level of precision; in fact it probably detracts from their experience as it takes them a second to figure out why the displayed number is so long.</p>
  </div>
  <div class="readable-text  intended-text" id="p378"> 
   <p>It would be nice if users had the option of rounding the result to the precision they really need. And come to think of it, for larger numbers we should ideally separate the thousands by commas.</p>
  </div>
  <div class="readable-text  intended-text" id="p379"> 
   <p>To implement this, let's first create a function called <kbd>format_value </kbd>that will format a number the way we want it, i.e., with commas separating the thousands, and optionally rounded to a certain number of decimal points.</p>
  </div>
  <div class="readable-text  intended-text" id="p380"> 
   <p><kbd>format_value </kbd>takes three arguments: the value to format, the abbreviation, and an optional number of <kbd>decimal_places</kbd> to round the value to. If we don't pass the latter (i.e., <kbd>is_rounded</kbd> is false<kbd>)</kbd>, the function won't do any rounding.</p>
  </div>
  <div class="browsable-container listing-container" id="p381"> 
   <div class="code-area-container"> 
    <pre class="code-area">def format_value(
        value: float,
        unit_abbrev: str,
        decimal_places: int = None) -&gt; str:
    is_rounded = decimal_places is not None
    rounded = round(value, decimal_places) if is_rounded else value
    formatted = format(rounded, ",")
    return f"{formatted} {unit_abbrev}"</pre>
   </div>
  </div>
  <div class="readable-text " id="p382"> 
   <p>We use the <kbd>round</kbd> function to perform the actual rounding if we need to and Python's built-in <kbd>format</kbd> function to add the commas, using "," as the <em>format spec</em>.</p>
  </div>
  <div class="readable-text  intended-text" id="p383"> 
   <p>We could just hardcode the number of decimal places to round to, but ideally we should let the user decide, which means adding a new input widget.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p384"> 
   <h4 class=" readable-text-h4">st.number_input</h4>
  </div>
  <div class="readable-text " id="p385"> 
   <p><kbd>st.number_input</kbd> is Streamlit's numeric input widget. It's quite similar to <kbd>st.text_input</kbd>, but it has some additional functionality, such as the ability to specify a minimum and maximum value, and a step button that lets you increase or decrease the entered value by clicking.</p>
  </div>
  <div class="readable-text  intended-text" id="p386"> 
   <p>We can use it to collect the user's preferred number of decimal places by adding this line to <kbd>frontend.py</kbd> right after the from- and to- unit dropdowns:</p>
  </div>
  <div class="browsable-container listing-container" id="p387"> 
   <div class="code-area-container"> 
    <pre class="code-area">places = st.number_input("Decimal places to round to", value=2, min_value=0)</pre>
   </div>
  </div>
  <div class="readable-text " id="p388"> 
   <p>We specify a default value of 2, and a minimum value of 0 since we can't have a negative number of decimal places (trying to enter a lower value shows an error. <kbd>places</kbd> will hold the entered number.</p>
  </div>
  <div class="readable-text  intended-text" id="p389"> 
   <p>This should give us the widget shown in figure 3.20.</p>
  </div>
  <div class="browsable-container figure-container" id="p390">  
   <img src="../Images/03__image019.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.20 st.number_input</h5>
  </div>
  <div class="readable-text " id="p391"> 
   <p>Notice the '-' and '+' buttons that let you increase or decrease the value by 1. You can adjust the step-interval to something else by specifying the <kbd>step</kbd> parameter in <kbd>st.number_input</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p392"> 
   <p>You may be wondering why we bothered to use <kbd>st.text_input</kbd> to collect the value-to-convert and cast to float when <kbd>st.number_input</kbd> was available. This is because at the time of writing, there doesn't seem to be an easy way to get rid of the '-' and '+ buttons in <kbd>st.number_input</kbd>. These make sense when we're collecting the number of decimal places, which is an integer in a very tight range, but the value-to-convert is virtually unbounded and there's no predefined step-interval that makes sense.</p>
  </div>
  <div class="readable-text  intended-text" id="p393"> 
   <p>Okay, now that we've collected the decimal places, we're ready to apply our formatting when we display the results. We can do this by changing the <kbd>from_display</kbd> and <kbd>to_display</kbd> variables so that they use the <kbd>format_value </kbd>function we defined earlier:</p>
  </div>
  <div class="browsable-container listing-container" id="p394"> 
   <div class="code-area-container"> 
    <pre class="code-area">from_display = format_value(input_num, result.from_unit.abbrev)
to_display = format_value(result.to_value, result.to_unit.abbrev, places)</pre>
   </div>
  </div>
  <div class="readable-text " id="p395"> 
   <p>We pass <kbd>places</kbd> (which we collect from the user) to round the <kbd>to_display </kbd>variable. We could have done this for <kbd>from_display</kbd> as well, but it's likely the user entered the precision they want to see in the from-value, so we don't want to mess with that.</p>
  </div>
  <div class="readable-text  intended-text" id="p396"> 
   <p>This gives us figure 3.21.</p>
  </div>
  <div class="browsable-container figure-container" id="p397">  
   <img src="../Images/03__image020.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.21 Unit converter app with a decimal places input</h5>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p398"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p399"> 
    <p>This won't pad to-values with extra trailing zeroes. For instance, if the to-value is a whole number, say 600, it will be displayed as "600.0" with just the one trailing zero.</p>
   </div>
  </div>
  <div class="readable-text " id="p400"> 
   <p>The formatted result looks much nicer, but we've also added an extra numeric input that increases the user's cognitive load a little. Maybe we should only introduce the decimal-places input if the user asks for it.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p401"> 
   <h4 class=" readable-text-h4">st.checkbox</h4>
  </div>
  <div class="readable-text " id="p402"> 
   <p><kbd>st.checkbox</kbd> is a Streamlit checkbox, i.e., a box that you can, well, check. Please try to contain your shock, we have an app to ship.</p>
  </div>
  <div class="readable-text  intended-text" id="p403"> 
   <p>Like <kbd>st.button</kbd>, <kbd>st.checkbox</kbd> is a <em>conditional</em> element; you can use an if statement to branch your logic based on whether it's checked or not.</p>
  </div>
  <div class="readable-text  intended-text" id="p404"> 
   <p>Our use case is to let the user decide if they want to round the conversion result, which we can do by modifying how we obtain the value of the <kbd>places</kbd> variable:</p>
  </div>
  <div class="browsable-container listing-container" id="p405"> 
   <div class="code-area-container"> 
    <pre class="code-area">places = None
if st.checkbox("Round result?", value=False):
    places = st.number_input(
        "Decimal places to round to", value=2, min_value=0)</pre>
   </div>
  </div>
  <div class="readable-text " id="p406"> 
   <p>The checkbox is unchecked by default since we're passing False to the value argument.</p>
  </div>
  <div class="readable-text  intended-text" id="p407"> 
   <p>Notice that we've included the line <kbd>places = None</kbd> above the <kbd>st.checkbox</kbd> code. This is because, down below, we're referring to <kbd>places</kbd> outside of the scope of the <kbd>if st.checkbox</kbd> block, so we need to pass an initial value to it in case the user leaves the box unchecked.</p>
  </div>
  <div class="readable-text  intended-text" id="p408"> 
   <p>Our app should now look like figure 3.22.</p>
  </div>
  <div class="browsable-container figure-container" id="p409">  
   <img src="../Images/03__image021.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.22 Unit converter app with rounding enabled</h5>
  </div>
  <div class="readable-text " id="p410"> 
   <p>Or if the user leaves "Round result?" unchecked, we get the full-precision treatment in figure 3.23.</p>
  </div>
  <div class="browsable-container figure-container" id="p411">  
   <img src="../Images/03__image022.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.23 Unit converter app with rounding disabled</h5>
  </div>
  <div class="readable-text" id="p412"> 
   <h3 class=" readable-text-h3">3.7.2 Getting rid of the button</h3>
  </div>
  <div class="readable-text " id="p413"> 
   <p>Our app works great now; it displays rounded output, but only if we want it to. We've added a click and a numeric input to enable this, however.</p>
  </div>
  <div class="readable-text  intended-text" id="p414"> 
   <p>Is there perhaps a way to simplify this experience? Let's turn our attention to the "Convert" button. Do we really even need it?</p>
  </div>
  <div class="readable-text  intended-text" id="p415"> 
   <p>All it does is trigger the conversion. But we don't really need an explicit trigger. Why not have the app <em>always</em> show the result based on the entered inputs? So if the user changes the value, they would immediately see the conversion result rather than having to click the button again.</p>
  </div>
  <div class="readable-text  intended-text" id="p416"> 
   <p>That definitely seems like a more intuitive experience, so let's make it happen.</p>
  </div>
  <div class="readable-text  intended-text" id="p417"> 
   <p>As it turns out, this is easy to do. Simply remove the line if <kbd>st.button("Convert"):</kbd> and move everything in that block outside.</p>
  </div>
  <div class="readable-text  intended-text" id="p418"> 
   <p>Listing 3.7 shows the final version of frontend.py.</p>
  </div>
  <div class="browsable-container listing-container" id="p419"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 3.7 Final version of frontend.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
from backend import convert_value, list_quantities, list_units
 
def format_value(
        value: float,
        unit_abbrev: str,
        decimal_places: int = None) -&gt; str:
    is_rounded = decimal_places is not None
    rounded = round(value, decimal_places) if is_rounded else value
    formatted = format(rounded, ",")
    return f"{formatted} {unit_abbrev}"
 
quantity = st.sidebar.radio("Select a quantity", list_quantities())
 
st.title("Unit Converter")
input_num = float(st.text_input("Value", value="0"))
 
units = list_units(quantity)
from_unit_col, to_unit_col = st.columns(2)
from_unit = from_unit_col.selectbox("From", units)
to_unit = to_unit_col.selectbox("To", units, index=1)
 
places = None
if st.checkbox("Round result?", value=False):
    places = st.number_input(
        "Decimal places to round to", value=2, min_value=0)
 
result = convert_value(quantity, from_unit, to_unit, input_num)
from_display = format_value(input_num, result.from_unit.abbrev)
to_display = format_value(
    result.to_value, result.to_unit.abbrev, places)
 
from_result_col, to_result_col = st.columns(2)
from_value_col, to_value_col = st.columns(2)
from_value_col.metric("From", from_display, delta=None)
to_value_col.metric("To", to_display, delta=None)
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p420"> 
   <p>And figure 3.24 shows a final screenshot of our app.</p>
  </div>
  <div class="browsable-container figure-container" id="p421">  
   <img src="../Images/03__image023.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 3.24 Unit converter app with the "Convert" button removed</h5>
  </div>
  <div class="readable-text " id="p422"> 
   <p>You'll find that removing the button makes the app <em>flow</em> a lot better. For instance, if you change the decimal places or the value, you see the results instantly.</p>
  </div>
  <div class="readable-text  intended-text" id="p423"> 
   <p>I hope this chapter has been a lot of fun! We started with a mere concept, broke it down into concrete requirements, designed a UI, thought deeply about the implementation, wrote code to turn our ideas into a working app, and refined it for a better user experience.</p>
  </div>
  <div class="readable-text  intended-text" id="p424"> 
   <p>The point of this chapter was to give you a sense of what it's like to develop Streamlit apps in the real world while working with real stakeholders. As you've hopefully learned, there's a lot more to the process than writing code; things like nailing the requirements and designing (and refining) the user experience are equally important.</p>
  </div>
  <div class="readable-text" id="p425"> 
   <h2 class=" readable-text-h2">3.8 Summary</h2>
  </div>
  <ul> 
   <li class="readable-text" id="p426">Building an app from a concept is about a lot more than writing code.</li>
   <li class="readable-text" id="p427">The six steps involved in creating a Streamlit app in the real world are: state the concept, define the requirements, visualize the user experience, brainstorm implementation, write code, and iterate.</li>
   <li class="readable-text" id="p428">Requirements can come from your users or from non-user stakeholders.</li>
   <li class="readable-text" id="p429">It's a good idea to visualize the user experience at the start by sketching mocks so you have something to work towards.</li>
   <li class="readable-text" id="p430">Brainstorming the implementation involves analyzing tradeoffs and mapping the flow of logic.</li>
   <li class="readable-text" id="p431">Separating your frontend and backend code and defining an API for the two to interact is a great way to organize your app.</li>
   <li class="readable-text" id="p432"><kbd>st.text_input</kbd> and <kbd>st.number_input</kbd> allow users to input text and numeric values.</li>
   <li class="readable-text" id="p433"><kbd>st.radio</kbd> and <kbd>st.selectbox</kbd> let users select a value from a list.</li>
   <li class="readable-text" id="p434"><kbd>st.sidebar</kbd> and <kbd>st.columns</kbd> are layout elements that let you break the natural top-to-bottom way that Streamlit renders UI elements.</li>
   <li class="readable-text" id="p435"><kbd>st.button</kbd> and <kbd>st.checkbox</kbd> are both conditional elements.</li>
  </ul>
</body>
</html>