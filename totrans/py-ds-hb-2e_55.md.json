["```py\nIn [1]: %matplotlib inline\n        import matplotlib.pyplot as plt\n        plt.style.use('seaborn-whitegrid')\n        import numpy as np\n```", "```py\nIn [2]: from skimage import data, color, feature\n        import skimage.data\n\n        image = color.rgb2gray(data.chelsea())\n        hog_vec, hog_vis = feature.hog(image, visualize=True)\n\n        fig, ax = plt.subplots(1, 2, figsize=(12, 6),\n                               subplot_kw=dict(xticks=[], yticks=[]))\n        ax[0].imshow(image, cmap='gray')\n        ax[0].set_title('input image')\n\n        ax[1].imshow(hog_vis)\n        ax[1].set_title('visualization of HOG features');\n```", "```py\nIn [3]: from sklearn.datasets import fetch_lfw_people\n        faces = fetch_lfw_people()\n        positive_patches = faces.images\n        positive_patches.shape\nOut[3]: (13233, 62, 47)\n```", "```py\nIn [4]: data.camera().shape\nOut[4]: (512, 512)\n```", "```py\nIn [5]: from skimage import data, transform\n\n        imgs_to_use = ['camera', 'text', 'coins', 'moon',\n                       'page', 'clock', 'immunohistochemistry',\n                       'chelsea', 'coffee', 'hubble_deep_field']\n        raw_images = (getattr(data, name)() for name in imgs_to_use)\n        images = [color.rgb2gray(image) if image.ndim == 3 else image\n                  for image in raw_images]\n```", "```py\nIn [6]: from sklearn.feature_extraction.image import PatchExtractor\n\n        def extract_patches(img, N, scale=1.0, patch_size=positive_patches[0].shape):\n            extracted_patch_size = tuple((scale * np.array(patch_size)).astype(int))\n            extractor = PatchExtractor(patch_size=extracted_patch_size,\n                                       max_patches=N, random_state=0)\n            patches = extractor.transform(img[np.newaxis])\n            if scale != 1:\n                patches = np.array([transform.resize(patch, patch_size)\n                                    for patch in patches])\n            return patches\n\n        negative_patches = np.vstack([extract_patches(im, 1000, scale)\n                                      for im in images for scale in [0.5, 1.0, 2.0]])\n        negative_patches.shape\nOut[6]: (30000, 62, 47)\n```", "```py\nIn [7]: fig, ax = plt.subplots(6, 10)\n        for i, axi in enumerate(ax.flat):\n            axi.imshow(negative_patches[500 * i], cmap='gray')\n            axi.axis('off')\n```", "```py\nIn [8]: from itertools import chain\n        X_train = np.array([feature.hog(im)\n                            for im in chain(positive_patches,\n                                            negative_patches)])\n        y_train = np.zeros(X_train.shape[0])\n        y_train[:positive_patches.shape[0]] = 1\n```", "```py\nIn [9]: X_train.shape\nOut[9]: (43233, 1215)\n```", "```py\nIn [10]: from sklearn.naive_bayes import GaussianNB\n         from sklearn.model_selection import cross_val_score\n\n         cross_val_score(GaussianNB(), X_train, y_train)\nOut[10]: array([0.94795883, 0.97143518, 0.97224471, 0.97501735, 0.97374508])\n```", "```py\nIn [11]: from sklearn.svm import LinearSVC\n         from sklearn.model_selection import GridSearchCV\n         grid = GridSearchCV(LinearSVC(), {'C': [1.0, 2.0, 4.0, 8.0]})\n         grid.fit(X_train, y_train)\n         grid.best_score_\nOut[11]: 0.9885272620319941\n```", "```py\nIn [12]: grid.best_params_\nOut[12]: {'C': 1.0}\n```", "```py\nIn [13]: model = grid.best_estimator_\n         model.fit(X_train, y_train)\nOut[13]: LinearSVC()\n```", "```py\nIn [14]: test_image = skimage.data.astronaut()\n         test_image = skimage.color.rgb2gray(test_image)\n         test_image = skimage.transform.rescale(test_image, 0.5)\n         test_image = test_image[:160, 40:180]\n\n         plt.imshow(test_image, cmap='gray')\n         plt.axis('off');\n```", "```py\nIn [15]: def sliding_window(img, patch_size=positive_patches[0].shape,\n                            istep=2, jstep=2, scale=1.0):\n             Ni, Nj = (int(scale * s) for s in patch_size)\n             for i in range(0, img.shape[0] - Ni, istep):\n                 for j in range(0, img.shape[1] - Ni, jstep):\n                     patch = img[i:i + Ni, j:j + Nj]\n                     if scale != 1:\n                         patch = transform.resize(patch, patch_size)\n                     yield (i, j), patch\n\n         indices, patches = zip(*sliding_window(test_image))\n         patches_hog = np.array([feature.hog(patch) for patch in patches])\n         patches_hog.shape\nOut[15]: (1911, 1215)\n```", "```py\nIn [16]: labels = model.predict(patches_hog)\n         labels.sum()\nOut[16]: 48.0\n```", "```py\nIn [17]: fig, ax = plt.subplots()\n         ax.imshow(test_image, cmap='gray')\n         ax.axis('off')\n\n         Ni, Nj = positive_patches[0].shape\n         indices = np.array(indices)\n\n         for i, j in indices[labels == 1]:\n             ax.add_patch(plt.Rectangle((j, i), Nj, Ni, edgecolor='red',\n                                        alpha=0.3, lw=2, facecolor='none'))\n```"]