- en: Chapter 7\. Excel File Manipulation with pandas
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章. 使用 pandas 进行 Excel 文件操作
- en: 'After six chapters of intense introductions to tools, Python, and pandas, I
    will give you a break and start this chapter with a practical case study that
    allows you to put your newly acquired skills to good use: with just ten lines
    of pandas code, you will consolidate dozens of Excel files into an Excel report,
    ready to be sent to your managers. After the case study, I’ll give you a more
    in-depth introduction to the tools that pandas offers to work with Excel files:
    the `read_excel` function and the `ExcelFile` class for reading, and the `to_excel`
    method and the `ExcelWriter` class for writing Excel files. pandas does not rely
    on the Excel application to read and write Excel files, which means that all code
    samples in this chapter run everywhere Python runs, including Linux.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在经历了六章对工具、Python 和 pandas 的激烈介绍之后，我将给你一个休息时间，并从一个实际案例研究开始本章，让你能够将你新获得的技能应用到实际中：仅需十行
    pandas 代码，你就可以将数十个 Excel 文件合并成一份 Excel 报告，准备发送给你的经理们。案例研究之后，我将更深入地介绍 pandas 提供的处理
    Excel 文件的工具：`read_excel` 函数和 `ExcelFile` 类用于读取，`to_excel` 方法和 `ExcelWriter` 类用于写入
    Excel 文件。pandas 不依赖 Excel 应用程序来读写 Excel 文件，这意味着本章中的所有代码示例都可以在 Python 运行的任何地方运行，包括
    Linux。
- en: 'Case Study: Excel Reporting'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 案例研究：Excel 报告
- en: 'This case study is inspired by a few real-world reporting projects I was involved
    in over the last few years. Even though the projects took place in completely
    different industries—including telecommunication, digital marketing, and finance—they
    were still remarkably similar: the starting point is usually a directory with
    Excel files that need to be processed into an Excel report—often on a monthly,
    weekly, or daily basis. In the companion repository, in the sales_data directory,
    you will find Excel files with fictitious sales transactions for a telecommunication
    provider selling different plans (Bronze, Silver, Gold) in a few stores throughout
    the United States. For every month, there are two files, one in the new subfolder
    for new contracts and one in the existing subfolder for existing customers. As
    the reports come from different systems, they come in different formats: the new
    customers are delivered as xlsx files, while the existing customers arrive in
    the older xls format. Each of the files has up to 10,000 transactions, and our
    goal is to produce an Excel report that shows the total sales per store and month.
    To get started, let’s have a look at the January.xlsx file from the new subfolder
    in [Figure 7-1](#filepos865924).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这个案例研究受到我在过去几年参与的几个真实报告项目的启发。尽管这些项目涉及完全不同的行业—包括电信、数字营销和金融—但它们仍然非常相似：起点通常是一个包含需要处理为
    Excel 报告的 Excel 文件的目录—通常是每月、每周或每日的基础上。在伴随的存储库中，在 sales_data 目录中，你会找到用于电信供应商销售不同套餐（Bronze、Silver、Gold）的虚构销售交易的
    Excel 文件，这些套餐分布在美国的几家商店中。对于每个月，都有两个文件，一个在 new 子文件夹中用于新合同，另一个在 existing 子文件夹中用于现有客户。由于这些报告来自不同的系统，它们有不同的格式：新客户以
    xlsx 文件的形式交付，而现有客户则以旧的 xls 格式交付。每个文件最多有 10,000 笔交易，我们的目标是生成一个 Excel 报告，显示每个商店和月份的总销售额。要开始，请查看
    new 子文件夹中的 January.xlsx 文件中的 [Figure 7-1](#filepos865924)。
- en: '![](images/00080.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00080.jpg)'
- en: Figure 7-1\. The first few rows of January.xlsx
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1. January.xlsx 的前几行
- en: 'The Excel files in the existing subfolder look practically the same, except
    that they are missing the `status` column and are stored in the legacy xls format.
    As a first step, let’s read the new transactions from January with pandas’ `read_excel`
    function:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: existing 子文件夹中的 Excel 文件看起来几乎相同，只是缺少 `status` 列，并存储在传统的 xls 格式中。作为第一步，让我们使用
    pandas 的 `read_excel` 函数读取 1 月份的新交易：
- en: '`In``[``1``]:``import``pandas``as``pd`'
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``1``]:``import``pandas``as``pd`'
- en: '`In``[``2``]:``df``=``pd``.``read_excel``(``"sales_data/new/January.xlsx"``)``df``.``info``()`'
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``2``]:``df``=``pd``.``read_excel``(``"sales_data/new/January.xlsx"``)``df``.``info``()``'
- en: '`<class ''pandas.core.frame.DataFrame''> RangeIndex: 9493 entries, 0 to 9492
    Data columns (total 7 columns): #   Column            Non-Null Count  Dtype --- 
    ------            --------------  ----- 0   transaction_id    9493 non-null  
    object 1   store             9493 non-null   object 2   status            9493
    non-null   object 3   transaction_date  9493 non-null   datetime64[ns] 4   plan             
    9493 non-null   object 5   contract_type     9493 non-null   object 6   amount           
    9493 non-null   float64 dtypes: datetime64[ns](1), float64(1), object(5) memory
    usage: 519.3+ KB`'
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`<class ''pandas.core.frame.DataFrame''> RangeIndex: 9493 entries, 0 to 9492
    Data columns (total 7 columns): #   Column            Non-Null Count  Dtype --- 
    ------            --------------  ----- 0   transaction_id    9493 non-null  
    object 1   store             9493 non-null   object 2   status            9493
    non-null   object 3   transaction_date  9493 non-null   datetime64[ns] 4   plan             
    9493 non-null   object 5   contract_type     9493 non-null   object 6   amount           
    9493 non-null   float64 dtypes: datetime64[ns](1 **[[""]]( "")**  float64(1),
    object(5) memory usage: 519.3+ KB`'
- en: THE READ_EXCEL FUNCTION WITH PYTHON 3.9
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用Python 3.9的READ_EXCEL函数
- en: 'This is the same warning as in [Chapter 5](index_split_015.html#filepos482650):
    if you are running `pd.read_excel` with Python 3.9 or above, make sure to use
    at least pandas 1.2 or you will get an error when reading xlsx files.'
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这与[第 5 章](index_split_015.html#filepos482650)中的警告相同：如果您使用Python 3.9或更高版本运行`pd.read_excel`，请确保至少使用pandas
    1.2，否则在读取xlsx文件时会出错。
- en: As you can see, pandas has properly recognized the data types of all columns,
    including the date format of `transaction_date`. This allows us to work with the
    data without further preparation. As this sample is deliberately simple, we can
    move on with creating a short script called sales_report_pandas.py as shown in
    [Example 7-1](#filepos871029). This script will read in all Excel files from both
    directories, aggregate the data, and write the summary table into a new Excel
    file. Use VS Code to write the script yourself, or open it from the companion
    repository. For a refresher on how to create or open files in VS Code, have another
    look at [Chapter 2](index_split_008.html#filepos96824). If you create it yourself,
    make sure to place it next to the sales_data folder—this will allow you to run
    the script without having to adjust any file paths.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，pandas已正确识别了所有列的数据类型，包括`transaction_date`的日期格式。这使我们能够在不需要进一步准备数据的情况下处理数据。由于此示例故意简单，我们可以继续创建一个名为sales_report_pandas.py的短脚本，如[示例 7-1](#filepos871029)所示。此脚本将从两个目录中读取所有Excel文件，聚合数据，并将汇总表写入新的Excel文件中。使用VS
    Code自己编写脚本，或者从伴随的代码库中打开它。如需了解如何在VS Code中创建或打开文件，请再次参考[第 2 章](index_split_008.html#filepos96824)。如果您自己创建，请确保将其放在sales_data文件夹旁边——这样可以在无需调整任何文件路径的情况下运行脚本。
- en: Example 7-1\. sales_report_pandas.py
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-1\. sales_report_pandas.py
- en: '`from``pathlib``import``Path``import``pandas``as``pd``# Directory of this file``this_dir``=``Path``(``__file__``)``.``resolve``()``.``parent`![](images/00031.jpg)`#
    Read in all Excel files from all subfolders of sales_data``parts``=``[]``for``path``in``(``this_dir``/``"sales_data"``)``.``rglob``(``"*.xls*"``):`![](images/00039.jpg)`print``(``f``''Reading
    {path.name}''``)``part``=``pd``.``read_excel``(``path``,``index_col``=``"transaction_id"``)``parts``.``append``(``part``)``#
    Combine the DataFrames from each file into a single DataFrame``# pandas takes
    care of properly aligning the columns``df``=``pd``.``concat``(``parts``)``# Pivot
    each store into a column and sum up all transactions per date``pivot``=``pd``.``pivot_table``(``df``,``index``=``"transaction_date"``,``columns``=``"store"``,``values``=``"amount"``,``aggfunc``=``"sum"``)``#
    Resample to end of month and assign an index name``summary``=``pivot``.``resample``(``"M"``)``.``sum``()``summary``.``index``.``name``=``"Month"``#
    Write summary report to Excel file``summary``.``to_excel``(``this_dir``/``"sales_report_pandas.xlsx"``)`'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`from``pathlib``import``Path``import``pandas``as``pd``# 本文件的目录``this_dir``=``Path``(``__file__``)``.``resolve``()``.``parent`![](images/00031.jpg)`#
    从sales_data的所有子文件夹中读取所有Excel文件``parts``=``[]``for``path``in``(``this_dir``/``"sales_data"``)``.``rglob``(``"*.xls*"``):`![](images/00039.jpg)`print``(``f``''读取
    {path.name}''``)``part``=``pd``.``read_excel``(``path``,``index_col``=``"transaction_id"``)``parts``.``append``(``part``)``#
    将每个文件的DataFrame合并为单个DataFrame``# pandas会正确对齐列``df``=``pd``.``concat``(``parts``)``#
    将每个商店转换为列，并按日期汇总所有交易``pivot``=``pd``.``pivot_table``(``df``,``index``=``"transaction_date"``,``columns``=``"store"``,``values``=``"amount"``,``aggfunc``=``"sum"``)``#
    重新采样到月底并分配索引名称``summary``=``pivot``.``resample``(``"M"``)``.``sum``()``summary``.``index``.``name``=``"Month"``#
    将汇总报告写入Excel文件``summary``.``to_excel``(``this_dir``/``"sales_report_pandas.xlsx"``)`'
- en: '![](images/00031.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00031.jpg)'
- en: 'Up to this chapter, I was using strings to specify file paths. By using the
    `Path` class from the standard library’s `pathlib` module instead, you get access
    to a powerful set of tools: path objects enable you to easily construct paths
    by concatenating individual parts via forward slashes, as it’s done four lines
    below with `this_dir / "sales_data"`. These paths work across platforms and allow
    you to apply filters like `rglob` as explained under the next point. `__file__`
    resolves to the path of the source code file when you run it—using its `parent`
    will give you therefore the name of the directory of this file. The `resolve`
    method that we use before calling `parent` turns the path into an absolute path.
    If you would run this from a Jupyter notebook instead, you would have to replace
    this line with `this_dir = Path(".").resolve()`, with the dot representing the
    current directory. In most cases, functions and classes that accept a path in
    the form of a string also accept a path object.'
  id: totrans-16
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本章之前，我一直使用字符串来指定文件路径。通过使用标准库的 pathlib 模块中的 `Path` 类，你可以获得一套强大的工具：路径对象使您能够通过连接个别部分使用斜杠来轻松构建路径，正如下面四行代码中使用
    `this_dir / "sales_data"` 一样。这些路径适用于各种平台，并允许您像在下一点解释的那样使用 `rglob` 等过滤器。当您运行时，`__file__`
    将解析为源代码文件的路径——使用其 `parent` 将因此给出此文件所在目录的名称。我们在调用 `parent` 之前使用的 `resolve` 方法将路径转换为绝对路径。如果您在
    Jupyter 笔记本中运行此代码，则必须使用 `this_dir = Path(".").resolve()` 替换此行，其中点表示当前目录。在大多数情况下，接受字符串形式路径的函数和类也接受路径对象。
- en: '![](images/00039.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00039.jpg)'
- en: 'The easiest way to read in all Excel files recursively from within a certain
    directory is to use the `rglob` method of the path object. `glob` is short for
    globbing, which refers to pathname expansion using wildcards. The `?` wildcard
    represents exactly one character, while `*` stands for any number of characters
    (including zero). The r in `rglob` means recursive globbing, i.e., it will look
    for matching files across all subdirectories—accordingly, `glob` would ignore
    subdirectories. Using `*.xls*` as the globbing expression makes sure that the
    old and new Excel files are found, as it matches both `.xls` and `.xlsx`. It’s
    usually a good idea to slightly enhance the expression like this: `[!~$]*.xls*`.
    This ignores temporary Excel files (their file name starts with `~$`). For more
    background on how to use globbing in Python, see the [Python docs](https://oreil.ly/fY0qG).'
  id: totrans-18
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从特定目录递归读取所有 Excel 文件的最简单方法是使用路径对象的 `rglob` 方法。`glob` 是通配符扩展的简写，用于使用通配符进行路径名扩展。`?`
    通配符代表一个字符，而 `*` 代表任意数量的字符（包括零个）。`rglob` 中的 r 表示递归通配符，即它将在所有子目录中查找匹配的文件——相应地，`glob`
    将忽略子目录。使用 `*.xls*` 作为通配符表达式确保可以找到旧的和新的 Excel 文件，因为它匹配 `.xls` 和 `.xlsx`。通常建议稍微增强表达式，例如
    `[!~$]*.xls*`。这会忽略临时 Excel 文件（它们的文件名以 `~$` 开头）。有关如何在 Python 中使用通配符扩展的更多背景信息，请参阅
    [Python 文档](https://oreil.ly/fY0qG)。
- en: Run the script, for example, by clicking the Run File button at the top right
    of VS Code. The script will take a moment to complete and once done, the Excel
    workbook sales_report_pandas.xlsx will show up in the same directory as the script.
    The content of Sheet1 should look like in [Figure 7-2](#filepos884738). That’s
    quite an impressive result for only ten lines of code—even if you will need to
    adjust the width of the first column to be able to see the dates!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，例如，通过点击 VS Code 右上角的“运行文件”按钮。脚本将需要一段时间来完成，完成后，Excel 工作簿 sales_report_pandas.xlsx
    将出现在与脚本相同的目录中。Sheet1 的内容应该像 [图 7-2](#filepos884738) 中所示。这对于只有十行代码的结果相当令人印象深刻——即使您需要调整第一列的宽度以查看日期！
- en: '![](images/00005.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00005.jpg)'
- en: Figure 7-2\. sales_report_pandas.xlsx (as-is, without adjusting any column width)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-2\. sales_report_pandas.xlsx（原样，不调整任何列宽）
- en: For simple cases like this one, pandas offers a really easy solution to work
    with Excel files. However, we can do much better—after all, a title, some formatting
    (including column width and a consistent number of decimals), and a chart wouldn’t
    hurt. That’s exactly what we will take care of in the next chapter by directly
    using the writer libraries that pandas uses under the hood. Before we get there,
    however, let’s have a more detailed look at how we can read and write Excel files
    with pandas.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像这样简单的情况，pandas 提供了处理 Excel 文件的非常简便的解决方案。但是，我们可以做得更好——毕竟，一个标题、一些格式（包括列宽和一致的小数位数）以及一个图表都不会有什么坏处。这正是我们将在下一章中通过直接使用
    pandas 底层使用的写入库来解决的问题。然而，在我们到达那里之前，让我们更详细地看看如何使用 pandas 读取和写入 Excel 文件。
- en: Reading and Writing Excel Files with pandas
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pandas 读写 Excel 文件
- en: The case study was using `read_excel` and `to_excel` with their default arguments
    to keep things simple. In this section, I will show you the most commonly used
    arguments and options when reading and writing Excel files with pandas. We’ll
    start with the `read_excel` function and the `ExcelFile` class before looking
    at the `to_excel` method and the `ExcelWriter` class. Along the way, I’ll also
    introduce Python’s `with` statement.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 该案例研究使用 `read_excel` 和 `to_excel` 的默认参数来简化操作。在本节中，我将介绍使用 pandas 读写 Excel 文件时最常用的参数和选项。我们将从
    `read_excel` 函数和 `ExcelFile` 类开始，然后再看看 `to_excel` 方法和 `ExcelWriter` 类。在此过程中，我还会介绍
    Python 的 `with` 语句。
- en: The read_excel Function and ExcelFile Class
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_excel` 函数和 ExcelFile 类'
- en: The case study used Excel workbooks where the data was conveniently in cell
    A1 of the first sheet. In reality, your Excel files are probably not so well organized.
    In this case, pandas offers parameters to fine-tune the reading process. For the
    next few samples, we’re going to use the stores.xlsx file that you will find in
    the xl folder of the companion repository. The first sheet is shown in [Figure 7-3](#filepos886927).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 该案例研究使用的是 Excel 工作簿，数据方便地位于第一个工作表的 A1 单元格。实际情况下，您的 Excel 文件可能没有那么好组织。在这种情况下，pandas
    提供了参数来优化读取过程。接下来的示例中，我们将使用 companion 存储库的 xl 文件夹中的 stores.xlsx 文件。第一个工作表显示在 [Figure 7-3](#filepos886927)
    中。
- en: '![](images/00012.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00012.jpg)'
- en: Figure 7-3\. The first sheet of stores.xlsx
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-3\. stores.xlsx 的第一个工作表
- en: 'By using the parameters `sheet_name`, `skiprows`, and `usecols`, we can tell
    pandas about the cell range that we want to read in. As usual, it’s a good idea
    to have a look at the data types of the returned DataFrame by running the `info`
    method:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `sheet_name`、`skiprows` 和 `usecols` 参数，我们可以告诉 pandas 我们想要读取的单元格范围。通常情况下，通过运行
    `info` 方法查看返回的 DataFrame 的数据类型是个好主意：
- en: '`In``[``3``]:``df``=``pd``.``read_excel``(``"xl/stores.xlsx"``,``sheet_name``=``"2019"``,``skiprows``=``1``,``usecols``=``"B:F"``)``df`'
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``3``]:``df``=``pd``.``read_excel``(``"xl/stores.xlsx"``,``sheet_name``=``"2019"``,``skiprows``=``1``,``usecols``=``"B:F"``)``df`'
- en: '`Out[3]:            Store  Employees    Manager      Since Flagship        
    0       New York         10      Sarah 2018-07-20    False         1  San Francisco        
    12     Neriah 2019-11-02  MISSING         2        Chicago          4    Katelin
    2020-01-31      NaN         3         Boston          5  Georgiana 2017-04-01    
    True         4  Washington DC          3       Evan        NaT    False        
    5      Las Vegas         11       Paul 2020-01-06    False`'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[3]:            Store  Employees    Manager      Since Flagship        
    0       New York         10      Sarah 2018-07-20    False         1  San Francisco        
    12     Neriah 2019-11-02  MISSING         2        Chicago          4    Katelin
    2020-01-31      NaN         3         Boston          5  Georgiana 2017-04-01    
    True         4  Washington DC          3       Evan        NaT    False        
    5      Las Vegas         11       Paul 2020-01-06    False`'
- en: '`In``[``4``]:``df``.``info``()`'
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``4``]:``df``.``info``()'
- en: '`<class ''pandas.core.frame.DataFrame''> RangeIndex: 6 entries, 0 to 5 Data
    columns (total 5 columns): #   Column     Non-Null Count  Dtype ---  ------    
    --------------  ----- 0   Store      6 non-null      object 1   Employees  6 non-null     
    int64 2   Manager    6 non-null      object 3   Since      5 non-null      datetime64[ns]
    4   Flagship   5 non-null      object dtypes: datetime64[ns](1), int64(1), object(3)
    memory usage: 368.0+ bytes`'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`<class ''pandas.core.frame.DataFrame''> RangeIndex: 6 entries, 0 to 5 Data
    columns (total 5 columns): #   Column     Non-Null Count  Dtype ---  ------    
    --------------  ----- 0   Store      6 non-null      object 1   Employees  6 non-null     
    int64 2   Manager    6 non-null      object 3   Since      5 non-null      datetime64[ns]
    4   Flagship   5 non-null      object dtypes: datetime64[ns](1 **[[""]]( "")**  int64(1),
    object(3) memory usage: 368.0+ bytes`'
- en: 'Everything looks good except for the `Flagship` column—its data type should
    be `bool` rather than `object`. To fix this, we can provide a converter function
    that deals with the offensive cells in that column (instead of writing the `fix_missing`
    function, we could have also provided a lambda expression instead):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Flagship` 列之外，一切看起来都很好——它的数据类型应为 `bool` 而不是 `object`。为了修复这个问题，我们可以提供一个转换函数，处理该列中的问题单元格（而不是编写
    `fix_missing` 函数，我们也可以使用 lambda 表达式代替）：
- en: '`In``[``5``]:``def``fix_missing``(``x``):``return``False``if``x``in``[``""``,``"MISSING"``]``else``x`'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``5``]:``def``fix_missing``(``x``):``return``False``if``x``in``[``""``,``"MISSING"``]``else``x`'
- en: '`In``[``6``]:``df``=``pd``.``read_excel``(``"xl/stores.xlsx"``,``sheet_name``=``"2019"``,``skiprows``=``1``,``usecols``=``"B:F"``,``converters``=``{``"Flagship"``:``fix_missing``})``df`'
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``6``]:``df``=``pd``.``read_excel``(``"xl/stores.xlsx"``,``sheet_name``=``"2019"``,``skiprows``=``1``,``usecols``=``"B:F"``,``converters``=``{``"Flagship"``:``fix_missing``})``df`'
- en: '`Out[6]:            Store  Employees    Manager      Since  Flagship        
    0       New York         10      Sarah 2018-07-20     False         1  San Francisco        
    12     Neriah 2019-11-02     False         2        Chicago          4    Katelin
    2020-01-31     False         3         Boston          5  Georgiana 2017-04-01     
    True         4  Washington DC          3       Evan        NaT     False        
    5      Las Vegas         11       Paul 2020-01-06     False`'
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[6]:            Store  Employees    Manager      Since  Flagship        
    0       纽约         10      莎拉 2018-07-20     False         1  旧金山         12    
    尼赖亚 2019-11-02     False         2        芝加哥          4    凯特琳 2020-01-31    
    False         3         波士顿          5  乔治安娜 2017-04-01      True         4  华盛顿特区         
    3       伊万        NaT     False         5      拉斯维加斯         11       保罗 2020-01-06    
    False`'
- en: '`In``[``7``]:``# The Flagship column now has Dtype "bool"``df``.``info``()`'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``7``]:``# Flagship 列现在的 Dtype 是 "bool"``df``.``info``()'
- en: '`<class ''pandas.core.frame.DataFrame''> RangeIndex: 6 entries, 0 to 5 Data
    columns (total 5 columns): #   Column     Non-Null Count  Dtype ---  ------    
    --------------  ----- 0   Store      6 non-null      object 1   Employees  6 non-null     
    int64 2   Manager    6 non-null      object 3   Since      5 non-null      datetime64[ns]
    4   Flagship   6 non-null      bool dtypes: bool(1), datetime64[ns](1), int64(1),
    object(2) memory usage: 326.0+ bytes`'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`<class ''pandas.core.frame.DataFrame''> RangeIndex: 6 entries, 0 to 5 Data
    columns (total 5 columns): #   Column     Non-Null Count  Dtype ---  ------    
    --------------  ----- 0   分店      6 non-null      object 1   员工数量  6 non-null     
    int64 2   经理    6 non-null      object 3   自从      5 non-null      datetime64[ns]
    4   是否旗舰店   6 non-null      bool dtypes: bool(1), datetime64[ns](1 **[[""]]( "")**  int64(1),
    object(2) memory usage: 326.0+ bytes`'
- en: 'The `read_excel` function also accepts a list of sheet names. In this case,
    it returns a dictionary with the DataFrame as value and the name of the sheet
    as key. To read in all sheets, you would need to provide `sheet_name=None`. Also,
    note the slight variation of how I am using `usecols` by providing the column
    names of the table:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_excel` 函数还接受一个工作表名称列表。在这种情况下，它将返回一个字典，其中 DataFrame 作为值，工作表名称作为键。要读取所有工作表，您需要提供
    `sheet_name=None`。还请注意，我在使用 `usecols` 时提供了表格列名的略微变体：'
- en: '`In``[``8``]:``sheets``=``pd``.``read_excel``(``"xl/stores.xlsx"``,``sheet_name``=``[``"2019"``,``"2020"``],``skiprows``=``1``,``usecols``=``[``"Store"``,``"Employees"``])``sheets``[``"2019"``]``.``head``(``2``)`'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``8``]:``sheets``=``pd``.``read_excel``(``"xl/stores.xlsx"``,``sheet_name``=``[``"2019"``,``"2020"``],``skiprows``=``1``,``usecols``=``[``"分店"``,``"员工数量"``])``sheets``[``"2019"``]``.``head``(``2``)`'
- en: '`Out[8]:            Store  Employees         0       New York         10        
    1  San Francisco         12`'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[8]:            分店  员工数量         0       纽约         10         1  旧金山        
    12`'
- en: 'If the source file doesn’t have column headers, set `header=None` and provide
    them via `names`. Note that `sheet_name` also accepts sheet indices:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源文件没有列标题，请将 `header=None` 设置，并通过 `names` 提供它们。请注意，`sheet_name` 还接受工作表索引：
- en: '`In``[``9``]:``df``=``pd``.``read_excel``(``"xl/stores.xlsx"``,``sheet_name``=``0``,``skiprows``=``2``,``skipfooter``=``3``,``usecols``=``"B:C,F"``,``header``=``None``,``names``=``[``"Branch"``,``"Employee_Count"``,``"Is_Flagship"``])``df`'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``9``]:``df``=``pd``.``read_excel``(``"xl/stores.xlsx"``,``sheet_name``=``0``,``skiprows``=``2``,``skipfooter``=``3``,``usecols``=``"B:C,F"``,``header``=``None``,``names``=``[``"分店"``,``"员工数量"``,``"是否旗舰店"``])``df`'
- en: '`Out[9]:           Branch  Employee_Count Is_Flagship         0       New York             
    10       False         1  San Francisco              12     MISSING         2       
    Chicago               4         NaN`'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[9]:           分店  员工数量 是否旗舰店         0       纽约              10      
    False         1  旧金山              12     MISSING         2        芝加哥              
    4         NaN`'
- en: 'To handle `NaN` values, use a combination of `na_values` and `keep_default_na`.
    The next sample tells pandas to only interpret cells with the word `MISSING` as
    `NaN` and nothing else:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理 `NaN` 值，请使用 `na_values` 和 `keep_default_na` 的组合。下一个示例告诉 pandas 仅将包含 `MISSING`
    字样的单元格解释为 `NaN`，而不是其他任何内容：
- en: '`In``[``10``]:``df``=``pd``.``read_excel``(``"xl/stores.xlsx"``,``sheet_name``=``"2019"``,``skiprows``=``1``,``usecols``=``"B,C,F"``,``skipfooter``=``2``,``na_values``=``"MISSING"``,``keep_default_na``=``False``)``df`'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``10``]:``df``=``pd``.``read_excel``(``"xl/stores.xlsx"``,``sheet_name``=``"2019"``,``skiprows``=``1``,``usecols``=``"B,C,F"``,``skipfooter``=``2``,``na_values``=``"MISSING"``,``keep_default_na``=``False``)``df`'
- en: '`Out[10]:            Store  Employees Flagship          0       New York        
    10    False          1  San Francisco         12      NaN          2        Chicago         
    4          3         Boston          5     True`'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[10]:            分店  员工数量 是否旗舰店          0       纽约         10    False
             1  旧金山         12      NaN          2        芝加哥          4         
    3         波士顿          5     True`'
- en: 'pandas offers an alternative way to read Excel files by using the `ExcelFile`
    class. This mostly makes a difference if you want to read in multiple sheets from
    a file in the legacy xls format: in this case, using `ExcelFile` will be faster
    as it prevents pandas from reading in the whole file multiple times. `ExcelFile`
    can be used as a context manager (see sidebar) so the file is properly closed
    again.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: pandas提供了另一种通过使用`ExcelFile`类读取Excel文件的方法。这主要在您想要从遗留xls格式文件中读取多个工作表时有所不同：在这种情况下，使用`ExcelFile`将更快，因为它防止pandas多次读取整个文件。`ExcelFile`可以作为上下文管理器使用（参见侧边栏），因此文件将再次被正确关闭。
- en: CONTEXT MANAGERS AND THE WITH STATEMENT
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 上下文管理器和`with`语句
- en: 'First of all, the `with` statement in Python doesn’t have anything to do with
    the `With` statement in VBA: in VBA, it is used to run a series of statements
    on the same object, while in Python, it is used to manage resources like files
    or database connections. If you want to load the latest sales data to be able
    to analyze it, you may have to open a file or establish a connection to a database.
    After you’re done reading the data, it’s best practice to close the file or connection
    as soon as possible again. Otherwise, you may run into situations where you can’t
    open another file or can’t establish another connection to the database—file handlers
    and database connections are limited resources. Opening and closing a text file
    manually works like this (`w` stands for opening the file in `write` mode, which
    replaces the file if it already exists):'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 首先，Python中的`with`语句与VBA中的`With`语句没有任何关系：在VBA中，它用于在同一对象上运行一系列语句，而在Python中，它用于管理文件或数据库连接等资源。如果要加载最新的销售数据以便进行分析，可能需要打开文件或建立到数据库的连接。在完成数据读取后，尽快关闭文件或连接是最佳实践。否则，您可能会遇到无法打开另一个文件或建立另一个数据库连接的情况——文件处理程序和数据库连接是有限资源。手动打开和关闭文本文件的方法如下（`w`表示以`写`模式打开文件，如果文件已存在则替换它）：
- en: '`In``[``11``]:``f``=``open``(``"output.txt"``,``"w"``)``f``.``write``(``"Some
    text"``)``f``.``close``()`'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``11``]:``f``=``open``(``"output.txt"``,``"w"``)``f``.``write``(``"Some
    text"``)``f``.``close``()``'
- en: 'Running this code will create a file called output.txt in the same directory
    as the notebook you are running it from and write “some text” to it. To read a
    file, you would use `r` instead of `w`, and to append to the end of the file,
    use `a`. Since files can also be manipulated from outside of your program, such
    an operation could fail. You could handle this by using the try/except mechanism
    that I will introduce in [Chapter 11](index_split_027.html#filepos1487255). However,
    since this is such a common operation, Python is providing the `with` statement
    to make things easier:'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行此代码将在与正在运行代码的笔记本相同的目录中创建一个名为output.txt的文件，并将“Some text”写入其中。要读取文件，您将使用`r`而不是`w`，要在文件末尾追加内容，使用`a`。由于文件也可以从程序外部进行操作，此类操作可能会失败。您可以通过使用我将在[第11章](index_split_027.html#filepos1487255)中介绍的try/except机制来处理此问题。然而，由于这是一个常见的操作，Python提供了`with`语句以简化操作：
- en: '`In``[``12``]:``with``open``(``"output.txt"``,``"w"``)``as``f``:``f``.``write``(``"Some
    text"``)`'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``12``]:``with``open``(``"output.txt"``,``"w"``)``as``f``:``f``.``write``(``"Some
    text"``)`'
- en: When code execution leaves the body of the `with` statement, the file is automatically
    closed, whether or not there is an exception happening. This guarantees that the
    resources are properly cleaned up. Objects that support the `with` statement are
    called context managers; this includes the `ExcelFile` and `ExcelWriter` objects
    in this chapter, as well as database connection objects that we will look at in
    [Chapter 11](index_split_027.html#filepos1487255).
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当代码执行离开`with`语句的主体时，无论是否发生异常，文件都会自动关闭。这确保资源得到适当的清理。支持`with`语句的对象称为上下文管理器；这包括本章中的`ExcelFile`和`ExcelWriter`对象，以及我们将在[第11章](index_split_027.html#filepos1487255)中查看的数据库连接对象。
- en: 'Let’s see the `ExcelFile` class in action:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`ExcelFile`类的实际应用：
- en: '`In``[``13``]:``with``pd``.``ExcelFile``(``"xl/stores.xls"``)``as``f``:``df1``=``pd``.``read_excel``(``f``,``"2019"``,``skiprows``=``1``,``usecols``=``"B:F"``,``nrows``=``2``)``df2``=``pd``.``read_excel``(``f``,``"2020"``,``skiprows``=``1``,``usecols``=``"B:F"``,``nrows``=``2``)``df1`'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``13``]:``with``pd``.``ExcelFile``(``"xl/stores.xls"``)``as``f``:``df1``=``pd``.``read_excel``(``f``,``"2019"``,``skiprows``=``1``,``usecols``=``"B:F"``,``nrows``=``2``)``df2``=``pd``.``read_excel``(``f``,``"2020"``,``skiprows``=``1``,``usecols``=``"B:F"``,``nrows``=``2``)``df1`'
- en: '`Out[13]:            Store  Employees Manager      Since Flagship         
    0       New York         10   Sarah 2018-07-20    False          1  San Francisco        
    12  Neriah 2019-11-02  MISSING`'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[13]:            Store  Employees Manager      Since Flagship         
    0       纽约         10   莎拉 2018-07-20    False          1  旧金山         12  尼莉亚
    2019-11-02  MISSING`'
- en: '`ExcelFile` also gives you access to the names of all sheets:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExcelFile`还允许您访问所有工作表的名称：'
- en: '`In``[``14``]:``stores``=``pd``.``ExcelFile``(``"xl/stores.xlsx"``)``stores``.``sheet_names`'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``14``]:``stores``=``pd``.``ExcelFile``(``"xl/stores.xlsx"``)``stores``.``sheet_names`'
- en: '`Out[14]: [''2019'', ''2020'', ''2019-2020'']`'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[14]: [''2019'', ''2020'', ''2019-2020'']`'
- en: 'Finally, pandas allows you to read Excel files from a URL, similar to how we
    did it with CSV files in [Chapter 5](index_split_015.html#filepos482650). Let’s
    read it directly from the companion repo:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，pandas允许您从URL直接读取Excel文件，类似于我们在[第5章](index_split_015.html#filepos482650)中读取CSV文件的方法。让我们直接从伴随存储库中读取：
- en: '`In``[``15``]:``url``=``(``"https://raw.githubusercontent.com/fzumstein/"``"python-for-excel/1st-edition/xl/stores.xlsx"``)``pd``.``read_excel``(``url``,``skiprows``=``1``,``usecols``=``"B:E"``,``nrows``=``2``)`'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``15``]:``url``=``(``"https://raw.githubusercontent.com/fzumstein/"``"python-for-excel/1st-edition/xl/stores.xlsx"``)``pd``.``read_excel``(``url``,``skiprows``=``1``,``usecols``=``"B:E"``,``nrows``=``2``)`'
- en: '`Out[15]:            Store  Employees Manager      Since          0       New
    York         10   Sarah 2018-07-20          1  San Francisco         12  Neriah
    2019-11-02`'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[15]:            Store  Employees Manager      Since          0       纽约        
    10   莎拉 2018-07-20          1  旧金山         12  尼莉亚 2019-11-02`'
- en: READING XLSB FILES VIA PANDAS
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过pandas读取XLSB文件
- en: 'If you use pandas with a version below 1.3, reading xlsb files requires you
    to explicitly specify the engine in the `read_excel` function or `ExcelFile` class:'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你使用版本低于1.3的pandas，读取xlsb文件需要在`read_excel`函数或`ExcelFile`类中显式指定引擎：
- en: '`pd``.``read_excel``(``"xl/stores.xlsb"``,``engine``=``"pyxlsb"``)`'
  id: totrans-67
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`pd``.``read_excel``(``"xl/stores.xlsb"``,``engine``=``"pyxlsb"``)`'
- en: This requires the pyxlsb package to be installed, as it isn’t part of Anaconda—we’ll
    get to that as well as to the other engines in the next chapter.
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这需要安装`pyxlsb`包，因为它不是Anaconda的一部分——我们将在下一章节介绍其它引擎时详细讨论。
- en: To summarize, [Table 7-1](#filepos927326) shows you the most commonly used `read_excel`
    parameters. You will find the complete list in the [official docs](https://oreil.ly/v8Yes).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，[表格 7-1](#filepos927326)展示了最常用的`read_excel`参数。你可以在[官方文档](https://oreil.ly/v8Yes)中找到完整列表。
- en: Table 7-1\. Selected parameters for read_excel
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Table 7-1\. `read_excel`的选定参数
- en: '|  Parameter  |  Description  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|  参数  |  描述  |'
- en: '|   `sheet_name` |  Instead of providing a sheet name, you could also provide
    the index of the sheet (zero-based), e.g.,  `sheet_name=0`. If you set `sheet_name=None`,
    pandas will read the whole workbook and return a dictionary in the form of `{"sheetname":
    df}`. To read a selection of sheets, provide a list with sheet names or indices.
    |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|   `sheet_name` |  你可以提供一个零基索引的表名，例如，`sheet_name=0`。如果你设置`sheet_name=None`，pandas将读取整个工作簿，并返回形如`{"sheetname":
    df}`的字典。如果要读取选择的几个表，可以提供一个包含表名或索引的列表。 |'
- en: '|   `skiprows` |  This allows you to skip over the indicated number of rows. 
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|   `skiprows` |  这允许您跳过指定数量的行。  |'
- en: '|   `usecols` |  If the Excel file includes the names of the column headers,
    provide them in a list to select the columns, e.g.,  `["Store", "Employees"]`.
    Alternatively, it can also be a list of column indices, e.g., `[1, 2]`, or a string
    (not a list!) of Excel column names, including ranges, e.g., `"B:D,G"`. You can
    also provide a function: as an example, to only include the columns that start
    with `Manager`, use: `usecols=lambda x: x.startswith("Manager")`. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|   `usecols` |  如果Excel文件包含列标题的名称，请以列表形式提供它们来选择列，例如，`["Store", "Employees"]`。或者，可以是列索引的列表，例如，`[1,
    2]`，或者一个包含Excel列名（包括范围）的字符串，例如，`"B:D,G"`。还可以提供一个函数：例如，只包含以`Manager`开头的列，请使用：`usecols=lambda
    x: x.startswith("Manager")`。 |'
- en: '|   `nrows` |  Number of rows you want to read.  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|   `nrows` |  你要读取的行数。  |'
- en: '|   `index_col` |  Indicates which column should be the index, accepts a column
    name or an index, e.g.,  `index_col=0`. If you provide a list with multiple columns,
    a hierarchical index will be created. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|   `index_col` |  指示应该作为索引的列，可以是列名或索引，例如，`index_col=0`。如果提供多列的列表，将创建一个分层索引。
    |'
- en: '|   `header` |  If you set  `header=None`, the default integer headers are
    assigned except if you provide the desired names via the `names` parameter. If
    you provide a list of indices, hierarchical column headers will be created. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|   `header` |  如果设置`header=None`，则分配默认整数标题，除非通过`names`参数提供所需的名称。如果提供索引列表，将创建分层列标题。'
- en: '|   `names` |  Provide the desired names of your columns as list.  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|   `names` |  以列表形式提供您的列的期望名称。'
- en: '|   `na_values` |  Pandas interprets the following cell values as  `NaN` by
    default (I introduced `NaN` in [Chapter 5](index_split_015.html#filepos482650)):
    empty cells, `#NA`, `NA`, `null`, `#N/A`, `N/A`, `NaN`, `n/a`, `-NaN`, `1.#IND`,
    `nan`, `#N/A N/A`, `-1.#QNAN`, `-nan`, `NULL`, `-1.#IND`, `<NA>`, `1.#QNAN`. If
    you’d like to add one or more values to that list, provide them via `na_values`.
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|   `na_values` |  默认情况下，pandas将以下单元格值解释为`NaN`（我在[第5章](index_split_015.html#filepos482650)介绍了`NaN`）：空单元格、`#NA`、`NA`、`null`、`#N/A`、`N/A`、`NaN`、`n/a`、`-NaN`、`1.#IND`、`nan`、`#N/A
    N/A`、`-1.#QNAN`、`-nan`、`NULL`、`-1.#IND`、`<NA>`、`1.#QNAN`。如果您想要添加一个或多个值到该列表，请通过`na_values`提供它们。'
- en: '|   `keep_default_na` |  If you’d like to ignore the default values that pandas
    interprets as  `NaN`, set `keep_default_na=False`. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|   `keep_default_na` |  如果您想忽略pandas解释为`NaN`的默认值，请设置`keep_default_na=False`。'
- en: '|   `convert_float` |  Excel stores all numbers internally as floats and by
    default, pandas transforms numbers without meaningful decimals to integers. If
    you want to change that behavior, set  `convert_float=False` (this may be a bit
    faster). |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|   `convert_float` |  Excel将所有数字内部存储为浮点数，并且默认情况下，pandas会将没有意义小数的数字转换为整数。如果您想改变这种行为，请设置`convert_float=False`（这可能会稍快一些）。'
- en: '|   `converters` |  Allows you to provide a function per column to convert
    its values. For example, to make the text in a certain column uppercase, use the
    following:  `converters={"column_name": lambda x: x.upper()}` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|   `converters` |  允许您为每列提供一个函数以转换其值。例如，要使某一列中的文本变为大写，使用以下内容：`converters={"column_name":
    lambda x: x.upper()}`。'
- en: So much for reading Excel files with pandas—let’s now switch sides and learn
    about writing Excel files in the next section!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 读取Excel文件与pandas相关的内容就这么多，接下来我们转向另一方面，学习如何在下一节中写入Excel文件！
- en: The to_excel Method and ExcelWriter Class
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: to_excel方法和ExcelWriter类
- en: 'The easiest way to write an Excel file with pandas is to use a DataFrame’s
    `to_excel` method. It allows you to specify to which cell of which sheet you want
    to write the DataFrame to. You can also decide whether or not to include the column
    headers and the index of the DataFrame and how to treat data types like `np.nan`
    and `np.inf` that don’t have an equivalent representation in Excel. Let’s start
    by creating a DataFrame with different data types and use its `to_excel` method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pandas写入Excel文件的最简单方法是使用DataFrame的`to_excel`方法。它允许您指定要将DataFrame写入的哪个工作表的哪个单元格。您还可以决定是否包括DataFrame的列标题和索引，以及如何处理Excel中没有等价表示的数据类型，如`np.nan`和`np.inf`。让我们从创建具有不同数据类型的DataFrame开始，并使用其`to_excel`方法：
- en: '`In``[``16``]:``import``numpy``as``np``import``datetime``as``dt`'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``16``]:``import``numpy``as``np``import``datetime``as``dt`'
- en: '`In``[``17``]:``data``=``[[``dt``.``datetime``(``2020``,``1``,``1``,``10``,``13``),``2.222``,``1``,``True``],``[``dt``.``datetime``(``2020``,``1``,``2``),``np``.``nan``,``2``,``False``],``[``dt``.``datetime``(``2020``,``1``,``2``),``np``.``inf``,``3``,``True``]]``df``=``pd``.``DataFrame``(``data``=``data``,``columns``=``[``"Dates"``,``"Floats"``,``"Integers"``,``"Booleans"``])``df``.``index``.``name``=``"index"``df`'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``17``]:``data``=``[[``dt``.``datetime``(``2020``,``1``,``1``,``10``,``13``),``2.222``,``1``,``True``],``[``dt``.``datetime``(``2020``,``1``,``2``),``np``.``nan``,``2``,``False``],``[``dt``.``datetime``(``2020``,``1``,``2``),``np``.``inf``,``3``,``True``]]``df``=``pd``.``DataFrame``(``data``=``data``,``columns``=``[``"Dates"``,``"Floats"``,``"Integers"``,``"Booleans"``])``df``.``index``.``name``=``"index"``df'
- en: '`Out[17]:                     Dates  Floats  Integers  Booleans          index
             0     2020-01-01 10:13:00   2.222         1      True          1    
    2020-01-02 00:00:00     NaN         2     False          2     2020-01-02 00:00:00    
    inf         3      True`'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[17]:                     日期        浮点数       整数       布尔值         索引        
    0     2020-01-01 10:13:00   2.222         1      True          1     2020-01-02
    00:00:00     NaN         2     False          2     2020-01-02 00:00:00     inf        
    3      True`'
- en: '`In``[``18``]:``df``.``to_excel``(``"written_with_pandas.xlsx"``,``sheet_name``=``"Output"``,``startrow``=``1``,``startcol``=``1``,``index``=``True``,``header``=``True``,``na_rep``=``"<NA>"``,``inf_rep``=``"<INF>"``)`'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``18``]:``df``.``to_excel``(``"written_with_pandas.xlsx"``,``sheet_name``=``"Output"``,``startrow``=``1``,``startcol``=``1``,``index``=``True``,``header``=``True``,``na_rep``=``"<NA>"``,``inf_rep``=``"<INF>"``)`'
- en: 'Running the `to_excel` command will create the Excel file as shown in [Figure 7-4](#filepos948095)
    (you will need to make column `C` wider to see the dates properly):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `to_excel` 命令将创建 Excel 文件，如 [Figure 7-4](#filepos948095) 所示（您需要扩展列 `C` 以正确查看日期）。
- en: '![](images/00062.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00062.jpg)'
- en: Figure 7-4\. written_with_pandas.xlsx
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-4\. written_with_pandas.xlsx
- en: 'If you want to write multiple DataFrames to the same or different sheets, you
    will need to use the `ExcelWriter` class. The following sample writes the same
    DataFrame to two different locations on Sheet1 and one more time to Sheet2:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将多个 DataFrame 写入同一张或不同的工作表中，需要使用 `ExcelWriter` 类。以下示例将相同的 DataFrame 写入 Sheet1
    的两个不同位置，并再次写入 Sheet2：
- en: '`In``[``19``]:``with``pd``.``ExcelWriter``(``"written_with_pandas2.xlsx"``)``as``writer``:``df``.``to_excel``(``writer``,``sheet_name``=``"Sheet1"``,``startrow``=``1``,``startcol``=``1``)``df``.``to_excel``(``writer``,``sheet_name``=``"Sheet1"``,``startrow``=``10``,``startcol``=``1``)``df``.``to_excel``(``writer``,``sheet_name``=``"Sheet2"``)`'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``19``]:``使用``pd``.``ExcelWriter``(``"written_with_pandas2.xlsx"``)``作为``writer``:``df``.``to_excel``(``writer``,``sheet_name``=``"Sheet1"``,``startrow``=``1``,``startcol``=``1``)``df``.``to_excel``(``writer``,``sheet_name``=``"Sheet1"``,``startrow``=``10``,``startcol``=``1``)``df``.``to_excel``(``writer``,``sheet_name``=``"Sheet2"``)``'
- en: Since we’re using the `ExcelWriter` class as a context manager, the file is
    automatically written to disk when it exits the context manager, i.e., when the
    indentation stops. Otherwise, you will have to call `writer.save()` explicitly.
    For a summary of the most commonly used parameters that `to_excel` accepts, have
    a look at [Table 7-2](#filepos953686). You will find the full list of parameters
    in the [official docs](https://oreil.ly/ESKAG).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 `ExcelWriter` 类作为上下文管理器，当退出上下文管理器时（即缩进停止时），文件会自动写入磁盘。否则，您需要显式调用 `writer.save()`。要获取
    `to_excel` 接受的最常用参数摘要，请参阅 [Table 7-2](#filepos953686)。您可以在 [官方文档](https://oreil.ly/ESKAG)
    中找到所有参数的完整列表。
- en: Table 7-2\. Selected parameters for to_excel
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-2\. to_excel 的选定参数
- en: '|  Parameter  |  Description  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|  参数  |  描述  |'
- en: '|   `sheet_name` |  Name of the sheet to write to.  |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|   `sheet_name` |  要写入的工作表名称。  |'
- en: '|   `startrow` and `startcol` |   `startrow` is the first row where the DataFrame
    will be written to and `startcol` is the first column. This uses zero-based indexing,
    so if you want to write your DataFrame into cell B3, use `startrow=2` and `startcol=1`.
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|   `startrow` 和 `startcol` |   `startrow` 是 DataFrame 将写入的第一行，`startcol` 是第一列。这使用从零开始的索引，因此如果要将
    DataFrame 写入到 B3 单元格，使用 `startrow=2` 和 `startcol=1`。 |'
- en: '|   `index` and `header` |  If you want to hide the index and/or header, set
    them to  `index=False` and `header=False`, respectively. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|   `index` 和 `header` |  如果要隐藏索引和/或标题，将它们分别设置为 `index=False` 和 `header=False`。
    |'
- en: '|   `na_rep` and `inf_rep` |  By default,  `np.nan` will be converted to an
    empty cell, while `np.inf`, NumPy’s representation of infinity, will be converted
    to the string `inf`. Providing values allows you to change this behavior. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '|   `na_rep` 和 `inf_rep` |  默认情况下，`np.nan` 将转换为空单元格，而 `np.inf`（NumPy 表示的无穷大）将转换为字符串
    `inf`。提供值可以更改此行为。 |'
- en: '|   `freeze_panes` |  Freeze the first couple of rows and columns by supplying
    a tuple: for example  `(2, 1)` will freeze the first two rows and the first column.
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|   `freeze_panes` |  通过提供一个元组来冻结前几行和列：例如 `(2, 1)` 将冻结前两行和第一列。 |'
- en: As you can see, reading and writing simple Excel files with pandas works well.
    There are limitations, though—let’s see which ones!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用 pandas 轻松读写简单的 Excel 文件效果很好。然而，有一些限制——让我们来看看是哪些限制！
- en: Limitations When Using pandas with Excel Files
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pandas 处理 Excel 文件的限制
- en: 'Using the pandas interface to read and write Excel files works great for simple
    cases, but there are limits:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pandas 接口读写 Excel 文件在简单情况下效果很好，但也有一些限制：
- en: When writing DataFrames to files, you can’t include a title or a chart.
  id: totrans-106
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当将 DataFrame 写入文件时，无法包含标题或图表。
- en: There is no way to change the default format of the header and index in Excel.
  id: totrans-107
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 Excel 中无法更改默认的标题和索引格式。
- en: When reading files, pandas automatically transforms cells with errors like `#REF!`
    or `#NUM!` into `NaN`, making it impossible to search for specific errors in your
    spreadsheets.
  id: totrans-108
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在读取文件时，pandas 自动将带有诸如 `#REF!` 或 `#NUM!` 的错误单元格转换为 `NaN`，这使得在电子表格中搜索特定错误变得不可能。
- en: Working with big Excel files may require extra settings that are easier to control
    by using the reader and writer packages directly, as we will see in the next chapter.
  id: totrans-109
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 处理大型 Excel 文件可能需要额外的设置，通过直接使用读取器和写入器包更容易控制，我们将在下一章中讨论。
- en: Conclusion
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 结论
- en: The nice thing about pandas is that it offers a consistent interface to work
    with all supported Excel file formats, whether that’s xls, xlsx, xlsm, or xlsb.
    This made it easy for us to read a directory of Excel files, aggregate the data,
    and dump the summary into an Excel report—in only ten lines of code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 的好处在于，它提供了一个一致的接口来处理所有支持的 Excel 文件格式，无论是 xls、xlsx、xlsm 还是 xlsb。这使得我们能够轻松读取一个目录中的
    Excel 文件，聚合数据，并将摘要信息仅用十行代码转储到 Excel 报告中。
- en: 'pandas, however, doesn’t do the heavy lifting itself: under the hood, it selects
    a reader or writer package to do the job. In the next chapter, I will show you
    which reader and writer packages pandas uses and how you use them directly or
    in combination with pandas. This will allow us to work around the limitations
    we saw in the previous section.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: pandas，然而，并不是自己完成繁重的工作：在幕后，它选择一个读取器或写入器包来完成工作。在下一章中，我将向你展示 pandas 使用哪些读取器和写入器包，并且如何直接或与
    pandas 结合使用它们。这将使我们能够解决我们在前一节中看到的限制。
