<html><head></head><body><section data-pdf-bookmark="Chapter 3. Reverse Complement of DNA: String Manipulation" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch03">&#13;
<h1><span class="label">Chapter 3. </span>Reverse Complement of DNA: <span class="keep-together">String Manipulation</span></h1>&#13;
&#13;
&#13;
<p>The <a href="https://oreil.ly/ot4z6">Rosalind REVC challenge</a> explains that the bases of DNA form pairs of <em>A-T</em> and <em>G-C</em>.<a data-primary="reverse complement of DNA" data-secondary="about" data-type="indexterm" id="idm45963631533176"/><a data-primary="strings (str)" data-secondary="manipulating" data-see="reverse complement of DNA" data-type="indexterm" id="idm45963631532216"/><a data-primary="base pairs in reverse complement of DNA" data-type="indexterm" id="idm45963631530984"/><a data-primary="DNA" data-secondary="reverse complement" data-see="reverse complement of DNA" data-type="indexterm" id="idm45963631530296"/>&#13;
Additionally, DNA has directionality and is usually read from the 5'-end (<em>five-prime end</em>) toward the 3'-end (<em>three-prime end</em>).<a data-primary="DNA" data-secondary="directionality of" data-type="indexterm" id="idm45963631527944"/>&#13;
As shown in <a data-type="xref" href="#fig_3.1">Figure 3-1</a>, the complement of the DNA string <em>AAAACCCGGT</em> is <em>TTTTGGGCCA</em>.<a data-primary="complement of DNA string" data-type="indexterm" id="idm45963631525096"/><a data-primary="strings (str)" data-secondary="mutating" data-see="transcribing DNA into mRNA" data-type="indexterm" id="idm45963631524408"/>&#13;
I then reverse this string (reading from the 3'-end) to get <em>ACCGGGTTTT</em> as the reverse complement.</p>&#13;
&#13;
<figure><div class="figure" id="fig_3.1">&#13;
<img alt="mpfb 0301" src="assets/mpfb_0301.png" width="250"/>&#13;
<h6><span class="label">Figure 3-1. </span>The reverse complement of DNA is the complement read from the opposite direction</h6>&#13;
</div></figure>&#13;
&#13;
<p>Although you can find many existing tools to generate the reverse complement of DNA—and I’ll drop a spoiler alert that the final solution will use a function from the Biopython library—the point of writing our own algorithm is to explore Python.&#13;
In this chapter, you will learn:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>How to implement a decision tree using a dictionary as a lookup table</p>&#13;
</li>&#13;
<li>&#13;
<p>How to dynamically generate a list or a string</p>&#13;
</li>&#13;
<li>&#13;
<p>How to use the <code>reversed()</code> function, which is an example of an iterator</p>&#13;
</li>&#13;
<li>&#13;
<p>How Python treats strings and lists similarly</p>&#13;
</li>&#13;
<li>&#13;
<p>How to use a list comprehension to generate a list</p>&#13;
</li>&#13;
<li>&#13;
<p>How to use <code>str.maketrans()</code> and <code>str.translate()</code> to transform a string</p>&#13;
</li>&#13;
<li>&#13;
<p>How to use Biopython’s <code>Bio.Seq</code> module</p>&#13;
</li>&#13;
<li>&#13;
<p>That the real treasure is the friends you make along the way</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Getting Started" data-type="sect1"><div class="sect1" id="idm45963631509592">&#13;
<h1>Getting Started</h1>&#13;
&#13;
<p>The code and tests for this program are in the <em>03_revc</em> directory.<a data-primary="reverse complement of DNA" data-secondary="getting started" data-type="indexterm" id="idm45963631507816"/>&#13;
To get a feel for how the program will work, change into that directory and copy the first solution to a program called <code>revc.py</code>:</p>&#13;
&#13;
<pre data-type="programlisting">$ cd 03_revc&#13;
$ cp solution1_for_loop.py revc.py</pre>&#13;
&#13;
<p>Run the program with <code>--help</code> to read the usage:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./revc.py --help&#13;
usage: revc.py [-h] DNA&#13;
&#13;
Print the reverse complement of DNA&#13;
&#13;
positional arguments:&#13;
  DNA         Input sequence or file&#13;
&#13;
optional arguments:&#13;
  -h, --help  show this help message and exit</pre>&#13;
&#13;
<p>The program wants <code>DNA</code> and will print the reverse complement, so I’ll give it a string:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./revc.py AAAACCCGGT&#13;
ACCGGGTTTT</pre>&#13;
&#13;
<p>As the help indicates, the program will also accept a file as input.&#13;
The first test input has the same string:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat tests/inputs/input1.txt&#13;
AAAACCCGGT</pre>&#13;
&#13;
<p>So the output should be the same:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./revc.py tests/inputs/input1.txt&#13;
ACCGGGTTTT</pre>&#13;
&#13;
<p>I want to make the specs for the program just a little harder, so the tests will pass both a mix of uppercase and lowercase.&#13;
The output should respect the case of the input:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./revc.py aaaaCCCGGT&#13;
ACCGGGtttt</pre>&#13;
&#13;
<p>Run <strong><code>pytest</code></strong> (or <strong><code>make test</code></strong>) to see what kinds of tests the program should pass.&#13;
When you’re satisfied you have a feel for what the program should do, start anew:</p>&#13;
&#13;
<pre data-type="programlisting">$ new.py -f -p 'Print the reverse complement of DNA' revc.py&#13;
Done, see new script "revc.py".</pre>&#13;
&#13;
<p>Edit the <code>get_args()</code> function until the program will print the preceding usage.&#13;
Then modify your program so that it will echo back input either from the command line or from an input file:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./revc.py AAAACCCGGT&#13;
AAAACCCGGT&#13;
$ ./revc.py tests/inputs/input1.txt&#13;
AAAACCCGGT</pre>&#13;
&#13;
<p>If you run the test suite, you should find your program passes the first three tests:</p>&#13;
&#13;
<pre data-type="programlisting">$ pytest -xv&#13;
============================= test session starts ==============================&#13;
...&#13;
&#13;
tests/revc_test.py::test_exists PASSED                                   [ 14%]&#13;
tests/revc_test.py::test_usage PASSED                                    [ 28%]&#13;
tests/revc_test.py::test_no_args PASSED                                  [ 42%]&#13;
tests/revc_test.py::test_uppercase FAILED                                [ 57%]&#13;
&#13;
=================================== FAILURES ===================================&#13;
________________________________ test_uppercase ________________________________&#13;
&#13;
    def test_uppercase():&#13;
        """ Runs on uppercase input """&#13;
&#13;
        rv, out = getstatusoutput(f'{RUN} AAAACCCGGT')&#13;
        assert rv == 0&#13;
&gt;       assert out == 'ACCGGGTTTT'&#13;
E       AssertionError: assert 'AAAACCCGGT' == 'ACCGGGTTTT'&#13;
E         - ACCGGGTTTT&#13;
E         + AAAACCCGGT&#13;
&#13;
tests/revc_test.py:47: AssertionError&#13;
=========================== short test summary info ============================&#13;
FAILED tests/revc_test.py::test_uppercase - AssertionError: assert 'AAAACCCGG...&#13;
!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!&#13;
========================= 1 failed, 3 passed in 0.33s ==========================</pre>&#13;
&#13;
<p>The program is being passed the input string <code>AAAACCCGGT</code>, and the test expects it to print <code>ACCGGGTTTT</code>.&#13;
Since the program is echoing the input, this test fails.&#13;
If you think you know how to write a program to satisfy these tests, have at it.&#13;
If not, I’ll show you how to create the reverse complement of DNA, starting with a simple approach and working up to more elegant solutions.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Iterating Over a Reversed String" data-type="sect2"><div class="sect2" id="idm45963631489400">&#13;
<h2>Iterating Over a Reversed String</h2>&#13;
&#13;
<p>When creating the reverse complement of DNA, it doesn’t matter if you first reverse the sequence and then complement it or vice versa.<a data-primary="reverse complement of DNA" data-secondary="iterating over a reversed string" data-type="indexterm" id="idm45963631487960"/><a data-primary="strings (str)" data-secondary="iterating through" data-tertiary="iterating over a reversed string" data-type="indexterm" id="idm45963631486984"/>&#13;
You will get the same answer either way, so I’ll start with how you can reverse a string.&#13;
In <a data-type="xref" href="ch02.html#ch02">Chapter 2</a>, I showed how you can use a string slice to get a portion of a string.&#13;
If you leave out the start position, it will start from the beginning:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; dna = 'AAAACCCGGT'&#13;
&gt;&gt;&gt; dna[:2]&#13;
'AA'</pre>&#13;
&#13;
<p>If you leave out the stop position, it will go to the end:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; dna[-2:]&#13;
'GT'</pre>&#13;
&#13;
<p>If you leave out both start and stop, it will return a copy of the entire string:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; dna[:]&#13;
'AAAACCCGGT'</pre>&#13;
&#13;
<p>It also takes an optional third argument to indicate the step size.&#13;
I can use no arguments for the start and stop, and a step of <code>-1</code> to reverse the string:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; dna[::-1]&#13;
'TGGCCCAAAA'</pre>&#13;
&#13;
<p>Python also has a built-in <code>reversed()</code> function, so I’ll try that:<a data-primary="reversed() function" data-type="indexterm" id="idm45963631478696"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; reversed(dna)&#13;
&lt;reversed object at 0x7ffc4c9013a0&gt;</pre>&#13;
&#13;
<p>Surprise!&#13;
You were probably expecting to see the string <code>TGGCCCAAAA</code>.&#13;
If you read <code>help(reversed)</code> in the REPL, however, you’ll see that this function will “Return a reverse iterator over the values of the given sequence.”<a data-primary="reversed() function" data-secondary="reverse iterator returned" data-type="indexterm" id="idm45963631475768"/></p>&#13;
&#13;
<p>What is an <em>iterator</em>?&#13;
Python’s <a href="https://oreil.ly/dIzn3">Functional Programming HOWTO</a> describes an iterator as “an object representing a stream of data.”<a data-primary="reverse complement of DNA" data-secondary="iterating over a reversed string" data-tertiary="iterators" data-type="indexterm" id="idm45963631473112"/><a data-primary="strings (str)" data-secondary="iterating through" data-tertiary="iterators" data-type="indexterm" id="idm45963631471864"/><a data-primary="functional programming (FP)" data-secondary="Functional Programming HOWTO" data-tertiary="iterators" data-type="indexterm" id="idm45963631470648"/>&#13;
I’ve mentioned that an <em>iterable</em> is some collection of items that Python can visit individually; for example, the characters of a string or the elements in a list.<a data-primary="iterables" data-secondary="collection items visited individually" data-type="indexterm" id="idm45963631468664"/>&#13;
An iterator is something that will generate values until it is exhausted.<a data-primary="iterators" data-type="indexterm" id="idm45963631467480"/>&#13;
Just as I can start with the first character of a string (or the first <span class="keep-together">element</span> of a list or the first line of a file) and read until the end of the string (or list or file), an iterator can be iterated from the first value it produces until it finishes.</p>&#13;
&#13;
<p>In this case, the <code>reversed()</code> function is returning a promise to produce the reversed values as soon as it appears that you need them.<a data-primary="functions" data-secondary="lazy functions" data-type="indexterm" id="idm45963631464712"/><a data-primary="reversed() function" data-secondary="lazy function" data-type="indexterm" id="idm45963631463768"/><a data-primary="lazy functions" data-secondary="reversed()" data-type="indexterm" id="idm45963631462824"/>&#13;
This is an example of a <em>lazy</em> function because it waits until forced to do any work.&#13;
One way to coerce the values from <code>reversed()</code> is to use a function that will consume the values.&#13;
For instance, if the only goal is to reverse the string, then I could use the <code>str.join()</code> function.&#13;
I always feel the syntax is backward on this function, but you will often invoke the <code>str.join()</code> method on a string literal that is the element used to join the sequence:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; ''.join(reversed(dna)) <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO1-1" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO1-1"><img alt="1" src="assets/1.png"/></a>&#13;
'TGGCCCAAAA'</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO1-1" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Use the empty string to join the reversed characters of the DNA string.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Another method uses the <code>list()</code> function to force <code>reversed()</code> to produce the values:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(reversed(dna))&#13;
['T', 'G', 'G', 'C', 'C', 'C', 'A', 'A', 'A', 'A']</pre>&#13;
&#13;
<p>Wait, what happened?&#13;
The <code>dna</code> variable is a string, but I got back a list—and not just because I used the <code>list()</code> function.&#13;
The documentation for <code>reversed()</code> shows that the function takes a <em>sequence</em>, which means any data structure or function that returns one thing followed by another.&#13;
In a list or iterator context, Python treats strings as lists of characters:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(dna)&#13;
['A', 'A', 'A', 'A', 'C', 'C', 'C', 'G', 'G', 'T']</pre>&#13;
&#13;
<p>A longer way to build up the reversed DNA sequence is to use a <code>for</code> loop to iterate over the reversed bases and append them to a string.&#13;
First I’ll declare a <code>rev</code> variable, and I’ll append each base in reverse order using the <code>+=</code> operator:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; rev = '' <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO2-1" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO2-1"><img alt="1" src="assets/1.png"/></a>&#13;
&gt;&gt;&gt; for base in reversed(dna): <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO2-2" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO2-2"><img alt="2" src="assets/2.png"/></a>&#13;
...     rev += base <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO2-3" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO2-3"><img alt="3" src="assets/3.png"/></a>&#13;
...&#13;
&gt;&gt;&gt; rev&#13;
'TGGCCCAAAA'</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO2-1" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Initialize the <code>rev</code> variable with the empty string.</p></dd>&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO2-2" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Iterate through the reversed bases of DNA.</p></dd>&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO2-3" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Append the current base to the <code>rev</code> variable.</p></dd>&#13;
</dl>&#13;
&#13;
<p>But since I still need to complement the bases, I’m not quite done.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating a Decision Tree" data-type="sect2"><div class="sect2" id="idm45963631428760">&#13;
<h2>Creating a Decision Tree</h2>&#13;
&#13;
<p>There are a total of eight complements: <em>A</em> to <em>T</em> and <em>G</em> to <em>C</em>, both upper- and lowercase, and then vice versa.<a data-primary="reverse complement of DNA" data-secondary="decision tree creation" data-type="indexterm" id="idm45963631425592"/><a data-primary="decision trees" data-secondary="reverse complement of DNA" data-type="indexterm" id="idm45963631424632"/><a data-primary="if and elif decision tree" data-secondary="reverse complement of DNA" data-type="indexterm" id="idm45963631423672"/>&#13;
I also need to handle the case of a character <em>not</em> being <em>A</em>, <em>C</em>, <em>G</em>, or <em>T</em>.&#13;
I can use <code>if</code>/<code>elif</code> statements to create a decision tree.&#13;
I’ll change my variable to <code>revc</code> since it’s now the reverse complement, and I’ll figure out the correct complement for each base:</p>&#13;
&#13;
<pre data-type="programlisting">revc = '' <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-1" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-1"><img alt="1" src="assets/1.png"/></a>&#13;
for base in reversed(dna): <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-2" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-2"><img alt="2" src="assets/2.png"/></a>&#13;
    if base == 'A': <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-3" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-3"><img alt="3" src="assets/3.png"/></a>&#13;
        revc += 'T' <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-4" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-4"><img alt="4" src="assets/4.png"/></a>&#13;
    elif base == 'T':&#13;
        revc += 'A'&#13;
    elif base == 'G':&#13;
        revc += 'C'&#13;
    elif base == 'C':&#13;
        revc += 'G'&#13;
    elif base == 'a':&#13;
        revc += 't'&#13;
    elif base == 't':&#13;
        revc += 'a'&#13;
    elif base == 'g':&#13;
        revc += 'c'&#13;
    elif base == 'c':&#13;
        revc += 'g'&#13;
    else: <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-5" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-5"><img alt="5" src="assets/5.png"/></a>&#13;
        revc += base</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-1" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Initialize a variable to hold the reverse complement string.</p></dd>&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-2" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Iterate through the reversed bases in the DNA string.</p></dd>&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-3" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Test each uppercase and lowercase base.</p></dd>&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-4" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Append the complementing base to the variable.</p></dd>&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-5" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>If the base doesn’t match any of these tests, use the base as is.</p></dd>&#13;
</dl>&#13;
&#13;
<p>If you inspect the <code>revc</code> variable, it appears to be correct:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; revc&#13;
'ACCGGGTTTT'</pre>&#13;
&#13;
<p>You should be able to incorporate these ideas into a program that will pass the test suite.&#13;
To understand what exactly is expected of your program, take a look at the <em>tests/revc_test.py</em> file.&#13;
After you pass the <code>test_uppercase()</code> function, see what is expected by <code>test_lowercase()</code>:</p>&#13;
&#13;
<pre data-type="programlisting">def test_lowercase():&#13;
    """ Runs on lowercase input """&#13;
&#13;
    rv, out = getstatusoutput(f'{RUN} aaaaCCCGGT') <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO4-1" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO4-1"><img alt="1" src="assets/1.png"/></a>&#13;
    assert rv == 0 <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO4-2" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO4-2"><img alt="2" src="assets/2.png"/></a>&#13;
    assert out == 'ACCGGGtttt' <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO4-3" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO4-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO4-1" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Run the program using lowercase and uppercase DNA strings.</p></dd>&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO4-2" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The exit value should be <code>0</code>.</p></dd>&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO4-3" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The output from the program should be the indicated string.</p></dd>&#13;
</dl>&#13;
&#13;
<p>The next tests will pass filenames rather than strings as input:</p>&#13;
&#13;
<pre data-type="programlisting">def test_input1():&#13;
    """ Runs on file input """&#13;
&#13;
    file, expected = TEST1 <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-1" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-1"><img alt="1" src="assets/1.png"/></a>&#13;
    rv, out = getstatusoutput(f'{RUN} {file}') <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-2" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-2"><img alt="2" src="assets/2.png"/></a>&#13;
    assert rv == 0 <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-3" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-3"><img alt="3" src="assets/3.png"/></a>&#13;
    assert out == open(expected).read().rstrip() <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-4" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-4"><img alt="4" src="assets/4.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-1" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The <code>TEST1</code> tuple is a file of input and a file of expected output.</p></dd>&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-2" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Run the program with the filename.</p></dd>&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-3" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Make sure the exit value is <code>0</code>.</p></dd>&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-4" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Open and read the expected file and compare that to the output.</p></dd>&#13;
</dl>&#13;
&#13;
<p>It’s equally important to read and understand the testing code as it is to learn how to write the solutions.&#13;
When you write your programs, you may find you can copy many of the ideas from these tests and save yourself time.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Refactoring" data-type="sect2"><div class="sect2" id="idm45963631351352">&#13;
<h2>Refactoring</h2>&#13;
&#13;
<p>While the algorithm in the preceding section will produce the correct answer, it is not an elegant solution.<a data-primary="reverse complement of DNA" data-secondary="refactoring" data-type="indexterm" id="idm45963631349960"/><a data-primary="refactoring programs" data-secondary="reverse complement of DNA" data-type="indexterm" id="idm45963631349000"/>&#13;
Still, it’s a place to start that passes the tests.&#13;
Now that you perhaps have a better idea of the challenge, it’s time to refactor the program.&#13;
Some of the solutions I present are as short as one or two lines of code.&#13;
Here are some ideas you might consider:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Use a dictionary as a lookup table instead of the <code>if</code>/<code>elif</code> chain.</p>&#13;
</li>&#13;
<li>&#13;
<p>Rewrite the <code>for</code> loop as a list comprehension.</p>&#13;
</li>&#13;
</ul>&#13;
<div class="hard-pagebreak"/>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Use the <code>str.translate()</code> method to complement the bases.</p>&#13;
</li>&#13;
<li>&#13;
<p>Create a <code>Bio.Seq</code> object and find the method that will do this for you.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>There’s no hurry to read ahead.&#13;
Take your time to try other solutions.&#13;
I haven’t introduced all these ideas yet, so I encourage you to research any unknowns and see if you can figure them out on your own.</p>&#13;
&#13;
<p>I remember one of my teachers in music school sharing this quote with me:</p>&#13;
<blockquote>&#13;
<p>Then said a teacher, Speak to us of Teaching.<a data-primary="Gibran, Kahlil" data-type="indexterm" id="idm45963631338616"/></p>&#13;
&#13;
<p>And he said:</p>&#13;
&#13;
<p>No man can reveal to you aught but that which already lies half asleep in the dawning of your knowledge.</p>&#13;
&#13;
<p>The teacher who walks in the shadow of the temple, among his followers, gives not of his wisdom but rather of his faith and his lovingness.</p>&#13;
&#13;
<p>If he is indeed wise he does not bid you enter the house of his wisdom, but rather leads you to the threshold of your own mind.</p>&#13;
<p data-type="attribution">Kahlil Gibran</p>&#13;
</blockquote>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solutions" data-type="sect1"><div class="sect1" id="idm45963631334456">&#13;
<h1>Solutions</h1>&#13;
&#13;
<p>All of the solutions share the same <code>get_args()</code> function, as follows:<a data-primary="reverse complement of DNA" data-secondary="solutions share same get_args()" data-type="indexterm" id="idm45963631332696"/><a data-primary="get_args()" data-secondary="reverse complement of DNA" data-type="indexterm" id="idm45963631331720"/></p>&#13;
&#13;
<pre data-type="programlisting">class Args(NamedTuple): <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO6-1" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO6-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Command-line arguments """&#13;
    dna: str&#13;
&#13;
&#13;
# --------------------------------------------------&#13;
def get_args() -&gt; Args:&#13;
    """ Get command-line arguments """&#13;
&#13;
    parser = argparse.ArgumentParser(&#13;
        description='Print the reverse complement of DNA',&#13;
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)&#13;
&#13;
    parser.add_argument('dna', metavar='DNA', help='Input sequence or file')&#13;
&#13;
    args = parser.parse_args()&#13;
&#13;
    if os.path.isfile(args.dna): <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO6-2" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO6-2"><img alt="2" src="assets/2.png"/></a>&#13;
        args.dna = open(args.dna).read().rstrip()&#13;
&#13;
    return Args(args.dna) <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO6-3" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO6-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO6-1" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The only argument to the program is a string of DNA.</p></dd>&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO6-2" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Handle the case when reading a file input.</p></dd>&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO6-3" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO6-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Return an <code>Args</code> object in compliance with the function signature.</p></dd>&#13;
</dl>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 1: Using a for Loop and Decision Tree" data-type="sect2"><div class="sect2" id="idm45963636236824">&#13;
<h2>Solution 1: Using a for Loop and Decision Tree</h2>&#13;
&#13;
<p>Here is my first solution using the <code>if</code>/<code>else</code> decision tree:<a data-primary="reverse complement of DNA" data-secondary="solution 1 loop and decision tree" data-type="indexterm" id="idm45963636234584"/><a data-primary="decision trees" data-secondary="reverse complement of DNA" data-type="indexterm" id="idm45963636233608"/><a data-primary="reverse complement of DNA" data-secondary="decision tree creation" data-type="indexterm" id="idm45963636232648"/></p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    revc = '' <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-1" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
    for base in reversed(args.dna): <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-2" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-2"><img alt="2" src="assets/2.png"/></a>&#13;
        if base == 'A': <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-3" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-3"><img alt="3" src="assets/3.png"/></a>&#13;
            revc += 'T'&#13;
        elif base == 'T':&#13;
            revc += 'A'&#13;
        elif base == 'G':&#13;
            revc += 'C'&#13;
        elif base == 'C':&#13;
            revc += 'G'&#13;
        elif base == 'a':&#13;
            revc += 't'&#13;
        elif base == 't':&#13;
            revc += 'a'&#13;
        elif base == 'g':&#13;
            revc += 'c'&#13;
        elif base == 'c':&#13;
            revc += 'g'&#13;
        else:&#13;
            revc += base&#13;
&#13;
    print(revc) <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-4" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-4"><img alt="4" src="assets/4.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-1" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Initialize a variable to hold the reverse complement.</p></dd>&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-2" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Iterate through the reversed bases of the DNA argument.</p></dd>&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-3" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Create an <code>if</code>/<code>elif</code> decision tree to determine each base’s complement.</p></dd>&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-4" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Print the result.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 2: Using a Dictionary Lookup" data-type="sect2"><div class="sect2" id="idm45963636209912">&#13;
<h2>Solution 2: Using a Dictionary Lookup</h2>&#13;
&#13;
<p>I mentioned that the <code>if</code>/<code>else</code> chain is something you should try to replace.<a data-primary="reverse complement of DNA" data-secondary="solution 2 dictionary lookup" data-type="indexterm" id="idm45963636207672"/><a data-primary="dictionaries" data-secondary="reverse complement of DNA" data-type="indexterm" id="idm45963636206696"/>&#13;
That is 18 lines of code (LOC) that could be represented more easily using a dictionary lookup:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; trans = {&#13;
...     'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A',&#13;
...     'a': 't', 'c': 'g', 'g': 'c', 't': 'a'&#13;
... }</pre>&#13;
&#13;
<p>If I use a <code>for</code> loop to iterate through a string of DNA, I can use the <code>dict.get()</code> method to safely request each base in a string of DNA to create the complement (see <a data-type="xref" href="#fig_3.1">Figure 3-1</a>).&#13;
Note that I will use the <code>base</code> as the optional second argument to <code>dict.get()</code>.&#13;
If the base doesn’t exist in the lookup table, then I’ll default to using the base as is, just like the <code>else</code> case from the first solution:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; for base in 'AAAACCCGGT':&#13;
...     print(base, trans.get(base, base))&#13;
...&#13;
A T&#13;
A T&#13;
A T&#13;
A T&#13;
C G&#13;
C G&#13;
C G&#13;
G C&#13;
G C&#13;
T A</pre>&#13;
&#13;
<p>I can create a <code>complement</code> variable to hold the new string I generate:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; complement = ''&#13;
&gt;&gt;&gt; for base in 'AAAACCCGGT':&#13;
...     complement += trans.get(base, base)&#13;
...&#13;
&gt;&gt;&gt; complement&#13;
'TTTTGGGCCA'</pre>&#13;
&#13;
<p>You saw before that using the <code>reversed()</code> function on a string will return a list of the characters of the string in reverse order:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(reversed(complement))&#13;
['A', 'C', 'C', 'G', 'G', 'G', 'T', 'T', 'T', 'T']</pre>&#13;
&#13;
<p>I can use the <code>str.join()</code> function to create a new string from a list:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; ''.join(reversed(complement))&#13;
'ACCGGGTTTT'</pre>&#13;
&#13;
<p>When I put all these ideas together, the <code>main()</code> function becomes significantly shorter.&#13;
It also becomes easier to expand because adding a new branch to the decision tree only requires adding a new key/value pair to the dictionary:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    trans = { <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-1" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-1"><img alt="1" src="assets/1.png"/></a>&#13;
        'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A',&#13;
        'a': 't', 'c': 'g', 'g': 'c', 't': 'a'&#13;
    }&#13;
&#13;
    complement = '' <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-2" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-2"><img alt="2" src="assets/2.png"/></a>&#13;
    for base in args.dna: <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-3" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-3"><img alt="3" src="assets/3.png"/></a>&#13;
        complement += trans.get(base, base) <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-4" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-4"><img alt="4" src="assets/4.png"/></a>&#13;
&#13;
    print(''.join(reversed(complement))) <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-5" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-5"><img alt="5" src="assets/5.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-1" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>This is a dictionary showing how to translate one base to its complement.</p></dd>&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-2" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Initialize a variable to hold the DNA complement.</p></dd>&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-3" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Iterate through each base in the DNA string.</p></dd>&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-4" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Append the translation of the base or the base itself to the complement.</p></dd>&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-5" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Reverse the complement and join the results on an empty string.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Python strings and lists are somewhat interchangeable. I can change the <span class="keep-together"><code>complement</code></span> variable to a list, and nothing else in the program changes:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    trans = {&#13;
        'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A',&#13;
        'a': 't', 'c': 'g', 'g': 'c', 't': 'a'&#13;
    }&#13;
&#13;
    complement = [] <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO9-1" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO9-1"><img alt="1" src="assets/1.png"/></a>&#13;
    for base in args.dna:&#13;
        complement += trans.get(base, base)&#13;
&#13;
    print(''.join(reversed(complement)))</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO9-1" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO9-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Initialize the complement to an empty list instead of a string.</p></dd>&#13;
</dl>&#13;
&#13;
<p>I am highlighting here that the <code>+=</code> operator works with both strings and lists to append a new value at the end.&#13;
There is also a <code>list.append()</code> method which does the same:</p>&#13;
&#13;
<pre data-type="programlisting">for base in args.dna:&#13;
    complement.append(trans.get(base, base))</pre>&#13;
&#13;
<p>The <code>reversed()</code> function works just as well on a list as it does a string.&#13;
It’s somewhat remarkable to me that using two different types for the <code>complement</code> results in so few changes to the code.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 3: Using a List Comprehension" data-type="sect2"><div class="sect2" id="idm45963636156824">&#13;
<h2>Solution 3: Using a List Comprehension</h2>&#13;
&#13;
<p>I suggested that you use a list comprehension without telling you what that is.<a data-primary="reverse complement of DNA" data-secondary="solution 3 list comprehension" data-type="indexterm" id="idm45963636155448"/><a data-primary="list comprehension" data-secondary="about" data-type="indexterm" id="idm45963636154472"/><a data-primary="list comprehension" data-secondary="reverse complement of DNA" data-type="indexterm" id="idm45963636153528"/><a data-primary="for loops" data-secondary="list comprehension" data-type="indexterm" id="idm45963636152568"/>&#13;
If you’ve never used one before, it’s essentially a way to write a <code>for</code> loop inside the square brackets (<code>[]</code>) used to create a new list (see <a data-type="xref" href="#fig_3.2">Figure 3-2</a>).&#13;
When the goal of a <code>for</code> loop is to build up a new string or list, it makes much more sense to use a list <span class="keep-together">comprehension.</span></p>&#13;
&#13;
<figure><div class="figure" id="fig_3.2">&#13;
<img alt="mpfb 0302" src="assets/mpfb_0302.png" width="250"/>&#13;
<h6><span class="label">Figure 3-2. </span>A list comprehension uses a <code>for</code> loop to generate a new list</h6>&#13;
</div></figure>&#13;
&#13;
<p>This shortens the three lines to initialize a <code>complement</code> and loop through the string of DNA down to one line:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    trans = {&#13;
        'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A',&#13;
        'a': 't', 'c': 'g', 'g': 'c', 't': 'a'&#13;
    }&#13;
&#13;
    complement = [trans.get(base, base) for base in args.dna] <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO10-1" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO10-1"><img alt="1" src="assets/1.png"/></a>&#13;
    print(''.join(reversed(complement)))</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO10-1" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO10-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Replace the <code>for</code> loop with a list comprehension.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Since the <code>complement</code> variable is only used once, I might even shorten this further by using the list comprehension directly:</p>&#13;
&#13;
<pre data-type="programlisting">print(''.join(reversed([trans.get(base, base) for base in args.dna])))</pre>&#13;
&#13;
<p>This is acceptable because the line is shorter than the maximum of 79 characters recommended by PEP8, but it’s not as readable as the longer version.&#13;
You should use whatever version you feel is most immediately understandable.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 4: Using str.translate()" data-type="sect2"><div class="sect2" id="idm45963636135256">&#13;
<h2>Solution 4: Using str.translate()</h2>&#13;
&#13;
<p>In <a data-type="xref" href="ch02.html#ch02">Chapter 2</a>, I used the <code>str.replace()</code> method to substitute all the <em>T</em>s with <em>U</em>s when transcribing DNA to RNA.<a data-primary="reverse complement of DNA" data-secondary="solution 4 str.translate" data-type="indexterm" id="idm45963636131736"/><a data-primary="strings (str)" data-secondary="translate() function" data-type="indexterm" id="idm45963636130760"/><a data-primary="translate() function for strings" data-type="indexterm" id="idm45963636129816"/>&#13;
Could I use that here?&#13;
Let’s try.&#13;
I’ll start by initializing the DNA string and replacing the <em>A</em>s with <em>T</em>s.&#13;
Remember that strings are <em>immutable</em>, meaning I can’t change a string in place, but rather must overwrite the string with a new value:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; dna = 'AAAACCCGGT'&#13;
&gt;&gt;&gt; dna = dna.replace('A', 'T')</pre>&#13;
&#13;
<p>Now let’s look at the DNA string:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; dna&#13;
'TTTTCCCGGT'</pre>&#13;
&#13;
<p>Can you see where this has started to go wrong?&#13;
I’ll complement the <em>T</em>s to <em>A</em>s now, and see if you can spot the problem:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; dna = dna.replace('T', 'A')&#13;
&gt;&gt;&gt; dna&#13;
'AAAACCCGGA'</pre>&#13;
&#13;
<p>As shown in <a data-type="xref" href="#fig_3.3">Figure 3-3</a>, all the <em>A</em>s that turned into <em>T</em>s in the first move were just changed back to <em>A</em>s.&#13;
Oh, that way madness lies.</p>&#13;
&#13;
<figure><div class="figure" id="fig_3.3">&#13;
<img alt="mpfb 0303" src="assets/mpfb_0303.png" width="250"/>&#13;
<h6><span class="label">Figure 3-3. </span>Iteratively using <code>str.replace()</code> leads to double replacements of values and the wrong answer</h6>&#13;
</div></figure>&#13;
&#13;
<p>Fortunately, Python has the <code>str.translate()</code> function for exactly this purpose.&#13;
If you read <strong><code>help(str.translate)</code></strong>, you will find the function requires a table “which must be a mapping of Unicode ordinals to Unicode ordinals, strings, or <code>None</code>.”&#13;
The <code>trans</code> dictionary table will serve, but first, it must be passed to the <code>str.maketrans()</code> function to transform the complement table into a form that uses the <em>ordinal</em> values of the keys:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; trans = {&#13;
...     'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A',&#13;
...     'a': 't', 'c': 'g', 'g': 'c', 't': 'a'&#13;
... }&#13;
&gt;&gt;&gt; str.maketrans(trans)&#13;
{65: 'T', 67: 'G', 71: 'C', 84: 'A', 97: 't', 99: 'g', 103: 'c', 116: 'a'}</pre>&#13;
&#13;
<p>You can see that the string key <code>A</code> was turned into the integer value <code>65</code>, which is the same value returned by the <code>ord()</code> function:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; ord('A')&#13;
65</pre>&#13;
&#13;
<p>This value represents the ordinal position of the character <em>A</em> in the ASCII (American Standard Code for Information Interchange, pronounced <em>as-key</em>) table.<a data-primary="ASCII (American Standard Code for Information Interchange) table" data-type="indexterm" id="idm45963636109384"/><a data-primary="chr() function" data-type="indexterm" id="idm45963636108664"/><a data-primary="ord() function" data-type="indexterm" id="idm45963636107992"/>&#13;
That is, <em>A</em> is the 65<sup>th</sup> character in the table.&#13;
The <code>chr()</code> function will reverse this process, providing the character represented by an ordinal value:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; chr(65)&#13;
'A'</pre>&#13;
&#13;
<p>The <code>str.translate()</code> function requires the complement table to have ordinal values for the keys, which is what I get from <code>str.maketrans()</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; 'AAAACCCGGT'.translate(str.maketrans(trans))&#13;
'TTTTGGGCCA'</pre>&#13;
&#13;
<p>Finally, I need to reverse the complement.&#13;
Here is a solution that incorporates all these ideas:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
&#13;
    trans = str.maketrans({ <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO11-1" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO11-1"><img alt="1" src="assets/1.png"/></a>&#13;
        'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A',&#13;
        'a': 't', 'c': 'g', 'g': 'c', 't': 'a'&#13;
    })&#13;
    print(''.join(reversed(args.dna.translate(trans)))) <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO11-2" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO11-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO11-1" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO11-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Create the translation table needed for the <code>str.translate()</code> function.</p></dd>&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO11-2" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO11-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Complement the DNA using the <code>trans</code> table. Reverse, and join for a new string.</p></dd>&#13;
</dl>&#13;
&#13;
<p>But, wait—there’s more!&#13;
There’s another even shorter way to write this. According to the <code>help(str.translate)</code> documentation:</p>&#13;
<blockquote>&#13;
<p>If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters to Unicode ordinals, strings or <code>None</code>. Character keys will be then converted to ordinals. <em>If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in <code>x</code> will be mapped to the character at the same position in <code>y</code>.</em></p></blockquote>&#13;
&#13;
<p>So I can remove the <code>trans</code> dictionary and write the entire solution like this:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    trans = str.maketrans('ACGTacgt', 'TGCAtgca') <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO12-1" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO12-1"><img alt="1" src="assets/1.png"/></a>&#13;
    print(''.join(reversed(args.seq.translate(trans)))) <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO12-2" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO12-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO12-1" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO12-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Make the translation table using two strings of equal lengths.</p></dd>&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO12-2" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO12-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Create the reverse complement.</p></dd>&#13;
</dl>&#13;
&#13;
<p>If you wanted to ruin someone’s day—and in all likelihood, that person will be future you—you could even condense this into a single line of code.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 5: Using Bio.Seq" data-type="sect2"><div class="sect2" id="idm45963636074184">&#13;
<h2>Solution 5: Using Bio.Seq</h2>&#13;
&#13;
<p>I told you at the beginning of this chapter that the final solution would involve an existing<a data-primary="reverse complement of DNA" data-secondary="solution 5 using Bio.Seq" data-type="indexterm" id="idm45963636072792"/><a data-primary="Biopython library" data-secondary="Bio.Seq" data-tertiary="reverse_complement()" data-type="indexterm" id="idm45963636071816"/> function.<sup><a data-type="noteref" href="ch03.html#idm45963636070440" id="idm45963636070440-marker">1</a></sup>&#13;
Many Python programmers working in bioinformatics have contributed to a set of modules under the name of <a href="https://biopython.org">Biopython</a>.<a data-primary="Biopython library" data-secondary="installing" data-type="indexterm" id="idm45963636068712"/><a data-primary="resources" data-secondary="Biopython library" data-type="indexterm" id="idm45963636067768"/>&#13;
They have written and tested many incredibly useful algorithms, and it rarely makes sense to write your own code when you can use someone else’s.</p>&#13;
&#13;
<p>Be sure that you have first installed <code>biopython</code> by running the following:</p>&#13;
&#13;
<pre data-type="programlisting">$ python3 -m pip install biopython</pre>&#13;
&#13;
<p>I could import the entire module using <code>import Bio</code>, but it makes much more sense to only import the code I need.&#13;
Here I only need the <code>Seq</code> class:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from Bio import Seq</pre>&#13;
&#13;
<p>Now I can use the <code>Seq.reverse_complement()</code> function:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; Seq.reverse_complement('AAAACCCGGT')&#13;
'ACCGGGTTTT'</pre>&#13;
&#13;
<p>This final solution is the version I would recommend, as it is the shortest and also uses existing, well-tested, documented modules that are almost ubiquitous in <span class="keep-together">bioinformatics</span> with Python:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    print(Seq.reverse_complement(args.dna)) <a class="co" href="#callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO13-1" id="co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO13-1"><img alt="1" src="assets/1.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO13-1" id="callout_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO13-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Use the <code>Bio.Seq.reverse_complement()</code> function.</p></dd>&#13;
</dl>&#13;
&#13;
<p>When you run <code>mypy</code> on this solution (you <em>are</em> running <code>mypy</code> on every one of your programs, right?), you may get the following error:<a data-primary="reverse complement of DNA" data-secondary="testing with mypy" data-type="indexterm" id="idm45963636051416"/><a data-primary="errors" data-secondary="mypy" data-tertiary="Bio.Seq.reverse_complement()" data-type="indexterm" id="idm45963636050456"/></p>&#13;
&#13;
<pre data-type="programlisting">=================================== FAILURES ===================================&#13;
___________________________________ revc.py ____________________________________&#13;
6: error: Skipping analyzing 'Bio': found module but no type hints or library&#13;
    stubs&#13;
6: note: See https://mypy.readthedocs.io/en/latest/running_mypy.html#missing&#13;
    -imports&#13;
===================================== mypy =====================================&#13;
Found 1 error in 1 file (checked 2 source files)&#13;
mypy.ini: No [mypy] section in config file&#13;
&#13;
=========================== short test summary info ============================&#13;
FAILED revc.py::mypy&#13;
!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!&#13;
========================= 1 failed, 1 skipped in 0.20s =========================</pre>&#13;
&#13;
<p>To silence this error, you can tell <code>mypy</code> to ignore imported files that are missing type annotations.<a data-primary="mypy" data-secondary="imported files missing type annotations" data-type="indexterm" id="idm45963636046776"/><a data-primary="errors" data-secondary="mypy" data-tertiary="imported files missing type annotations" data-type="indexterm" id="idm45963636045816"/>&#13;
In the <a href="https://oreil.ly/RpMgV">root directory of the GitHub repository for this book</a>, you will find a file called <em>mypy.ini</em> with the following contents:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat mypy.ini&#13;
[mypy]&#13;
ignore_missing_imports = True</pre>&#13;
&#13;
<p>Adding a <em>mypy.ini</em> file to any working directory allows you to make changes to the defaults that <code>mypy</code> uses <em>when you run it in the same directory</em>.&#13;
If you would like to make this a global change so that <code>mypy</code> will use this no matter what directory you are in, then put this same content into <em>$HOME/.mypy.ini</em>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review" data-type="sect1"><div class="sect1" id="idm45963636039080">&#13;
<h1>Review</h1>&#13;
&#13;
<p>Manually creating the reverse complement of DNA is something of a rite of passage.&#13;
Here’s what I showed:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>You can write a decision tree using a series of <code>if</code>/<code>else</code> statements or by using a dictionary as a lookup table.</p>&#13;
</li>&#13;
<li>&#13;
<p>Strings and lists are very similar. Both can be iterated using a <code>for</code> loop, and the <code>+=</code> operator can be used to append to both.</p>&#13;
</li>&#13;
<li>&#13;
<p>A list comprehension uses a <code>for</code> loop to iterate a sequence and generate a new list.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>reversed()</code> function is a lazy function that will return an iterator of the elements of a sequence in reverse order.</p>&#13;
</li>&#13;
<li>&#13;
<p>You can use the <code>list()</code> function in the REPL to coerce lazy functions, iterators, and generators to generate their values.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>str.maketrans()</code> and <code>str.translate()</code> functions can perform string substitution and generate a new string.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>ord()</code> function returns the ordinal value of a character, and conversely, the <code>chr()</code> function returns the character for a given ordinal value.</p>&#13;
</li>&#13;
<li>&#13;
<p>Biopython is a collection of modules and functions specific to bioinformatics. The preferred way to create the reverse complement of DNA is to use the <code>Bio.Seq.reverse_complement()</code> function.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45963636070440"><sup><a href="ch03.html#idm45963636070440-marker">1</a></sup> This is kind of like how my high school calculus teacher spent a week teaching us how to perform manual derivatives, then showed us how it could be done in 20 seconds by pulling down the exponent and yada yada yada.</p></div></div></section></body></html>