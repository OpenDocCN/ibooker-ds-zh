- en: Chapter 15\. Operating on Data in Pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the strengths of NumPy is that it allows us to perform quick element-wise
    operations, both with basic arithmetic (addition, subtraction, multiplication,
    etc.) and with more complicated operations (trigonometric functions, exponential
    and logarithmic functions, etc.). Pandas inherits much of this functionality from
    NumPy, and the ufuncs introduced in [Chapter 6](ch06.xhtml#section-0203-computation-on-arrays-ufuncs)
    are key to this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pandas includes a couple of useful twists, however: for unary operations like
    negation and trigonometric functions, these ufuncs will *preserve index and column
    labels* in the output, and for binary operations such as addition and multiplication,
    Pandas will automatically *align indices* when passing the objects to the ufunc.
    This means that keeping the context of data and combining data from different
    sources—both potentially error-prone tasks with raw NumPy arrays—become essentially
    foolproof with Pandas. We will additionally see that there are well-defined operations
    between one-dimensional `Series` structures and two-dimensional `DataFrame` structures.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ufuncs: Index Preservation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because Pandas is designed to work with NumPy, any NumPy ufunc will work on
    Pandas `Series` and `DataFrame` objects. Let’s start by defining a simple `Series`
    and `DataFrame` on which to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If we apply a NumPy ufunc on either of these objects, the result will be another
    Pandas object *with the indices preserved:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is true also for more involved sequences of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Any of the ufuncs discussed in [Chapter 6](ch06.xhtml#section-0203-computation-on-arrays-ufuncs)
    can be used in a similar manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ufuncs: Index Alignment'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For binary operations on two `Series` or `DataFrame` objects, Pandas will align
    indices in the process of performing the operation. This is very convenient when
    working with incomplete data, as we’ll see in some of the examples that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Index Alignment in Series
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an example, suppose we are combining two different data sources and wish
    to find only the top three US states by *area* and the top three US states by
    *population*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see what happens when we divide these to compute the population density:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting array contains the *union* of indices of the two input arrays,
    which could be determined directly from these indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Any item for which one or the other does not have an entry is marked with `NaN`,
    or “Not a Number,” which is how Pandas marks missing data (see further discussion
    of missing data in [Chapter 16](ch16.xhtml#section-0304-missing-values)). This
    index matching is implemented this way for any of Python’s built-in arithmetic
    expressions; any missing values are marked by `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If using `NaN` values is not the desired behavior, the fill value can be modified
    using appropriate object methods in place of the operators. For example, calling
    `A.add(B)` is equivalent to calling `A + B`, but allows optional explicit specification
    of the fill value for any elements in `A` or `B` that might be missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Index Alignment in DataFrames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A similar type of alignment takes place for *both* columns and indices when
    performing operations on `DataFrame` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that indices are aligned correctly irrespective of their order in the
    two objects, and indices in the result are sorted. As was the case with `Series`,
    we can use the associated object’s arithmetic methods and pass any desired `fill_value`
    to be used in place of missing entries. Here we’ll fill with the mean of all values
    in `A`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 15-1](#table-15-1) lists Python operators and their equivalent Pandas
    object methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-1\. Mapping between Python operators and Pandas methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Python operator | Pandas method(s) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | `add` |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | `sub`, `subtract` |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | `mul`, `multiply` |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | `truediv`, `div`, `divide` |'
  prefs: []
  type: TYPE_TB
- en: '| `//` | `floordiv` |'
  prefs: []
  type: TYPE_TB
- en: '| `%` | `mod` |'
  prefs: []
  type: TYPE_TB
- en: '| `**` | `pow` |'
  prefs: []
  type: TYPE_TB
- en: 'Ufuncs: Operations Between DataFrames and Series'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When performing operations between a `DataFrame` and a `Series`, the index
    and column alignment is similarly maintained, and the result is similar to operations
    between a two-dimensional and one-dimensional NumPy array. Consider one common
    operation, where we find the difference of a two-dimensional array and one of
    its rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: According to NumPy’s broadcasting rules (see [Chapter 8](ch08.xhtml#section-0205-computation-on-arrays-broadcasting)),
    subtraction between a two-dimensional array and one of its rows is applied row-wise.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Pandas, the convention similarly operates row-wise by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you would instead like to operate column-wise, you can use the object methods
    mentioned earlier, while specifying the `axis` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that these `DataFrame`/`Series` operations, like the operations discussed
    previously, will automatically align indices between the two elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This preservation and alignment of indices and columns means that operations
    on data in Pandas will always maintain the data context, which prevents the common
    errors that might arise when working with heterogeneous and/or misaligned data
    in raw NumPy arrays.
  prefs: []
  type: TYPE_NORMAL
