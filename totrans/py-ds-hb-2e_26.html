<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 23. Working with Time Series" data-type="chapter" epub:type="chapter"><div class="chapter" id="section-0311-working-with-time-series">
<h1><span class="label">Chapter 23. </span>Working with Time Series</h1>
<p><a data-primary="Pandas" data-secondary="time series" data-type="indexterm" id="ix_ch23-asciidoc0"/><a data-primary="time series" data-secondary="Pandas" data-type="indexterm" id="ix_ch23-asciidoc1"/>Pandas was originally developed in the context of financial modeling, so
as you might expect, it contains an extensive set of tools for working
with dates, times, and time-indexed data. Date and time data comes in a
few flavors, which we will discuss here:</p>
<dl>
<dt><em>Timestamps</em></dt>
<dd>
<p>Particular moments in time (e.g., July 4,
2021 at 7:00 a.m.).</p>
</dd>
<dt><em>Time intervals</em> and <em>periods</em></dt>
<dd>
<p>A length of time between a
particular beginning and end point; for example, the month of June 2021.
Periods usually reference a special case of time intervals in which each
interval is of uniform length and does not overlap (e.g., 24-hour-long
periods comprising days).</p>
</dd>
<dt><em>Time deltas</em> or <em>durations</em></dt>
<dd>
<p>An exact length of time (e.g.,
a duration of 22.56 seconds).</p>
</dd>
</dl>
<p>This chapter will introduce how to work with each of these types of
date/time data in Pandas. This is by no means a complete guide to the
time series tools available in Python or Pandas, but instead is intended
as a broad overview of how you as a user should approach working with
time series. We will start with a brief discussion of tools for dealing
with dates and times in Python, before moving more specifically to a
discussion of the tools provided by Pandas. Finally, we will review some short examples of working
with time series data in Pandas.</p>
<section class="pagebreak-before less_space" data-pdf-bookmark="Dates and Times in Python" data-type="sect1"><div class="sect1" id="ch_0311-working-with-time-series_dates-and-times-in-python">
<h1>Dates and Times in Python</h1>
<p><a data-primary="time series" data-secondary="Python versus Pandas" data-type="indexterm" id="ix_ch23-asciidoc2"/>The Python world has a number of available representations of dates,
times, deltas, and time spans. While the time series tools provided by
Pandas tend to be the most useful for data science applications, it is
helpful to see their relationship to other tools used in Python.</p>
<section data-pdf-bookmark="Native Python Dates and Times: datetime and dateutil" data-type="sect2"><div class="sect2" id="ch_0311-working-with-time-series_native-python-dates-and-times-datetime-and-dateutil">
<h2>Native Python Dates and Times: datetime and dateutil</h2>
<p><a data-primary="datetime module" data-type="indexterm" id="idm45858768949968"/><a data-primary="dateutil module" data-type="indexterm" id="idm45858768949264"/><a data-primary="time series" data-secondary="native Python dates and times" data-type="indexterm" id="idm45858768948592"/>Python’s basic objects for working with dates and times
reside in the built-in 
<span class="keep-together"><code>datetime</code></span> module. Along with the third-party
<code>dateutil</code> module, you can use this to quickly perform a host of useful
functionalities on dates and times. For example, you can manually build
a date using the <code>datetime</code> type:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="kn">from</code> <code class="nn">datetime</code> <code class="kn">import</code> <code class="n">datetime</code>
        <code class="n">datetime</code><code class="p">(</code><code class="n">year</code><code class="o">=</code><code class="mi">2021</code><code class="p">,</code> <code class="n">month</code><code class="o">=</code><code class="mi">7</code><code class="p">,</code> <code class="n">day</code><code class="o">=</code><code class="mi">4</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="n">datetime</code><code class="o">.</code><code class="n">datetime</code><code class="p">(</code><code class="mi">2021</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code></pre>
<p>Or, using the <code>dateutil</code> module, you can parse dates from a variety of
string formats:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="kn">from</code> <code class="nn">dateutil</code> <code class="kn">import</code> <code class="n">parser</code>
        <code class="n">date</code> <code class="o">=</code> <code class="n">parser</code><code class="o">.</code><code class="n">parse</code><code class="p">(</code><code class="s2">"4th of July, 2021"</code><code class="p">)</code>
        <code class="n">date</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="n">datetime</code><code class="o">.</code><code class="n">datetime</code><code class="p">(</code><code class="mi">2021</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code></pre>
<p>Once you have a <code>datetime</code> object, you can do things like printing the
day of the week:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="n">date</code><code class="o">.</code><code class="n">strftime</code><code class="p">(</code><code class="s1">'%A'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="s1">'Sunday'</code></pre>
<p>Here we’ve used one of the standard string format codes for
printing dates (<code>'%A'</code>), which you can read
about in the
<a href="https://oreil.ly/bjdsf"><code>strftime</code>
section</a> of Python’s
<a href="https://oreil.ly/AGVR9"><code>datetime</code>
documentation</a>. Documentation of other useful date utilities can be
found in <a href="https://oreil.ly/Y5Rwd"><code>dateutil</code>’s
online documentation</a>. A related package to be aware of is
<a href="https://oreil.ly/DU9Jr"><code>pytz</code></a>, which contains tools for working
with the most migraine-inducing element of time series data: time zones.</p>
<p>The power of <code>datetime</code> and <code>dateutil</code> lies in their flexibility and
easy syntax: you can use these objects and their built-in methods to
easily perform nearly any operation you might be interested in. Where
they break down is when you wish to work with large arrays of dates and
times: just as lists of Python numerical variables are suboptimal
compared to NumPy-style typed numerical arrays, lists of Python
<code>datetime</code> objects are suboptimal compared to typed arrays of encoded
dates.</p>
</div></section>
<section class="pagebreak-before less_space" data-pdf-bookmark="Typed Arrays of Times: NumPy’s datetime64" data-type="sect2"><div class="sect2" id="ch_0311-working-with-time-series_typed-arrays-of-times-numpys-datetime64">
<h2>Typed Arrays of Times: NumPy’s datetime64</h2>
<p><a data-primary="datetime64 dtype" data-type="indexterm" id="ix_ch23-asciidoc3"/><a data-primary="NumPy" data-secondary="datetime64 dtype" data-type="indexterm" id="ix_ch23-asciidoc4"/><a data-primary="time series" data-secondary="datetime64" data-type="indexterm" id="ix_ch23-asciidoc5"/><a data-primary="time series" data-secondary="typed arrays" data-type="indexterm" id="ix_ch23-asciidoc6"/>NumPy’s <code>datetime64</code> dtype encodes dates as 64-bit integers,
and thus allows arrays of dates to be represented compactly and operated
on in an efficient manner. The 
<span class="keep-together"><code>datetime64</code></span> requires a specific input
format:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>
        <code class="n">date</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">(</code><code class="s1">'2021-07-04'</code><code class="p">,</code> <code class="n">dtype</code><code class="o">=</code><code class="n">np</code><code class="o">.</code><code class="n">datetime64</code><code class="p">)</code>
        <code class="n">date</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="n">array</code><code class="p">(</code><code class="s1">'2021-07-04'</code><code class="p">,</code> <code class="n">dtype</code><code class="o">=</code><code class="s1">'datetime64[D]'</code><code class="p">)</code></pre>
<p>Once we have dates in this form, we can quickly do vectorized operations
on it:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">date</code> <code class="o">+</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">12</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="s1">'2021-07-04'</code><code class="p">,</code> <code class="s1">'2021-07-05'</code><code class="p">,</code> <code class="s1">'2021-07-06'</code><code class="p">,</code> <code class="s1">'2021-07-07'</code><code class="p">,</code>
               <code class="s1">'2021-07-08'</code><code class="p">,</code> <code class="s1">'2021-07-09'</code><code class="p">,</code> <code class="s1">'2021-07-10'</code><code class="p">,</code> <code class="s1">'2021-07-11'</code><code class="p">,</code>
               <code class="s1">'2021-07-12'</code><code class="p">,</code> <code class="s1">'2021-07-13'</code><code class="p">,</code> <code class="s1">'2021-07-14'</code><code class="p">,</code> <code class="s1">'2021-07-15'</code><code class="p">],</code>
              <code class="n">dtype</code><code class="o">=</code><code class="s1">'datetime64[D]'</code><code class="p">)</code></pre>
<p>Because of the uniform type in NumPy <code>datetime64</code> arrays, this kind of
operation can be accomplished much more quickly than if we were working
directly with Python’s <code>datetime</code> objects, especially as
arrays get large (we introduced this type of vectorization in
<a data-type="xref" href="ch06.xhtml#section-0203-computation-on-arrays-ufuncs">Chapter 6</a>).</p>
<p>One detail of the <code>datetime64</code> and related <code>timedelta64</code> objects is that
they are built on a <em>fundamental time unit</em>. Because the <code>datetime64</code>
object is limited to 64-bit precision, the range of encodable times is
<math alttext="2 Superscript 64">
<msup><mn>2</mn> <mn>64</mn> </msup>
</math> times this fundamental unit. In other words,

<span class="keep-together"><code>datetime64</code></span> imposes a trade-off between <em>time resolution</em> and <em>maximum time span</em>.</p>
<p>For example, if you want a time resolution of 1 nanosecond, you only
have enough information to encode a range of <math alttext="2 Superscript 64">
<msup><mn>2</mn> <mn>64</mn> </msup>
</math>
nanoseconds, or just under 600 years. NumPy will infer the desired unit
from the input; for example, here is a day-based <code>datetime</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">datetime64</code><code class="p">(</code><code class="s1">'2021-07-04'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">numpy</code><code class="o">.</code><code class="n">datetime64</code><code class="p">(</code><code class="s1">'2021-07-04'</code><code class="p">)</code></pre>
<p>Here is a minute-based datetime:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">datetime64</code><code class="p">(</code><code class="s1">'2021-07-04 12:00'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">numpy</code><code class="o">.</code><code class="n">datetime64</code><code class="p">(</code><code class="s1">'2021-07-04T12:00'</code><code class="p">)</code></pre>
<p>You can force any desired fundamental unit using one of many format
codes; for example, here we’ll force a nanosecond-based
time:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">datetime64</code><code class="p">(</code><code class="s1">'2021-07-04 12:59:59.50'</code><code class="p">,</code> <code class="s1">'ns'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">numpy</code><code class="o">.</code><code class="n">datetime64</code><code class="p">(</code><code class="s1">'2021-07-04T12:59:59.500000000'</code><code class="p">)</code></pre>
<p><a data-type="xref" href="#table-23-1">Table 23-1</a>, drawn from the NumPy <code>datetime64</code> documentation,
lists the available format codes along with the relative and absolute
time spans that they can encode.</p>
<table id="table-23-1">
<caption><span class="label">Table 23-1. </span>Description of date and time codes</caption>
<thead>
<tr>
<th>Code</th>
<th>Meaning</th>
<th>Time span (relative)</th>
<th>Time span (absolute)</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>Y</code></p></td>
<td><p>Year</p></td>
<td><p>± 9.2e18 years</p></td>
<td><p>[9.2e18 BC, 9.2e18 AD]</p></td>
</tr>
<tr>
<td><p><code>M</code></p></td>
<td><p>Month</p></td>
<td><p>± 7.6e17 years</p></td>
<td><p>[7.6e17 BC, 7.6e17 AD]</p></td>
</tr>
<tr>
<td><p><code>W</code></p></td>
<td><p>Week</p></td>
<td><p>± 1.7e17 years</p></td>
<td><p>[1.7e17 BC, 1.7e17 AD]</p></td>
</tr>
<tr>
<td><p><code>D</code></p></td>
<td><p>Day</p></td>
<td><p>± 2.5e16 years</p></td>
<td><p>[2.5e16 BC, 2.5e16 AD]</p></td>
</tr>
<tr>
<td><p><code>h</code></p></td>
<td><p>Hour</p></td>
<td><p>± 1.0e15 years</p></td>
<td><p>[1.0e15 BC, 1.0e15 AD]</p></td>
</tr>
<tr>
<td><p><code>m</code></p></td>
<td><p>Minute</p></td>
<td><p>± 1.7e13 years</p></td>
<td><p>[1.7e13 BC, 1.7e13 AD]</p></td>
</tr>
<tr>
<td><p><code>s</code></p></td>
<td><p>Second</p></td>
<td><p>± 2.9e12 years</p></td>
<td><p>[ 2.9e9 BC, 2.9e9 AD]</p></td>
</tr>
<tr>
<td><p><code>ms</code></p></td>
<td><p>Millisecond</p></td>
<td><p>± 2.9e9 years</p></td>
<td><p>[ 2.9e6 BC, 2.9e6 AD]</p></td>
</tr>
<tr>
<td><p><code>us</code></p></td>
<td><p>Microsecond</p></td>
<td><p>± 2.9e6 years</p></td>
<td><p>[290301 BC, 294241 AD]</p></td>
</tr>
<tr>
<td><p><code>ns</code></p></td>
<td><p>Nanosecond</p></td>
<td><p>± 292 years</p></td>
<td><p>[ 1678 AD, 2262 AD]</p></td>
</tr>
<tr>
<td><p><code>ps</code></p></td>
<td><p>Picosecond</p></td>
<td><p>± 106 days</p></td>
<td><p>[ 1969 AD, 1970 AD]</p></td>
</tr>
<tr>
<td><p><code>fs</code></p></td>
<td><p>Femtosecond</p></td>
<td><p>± 2.6 hours</p></td>
<td><p>[ 1969 AD, 1970 AD]</p></td>
</tr>
<tr>
<td><p><code>as</code></p></td>
<td><p>Attosecond</p></td>
<td><p>± 9.2 seconds</p></td>
<td><p>[ 1969 AD, 1970 AD]</p></td>
</tr>
</tbody>
</table>
<p>For the types of data we see in the real world, a useful default is
<code>datetime64[ns]</code>, as it can encode a useful range of modern dates with a
suitably fine precision.</p>
<p>Finally, note that while the <code>datetime64</code> data type addresses some of
the deficiencies of the built-in Python <code>datetime</code> type, it lacks many
of the convenient methods and functions provided by <code>datetime</code> and
especially <code>dateutil</code>. More information can be found in
<a href="https://oreil.ly/XDbck">NumPy’s
<code>datetime64</code> documentation</a>.<a data-startref="ix_ch23-asciidoc6" data-type="indexterm" id="idm45858768383984"/><a data-startref="ix_ch23-asciidoc5" data-type="indexterm" id="idm45858768383248"/><a data-startref="ix_ch23-asciidoc4" data-type="indexterm" id="idm45858768382576"/><a data-startref="ix_ch23-asciidoc3" data-type="indexterm" id="idm45858768381904"/></p>
</div></section>
<section data-pdf-bookmark="Dates and Times in Pandas: The Best of Both Worlds" data-type="sect2"><div class="sect2" id="ch_0311-working-with-time-series_dates-and-times-in-pandas-the-best-of-both-worlds">
<h2>Dates and Times in Pandas: The Best of Both Worlds</h2>
<p><a data-primary="time series" data-secondary="dates and times in Pandas" data-type="indexterm" id="idm45858768379872"/>Pandas builds upon all the tools just discussed to provide a <code>Timestamp</code>
object, which combines the ease of use of <code>datetime</code> and <code>dateutil</code> with
the efficient storage and vectorized interface of <code>numpy.datetime64</code>.
From a group of these <code>Timestamp</code> objects, Pandas can construct a
<code>DatetimeIndex</code> that can be used to index data in a <code>Series</code> or
<code>DataFrame</code>.</p>
<p>For example, we can use Pandas tools to repeat the demonstration from
earlier. We can parse a flexibly formatted string date and use format
codes to output the day of the week, as follows:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>
        <code class="n">date</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">to_datetime</code><code class="p">(</code><code class="s2">"4th of July, 2021"</code><code class="p">)</code>
        <code class="n">date</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">Timestamp</code><code class="p">(</code><code class="s1">'2021-07-04 00:00:00'</code><code class="p">)</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">date</code><code class="o">.</code><code class="n">strftime</code><code class="p">(</code><code class="s1">'%A'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="s1">'Sunday'</code></pre>
<p>Additionally, we can do NumPy-style vectorized operations directly on
this same object:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">date</code> <code class="o">+</code> <code class="n">pd</code><code class="o">.</code><code class="n">to_timedelta</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">12</code><code class="p">),</code> <code class="s1">'D'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">DatetimeIndex</code><code class="p">([</code><code class="s1">'2021-07-04'</code><code class="p">,</code> <code class="s1">'2021-07-05'</code><code class="p">,</code> <code class="s1">'2021-07-06'</code><code class="p">,</code> <code class="s1">'2021-07-07'</code><code class="p">,</code>
                        <code class="s1">'2021-07-08'</code><code class="p">,</code> <code class="s1">'2021-07-09'</code><code class="p">,</code> <code class="s1">'2021-07-10'</code><code class="p">,</code> <code class="s1">'2021-07-11'</code><code class="p">,</code>
                        <code class="s1">'2021-07-12'</code><code class="p">,</code> <code class="s1">'2021-07-13'</code><code class="p">,</code> <code class="s1">'2021-07-14'</code><code class="p">,</code> <code class="s1">'2021-07-15'</code><code class="p">],</code>
                       <code class="n">dtype</code><code class="o">=</code><code class="s1">'datetime64[ns]'</code><code class="p">,</code> <code class="n">freq</code><code class="o">=</code><code class="kc">None</code><code class="p">)</code></pre>
<p>In the next section, we will take a closer look at manipulating time
series data with the tools provided by Pandas.<a data-startref="ix_ch23-asciidoc2" data-type="indexterm" id="idm45858768195200"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Pandas Time Series: Indexing by Time" data-type="sect1"><div class="sect1" id="ch_0311-working-with-time-series_pandas-time-series-indexing-by-time">
<h1>Pandas Time Series: Indexing by Time</h1>
<p><a data-primary="time series" data-secondary="indexing data by timestamps" data-type="indexterm" id="idm45858768232528"/><a data-primary="timestamps, indexing data by" data-type="indexterm" id="idm45858768231584"/>The Pandas time series tools really become useful when you begin to
index data by timestamps. For example, we can construct a <code>Series</code>
object that has time-indexed data:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="n">index</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DatetimeIndex</code><code class="p">([</code><code class="s1">'2020-07-04'</code><code class="p">,</code> <code class="s1">'2020-08-04'</code><code class="p">,</code>
                                   <code class="s1">'2021-07-04'</code><code class="p">,</code> <code class="s1">'2021-08-04'</code><code class="p">])</code>
         <code class="n">data</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">([</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code> <code class="n">index</code><code class="o">=</code><code class="n">index</code><code class="p">)</code>
         <code class="n">data</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="mi">2020</code><code class="o">-</code><code class="mi">07</code><code class="o">-</code><code class="mi">04</code>    <code class="mi">0</code>
         <code class="mi">2020</code><code class="o">-</code><code class="mi">08</code><code class="o">-</code><code class="mi">04</code>    <code class="mi">1</code>
         <code class="mi">2021</code><code class="o">-</code><code class="mi">07</code><code class="o">-</code><code class="mi">04</code>    <code class="mi">2</code>
         <code class="mi">2021</code><code class="o">-</code><code class="mi">08</code><code class="o">-</code><code class="mi">04</code>    <code class="mi">3</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>And now that we have this data in a <code>Series</code>, we can make use of any of
the <code>Series</code> indexing patterns we discussed in previous chapters,
passing values that can be coerced into dates:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="n">data</code><code class="p">[</code><code class="s1">'2020-07-04'</code><code class="p">:</code><code class="s1">'2021-07-04'</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="mi">2020</code><code class="o">-</code><code class="mi">07</code><code class="o">-</code><code class="mi">04</code>    <code class="mi">0</code>
         <code class="mi">2020</code><code class="o">-</code><code class="mi">08</code><code class="o">-</code><code class="mi">04</code>    <code class="mi">1</code>
         <code class="mi">2021</code><code class="o">-</code><code class="mi">07</code><code class="o">-</code><code class="mi">04</code>    <code class="mi">2</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>There are additional special date-only indexing operations, such as
passing a year to obtain a slice of all data from that year:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="n">data</code><code class="p">[</code><code class="s1">'2021'</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="mi">2021</code><code class="o">-</code><code class="mi">07</code><code class="o">-</code><code class="mi">04</code>    <code class="mi">2</code>
         <code class="mi">2021</code><code class="o">-</code><code class="mi">08</code><code class="o">-</code><code class="mi">04</code>    <code class="mi">3</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>Later, we will see additional examples of the convenience of
dates-as-indices. But first, let’s take a closer look at the
available time series data structures.</p>
</div></section>
<section data-pdf-bookmark="Pandas Time Series Data Structures" data-type="sect1"><div class="sect1" id="ch_0311-working-with-time-series_pandas-time-series-data-structures">
<h1>Pandas Time Series Data Structures</h1>
<p><a data-primary="time series" data-secondary="Pandas data structures for" data-type="indexterm" id="idm45858767989968"/>This section will introduce the fundamental Pandas data structures for
working with time series data:</p>
<ul>
<li>
<p><a data-primary="Timestamp type" data-type="indexterm" id="idm45858767987888"/>For <em>timestamps</em>, Pandas provides the <code>Timestamp</code> type. As mentioned
before, this is essentially a replacement for Python’s
native <code>datetime</code>, but it’s based on the more efficient
<code>numpy.datetime64</code> data type. The associated <code>Index</code> structure is
<code>DatetimeIndex</code>.</p>
</li>
<li>
<p><a data-primary="Period type" data-type="indexterm" id="idm45858767983632"/>For <em>time periods</em>, Pandas provides the <code>Period</code> type. This encodes a
fixed-frequency interval based on <code>numpy.datetime64</code>. The associated
index structure is <code>PeriodIndex</code>.</p>
</li>
<li>
<p><a data-primary="Timedelta type" data-type="indexterm" id="idm45858767980336"/>For <em>time deltas</em> or <em>durations</em>, Pandas provides the <code>Timedelta</code>
type. <code>Timedelta</code> is a more efficient replacement for
Python’s native <code>datetime.timedelta</code> type, and is based on
<code>numpy.timedelta64</code>. The associated index structure is <code>TimedeltaIndex</code>.</p>
</li>
</ul>
<p>The most fundamental of these date/time objects are the <code>Timestamp</code> and
<code>Datetime​In⁠dex</code> objects. While these class objects can be invoked
directly, it is more common to use the <code>pd.to_datetime</code> function, which
can parse a wide variety of formats. Passing a single date to
<code>pd.to_datetime</code> yields a <code>Timestamp</code>; passing a series of dates by
default yields a <code>DatetimeIndex</code>, as you can see here:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="n">dates</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">to_datetime</code><code class="p">([</code><code class="n">datetime</code><code class="p">(</code><code class="mi">2021</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">3</code><code class="p">),</code> <code class="s1">'4th of July, 2021'</code><code class="p">,</code>
                                <code class="s1">'2021-Jul-6'</code><code class="p">,</code> <code class="s1">'07-07-2021'</code><code class="p">,</code> <code class="s1">'20210708'</code><code class="p">])</code>
         <code class="n">dates</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="n">DatetimeIndex</code><code class="p">([</code><code class="s1">'2021-07-03'</code><code class="p">,</code> <code class="s1">'2021-07-04'</code><code class="p">,</code> <code class="s1">'2021-07-06'</code><code class="p">,</code> <code class="s1">'2021-07-07'</code><code class="p">,</code>
                        <code class="s1">'2021-07-08'</code><code class="p">],</code>
                       <code class="n">dtype</code><code class="o">=</code><code class="s1">'datetime64[ns]'</code><code class="p">,</code> <code class="n">freq</code><code class="o">=</code><code class="kc">None</code><code class="p">)</code></pre>
<p>Any <code>DatetimeIndex</code> can be converted to a <code>PeriodIndex</code> with the
<code>to_period</code> function, with the addition of a frequency code; here
we’ll use <code>'D'</code> to indicate daily
frequency:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="n">dates</code><code class="o">.</code><code class="n">to_period</code><code class="p">(</code><code class="s1">'D'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="n">PeriodIndex</code><code class="p">([</code><code class="s1">'2021-07-03'</code><code class="p">,</code> <code class="s1">'2021-07-04'</code><code class="p">,</code> <code class="s1">'2021-07-06'</code><code class="p">,</code> <code class="s1">'2021-07-07'</code><code class="p">,</code>
                      <code class="s1">'2021-07-08'</code><code class="p">],</code>
                     <code class="n">dtype</code><code class="o">=</code><code class="s1">'period[D]'</code><code class="p">)</code></pre>
<p>A <code>TimedeltaIndex</code> is created, for example, when a date is subtracted
from another:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="n">dates</code> <code class="o">-</code> <code class="n">dates</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="n">TimedeltaIndex</code><code class="p">([</code><code class="s1">'0 days'</code><code class="p">,</code> <code class="s1">'1 days'</code><code class="p">,</code> <code class="s1">'3 days'</code><code class="p">,</code> <code class="s1">'4 days'</code><code class="p">,</code> <code class="s1">'5 days'</code><code class="p">],</code>
          <code class="o">&gt;</code> <code class="n">dtype</code><code class="o">=</code><code class="s1">'timedelta64[ns]'</code><code class="p">,</code> <code class="n">freq</code><code class="o">=</code><code class="kc">None</code><code class="p">)</code></pre>
</div></section>
<section data-pdf-bookmark="Regular Sequences: pd.date_range" data-type="sect1"><div class="sect1" id="ch_0311-working-with-time-series_regular-sequences-pd.date_range">
<h1>Regular Sequences: pd.date_range</h1>
<p><a data-primary="pd.date_range() function" data-type="indexterm" id="idm45858767766720"/><a data-primary="time series" data-secondary="pd.date_range()" data-type="indexterm" id="idm45858767765888"/>To make creation of regular date sequences more convenient, Pandas
offers a few functions for this purpose: <code>pd.date_range</code> for timestamps,
<code>pd.period_range</code> for periods, and <code>pd.timedelta_range</code> for time deltas.
We’ve seen that Python’s <code>range</code> and
NumPy’s <code>np.arange</code> take a start point, end point, and
optional step size and return a sequence. Similarly, <code>pd.date_range</code>
accepts a start date, an end date, and an optional frequency code to
create a regular sequence of dates:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">18</code><code class="p">]:</code> <code class="n">pd</code><code class="o">.</code><code class="n">date_range</code><code class="p">(</code><code class="s1">'2015-07-03'</code><code class="p">,</code> <code class="s1">'2015-07-10'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">18</code><code class="p">]:</code> <code class="n">DatetimeIndex</code><code class="p">([</code><code class="s1">'2015-07-03'</code><code class="p">,</code> <code class="s1">'2015-07-04'</code><code class="p">,</code> <code class="s1">'2015-07-05'</code><code class="p">,</code> <code class="s1">'2015-07-06'</code><code class="p">,</code>
                        <code class="s1">'2015-07-07'</code><code class="p">,</code> <code class="s1">'2015-07-08'</code><code class="p">,</code> <code class="s1">'2015-07-09'</code><code class="p">,</code> <code class="s1">'2015-07-10'</code><code class="p">],</code>
                       <code class="n">dtype</code><code class="o">=</code><code class="s1">'datetime64[ns]'</code><code class="p">,</code> <code class="n">freq</code><code class="o">=</code><code class="s1">'D'</code><code class="p">)</code></pre>
<p>Alternatively, the date range can be specified not with a start and end
point, but with a start point and a number of periods:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">19</code><code class="p">]:</code> <code class="n">pd</code><code class="o">.</code><code class="n">date_range</code><code class="p">(</code><code class="s1">'2015-07-03'</code><code class="p">,</code> <code class="n">periods</code><code class="o">=</code><code class="mi">8</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">19</code><code class="p">]:</code> <code class="n">DatetimeIndex</code><code class="p">([</code><code class="s1">'2015-07-03'</code><code class="p">,</code> <code class="s1">'2015-07-04'</code><code class="p">,</code> <code class="s1">'2015-07-05'</code><code class="p">,</code> <code class="s1">'2015-07-06'</code><code class="p">,</code>
                        <code class="s1">'2015-07-07'</code><code class="p">,</code> <code class="s1">'2015-07-08'</code><code class="p">,</code> <code class="s1">'2015-07-09'</code><code class="p">,</code> <code class="s1">'2015-07-10'</code><code class="p">],</code>
                       <code class="n">dtype</code><code class="o">=</code><code class="s1">'datetime64[ns]'</code><code class="p">,</code> <code class="n">freq</code><code class="o">=</code><code class="s1">'D'</code><code class="p">)</code></pre>
<p>The spacing can be modified by altering the <code>freq</code> argument, which
defaults to <code>D</code>. For example, here we construct a range of hourly
timestamps:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">20</code><code class="p">]:</code> <code class="n">pd</code><code class="o">.</code><code class="n">date_range</code><code class="p">(</code><code class="s1">'2015-07-03'</code><code class="p">,</code> <code class="n">periods</code><code class="o">=</code><code class="mi">8</code><code class="p">,</code> <code class="n">freq</code><code class="o">=</code><code class="s1">'H'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">20</code><code class="p">]:</code> <code class="n">DatetimeIndex</code><code class="p">([</code><code class="s1">'2015-07-03 00:00:00'</code><code class="p">,</code> <code class="s1">'2015-07-03 01:00:00'</code><code class="p">,</code>
                        <code class="s1">'2015-07-03 02:00:00'</code><code class="p">,</code> <code class="s1">'2015-07-03 03:00:00'</code><code class="p">,</code>
                        <code class="s1">'2015-07-03 04:00:00'</code><code class="p">,</code> <code class="s1">'2015-07-03 05:00:00'</code><code class="p">,</code>
                        <code class="s1">'2015-07-03 06:00:00'</code><code class="p">,</code> <code class="s1">'2015-07-03 07:00:00'</code><code class="p">],</code>
                       <code class="n">dtype</code><code class="o">=</code><code class="s1">'datetime64[ns]'</code><code class="p">,</code> <code class="n">freq</code><code class="o">=</code><code class="s1">'H'</code><code class="p">)</code></pre>
<p>To create regular sequences of <code>Period</code> or <code>Timedelta</code> values, the
similar <code>pd.period_range</code> and <code>pd.timedelta_range</code> functions are useful.
Here are some monthly periods:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">21</code><code class="p">]:</code> <code class="n">pd</code><code class="o">.</code><code class="n">period_range</code><code class="p">(</code><code class="s1">'2015-07'</code><code class="p">,</code> <code class="n">periods</code><code class="o">=</code><code class="mi">8</code><code class="p">,</code> <code class="n">freq</code><code class="o">=</code><code class="s1">'M'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">21</code><code class="p">]:</code> <code class="n">PeriodIndex</code><code class="p">([</code><code class="s1">'2015-07'</code><code class="p">,</code> <code class="s1">'2015-08'</code><code class="p">,</code> <code class="s1">'2015-09'</code><code class="p">,</code>
                      <code class="s1">'2015-10'</code><code class="p">,</code> <code class="s1">'2015-11'</code><code class="p">,</code> <code class="s1">'2015-12'</code><code class="p">,</code>
                      <code class="s1">'2016-01'</code><code class="p">,</code> <code class="s1">'2016-02'</code><code class="p">],</code>
                     <code class="n">dtype</code><code class="o">=</code><code class="s1">'period[M]'</code><code class="p">)</code></pre>
<p>And a sequence of durations increasing by an hour:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">22</code><code class="p">]:</code> <code class="n">pd</code><code class="o">.</code><code class="n">timedelta_range</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="n">periods</code><code class="o">=</code><code class="mi">6</code><code class="p">,</code> <code class="n">freq</code><code class="o">=</code><code class="s1">'H'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">22</code><code class="p">]:</code> <code class="n">TimedeltaIndex</code><code class="p">([</code><code class="s1">'0 days 00:00:00'</code><code class="p">,</code> <code class="s1">'0 days 01:00:00'</code><code class="p">,</code> <code class="s1">'0 days 02:00:00'</code><code class="p">,</code>
                         <code class="s1">'0 days 03:00:00'</code><code class="p">,</code> <code class="s1">'0 days 04:00:00'</code><code class="p">,</code> <code class="s1">'0 days 05:00:00'</code><code class="p">],</code>
                        <code class="n">dtype</code><code class="o">=</code><code class="s1">'timedelta64[ns]'</code><code class="p">,</code> <code class="n">freq</code><code class="o">=</code><code class="s1">'H'</code><code class="p">)</code></pre>
<p>All of these require an understanding of Pandas frequency codes, which
are summarized in the next section.</p>
</div></section>
<section data-pdf-bookmark="Frequencies and Offsets" data-type="sect1"><div class="sect1" id="ch_0311-working-with-time-series_frequencies-and-offsets">
<h1>Frequencies and Offsets</h1>
<p><a data-primary="offsets, time series" data-type="indexterm" id="ix_ch23-asciidoc7"/><a data-primary="time series" data-secondary="frequency codes" data-type="indexterm" id="ix_ch23-asciidoc8"/><a data-primary="time series" data-secondary="offsets" data-type="indexterm" id="ix_ch23-asciidoc9"/>Fundamental to these Pandas time series tools is the concept of a
<em>frequency</em> or <em>date offset</em>. The following table summarizes the main
codes available; as with the <code>D</code> (day) and <code>H</code> (hour) codes demonstrated
in the previous sections, we can use these to specify any desired
frequency spacing. <a data-type="xref" href="#table-23-2">Table 23-2</a> summarizes the main codes available.</p>
<table id="table-23-2">
<caption><span class="label">Table 23-2. </span>Listing of Pandas frequency codes</caption>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>D</code></p></td>
<td><p>Calendar day</p></td>
<td><p><code>B</code></p></td>
<td><p>Business day</p></td>
</tr>
<tr>
<td><p><code>W</code></p></td>
<td><p>Weekly</p></td>
<td/>
<td/>
</tr>
<tr>
<td><p><code>M</code></p></td>
<td><p>Month end</p></td>
<td><p><code>BM</code></p></td>
<td><p>Business month end</p></td>
</tr>
<tr>
<td><p><code>Q</code></p></td>
<td><p>Quarter end</p></td>
<td><p><code>BQ</code></p></td>
<td><p>Business quarter end</p></td>
</tr>
<tr>
<td><p><code>A</code></p></td>
<td><p>Year end</p></td>
<td><p><code>BA</code></p></td>
<td><p>Business year end</p></td>
</tr>
<tr>
<td><p><code>H</code></p></td>
<td><p>Hours</p></td>
<td><p><code>BH</code></p></td>
<td><p>Business hours</p></td>
</tr>
<tr>
<td><p><code>T</code></p></td>
<td><p>Minutes</p></td>
<td/>
<td/>
</tr>
<tr>
<td><p><code>S</code></p></td>
<td><p>Seconds</p></td>
<td/>
<td/>
</tr>
<tr>
<td><p><code>L</code></p></td>
<td><p>Milliseconds</p></td>
<td/>
<td/>
</tr>
<tr>
<td><p><code>U</code></p></td>
<td><p>Microseconds</p></td>
<td/>
<td/>
</tr>
<tr>
<td><p><code>N</code></p></td>
<td><p>Nanoseconds</p></td>
<td/>
<td/>
</tr>
</tbody>
</table>
<p>The monthly, quarterly, and annual frequencies are all marked at the end
of the specified period. Adding an <code>S</code> suffix to any of these causes
them to instead be marked at the beginning (see <a data-type="xref" href="#table-23-3">Table 23-3</a>).</p>
<table id="table-23-3">
<caption><span class="label">Table 23-3. </span>Listing of start-indexed frequency codes</caption>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>MS</code></p></td>
<td><p>Month start</p></td>
<td><p><code>BMS</code></p></td>
<td><p>Business month start</p></td>
</tr>
<tr>
<td><p><code>QS</code></p></td>
<td><p>Quarter start</p></td>
<td><p><code>BQS</code></p></td>
<td><p>Business quarter start</p></td>
</tr>
<tr>
<td><p><code>AS</code></p></td>
<td><p>Year start</p></td>
<td><p><code>BAS</code></p></td>
<td><p>Business year start</p></td>
</tr>
</tbody>
</table>
<p>Additionally, you can change the month used to mark any quarterly or
annual code by adding a three-letter month code as a suffix:</p>
<ul>
<li>
<p><code>Q-JAN</code>, <code>BQ-FEB</code>, <code>QS-MAR</code>, <code>BQS-APR</code>, etc.</p>
</li>
<li>
<p><code>A-JAN</code>, <code>BA-FEB</code>, <code>AS-MAR</code>, <code>BAS-APR</code>, etc.</p>
</li>
</ul>
<p>In the same way, the split point of the weekly frequency can be modified
by adding a three-letter weekday code: <code>W-SUN</code>, <code>W-MON</code>, <code>W-TUE</code>, <code>W-WED</code>, etc.</p>
<p>On top of this, codes can be combined with numbers to specify other
frequencies. For example, for a frequency of 2 hours and 30 minutes, we
can combine the hour (<code>H</code>) and minute (<code>T</code>) codes as follows:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">23</code><code class="p">]:</code> <code class="n">pd</code><code class="o">.</code><code class="n">timedelta_range</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="n">periods</code><code class="o">=</code><code class="mi">6</code><code class="p">,</code> <code class="n">freq</code><code class="o">=</code><code class="s2">"2H30T"</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">23</code><code class="p">]:</code> <code class="n">TimedeltaIndex</code><code class="p">([</code><code class="s1">'0 days 00:00:00'</code><code class="p">,</code> <code class="s1">'0 days 02:30:00'</code><code class="p">,</code> <code class="s1">'0 days 05:00:00'</code><code class="p">,</code>
                         <code class="s1">'0 days 07:30:00'</code><code class="p">,</code> <code class="s1">'0 days 10:00:00'</code><code class="p">,</code> <code class="s1">'0 days 12:30:00'</code><code class="p">],</code>
                        <code class="n">dtype</code><code class="o">=</code><code class="s1">'timedelta64[ns]'</code><code class="p">,</code> <code class="n">freq</code><code class="o">=</code><code class="s1">'150T'</code><code class="p">)</code></pre>
<p>All of these short codes refer to specific instances of Pandas time
series offsets, which can be found in the <code>pd.tseries.offsets</code> module.
For example, we can create a business day offset directly as follows:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">24</code><code class="p">]:</code> <code class="kn">from</code> <code class="nn">pandas.tseries.offsets</code> <code class="kn">import</code> <code class="n">BDay</code>
         <code class="n">pd</code><code class="o">.</code><code class="n">date_range</code><code class="p">(</code><code class="s1">'2015-07-01'</code><code class="p">,</code> <code class="n">periods</code><code class="o">=</code><code class="mi">6</code><code class="p">,</code> <code class="n">freq</code><code class="o">=</code><code class="n">BDay</code><code class="p">())</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">24</code><code class="p">]:</code> <code class="n">DatetimeIndex</code><code class="p">([</code><code class="s1">'2015-07-01'</code><code class="p">,</code> <code class="s1">'2015-07-02'</code><code class="p">,</code> <code class="s1">'2015-07-03'</code><code class="p">,</code> <code class="s1">'2015-07-06'</code><code class="p">,</code>
                        <code class="s1">'2015-07-07'</code><code class="p">,</code> <code class="s1">'2015-07-08'</code><code class="p">],</code>
                       <code class="n">dtype</code><code class="o">=</code><code class="s1">'datetime64[ns]'</code><code class="p">,</code> <code class="n">freq</code><code class="o">=</code><code class="s1">'B'</code><code class="p">)</code></pre>
<p>For more discussion of the use of frequencies and offsets, see the
<a href="https://oreil.ly/J6JHA"><code>DateOffset</code>
section</a> of the Pandas documentation.<a data-startref="ix_ch23-asciidoc9" data-type="indexterm" id="idm45858767172112"/><a data-startref="ix_ch23-asciidoc8" data-type="indexterm" id="idm45858767171504"/><a data-startref="ix_ch23-asciidoc7" data-type="indexterm" id="idm45858767170832"/></p>
</div></section>
<section data-pdf-bookmark="Resampling, Shifting, and Windowing" data-type="sect1"><div class="sect1" id="ch_0311-working-with-time-series_resampling-shifting-and-windowing">
<h1>Resampling, Shifting, and Windowing</h1>
<p>The ability to use dates and times as indices to intuitively organize
and access data is an important aspect of the Pandas time series tools.
The benefits of indexed data in general (automatic alignment during
operations, intuitive data slicing and access, etc.) still apply, and
Pandas provides several additional time series–specific 
<span class="keep-together">operations</span>.</p>
<p>We will take a look at a few of those here, using some stock price data
as an example. Because Pandas was developed largely in a finance
context, it includes some very specific tools for financial data. For
example, the accompanying <code>pandas-datareader</code> package (installable via
<code>pip install pandas-datareader</code>) knows how to import data from various
online sources. Here we will load part of the S&amp;P 500 price history:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">25</code><code class="p">]:</code> <code class="kn">from</code> <code class="nn">pandas_datareader</code> <code class="kn">import</code> <code class="n">data</code>

         <code class="n">sp500</code> <code class="o">=</code> <code class="n">data</code><code class="o">.</code><code class="n">DataReader</code><code class="p">(</code><code class="s1">'^GSPC'</code><code class="p">,</code> <code class="n">start</code><code class="o">=</code><code class="s1">'2018'</code><code class="p">,</code> <code class="n">end</code><code class="o">=</code><code class="s1">'2022'</code><code class="p">,</code>
                                 <code class="n">data_source</code><code class="o">=</code><code class="s1">'yahoo'</code><code class="p">)</code>
         <code class="n">sp500</code><code class="o">.</code><code class="n">head</code><code class="p">()</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">25</code><code class="p">]:</code>                    <code class="n">High</code>          <code class="n">Low</code>         <code class="n">Open</code>        <code class="n">Close</code>      <code class="n">Volume</code> \
         <code class="n">Date</code>
         <code class="mi">2018</code><code class="o">-</code><code class="mi">01</code><code class="o">-</code><code class="mi">02</code>  <code class="mf">2695.889893</code>  <code class="mf">2682.360107</code>  <code class="mf">2683.729980</code>  <code class="mf">2695.810059</code>  <code class="mi">3367250000</code>
         <code class="mi">2018</code><code class="o">-</code><code class="mi">01</code><code class="o">-</code><code class="mi">03</code>  <code class="mf">2714.370117</code>  <code class="mf">2697.770020</code>  <code class="mf">2697.850098</code>  <code class="mf">2713.060059</code>  <code class="mi">3538660000</code>
         <code class="mi">2018</code><code class="o">-</code><code class="mi">01</code><code class="o">-</code><code class="mi">04</code>  <code class="mf">2729.290039</code>  <code class="mf">2719.070068</code>  <code class="mf">2719.310059</code>  <code class="mf">2723.989990</code>  <code class="mi">3695260000</code>
         <code class="mi">2018</code><code class="o">-</code><code class="mi">01</code><code class="o">-</code><code class="mi">05</code>  <code class="mf">2743.449951</code>  <code class="mf">2727.919922</code>  <code class="mf">2731.330078</code>  <code class="mf">2743.149902</code>  <code class="mi">3236620000</code>
         <code class="mi">2018</code><code class="o">-</code><code class="mi">01</code><code class="o">-</code><code class="mi">08</code>  <code class="mf">2748.510010</code>  <code class="mf">2737.600098</code>  <code class="mf">2742.669922</code>  <code class="mf">2747.709961</code>  <code class="mi">3242650000</code>


                       <code class="n">Adj</code> <code class="n">Close</code>
         <code class="n">Date</code>
         <code class="mi">2018</code><code class="o">-</code><code class="mi">01</code><code class="o">-</code><code class="mi">02</code>  <code class="mf">2695.810059</code>
         <code class="mi">2018</code><code class="o">-</code><code class="mi">01</code><code class="o">-</code><code class="mi">03</code>  <code class="mf">2713.060059</code>
         <code class="mi">2018</code><code class="o">-</code><code class="mi">01</code><code class="o">-</code><code class="mi">04</code>  <code class="mf">2723.989990</code>
         <code class="mi">2018</code><code class="o">-</code><code class="mi">01</code><code class="o">-</code><code class="mi">05</code>  <code class="mf">2743.149902</code>
         <code class="mi">2018</code><code class="o">-</code><code class="mi">01</code><code class="o">-</code><code class="mi">08</code>  <code class="mf">2747.709961</code></pre>
<p>For simplicity, we’ll use just the closing price:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">26</code><code class="p">]:</code> <code class="n">sp500</code> <code class="o">=</code> <code class="n">sp500</code><code class="p">[</code><code class="s1">'Close'</code><code class="p">]</code></pre>
<p>We can visualize this using the <code>plot</code> method, after the normal
Matplotlib setup boilerplate (see
<a data-type="xref" href="part04.xhtml#section-0400-introduction-to-matplotlib">Part IV</a>); the result is
shown in <a data-type="xref" href="#fig_0311-working-with-time-series_files_in_output_68_0">Figure 23-1</a>.</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">27</code><code class="p">]:</code> <code class="o">%</code><code class="k">matplotlib</code> inline
         <code class="kn">import</code> <code class="nn">matplotlib.pyplot</code> <code class="k">as</code> <code class="nn">plt</code>
         <code class="n">plt</code><code class="o">.</code><code class="n">style</code><code class="o">.</code><code class="n">use</code><code class="p">(</code><code class="s1">'seaborn-whitegrid'</code><code class="p">)</code>
         <code class="n">sp500</code><code class="o">.</code><code class="n">plot</code><code class="p">();</code></pre>
<figure><div class="figure" id="fig_0311-working-with-time-series_files_in_output_68_0">
<img alt="output 68 0" height="394" src="assets/output_68_0.png" width="600"/>
<h6><span class="label">Figure 23-1. </span>S&amp;P500 closing price over time</h6>
</div></figure>
<section data-pdf-bookmark="Resampling and Converting Frequencies" data-type="sect2"><div class="sect2" id="ch_0311-working-with-time-series_resampling-and-converting-frequencies">
<h2>Resampling and Converting Frequencies</h2>
<p><a data-primary="asfreq() method" data-type="indexterm" id="ix_ch23-asciidoc10"/><a data-primary="resample() method" data-type="indexterm" id="ix_ch23-asciidoc11"/><a data-primary="time series" data-secondary="resampling and converting frequencies" data-type="indexterm" id="ix_ch23-asciidoc12"/>One common need when dealing with time series data is resampling at a
higher or lower frequency. This can be done using the <code>resample</code> method,
or the much simpler <code>asfreq</code> method. The primary difference between the
two is that <code>resample</code> is fundamentally a <em>data aggregation</em>, while
<code>asfreq</code> is fundamentally a <em>data selection</em>.</p>
<p>Let’s compare what the two return when we downsample the S&amp;P
500 closing price data. Here we will resample the data at the end of
business year; <a data-type="xref" href="#fig_0311-working-with-time-series_files_in_output_70_0">Figure 23-2</a> shows the result.</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">28</code><code class="p">]:</code> <code class="n">sp500</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">alpha</code><code class="o">=</code><code class="mf">0.5</code><code class="p">,</code> <code class="n">style</code><code class="o">=</code><code class="s1">'-'</code><code class="p">)</code>
         <code class="n">sp500</code><code class="o">.</code><code class="n">resample</code><code class="p">(</code><code class="s1">'BA'</code><code class="p">)</code><code class="o">.</code><code class="n">mean</code><code class="p">()</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">style</code><code class="o">=</code><code class="s1">':'</code><code class="p">)</code>
         <code class="n">sp500</code><code class="o">.</code><code class="n">asfreq</code><code class="p">(</code><code class="s1">'BA'</code><code class="p">)</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">style</code><code class="o">=</code><code class="s1">'--'</code><code class="p">);</code>
         <code class="n">plt</code><code class="o">.</code><code class="n">legend</code><code class="p">([</code><code class="s1">'input'</code><code class="p">,</code> <code class="s1">'resample'</code><code class="p">,</code> <code class="s1">'asfreq'</code><code class="p">],</code>
                    <code class="n">loc</code><code class="o">=</code><code class="s1">'upper left'</code><code class="p">);</code></pre>
<figure><div class="figure" id="fig_0311-working-with-time-series_files_in_output_70_0">
<img alt="output 70 0" height="394" src="assets/output_70_0.png" width="600"/>
<h6><span class="label">Figure 23-2. </span>Resampling of S&amp;P500 closing price</h6>
</div></figure>
<p>Notice the difference: at each point, <code>resample</code> reports the <em>average of
the previous year</em>, while <code>asfreq</code> reports the <em>value at the end of the
year</em>.</p>
<p>For upsampling, <code>resample</code> and <code>asfreq</code> are largely equivalent, though
<code>resample</code> has many more options available. In this case, the default
for both methods is to leave the upsampled points empty; that is, filled
with NA values. Like the <code>pd.fillna</code> function discussed in
<a data-type="xref" href="ch16.xhtml#section-0304-missing-values">Chapter 16</a>, <code>asfreq</code> accepts
a <code>method</code> argument to specify how values are imputed. Here, we will
resample the business day data at a daily frequency (i.e., including
weekends); <a data-type="xref" href="#fig_0311-working-with-time-series_files_in_output_73_0">Figure 23-3</a> shows the result.</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">29</code><code class="p">]:</code> <code class="n">fig</code><code class="p">,</code> <code class="n">ax</code> <code class="o">=</code> <code class="n">plt</code><code class="o">.</code><code class="n">subplots</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="n">sharex</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code>
         <code class="n">data</code> <code class="o">=</code> <code class="n">sp500</code><code class="o">.</code><code class="n">iloc</code><code class="p">[:</code><code class="mi">20</code><code class="p">]</code>

         <code class="n">data</code><code class="o">.</code><code class="n">asfreq</code><code class="p">(</code><code class="s1">'D'</code><code class="p">)</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">ax</code><code class="o">=</code><code class="n">ax</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code> <code class="n">marker</code><code class="o">=</code><code class="s1">'o'</code><code class="p">)</code>

         <code class="n">data</code><code class="o">.</code><code class="n">asfreq</code><code class="p">(</code><code class="s1">'D'</code><code class="p">,</code> <code class="n">method</code><code class="o">=</code><code class="s1">'bfill'</code><code class="p">)</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">ax</code><code class="o">=</code><code class="n">ax</code><code class="p">[</code><code class="mi">1</code><code class="p">],</code> <code class="n">style</code><code class="o">=</code><code class="s1">'-o'</code><code class="p">)</code>
         <code class="n">data</code><code class="o">.</code><code class="n">asfreq</code><code class="p">(</code><code class="s1">'D'</code><code class="p">,</code> <code class="n">method</code><code class="o">=</code><code class="s1">'ffill'</code><code class="p">)</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">ax</code><code class="o">=</code><code class="n">ax</code><code class="p">[</code><code class="mi">1</code><code class="p">],</code> <code class="n">style</code><code class="o">=</code><code class="s1">'--o'</code><code class="p">)</code>
         <code class="n">ax</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="o">.</code><code class="n">legend</code><code class="p">([</code><code class="s2">"back-fill"</code><code class="p">,</code> <code class="s2">"forward-fill"</code><code class="p">]);</code></pre>
<figure><div class="figure" id="fig_0311-working-with-time-series_files_in_output_73_0">
<img alt="output 73 0" height="392" src="assets/output_73_0.png" width="600"/>
<h6><span class="label">Figure 23-3. </span>Comparison between forward-fill and back-fill interpolation</h6>
</div></figure>
<p>Because the S&amp;P 500 data only exists for business days, the top panel
has gaps representing NA values. The bottom panel shows the differences
between two strategies for filling the gaps: forward filling and
backward filling.<a data-startref="ix_ch23-asciidoc12" data-type="indexterm" id="idm45858766648368"/><a data-startref="ix_ch23-asciidoc11" data-type="indexterm" id="idm45858766647664"/><a data-startref="ix_ch23-asciidoc10" data-type="indexterm" id="idm45858766646992"/></p>
</div></section>
<section data-pdf-bookmark="Time Shifts" data-type="sect2"><div class="sect2" id="ch_0311-working-with-time-series_time-shifts">
<h2>Time Shifts</h2>
<p><a data-primary="time series" data-secondary="time-shifts" data-type="indexterm" id="idm45858766644672"/>Another common time series–specific operation is shifting of data in
time. <a data-primary="shift() function" data-type="indexterm" id="idm45858766643568"/>For this, Pandas provides the <code>shift</code> method, which can be used to
shift data by a given number of entries. With time series data sampled
at a regular frequency, this can give us a way to explore trends over
time.</p>
<p>For example, here we resample the data to daily values, and shift by 364
to compute the 1-year return on investment for the S&amp;P 500 over time
(see <a data-type="xref" href="#fig_0311-working-with-time-series_files_in_output_76_0">Figure 23-4</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">30</code><code class="p">]:</code> <code class="n">sp500</code> <code class="o">=</code> <code class="n">sp500</code><code class="o">.</code><code class="n">asfreq</code><code class="p">(</code><code class="s1">'D'</code><code class="p">,</code> <code class="n">method</code><code class="o">=</code><code class="s1">'pad'</code><code class="p">)</code>

         <code class="n">ROI</code> <code class="o">=</code> <code class="mi">100</code> <code class="o">*</code> <code class="p">(</code><code class="n">sp500</code><code class="o">.</code><code class="n">shift</code><code class="p">(</code><code class="o">-</code><code class="mi">365</code><code class="p">)</code> <code class="o">-</code> <code class="n">sp500</code><code class="p">)</code> <code class="o">/</code> <code class="n">sp500</code>
         <code class="n">ROI</code><code class="o">.</code><code class="n">plot</code><code class="p">()</code>
         <code class="n">plt</code><code class="o">.</code><code class="n">ylabel</code><code class="p">(</code><code class="s1">'% Return on Investment after 1 year'</code><code class="p">);</code></pre>
<figure><div class="figure" id="fig_0311-working-with-time-series_files_in_output_76_0">
<img alt="output 76 0" height="409" src="assets/output_76_0.png" width="600"/>
<h6><span class="label">Figure 23-4. </span>Return on investment after one year</h6>
</div></figure>
<p>The worst one-year return was around March 2019, with the
coronavirus-related market crash exactly a year later. As you might
expect, the best one-year return was to be found in March 2020, for
those with enough foresight or luck to buy low.</p>
</div></section>
<section data-pdf-bookmark="Rolling Windows" data-type="sect2"><div class="sect2" id="ch_0311-working-with-time-series_rolling-windows">
<h2>Rolling Windows</h2>
<p><a data-primary="rolling statistics" data-type="indexterm" id="idm45858766529744"/><a data-primary="time series" data-secondary="rolling statistics" data-type="indexterm" id="idm45858766528816"/>Calculating rolling statistics is a third type of time series–specific
operation implemented by Pandas. This can be accomplished via the
<code>rolling</code> attribute of <code>Series</code> and <code>DataFrame</code> objects, which returns a
view similar to what we saw with the <code>groupby</code> operation (see
<a data-type="xref" href="ch20.xhtml#section-0308-aggregation-and-grouping">Chapter 20</a>).
This rolling view makes available a number of aggregation operations by
default.</p>
<p>For example, we can look at the one-year centered rolling mean and
standard deviation of the stock prices (see <a data-type="xref" href="#fig_0311-working-with-time-series_files_in_output_80_0">Figure 23-5</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">31</code><code class="p">]:</code> <code class="n">rolling</code> <code class="o">=</code> <code class="n">sp500</code><code class="o">.</code><code class="n">rolling</code><code class="p">(</code><code class="mi">365</code><code class="p">,</code> <code class="n">center</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code>

         <code class="n">data</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">({</code><code class="s1">'input'</code><code class="p">:</code> <code class="n">sp500</code><code class="p">,</code>
                              <code class="s1">'one-year rolling_mean'</code><code class="p">:</code> <code class="n">rolling</code><code class="o">.</code><code class="n">mean</code><code class="p">(),</code>
                              <code class="s1">'one-year rolling_median'</code><code class="p">:</code> <code class="n">rolling</code><code class="o">.</code><code class="n">median</code><code class="p">()})</code>
         <code class="n">ax</code> <code class="o">=</code> <code class="n">data</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">style</code><code class="o">=</code><code class="p">[</code><code class="s1">'-'</code><code class="p">,</code> <code class="s1">'--'</code><code class="p">,</code> <code class="s1">':'</code><code class="p">])</code>
         <code class="n">ax</code><code class="o">.</code><code class="n">lines</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="o">.</code><code class="n">set_alpha</code><code class="p">(</code><code class="mf">0.3</code><code class="p">)</code></pre>
<figure><div class="figure" id="fig_0311-working-with-time-series_files_in_output_80_0">
<img alt="output 80 0" height="418" src="assets/output_80_0.png" width="600"/>
<h6><span class="label">Figure 23-5. </span>Rolling statistics on S&amp;P500 index</h6>
</div></figure>
<p>As with <code>groupby</code> operations, the <code>aggregate</code> and <code>apply</code> methods can be
used for custom rolling computations.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="ch_0311-working-with-time-series_where-to-learn-more">
<h5>Where to Learn More</h5>
<p>This chapter has provided only a brief summary of some of the most
essential features of time series tools provided by Pandas; for a more
complete discussion, you can refer to the
<a href="https://oreil.ly/uC3pB">“Time
Series/Date Functionality” section</a> of the Pandas online documentation.</p>
<p>Another excellent resource is the book
<a href="https://oreil.ly/ik2g7"><em>Python
for Data Analysis</em></a> by Wes McKinney (O’Reilly). It is an invaluable resource on the use of Pandas. In
particular, this book emphasizes time series tools in the context of
business and finance, and focuses much more on particular details of
business calendars, time zones, and related topics.</p>
<p>As always, you can also use the IPython help functionality to explore
and try out further options available to the functions and methods
discussed here. I find this often is the best way to learn a new Python
tool.</p>
</div></aside>
</div></section>
</div></section>
<section class="pagebreak-before less_space" data-pdf-bookmark="Example: Visualizing Seattle Bicycle Counts" data-type="sect1"><div class="sect1" id="ch_0311-working-with-time-series_example-visualizing-seattle-bicycle-counts">
<h1>Example: Visualizing Seattle Bicycle Counts</h1>
<p><a data-primary="bicycle traffic prediction" data-secondary="time series" data-type="indexterm" id="ix_ch23-asciidoc13"/><a data-primary="Seattle, bicycle traffic prediction in" data-secondary="time series" data-type="indexterm" id="ix_ch23-asciidoc14"/><a data-primary="time series" data-secondary="Seattle bicycle counts example" data-type="indexterm" id="ix_ch23-asciidoc15"/>As a more involved example of working with time series data,
let’s take a look at bicycle counts on Seattle’s
<a href="https://oreil.ly/6qVBt">Fremont
Bridge</a>. This data comes from an automated bicycle counter installed in
late 2012, which has inductive sensors on the east and west sidewalks of
the bridge. The hourly bicycle counts can be downloaded from
<a class="bare" href="http://data.seattle.gov"><em class="hyperlink">http://data.seattle.gov</em></a>; the Fremont
Bridge Bicycle Counter dataset is available under the Transportation
category.</p>
<p>The CSV used for this book can be downloaded as follows:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">32</code><code class="p">]:</code> <code class="c1"># url = ('https://raw.githubusercontent.com/jakevdp/'</code>
         <code class="c1">#        'bicycle-data/main/FremontBridge.csv')</code>
         <code class="c1"># !curl -O {url}</code></pre>
<p>Once this dataset is downloaded, we can use Pandas to read the CSV
output into a <code>DataFrame</code>. We will specify that we want the <code>Date</code>
column as an index, and we want these dates to be automatically parsed:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">33</code><code class="p">]:</code> <code class="n">data</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">read_csv</code><code class="p">(</code><code class="s1">'FremontBridge.csv'</code><code class="p">,</code> <code class="n">index_col</code><code class="o">=</code><code class="s1">'Date'</code><code class="p">,</code> <code class="n">parse_dates</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code>
         <code class="n">data</code><code class="o">.</code><code class="n">head</code><code class="p">()</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">33</code><code class="p">]:</code>                      <code class="n">Fremont</code> <code class="n">Bridge</code> <code class="n">Total</code>  <code class="n">Fremont</code> <code class="n">Bridge</code> <code class="n">East</code> <code class="n">Sidewalk</code>  \
         <code class="n">Date</code>
         <code class="mi">2019</code><code class="o">-</code><code class="mi">11</code><code class="o">-</code><code class="mi">01</code> <code class="mi">00</code><code class="p">:</code><code class="mi">00</code><code class="p">:</code><code class="mi">00</code>                  <code class="mf">12.0</code>                           <code class="mf">7.0</code>
         <code class="mi">2019</code><code class="o">-</code><code class="mi">11</code><code class="o">-</code><code class="mi">01</code> <code class="mi">01</code><code class="p">:</code><code class="mi">00</code><code class="p">:</code><code class="mi">00</code>                   <code class="mf">7.0</code>                           <code class="mf">0.0</code>
         <code class="mi">2019</code><code class="o">-</code><code class="mi">11</code><code class="o">-</code><code class="mi">01</code> <code class="mi">02</code><code class="p">:</code><code class="mi">00</code><code class="p">:</code><code class="mi">00</code>                   <code class="mf">1.0</code>                           <code class="mf">0.0</code>
         <code class="mi">2019</code><code class="o">-</code><code class="mi">11</code><code class="o">-</code><code class="mi">01</code> <code class="mi">03</code><code class="p">:</code><code class="mi">00</code><code class="p">:</code><code class="mi">00</code>                   <code class="mf">6.0</code>                           <code class="mf">6.0</code>
         <code class="mi">2019</code><code class="o">-</code><code class="mi">11</code><code class="o">-</code><code class="mi">01</code> <code class="mi">04</code><code class="p">:</code><code class="mi">00</code><code class="p">:</code><code class="mi">00</code>                   <code class="mf">6.0</code>                           <code class="mf">5.0</code>

                              <code class="n">Fremont</code> <code class="n">Bridge</code> <code class="n">West</code> <code class="n">Sidewalk</code>
         <code class="n">Date</code>
         <code class="mi">2019</code><code class="o">-</code><code class="mi">11</code><code class="o">-</code><code class="mi">01</code> <code class="mi">00</code><code class="p">:</code><code class="mi">00</code><code class="p">:</code><code class="mi">00</code>                           <code class="mf">5.0</code>
         <code class="mi">2019</code><code class="o">-</code><code class="mi">11</code><code class="o">-</code><code class="mi">01</code> <code class="mi">01</code><code class="p">:</code><code class="mi">00</code><code class="p">:</code><code class="mi">00</code>                           <code class="mf">7.0</code>
         <code class="mi">2019</code><code class="o">-</code><code class="mi">11</code><code class="o">-</code><code class="mi">01</code> <code class="mi">02</code><code class="p">:</code><code class="mi">00</code><code class="p">:</code><code class="mi">00</code>                           <code class="mf">1.0</code>
         <code class="mi">2019</code><code class="o">-</code><code class="mi">11</code><code class="o">-</code><code class="mi">01</code> <code class="mi">03</code><code class="p">:</code><code class="mi">00</code><code class="p">:</code><code class="mi">00</code>                           <code class="mf">0.0</code>
         <code class="mi">2019</code><code class="o">-</code><code class="mi">11</code><code class="o">-</code><code class="mi">01</code> <code class="mi">04</code><code class="p">:</code><code class="mi">00</code><code class="p">:</code><code class="mi">00</code>                           <code class="mf">1.0</code></pre>
<p>For convenience, we’ll shorten the column names:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">34</code><code class="p">]:</code> <code class="n">data</code><code class="o">.</code><code class="n">columns</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'Total'</code><code class="p">,</code> <code class="s1">'East'</code><code class="p">,</code> <code class="s1">'West'</code><code class="p">]</code></pre>
<p>Now let’s take a look at the summary statistics for this
data:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">35</code><code class="p">]:</code> <code class="n">data</code><code class="o">.</code><code class="n">dropna</code><code class="p">()</code><code class="o">.</code><code class="n">describe</code><code class="p">()</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">35</code><code class="p">]:</code>                <code class="n">Total</code>           <code class="n">East</code>           <code class="n">West</code>
         <code class="n">count</code>  <code class="mf">147255.000000</code>  <code class="mf">147255.000000</code>  <code class="mf">147255.000000</code>
         <code class="n">mean</code>      <code class="mf">110.341462</code>      <code class="mf">50.077763</code>      <code class="mf">60.263699</code>
         <code class="n">std</code>       <code class="mf">140.422051</code>      <code class="mf">64.634038</code>      <code class="mf">87.252147</code>
         <code class="nb">min</code>         <code class="mf">0.000000</code>       <code class="mf">0.000000</code>       <code class="mf">0.000000</code>
         <code class="mi">25</code><code class="o">%</code>        <code class="mf">14.000000</code>       <code class="mf">6.000000</code>       <code class="mf">7.000000</code>
         <code class="mi">50</code><code class="o">%</code>        <code class="mf">60.000000</code>      <code class="mf">28.000000</code>      <code class="mf">30.000000</code>
         <code class="mi">75</code><code class="o">%</code>       <code class="mf">145.000000</code>      <code class="mf">68.000000</code>      <code class="mf">74.000000</code>
         <code class="nb">max</code>      <code class="mf">1097.000000</code>     <code class="mf">698.000000</code>     <code class="mf">850.000000</code></pre>
<section data-pdf-bookmark="Visualizing the Data" data-type="sect2"><div class="sect2" id="ch_0311-working-with-time-series_visualizing-the-data">
<h2>Visualizing the Data</h2>
<p>We can gain some insight into the dataset by visualizing it.
Let’s start by plotting the raw data (see <a data-type="xref" href="#fig_0311-working-with-time-series_files_in_output_92_0">Figure 23-6</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">36</code><code class="p">]:</code> <code class="n">data</code><code class="o">.</code><code class="n">plot</code><code class="p">()</code>
         <code class="n">plt</code><code class="o">.</code><code class="n">ylabel</code><code class="p">(</code><code class="s1">'Hourly Bicycle Count'</code><code class="p">);</code></pre>
<figure><div class="figure" id="fig_0311-working-with-time-series_files_in_output_92_0">
<img alt="output 92 0" height="368" src="assets/output_92_0.png" width="600"/>
<h6><span class="label">Figure 23-6. </span>Hourly bicycle counts on Seattle’s Fremont Bridge</h6>
</div></figure>
<p>The ~150,000 hourly samples are far too dense for us to make much sense
of. We can gain more insight by resampling the data to a coarser grid.
Let’s resample by week (see <a data-type="xref" href="#fig_0311-working-with-time-series_files_in_output_94_0">Figure 23-7</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">37</code><code class="p">]:</code> <code class="n">weekly</code> <code class="o">=</code> <code class="n">data</code><code class="o">.</code><code class="n">resample</code><code class="p">(</code><code class="s1">'W'</code><code class="p">)</code><code class="o">.</code><code class="n">sum</code><code class="p">()</code>
         <code class="n">weekly</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">style</code><code class="o">=</code><code class="p">[</code><code class="s1">'-'</code><code class="p">,</code> <code class="s1">':'</code><code class="p">,</code> <code class="s1">'--'</code><code class="p">])</code>
         <code class="n">plt</code><code class="o">.</code><code class="n">ylabel</code><code class="p">(</code><code class="s1">'Weekly bicycle count'</code><code class="p">);</code></pre>
<p>This reveals some trends: as you might expect, people bicycle more in
the summer than in the winter, and even within a particular season the
bicycle use varies from week to week (likely dependent on weather; see
<a data-type="xref" href="ch42.xhtml#section-0506-linear-regression">Chapter 42</a>, where
we explore this further). Further, the effect of the COVID-19 pandemic
on commuting patterns is quite clear, starting in early 2020.</p>
<figure><div class="figure" id="fig_0311-working-with-time-series_files_in_output_94_0">
<img alt="output 94 0" height="371" src="assets/output_94_0.png" width="600"/>
<h6><span class="label">Figure 23-7. </span>Weekly bicycle crossings of Seattle’s Fremont Bridge</h6>
</div></figure>
<p>Another option that comes in handy for aggregating the data is to use a
rolling mean, utilizing the <code>pd.rolling_mean</code> function. Here
we’ll examine the 30-day rolling mean of our data, making
sure to center the window (see <a data-type="xref" href="#fig_0311-working-with-time-series_files_in_output_96_0">Figure 23-8</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">38</code><code class="p">]:</code> <code class="n">daily</code> <code class="o">=</code> <code class="n">data</code><code class="o">.</code><code class="n">resample</code><code class="p">(</code><code class="s1">'D'</code><code class="p">)</code><code class="o">.</code><code class="n">sum</code><code class="p">()</code>
         <code class="n">daily</code><code class="o">.</code><code class="n">rolling</code><code class="p">(</code><code class="mi">30</code><code class="p">,</code> <code class="n">center</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code><code class="o">.</code><code class="n">sum</code><code class="p">()</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">style</code><code class="o">=</code><code class="p">[</code><code class="s1">'-'</code><code class="p">,</code> <code class="s1">':'</code><code class="p">,</code> <code class="s1">'--'</code><code class="p">])</code>
         <code class="n">plt</code><code class="o">.</code><code class="n">ylabel</code><code class="p">(</code><code class="s1">'mean hourly count'</code><code class="p">);</code></pre>
<figure><div class="figure" id="fig_0311-working-with-time-series_files_in_output_96_0">
<img alt="output 96 0" height="376" src="assets/output_96_0.png" width="600"/>
<h6><span class="label">Figure 23-8. </span>Rolling mean of weekly bicycle counts</h6>
</div></figure>
<p>The jaggedness of the result is due to the hard cutoff of the window. We
can get a smoother version of a rolling mean using a window function—for
example, a Gaussian window, as shown in <a data-type="xref" href="#fig_0311-working-with-time-series_files_in_output_98_0">Figure 23-9</a>. The
following code specifies both the width of the window (here, 50 days)
and the width of the Gaussian window (here, 10 days):</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">39</code><code class="p">]:</code> <code class="n">daily</code><code class="o">.</code><code class="n">rolling</code><code class="p">(</code><code class="mi">50</code><code class="p">,</code> <code class="n">center</code><code class="o">=</code><code class="kc">True</code><code class="p">,</code>
                       <code class="n">win_type</code><code class="o">=</code><code class="s1">'gaussian'</code><code class="p">)</code><code class="o">.</code><code class="n">sum</code><code class="p">(</code><code class="n">std</code><code class="o">=</code><code class="mi">10</code><code class="p">)</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">style</code><code class="o">=</code><code class="p">[</code><code class="s1">'-'</code><code class="p">,</code> <code class="s1">':'</code><code class="p">,</code> <code class="s1">'--'</code><code class="p">]);</code></pre>
<figure><div class="figure" id="fig_0311-working-with-time-series_files_in_output_98_0">
<img alt="output 98 0" height="394" src="assets/output_98_0.png" width="600"/>
<h6><span class="label">Figure 23-9. </span>Gaussian smoothed weekly bicycle counts</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="Digging into the Data" data-type="sect2"><div class="sect2" id="ch_0311-working-with-time-series_digging-into-the-data">
<h2>Digging into the Data</h2>
<p>While these smoothed data views are useful to get an idea of the general
trend in the data, they hide much of the structure. For example, we
might want to look at the average traffic as a function of the time of
day. We can do this using the <code>groupby</code> functionality discussed in
<a data-type="xref" href="ch20.xhtml#section-0308-aggregation-and-grouping">Chapter 20</a> (see
<a data-type="xref" href="#fig_0311-working-with-time-series_files_in_output_100_0">Figure 23-10</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">40</code><code class="p">]:</code> <code class="n">by_time</code> <code class="o">=</code> <code class="n">data</code><code class="o">.</code><code class="n">groupby</code><code class="p">(</code><code class="n">data</code><code class="o">.</code><code class="n">index</code><code class="o">.</code><code class="n">time</code><code class="p">)</code><code class="o">.</code><code class="n">mean</code><code class="p">()</code>
         <code class="n">hourly_ticks</code> <code class="o">=</code> <code class="mi">4</code> <code class="o">*</code> <code class="mi">60</code> <code class="o">*</code> <code class="mi">60</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">6</code><code class="p">)</code>
         <code class="n">by_time</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">xticks</code><code class="o">=</code><code class="n">hourly_ticks</code><code class="p">,</code> <code class="n">style</code><code class="o">=</code><code class="p">[</code><code class="s1">'-'</code><code class="p">,</code> <code class="s1">':'</code><code class="p">,</code> <code class="s1">'--'</code><code class="p">]);</code></pre>
<figure><div class="figure" id="fig_0311-working-with-time-series_files_in_output_100_0">
<img alt="output 100 0" height="408" src="assets/output_100_0.png" width="600"/>
<h6><span class="label">Figure 23-10. </span>Average hourly bicycle counts</h6>
</div></figure>
<p>The hourly traffic is a strongly bimodal sequence, with peaks around
8:00 a.m. and 5:00 p.m. This is likely evidence of a strong component of
commuter traffic crossing the bridge. There is a directional component
as well: according to the data, the east sidewalk is used more during
the a.m. commute, and the west sidewalk is used more during the p.m.
commute.</p>
<p>We also might be curious about how things change based on the day of the
week. Again, we can do this with a simple <code>groupby</code> (see <a data-type="xref" href="#fig_0311-working-with-time-series_files_in_output_102_0">Figure 23-11</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">41</code><code class="p">]:</code> <code class="n">by_weekday</code> <code class="o">=</code> <code class="n">data</code><code class="o">.</code><code class="n">groupby</code><code class="p">(</code><code class="n">data</code><code class="o">.</code><code class="n">index</code><code class="o">.</code><code class="n">dayofweek</code><code class="p">)</code><code class="o">.</code><code class="n">mean</code><code class="p">()</code>
         <code class="n">by_weekday</code><code class="o">.</code><code class="n">index</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'Mon'</code><code class="p">,</code> <code class="s1">'Tues'</code><code class="p">,</code> <code class="s1">'Wed'</code><code class="p">,</code> <code class="s1">'Thurs'</code><code class="p">,</code> <code class="s1">'Fri'</code><code class="p">,</code> <code class="s1">'Sat'</code><code class="p">,</code> <code class="s1">'Sun'</code><code class="p">]</code>
         <code class="n">by_weekday</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">style</code><code class="o">=</code><code class="p">[</code><code class="s1">'-'</code><code class="p">,</code> <code class="s1">':'</code><code class="p">,</code> <code class="s1">'--'</code><code class="p">]);</code></pre>
<figure><div class="figure" id="fig_0311-working-with-time-series_files_in_output_102_0">
<img alt="output 102 0" height="387" src="assets/output_102_0.png" width="600"/>
<h6><span class="label">Figure 23-11. </span>Average daily bicycle counts</h6>
</div></figure>
<p>This shows a strong distinction between weekday and weekend totals, with
around twice as many average riders crossing the bridge on Monday
through Friday than on Saturday and Sunday.</p>
<p>With this in mind, let’s do a compound <code>groupby</code> and look at
the hourly trends on weekdays versus weekends. We’ll start
by grouping by flags marking the weekend and the time of day:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">42</code><code class="p">]:</code> <code class="n">weekend</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">where</code><code class="p">(</code><code class="n">data</code><code class="o">.</code><code class="n">index</code><code class="o">.</code><code class="n">weekday</code> <code class="o">&lt;</code> <code class="mi">5</code><code class="p">,</code> <code class="s1">'Weekday'</code><code class="p">,</code> <code class="s1">'Weekend'</code><code class="p">)</code>
         <code class="n">by_time</code> <code class="o">=</code> <code class="n">data</code><code class="o">.</code><code class="n">groupby</code><code class="p">([</code><code class="n">weekend</code><code class="p">,</code> <code class="n">data</code><code class="o">.</code><code class="n">index</code><code class="o">.</code><code class="n">time</code><code class="p">])</code><code class="o">.</code><code class="n">mean</code><code class="p">()</code></pre>
<p>Now we’ll use some of the Matplotlib tools that will be
described in <a data-type="xref" href="ch31.xhtml#section-0408-multiple-subplots">Chapter 31</a> to
plot two panels side by side, as shown in <a data-type="xref" href="#fig_0311-working-with-time-series_files_in_output_106_0">Figure 23-12</a>.</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">43</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">matplotlib.pyplot</code> <code class="k">as</code> <code class="nn">plt</code>
         <code class="n">fig</code><code class="p">,</code> <code class="n">ax</code> <code class="o">=</code> <code class="n">plt</code><code class="o">.</code><code class="n">subplots</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="n">figsize</code><code class="o">=</code><code class="p">(</code><code class="mi">14</code><code class="p">,</code> <code class="mi">5</code><code class="p">))</code>
         <code class="n">by_time</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="s1">'Weekday'</code><code class="p">]</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">ax</code><code class="o">=</code><code class="n">ax</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code> <code class="n">title</code><code class="o">=</code><code class="s1">'Weekdays'</code><code class="p">,</code>
                                     <code class="n">xticks</code><code class="o">=</code><code class="n">hourly_ticks</code><code class="p">,</code> <code class="n">style</code><code class="o">=</code><code class="p">[</code><code class="s1">'-'</code><code class="p">,</code> <code class="s1">':'</code><code class="p">,</code> <code class="s1">'--'</code><code class="p">])</code>
         <code class="n">by_time</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="s1">'Weekend'</code><code class="p">]</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">ax</code><code class="o">=</code><code class="n">ax</code><code class="p">[</code><code class="mi">1</code><code class="p">],</code> <code class="n">title</code><code class="o">=</code><code class="s1">'Weekends'</code><code class="p">,</code>
                                     <code class="n">xticks</code><code class="o">=</code><code class="n">hourly_ticks</code><code class="p">,</code> <code class="n">style</code><code class="o">=</code><code class="p">[</code><code class="s1">'-'</code><code class="p">,</code> <code class="s1">':'</code><code class="p">,</code> <code class="s1">'--'</code><code class="p">]);</code></pre>
<figure><div class="figure" id="fig_0311-working-with-time-series_files_in_output_106_0">
<img alt="output 106 0" height="232" src="assets/output_106_0.png" width="600"/>
<h6><span class="label">Figure 23-12. </span>Average hourly bicycle counts by weekday and weekend</h6>
</div></figure>
<p>The result shows a bimodal commuting pattern during the work week, and a
unimodal recreational pattern during the weekends. It might be
interesting to dig through this data in more detail and examine the
effects of weather, temperature, time of year, and other factors on
people’s commuting patterns; for further discussion, see my
blog post
<a href="https://oreil.ly/j5oEI">“Is
Seattle Really Seeing an Uptick in Cycling?”</a>, which uses a subset of
this data. We will also revisit this dataset in the context of modeling
in <a data-type="xref" href="ch42.xhtml#section-0506-linear-regression">Chapter 42</a><a data-startref="ix_ch23-asciidoc15" data-type="indexterm" id="idm45858765418128"/><a data-startref="ix_ch23-asciidoc14" data-type="indexterm" id="idm45858765417456"/><a data-startref="ix_ch23-asciidoc13" data-type="indexterm" id="idm45858765416784"/>.<a data-startref="ix_ch23-asciidoc1" data-type="indexterm" id="idm45858765415984"/><a data-startref="ix_ch23-asciidoc0" data-type="indexterm" id="idm45858765415280"/></p>
</div></section>
</div></section>
</div></section></div></body></html>