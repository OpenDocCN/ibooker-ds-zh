<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 6. Computation on NumPy Arrays: &#10;Universal Functions" data-type="chapter" epub:type="chapter"><div class="chapter" id="section-0203-computation-on-arrays-ufuncs">
<h1><span class="label">Chapter 6. </span>Computation on NumPy Arrays: 
<span class="keep-together">Universal Functions</span></h1>
<p><a data-primary="arrays" data-secondary="computation on" data-type="indexterm" id="ix_ch06-asciidoc0"/><a data-primary="arrays" data-secondary="universal functions" data-type="indexterm" id="ix_ch06-asciidoc1"/><a data-primary="NumPy" data-secondary="computation on arrays" data-type="indexterm" id="ix_ch06-asciidoc2"/><a data-primary="NumPy" data-secondary="universal functions" data-type="indexterm" id="ix_ch06-asciidoc3"/><a data-primary="universal functions (ufuncs)" data-type="indexterm" id="ix_ch06-asciidoc4"/>Up until now, we have been discussing some of the basic nuts and bolts
of NumPy. In the next few chapters, we will dive into the reasons that
NumPy is so important in the Python data science world: namely, because
it provides an easy and flexible interface to optimize computation with
arrays of data.</p>
<p>Computation on NumPy arrays can be very fast, or it can be very slow.
The key to making it fast is to use vectorized operations, generally
implemented through NumPy’s <em>universal functions</em> (ufuncs).
This chapter motivates the need for NumPy’s ufuncs, which
can be used to make repeated calculations on array elements much more
efficient. It then introduces many of the most common and useful
arithmetic ufuncs available in the NumPy package.</p>
<section data-pdf-bookmark="The Slowness of Loops" data-type="sect1"><div class="sect1" id="ch_0203-computation-on-arrays-ufuncs_the-slowness-of-loops">
<h1>The Slowness of Loops</h1>
<p><a data-primary="universal functions (ufuncs)" data-secondary="slowness of Python loops" data-type="indexterm" id="idm45858805471696"/>Python’s default implementation (known as CPython) does some
operations very slowly. This is partly due to the dynamic, interpreted
nature of the language; types are flexible, so sequences of operations
cannot be compiled down to efficient machine code as in languages like C
and Fortran. Recently there have been various attempts to address this
weakness: well-known examples are the <a href="http://pypy.org">PyPy project</a>, a
just-in-time compiled implementation of Python; the
<a href="http://cython.org">Cython project</a>, which converts Python code to
compilable C code; and the <a href="http://numba.pydata.org">Numba project</a>,
which converts snippets of Python code to fast LLVM bytecode. Each of
these has its strengths and weaknesses, but it is safe to say that none
of the three approaches has yet surpassed the reach and popularity of
the standard CPython engine.</p>
<p>The relative sluggishness of Python generally manifests itself in
situations where many small operations are being repeated; for instance,
looping over arrays to operate on each element. For example, imagine we
have an array of values and we’d like to compute the
reciprocal of each. A straightforward approach might look like this:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>
        <code class="n">rng</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">default_rng</code><code class="p">(</code><code class="n">seed</code><code class="o">=</code><code class="mi">1701</code><code class="p">)</code>

        <code class="k">def</code> <code class="nf">compute_reciprocals</code><code class="p">(</code><code class="n">values</code><code class="p">):</code>
            <code class="n">output</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">empty</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">values</code><code class="p">))</code>
            <code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">values</code><code class="p">)):</code>
                <code class="n">output</code><code class="p">[</code><code class="n">i</code><code class="p">]</code> <code class="o">=</code> <code class="mf">1.0</code> <code class="o">/</code> <code class="n">values</code><code class="p">[</code><code class="n">i</code><code class="p">]</code>
            <code class="k">return</code> <code class="n">output</code>

        <code class="n">values</code> <code class="o">=</code> <code class="n">rng</code><code class="o">.</code><code class="n">integers</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="n">size</code><code class="o">=</code><code class="mi">5</code><code class="p">)</code>
        <code class="n">compute_reciprocals</code><code class="p">(</code><code class="n">values</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mf">0.11111111</code><code class="p">,</code> <code class="mf">0.25</code>      <code class="p">,</code> <code class="mf">1.</code>        <code class="p">,</code> <code class="mf">0.33333333</code><code class="p">,</code> <code class="mf">0.125</code>     <code class="p">])</code></pre>
<p>This implementation probably feels fairly natural to someone from, say,
a C or Java background. But if we measure the execution time of this
code for a large input, we see that this operation is very slow—perhaps
surprisingly so! We’ll benchmark this with
IPython’s <code>%timeit</code> magic (discussed in
<a data-type="xref" href="ch03.xhtml#section-0107-timing-and-profiling">“Profiling and Timing Code”</a>):</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="n">big_array</code> <code class="o">=</code> <code class="n">rng</code><code class="o">.</code><code class="n">integers</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">100</code><code class="p">,</code> <code class="n">size</code><code class="o">=</code><code class="mi">1000000</code><code class="p">)</code>
        <code class="o">%</code><code class="k">timeit</code> compute_reciprocals(big_array)
<code class="n">Out</code><code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="mf">2.61</code> <code class="n">s</code> <code class="err">±</code> <code class="mi">192</code> <code class="n">ms</code> <code class="n">per</code> <code class="n">loop</code> <code class="p">(</code><code class="n">mean</code> <code class="err">±</code> <code class="n">std</code><code class="o">.</code> <code class="n">dev</code><code class="o">.</code> <code class="n">of</code> <code class="mi">7</code> <code class="n">runs</code><code class="p">,</code> <code class="mi">1</code> <code class="n">loop</code> <code class="n">each</code><code class="p">)</code></pre>
<p>It takes several seconds to compute these million operations and to
store the result! When even cell phones have processing speeds measured
in gigaflops (i.e., billions of numerical operations per second), this
seems almost absurdly slow. It turns out that the bottleneck here is not
the operations themselves, but the type checking and function dispatches
that CPython must do at each cycle of the loop. Each time the reciprocal
is computed, Python first examines the object’s type and
does a dynamic lookup of the correct function to use for that type. If
we were working in compiled code instead, this type specification would
be known before the code executed and the result could be computed much
more efficiently.</p>
</div></section>
<section data-pdf-bookmark="Introducing Ufuncs" data-type="sect1"><div class="sect1" id="ch_0203-computation-on-arrays-ufuncs_introducing-ufuncs">
<h1>Introducing Ufuncs</h1>
<p><a data-primary="universal functions (ufuncs)" data-secondary="basics" data-type="indexterm" id="ix_ch06-asciidoc5"/>For many types of operations, NumPy provides a convenient interface into
just this kind of statically typed, compiled routine. This is known as a
<em>vectorized</em> operation. For simple operations like the element-wise
division here, vectorization is as simple as using Python arithmetic
operators directly on the array object. This vectorized approach is
designed to push the loop into the compiled layer that underlies NumPy,
leading to much faster execution.</p>
<p class="pagebreak-before less_space">Compare the results of the following two operations:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="nb">print</code><code class="p">(</code><code class="n">compute_reciprocals</code><code class="p">(</code><code class="n">values</code><code class="p">))</code>
        <code class="nb">print</code><code class="p">(</code><code class="mf">1.0</code> <code class="o">/</code> <code class="n">values</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="p">[</code><code class="mf">0.11111111</code> <code class="mf">0.25</code>       <code class="mf">1.</code>         <code class="mf">0.33333333</code> <code class="mf">0.125</code>     <code class="p">]</code>
        <code class="p">[</code><code class="mf">0.11111111</code> <code class="mf">0.25</code>       <code class="mf">1.</code>         <code class="mf">0.33333333</code> <code class="mf">0.125</code>     <code class="p">]</code></pre>
<p>Looking at the execution time for our big array, we see that it
completes orders of magnitude faster than the Python loop:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="o">%</code><code class="k">timeit</code> (1.0 / big_array)
<code class="n">Out</code><code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="mf">2.54</code> <code class="n">ms</code> <code class="err">±</code> <code class="mi">383</code> <code class="n">µs</code> <code class="n">per</code> <code class="n">loop</code> <code class="p">(</code><code class="n">mean</code> <code class="err">±</code> <code class="n">std</code><code class="o">.</code> <code class="n">dev</code><code class="o">.</code> <code class="n">of</code> <code class="mi">7</code> <code class="n">runs</code><code class="p">,</code> <code class="mi">100</code> <code class="n">loops</code> <code class="n">each</code><code class="p">)</code></pre>
<p>Vectorized operations in NumPy are implemented via ufuncs, whose main
purpose is to quickly execute repeated operations on values in NumPy
arrays. Ufuncs are extremely flexible—before we saw an operation between
a scalar and an array, but we can also operate between two arrays:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code> <code class="o">/</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">6</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mf">0.</code>        <code class="p">,</code> <code class="mf">0.5</code>       <code class="p">,</code> <code class="mf">0.66666667</code><code class="p">,</code> <code class="mf">0.75</code>      <code class="p">,</code> <code class="mf">0.8</code>       <code class="p">])</code></pre>
<p>And ufunc operations are not limited to one-dimensional arrays. They can
act on multidimensional arrays as well:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">9</code><code class="p">)</code><code class="o">.</code><code class="n">reshape</code><code class="p">((</code><code class="mi">3</code><code class="p">,</code> <code class="mi">3</code><code class="p">))</code>
        <code class="mi">2</code> <code class="o">**</code> <code class="n">x</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code>  <code class="mi">1</code><code class="p">,</code>   <code class="mi">2</code><code class="p">,</code>   <code class="mi">4</code><code class="p">],</code>
               <code class="p">[</code>  <code class="mi">8</code><code class="p">,</code>  <code class="mi">16</code><code class="p">,</code>  <code class="mi">32</code><code class="p">],</code>
               <code class="p">[</code> <code class="mi">64</code><code class="p">,</code> <code class="mi">128</code><code class="p">,</code> <code class="mi">256</code><code class="p">]])</code></pre>
<p>Computations using vectorization through ufuncs are nearly always more
efficient than their counterparts implemented using Python loops,
especially as the arrays grow in size. Any time you see such a loop in a
NumPy script, you should consider whether it can be replaced with a
vectorized expression.</p>
</div></section>
<section data-pdf-bookmark="Exploring NumPy’s Ufuncs" data-type="sect1"><div class="sect1" id="ch_0203-computation-on-arrays-ufuncs_exploring-numpys-ufuncs">
<h1>Exploring NumPy’s Ufuncs</h1>
<p><a data-primary="binary ufuncs" data-type="indexterm" id="idm45858805022960"/><a data-primary="unary ufuncs" data-type="indexterm" id="idm45858805022256"/>Ufuncs exist in two flavors: <em>unary ufuncs</em>, which operate on a single
input, and <em>binary ufuncs</em>, which operate on two inputs.
We’ll see examples of both these types of functions here.</p>
<section data-pdf-bookmark="Array Arithmetic" data-type="sect2"><div class="sect2" id="ch_0203-computation-on-arrays-ufuncs_array-arithmetic">
<h2>Array Arithmetic</h2>
<p><a data-primary="arithmetic operators" data-type="indexterm" id="idm45858805018576"/><a data-primary="arrays" data-secondary="arithmetic operators" data-type="indexterm" id="idm45858805017872"/><a data-primary="universal functions (ufuncs)" data-secondary="array arithmetic" data-type="indexterm" id="idm45858805016928"/>NumPy’s ufuncs feel very natural to use because they make
use of Python’s native arithmetic operators. The standard
addition, subtraction, multiplication, and division can all be used:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">4</code><code class="p">)</code>
        <code class="nb">print</code><code class="p">(</code><code class="s2">"x      ="</code><code class="p">,</code> <code class="n">x</code><code class="p">)</code>
        <code class="nb">print</code><code class="p">(</code><code class="s2">"x + 5  ="</code><code class="p">,</code> <code class="n">x</code> <code class="o">+</code> <code class="mi">5</code><code class="p">)</code>
        <code class="nb">print</code><code class="p">(</code><code class="s2">"x - 5  ="</code><code class="p">,</code> <code class="n">x</code> <code class="o">-</code> <code class="mi">5</code><code class="p">)</code>
        <code class="nb">print</code><code class="p">(</code><code class="s2">"x * 2  ="</code><code class="p">,</code> <code class="n">x</code> <code class="o">*</code> <code class="mi">2</code><code class="p">)</code>
        <code class="nb">print</code><code class="p">(</code><code class="s2">"x / 2  ="</code><code class="p">,</code> <code class="n">x</code> <code class="o">/</code> <code class="mi">2</code><code class="p">)</code>
        <code class="nb">print</code><code class="p">(</code><code class="s2">"x // 2 ="</code><code class="p">,</code> <code class="n">x</code> <code class="o">//</code> <code class="mi">2</code><code class="p">)</code>  <code class="c1"># floor division</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">x</code>      <code class="o">=</code> <code class="p">[</code><code class="mi">0</code> <code class="mi">1</code> <code class="mi">2</code> <code class="mi">3</code><code class="p">]</code>
        <code class="n">x</code> <code class="o">+</code> <code class="mi">5</code>  <code class="o">=</code> <code class="p">[</code><code class="mi">5</code> <code class="mi">6</code> <code class="mi">7</code> <code class="mi">8</code><code class="p">]</code>
        <code class="n">x</code> <code class="o">-</code> <code class="mi">5</code>  <code class="o">=</code> <code class="p">[</code><code class="o">-</code><code class="mi">5</code> <code class="o">-</code><code class="mi">4</code> <code class="o">-</code><code class="mi">3</code> <code class="o">-</code><code class="mi">2</code><code class="p">]</code>
        <code class="n">x</code> <code class="o">*</code> <code class="mi">2</code>  <code class="o">=</code> <code class="p">[</code><code class="mi">0</code> <code class="mi">2</code> <code class="mi">4</code> <code class="mi">6</code><code class="p">]</code>
        <code class="n">x</code> <code class="o">/</code> <code class="mi">2</code>  <code class="o">=</code> <code class="p">[</code><code class="mf">0.</code>  <code class="mf">0.5</code> <code class="mf">1.</code>  <code class="mf">1.5</code><code class="p">]</code>
        <code class="n">x</code> <code class="o">//</code> <code class="mi">2</code> <code class="o">=</code> <code class="p">[</code><code class="mi">0</code> <code class="mi">0</code> <code class="mi">1</code> <code class="mi">1</code><code class="p">]</code></pre>
<p>There is also a unary ufunc for negation, a <code>**</code> operator for
exponentiation, and a <code>%</code> operator for modulus:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="nb">print</code><code class="p">(</code><code class="s2">"-x     = "</code><code class="p">,</code> <code class="o">-</code><code class="n">x</code><code class="p">)</code>
        <code class="nb">print</code><code class="p">(</code><code class="s2">"x ** 2 = "</code><code class="p">,</code> <code class="n">x</code> <code class="o">**</code> <code class="mi">2</code><code class="p">)</code>
        <code class="nb">print</code><code class="p">(</code><code class="s2">"x % 2  = "</code><code class="p">,</code> <code class="n">x</code> <code class="o">%</code> <code class="mi">2</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="o">-</code><code class="n">x</code>     <code class="o">=</code>  <code class="p">[</code> <code class="mi">0</code> <code class="o">-</code><code class="mi">1</code> <code class="o">-</code><code class="mi">2</code> <code class="o">-</code><code class="mi">3</code><code class="p">]</code>
        <code class="n">x</code> <code class="o">**</code> <code class="mi">2</code> <code class="o">=</code>  <code class="p">[</code><code class="mi">0</code> <code class="mi">1</code> <code class="mi">4</code> <code class="mi">9</code><code class="p">]</code>
        <code class="n">x</code> <code class="o">%</code> <code class="mi">2</code>  <code class="o">=</code>  <code class="p">[</code><code class="mi">0</code> <code class="mi">1</code> <code class="mi">0</code> <code class="mi">1</code><code class="p">]</code></pre>
<p>In addition, these can be strung together however you wish, and the
standard order of operations is respected:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="o">-</code><code class="p">(</code><code class="mf">0.5</code><code class="o">*</code><code class="n">x</code> <code class="o">+</code> <code class="mi">1</code><code class="p">)</code> <code class="o">**</code> <code class="mi">2</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="o">-</code><code class="mf">1.</code>  <code class="p">,</code> <code class="o">-</code><code class="mf">2.25</code><code class="p">,</code> <code class="o">-</code><code class="mf">4.</code>  <code class="p">,</code> <code class="o">-</code><code class="mf">6.25</code><code class="p">])</code></pre>
<p>All of these arithmetic operations are simply convenient wrappers around
specific ufuncs built into NumPy. For example, the <code>+</code> operator is a
wrapper for the <code>add</code> ufunc:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code></pre>
<p><a data-type="xref" href="#table-6-1">Table 6-1</a> lists the arithmetic operators implemented in NumPy.</p>
<table id="table-6-1">
<caption><span class="label">Table 6-1. </span>Arithmetic operators implemented in NumPy</caption>
<thead>
<tr>
<th>Operator</th>
<th>Equivalent ufunc</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>+</code></p></td>
<td><p><code>np.add</code></p></td>
<td><p>Addition (e.g., <code>1 + 1 = 2</code>)</p></td>
</tr>
<tr>
<td><p><code>-</code></p></td>
<td><p><code>np.subtract</code></p></td>
<td><p>Subtraction (e.g., <code>3 - 2 = 1</code>)</p></td>
</tr>
<tr>
<td><p><code>-</code></p></td>
<td><p><code>np.negative</code></p></td>
<td><p>Unary negation (e.g., <code>-2</code>)</p></td>
</tr>
<tr>
<td><p><code>*</code></p></td>
<td><p><code>np.multiply</code></p></td>
<td><p>Multiplication (e.g., <code>2 * 3 = 6</code>)</p></td>
</tr>
<tr>
<td><p><code>/</code></p></td>
<td><p><code>np.divide</code></p></td>
<td><p>Division (e.g., <code>3 / 2 = 1.5</code>)</p></td>
</tr>
<tr>
<td><p><code>//</code></p></td>
<td><p><code>np.floor_divide</code></p></td>
<td><p>Floor division (e.g., <code>3 // 2 = 1</code>)</p></td>
</tr>
<tr>
<td><p><code>**</code></p></td>
<td><p><code>np.power</code></p></td>
<td><p>Exponentiation (e.g., <code>2 ** 3 = 8</code>)</p></td>
</tr>
<tr>
<td><p><code>%</code></p></td>
<td><p><code>np.mod</code></p></td>
<td><p>Modulus/remainder (e.g., <code>9 % 4 = 1</code>)</p></td>
</tr>
</tbody>
</table>
<p>Additionally, there are Boolean/bitwise operators; we will explore these
in <a data-type="xref" href="ch09.xhtml#section-0206-boolean-arrays-and-masks">Chapter 9</a>.</p>
</div></section>
<section data-pdf-bookmark="Absolute Value" data-type="sect2"><div class="sect2" id="ch_0203-computation-on-arrays-ufuncs_absolute-value">
<h2>Absolute Value</h2>
<p><a data-primary="absolute value function" data-type="indexterm" id="idm45858804530640"/><a data-primary="universal functions (ufuncs)" data-secondary="absolute value" data-type="indexterm" id="idm45858804529936"/>Just as NumPy understands Python’s built-in arithmetic
operators, it also understands Python’s built-in absolute
value function:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="o">-</code><code class="mi">2</code><code class="p">,</code> <code class="o">-</code><code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">])</code>
         <code class="nb">abs</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mi">2</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">])</code></pre>
<p>The corresponding NumPy ufunc is <code>np.absolute</code>, which is also available
under the alias <code>np.abs</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">absolute</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mi">2</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">abs</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mi">2</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">])</code></pre>
<p>This ufunc can also handle complex data, in which case it returns the
magnitude:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mi">3</code> <code class="o">-</code> <code class="mi">4</code><code class="n">j</code><code class="p">,</code> <code class="mi">4</code> <code class="o">-</code> <code class="mi">3</code><code class="n">j</code><code class="p">,</code> <code class="mi">2</code> <code class="o">+</code> <code class="mi">0</code><code class="n">j</code><code class="p">,</code> <code class="mi">0</code> <code class="o">+</code> <code class="mi">1</code><code class="n">j</code><code class="p">])</code>
         <code class="n">np</code><code class="o">.</code><code class="n">abs</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mf">5.</code><code class="p">,</code> <code class="mf">5.</code><code class="p">,</code> <code class="mf">2.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">])</code></pre>
</div></section>
<section data-pdf-bookmark="Trigonometric Functions" data-type="sect2"><div class="sect2" id="ch_0203-computation-on-arrays-ufuncs_trigonometric-functions">
<h2>Trigonometric Functions</h2>
<p><a data-primary="trigonometric functions" data-type="indexterm" id="idm45858804305408"/><a data-primary="universal functions (ufuncs)" data-secondary="trigonometric functions" data-type="indexterm" id="idm45858804304704"/>NumPy provides a large number of useful ufuncs, and some of the most
useful for the data scientist are the trigonometric functions.
We’ll start by defining an array of angles:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="n">theta</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">linspace</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">pi</code><code class="p">,</code> <code class="mi">3</code><code class="p">)</code></pre>
<p>Now we can compute some trigonometric functions on these values:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="nb">print</code><code class="p">(</code><code class="s2">"theta      = "</code><code class="p">,</code> <code class="n">theta</code><code class="p">)</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"sin(theta) = "</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">sin</code><code class="p">(</code><code class="n">theta</code><code class="p">))</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"cos(theta) = "</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">cos</code><code class="p">(</code><code class="n">theta</code><code class="p">))</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"tan(theta) = "</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">tan</code><code class="p">(</code><code class="n">theta</code><code class="p">))</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="n">theta</code>      <code class="o">=</code>  <code class="p">[</code><code class="mf">0.</code>         <code class="mf">1.57079633</code> <code class="mf">3.14159265</code><code class="p">]</code>
         <code class="n">sin</code><code class="p">(</code><code class="n">theta</code><code class="p">)</code> <code class="o">=</code>  <code class="p">[</code><code class="mf">0.0000000e+00</code> <code class="mf">1.0000000e+00</code> <code class="mf">1.2246468e-16</code><code class="p">]</code>
         <code class="n">cos</code><code class="p">(</code><code class="n">theta</code><code class="p">)</code> <code class="o">=</code>  <code class="p">[</code> <code class="mf">1.000000e+00</code>  <code class="mf">6.123234e-17</code> <code class="o">-</code><code class="mf">1.000000e+00</code><code class="p">]</code>
         <code class="n">tan</code><code class="p">(</code><code class="n">theta</code><code class="p">)</code> <code class="o">=</code>  <code class="p">[</code> <code class="mf">0.00000000e+00</code>  <code class="mf">1.63312394e+16</code> <code class="o">-</code><code class="mf">1.22464680e-16</code><code class="p">]</code></pre>
<p>The values are computed to within machine precision, which is why values
that should be zero do not always hit exactly zero. Inverse
trigonometric functions are also available:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="p">[</code><code class="o">-</code><code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">]</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"x         = "</code><code class="p">,</code> <code class="n">x</code><code class="p">)</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"arcsin(x) = "</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">arcsin</code><code class="p">(</code><code class="n">x</code><code class="p">))</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"arccos(x) = "</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">arccos</code><code class="p">(</code><code class="n">x</code><code class="p">))</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"arctan(x) = "</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">arctan</code><code class="p">(</code><code class="n">x</code><code class="p">))</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="n">x</code>         <code class="o">=</code>  <code class="p">[</code><code class="o">-</code><code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">]</code>
         <code class="n">arcsin</code><code class="p">(</code><code class="n">x</code><code class="p">)</code> <code class="o">=</code>  <code class="p">[</code><code class="o">-</code><code class="mf">1.57079633</code>  <code class="mf">0.</code>          <code class="mf">1.57079633</code><code class="p">]</code>
         <code class="n">arccos</code><code class="p">(</code><code class="n">x</code><code class="p">)</code> <code class="o">=</code>  <code class="p">[</code><code class="mf">3.14159265</code> <code class="mf">1.57079633</code> <code class="mf">0.</code>        <code class="p">]</code>
         <code class="n">arctan</code><code class="p">(</code><code class="n">x</code><code class="p">)</code> <code class="o">=</code>  <code class="p">[</code><code class="o">-</code><code class="mf">0.78539816</code>  <code class="mf">0.</code>          <code class="mf">0.78539816</code><code class="p">]</code></pre>
</div></section>
<section data-pdf-bookmark="Exponents and Logarithms" data-type="sect2"><div class="sect2" id="ch_0203-computation-on-arrays-ufuncs_exponents-and-logarithms">
<h2>Exponents and Logarithms</h2>
<p><a data-primary="exponentials" data-type="indexterm" id="idm45858804037504"/><a data-primary="universal functions (ufuncs)" data-secondary="exponentials" data-type="indexterm" id="idm45858804036832"/>Other common operations available in NumPy ufuncs are the exponentials:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">18</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"x   ="</code><code class="p">,</code> <code class="n">x</code><code class="p">)</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"e^x ="</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">exp</code><code class="p">(</code><code class="n">x</code><code class="p">))</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"2^x ="</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">exp2</code><code class="p">(</code><code class="n">x</code><code class="p">))</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"3^x ="</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">power</code><code class="p">(</code><code class="mf">3.</code><code class="p">,</code> <code class="n">x</code><code class="p">))</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">18</code><code class="p">]:</code> <code class="n">x</code>   <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]</code>
         <code class="n">e</code><code class="o">^</code><code class="n">x</code> <code class="o">=</code> <code class="p">[</code> <code class="mf">2.71828183</code>  <code class="mf">7.3890561</code>  <code class="mf">20.08553692</code><code class="p">]</code>
         <code class="mi">2</code><code class="o">^</code><code class="n">x</code> <code class="o">=</code> <code class="p">[</code><code class="mf">2.</code> <code class="mf">4.</code> <code class="mf">8.</code><code class="p">]</code>
         <code class="mi">3</code><code class="o">^</code><code class="n">x</code> <code class="o">=</code> <code class="p">[</code> <code class="mf">3.</code>  <code class="mf">9.</code> <code class="mf">27.</code><code class="p">]</code></pre>
<p><a data-primary="logarithms" data-type="indexterm" id="idm45858803949488"/><a data-primary="universal functions (ufuncs)" data-secondary="logarithms" data-type="indexterm" id="idm45858803948880"/>The inverse of the exponentials, the logarithms, are also available. The
basic <code>np.log</code> gives the natural logarithm; if you prefer to compute the
base-2 logarithm or the base-10 logarithm, these are available as well:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">19</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">10</code><code class="p">]</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"x        ="</code><code class="p">,</code> <code class="n">x</code><code class="p">)</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"ln(x)    ="</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">log</code><code class="p">(</code><code class="n">x</code><code class="p">))</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"log2(x)  ="</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">log2</code><code class="p">(</code><code class="n">x</code><code class="p">))</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"log10(x) ="</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">log10</code><code class="p">(</code><code class="n">x</code><code class="p">))</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">19</code><code class="p">]:</code> <code class="n">x</code>        <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">10</code><code class="p">]</code>
         <code class="n">ln</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>    <code class="o">=</code> <code class="p">[</code><code class="mf">0.</code>         <code class="mf">0.69314718</code> <code class="mf">1.38629436</code> <code class="mf">2.30258509</code><code class="p">]</code>
         <code class="n">log2</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>  <code class="o">=</code> <code class="p">[</code><code class="mf">0.</code>         <code class="mf">1.</code>         <code class="mf">2.</code>         <code class="mf">3.32192809</code><code class="p">]</code>
         <code class="n">log10</code><code class="p">(</code><code class="n">x</code><code class="p">)</code> <code class="o">=</code> <code class="p">[</code><code class="mf">0.</code>         <code class="mf">0.30103</code>    <code class="mf">0.60205999</code> <code class="mf">1.</code>        <code class="p">]</code></pre>
<p>There are also some specialized versions that are useful for maintaining
precision with very small input:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">20</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mf">0.001</code><code class="p">,</code> <code class="mf">0.01</code><code class="p">,</code> <code class="mf">0.1</code><code class="p">]</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"exp(x) - 1 ="</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">expm1</code><code class="p">(</code><code class="n">x</code><code class="p">))</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"log(1 + x) ="</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">log1p</code><code class="p">(</code><code class="n">x</code><code class="p">))</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">20</code><code class="p">]:</code> <code class="n">exp</code><code class="p">(</code><code class="n">x</code><code class="p">)</code> <code class="o">-</code> <code class="mi">1</code> <code class="o">=</code> <code class="p">[</code><code class="mf">0.</code>         <code class="mf">0.0010005</code>  <code class="mf">0.01005017</code> <code class="mf">0.10517092</code><code class="p">]</code>
         <code class="n">log</code><code class="p">(</code><code class="mi">1</code> <code class="o">+</code> <code class="n">x</code><code class="p">)</code> <code class="o">=</code> <code class="p">[</code><code class="mf">0.</code>         <code class="mf">0.0009995</code>  <code class="mf">0.00995033</code> <code class="mf">0.09531018</code><code class="p">]</code></pre>
<p>When <code>x</code> is very small, these functions give more precise values than if
the raw <code>np.log</code> or <code>np.exp</code> were to be used.</p>
</div></section>
<section data-pdf-bookmark="Specialized Ufuncs" data-type="sect2"><div class="sect2" id="ch_0203-computation-on-arrays-ufuncs_specialized-ufuncs">
<h2>Specialized Ufuncs</h2>
<p><a data-primary="universal functions (ufuncs)" data-secondary="specialized ufuncs" data-type="indexterm" id="idm45858803618960"/>NumPy has many more ufuncs available, including for hyperbolic
trigonometry, bitwise arithmetic, comparison operations, conversions
from radians to degrees, rounding and remainders, and much more. A look
through the NumPy documentation reveals a lot of interesting
functionality.</p>
<p><a data-primary="scipy.special submodule" data-type="indexterm" id="idm45858803617632"/>Another excellent source for more specialized ufuncs is the submodule
<code>scipy.special</code>. If you want to compute some obscure mathematical
function on your data, chances are it is implemented in <code>scipy.special</code>.
There are far too many functions to list them all, but the following
snippet shows a couple that might come up in a statistics context:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">21</code><code class="p">]:</code> <code class="kn">from</code> <code class="nn">scipy</code> <code class="kn">import</code> <code class="n">special</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">22</code><code class="p">]:</code> <code class="c1"># Gamma functions (generalized factorials) and related functions</code>
         <code class="n">x</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">10</code><code class="p">]</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"gamma(x)     ="</code><code class="p">,</code> <code class="n">special</code><code class="o">.</code><code class="n">gamma</code><code class="p">(</code><code class="n">x</code><code class="p">))</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"ln|gamma(x)| ="</code><code class="p">,</code> <code class="n">special</code><code class="o">.</code><code class="n">gammaln</code><code class="p">(</code><code class="n">x</code><code class="p">))</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"beta(x, 2)   ="</code><code class="p">,</code> <code class="n">special</code><code class="o">.</code><code class="n">beta</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="mi">2</code><code class="p">))</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">22</code><code class="p">]:</code> <code class="n">gamma</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>     <code class="o">=</code> <code class="p">[</code><code class="mf">1.0000e+00</code> <code class="mf">2.4000e+01</code> <code class="mf">3.6288e+05</code><code class="p">]</code>
         <code class="n">ln</code><code class="o">|</code><code class="n">gamma</code><code class="p">(</code><code class="n">x</code><code class="p">)</code><code class="o">|</code> <code class="o">=</code> <code class="p">[</code> <code class="mf">0.</code>          <code class="mf">3.17805383</code> <code class="mf">12.80182748</code><code class="p">]</code>
         <code class="n">beta</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code>   <code class="o">=</code> <code class="p">[</code><code class="mf">0.5</code>        <code class="mf">0.03333333</code> <code class="mf">0.00909091</code><code class="p">]</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">23</code><code class="p">]:</code> <code class="c1"># Error function (integral of Gaussian),</code>
         <code class="c1"># its complement, and its inverse</code>
         <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mi">0</code><code class="p">,</code> <code class="mf">0.3</code><code class="p">,</code> <code class="mf">0.7</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">])</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"erf(x)  ="</code><code class="p">,</code> <code class="n">special</code><code class="o">.</code><code class="n">erf</code><code class="p">(</code><code class="n">x</code><code class="p">))</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"erfc(x) ="</code><code class="p">,</code> <code class="n">special</code><code class="o">.</code><code class="n">erfc</code><code class="p">(</code><code class="n">x</code><code class="p">))</code>
         <code class="nb">print</code><code class="p">(</code><code class="s2">"erfinv(x) ="</code><code class="p">,</code> <code class="n">special</code><code class="o">.</code><code class="n">erfinv</code><code class="p">(</code><code class="n">x</code><code class="p">))</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">23</code><code class="p">]:</code> <code class="n">erf</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>  <code class="o">=</code> <code class="p">[</code><code class="mf">0.</code>         <code class="mf">0.32862676</code> <code class="mf">0.67780119</code> <code class="mf">0.84270079</code><code class="p">]</code>
         <code class="n">erfc</code><code class="p">(</code><code class="n">x</code><code class="p">)</code> <code class="o">=</code> <code class="p">[</code><code class="mf">1.</code>         <code class="mf">0.67137324</code> <code class="mf">0.32219881</code> <code class="mf">0.15729921</code><code class="p">]</code>
         <code class="n">erfinv</code><code class="p">(</code><code class="n">x</code><code class="p">)</code> <code class="o">=</code> <code class="p">[</code><code class="mf">0.</code>         <code class="mf">0.27246271</code> <code class="mf">0.73286908</code>        <code class="n">inf</code><code class="p">]</code></pre>
<p>There are many, many more ufuncs available in both NumPy and
<code>scipy.special</code>. Because the documentation of these packages is
available online, a web search along the lines of “gamma function
python” will generally find the relevant information.<a data-startref="ix_ch06-asciidoc5" data-type="indexterm" id="idm45858803360736"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Advanced Ufunc Features" data-type="sect1"><div class="sect1" id="ch_0203-computation-on-arrays-ufuncs_advanced-ufunc-features">
<h1>Advanced Ufunc Features</h1>
<p><a data-primary="universal functions (ufuncs)" data-secondary="advanced features" data-type="indexterm" id="ix_ch06-asciidoc6"/>Many NumPy users make use of ufuncs without ever learning their full set
of features. I’ll outline a few specialized features of
ufuncs here.</p>
<section data-pdf-bookmark="Specifying Output" data-type="sect2"><div class="sect2" id="ch_0203-computation-on-arrays-ufuncs_specifying-output">
<h2>Specifying Output</h2>
<p><a data-primary="arrays" data-secondary="specifying output to" data-type="indexterm" id="idm45858803309088"/><a data-primary="universal functions (ufuncs)" data-secondary="specifying output" data-type="indexterm" id="idm45858803308112"/>For large calculations, it is sometimes useful to be able to specify the
array where the result of the calculation will be stored. For all
ufuncs, this can be done using the <code>out</code> argument of the function:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">24</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code>
         <code class="n">y</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">empty</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code>
         <code class="n">np</code><code class="o">.</code><code class="n">multiply</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="n">out</code><code class="o">=</code><code class="n">y</code><code class="p">)</code>
         <code class="nb">print</code><code class="p">(</code><code class="n">y</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">24</code><code class="p">]:</code> <code class="p">[</code> <code class="mf">0.</code> <code class="mf">10.</code> <code class="mf">20.</code> <code class="mf">30.</code> <code class="mf">40.</code><code class="p">]</code></pre>
<p class="pagebreak-before less_space">This can even be used with array views. For example, we can write the
results of a computation to every other element of a specified array:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">25</code><code class="p">]:</code> <code class="n">y</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">zeros</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code>
         <code class="n">np</code><code class="o">.</code><code class="n">power</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="n">x</code><code class="p">,</code> <code class="n">out</code><code class="o">=</code><code class="n">y</code><code class="p">[::</code><code class="mi">2</code><code class="p">])</code>
         <code class="nb">print</code><code class="p">(</code><code class="n">y</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">25</code><code class="p">]:</code> <code class="p">[</code> <code class="mf">1.</code>  <code class="mf">0.</code>  <code class="mf">2.</code>  <code class="mf">0.</code>  <code class="mf">4.</code>  <code class="mf">0.</code>  <code class="mf">8.</code>  <code class="mf">0.</code> <code class="mf">16.</code>  <code class="mf">0.</code><code class="p">]</code></pre>
<p>If we had instead written <code>y[::2] = 2 ** x</code>, this would have resulted in
the creation of a temporary array to hold the results of <code>2 ** x</code>,
followed by a second operation copying those values into the <code>y</code> array.
This doesn’t make much of a difference for such a small
computation, but for very large arrays the memory savings from careful
use of the <code>out</code> argument can be significant.</p>
</div></section>
<section data-pdf-bookmark="Aggregations" data-type="sect2"><div class="sect2" id="ch_0203-computation-on-arrays-ufuncs_aggregations">
<h2>Aggregations</h2>
<p><a data-primary="aggregates" data-secondary="computed directly from object" data-type="indexterm" id="idm45858803138128"/><a data-primary="universal functions (ufuncs)" data-secondary="aggregates" data-type="indexterm" id="idm45858803137184"/>For binary ufuncs, aggregations can be computed directly from the
object. <a data-primary="reduce() method" data-type="indexterm" id="idm45858803136144"/>For example, if we’d like to <em>reduce</em> an array with
a particular operation, we can use the <code>reduce</code> method of any ufunc. A
reduce repeatedly applies a given operation to the elements of an array
until only a single result remains.</p>
<p>For example, calling <code>reduce</code> on the <code>add</code> ufunc returns the sum of all
elements in the array:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">26</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">6</code><code class="p">)</code>
         <code class="n">np</code><code class="o">.</code><code class="n">add</code><code class="o">.</code><code class="n">reduce</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">26</code><code class="p">]:</code> <code class="mi">15</code></pre>
<p>Similarly, calling <code>reduce</code> on the <code>multiply</code> ufunc results in the
product of all array elements:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">27</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">multiply</code><code class="o">.</code><code class="n">reduce</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">27</code><code class="p">]:</code> <code class="mi">120</code></pre>
<p>If we’d like to store all the intermediate results of the
computation, we can instead use <code>accumulate</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">28</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">add</code><code class="o">.</code><code class="n">accumulate</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">28</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code> <code class="mi">1</code><code class="p">,</code>  <code class="mi">3</code><code class="p">,</code>  <code class="mi">6</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">15</code><code class="p">])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">29</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">multiply</code><code class="o">.</code><code class="n">accumulate</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">29</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code>  <code class="mi">1</code><code class="p">,</code>   <code class="mi">2</code><code class="p">,</code>   <code class="mi">6</code><code class="p">,</code>  <code class="mi">24</code><code class="p">,</code> <code class="mi">120</code><code class="p">])</code></pre>
<p>Note that for these particular cases, there are dedicated NumPy
functions to compute the results (<code>np.sum</code>, <code>np.prod</code>, <code>np.cumsum</code>,
<code>np.cumprod</code>), which we’ll explore in

<span class="keep-together"><a data-type="xref" href="ch07.xhtml#section-0204-computation-on-arrays-aggregates">Chapter 7</a></span>.</p>
</div></section>
<section class="pagebreak-before less_space" data-pdf-bookmark="Outer Products" data-type="sect2"><div class="sect2" id="ch_0203-computation-on-arrays-ufuncs_outer-products">
<h2>Outer Products</h2>
<p><a data-primary="outer products" data-type="indexterm" id="idm45858802918288"/><a data-primary="universal functions (ufuncs)" data-secondary="outer products" data-type="indexterm" id="idm45858802917584"/>Finally, any ufunc can compute the output of all pairs of two different
inputs using the <code>outer</code> method. This allows you, in one line, to do
things like create a multiplication table:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">30</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">6</code><code class="p">)</code>
         <code class="n">np</code><code class="o">.</code><code class="n">multiply</code><code class="o">.</code><code class="n">outer</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">x</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">30</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code> <code class="mi">1</code><code class="p">,</code>  <code class="mi">2</code><code class="p">,</code>  <code class="mi">3</code><code class="p">,</code>  <code class="mi">4</code><code class="p">,</code>  <code class="mi">5</code><code class="p">],</code>
                <code class="p">[</code> <code class="mi">2</code><code class="p">,</code>  <code class="mi">4</code><code class="p">,</code>  <code class="mi">6</code><code class="p">,</code>  <code class="mi">8</code><code class="p">,</code> <code class="mi">10</code><code class="p">],</code>
                <code class="p">[</code> <code class="mi">3</code><code class="p">,</code>  <code class="mi">6</code><code class="p">,</code>  <code class="mi">9</code><code class="p">,</code> <code class="mi">12</code><code class="p">,</code> <code class="mi">15</code><code class="p">],</code>
                <code class="p">[</code> <code class="mi">4</code><code class="p">,</code>  <code class="mi">8</code><code class="p">,</code> <code class="mi">12</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">20</code><code class="p">],</code>
                <code class="p">[</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">15</code><code class="p">,</code> <code class="mi">20</code><code class="p">,</code> <code class="mi">25</code><code class="p">]])</code></pre>
<p>The <code>ufunc.at</code> and <code>ufunc.reduceat</code> methods are useful as well, and we
will explore them in <a data-type="xref" href="ch10.xhtml#section-0207-fancy-indexing">Chapter 10</a>.</p>
<p><a data-primary="broadcasting" data-secondary="defined" data-type="indexterm" id="idm45858802788496"/>We will also encounter the ability of ufuncs to operate between arrays
of different shapes and sizes, a set of operations known as
<em>broadcasting</em>. This subject is important enough that we will devote a
whole chapter to it (see
<a data-type="xref" href="ch08.xhtml#section-0205-computation-on-arrays-broadcasting">Chapter 8</a>).<a data-startref="ix_ch06-asciidoc6" data-type="indexterm" id="idm45858802786208"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Ufuncs: Learning More" data-type="sect1"><div class="sect1" id="ch_0203-computation-on-arrays-ufuncs_ufuncs-learning-more">
<h1>Ufuncs: Learning More</h1>
<p>More information on universal functions (including the full list of
available functions) can be found on the <a href="http://www.numpy.org">NumPy</a> and
<a href="http://www.scipy.org">SciPy</a> documentation websites.</p>
<p>Recall that you can also access information directly from within IPython
by importing the packages and using IPython’s tab completion
and help (<code>?</code>) functionality, as described in
<a data-type="xref" href="ch01.xhtml#section-0101-help-and-documentation">Chapter 1</a>.<a data-startref="ix_ch06-asciidoc4" data-type="indexterm" id="idm45858802752640"/><a data-startref="ix_ch06-asciidoc3" data-type="indexterm" id="idm45858802751936"/><a data-startref="ix_ch06-asciidoc2" data-type="indexterm" id="idm45858802751264"/><a data-startref="ix_ch06-asciidoc1" data-type="indexterm" id="idm45858802750592"/><a data-startref="ix_ch06-asciidoc0" data-type="indexterm" id="idm45858802749920"/></p>
</div></section>
</div></section></div></body></html>