<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 12. Structured Data: NumPy’s &#10;Structured Arrays" data-type="chapter" epub:type="chapter"><div class="chapter" id="section-0209-structured-data-numpy">
<h1><span class="label">Chapter 12. </span>Structured Data: NumPy’s 
<span class="keep-together">Structured Arrays</span></h1>
<p><a data-primary="arrays" data-secondary="structured" data-type="indexterm" id="ix_ch12-asciidoc0"/><a data-primary="NumPy" data-secondary="structured arrays" data-type="indexterm" id="ix_ch12-asciidoc1"/><a data-primary="structured arrays" data-type="indexterm" id="ix_ch12-asciidoc2"/>While often our data can be well represented by a homogeneous array of
values, sometimes this is not the case. This chapter demonstrates the
use of NumPy’s <em>structured arrays</em> and <em>record arrays</em>,
which provide efficient storage for compound, heterogeneous data. While
the patterns shown here are useful for simple operations, scenarios like
this often lend themselves to the use of Pandas <code>DataFrame</code>s, which
we’ll explore in
<a data-type="xref" href="part03.xhtml#section-0300-introduction-to-pandas">Part III</a>.</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code></pre>
<p>Imagine that we have several categories of data on a number of people
(say, name, age, and weight), and we’d like to store these
values for use in a Python program. It would be possible to store these
in three separate arrays:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="n">name</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'Alice'</code><code class="p">,</code> <code class="s1">'Bob'</code><code class="p">,</code> <code class="s1">'Cathy'</code><code class="p">,</code> <code class="s1">'Doug'</code><code class="p">]</code>
        <code class="n">age</code> <code class="o">=</code> <code class="p">[</code><code class="mi">25</code><code class="p">,</code> <code class="mi">45</code><code class="p">,</code> <code class="mi">37</code><code class="p">,</code> <code class="mi">19</code><code class="p">]</code>
        <code class="n">weight</code> <code class="o">=</code> <code class="p">[</code><code class="mf">55.0</code><code class="p">,</code> <code class="mf">85.5</code><code class="p">,</code> <code class="mf">68.0</code><code class="p">,</code> <code class="mf">61.5</code><code class="p">]</code></pre>
<p>But this is a bit clumsy. There’s nothing here that tells us
that the three arrays are related; NumPy’s structured arrays
allow us to do this more naturally by using a single structure to store
all of this data.</p>
<p>Recall that previously we created a simple array using an expression
like this:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">zeros</code><code class="p">(</code><code class="mi">4</code><code class="p">,</code> <code class="n">dtype</code><code class="o">=</code><code class="nb">int</code><code class="p">)</code></pre>
<p>We can similarly create a structured array using a compound data type
specification:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="c1"># Use a compound data type for structured arrays</code>
        <code class="n">data</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">zeros</code><code class="p">(</code><code class="mi">4</code><code class="p">,</code> <code class="n">dtype</code><code class="o">=</code><code class="p">{</code><code class="s1">'names'</code><code class="p">:(</code><code class="s1">'name'</code><code class="p">,</code> <code class="s1">'age'</code><code class="p">,</code> <code class="s1">'weight'</code><code class="p">),</code>
                                  <code class="s1">'formats'</code><code class="p">:(</code><code class="s1">'U10'</code><code class="p">,</code> <code class="s1">'i4'</code><code class="p">,</code> <code class="s1">'f8'</code><code class="p">)})</code>
        <code class="nb">print</code><code class="p">(</code><code class="n">data</code><code class="o">.</code><code class="n">dtype</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="p">[(</code><code class="s1">'name'</code><code class="p">,</code> <code class="s1">'&lt;U10'</code><code class="p">),</code> <code class="p">(</code><code class="s1">'age'</code><code class="p">,</code> <code class="s1">'&lt;i4'</code><code class="p">),</code> <code class="p">(</code><code class="s1">'weight'</code><code class="p">,</code> <code class="s1">'&lt;f8'</code><code class="p">)]</code></pre>
<p>Here <code>'U10'</code> translates to “Unicode string of
maximum length 10,” <code>'i4'</code> translates to
“4-byte (i.e., 32-bit) integer,” and <code>'f8'</code>
translates to “8-byte (i.e., 64-bit) float.” We’ll discuss
other options for these type codes in the following section.</p>
<p>Now that we’ve created an empty container array, we can fill
the array with our lists of values:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">data</code><code class="p">[</code><code class="s1">'name'</code><code class="p">]</code> <code class="o">=</code> <code class="n">name</code>
        <code class="n">data</code><code class="p">[</code><code class="s1">'age'</code><code class="p">]</code> <code class="o">=</code> <code class="n">age</code>
        <code class="n">data</code><code class="p">[</code><code class="s1">'weight'</code><code class="p">]</code> <code class="o">=</code> <code class="n">weight</code>
        <code class="nb">print</code><code class="p">(</code><code class="n">data</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="p">[(</code><code class="s1">'Alice'</code><code class="p">,</code> <code class="mi">25</code><code class="p">,</code> <code class="mf">55.</code> <code class="p">)</code> <code class="p">(</code><code class="s1">'Bob'</code><code class="p">,</code> <code class="mi">45</code><code class="p">,</code> <code class="mf">85.5</code><code class="p">)</code> <code class="p">(</code><code class="s1">'Cathy'</code><code class="p">,</code> <code class="mi">37</code><code class="p">,</code> <code class="mf">68.</code> <code class="p">)</code>
         <code class="p">(</code><code class="s1">'Doug'</code><code class="p">,</code> <code class="mi">19</code><code class="p">,</code> <code class="mf">61.5</code><code class="p">)]</code></pre>
<p>As we had hoped, the data is now conveniently arranged in one structured
array.</p>
<p>The handy thing with structured arrays is that we can now refer to
values either by index or by name:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="c1"># Get all names</code>
        <code class="n">data</code><code class="p">[</code><code class="s1">'name'</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="s1">'Alice'</code><code class="p">,</code> <code class="s1">'Bob'</code><code class="p">,</code> <code class="s1">'Cathy'</code><code class="p">,</code> <code class="s1">'Doug'</code><code class="p">],</code> <code class="n">dtype</code><code class="o">=</code><code class="s1">'&lt;U10'</code><code class="p">)</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="c1"># Get first row of data</code>
        <code class="n">data</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="p">(</code><code class="s1">'Alice'</code><code class="p">,</code> <code class="mi">25</code><code class="p">,</code> <code class="mf">55.</code><code class="p">)</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="c1"># Get the name from the last row</code>
        <code class="n">data</code><code class="p">[</code><code class="o">-</code><code class="mi">1</code><code class="p">][</code><code class="s1">'name'</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="s1">'Doug'</code></pre>
<p>Using Boolean masking, we can even do some more sophisticated
operations, such as filtering on age:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="c1"># Get names where age is under 30</code>
        <code class="n">data</code><code class="p">[</code><code class="n">data</code><code class="p">[</code><code class="s1">'age'</code><code class="p">]</code> <code class="o">&lt;</code> <code class="mi">30</code><code class="p">][</code><code class="s1">'name'</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="s1">'Alice'</code><code class="p">,</code> <code class="s1">'Doug'</code><code class="p">],</code> <code class="n">dtype</code><code class="o">=</code><code class="s1">'&lt;U10'</code><code class="p">)</code></pre>
<p>If you’d like to do any operations that are any more
complicated than these, you should probably consider the Pandas package,
covered in <a data-type="xref" href="part04.xhtml#section-0400-introduction-to-matplotlib">Part IV</a>. As
you’ll see, Pandas provides a <code>DataFrame</code> object, which is a
structure built on NumPy arrays that offers a variety of useful data
manipulation functionality similar to what you’ve seen here,
as well as much, much more.</p>
<section class="pagebreak-before less_space" data-pdf-bookmark="Exploring Structured Array Creation" data-type="sect1"><div class="sect1" id="ch_0209-structured-data-numpy_exploring-structured-array-creation">
<h1>Exploring Structured Array Creation</h1>
<p><a data-primary="structured arrays" data-secondary="creating" data-type="indexterm" id="idm45858793208720"/>Structured array data types can be specified in a number of ways.
Earlier, we saw the dictionary method:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">dtype</code><code class="p">({</code><code class="s1">'names'</code><code class="p">:(</code><code class="s1">'name'</code><code class="p">,</code> <code class="s1">'age'</code><code class="p">,</code> <code class="s1">'weight'</code><code class="p">),</code>
                   <code class="s1">'formats'</code><code class="p">:(</code><code class="s1">'U10'</code><code class="p">,</code> <code class="s1">'i4'</code><code class="p">,</code> <code class="s1">'f8'</code><code class="p">)})</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">dtype</code><code class="p">([(</code><code class="s1">'name'</code><code class="p">,</code> <code class="s1">'&lt;U10'</code><code class="p">),</code> <code class="p">(</code><code class="s1">'age'</code><code class="p">,</code> <code class="s1">'&lt;i4'</code><code class="p">),</code> <code class="p">(</code><code class="s1">'weight'</code><code class="p">,</code> <code class="s1">'&lt;f8'</code><code class="p">)])</code></pre>
<p>For clarity, numerical types can be specified using Python types or
NumPy <code>dtype</code>s instead:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">dtype</code><code class="p">({</code><code class="s1">'names'</code><code class="p">:(</code><code class="s1">'name'</code><code class="p">,</code> <code class="s1">'age'</code><code class="p">,</code> <code class="s1">'weight'</code><code class="p">),</code>
                   <code class="s1">'formats'</code><code class="p">:((</code><code class="n">np</code><code class="o">.</code><code class="n">str_</code><code class="p">,</code> <code class="mi">10</code><code class="p">),</code> <code class="nb">int</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">float32</code><code class="p">)})</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">dtype</code><code class="p">([(</code><code class="s1">'name'</code><code class="p">,</code> <code class="s1">'&lt;U10'</code><code class="p">),</code> <code class="p">(</code><code class="s1">'age'</code><code class="p">,</code> <code class="s1">'&lt;i8'</code><code class="p">),</code> <code class="p">(</code><code class="s1">'weight'</code><code class="p">,</code> <code class="s1">'&lt;f4'</code><code class="p">)])</code></pre>
<p>A compound type can also be specified as a list of tuples:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">dtype</code><code class="p">([(</code><code class="s1">'name'</code><code class="p">,</code> <code class="s1">'S10'</code><code class="p">),</code> <code class="p">(</code><code class="s1">'age'</code><code class="p">,</code> <code class="s1">'i4'</code><code class="p">),</code> <code class="p">(</code><code class="s1">'weight'</code><code class="p">,</code> <code class="s1">'f8'</code><code class="p">)])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="n">dtype</code><code class="p">([(</code><code class="s1">'name'</code><code class="p">,</code> <code class="s1">'S10'</code><code class="p">),</code> <code class="p">(</code><code class="s1">'age'</code><code class="p">,</code> <code class="s1">'&lt;i4'</code><code class="p">),</code> <code class="p">(</code><code class="s1">'weight'</code><code class="p">,</code> <code class="s1">'&lt;f8'</code><code class="p">)])</code></pre>
<p>If the names of the types do not matter to you, you can specify the
types alone in a comma-separated string:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">dtype</code><code class="p">(</code><code class="s1">'S10,i4,f8'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="n">dtype</code><code class="p">([(</code><code class="s1">'f0'</code><code class="p">,</code> <code class="s1">'S10'</code><code class="p">),</code> <code class="p">(</code><code class="s1">'f1'</code><code class="p">,</code> <code class="s1">'&lt;i4'</code><code class="p">),</code> <code class="p">(</code><code class="s1">'f2'</code><code class="p">,</code> <code class="s1">'&lt;f8'</code><code class="p">)])</code></pre>
<p>The shortened string format codes may not be immediately intuitive, but
they are built on simple principles. The first (optional) character <code>&lt;</code>
or <code>&gt;</code>, means “little endian” or “big endian,” respectively, and
specifies the ordering convention for significant bits. The next
character specifies the type of data: characters, bytes, ints, floating
points, and so on (see <a data-type="xref" href="#table-12-1">Table 12-1</a>). The last character or
characters represent the size of the object in bytes.</p>
<table id="table-12-1">
<caption><span class="label">Table 12-1. </span>NumPy data types</caption>
<thead>
<tr>
<th>Character</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>'b'</code></p></td>
<td><p>Byte</p></td>
<td><p><code>np.dtype('b')</code></p></td>
</tr>
<tr>
<td><p><code>'i'</code></p></td>
<td><p>Signed integer</p></td>
<td><p><code>np.dtype('i4') == np.int32</code></p></td>
</tr>
<tr>
<td><p><code>'u'</code></p></td>
<td><p>Unsigned integer</p></td>
<td><p><code>np.dtype('u1') == np.uint8</code></p></td>
</tr>
<tr>
<td><p><code>'f'</code></p></td>
<td><p>Floating point</p></td>
<td><p><code>np.dtype('f8') == np.int64</code></p></td>
</tr>
<tr>
<td><p><code>'c'</code></p></td>
<td><p>Complex floating point</p></td>
<td><p><code>np.dtype('c16') == np.complex128</code></p></td>
</tr>
<tr>
<td><p><code>'S'</code>, <code>'a'</code></p></td>
<td><p>String</p></td>
<td><p><code>np.dtype('S5')</code></p></td>
</tr>
<tr>
<td><p><code>'U'</code></p></td>
<td><p>Unicode string</p></td>
<td><p><code>np.dtype('U') == np.str_</code></p></td>
</tr>
<tr>
<td><p><code>'V'</code></p></td>
<td><p>Raw data (void)</p></td>
<td><p><code>np.dtype('V') == np.void</code></p></td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="More Advanced Compound Types" data-type="sect1"><div class="sect1" id="ch_0209-structured-data-numpy_more-advanced-compound-types">
<h1>More Advanced Compound Types</h1>
<p><a data-primary="structured arrays" data-secondary="advanced compound types" data-type="indexterm" id="idm45858792877584"/>It is possible to define even more advanced compound types. For example,
you can create a type where each element contains an array or matrix of
values. Here, we’ll create a data type with a <code>mat</code>
component consisting of a <math alttext="3 times 3">
<mrow>
<mn>3</mn>
<mo>×</mo>
<mn>3</mn>
</mrow>
</math> floating-point matrix:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="n">tp</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">dtype</code><code class="p">([(</code><code class="s1">'id'</code><code class="p">,</code> <code class="s1">'i8'</code><code class="p">),</code> <code class="p">(</code><code class="s1">'mat'</code><code class="p">,</code> <code class="s1">'f8'</code><code class="p">,</code> <code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="mi">3</code><code class="p">))])</code>
         <code class="n">X</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">zeros</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="n">dtype</code><code class="o">=</code><code class="n">tp</code><code class="p">)</code>
         <code class="nb">print</code><code class="p">(</code><code class="n">X</code><code class="p">[</code><code class="mi">0</code><code class="p">])</code>
         <code class="nb">print</code><code class="p">(</code><code class="n">X</code><code class="p">[</code><code class="s1">'mat'</code><code class="p">][</code><code class="mi">0</code><code class="p">])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="p">[[</code><code class="mf">0.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">],</code> <code class="p">[</code><code class="mf">0.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">],</code> <code class="p">[</code><code class="mf">0.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">]])</code>
         <code class="p">[[</code><code class="mf">0.</code> <code class="mf">0.</code> <code class="mf">0.</code><code class="p">]</code>
          <code class="p">[</code><code class="mf">0.</code> <code class="mf">0.</code> <code class="mf">0.</code><code class="p">]</code>
          <code class="p">[</code><code class="mf">0.</code> <code class="mf">0.</code> <code class="mf">0.</code><code class="p">]]</code></pre>
<p>Now each element in the <code>X</code> array consists of an <code>id</code> and a
<math alttext="3 times 3">
<mrow>
<mn>3</mn>
<mo>×</mo>
<mn>3</mn>
</mrow>
</math> matrix. Why would you use this rather than a
simple multidimensional array, or perhaps a Python dictionary? One
reason is that this NumPy <code>dtype</code> directly maps onto a C structure
definition, so the buffer containing the array content can be accessed
directly within an appropriately written C program. If you find yourself
writing a Python interface to a legacy C or Fortran library that
manipulates structured data, structured arrays can provide a powerful
interface.</p>
</div></section>
<section data-pdf-bookmark="Record Arrays: Structured Arrays with a Twist" data-type="sect1"><div class="sect1" id="ch_0209-structured-data-numpy_record-arrays-structured-arrays-with-a-twist">
<h1>Record Arrays: Structured Arrays with a Twist</h1>
<p><a data-primary="record arrays" data-type="indexterm" id="idm45858792750000"/><a data-primary="structured arrays" data-secondary="record arrays" data-type="indexterm" id="idm45858792749296"/>NumPy also provides record arrays (instances of the <code>np.recarray</code>
class), which are almost identical to the structured arrays just
described, but with one additional feature: fields can be accessed as
attributes rather than as dictionary keys. Recall that we previously
accessed the ages in our sample dataset by writing:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="n">data</code><code class="p">[</code><code class="s1">'age'</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mi">25</code><code class="p">,</code> <code class="mi">45</code><code class="p">,</code> <code class="mi">37</code><code class="p">,</code> <code class="mi">19</code><code class="p">],</code> <code class="n">dtype</code><code class="o">=</code><code class="n">int32</code><code class="p">)</code></pre>
<p>If we view our data as a record array instead, we can access this with
slightly fewer keystrokes:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="n">data_rec</code> <code class="o">=</code> <code class="n">data</code><code class="o">.</code><code class="n">view</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">recarray</code><code class="p">)</code>
         <code class="n">data_rec</code><code class="o">.</code><code class="n">age</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mi">25</code><code class="p">,</code> <code class="mi">45</code><code class="p">,</code> <code class="mi">37</code><code class="p">,</code> <code class="mi">19</code><code class="p">],</code> <code class="n">dtype</code><code class="o">=</code><code class="n">int32</code><code class="p">)</code></pre>
<p>The downside is that for record arrays, there is some extra overhead
involved in accessing the fields, even when using the same syntax:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="o">%</code><code class="k">timeit</code> data['age']
         <code class="o">%</code><code class="k">timeit</code> data_rec['age']
         <code class="o">%</code><code class="k">timeit</code> data_rec.age
<code class="n">Out</code><code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="mi">121</code> <code class="n">ns</code> <code class="err">±</code> <code class="mf">1.4</code> <code class="n">ns</code> <code class="n">per</code> <code class="n">loop</code> <code class="p">(</code><code class="n">mean</code> <code class="err">±</code> <code class="n">std</code><code class="o">.</code> <code class="n">dev</code><code class="o">.</code> <code class="n">of</code> <code class="mi">7</code> <code class="n">runs</code><code class="p">,</code> <code class="mi">1000000</code> <code class="n">loops</code> <code class="n">each</code><code class="p">)</code>
         <code class="mf">2.41</code> <code class="n">µs</code> <code class="err">±</code> <code class="mf">15.7</code> <code class="n">ns</code> <code class="n">per</code> <code class="n">loop</code> <code class="p">(</code><code class="n">mean</code> <code class="err">±</code> <code class="n">std</code><code class="o">.</code> <code class="n">dev</code><code class="o">.</code> <code class="n">of</code> <code class="mi">7</code> <code class="n">runs</code><code class="p">,</code> <code class="mi">100000</code> <code class="n">loops</code> <code class="n">each</code><code class="p">)</code>
         <code class="mf">3.98</code> <code class="n">µs</code> <code class="err">±</code> <code class="mf">20.5</code> <code class="n">ns</code> <code class="n">per</code> <code class="n">loop</code> <code class="p">(</code><code class="n">mean</code> <code class="err">±</code> <code class="n">std</code><code class="o">.</code> <code class="n">dev</code><code class="o">.</code> <code class="n">of</code> <code class="mi">7</code> <code class="n">runs</code><code class="p">,</code> <code class="mi">100000</code> <code class="n">loops</code> <code class="n">each</code><code class="p">)</code></pre>
<p>Whether the more convenient notation is worth the (slight) overhead will
depend on your own application.<a data-startref="ix_ch12-asciidoc2" data-type="indexterm" id="idm45858792605296"/><a data-startref="ix_ch12-asciidoc1" data-type="indexterm" id="idm45858792604688"/><a data-startref="ix_ch12-asciidoc0" data-type="indexterm" id="idm45858792482512"/></p>
</div></section>
<section data-pdf-bookmark="On to Pandas" data-type="sect1"><div class="sect1" id="ch_0209-structured-data-numpy_on-to-pandas">
<h1>On to Pandas</h1>
<p>This chapter on structured and record arrays is purposely located at the
end of this part of the book, because it leads so well into the next
package we will cover: Pandas. Structured arrays can come in handy in
certain situations, like when you’re using NumPy arrays to
map onto binary data formats in C, Fortran, or another language. But for
day-to-day use of structured data, the Pandas package is a much better
choice; we’ll explore it in depth in the chapters that
follow.</p>
</div></section>
</div></section></div></body></html>