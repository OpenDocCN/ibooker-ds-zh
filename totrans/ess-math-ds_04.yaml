- en: Chapter 4\. Linear Algebra
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。线性代数
- en: Changing gears a little bit, let’s venture away from probability and statistics
    and into linear algebra. Sometimes people confuse linear algebra with basic algebra,
    thinking maybe it has to do with plotting lines using the algebraic function *y*
    = *mx* + *b*. This is why linear algebra probably should have been called “vector
    algebra” or “matrix algebra” because it is much more abstract. Linear systems
    play a role but in a much more metaphysical way.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微转换一下思路，让我们远离概率和统计，进入线性代数领域。有时人们会混淆线性代数和基本代数，可能认为它与使用代数函数*y* = *mx* + *b*绘制线条有关。这就是为什么线性代数可能应该被称为“向量代数”或“矩阵代数”，因为它更加抽象。线性系统发挥作用，但以一种更加形而上的方式。
- en: So, what exactly is linear algebra? Well, *linear algebra* concerns itself with
    linear systems but represents them through vector spaces and matrices. If you
    do not know what a vector or a matrix is, do not worry! We will define and explore
    them in depth. Linear algebra is hugely fundamental to many applied areas of math,
    statistics, operations research, data science, and machine learning. When you
    work with data in any of these areas, you are using linear algebra and perhaps
    you may not even know it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，线性代数到底是什么？嗯，*线性代数*关注线性系统，但通过向量空间和矩阵来表示它们。如果你不知道什么是向量或矩阵，不用担心！我们将深入定义和探索它们。线性代数对于许多应用领域的数学、统计学、运筹学、数据科学和机器学习都至关重要。当你在这些领域中处理数据时，你正在使用线性代数，也许你甚至不知道。
- en: You can get away with not learning linear algebra for a while, using machine
    learning and statistics libraries that do it all for you. But if you are going
    to get intuition behind these black boxes and be more effective at working with
    data, understanding the fundamentals of linear algebra is inevitable. Linear algebra
    is an enormous topic that can fill thick textbooks, so of course we cannot gain
    total mastery in just one chapter of this book. However, we can learn enough to
    be more comfortable with it and navigate the data science domain effectively.
    There will also be opportunities to apply it in the remaining chapters in this
    book, including Chapters [5](ch05.xhtml#ch05) and [7](ch07.xhtml#ch07).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以暂时不学习线性代数，使用机器学习和统计库为你完成所有工作。但是，如果你想理解这些黑匣子背后的直觉，并更有效地处理数据，理解线性代数的基础是不可避免的。线性代数是一个庞大的主题，可以填满厚厚的教科书，所以当然我们不能在这本书的一章中完全掌握它。然而，我们可以学到足够多，以便更加熟练地应用它并有效地在数据科学领域中导航。在本书的剩余章节中，包括第[5](ch05.xhtml#ch05)章和第[7](ch07.xhtml#ch07)章，也将有机会应用它。
- en: What Is a Vector?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是向量？
- en: Simply put, a *vector* is an arrow in space with a specific direction and length,
    often representing a piece of data. It is the central building block of linear
    algebra, including matrices and linear transformations. In its fundamental form,
    it has no concept of location so always imagine its tail starts at the origin
    of a Cartesian plane (0,0).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，*向量*是空间中具有特定方向和长度的箭头，通常代表一段数据。它是线性代数的中心构建模块，包括矩阵和线性变换。在其基本形式中，它没有位置的概念，所以始终想象它的尾部从笛卡尔平面的原点（0,0）开始。
- en: '[Figure 4-1](#IcpsmEJwfp) shows a vector <math alttext="ModifyingAbove v With
    right-arrow"><mover accent="true"><mi>v</mi> <mo>→</mo></mover></math> that moves
    three steps in the horizontal direction and two steps in the vertical direction.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-1](#IcpsmEJwfp)展示了一个向量<math alttext="ModifyingAbove v With right-arrow"><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover></math>，它在水平方向移动三步，在垂直方向移动两步。'
- en: '![emds 0401](Images/emds_0401.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0401](Images/emds_0401.png)'
- en: Figure 4-1\. A simple vector
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-1。一个简单的向量
- en: To emphasize again, the purpose of the vector is to visually represent a piece
    of data. If you have a data record for the square footage of a house 18,000 square
    feet and its valuation $260,000, we could express that as a vector [18000, 2600000],
    stepping 18,000 steps in the horizontal direction and 260,000 steps in the vertical
    direction.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，向量的目的是直观地表示一段数据。如果你有一条房屋面积为18,000平方英尺，估值为26万美元的数据记录，我们可以将其表示为一个向量[18000,
    2600000]，在水平方向移动18000步，在垂直方向移动260000步。
- en: 'We declare a vector mathematically like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们数学上声明一个向量如下：
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr>
    <mtr><mtd><mi>y</mi></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr>
    <mtr><mtd><mi>y</mi></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></m></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
- en: We can declare a vector using a simple Python collection, like a Python list
    as shown in [Example 4-1](#BlpnGwdoVc).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用简单的Python集合，如Python列表，在[示例 4-1](#BlpnGwdoVc)中所示声明一个向量。
- en: Example 4-1\. Declaring a vector in Python using a list
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-1\. 使用列表在Python中声明向量
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, when we start doing mathematical computations with vectors, especially
    when doing tasks like machine learning, we should probably use the NumPy library
    as it is more efficient than plain Python. You can also use SymPy to perform linear
    algebra operations, and we will use it occasionally in this chapter when decimals
    become inconvenient. However, NumPy is what you will likely use in practice so
    that is what we will mainly stick to.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们开始对向量进行数学计算，特别是在执行诸如机器学习之类的任务时，我们应该使用NumPy库，因为它比纯Python更高效。您还可以使用SymPy执行线性代数运算，在本章中，当小数变得不方便时，我们偶尔会使用它。然而，在实践中，您可能主要使用NumPy，因此我们主要会坚持使用它。
- en: To declare a vector, you can use NumPy’s `array()` function and then can pass
    a collection of numbers to it as shown in [Example 4-2](#kAgRAsEUac).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个向量，您可以使用NumPy的`array()`函数，然后可以像[示例 4-2](#kAgRAsEUac)中所示传递一组数字给它。
- en: Example 4-2\. Declaring a vector in Python using NumPy
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-2\. 使用NumPy在Python中声明向量
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Python Is Slow, Its Numerical Libraries Are Not
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python速度慢，但其数值库不慢
- en: Python is a computationally slow language platform, as it does not compile to
    lower-level machine code and bytecode like Java, C#, C, etc. It is dynamically
    interpreted at runtime. However, Python’s numeric and scientific libraries are
    not slow. Libraries like NumPy are typically written in low-level languages like
    C and C++, hence why they are computationally efficient. Python really acts as
    “glue code” integrating these libraries for your tasks.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一个计算速度较慢的语言平台，因为它不像Java、C#、C等编译为较低级别的机器代码和字节码。它在运行时动态解释。然而，Python的数值和科学库并不慢。像NumPy这样的库通常是用低级语言如C和C++编写的，因此它们在计算上是高效的。Python实际上充当“胶水代码”，为您的任务集成这些库。
- en: A vector has countless practical applications. In physics, a vector is often
    thought of as a direction and magnitude. In math, it is a direction and scale
    on an XY plane, kind of like a movement. In computer science, it is an array of
    numbers storing data. The computer science context is the one we will become the
    most familiar with as data science professionals. However, it is important we
    never forget the visual aspect so we do not think of vectors as esoteric grids
    of numbers. Without a visual understanding, it is almost impossible to grasp many
    fundamental linear algebra concepts like linear dependence and determinants.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 向量有无数的实际应用。在物理学中，向量通常被认为是一个方向和大小。在数学中，它是XY平面上的一个方向和比例，有点像运动。在计算机科学中，它是存储数据的一组数字。作为数据科学专业人员，我们将最熟悉计算机科学的上下文。然而，重要的是我们永远不要忘记视觉方面，这样我们就不会把向量看作是神秘的数字网格。没有视觉理解，几乎不可能掌握许多基本的线性代数概念，如线性相关性和行列式。
- en: Here are some more examples of vectors. In [Figure 4-2](#pHSCTHSSvm) note that
    some of these vectors have negative directions on the X and Y scales. Vectors
    with negative directions will have an impact when we combine them later, essentially
    subtracting rather than adding them together.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些更多的向量示例。在[图 4-2](#pHSCTHSSvm)中，请注意一些向量在X和Y轴上具有负方向。具有负方向的向量在我们后面合并时会产生影响，基本上是相减而不是相加。
- en: '![emds 0402](Images/emds_0402.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0402](Images/emds_0402.png)'
- en: Figure 4-2\. A sampling of different vectors
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2\. 不同向量的抽样
- en: 'Note also vectors can exist on more than two dimensions. Next we declare a
    three-dimensional vector along axes x, y, and z:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，向量可以存在于超过两个维度。接下来我们声明一个沿着 x、y 和 z 轴的三维向量：
- en: <math alttext="ModifyingAbove v With right-arrow equals Start 3 By 1 Matrix
    1st Row  x 2nd Row  y 3rd Row  z EndMatrix equals Start 3 By 1 Matrix 1st Row  4
    2nd Row  1 3rd Row  2 EndMatrix" display="block"><mrow><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr>
    <mtr><mtd><mi>y</mi></mtd></mtr> <mtr><mtd><mi>z</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="ModifyingAbove v With right-arrow equals Start 3 By 1 Matrix
    1st Row  x 2nd Row  y 3rd Row  z EndMatrix equals Start 3 By 1 Matrix 1st Row  4
    2nd Row  1 3rd Row  2 EndMatrix" display="block"><mrow><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr>
    <mtr><mtd><mi>y</mi></mtd></mtr> <mtr><mtd><mi>z</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'To create this vector, we are stepping four steps in the x direction, one in
    the y direction, and two in the z direction. Here it is visualized in [Figure 4-3](#JQBuLSITaf).
    Note that we no longer are showing a vector on a two-dimensional grid but rather
    a three-dimensional space with three axes: x, y, and z.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个向量，我们在 x 方向走了四步，在 y 方向走了一步，在 z 方向走了两步。这在[图 4-3](#JQBuLSITaf)中有可视化展示。请注意，我们不再在二维网格上显示向量，而是在一个三维空间中，有三个轴：x、y
    和 z。
- en: '![emds 0403](Images/emds_0403.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0403](Images/emds_0403.png)'
- en: Figure 4-3\. A three-dimensional vector
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-3\. 一个三维向量
- en: Naturally, we can express this three-dimensional vector in Python using three
    numeric values, as declared in [Example 4-3](#eQMUWBhCIB).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以使用三个数值在 Python 中表示这个三维向量，就像在[示例 4-3](#eQMUWBhCIB)中声明的那样。
- en: Example 4-3\. Declaring a three-dimensional vector in Python using NumPy
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-3\. 在 Python 中使用 NumPy 声明一个三维向量
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Like many mathematical models, visualizing more than three dimensions is challenging
    and something we will not expend energy doing in this book. But numerically, it
    is still straightforward. [Example 4-4](#onWRdWVGdW) shows how we declare a five-dimensional
    vector mathematically in Python.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多数学模型一样，可视化超过三维是具有挑战性的，这是我们在本书中不会花费精力去做的事情。但从数字上来看，仍然很简单。[示例 4-4](#onWRdWVGdW)展示了我们如何在
    Python 中数学上声明一个五维向量。
- en: <math alttext="ModifyingAbove v With right-arrow equals Start 5 By 1 Matrix
    1st Row  6 2nd Row  1 3rd Row  5 4th Row  8 5th Row  3 EndMatrix" display="block"><mrow><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover> <mo>=</mo> <mfenced separators=""
    open="[" close="]"><mtable><mtr><mtd><mn>6</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>5</mn></mtd></mtr> <mtr><mtd><mn>8</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="ModifyingAbove v With right-arrow equals Start 5 By 1 Matrix
    1st Row  6 2nd Row  1 3rd Row  5 4th Row  8 5th Row  3 EndMatrix" display="block"><mrow><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover> <mo>=</mo> <mfenced separators=""
    open="[" close="]"><mtable><mtr><mtd><mn>6</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>5</mn></mtd></mtr> <mtr><mtd><mn>8</mn></mtd></mtr> <mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: Example 4-4\. Declaring a five-dimensional vector in Python using NumPy
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-4\. 在 Python 中使用 NumPy 声明一个五维向量
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Adding and Combining Vectors
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加和组合向量
- en: On their own, vectors are not terribly interesting. You express a direction
    and size, kind of like a movement in space. But when you start combining vectors,
    known as *vector addition*, it starts to get interesting. We effectively combine
    the movements of two vectors into a single vector.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 单独看，向量并不是非常有趣。它表示一个方向和大小，有点像在空间中的移动。但当你开始组合向量，也就是*向量相加*时，事情就变得有趣起来。我们实际上将两个向量的运动合并成一个单一的向量。
- en: Say we have two vectors <math alttext="ModifyingAbove v With right-arrow"><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover></math> and <math alttext="ModifyingAbove
    w With right-arrow"><mover accent="true"><mi>w</mi> <mo>→</mo></mover></math>
    as shown in [Figure 4-4](#NDAOFFKCBg). How do we add these two vectors together?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个向量 <math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math> 和 <math alttext="ModifyingAbove w With right-arrow"><mover
    accent="true"><mi>w</mi> <mo>→</mo></mover></math> 如[图 4-4](#NDAOFFKCBg)所示。我们如何将这两个向量相加呢？
- en: '![emds 0404](Images/emds_0404.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0404](Images/emds_0404.png)'
- en: Figure 4-4\. Adding two vectors together
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-4\. 将两个向量相加
- en: We will get to why adding vectors is useful in a moment. But if we wanted to
    combine these two vectors, including their direction and scale, what would that
    look like? Numerically, this is straightforward. You simply add the respective
    x-values and then the y-values into a new vector as shown in [Example 4-5](#bvfoUpUGnc).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论为什么添加向量是有用的。但如果我们想要结合这两个向量，包括它们的方向和大小，那会是什么样子呢？从数字上来看，这很简单。你只需将各自的 x
    值相加，然后将 y 值相加，得到一个新的向量，如[示例 4-5](#bvfoUpUGnc)所示。
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mover
    accent="true"><mi>w</mi> <mo>→</mo></mover> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover> <mo>+</mo> <mover accent="true"><mi>w</mi>
    <mo>→</mo></mover> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mn>3</mn>
    <mo>+</mo> <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>2</mn> <mo>+</mo>
    <mo>-</mo> <mn>1</mn></mrow></mtd></mtr></mtable></mfenced> <mo>=</mo> <mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>5</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></m></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mover
    accent="true"><mi>w</mi> <mo>→</mo></mover> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover> <mo>+</mo> <mover accent="true"><mi>w</mi>
    <mo>→</mo></mover> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mn>3</mn>
    <mo>+</mo> <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>2</mn> <mo>+</mo>
    <mo>-</mo> <mn>1</mn></mrow></mtd></mtr></mtable></mfenced> <mo>=</mo> <mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>5</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
- en: Example 4-5\. Adding two vectors in Python using NumPy
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-5\. 使用 NumPy 在 Python 中将两个向量相加
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: But what does this mean visually? To visually add these two vectors together,
    connect one vector after the other and walk to the tip of the last vector ([Figure 4-5](#jHAeQufeOr)).
    The point you end at is a new vector, the result of summing the two vectors.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但这在视觉上意味着什么呢？要将这两个向量视觉上相加，将一个向量连接到另一个向量的末端，然后走到最后一个向量的顶端（[图 4-5](#jHAeQufeOr)）。你最终停留的位置就是一个新向量，是这两个向量相加的结果。
- en: '![emds 0405](Images/emds_0405.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0405](Images/emds_0405.png)'
- en: Figure 4-5\. Adding two vectors into a new vector
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-5\. 将两个向量相加得到一个新向量
- en: As seen in [Figure 4-5](#jHAeQufeOr), when we walk to the end of the last vector
    <math alttext="ModifyingAbove w With right-arrow"><mover accent="true"><mi>w</mi>
    <mo>→</mo></mover></math> we end up with a new vector [5, 1]. This new vector
    is the result of summing <math alttext="ModifyingAbove v With right-arrow"><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover></math> and <math alttext="ModifyingAbove
    w With right-arrow"><mover accent="true"><mi>w</mi> <mo>→</mo></mover></math>
    . In practice, this can be simply adding data together. If we were totaling housing
    values and their square footage in an area, we would be adding several vectors
    into a single vector in this manner.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 [4-5](#jHAeQufeOr) 所示，当我们走到最后一个向量 <math alttext="ModifyingAbove w With right-arrow"><mover
    accent="true"><mi>w</mi> <mo>→</mo></mover></math> 的末端时，我们得到一个新向量 [5, 1]。这个新向量是将
    <math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math> 和 <math alttext="ModifyingAbove w With right-arrow"><mover
    accent="true"><mi>w</mi> <mo>→</mo></mover></math> 相加的结果。在实践中，这可以简单地将数据相加。如果我们在一个区域中总结房屋价值和其平方英尺，我们将以这种方式将多个向量相加成一个单一向量。
- en: Note that it does not matter whether we add <math alttext="ModifyingAbove v
    With right-arrow"><mover accent="true"><mi>v</mi> <mo>→</mo></mover></math> before
    <math alttext="ModifyingAbove w With right-arrow"><mover accent="true"><mi>w</mi>
    <mo>→</mo></mover></math> or vice versa, which means it is *commutative* and order
    of operation does not matter. If we walk <math alttext="ModifyingAbove w With
    right-arrow"><mover accent="true"><mi>w</mi> <mo>→</mo></mover></math> before
    <math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math> we end up with the same resulting vector [5, 1] as visualized
    in [Figure 4-6](#CvgeFbUEet).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，无论我们是先将 <math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math> 加上 <math alttext="ModifyingAbove w With right-arrow"><mover
    accent="true"><mi>w</mi> <mo>→</mo></mover></math> 还是反之，都不影响结果，这意味着它是*可交换*的，操作顺序不重要。如果我们先走
    <math alttext="ModifyingAbove w With right-arrow"><mover accent="true"><mi>w</mi>
    <mo>→</mo></mover></math> 再走 <math alttext="ModifyingAbove v With right-arrow"><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover></math>，我们最终得到的向量 [5, 1] 与 [图 4-6](#CvgeFbUEet)
    中可视化的相同。
- en: '![emds 0406](Images/emds_0406.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0406](Images/emds_0406.png)'
- en: Figure 4-6\. Adding vectors is commutative
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-6\. 向量的加法是可交换的
- en: Scaling Vectors
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩放向量
- en: '*Scaling* is growing or shrinking a vector’s length. You can grow/shrink a
    vector by multiplying or scaling it with a single value, known as a *scalar*.
    [Figure 4-7](#TDiKegoNgG) is vector <math alttext="ModifyingAbove v With right-arrow"><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover></math> being scaled by a factor of
    2, which doubles it.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*缩放*是增加或减小向量的长度。你可以通过乘以一个称为*标量*的单个值来增加/减小向量。[图4-7](#TDiKegoNgG)是向量<math alttext="ModifyingAbove
    v With right-arrow"><mover accent="true"><mi>v</mi> <mo>→</mo></mover></math>被放大2倍的示例。'
- en: '![emds 0407](Images/emds_0407.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0407](Images/emds_0407.png)'
- en: Figure 4-7\. Scaling a vector
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-7\. 向量的缩放
- en: 'Mathematically, you multiply each element of the vector by the scalar value:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，你将向量的每个元素乘以标量值：
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mn>2</mn>
    <mover accent="true"><mi>v</mi> <mo>→</mo></mover> <mo>=</mo> <mn>2</mn> <mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mn>3</mn> <mo>×</mo>
    <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn> <mo>×</mo> <mn>2</mn></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>6</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mn>2</mn>
    <mover accent="true"><mi>v</mi> <mo>→</mo></mover> <mo>=</mo> <mn>2</mn> <mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mn>3</mn> <mo>×</mo>
    <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn> <mo>×</mo> <mn>2</mn></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>6</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
- en: Performing this scaling operation in Python is as easy as multiplying a vector
    by the scalar, as coded in [Example 4-6](#bFNICSfEJu).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中执行这个缩放操作就像将向量乘以标量一样简单，就像在[示例4-6](#bFNICSfEJu)中编写的那样。
- en: Example 4-6\. Scaling a number in Python using NumPy
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-6\. 在Python中使用NumPy缩放数字
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here in [Figure 4-8](#wfUpJAIJuR) <math alttext="ModifyingAbove v With right-arrow"><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover></math> is being scaled down by factor
    of .5, which halves it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，[图4-8](#wfUpJAIJuR)中的<math alttext="ModifyingAbove v With right-arrow"><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover></math>被缩小了一半。
- en: '![emds 0408](Images/emds_0408.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0408](Images/emds_0408.png)'
- en: Figure 4-8\. Scaling down a vector by half
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-8\. 将向量缩小一半
- en: An important detail to note here is that scaling a vector does not change its
    direction, only its magnitude. But there is one slight exception to this rule
    as visualized in [Figure 4-9](#FhcgmMWkaq). When you multiply a vector by a negative
    number, it flips the direction of the vector as shown in the image.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一个重要细节是，缩放向量不会改变其方向，只会改变其大小。但是有一个轻微的例外，如[图4-9](#FhcgmMWkaq)中所示。当你用一个负数乘以一个向量时，它会翻转向量的方向。
- en: '![emds 0409](Images/emds_0409.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0409](Images/emds_0409.png)'
- en: Figure 4-9\. A negative scalar flips the vector direction
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-9\. 负标量会翻转向量方向
- en: When you think about it, though, scaling by a negative number has not really
    changed direction in that it still exists on the same line. This segues to a key
    concept called linear dependence.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细思考一下，通过负数进行缩放实际上并没有改变方向，因为它仍然存在于同一条线上。这引出了一个称为线性相关的关键概念。
- en: Span and Linear Dependence
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨度和线性相关性
- en: These two operations, adding two vectors and scaling them, brings about a simple
    but powerful idea. With these two operations, we can combine two vectors and scale
    them to create any resulting vector we want. [Figure 4-10](#RkeRvAFrnW) shows
    six examples of taking two vectors <math alttext="ModifyingAbove v With right-arrow"><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover></math> and <math alttext="ModifyingAbove
    w With right-arrow"><mover accent="true"><mi>w</mi> <mo>→</mo></mover></math>
    , and scaling and combining. These vectors <math alttext="ModifyingAbove v With
    right-arrow"><mover accent="true"><mi>v</mi> <mo>→</mo></mover></math> and <math
    alttext="ModifyingAbove w With right-arrow"><mover accent="true"><mi>w</mi> <mo>→</mo></mover></math>
    , fixed in two different directions, can be scaled and added to create *any* new
    vector <math alttext="ModifyingAbove v plus w With right-arrow"><mover accent="true"><mrow><mi>v</mi><mo>+</mo><mi>w</mi></mrow>
    <mo>→</mo></mover></math> .
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个操作，相加两个向量并对它们进行缩放，带来了一个简单但强大的想法。通过这两个操作，我们可以组合两个向量并对它们进行缩放，以创建我们想要的任何结果向量。[图 4-10](#RkeRvAFrnW)展示了取两个向量<math
    alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi> <mo>→</mo></mover></math>和<math
    alttext="ModifyingAbove w With right-arrow"><mover accent="true"><mi>w</mi> <mo>→</mo></mover></math>，进行缩放和组合的六个示例。这些向量<math
    alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi> <mo>→</mo></mover></math>和<math
    alttext="ModifyingAbove w With right-arrow"><mover accent="true"><mi>w</mi> <mo>→</mo></mover></math>，固定在两个不同方向上，可以被缩放和相加以创建*任何*新向量<math
    alttext="ModifyingAbove v plus w With right-arrow"><mover accent="true"><mrow><mi>v</mi><mo>+</mo><mi>w</mi></mrow>
    <mo>→</mo></mover></math>。
- en: '![emds 0410](Images/emds_0410.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0410](Images/emds_0410.png)'
- en: Figure 4-10\. Scaling two added vectors allows us to create any new vector
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-10。缩放两个相加的向量允许我们创建任何新向量
- en: Again, <math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math> and <math alttext="ModifyingAbove w With right-arrow"><mover
    accent="true"><mi>w</mi> <mo>→</mo></mover></math> are fixed in direction, except
    for flipping with negative scalars, but we can use scaling to freely create any
    vector composed of <math alttext="ModifyingAbove v plus w With right-arrow"><mover
    accent="true"><mrow><mi>v</mi><mo>+</mo><mi>w</mi></mrow> <mo>→</mo></mover></math>
    .
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，<math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math>和<math alttext="ModifyingAbove w With right-arrow"><mover
    accent="true"><mi>w</mi> <mo>→</mo></mover></math>在方向上固定，除了使用负标量进行翻转，但我们可以使用缩放自由地创建由<math
    alttext="ModifyingAbove v plus w With right-arrow"><mover accent="true"><mrow><mi>v</mi><mo>+</mo><mi>w</mi></mrow>
    <mo>→</mo></mover></math>组成的任何向量。
- en: This whole space of possible vectors is called *span*, and in most cases our
    span can create unlimited vectors off those two vectors, simply by scaling and
    summing them. When we have two vectors in two different directions, they are *linearly
    independent* and have this unlimited span.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 整个可能向量空间称为*span*，在大多数情况下，我们的span可以通过缩放和求和这两个向量来创建无限数量的向量。当我们有两个不同方向的向量时，它们是*线性独立*的，并且具有这种无限的span。
- en: But in what case are we limited in the vectors we can create? Think about it
    and read on.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 但在哪种情况下我们受限于可以创建的向量？思考一下并继续阅读。
- en: What happens when two vectors exist in the same direction, or exist on the same
    line? The combination of those vectors is also stuck on the same line, limiting
    our span to just that line. No matter how you scale it, the resulting sum vector
    is also stuck on that same line. This makes them *linearly dependent*, as shown
    in [Figure 4-11](#WgWduALDRL).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个向量存在于相同方向，或存在于同一条线上时会发生什么？这些向量的组合也被限制在同一条线上，将我们的span限制在那条线上。无论如何缩放，结果的和向量也被困在同一条线上。这使它们成为*线性相关*，如[图 4-11](#WgWduALDRL)所示。
- en: '![emds 0411](Images/emds_0411.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0411](Images/emds_0411.png)'
- en: Figure 4-11\. Linearly dependent vectors
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-11。线性相关向量
- en: The span here is stuck on the same line as the two vectors it is made out of.
    Because the two vectors exist on the same underlying line, we cannot flexibly
    create any new vector through scaling.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的span被困在与由两个向量组成的同一条线上。因为这两个向量存在于相同的基础线上，我们无法通过缩放灵活地创建任何新向量。
- en: In three or more dimensions, when we have a linearly dependent set of vectors,
    we often get stuck on a plane in a smaller number of dimensions. Here is an example
    of being stuck on a two-dimensional plane even though we have three-dimensional
    vectors as declared in [Figure 4-12](#NqKDEfAlvb).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在三维或更高维空间中，当我们有一组线性相关的向量时，我们经常会被困在较低维度的平面上。这里有一个例子，即使我们有三维向量如[图 4-12](#NqKDEfAlvb)所述，我们也被困在二维平面上。
- en: '![emds 0412](Images/emds_0412.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0412](Images/emds_0412.png)'
- en: Figure 4-12\. Linear dependence in three dimensions; note our span is limited
    to a flat plane
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-12。三维空间中的线性相关性；请注意我们的张成空间被限制在一个平面上
- en: Later we will learn a simple tool called the determinant to check for linear
    dependence, but why do we care whether two vectors are linearly dependent or independent?
    A lot of problems become difficult or unsolvable when they are linearly dependent.
    For example, when we learn about systems of equations later in this chapter, a
    linearly dependent set of equations can cause variables to disappear and make
    the problem unsolvable. But if you have linear independence, that flexibility
    to create any vector you need from two or more vectors becomes invaluable to solve
    for a solution!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 后面我们将学习一个简单的工具叫做行列式来检查线性相关性，但我们为什么关心两个向量是线性相关还是线性无关呢？当它们线性相关时，很多问题会变得困难或无法解决。例如，当我们在本章后面学习方程组时，一个线性相关的方程组会导致变量消失，使问题无法解决。但如果你有线性无关性，那么从两个或更多向量中创建任何你需要的向量的灵活性将变得无价，以便解决问题！
- en: Linear Transformations
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性变换
- en: This concept of adding two vectors with fixed direction, but scaling them to
    get different combined vectors, is hugely important. This combined vector, except
    in cases of linear dependence, can point in any direction and have any length
    we choose. This sets up an intuition for linear transformations where we use a
    vector to transform another vector in a function-like manner.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将具有固定方向的两个向量相加，但按比例缩放它们以获得不同的组合向量的概念非常重要。这个组合向量，除了线性相关的情况外，可以指向任何方向并具有我们选择的任何长度。这为线性变换建立了一种直观，我们可以使用一个向量以类似函数的方式来转换另一个向量。
- en: Basis Vectors
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基向量
- en: Imagine we have two simple vectors <math alttext="ModifyingAbove i With caret"><mover
    accent="true"><mi>i</mi> <mo>^</mo></mover></math> and <math alttext="ModifyingAbove
    j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math> (“i-hat”
    and “j-hat”). These are known as *basis vectors*, which are used to describe transformations
    on other vectors. They typically have a length of 1 and point in perpendicular
    positive directions as visualized in [Figure 4-13](#sEddcHheJh).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们有两个简单的向量<math alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi>
    <mo>^</mo></mover></math>和<math alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi>
    <mo>^</mo></mover></math>（“i-hat”和“j-hat”）。这些被称为*基向量*，用于描述对其他向量的变换。它们通常长度为1，并且指向垂直正方向，如[图4-13](#sEddcHheJh)中可视化的。
- en: '![emds 0413](Images/emds_0413.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0413](Images/emds_0413.png)'
- en: Figure 4-13\. Basis vectors <math alttext="ModifyingAbove i With caret"><mover
    accent="true"><mi>i</mi> <mo>^</mo></mover></math> and <math alttext="ModifyingAbove
    j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math>
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-13。基向量<math alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi>
    <mo>^</mo></mover></math>和<math alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi>
    <mo>^</mo></mover></math>
- en: 'Think of the basis vectors as building blocks to build or transform any vector.
    Our basis vector is expressed in a 2 × 2 matrix, where the first column is <math
    alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math>
    and the second column is <math alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi>
    <mo>^</mo></mover></math> :'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将基向量视为构建或转换任何向量的构建块。我们的基向量用一个2×2矩阵表示，其中第一列是<math alttext="ModifyingAbove i With
    caret"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math>，第二列是<math alttext="ModifyingAbove
    j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math>：
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mover
    accent="true"><mi>i</mi> <mo>^</mo></mover> <mo>=</mo> <mfenced separators=""
    open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mover
    accent="true"><mi>j</mi> <mo>^</mo></mover> <mo>=</mo> <mfenced separators=""
    open="[" close="]"><mtable><mtr><mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mtext>basis</mtext>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mover
    accent="true"><mi>i</mi> <mo>^</mo></mover> <mo>=</mo> <mfenced separators=""
    open="[" close="]"><mtable><mtr><mtd><mn>1</mn></td></mtr> <mtr><mtd><mn>0</mn></td></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mover
    accent="true"><mi>j</mi> <mo>^</mo></mover> <mo>=</mo> <mfenced separators=""
    open="[" close="]"><mtable><mtr><mtd><mn>0</mn></td></mtr> <mtr><mtd><mn>1</mn></td></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mtext>基向量</mtext>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>1</mn></td> <mtd><mn>0</mn></td></mtr>
    <mtr><mtd><mn>0</mn></td> <mtd><mn>1</mn></td></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
- en: A *matrix* is a collection of vectors (such as <math alttext="ModifyingAbove
    i With caret"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math> , <math
    alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math>
    ) that can have multiple rows and columns and is a convenient way to package data.
    We can use <math alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi>
    <mo>^</mo></mover></math> and <math alttext="ModifyingAbove j With caret"><mover
    accent="true"><mi>j</mi> <mo>^</mo></mover></math> to create any vector we want
    by scaling and adding them. Let’s start with each having a length of 1 and showing
    the resulting vector <math alttext="ModifyingAbove v With right-arrow"><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover></math> in [Figure 4-14](#MvKpOBjCEA).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*矩阵*是一组向量（如<math alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi>
    <mo>^</mo></mover></math>，<math alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi>
    <mo>^</mo></mover></math>），可以有多行多列，是打包数据的便捷方式。我们可以使用<math alttext="ModifyingAbove
    i With caret"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math>和<math
    alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math>通过缩放和相加来创建任何我们想要的向量。让我们从长度为1开始，并在[图4-14](#MvKpOBjCEA)中展示结果向量<math
    alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi> <mo>→</mo></mover></math>。'
- en: '![emds 0414](Images/emds_0414.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0414](Images/emds_0414.png)'
- en: Figure 4-14\. Creating a vector from basis vectors
  id: totrans-94
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-14\. 从基向量创建向量
- en: 'I want vector <math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math> to land at [3, 2]. What happens to <math alttext="ModifyingAbove
    v With right-arrow"><mover accent="true"><mi>v</mi> <mo>→</mo></mover></math>
    if we stretch <math alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi>
    <mo>^</mo></mover></math> by a factor of 3 and <math alttext="ModifyingAbove j
    With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math> by a factor
    of 2? First we scale them individually as shown here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望向量<math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math>落在[3, 2]处。如果我们将<math alttext="ModifyingAbove i With caret"><mover
    accent="true"><mi>i</mi> <mo>^</mo></mover></math>拉伸3倍，<math alttext="ModifyingAbove
    j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math>拉伸2倍，那么<math
    alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi> <mo>→</mo></mover></math>会发生什么？首先，我们分别按照下面的方式对它们进行缩放：
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mn>3</mn>
    <mover accent="true"><mi>i</mi> <mo>^</mo></mover> <mo>=</mo> <mn>3</mn> <mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mn>2</mn>
    <mover accent="true"><mi>j</mi> <mo>^</mo></mover> <mo>=</mo> <mn>2</mn> <mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mn>3</mn>
    <mover accent="true"><mi>i</mi> <mo>^</mo></mover> <mo>=</mo> <mn>3</mn> <mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>1</mn></td></mtr> <mtr><mtd><mn>0</mn></td></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>3</mn></td></mtr>
    <mtr><mtd><mn>0</mn></td></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mn>2</mn>
    <mover accent="true"><mi>j</mi> <mo>^</mo></mover> <mo>=</mo> <mn>2</mn> <mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>0</mn></td></mtr> <mtr><mtd><mn>1</mn></td></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>0</mn></td></tr>
    <mtr><mtd><mn>2</mn></td></tr></mtable></mfenced></mrow></mtd></tr></mtable></math>
- en: If we stretched space in these two directions, what does this do to <math alttext="ModifyingAbove
    v With right-arrow"><mover accent="true"><mi>v</mi> <mo>→</mo></mover></math>
    ? Well, it is going to stretch with <math alttext="ModifyingAbove i With caret"><mover
    accent="true"><mi>i</mi> <mo>^</mo></mover></math> and <math alttext="ModifyingAbove
    j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math> . This
    is known as a *linear transformation*, where we transform a vector with stretching,
    squishing, sheering, or rotating by tracking basis vector movements. In this case
    ([Figure 4-15](#ioUOiIisaH)), scaling <math alttext="ModifyingAbove i With caret"><mover
    accent="true"><mi>i</mi> <mo>^</mo></mover></math> and <math alttext="ModifyingAbove
    j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math> has stretched
    space along with our vector <math alttext="ModifyingAbove v With right-arrow"><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover></math> .
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这两个方向上拉伸空间，那么这对 <math alttext="ModifyingAbove v With right-arrow"><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover></math> 会有什么影响呢？嗯，它将会随着 <math alttext="ModifyingAbove
    i With caret"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math> 和 <math
    alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math>
    一起拉伸。这被称为*线性变换*，我们通过跟踪基向量的移动来进行向量的拉伸、挤压、剪切或旋转。在这种情况下（[图 4-15](#ioUOiIisaH)），缩放
    <math alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math>
    和 <math alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi>
    <mo>^</mo></mover></math> 已经沿着我们的向量 <math alttext="ModifyingAbove v With right-arrow"><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover></math> 拉伸了空间。
- en: '![emds 0415](Images/emds_0415.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0415](Images/emds_0415.png)'
- en: Figure 4-15\. A linear transformation
  id: totrans-99
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-15\. 一个线性变换
- en: 'But where does <math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math> land? It is easy to see where it lands here, which is
    [3, 2]. Recall that vector <math alttext="ModifyingAbove v With right-arrow"><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover></math> is composed of adding <math
    alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math>
    and <math alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi>
    <mo>^</mo></mover></math> . So we simply take the stretched <math alttext="ModifyingAbove
    i With caret"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math> and <math
    alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math>
    and add them together to see where vector <math alttext="ModifyingAbove v With
    right-arrow"><mover accent="true"><mi>v</mi> <mo>→</mo></mover></math> has landed:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 <math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math> 会落在哪里呢？很容易看出它会落在这里，即 [3, 2]。记住向量 <math alttext="ModifyingAbove
    v With right-arrow"><mover accent="true"><mi>v</mi> <mo>→</mo></mover></math>
    是由 <math alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi>
    <mo>^</mo></mover></math> 和 <math alttext="ModifyingAbove j With caret"><mover
    accent="true"><mi>j</mi> <mo>^</mo></mover></math> 相加而成的。因此，我们只需将拉伸的 <math alttext="ModifyingAbove
    i With caret"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math> 和 <math
    alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math>
    相加，就能看出向量 <math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math> 落在哪里：
- en: <math alttext="ModifyingAbove v With right-arrow Subscript n e w Baseline equals
    StartBinomialOrMatrix 3 Choose 0 EndBinomialOrMatrix plus StartBinomialOrMatrix
    0 Choose 2 EndBinomialOrMatrix equals StartBinomialOrMatrix 3 Choose 2 EndBinomialOrMatrix"
    display="block"><mrow><msub><mover accent="true"><mi>v</mi> <mo>→</mo></mover>
    <mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub> <mo>=</mo> <mfenced open="["
    close="]"><mtable><mtr><mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced> <mo>=</mo> <mfenced open="["
    close="]"><mtable><mtr><mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="ModifyingAbove v With right-arrow Subscript n e w Baseline equals
    StartBinomialOrMatrix 3 Choose 0 EndBinomialOrMatrix plus StartBinomialOrMatrix
    0 Choose 2 EndBinomialOrMatrix equals StartBinomialOrMatrix 3 Choose 2 EndBinomialOrMatrix"
    display="block"><mrow><msub><mover accent="true"><mi>v</mi> <mo>→</mo></mover>
    <mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub> <mo>=</mo> <mfenced open="["
    close="]"><mtable><mtr><mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd></mtr></mtable></mfenced>
    <mo>+</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced> <mo>=</mo> <mfenced open="["
    close="]"><mtable><mtr><mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: Generally, with linear transformations, there are four movements you can achieve,
    as shown in [Figure 4-16](#FFQRVdcspb).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，通过线性变换，你可以实现四种运动，如[图4-16](#FFQRVdcspb)所示。
- en: '![emds 0416](Images/emds_0416.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0416](Images/emds_0416.png)'
- en: Figure 4-16\. Four movements can be achieved with linear transformations
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-16。线性变换可以实现四种运动
- en: These four linear transformations are a central part of linear algebra. Scaling
    a vector will stretch or squeeze it. Rotations will turn the vector space, and
    inversions will flip the vector space so that <math alttext="ModifyingAbove i
    With caret"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math> and <math
    alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math>
    swap respective places.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种线性变换是线性代数的核心部分。缩放向量将拉伸或挤压它。旋转将转动向量空间，而反转将翻转向量空间，使<math alttext="ModifyingAbove
    i With caret"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math>和<math
    alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math>交换位置。
- en: It is important to note that you cannot have transformations that are nonlinear,
    resulting in curvy or squiggly transformations that no longer respect a straight
    line. This is why we call it linear algebra, not nonlinear algebra!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，你不能有非线性的变换，导致曲线或波浪状的变换不再遵守直线。这就是为什么我们称其为线性代数，而不是非线性代数！
- en: Matrix Vector Multiplication
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵向量乘法
- en: This brings us to our next big idea in linear algebra. This concept of tracking
    where <math alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi>
    <mo>^</mo></mover></math> and <math alttext="ModifyingAbove j With caret"><mover
    accent="true"><mi>j</mi> <mo>^</mo></mover></math> land after a transformation
    is important because it allows us not just to create vectors but also to transform
    existing vectors. If you want true linear algebra enlightenment, think why creating
    vectors and transforming vectors are actually the same thing. It’s all a matter
    of relativity given your basis vectors being a starting point before and after
    a transformation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引出线性代数中的下一个重要概念。在变换后跟踪<math alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi>
    <mo>^</mo></mover></math>和<math alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi>
    <mo>^</mo></mover></math>落在哪里的概念很重要，因为这不仅允许我们创建向量，还可以变换现有向量。如果你想要真正的线性代数启示，想想为什么创建向量和变换向量实际上是相同的事情。这完全取决于相对性，考虑到你的基向量在变换前后都是起点。
- en: 'The formula to transform a vector <math alttext="ModifyingAbove v With right-arrow"><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover></math> given basis vectors <math alttext="ModifyingAbove
    i With caret"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math> and <math
    alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math>
    packaged as a matrix is:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 给定作为矩阵打包的基向量<math alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi>
    <mo>^</mo></mover></math>和<math alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi>
    <mo>^</mo></mover></math>，变换向量<math alttext="ModifyingAbove v With right-arrow"><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover></math>的公式是：
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfenced
    open="[" close="]"><mtable><mtr><mtd><msub><mi>x</mi> <mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mtd></mtr>
    <mtr><mtd><msub><mi>y</mi> <mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mi>a</mi></mtd> <mtd><mi>b</mi></mtd></mtr>
    <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced> <mfenced
    open="[" close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfenced
    open="[" close="]"><mtable><mtr><mtd><msub><mi>x</mi> <mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mtd></mtr>
    <mtr><mtd><msub><mi>y</mi> <mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mi>a</mi> <mi>x</mi>
    <mo>+</mo> <mi>b</mi> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mi>c</mi>
    <mi>x</mi> <mo>+</mo> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfenced
    open="[" close="]"><mtable><mtr><mtd><msub><mi>x</mi> <mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mtd></mtr>
    <mtr><mtd><msub><mi>y</mi> <mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mi>a</mi></mtd> <mtd><mi>b</mi></mtd></mtr>
    <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced> <mfenced
    open="[" close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfenced
    open="[" close="]"><mtable><mtr><mtd><msub><mi>x</mi> <mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mtd></mtr>
    <mtr><mtd><msub><mi>y</mi> <mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mi>a</mi> <mi>x</mi>
    <mo>+</mo> <mi>b</mi> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mi>c</mi>
    <mi>x</mi> <mo>+</mo> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
- en: <math alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi>
    <mo>^</mo></mover></math> is the first column [*a, c*] and <math alttext="ModifyingAbove
    j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math> is the
    column [*b, d*]. We package both of these basis vectors as a matrix, which again
    is a collection of vectors expressed as a grid of numbers in two or more dimensions.
    This transformation of a vector by applying basis vectors is known as *matrix
    vector multiplication*. This may seem contrived at first, but this formula is
    a shortcut for scaling and adding <math alttext="ModifyingAbove i With caret"><mover
    accent="true"><mi>i</mi> <mo>^</mo></mover></math> and <math alttext="ModifyingAbove
    j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math> just like
    we did earlier adding two vectors, and applying the transformation to any vector
    <math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math> .
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi>
    <mo>^</mo></mover></math> 是第一列[*a, c*]，<math alttext="ModifyingAbove j With caret"><mover
    accent="true"><mi>j</mi> <mo>^</mo></mover></math> 是第二列[*b, d*]。我们将这两个基向量打包成一个矩阵，再次表示为一个在两个或更多维度中以数字网格形式表达的向量集合。通过应用基向量对向量进行转换被称为*矩阵向量乘法*。这一开始可能看起来有些牵强，但这个公式是对缩放和添加<math
    alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math>和<math
    alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math>的快捷方式，就像我们之前对两个向量进行加法，并将该转换应用于任何向量<math
    alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi> <mo>→</mo></mover></math>。
- en: So in effect, a matrix really is a transformation expressed as basis vectors.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实际上，矩阵确实是表示为基向量的转换。
- en: To execute this transformation in Python using NumPy, we will need to declare
    our basis vectors as a matrix and then apply it to vector <math alttext="ModifyingAbove
    v With right-arrow"><mover accent="true"><mi>v</mi> <mo>→</mo></mover></math>
    using the `dot()` operator ([Example 4-7](#CHJGoFdTjq)). The `dot()` operator
    will perform this scaling and addition between our matrix and vector as we just
    described. This is known as the *dot product*, and we will explore it throughout
    this chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Python中使用NumPy执行这种转换，我们需要将基向量声明为矩阵，然后使用`dot()`运算符将其应用于向量<math alttext="ModifyingAbove
    v With right-arrow"><mover accent="true"><mi>v</mi> <mo>→</mo></mover></math>（参见[示例 4-7](#CHJGoFdTjq)）。`dot()`运算符将执行我们刚刚描述的矩阵和向量之间的缩放和加法。这被称为*点积*，我们将在本章中探讨它。
- en: Example 4-7\. Matrix vector multiplication in NumPy
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-7\. NumPy中的矩阵向量乘法
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When thinking in terms of basis vectors, I prefer to break out the basis vectors
    and then compose them together into a matrix. Just note you will need to *transpose*,
    or swap the columns and rows. This is because NumPy’s `array()` function will
    do the opposite orientation we want, populating each vector as a row rather than
    a column. Transposition in NumPy is demonstrated in [Example 4-8](#RCsLehHkev).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑基向量时，我更喜欢将基向量分解然后将它们组合成一个矩阵。只需注意你需要*转置*，或者交换列和行。这是因为NumPy的`array()`函数会执行我们不希望的相反方向，将每个向量填充为一行而不是一列。在NumPy中的转置示例可在[示例
    4-8](#RCsLehHkev)中看到。
- en: Example 4-8\. Separating the basis vectors and applying them as a transformation
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-8\. 分离基向量并将它们应用为一个转换
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here’s another example. Let’s start with vector <math alttext="ModifyingAbove
    v With right-arrow"><mover accent="true"><mi>v</mi> <mo>→</mo></mover></math>
    being [2, 1] and <math alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi>
    <mo>^</mo></mover></math> and <math alttext="ModifyingAbove j With caret"><mover
    accent="true"><mi>j</mi> <mo>^</mo></mover></math> start at [1, 0] and [0, 1],
    respectively. We then transform <math alttext="ModifyingAbove i With caret"><mover
    accent="true"><mi>i</mi> <mo>^</mo></mover></math> and <math alttext="ModifyingAbove
    j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math> to [2,
    0] and [0, 3]. What happens to vector <math alttext="ModifyingAbove v With right-arrow"><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover></math> ? Working this out mathematically
    by hand using our formula, we get this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有另一个例子。让我们从向量<math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math>为[2, 1]开始，<math alttext="ModifyingAbove i With caret"><mover
    accent="true"><mi>i</mi> <mo>^</mo></mover></math>和<math alttext="ModifyingAbove
    j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math>分别从[1,
    0]和[0, 1]开始。然后我们将<math alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi>
    <mo>^</mo></mover></math>和<math alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi>
    <mo>^</mo></mover></math>转换为[2, 0]和[0, 3]。向量<math alttext="ModifyingAbove v With
    right-arrow"><mover accent="true"><mi>v</mi> <mo>→</mo></mover></math>会发生什么？通过手工使用我们的公式进行数学计算，我们得到如下结果：
- en: <math alttext="StartBinomialOrMatrix x Subscript n e w Baseline Choose y Subscript
    n e w Baseline EndBinomialOrMatrix equals Start 2 By 2 Matrix 1st Row 1st Column
    a 2nd Column b 2nd Row 1st Column c 2nd Column d EndMatrix StartBinomialOrMatrix
    x Choose y EndBinomialOrMatrix equals StartBinomialOrMatrix a x plus b y Choose
    c x plus d y EndBinomialOrMatrix" display="block"><mrow><mfenced open="[" close="]"><mtable><mtr><mtd><msub><mi>x</mi>
    <mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mtd></mtr> <mtr><mtd><msub><mi>y</mi>
    <mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mi>a</mi></mtd> <mtd><mi>b</mi></mtd></mtr>
    <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced> <mfenced
    open="[" close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mi>a</mi> <mi>x</mi>
    <mo>+</mo> <mi>b</mi> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mi>c</mi>
    <mi>x</mi> <mo>+</mo> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math><math
    alttext="StartBinomialOrMatrix x Subscript n e w Baseline Choose y Subscript n
    e w Baseline EndBinomialOrMatrix equals Start 2 By 2 Matrix 1st Row 1st Column
    2 2nd Column 0 2nd Row 1st Column 0 2nd Column 3 EndMatrix StartBinomialOrMatrix
    2 Choose 1 EndBinomialOrMatrix equals StartBinomialOrMatrix left-parenthesis 2
    right-parenthesis left-parenthesis 2 right-parenthesis plus left-parenthesis 0
    right-parenthesis left-parenthesis 1 right-parenthesis Choose left-parenthesis
    2 right-parenthesis left-parenthesis 0 right-parenthesis plus left-parenthesis
    3 right-parenthesis left-parenthesis 1 right-parenthesis EndBinomialOrMatrix equals
    StartBinomialOrMatrix 4 Choose 3 EndBinomialOrMatrix" display="block"><mrow><mfenced
    open="[" close="]"><mtable><mtr><mtd><msub><mi>x</mi> <mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mtd></mtr>
    <mtr><mtd><msub><mi>y</mi> <mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable></mfenced> <mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mo>(</mo> <mn>2</mn>
    <mo>)</mo> <mo>(</mo> <mn>2</mn> <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>0</mn> <mo>)</mo>
    <mo>(</mo> <mn>1</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd><mrow><mo>(</mo>
    <mn>2</mn> <mo>)</mo> <mo>(</mo> <mn>0</mn> <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>3</mn>
    <mo>)</mo> <mo>(</mo> <mn>1</mn> <mo>)</mo></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="开始二项式或矩阵 x 下标 n e w 选择 y 下标 n e w 等于开始 2 乘 2 矩阵 第一行第一列 a 第二列
    b 第二行第一列 c 第二列 d 结束矩阵 开始二项式或矩阵 x 选择 y 结束二项式或矩阵 等于开始二项式或矩阵 a x 加 b y 选择 c x 加 d
    y 结束二项式或矩阵" display="block"><mrow><mfenced open="[" close="]"><mtable><mtr><mtd><msub><mi>x</mi>
    <mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mtd></mtr> <mtr><mtd><msub><mi>y</mi>
    <mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mi>a</mi></mtd> <mtd><mi>b</mi></mtd></mtr>
    <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced> <mfenced
    open="[" close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mi>a</mi> <mi>x</mi>
    <mo>+</mo> <mi>b</mi> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mi>c</mi>
    <mi>x</mi> <mo>+</mo> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math><math
    alttext="开始二项式或矩阵 x 下标 n e w 选择 y 下标 n e w 等于开始 2 乘 2 矩阵 第一行第一列 2 第二列 0 第二行第一列
    0 第二列 3 结束矩阵 开始二项式或矩阵 2 选择 1 结束二项式或矩阵 等于开始二项式或矩阵 左括号 2 右括号 左括号 2 右括号 加 左括号 0 右括号
    左括号 1 右括号 选择 左括号 2 右括号 左括号 0 右括号 加 左括号 3 右括号 左括号 1 右括号 结束二项式或矩阵 等于开始二项式或矩阵 4 选择
    3 结束二项式或矩阵" display="block"><mrow><mfenced open="[" close="]"><mtable><mtr><mtd><msub><mi>x</mi>
    <mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mtd></mtr> <mtr><mtd><msub><mi>y</mi>
    <mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable></mfenced> <mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>1</mn></m></tr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mo>(</mo> <mn>2</mn>
    <mo>)</mo> <mo>(</mo> <mn>2</mn> <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>0</mn> <mo>)</mo>
    <mo>(</mo> <mn>1</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd><mrow><mo>(</mo>
    <mn>2</mn> <mo>)</mo> <mo>(</mo> <mn>0</mn> <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>3</mn>
    <mo>)</mo> <mo>(</mo> <mn>1</mn> <mo>)</mo></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: '[Example 4-9](#glJhkqdFVq) shows this solution in Python.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例4-9](#glJhkqdFVq)展示了这个解决方案在Python中的应用。'
- en: Example 4-9\. Transforming a vector using NumPy
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-9。使用NumPy转换向量
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The vector <math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math> now lands at [4, 3]. [Figure 4-17](#wOOmFvfSph) shows
    what this transformation looks like.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 向量<math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math>现在落在[4, 3]处。[图4-17](#wOOmFvfSph)展示了这个变换的样子。
- en: '![emds 0417](Images/emds_0417.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0417](Images/emds_0417.png)'
- en: Figure 4-17\. A stretching linear transformation
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-17。一个拉伸的线性变换
- en: Here is an example that jumps things up a notch. Let’s take vector <math alttext="ModifyingAbove
    v With right-arrow"><mover accent="true"><mi>v</mi> <mo>→</mo></mover></math>
    of value [2, 1]. <math alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi>
    <mo>^</mo></mover></math> and <math alttext="ModifyingAbove j With caret"><mover
    accent="true"><mi>j</mi> <mo>^</mo></mover></math> start at [1, 0] and [0, 1],
    but then are transformed and land at [2, 3] and [2, -1]. What happens to <math
    alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi> <mo>→</mo></mover></math>
    ? Let’s look in [Figure 4-18](#BFAJsJbkfa) and [Example 4-10](#JcsfGNwpLU).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个将事情提升到一个新水平的例子。让我们取值为[2, 1]的向量<math alttext="ModifyingAbove v With right-arrow"><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover></math>。<math alttext="ModifyingAbove
    i With caret"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math>和<math
    alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math>起始于[1,
    0]和[0, 1]，但随后被变换并落在[2, 3]和[2, -1]。<math alttext="ModifyingAbove v With right-arrow"><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover></math>会发生什么？让我们在[图4-18](#BFAJsJbkfa)和[示例4-10](#JcsfGNwpLU)中看看。
- en: '![emds 0418](Images/emds_0418.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0418](Images/emds_0418.png)'
- en: Figure 4-18\. A linear transformation that does a rotation, shear, and flipping
    of space
  id: totrans-129
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-18。一个进行旋转、剪切和空间翻转的线性变换
- en: Example 4-10\. A more complicated transformation
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-10。一个更复杂的变换
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A lot has happened here. Not only did we scale <math alttext="ModifyingAbove
    i With caret"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math> and <math
    alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math>
    and elongate vector <math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math> . We actually sheared, rotated, and flipped space, too.
    You know space was flipped when <math alttext="ModifyingAbove i With caret"><mover
    accent="true"><mi>i</mi> <mo>^</mo></mover></math> and <math alttext="ModifyingAbove
    j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math> change
    places in their clockwise orientation, and we will learn how to detect this with
    determinants later in this chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情。我们不仅缩放了<math alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi>
    <mo>^</mo></mover></math>和<math alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi>
    <mo>^</mo></mover></math>，还拉长了向量<math alttext="ModifyingAbove v With right-arrow"><mover
    accent="true"><mi>v</mi> <mo>→</mo></mover></math>。我们实际上还剪切、旋转和翻转了空间。当<math alttext="ModifyingAbove
    i With caret"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math>和<math
    alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math>在顺时针方向上交换位置时，你会知道空间被翻转了，我们将在本章后面学习如何通过行列式检测这一点。
- en: Matrix Multiplication
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵乘法
- en: We learned how to multiply a vector and a matrix, but what exactly does multiplying
    two matrices accomplish? Think of *matrix multiplication* as applying multiple
    transformations to a vector space. Each transformation is like a function, where
    we apply the innermost first and then apply each subsequent transformation outward.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学会了如何将一个向量和一个矩阵相乘，但是将两个矩阵相乘到底实现了什么？将*矩阵乘法*看作是对向量空间应用多个变换。每个变换就像一个函数，我们首先应用最内层的变换，然后依次向外应用每个后续变换。
- en: 'Here is how we apply a rotation and then a shear to any vector <math alttext="ModifyingAbove
    v With right-arrow"><mover accent="true"><mi>v</mi> <mo>→</mo></mover></math>
    with value [*x, y*]:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们如何对任意向量<math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math>（值为[*x, y*]）应用旋转和剪切：
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 1 2nd Row
    1st Column 0 2nd Column 1 EndMatrix Start 2 By 2 Matrix 1st Row 1st Column 0 2nd
    Column negative 1 2nd Row 1st Column 1 2nd Column 0 EndMatrix StartBinomialOrMatrix
    x Choose y EndBinomialOrMatrix" display="block"><mrow><mfenced open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>0</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>1</mn></mrow></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 1 2nd Row
    1st Column 0 2nd Column 1 EndMatrix Start 2 By 2 Matrix 1st Row 1st Column 0 2nd
    Column negative 1 2nd Row 1st Column 1 2nd Column 0 EndMatrix StartBinomialOrMatrix
    x Choose y EndBinomialOrMatrix" display="block"><mrow><mfenced open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>0</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>1</mn></mrow></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'We can actually consolidate these two transformations by using this formula,
    applying one transformation onto the last. You multiply and add each row from
    the first matrix to each respective column of the second matrix, in an “over-and-down!
    over-and-down!” pattern:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以通过使用这个公式将这两个变换合并，将一个变换应用到最后一个上。你需要将第一个矩阵的每一行与第二个矩阵的每一列相乘并相加，按照“上下！上下！”的模式进行：
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column a 2nd Column b 2nd Row
    1st Column c 2nd Column d EndMatrix Start 2 By 2 Matrix 1st Row 1st Column e 2nd
    Column f 2nd Row 1st Column g 2nd Column h EndMatrix equals Start 2 By 2 Matrix
    1st Row 1st Column a e plus b g 2nd Column a f plus b h 2nd Row 1st Column c e
    plus d y 2nd Column c f plus d h EndMatrix" display="block"><mrow><mfenced open="["
    close="]"><mtable><mtr><mtd><mi>a</mi></mtd> <mtd><mi>b</mi></mtd></mtr> <mtr><mtd><mi>c</mi></mtd>
    <mtd><mi>d</mi></mtd></mtr></mtable></mfenced> <mfenced open="[" close="]"><mtable><mtr><mtd><mi>e</mi></mtd>
    <mtd><mi>f</mi></mtd></mtr> <mtr><mtd><mi>g</mi></mtd> <mtd><mi>h</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mi>a</mi> <mi>e</mi>
    <mo>+</mo> <mi>b</mi> <mi>g</mi></mrow></mtd> <mtd><mrow><mi>a</mi> <mi>f</mi>
    <mo>+</mo> <mi>b</mi> <mi>h</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mi>c</mi>
    <mi>e</mi> <mo>+</mo> <mi>d</mi> <mi>y</mi></mrow></mtd> <mtd><mrow><mi>c</mi>
    <mi>f</mi> <mo>+</mo> <mi>d</mi> <mi>h</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column a 2nd Column b 2nd Row
    1st Column c 2nd Column d EndMatrix Start 2 By 2 Matrix 1st Row 1st Column e 2nd
    Column f 2nd Row 1st Column g 2nd Column h EndMatrix equals Start 2 By 2 Matrix
    1st Row 1st Column a e plus b g 2nd Column a f plus b h 2nd Row 1st Column c e
    plus d y 2nd Column c f plus d h EndMatrix" display="block"><mrow><mfenced open="["
    close="]"><mtable><mtr><mtd><mi>a</mi></mtd> <mtd><mi>b</mi></mtd></mtr> <mtr><mtd><mi>c</mi></mtd>
    <mtd><mi>d</mi></mtd></mtr></mtable></mfenced> <mfenced open="[" close="]"><mtable><mtr><mtd><mi>e</mi></mtd>
    <mtd><mi>f</mi></mtd></mtr> <mtr><mtd><mi>g</mi></mtd> <mtd><mi>h</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mi>a</mi> <mi>e</mi>
    <mo>+</mo> <mi>b</mi> <mi>g</mi></mrow></mtd> <mtd><mrow><mi>a</mi> <mi>f</mi>
    <mo>+</mo> <mi>b</mi> <mi>h</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mi>c</mi>
    <mi>e</mi> <mo>+</mo> <mi>d</mi> <mi>y</mi></mrow></mtd> <mtd><mrow><mi>c</mi>
    <mi>f</mi> <mo>+</mo> <mi>d</mi> <mi>h</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'So we can actually consolidate these two separate transformations (rotation
    and shear) into a single transformation:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们实际上可以通过使用这个公式将这两个单独的变换（旋转和剪切）合并为一个单一的变换：
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced> <mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>0</mn></mtd> <mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced> <mfenced
    open="[" close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mo>=</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mo>(</mo> <mn>1</mn> <mo>)</mo>
    <mo>(</mo> <mn>0</mn> <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>1</mn> <mo>)</mo> <mo>(</mo>
    <mn>1</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo> <mo>-</mo> <mn>1</mn>
    <mo>)</mo> <mo>(</mo> <mn>1</mn> <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>1</mn> <mo>)</mo>
    <mo>(</mo> <mn>0</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd><mrow><mo>(</mo>
    <mn>0</mn> <mo>)</mo> <mo>(</mo> <mn>0</mn> <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>1</mn>
    <mo>)</mo> <mo>(</mo> <mn>1</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo>
    <mn>0</mn> <mo>)</mo> <mo>(</mo> <mo>-</mo> <mn>1</mn> <mo>)</mo> <mo>+</mo> <mo>(</mo>
    <mn>1</mn> <mo>)</mo> <mo>(</mo> <mn>0</mn> <mo>)</mo></mrow></mtd></mtr></mtable></mfenced>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mo>=</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>1</mn></mrow></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced> <mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>0</mn></mtd> <mtd><mrow><mo>-</mo> <mn>1</mn></mrow></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced> <mfenced
    open="[" close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mo>=</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mo>(</mo> <mn>1</mn> <mo>)</mo>
    <mo>(</mo> <mn>0</mn> <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>1</mn> <mo>)</mo> <mo>(</mo>
    <mn>1</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo> <mo>-</mo> <mn>1</mn>
    <mo>)</mo> <mo>(</mo> <mn>1</mn> <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>1</mn> <mo>)</mo>
    <mo>(</mo> <mn>0</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd><mrow><mo>(</mo>
    <mn>0</mn> <mo>)</mo> <mo>(</mo> <mn>0</mn> <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>1</mn>
    <mo>)</mo> <mo>(</mo> <mn>1</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo>
    <mn>0</mn> <mo>)</mo> <mo>(</mo> <mo>-</mo> <mn>1</mn> <mo>)</mo> <mo>+</mo> <mo>(</mo>
    <mn>1</mn> <mo>)</mo> <mo>(</mo> <mn>0</mn> <mo>)</mo></mrow></mtd></mtr></mtable></mfenced>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mo>=</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>1</mn></mrow></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
- en: To execute this in Python using NumPy, you can combine the two matrices simply
    using the `matmul()` or `@` operator ([Example 4-11](#kobdVPLRAh)). We will then
    turn around and use this consolidated tranformation and apply it to a vector [1,
    2].
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Python 中使用 NumPy 执行这个操作，你可以简单地使用 `matmul()` 或 `@` 运算符来组合这两个矩阵（[示例 4-11](#kobdVPLRAh)）。然后我们将转身并将这个合并的变换应用于一个向量
    [1, 2]。
- en: Example 4-11\. Combining two transformations
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-11\. 组合两个变换
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using `dot()` Versus `matmul()` and `@`
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `dot()` 与 `matmul()` 以及 `@`
- en: In general, you want to prefer `matmul()` and its shorthand `@` to combine matrices
    rather than the `dot()` operator in NumPy. The former generally has a preferable
    policy for higher-dimensional matrices and how the elements are broadcasted.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你应该更倾向于使用 `matmul()` 和它的简写 `@` 来组合矩阵，而不是 NumPy 中的 `dot()` 运算符。前者通常对于高维矩阵和元素广播有更好的策略。
- en: If you like diving into these kinds of implementation details, [this StackOverflow
    question is a good place to start](https://oreil.ly/YX83Q).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢深入研究这些实现细节，[这个 StackOverflow 问题是一个很好的起点](https://oreil.ly/YX83Q)。
- en: 'Note that we also could have applied each transformation individually to vector
    <math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math> and still have gotten the same result. If you replace
    the last line with these three lines applying each transformation, you will still
    get [-1, 1] on that new vector:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们也可以将每个变换分别应用于向量 <math alttext="在 v 上方带箭头"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math>，并且仍然会得到相同的结果。如果你用这三行替换最后一行，分别应用每个变换，你仍然会得到那个新向量 [-1,
    1]：
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that the order you apply each transformation matters! If we apply `transformation1`
    on `transformation2`, we get a different result of [-2, 3] as calculated in [Example 4-12](#IOcCtlSitO).
    So matrix dot products are not commutative, meaning you cannot flip the order
    and expect the same result!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，应用每个变换的顺序很重要！如果我们在 `变换2` 上应用 `变换1`，我们会得到一个不同的结果 [-2, 3]，如 [示例 4-12](#IOcCtlSitO)
    中计算的那样。因此矩阵点积不是可交换的，这意味着你不能改变顺序并期望得到相同的结果！
- en: Example 4-12\. Applying the transformations in reverse
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-12\. 反向应用变换
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Think of each transformation as a function, and we apply them from the innermost
    to outermost just like nested function calls.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个变换看作一个函数，并且我们从最内层到最外层应用它们，就像嵌套函数调用一样。
- en: Determinants
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行列式
- en: 'When we perform linear transformations, we sometimes “expand” or “squish” space
    and the degree this happens can be helpful. Take a sampled area from the vector
    space in [Figure 4-20](#LvCkMSfcus): what happens to it after we scale <math alttext="ModifyingAbove
    i With caret"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math> and <math
    alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math>
    ?'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行线性变换时，有时会“扩展”或“挤压”空间，这种情况发生的程度可能会有所帮助。从向量空间中的采样区域中取出一个样本区域，看看在我们对 <math
    alttext="在 i 上方修改"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math> 和
    <math alttext="在 j 上方修改"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math>
    进行缩放后会发生什么？
- en: '![emds 0420](Images/emds_0420.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0420](Images/emds_0420.png)'
- en: Figure 4-20\. A determinant measures how a linear transformation scales an area
  id: totrans-156
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-20\. 一个行列式测量线性变换如何缩放一个区域
- en: Note it increases in area by a factor of 6.0, and this factor is known as a
    *determinant*. Determinants describe how much a sampled area in a vector space
    changes in scale with linear transformations, and this can provide helpful information
    about the transformation.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，面积增加了6.0倍，这个因子被称为*行列式*。行列式描述了在向量空间中采样区域随线性变换的尺度变化，这可以提供有关变换的有用信息。
- en: '[Example 4-13](#PAtNLPvfAr) shows how to calculate this determinant in Python.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-13](#PAtNLPvfAr) 展示了如何在 Python 中计算这个行列式。'
- en: Example 4-13\. Calculating a determinant
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-13\. 计算行列式
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Simple shears and rotations should not affect the determinant, as the area will
    not change. [Figure 4-21](#NKgNjQhHDF) and [Example 4-14](#jglHQIPrRe) shows a
    simple shear and the determinant remains a factor 1.0, showing it is unchanged.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的剪切和旋转不会影响行列式，因为面积不会改变。[图 4-21](#NKgNjQhHDF) 和 [示例 4-14](#jglHQIPrRe) 展示了一个简单的剪切，行列式仍然保持为1.0，表明它没有改变。
- en: '![emds 0421](Images/emds_0421.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0421](Images/emds_0421.png)'
- en: Figure 4-21\. A simple shear does not change the determinant
  id: totrans-163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-21\. 简单的剪切不会改变行列式
- en: Example 4-14\. A determinant for a shear
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-14\. 一个剪切的行列式
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: But scaling will increase or decrease the determinant, as that will increase/decrease
    the sampled area. When the orientation flips ( <math alttext="ModifyingAbove i
    With caret"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math> , <math
    alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math>
    swap clockwise positions), then the determinant will be negative. [Figure 4-22](#LgGdleomel)
    and [Example 4-15](#DUDwHbbBQL) illustrate a determinant showing a transformation
    that not only scaled but also flipped the orientation of the vector space.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 但是缩放会增加或减少行列式，因为这会增加/减少采样区域。当方向翻转时（ <math alttext="在 i 上方修改"><mover accent="true"><mi>i</mi>
    <mo>^</mo></mover></math> ， <math alttext="在 j 上方修改"><mover accent="true"><mi>j</mi>
    <mo>^</mo></mover></math> 顺时针交换位置），那么行列式将为负。[图 4-22](#LgGdleomel) 和 [示例 4-15](#DUDwHbbBQL)
    说明了一个行列式展示了一个不仅缩放而且翻转了向量空间方向的变换。
- en: '![emds 0422](Images/emds_0422.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0422](Images/emds_0422.png)'
- en: Figure 4-22\. A determinant on a flipped space is negative
  id: totrans-168
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-22\. 在翻转空间上的行列式是负的
- en: Example 4-15\. A negative determinant
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-15\. 一个负的行列式
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Because this determinant is negative, we quickly see that the orientation has
    flipped. But by far the most critical piece of information the determinant tells
    you is whether the transformation is linearly dependent. If you have a determinant
    of 0, that means all of the space has been squished into a lesser dimension.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个行列式是负的，我们很快就看到方向已经翻转。但行列式告诉你的最关键的信息是变换是否线性相关。如果行列式为0，那意味着所有的空间都被压缩到一个较低的维度。
- en: In [Figure 4-23](#VBGcgBScmp) we see two linearly dependent transformations,
    where a 2D space is compressed into one dimension and a 3D space is compressed
    into two dimensions. The area and volume respectively in both cases are 0!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图4-23](#VBGcgBScmp)中，我们看到两个线性相关的变换，其中一个二维空间被压缩成一维，一个三维空间被压缩成两维。在这两种情况下，面积和体积分别为0！
- en: '![emds 0423](Images/emds_0423.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0423](Images/emds_0423.png)'
- en: Figure 4-23\. Linear dependence in 2D and 3D
  id: totrans-174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-23。二维和三维中的线性依赖
- en: '[Example 4-16](#gvdhUhSoVO) shows the code for the preceding 2D example squishing
    an entire 2D space into a single one-dimensional number line.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例4-16](#gvdhUhSoVO)展示了前述2D示例的代码，将整个二维空间压缩成一个一维数轴。'
- en: Example 4-16\. A determinant of zero
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-16。行列式为零
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So testing for a 0 determinant is highly helpful to determine if a transformation
    has linear dependence. When you encounter this you will likely find a difficult
    or unsolvable problem on your hands.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试行列式为0对于确定一个变换是否具有线性依赖性非常有帮助。当你遇到这种情况时，你可能会发现手头上有一个困难或无法解决的问题。
- en: Special Types of Matrices
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊类型的矩阵
- en: There are a few notable cases of matrices that we should cover.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该涵盖一些值得注意的矩阵情况。
- en: Square Matrix
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方阵
- en: 'The *square matrix* is a matrix that has an equal number of rows and columns:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*方阵*是行数和列数相等的矩阵：'
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 4 2nd Column 2 3rd Column
    7 2nd Row 1st Column 5 2nd Column 1 3rd Column 9 3rd Row 1st Column 4 2nd Column
    0 3rd Column 1 EndMatrix" display="block"><mfenced separators="" open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>7</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>9</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></math>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 4 2nd Column 2 3rd Column
    7 2nd Row 1st Column 5 2nd Column 1 3rd Column 9 3rd Row 1st Column 4 2nd Column
    0 3rd Column 1 EndMatrix" display="block"><mfenced separators="" open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>7</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>9</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></math>
- en: They are primarily used to represent linear transformations and are a requirement
    for many operations like eigendecomposition.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 它们主要用于表示线性变换，并且是许多操作的要求，如特征分解。
- en: Identity Matrix
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份矩阵
- en: 'The *identity matrix* is a square matrix that has a diagonal of 1s while the
    other values are 0:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*身份矩阵*是一个对角线为1的方阵，而其他值为0：'
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column 0 3rd Column
    0 2nd Row 1st Column 0 2nd Column 1 3rd Column 0 3rd Row 1st Column 0 2nd Column
    0 3rd Column 1 EndMatrix" display="block"><mfenced separators="" open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></math>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column 0 3rd Column
    0 2nd Row 1st Column 0 2nd Column 1 3rd Column 0 3rd Row 1st Column 0 2nd Column
    0 3rd Column 1 EndMatrix" display="block"><mfenced separators="" open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></math>
- en: What’s the big deal with identity matrices? Well, when you have an identity
    matrix, you essentially have undone a transformation and found your starting basis
    vectors. This will play a big role in solving systems of equations in the next
    section.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 身份矩阵有什么了不起的地方？当你有一个身份矩阵时，实际上是撤销了一个变换并找到了起始基向量。这在下一节解方程组中将起到重要作用。
- en: Inverse Matrix
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逆矩阵
- en: 'An *inverse matrix* is a matrix that undoes the transformation of another matrix.
    Let’s say I have matrix *A*:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*逆矩阵*是一个可以撤销另一个矩阵变换的矩阵。假设我有矩阵*A*：'
- en: <math alttext="upper A equals Start 3 By 3 Matrix 1st Row 1st Column 4 2nd Column
    2 3rd Column 4 2nd Row 1st Column 5 2nd Column 3 3rd Column 7 3rd Row 1st Column
    9 2nd Column 3 3rd Column 6 EndMatrix" display="block"><mrow><mi>A</mi> <mo>=</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd> <mtd><mn>2</mn></mtd>
    <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>7</mn></mtd></mtr>
    <mtr><mtd><mn>9</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>6</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper A equals Start 3 By 3 Matrix 1st Row 1st Column 4 2nd Column
    2 3rd Column 4 2nd Row 1st Column 5 2nd Column 3 3rd Column 7 3rd Row 1st Column
    9 2nd Column 3 3rd Column 6 EndMatrix" display="block"><mrow><mi>A</mi> <mo>=</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd> <mtd><mn>2</mn></mtd>
    <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>7</mn></mtd></mtr>
    <mtr><mtd><mn>9</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>6</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'The inverse of matrix *A* is called <math alttext="upper A Superscript negative
    1"><msup><mi>A</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math> . We will
    learn how to calculate the inverse using Sympy or NumPy in the next section, but
    this is what the inverse of matrix *A* is:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵*A*的逆被称为<math alttext="upper A Superscript negative 1"><msup><mi>A</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>。我们将在下一节学习如何使用Sympy或NumPy计算逆，但这就是矩阵*A*的逆：
- en: <math alttext="upper A Superscript negative 1 Baseline equals Start 3 By 3 Matrix
    1st Row 1st Column negative one-half 2nd Column 0 3rd Column one-third 2nd Row
    1st Column 5.5 2nd Column negative 2 3rd Column four-thirds 3rd Row 1st Column
    negative 2 2nd Column 1 3rd Column one-third EndMatrix" display="block"><mrow><msup><mi>A</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mo>-</mo>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac></mrow></mtd> <mtd><mn>0</mn></mtd> <mtd><mfrac><mn>1</mn>
    <mn>3</mn></mfrac></mtd></mtr> <mtr><mtd><mrow><mn>5</mn> <mo>.</mo> <mn>5</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd> <mtd><mfrac><mn>4</mn> <mn>3</mn></mfrac></mtd></mtr>
    <mtr><mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mfrac><mn>1</mn>
    <mn>3</mn></mfrac></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper A Superscript negative 1 Baseline equals Start 3 By 3 Matrix
    1st Row 1st Column negative one-half 2nd Column 0 3rd Column one-third 2nd Row
    1st Column 5.5 2nd Column negative 2 3rd Column four-thirds 3rd Row 1st Column
    negative 2 2nd Column 1 3rd Column one-third EndMatrix" display="block"><mrow><msup><mi>A</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mo>-</mo>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac></mrow></mtd> <mtd><mn>0</mn></mtd> <mtd><mfrac><mn>1</mn>
    <mn>3</mn></mfrac></mtd></mtr> <mtr><mtd><mrow><mn>5</mn> <mo>.</mo> <mn>5</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd> <mtd><mfrac><mn>4</mn> <mn>3</mn></mfrac></mtd></mtr>
    <mtr><mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mfrac><mn>1</mn>
    <mn>3</mn></mfrac></mtd></mtr></mtable></mfenced></mrow></math>
- en: When we perform matrix multiplication between <math alttext="upper A Superscript
    negative 1"><msup><mi>A</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math> and
    *A*, we end up with an identity matrix. We will see this in action with NumPy
    and Sympy in the next section on systems of equations.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在<math alttext="upper A Superscript negative 1"><msup><mi>A</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>和*A*之间进行矩阵乘法时，我们得到一个身份矩阵。我们将在下一节关于方程组的NumPy和Sympy中看到这一点。
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column negative one-half 2nd
    Column 0 3rd Column one-third 2nd Row 1st Column 5.5 2nd Column negative 2 3rd
    Column four-thirds 3rd Row 1st Column negative 2 2nd Column 1 3rd Column one-third
    EndMatrix Start 3 By 3 Matrix 1st Row 1st Column 4 2nd Column 2 3rd Column 4 2nd
    Row 1st Column 5 2nd Column 3 3rd Column 7 3rd Row 1st Column 9 2nd Column 3 3rd
    Column 6 EndMatrix equals Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column
    0 3rd Column 0 2nd Row 1st Column 0 2nd Column 1 3rd Column 0 3rd Row 1st Column
    0 2nd Column 0 3rd Column 1 EndMatrix" display="block"><mrow><mfenced open="["
    close="]"><mtable><mtr><mtd><mrow><mo>-</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac></mrow></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mfrac><mn>1</mn> <mn>3</mn></mfrac></mtd></mtr> <mtr><mtd><mrow><mn>5</mn>
    <mo>.</mo> <mn>5</mn></mrow></mtd> <mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd>
    <mtd><mfrac><mn>4</mn> <mn>3</mn></mfrac></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mfrac><mn>1</mn> <mn>3</mn></mfrac></mtd></mtr></mtable></mfenced>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd> <mtd><mn>2</mn></mtd>
    <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>7</mn></mtd></mtr>
    <mtr><mtd><mn>9</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>6</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced separators="" open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column negative one-half 2nd
    Column 0 3rd Column one-third 2nd Row 1st Column 5.5 2nd Column negative 2 3rd
    Column four-thirds 3rd Row 1st Column negative 2 2nd Column 1 3rd Column one-third
    EndMatrix Start 3 By 3 Matrix 1st Row 1st Column 4 2nd Column 2 3rd Column 4 2nd
    Row 1st Column 5 2nd Column 3 3rd Column 7 3rd Row 1st Column 9 2nd Column 3 3rd
    Column 6 EndMatrix equals Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column
    0 3rd Column 0 2nd Row 1st Column 0 2nd Column 1 3rd Column 0 3rd Row 1st Column
    0 2nd Column 0 3rd Column 1 EndMatrix" display="block"><mrow><mfenced open="["
    close="]"><mtable><mtr><mtd><mrow><mo>-</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac></mrow></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mfrac><mn>1</mn> <mn>3</mn></mfrac></mtd></mtr> <mtr><mtd><mrow><mn>5</mn>
    <mo>.</mo> <mn>5</mn></mrow></mtd> <mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd>
    <mtd><mfrac><mn>4</mn> <mn>3</mn></mfrac></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mfrac><mn>1</mn> <mn>3</mn></mfrac></mtd></mtr></mtable></mfenced>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd> <mtd><mn>2</mn></mtd>
    <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>7</mn></mtd></mtr>
    <mtr><mtd><mn>9</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>6</mn></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced separators="" open="[" close="]"><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: Diagonal Matrix
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对角矩阵
- en: Similar to the identity matrix is the *diagonal matrix*, which has a diagonal
    of nonzero values while the rest of the values are 0\. Diagonal matrices are desirable
    in certain computations because they represent simple scalars being applied to
    a vector space. It shows up in some linear algebra operations.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 与身份矩阵类似的是*对角矩阵*，它在对角线上有非零值，而其余值为0。对角矩阵在某些计算中是可取的，因为它们代表应用于向量空间的简单标量。它出现在一些线性代数操作中。
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 4 2nd Column 0 3rd Column
    0 2nd Row 1st Column 0 2nd Column 2 3rd Column 0 3rd Row 1st Column 0 2nd Column
    0 3rd Column 5 EndMatrix" display="block"><mfenced separators="" open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>2</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced></math>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 4 2nd Column 0 3rd Column
    0 2nd Row 1st Column 0 2nd Column 2 3rd Column 0 3rd Row 1st Column 0 2nd Column
    0 3rd Column 5 EndMatrix" display="block"><mfenced separators="" open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>2</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced></math>
- en: Triangular Matrix
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三角矩阵
- en: Similar to the diagonal matrix is the *triangular matrix*, which has a diagonal
    of nonzero values in front of a triangle of values, while the rest of the values
    are 0.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与对角矩阵类似的是*三角矩阵*，它在一个三角形值的对角线前有非零值，而其余值为0。
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 4 2nd Column 2 3rd Column
    9 2nd Row 1st Column 0 2nd Column 1 3rd Column 6 3rd Row 1st Column 0 2nd Column
    0 3rd Column 5 EndMatrix" display="block"><mfenced separators="" open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>9</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>6</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced></math>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 4 2nd Column 2 3rd Column
    9 2nd Row 1st Column 0 2nd Column 1 3rd Column 6 3rd Row 1st Column 0 2nd Column
    0 3rd Column 5 EndMatrix" display="block"><mfenced separators="" open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>9</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>6</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable></mfenced></math>
- en: Triangular matrices are desirable in many numerical analysis tasks, because
    they typically are easier to solve in systems of equations. They also show up
    in certain decomposition tasks like [LU Decomposition](https://oreil.ly/vYK8t).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 三角矩阵在许多数值分析任务中是理想的，因为它们通常更容易在方程组中解决。它们也出现在某些分解任务中，比如[LU分解](https://oreil.ly/vYK8t)。
- en: Sparse Matrix
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 稀疏矩阵
- en: Occasionally, you will run into matrices that are mostly zeroes and have very
    few nonzero elements. These are called *sparse matrices*. From a pure mathematical
    standpoint, they are not terribly interesting. But from a computing standpoint,
    they provide opportunities to create efficiency. If a matrix has mostly 0s, a
    sparse matrix implementation will not waste space storing a bunch of 0s, and instead
    only keep track of the cells that are nonzero.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你会遇到大部分元素为零且只有很少非零元素的矩阵。这些被称为*稀疏矩阵*。从纯数学的角度来看，它们并不是特别有趣。但从计算的角度来看，它们提供了创造效率的机会。如果一个矩阵大部分为0，稀疏矩阵的实现将不会浪费空间存储大量的0，而是只跟踪非零的单元格。
- en: <math alttext="sparse colon Start 4 By 3 Matrix 1st Row 1st Column 0 2nd Column
    0 3rd Column 0 2nd Row 1st Column 0 2nd Column 0 3rd Column 2 3rd Row 1st Column
    0 2nd Column 0 3rd Column 0 4th Row 1st Column 0 2nd Column 0 3rd Column 0 EndMatrix"
    display="block"><mrow><mtext>sparse:</mtext> <mfenced separators="" open="[" close="]"><mtable><mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="sparse colon Start 4 By 3 Matrix 1st Row 1st Column 0 2nd Column
    0 3rd Column 0 2nd Row 1st Column 0 2nd Column 0 3rd Column 2 3rd Row 1st Column
    0 2nd Column 0 3rd Column 0 4th Row 1st Column 0 2nd Column 0 3rd Column 0 EndMatrix"
    display="block"><mrow><mtext>sparse:</mtext> <mfenced separators="" open="[" close="]"><mtable><mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: When you have large matrices that are sparse, you might explicitly use a sparse
    function to create your matrix.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有大型稀疏矩阵时，你可能会明确使用稀疏函数来创建你的矩阵。
- en: Systems of Equations and Inverse Matrices
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方程组和逆矩阵
- en: 'One of the basic use cases for linear algebra is solving systems of equations.
    It is also a good application to learn about inverse matrices. Let’s say you are
    provided with the following equations and you need to solve for *x*, *y*, and
    *z*:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数的基本用例之一是解方程组。学习逆矩阵也是一个很好的应用。假设你被提供以下方程，需要解出*x*、*y*和*z*：
- en: <math display="block"><mrow><mn>4</mn> <mi>x</mi> <mo>+</mo> <mn>2</mn> <mi>y</mi>
    <mo>+</mo> <mn>4</mn> <mi>z</mi> <mo>=</mo> <mn>44</mn></mrow></math> <math display="block"><mrow><mn>5</mn>
    <mi>x</mi> <mo>+</mo> <mn>3</mn> <mi>y</mi> <mo>+</mo> <mn>7</mn> <mi>z</mi> <mo>=</mo>
    <mn>56</mn></mrow></math> <math display="block"><mrow><mn>9</mn> <mi>x</mi> <mo>+</mo>
    <mn>3</mn> <mi>y</mi> <mo>+</mo> <mn>6</mn> <mi>z</mi> <mo>=</mo> <mn>72</mn></mrow></math>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><mn>4</mn> <mi>x</mi> <mo>+</mo> <mn>2</mn> <mi>y</mi>
    <mo>+</mo> <mn>4</mn> <mi>z</mi> <mo>=</mo> <mn>44</mn></mrow></math> <math display="block"><mrow><mn>5</mn>
    <mi>x</mi> <mo>+</mo> <mn>3</mn> <mi>y</mi> <mo>+</mo> <mn>7</mn> <mi>z</mi> <mo>=</mo>
    <mn>56</mn></mrow></math> <math display="block"><mrow><mn>9</mn> <mi>x</mi> <mo>+</mo>
    <mn>3</mn> <mi>y</mi> <mo>+</mo> <mn>6</mn> <mi>z</mi> <mo>=</mo> <mn>72</mn></mrow></math>
- en: 'You can try manually experimenting with different algebraic operations to isolate
    the three variables, but if you want a computer to solve it you will need to express
    this problem in terms of matrices as shown next. Extract the coefficients into
    matrix *A*, the values on the right side of the equation into matrix *B*, and
    the unknown variables into matrix *X*:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试手动尝试不同的代数运算来分离三个变量，但如果你想让计算机解决它，你需要将这个问题用矩阵表示，如下所示。将系数提取到矩阵*A*中，方程右侧的值提取到矩阵*B*中，未知变量提取到矩阵*X*中：
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>A</mi>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd> <mtd><mn>2</mn></mtd>
    <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>7</mn></mtd></mtr>
    <mtr><mtd><mn>9</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>6</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>B</mi>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>44</mn></mtd></mtr>
    <mtr><mtd><mn>56</mn></mtd></mtr> <mtr><mtd><mn>72</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>X</mi>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr>
    <mtr><mtd><mi>y</mi></mtd></mtr> <mtr><mtd><mi>z</mi></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>A</mi>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd> <mtd><mn>2</mn></mtd>
    <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>7</mn></mtd></mtr>
    <mtr><mtd><mn>9</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>6</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>B</mi>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>44</mn></mtd></mtr>
    <mtr><mtd><mn>56</mn></mtd></mtr> <mtr><mtd><mn>72</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>X</mi>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr>
    <mtr><mtd><mi>y</mi></mtd></mtr> <mtr><mtd><mi>z</mi></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
- en: 'The function for a linear system of equations is *AX* = *B*. We need to transform
    matrix *A* with some other matrix *X* that will result in matrix *B*:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 线性方程组的函数是*AX* = *B*。我们需要用另一个矩阵*X*转换矩阵*A*，结果得到矩阵*B*：
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>A</mi>
    <mi>X</mi> <mo>=</mo> <mi>B</mi></mrow></mtd></mtr></mtable></math> <math display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfenced open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd> <mtd><mn>3</mn></mtd>
    <mtd><mn>7</mn></mtd></mtr> <mtr><mtd><mn>9</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>6</mn></mtd></mtr></mtable></mfenced>
    <mo>·</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr>
    <mtr><mtd><mi>y</mi></mtd></mtr> <mtr><mtd><mi>z</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>44</mn></mtd></mtr>
    <mtr><mtd><mn>56</mn></mtd></mtr> <mtr><mtd><mn>72</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>A</mi>
    <mi>X</mi> <mo>=</mo> <mi>B</mi></mrow></mtd></mtr></mtable></math> <math display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfenced open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd> <mtd><mn>3</mn></mtd>
    <mtd><mn>7</mn></mtd></mtr> <mtr><mtd><mn>9</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>6</mn></mtd></mtr></mtable></mfenced>
    <mo>·</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr>
    <mtr><mtd><mi>y</mi></mtd></tr> <mtr><mtd><mi>z</mi></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>44</mn></mtd></mtr>
    <mtr><mtd><mn>56</mn></mtd></tr> <mtr><mtd><mn>72</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
- en: 'We need to “undo” *A* so we can isolate *X* and get the values for *x*, *y*,
    and *z*. The way you undo *A* is to take the inverse of *A* denoted by <math alttext="upper
    A Superscript negative 1"><msup><mi>A</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    and apply it to *A* via matrix multiplication. We can express this algebraically:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要“撤销”*A*，这样我们就可以隔离*X*并获得*x*、*y*和*z*的值。撤销*A*的方法是取*A*的逆，用<math alttext="upper
    A Superscript negative 1"><msup><mi>A</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>表示，并通过矩阵乘法应用于*A*。我们可以用代数方式表达这一点：
- en: <math display="block"><mrow><mi>A</mi> <mi>X</mi> <mo>=</mo> <mi>B</mi></mrow></math>
    <math display="block"><mrow><msup><mi>A</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>A</mi> <mi>X</mi> <mo>=</mo> <msup><mi>A</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>B</mi></mrow></math> <math display="block"><mrow><mi>X</mi> <mo>=</mo> <msup><mi>A</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>B</mi></mrow></math>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><mi>A</mi> <mi>X</mi> <mo>=</mo> <mi>B</mi></mrow></math>
    <math display="block"><mrow><msup><mi>A</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>A</mi> <mi>X</mi> <mo>=</mo> <msup><mi>A</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>B</mi></mrow></math> <math display="block"><mrow><mi>X</mi> <mo>=</mo> <msup><mi>A</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>B</mi></mrow></math>
- en: 'To calculate the inverse of matrix *A*, we probably use a computer rather than
    searching for solutions by hand using Gaussian elimination, which we will not
    venture into in this book. Here is the inverse of matrix *A*:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算矩阵*A*的逆，我们可能会使用计算机，而不是手动使用高斯消元法寻找解决方案，这在本书中我们不会涉及。这是矩阵*A*的逆：
- en: <math alttext="upper A Superscript negative 1 Baseline equals Start 3 By 3 Matrix
    1st Row 1st Column negative one-half 2nd Column 0 3rd Column one-third 2nd Row
    1st Column 5.5 2nd Column negative 2 3rd Column four-thirds 3rd Row 1st Column
    negative 2 2nd Column 1 3rd Column one-third EndMatrix" display="block"><mrow><msup><mi>A</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mo>-</mo>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac></mrow></mtd> <mtd><mn>0</mn></mtd> <mtd><mfrac><mn>1</mn>
    <mn>3</mn></mfrac></mtd></mtr> <mtr><mtd><mrow><mn>5</mn> <mo>.</mo> <mn>5</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd> <mtd><mfrac><mn>4</mn> <mn>3</mn></mfrac></mtd></mtr>
    <mtr><mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mfrac><mn>1</mn>
    <mn>3</mn></mfrac></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper A Superscript negative 1 Baseline equals Start 3 By 3 Matrix
    1st Row 1st Column negative one-half 2nd Column 0 3rd Column one-third 2nd Row
    1st Column 5.5 2nd Column negative 2 3rd Column four-thirds 3rd Row 1st Column
    negative 2 2nd Column 1 3rd Column one-third EndMatrix" display="block"><mrow><msup><mi>A</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mo>-</mo>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac></mrow></mtd> <mtd><mn>0</mn></mtd> <mtd><mfrac><mn>1</mn>
    <mn>3</mn></mfrac></mtd></mtr> <mtr><mtd><mrow><mn>5</mn> <mo>.</mo> <mn>5</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd> <mtd><mfrac><mn>4</mn> <mn>3</mn></mfrac></mtd></mtr>
    <mtr><mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mfrac><mn>1</mn>
    <mn>3</mn></mfrac></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'Note when we matrix multiply <math alttext="upper A Superscript negative 1"><msup><mi>A</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></math> against *A* it will create an
    identity matrix, a matrix of all zeroes except for 1s in the diagonal. The identity
    matrix is the linear algebra equivalent of multiplying by 1, meaning it essentially
    has no effect and will effectively isolate values for *x*, *y*, and *z*:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将<math alttext="upper A Superscript negative 1"><msup><mi>A</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>与*A*相乘时，将创建一个单位矩阵，一个除了对角线上为1之外全为零的矩阵。单位矩阵是线性代数中相当于乘以1的概念，意味着它基本上没有影响，将有效地隔离*x*、*y*和*z*的值：
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><msup><mi>A</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mo>-</mo>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac></mrow></mtd> <mtd><mn>0</mn></mtd> <mtd><mfrac><mn>1</mn>
    <mn>3</mn></mfrac></mtd></mtr> <mtr><mtd><mrow><mn>5</mn> <mo>.</mo> <mn>5</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd> <mtd><mfrac><mn>4</mn> <mn>3</mn></mfrac></mtd></mtr>
    <mtr><mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mfrac><mn>1</mn>
    <mn>3</mn></mfrac></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>A</mi>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd> <mtd><mn>2</mn></mtd>
    <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>7</mn></mtd></mtr>
    <mtr><mtd><mn>9</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>6</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><msup><mi>A</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>A</mi> <mo>=</mo> <mfenced open="["
    close="]"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><msup><mi>A</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mrow><mo>-</mo>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac></mrow></mtd> <mtd><mn>0</mn></mtd> <mtd><mfrac><mn>1</mn>
    <mn>3</mn></mfrac></mtd></mtr> <mtr><mtd><mrow><mn>5</mn> <mo>.</mo> <mn>5</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd> <mtd><mfrac><mn>4</mn> <mn>3</mn></mfrac></mtd></mtr>
    <mtr><mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mfrac><mn>1</mn>
    <mn>3</mn></mfrac></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>A</mi>
    <mo>=</mo> <mfenced open="[" close="]"><mtable><mtr><mtd><mn>4</mn></mtd> <mtd><mn>2</mn></mtd>
    <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>5</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>7</mn></mtd></mtr>
    <mtr><mtd><mn>9</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>6</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><msup><mi>A</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>A</mi> <mo>=</mo> <mfenced open="["
    close="]"><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
- en: To see this identity matrix in action in Python, you will want to use SymPy
    instead of NumPy. The floating point decimals in NumPy will not make the identity
    matrix as obvious, but doing it symbolically in [Example 4-17](#chOOTGrRCm) we
    will see a clean, symbolic output. Note that to do matrix multiplication in SymPy
    we use the asterisk *** rather than *@*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Python 中看到这个单位矩阵的运作，您将需要使用 SymPy 而不是 NumPy。 NumPy 中的浮点小数不会使单位矩阵显得那么明显，但在[示例 4-17](#chOOTGrRCm)中以符号方式进行，我们将看到一个清晰的符号输出。请注意，在
    SymPy 中进行矩阵乘法时，我们使用星号 *** 而不是 *@*。
- en: Example 4-17\. Using SymPy to study the inverse and identity matrix
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-17\. 使用 SymPy 研究逆矩阵和单位矩阵
- en: '[PRE17]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In practice, the lack of floating point precision will not affect our answers
    too badly, so using NumPy should be fine to solve for *x*. [Example 4-18](#wqpBKiRBAT)
    shows a solution with NumPy.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，浮点精度的缺失不会对我们的答案产生太大影响，因此使用 NumPy 来解决 *x* 应该是可以的。[示例 4-18](#wqpBKiRBAT)
    展示了使用 NumPy 的解决方案。
- en: Example 4-18\. Using NumPy to solve a system of equations
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-18\. 使用 NumPy 解决一组方程
- en: '[PRE18]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So *x* = 2, *y* = 34, and *z* = –8\. [Example 4-19](#dpclnceGpV) shows the full
    solution in SymPy as an alternative to NumPy.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 因此 *x* = 2，*y* = 34，*z* = –8\. [示例 4-19](#dpclnceGpV) 展示了 SymPy 中的完整解决方案，作为
    NumPy 的替代方案。
- en: Example 4-19\. Using SymPy to solve a system of equations
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-19\. 使用 SymPy 解决一组方程
- en: '[PRE19]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is the solution in mathematical notation:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是数学符号表示的解决方案：
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><msup><mi>A</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>B</mi> <mo>=</mo> <mi>X</mi></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfenced
    open="[" close="]"><mtable><mtr><mtd><mrow><mo>-</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac></mrow></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mfrac><mn>1</mn> <mn>3</mn></mfrac></mtd></mtr> <mtr><mtd><mrow><mn>5</mn>
    <mo>.</mo> <mn>5</mn></mrow></mtd> <mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd>
    <mtd><mfrac><mn>4</mn> <mn>3</mn></mfrac></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mfrac><mn>1</mn> <mn>3</mn></mfrac></mtd></mtr></mtable></mfenced>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>44</mn></mtd></mtr> <mtr><mtd><mn>56</mn></mtd></mtr>
    <mtr><mtd><mn>72</mn></mtd></mtr></mtable></mfenced> <mo>=</mo> <mfenced open="["
    close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr>
    <mtr><mtd><mi>z</mi></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>34</mn></mtd></mtr>
    <mtr><mtd><mrow><mo>-</mo> <mn>8</mn></mrow></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr>
    <mtr><mtd><mi>z</mi></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><msup><mi>A</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>B</mi> <mo>=</mo> <mi>X</mi></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfenced
    open="[" close="]"><mtable><mtr><mtd><mrow><mo>-</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac></mrow></mtd>
    <mtd><mn>0</mn></td> <mtd><mfrac><mn>1</mn> <mn>3</mn></mfrac></mtd></mtr> <mtr><mtd><mrow><mn>5</mn>
    <mo>.</mo> <mn>5</mn></mrow></mtd> <mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd>
    <mtd><mfrac><mn>4</mn> <mn>3</mn></mfrac></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mfrac><mn>1</mn> <mn>3</mn></mfrac></mtd></mtr></mtable></mfenced>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mn>44</mn></mtd></mtr> <mtr><mtd><mn>56</mn></mtd></mtr>
    <mtr><mtd><mn>72</mn></mtd></mtr></mtable></mfenced> <mo>=</mo> <mfenced open="["
    close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr>
    <mtr><mtd><mi>z</mi></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mfenced
    open="[" close="]"><mtable><mtr><mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>34</mn></mtd></mtr>
    <mtr><mtd><mrow><mo>-</mo> <mn>8</mn></mrow></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced open="[" close="]"><mtable><mtr><mtd><mi>x</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd></mtr>
    <mtr><mtd><mi>z</mi></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
- en: Hopefully, this gave you an intuition for inverse matrices and how they can
    be used to solve a system of equations.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这给了你逆矩阵的直觉以及它们如何用于解方程组的用途。
- en: Systems of Equations in Linear Programming
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性规划中的方程组
- en: This method of solving systems of equations is used for linear programming as
    well, where inequalities define constraints and an objective is minimized/maximized.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解方程组的方法也用于线性规划，其中不等式定义约束条件，目标是最小化/最大化。
- en: '[PatrickJMT has a lot of good videos on Linear Programming](https://bit.ly/3aVyrD6).
    We also cover it briefly in [Appendix A](app01.xhtml#appendix).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[PatrickJMT 在线性规划方面有很多优质视频](https://bit.ly/3aVyrD6)。我们也在[附录 A](app01.xhtml#appendix)中简要介绍了它。'
- en: In practicality, you should rarely find it necessary to calculate inverse matrices
    by hand and can have a computer do it for you. But if you have a need or are curious,
    you will want to learn about Gaussian elimination. [PatrickJMT on YouTube](https://oreil.ly/RfXAv)
    has a number of videos demonstrating Gaussian elimination.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际操作中，你很少需要手动计算逆矩阵，可以让计算机为你完成。但如果你有需求或好奇，你会想了解高斯消元法。[PatrickJMT 在 YouTube 上的视频](https://oreil.ly/RfXAv)展示了许多关于高斯消元法的视频。
- en: Eigenvectors and Eigenvalues
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征向量和特征值
- en: '*Matrix decomposition* is breaking up a matrix into its basic components, much
    like factoring numbers (e.g., 10 can be factored to 2 × 5).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*矩阵分解*是将矩阵分解为其基本组件，类似于分解数字（例如，10 可以分解为 2 × 5）。'
- en: Matrix decomposition is helpful for tasks like finding inverse matrices and
    calculating determinants, as well as linear regression. There are many ways to
    decompose a matrix depending on your task. In [Chapter 5](ch05.xhtml#ch05) we
    will use a matrix decomposition technique, QR decomposition, to perform a linear
    regression.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵分解对于诸如找到逆矩阵、计算行列式以及线性回归等任务非常有帮助。根据你的任务，有许多分解矩阵的方法。在[第 5 章](ch05.xhtml#ch05)中，我们将使用一种矩阵分解技术，QR
    分解，来执行线性回归。
- en: But in this chapter let’s focus on a common method called eigendecomposition,
    which is often used for machine learning and principal component analysis. At
    this level we do not have the bandwidth to dive into each of these applications.
    For now, just know eigendecomposition is helpful for breaking up a matrix into
    components that are easier to work with in different machine learning tasks. Note
    also it only works on square matrices.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 但在本章中，让我们专注于一种常见方法，称为特征分解，这经常用于机器学习和主成分分析。在这个层面上，我们没有精力深入研究每个应用。现在，只需知道特征分解有助于将矩阵分解为在不同机器学习任务中更易处理的组件。还要注意它只适用于方阵。
- en: 'In eigendecomposition, there are two components: the eigenvalues denoted by
    lambda <math alttext="lamda"><mi>λ</mi></math> and eigenvector by *v* shown in
    [Figure 4-24](#mFUgimEtDa).'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在特征分解中，有两个组成部分：用 lambda 表示的特征值 <math alttext="lamda"><mi>λ</mi></math> 和用 *v*
    表示的特征向量，如 [图 4-24](#mFUgimEtDa) 所示。
- en: '![emds 0424](Images/emds_0424.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![emds 0424](Images/emds_0424.png)'
- en: Figure 4-24\. The eigenvector and eigenvalues
  id: totrans-242
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-24\. 特征向量和特征值
- en: 'If we have a square matrix *A*, it has the following eigenvalue equation:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个方阵 *A*，它有以下特征值方程：
- en: <math alttext="dollar-sign upper A v equals lamda v dollar-sign"><mrow><mi>A</mi>
    <mi>v</mi> <mo>=</mo> <mi>λ</mi> <mi>v</mi></mrow></math>
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper A v equals lamda v dollar-sign"><mrow><mi>A</mi>
    <mi>v</mi> <mo>=</mo> <mi>λ</mi> <mi>v</mi></mrow></math>
- en: If *A* is the original matrix, it is composed of eigenvector <math alttext="v"><mi>v</mi></math>
    and eigenvalue <math alttext="lamda"><mi>λ</mi></math> . There is one eigenvector
    and eigenvalue for each dimension of the parent matrix, and not all matrices can
    be decomposed into an eigenvector and eigenvalue. Sometimes complex (imaginary)
    numbers will even result.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *A* 是原始矩阵，它由特征向量 <math alttext="v"><mi>v</mi></math> 和特征值 <math alttext="lamda"><mi>λ</mi></math>
    组成。对于父矩阵的每个维度，都有一个特征向量和特征值，并非所有矩阵都可以分解为特征向量和特征值。有时甚至会出现复数（虚数）。
- en: '[Example 4-20](#QVjawvbekH) is how we calculate eigenvectors and eigenvalues
    in NumPy for a given matrix <math alttext="upper A"><mi>A</mi></math> .'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-20](#QVjawvbekH) 是我们如何在 NumPy 中为给定矩阵 <math alttext="upper A"><mi>A</mi></math>
    计算特征向量和特征值的方法。'
- en: Example 4-20\. Performing eigendecomposition in NumPy
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-20\. 在 NumPy 中执行特征分解
- en: '[PRE20]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So how do we rebuild matrix *A* from the eigenvectors and eigenvalues? Recall
    this formula:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何从特征向量和特征值重建矩阵 *A* 呢？回想一下这个公式：
- en: <math alttext="dollar-sign upper A v equals lamda v dollar-sign"><mrow><mi>A</mi>
    <mi>v</mi> <mo>=</mo> <mi>λ</mi> <mi>v</mi></mrow></math>
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper A v equals lamda v dollar-sign"><mrow><mi>A</mi>
    <mi>v</mi> <mo>=</mo> <mi>λ</mi> <mi>v</mi></mrow></math>
- en: 'We need to make a few tweaks to the formula to reconstruct *A*:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对重构 *A* 的公式进行一些调整：
- en: <math alttext="dollar-sign upper A equals upper Q normal upper Lamda upper Q
    Superscript negative 1 dollar-sign"><mrow><mi>A</mi> <mo>=</mo> <mi>Q</mi> <mi>Λ</mi>
    <msup><mi>Q</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper A equals upper Q normal upper Lamda upper Q
    Superscript negative 1 dollar-sign"><mrow><mi>A</mi> <mo>=</mo> <mi>Q</mi> <mi>Λ</mi>
    <msup><mi>Q</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
- en: In this new formula, <math alttext="upper Q"><mi>Q</mi></math> is the eigenvectors,
    <math alttext="normal upper Lamda"><mi>Λ</mi></math> is the eigenvalues in diagonal
    form, and <math alttext="upper Q Superscript negative 1"><msup><mi>Q</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    is the inverse matrix of <math alttext="upper Q"><mi>Q</mi></math> . Diagonal
    form means the vector is padded into a matrix of zeroes and occupies the diagonal
    line in a similar pattern to an identity matrix.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新公式中，<math alttext="upper Q"><mi>Q</mi></math> 是特征向量，<math alttext="normal
    upper Lamda"><mi>Λ</mi></math> 是对角形式的特征值，<math alttext="upper Q Superscript negative
    1"><msup><mi>Q</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math> 是 <math alttext="upper
    Q"><mi>Q</mi></math> 的逆矩阵。对角形式意味着向量被填充成一个零矩阵，并且占据对角线，类似于单位矩阵的模式。
- en: '[Example 4-21](#dJbWIrPcEW) brings the example full circle in Python, starting
    with decomposing the matrix and then recomposing it.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-21](#dJbWIrPcEW) 在 Python 中将示例完整地展示，从分解矩阵开始，然后重新组合它。'
- en: Example 4-21\. Decomposing and recomposing a matrix in NumPy
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-21\. 在 NumPy 中分解和重组矩阵
- en: '[PRE21]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, the matrix we rebuilt is the one we started with.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们重建的矩阵就是我们开始的那个矩阵。
- en: Conclusion
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: Linear algebra can be maddeningly abstract and it is full of mysteries and ideas
    to ponder. You may find the whole topic is one big rabbit hole, and you would
    be right! However, it is a good idea to continue being curious about it if you
    want to have a long, successful data science career. It is the foundation for
    statistical computing, machine learning, and other applied data science areas.
    Ultimately, it is the foundation for computer science in general. You can certainly
    get away with not knowing it for a while but you will encounter limitations in
    your understanding at some point.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数可能令人困惑，充满了神秘和值得思考的想法。你可能会发现整个主题就像一个大的兔子洞，你是对的！然而，如果你想要有一个长期成功的数据科学职业，继续对它感到好奇是个好主意。它是统计计算、机器学习和其他应用数据科学领域的基础。最终，它是计算机科学的基础。你当然可以一段时间不了解它，但在某个时候你会遇到理解上的限制。
- en: You may wonder how these ideas are practical as they may feel theoretical. Do
    not worry; we will see some practical applications throughout this book. But the
    theory and geometric interpretations are important to have intuition when you
    work with data, and by understanding linear transformations visually you are prepared
    to take on more advanced concepts that may be thrown at you later in your pursuits.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道这些理念如何实际应用，因为它们可能感觉很理论。不用担心；我们将在本书中看到一些实际应用。但是理论和几何解释对于在处理数据时具有直觉是很重要的，通过直观地理解线性变换，你就能为以后可能遇到的更高级概念做好准备。
- en: If you want to learn more about linear programming, there is no better place
    than [3Blue1Brown’s YouTube playlist “Essence of Linear Algebra”](https://oreil.ly/FSCNz).
    The [linear algebra videos from PatrickJMT](https://oreil.ly/Hx9GP) are helpful
    as well.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更多地了解线性规划，没有比[3Blue1Brown的YouTube播放列表“线性代数的本质”](https://oreil.ly/FSCNz)更好的地方了。[PatrickJMT的线性代数视频](https://oreil.ly/Hx9GP)也很有帮助。
- en: If you want to get more comfortable with NumPy, the O’Reilly book *Python for
    Data Analysis* (2nd edition) by Wes McKinney is a recommended read. It does not
    focus much on linear algebra, but it does provide practical instruction on using
    NumPy, Pandas, and Python on datasets.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更加熟悉NumPy，推荐阅读Wes McKinney的O'Reilly图书《Python数据分析》（第二版）。它并不太关注线性代数，但提供了关于在数据集上使用NumPy、Pandas和Python的实用指导。
- en: Exercises
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Vector <math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math> has a value of [1, 2] but then a transformation happens.
    <math alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math>
    lands at [2, 0] and <math alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi>
    <mo>^</mo></mover></math> lands at [0, 1.5]. Where does <math alttext="ModifyingAbove
    v With right-arrow"><mover accent="true"><mi>v</mi> <mo>→</mo></mover></math>
    land?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向量<math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math>的值为[1, 2]，然后发生了一个变换。<math alttext="ModifyingAbove i With
    caret"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math>落在[2, 0]，<math
    alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math>落在[0,
    1.5]。<math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math>会落在哪里？
- en: Vector <math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math> has a value of [1, 2] but then a transformation happens.
    <math alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math>
    lands at [-2, 1] and <math alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi>
    <mo>^</mo></mover></math> lands at [1, -2]. Where does <math alttext="ModifyingAbove
    v With right-arrow"><mover accent="true"><mi>v</mi> <mo>→</mo></mover></math>
    land?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向量<math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math>的值为[1, 2]，然后发生了一个变换。<math alttext="ModifyingAbove i With
    caret"><mover accent="true"><mi>i</mi> <mo>^</mo></mover></math>落在[-2, 1]，<math
    alttext="ModifyingAbove j With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math>落在[1,
    -2]。<math alttext="ModifyingAbove v With right-arrow"><mover accent="true"><mi>v</mi>
    <mo>→</mo></mover></math>会落在哪里？
- en: A transformation <math alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi>
    <mo>^</mo></mover></math> lands at [1, 0] and <math alttext="ModifyingAbove j
    With caret"><mover accent="true"><mi>j</mi> <mo>^</mo></mover></math> lands at
    [2, 2]. What is the determinant of this transformation?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个变换<math alttext="ModifyingAbove i With caret"><mover accent="true"><mi>i</mi>
    <mo>^</mo></mover></math>落在[1, 0]，<math alttext="ModifyingAbove j With caret"><mover
    accent="true"><mi>j</mi> <mo>^</mo></mover></math>落在[2, 2]。这个变换的行列式是多少？
- en: Can two or more linear transformations be done in single linear transformation?
    Why or why not?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个线性变换中是否可以进行两个或更多个线性变换？为什么？
- en: 'Solve the system of equations for *x*, *y*, and *z*:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解方程组以求解*x*、*y*和*z*：
- en: <math display="block"><mrow><mn>3</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn> <mi>y</mi>
    <mo>+</mo> <mn>0</mn> <mi>z</mi> <mo>=</mo> <mo>=</mo> <mn>54</mn></mrow></math>
    <math display="block"><mrow><mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>4</mn> <mi>y</mi>
    <mo>+</mo> <mn>1</mn> <mi>z</mi> <mo>=</mo> <mn>12</mn></mrow></math> <math display="block"><mrow><mn>3</mn>
    <mi>x</mi> <mo>+</mo> <mn>1</mn> <mi>y</mi> <mo>+</mo> <mn>8</mn> <mi>z</mi> <mo>=</mo>
    <mn>6</mn></mrow></math>
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><mn>3</mn> <mi>x</mi> <mo>+</mo> <mn>1</mn> <mi>y</mi>
    <mo>+</mo> <mn>0</mn> <mi>z</mi> <mo>=</mo> <mo>=</mo> <mn>54</mn></mrow></math>
    <math display="block"><mrow><mn>2</mn> <mi>x</mi> <mo>+</mo> <mn>4</mn> <mi>y</mi>
    <mo>+</mo> <mn>1</mn> <mi>z</mi> <mo>=</mo> <mn>12</mn></mrow></math> <math display="block"><mrow><mn>3</mn>
    <mi>x</mi> <mo>+</mo> <mn>1</mn> <mi>y</mi> <mo>+</mo> <mn>8</mn> <mi>z</mi> <mo>=</mo>
    <mn>6</mn></mrow></math>
- en: Is the following matrix linearly dependent? Why or why not?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下矩阵是否线性相关？为什么？
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 2 2nd Column 1 2nd Row
    1st Column 6 2nd Column 3 EndMatrix" display="block"><mfenced open="[" close="]"><mtable><mtr><mtd><mn>2</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>6</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable></mfenced></math>
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 2 2nd Column 1 2nd Row
    1st Column 6 2nd Column 3 EndMatrix" display="block"><mfenced open="[" close="]"><mtable><mtr><mtd><mn>2</mn></mtd>
    <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>6</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable></mfenced></math>
- en: Answers are in [Appendix B](app02.xhtml#exercise_answers).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在[附录 B](app02.xhtml#exercise_answers)中。
