- en: 'Chapter 8\. Find a Motif in DNA: Exploring Sequence Similarity'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。在 DNA 中查找基序：探索序列相似性
- en: In [the Rosalind SUBS challenge](https://oreil.ly/hoUhB), I’ll be searching
    for any occurrences of one sequence inside another. A shared subsequence might
    represent a conserved element such as a marker, gene, or regulatory sequence.
    Conserved sequences between two organisms might suggest some inherited or convergent
    trait. I’ll explore how to write a solution using the `str` (string) class in
    Python and will compare strings to lists. Then I’ll explore how to express these
    ideas using higher-order functions and will continue the discussion of k-mers
    I started in [Chapter 7](ch07.html#ch07). Finally, I’ll show how regular expressions
    can find patterns and will point out problems with overlapping matches.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Rosalind SUBS 挑战](https://oreil.ly/hoUhB) 中，我将搜索另一个序列内任何出现的序列。共享的子序列可能代表诸如标记、基因或调控序列等保守元素。两个生物之间的保守序列可能暗示一些遗传或收敛特征。我将探讨如何使用
    Python 中的 `str`（字符串）类编写解决方案，并将字符串与列表进行比较。然后，我将探讨如何使用高阶函数表达这些想法，并将继续讨论我在 [第 7 章](ch07.html#ch07)
    中开始的 k-mer。最后，我将展示如何使用正则表达式找到模式，并指出重叠匹配的问题。
- en: 'In this chapter, I’ll demonstrate:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将演示：
- en: How to use `str.find()`, `str.index()`, and string slices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `str.find()`、`str.index()` 和字符串切片
- en: How to use sets to create unique collections of elements
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用集合创建唯一的元素集合
- en: How to combine higher-order functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何组合高阶函数
- en: How to find subsequences using k-mers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 k-mer 查找子序列
- en: How to find possibly overlapping sequences using regular expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用正则表达式查找可能重叠的序列
- en: Getting Started
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'The code and tests for this chapter are in *08_subs*. I suggest you start by
    copying the first solution to the program `subs.py` and requesting help:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码和测试位于 *08_subs*。我建议您从将第一个解决方案复制到程序 `subs.py` 并请求帮助开始：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The program should report the starting locations where the subsequence can
    be found in the sequence. As shown in [Figure 8-1](#fig_8.1), the subsequence
    *ATAT* can be found at positions 2, 4, and 10 in the sequence *GATATATGCATATACTT*:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序应报告子序列在序列中的起始位置。如 [图 8-1](#fig_8.1) 所示，子序列 *ATAT* 可以在序列 *GATATATGCATATACTT*
    的位置 2、4 和 10 处找到：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![mpfb 0801](assets/mpfb_0801.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0801](assets/mpfb_0801.png)'
- en: Figure 8-1\. The subsequence *ATAT* can be found at positions 2, 4, and 10
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-1。子序列 *ATAT* 可以在位置 2、4 和 10 找到
- en: 'Run the tests to see if you understand what will be expected, then start your
    program from scratch:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以查看您是否了解将要预期的内容，然后从头开始编写您的程序：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is how I define the program’s parameters:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我定义程序参数的方法：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO1-1)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO1-1)'
- en: The `Args` class will have two string fields, `seq` and `subseq`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Args` 类将有两个字符串字段，`seq` 和 `subseq`。'
- en: '[![2](assets/2.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO1-2)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO1-2)'
- en: The function returns an `Args` object.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回一个 `Args` 对象。
- en: '[![3](assets/3.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO1-3)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO1-3)'
- en: Package and return the arguments using `Args`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Args` 打包并返回参数。
- en: 'Have your `main()` print the sequence and subsequence:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让您的 `main()` 打印序列和子序列：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run the program with the expected inputs and verify that it prints the arguments
    correctly:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预期的输入运行程序，并验证它是否正确打印了参数：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now you have a program that should pass the first two tests. If you think you
    can finish this on your own, please proceed; otherwise, I’ll show you one way
    to find the location of one string inside another.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有一个应该通过前两个测试的程序。如果您认为自己能够独立完成，请继续；否则，我将向您展示一种在一个字符串中找到另一个字符串的位置的方法。
- en: Finding Subsequences
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找子序列
- en: 'To demonstrate how to find the subsequence, I’ll start by defining the following
    sequence and subsequence in the REPL:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何找到子序列，我将首先在 REPL 中定义以下序列和子序列：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'I can use `in` to determine if one sequence is a subset of another. This also
    works for membership in lists, sets, or keys of a dictionary:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用 `in` 来确定一个序列是否是另一个序列的子集。这也适用于列表、集合或字典的键的成员资格：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That’s good information, but it doesn’t tell me *where* the string can be found.
    Luckily there’s the `str.find()` function, which says `subseq` can be found starting
    at index 1 (which is the second character):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很好的信息，但它没有告诉我*字符串*可以在哪里找到。幸运的是有`str.find()`函数，它说`subseq`可以从索引1（即第二个字符）开始找到：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I know from the Rosalind description that the answer should be 2, 4, and 10.
    I just found 2, so how can I find the next? I can’t just call the same function
    again because I’ll get the same answer. I need to look further into the sequence.
    Maybe `help(str.find)` could be of some use?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我从Rosalind的描述中知道答案应该是2、4和10。我刚刚找到了2，那么下一个如何找到？我不能再次调用相同的函数，因为我会得到相同的答案。我需要进一步查看序列。也许`help(str.find)`可能有一些用处？
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It appears I can specify a *start* position. I’ll use 1 greater than the position
    where the first subsequence was found, which was 1, so starting at 2:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我可以指定一个*起始*位置。我将使用比第一个子序列被发现的位置大1的位置，这个位置是1，所以从2开始：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Great. That’s the next answer—well, 4 is the next answer, but you know what
    I mean. I’ll try that again, this time starting at 4:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了。这是下一个答案——好吧，4是下一个答案，但你知道我是什么意思的。我再试一次，这次从4开始：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'That was the last value I expected. What happens if I try using a start of
    10? As the documentation shows, this will return `-1` to indicate the subsequence
    cannot be found:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那是我预料之外的最后一个值。如果我尝试使用起始值为10会发生什么？正如文档所示，这将返回`-1`来指示无法找到子序列：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Can you think of a way to iterate through the sequence, remembering the last
    position where the subsequence was found until it cannot be found?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到一种方法来遍历序列，并记住子序列被找到的最后位置直到找不到为止吗？
- en: 'Another option would be to use `str.index()`, but only if the subsequence is
    present:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用`str.index()`，但仅当子序列存在时：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To find the next occurrence, you could slice the sequence using the last known
    position. You’ll have to add this position to the starting position, but you’re
    essentially doing the same operation of moving further into the sequence to find
    if the subsequence is present and where:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到下一个出现，你可以使用最后已知位置对序列进行切片。你将不得不将这个位置添加到起始位置，但你本质上是在做同样的操作，即向序列深入以查找子序列是否存在以及其位置在哪里：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you read **`help(str.index)`**, you’ll see that, like `str.find()`, the
    function takes a second optional start position of the index at which to start
    looking:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读**`help(str.index)`**，你会发现，像`str.find()`一样，这个函数接受第二个可选的索引起始位置来开始查找：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A third approach would be to use k-mers. If the subsequence is present, then
    it is by definition a k-mer, where *k* is the length of the subsequence. Use your
    code from [Chapter 7](ch07.html#ch07) to extract all the k-mers and their positions
    from the sequence, and note the positions of the k-mers that match the subsequence.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法是使用k-mer。如果子序列存在，那么它就是一个k-mer，其中*k*是子序列的长度定义。使用你从[第7章](ch07.html#ch07)中提取序列中所有k-mer及其位置的代码，并注意与子序列匹配的k-mer的位置。
- en: 'Finally, since I’m looking for a pattern of text, I could use a regular expression.
    In [Chapter 5](ch05.html#ch05), I used the `re.findall()` function to find all
    the *G*s and *C*s in DNA. I can similarly use this method to find all the subsequences
    in the sequence:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我正在寻找一种文本模式，我可以使用正则表达式。在[第5章](ch05.html#ch05)中，我使用`re.findall()`函数来查找DNA中所有*G*和*C*。我可以类似地使用这种方法来找到序列中所有的子序列：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That seems to have a couple of problems. One is that it only returned two of
    the subsequences when I know there are three. The other problem is that this provides
    no information about *where* the matches are found. Fear not, the `re.finditer()`
    function solves this second problem:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎有一些问题。一个问题是它只返回了两个子序列，而我知道有三个。另一个问题是这并不提供关于*匹配位置*的任何信息。不用担心，`re.finditer()`函数解决了这个第二个问题：
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now it’s apparent that it finds the first and last subsequences. Why doesn’t
    it find the second instance? It turns out regular expressions don’t handle overlapping
    patterns very well, but some additions to the search pattern can fix this. I’ll
    leave it to you and some internet searching to see if you can figure out a solution.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在显而易见它找到了第一个和最后一个子序列。为什么它不会找到第二个实例？原来正则表达式对重叠模式处理得不太好，但是对搜索模式的一些添加可以解决这个问题。我将把这个问题留给你和一些互联网搜索，看看你是否能找到解决方案。
- en: I’ve presented four different options for how to solve this problem. See if
    you can write solutions using each approach. The point is to explore the corners
    of Python, storing away tasty bits and tricks that might prove decisive in some
    future program you write. It’s OK to spend hours or days working this out. Keep
    at it until you have solutions that pass both `pytest` and `make test`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我介绍了四种不同的解决方案。看看你能否使用每种方法编写解决方案。关键在于探索Python的各个角落，存储可能在未来某个程序中起决定性作用的有趣片段和技巧。花上几个小时或几天也没关系。坚持下去，直到你有解决方案能够通过`pytest`和`make
    test`。
- en: Solutions
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: All of the solutions share the same `get_args()` shown previously.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所有解决方案都共享相同的`get_args()`，如前所示。
- en: 'Solution 1: Using the str.find() Method'
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 1：使用`str.find()`方法
- en: 'Here is my first solution using the `str.find()` method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我使用`str.find()`方法的第一个解决方案：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](assets/1.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-1)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-1)'
- en: Initialize the `last` position to `0`, the start of the sequence.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将`last`位置初始化为`0`，序列的起始位置。
- en: '[![2](assets/2.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-2)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-2)'
- en: Initialize a list to hold all the positions where the subsequence is found.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化一个列表以保存发现子序列的所有位置。
- en: '[![3](assets/3.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-3)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-3)'
- en: Create an infinite loop using `while`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个使用`while`的无限循环。
- en: '[![4](assets/4.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-4)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-4)'
- en: Use `str.find()` to look for the subsequence using the last known position.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`str.find()`查找子序列，使用上次已知位置。
- en: '[![5](assets/5.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-5)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-5)'
- en: If the return is `-1`, the subsequence is not found, so exit the loop.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回`-1`，则未找到子序列，因此退出循环。
- en: '[![6](assets/6.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-6)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-6)'
- en: Append one greater than the index to the list of found positions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将大于索引的值附加到已发现位置的列表中。
- en: '[![7](assets/7.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-7)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-7)'
- en: Update the last known position with one greater than the found index.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 更新最后已知位置，其值比找到的索引大一。
- en: '[![8](assets/8.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-8)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-8)'
- en: Print the found positions using `*` to expand the list into the elements. The
    function will use a space to separate multiple values.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`*`打印已找到的位置，将列表扩展为其元素。函数将使用空格分隔多个值。
- en: 'This solution turns on keeping track of the *last* place the subsequence was
    found. I initialize this to `0`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此解决方案开启了跟踪*最后*发现子序列的位置。我将其初始化为`0`：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'I use this with `str.find()` to look for the subsequence starting at the last
    known position:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`str.find()`查找子序列，从上次已知位置开始：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As long as `seq.find()` returns a value other than `-1`, I update the last
    position to one greater to search starting at the next character:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 只要`seq.find()`返回除`-1`以外的值，我将更新最后位置为大于该值的一个以便从下一个字符开始搜索：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Another call to the function finds the last instance:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个函数调用找到了最后一个实例：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, `seq.find()` returns `-1` to indicate that the pattern can no longer
    be found:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`seq.find()`返回`-1`表示无法再找到该模式：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This solution would be immediately understandable to someone with a background
    in the C programming language. It’s a very *imperative* approach with lots of
    detailed logic for updating the state of the algorithm. *State* is how data in
    a program changes over time. For instance, properly updating and using the last
    known position is key to making this approach work. Later approaches use far less
    explicit coding.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有 C 语言背景的人来说，这种解决方案将立即变得易于理解。这是一种非常 *命令式* 的方法，具有大量用于更新算法状态的详细逻辑。*状态* 是程序中数据随时间变化的方式。例如，正确更新和使用上一个已知位置对于使这种方法工作至关重要。后续方法使用的显式编码要少得多。
- en: 'Solution 2: Using the str.index() Method'
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 2：使用 `str.index()` 方法
- en: 'This next solution is a variation that slices the sequence using the last known
    position:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个解决方案是使用上一个已知位置对序列进行切片的变体：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](assets/1.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-1)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-1)'
- en: Unpack the sequence and subsequence.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 解包序列和子序列。
- en: '[![2](assets/2.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-2)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-2)'
- en: Ask if the subsequence appears in a slice of the sequence starting at the last
    found position. The `while` loop will execute as long as this condition is true.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 询问子序列是否出现在从上次找到的位置开始的序列片段中。只要此条件为真，`while` 循环就会执行。
- en: '[![3](assets/3.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-3)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-3)'
- en: Use `str.index()` to get the starting position of the subsequence. The `last`
    variable gets updated by adding 1 to the subsequence index to create the next
    starting position.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `str.index()` 获取子序列的起始位置。`last` 变量通过将子序列索引加 1 来更新，以创建下一个起始位置。
- en: '[![4](assets/4.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-4)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-4)'
- en: Append this position to the list of found positions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将此位置追加到找到位置列表中。
- en: '[![5](assets/5.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-5)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-5)'
- en: Use `map()` to coerce all the found integer positions to strings, then join
    them on spaces to print.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `map()` 将所有找到的整数位置强制转换为字符串，然后在空格上进行连接以打印。
- en: 'Here again, I rely on tracking the last place a subsequence was found. I start
    at position 0, or the beginning of the string:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我依赖于跟踪子序列被找到的上一个位置。我从位置 0 或字符串的开头开始：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `while True` loop in the first solution is a common way to start an infinite
    loop. Here, the `while` loop will only execute as long as the subsequence is found
    in the slice of the sequence, meaning I don’t have to manually decide when to
    `break` out of the loop:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个解决方案中的 `while True` 循环是开始一个无限循环的常见方法。在这里，只要子序列在序列的片段中被找到，`while` 循环就会执行，这意味着我不必手动决定何时
    `break` 出循环：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The found positions, in this case, are a list of integer values. In the first
    solution, I used `*found` to splat the list and relied on `print()` to coerce
    the values to strings and join them on spaces. If instead I were to try to create
    a new string from `found` using `str.join()`, I would run into problems. The `str.join()`
    function joins many *strings* into a single string and so raises an exception
    when you give it nonstring values:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，找到的位置是一个整数值列表。在第一个解决方案中，我使用 `*found` 来展开列表，并依赖于 `print()` 将值强制转换为字符串并在空格上进行连接。如果我尝试使用
    `str.join()` 从 `found` 创建新字符串，我会遇到问题。`str.join()` 函数将许多 *字符串* 连接成单个字符串，因此当你给它非字符串值时会引发异常：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'I could use a list comprehension to turn each number `n` into a string using
    the `str()` function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用列表推导式，使用 `str()` 函数将每个数字 `n` 转换为字符串：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This can also be written using a `map()`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以使用 `map()` 来写：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'I can leave out the `lambda` entirely because the `str()` function expects
    a single argument, and `map()` will naturally supply each value from `found` as
    the argument to `str()`. This is my preferred way to turn a list of integers into
    a list of strings:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我完全可以省略 `lambda`，因为 `str()` 函数期望单个参数，并且 `map()` 自然会将每个 `found` 的值作为参数传递给 `str()`。这是我首选的方法，将整数列表转换为字符串列表：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Solution 3: A Purely Functional Approach'
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 3：一种纯函数式方法
- en: 'This next solution combines many of the preceding ideas using a purely functional
    approach. To start, consider the `while` loops in the first two solutions used
    to append nonnegative values to the `found` list. Does that sound like something
    a list comprehension could do? The range of values to iterate includes all the
    positions `n` from 0 to the end of the sequence minus the length of the subsequence:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个解决方案结合了许多先前的想法，使用纯函数式方法。首先，考虑第一和第二个解决方案中使用的`while`循环，用于将非负值附加到`found`列表中。这听起来像是列表理解可以做的事情吗？迭代的值范围包括从0到序列末尾减去子序列长度的所有位置`n`：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'A list comprehension can use these values with `str.find()` to search for the
    subsequence in the sequence starting at each position `n`. Starting at positions
    0 and 1, the subsequence can be found at index 1. Starting at positions 2 and
    3, the subsequence can be found at index 3. This continues until `-1` indicates
    the subsequence is not present for those positions `n`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表理解可以使用这些值和`str.find()`来搜索子序列在序列中从每个位置`n`开始。从位置0和1开始，子序列可以在索引1处找到。从位置2和3开始，子序列可以在索引3处找到。这一直持续到`-1`指示子序列在那些位置`n`上不存在：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'I only want the nonnegative values, so I use `filter()` to remove them:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我只想要非负值，所以我使用`filter()`将它们移除：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Which could also be written by reversing the comparison in the `lambda`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以通过反转`lambda`中的比较来编写：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'I show you this because I’d like to use `partial()` with the `operator.le()`
    (less than or equal) function because I don’t like `lambda` expressions:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我向您展示这个，因为我想使用`partial()`与`operator.le()`（小于或等于）函数，因为我不喜欢`lambda`表达式：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'I’d like to change the list comprehension to a `map()`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我想将列表理解改为`map()`：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'but again I want to get rid of the `lambda` by using `partial()`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但我再次想要摆脱`lambda`，所以使用`partial()`：
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'I can use `set()` to get a distinct list:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用`set()`来获取一个不同的列表：
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'These are almost the correct values, but they are the *index* positions, which
    are zero-based. I need the values one greater, so I can make a function to add
    1 and apply this using a `map()`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些几乎是正确的值，但它们是*索引*位置，零基础的。我需要值加一，所以我可以创建一个函数来加1，并使用`map()`应用它：
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In these limited examples, the results are properly sorted; however, one can
    never rely on the order of values from a set. I must use the `sorted()` function
    to ensure they are properly sorted numerically:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些有限的例子中，结果已经正确排序；但是，人们永远不能依赖于集合中的值的顺序。我必须使用`sorted()`函数确保它们在数值上正确排序：
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, I need to print these values, which still exist as a list of integers:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我需要打印这些仍然存在的整数列表的值：
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'That’s almost right. As in the first solution, I need to splat the results
    to get `print()` to see the individual elements:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 那几乎是正确的。与第一个解决方案一样，我需要展开结果以使`print()`看到单独的元素：
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'That’s a lot of closing parentheses. This code is starting to look a little
    like Lisp. If you combine all these ideas, you wind up with the same answer as
    the imperative solution but now by combining only functions:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很多右括号。这段代码开始看起来有点像Lisp。如果将所有这些想法结合起来，你最终得到与命令式解决方案相同的答案，但现在只结合函数：
- en: '[PRE43]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[![1](assets/1.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-1)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-1)'
- en: Unpack the sequence and subsequence.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 展开序列和子序列。
- en: '[![2](assets/2.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-2)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-2)'
- en: Generate a range of numbers up to the length of the sequence less the length
    of the subsequence.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个数字范围，直到序列的长度减去子序列的长度。
- en: '[![3](assets/3.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-3)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-3)'
- en: Create a partial `ok()` function that will return `True` if a given number is
    greater than or equal to `0`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个部分`ok()`函数，如果给定的数字大于或等于`0`，则返回`True`。
- en: '[![4](assets/4.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-4)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-4)'
- en: Create a partial `find()` function that will look for the subsequence in the
    sequence when provided with a start parameter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个部分`find()`函数，当提供起始参数时，将查找序列中的子序列。
- en: '[![5](assets/5.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-5)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-5)'
- en: Create a partial `add1()` function that will return one greater than the argument.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个部分函数`add1()`，它将返回比参数大一的值。
- en: '[![6](assets/6.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-6)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-6)'
- en: Apply all the numbers from the range to the `find()` function, filter out negative
    values, make the result unique by using the set() function, add one to the values,
    and sort the numbers before printing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 将范围内的所有数字应用于`find()`函数，过滤掉负值，使用`set()`函数使结果唯一，对值加1并排序后再打印。
- en: This solution uses only *pure* functions and would be fairly easy to understand
    for a person with a background in the Haskell programming language. If it seems
    like a jumble of confusion to you, I’d encourage you to spend some time working
    in the REPL with each piece until you understand how all these functions fit together
    perfectly.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案只使用*纯*函数，对于背景在Haskell编程语言中的人来说应该很容易理解。如果对你来说这似乎一团糟，请花些时间在REPL中逐个理解每个部分如何完美地配合在一起。
- en: 'Solution 4: Using K-mers'
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案4：使用K-mers
- en: 'I mentioned that you might try finding the answer using k-mers, which I showed
    in [Chapter 7](ch07.html#ch07). If the subsequence exists in the sequence, then
    it must be a k-mer, where *k* equals the length of the subsequence:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到过你可以尝试使用k-mers找到答案，这在[第7章](ch07.html#ch07)中已经展示过了。如果子序列存在于序列中，那么它必须是一个k-mer，其中*k*等于子序列的长度：
- en: '[PRE44]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here are all the 4-mers in the sequence:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是序列中的所有4-mers：
- en: '[PRE45]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here are the 4-mers that are the same as the subsequence I’m looking for:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是与子序列相同的4-mers：
- en: '[PRE46]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'I need to know the positions as well as the k-mers. The `enumerate()` function
    will return both the index and value of all the elements in a sequence. Here are
    the first four:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要知道位置以及k-mers。`enumerate()`函数将返回序列中所有元素的索引和值。以下是前四个：
- en: '[PRE47]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'I can use this with `filter()`, but now the `lambda` is receiving a tuple of
    the index and value so I will need to look at the second field (which is at index
    1):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以与`filter()`一起使用，但现在`lambda`接收的是索引和值的元组，所以我需要查看第二个字段（即索引1）：
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'I really only care about getting the index for the matching k-mers. I could
    rewrite this using a `map()` with an `if` expression to return the index position
    when it’s a match, and `None` otherwise:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我真正关心的只是获取匹配k-mers的索引。我可以使用带有`if`表达式的`map()`来重写这个，当匹配时返回索引位置，否则返回`None`：
- en: '[PRE49]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'I’m frustrated that the standard `map()` function can only pass a single value
    to the `lambda`. What I need is some way to splat the tuple, like `*t`, to turn
    it into two values. Luckily, I’ve studied the `itertools` module documentation
    and found the `starmap()` function, so named because it will add a *star* to the
    `lambda` argument to splat it. This allows me to unpack a tuple value like `(0,
    ''GATA'')` into the variables `i` with the index value of `0` and `kmer` with
    the value `''GATA''`. With these, I can compare the `kmer` to the subsequence
    and also add 1 to the index (`i`):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我对标准的`map()`函数只能传递单个值给`lambda`感到沮丧。我需要的是一种可以打散元组的方法，就像`*t`，将其转换为两个值。幸运的是，我研究了`itertools`模块的文档，并找到了`starmap()`函数，因为它会给`lambda`参数添加一个*星号*来打散它。这使我能够将类似`(0,
    'GATA')`的元组值解包为变量`i`（索引值为`0`）和`kmer`（值为`'GATA'`）。有了这些，我可以比较`kmer`与子序列，并将索引(`i`)加1：
- en: '[PRE50]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This probably seems like an odd choice until I show you that `filter()`, if
    passed `None` for the `lambda`, will use the truthiness of each value, so that
    `None` values will be excluded. Because this line of code is getting rather long,
    I’ll write the function `f()` for `map()` on a separate line:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是一个奇怪的选择，直到我告诉你，如果在`lambda`中传递`None`，`filter()`将使用每个值的真值性，因此将排除`None`值。因为这行代码变得相当长，我将在单独的一行上写函数`f()`来进行`map()`：
- en: '[PRE51]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'I can express a k-mer solution using imperative techniques:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用命令式技术表达一个k-mer解决方案：
- en: '[PRE52]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[![1](assets/1.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-1)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-1)'
- en: When looking for k-mers, `k` is the length of the subsequence.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找k-mers时，`k`是子序列的长度。
- en: '[![2](assets/2.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-2)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-2)'
- en: Use a list comprehension to generate all the k-mers from the sequence.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表推导式从序列生成所有 k-mer。
- en: '[![3](assets/3.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-3)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-3)'
- en: Iterate through the index and value of all the k-mers, where the k-mer is equal
    to the subsequence. Return one greater than the index position.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代遍历所有 k-mer 的索引和值，其中 k-mer 等于子序列。返回比索引位置大一的值。
- en: '[![4](assets/4.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-4)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-4)'
- en: Print the found positions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 打印找到的位置。
- en: 'I can also express these ideas using purely functional techniques. Note that
    `mypy` insists on a type annotation for the `found` variable:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我还可以使用纯函数技术表达这些想法。请注意，`mypy` 坚持对 `found` 变量进行类型注释：
- en: '[PRE53]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[![1](assets/1.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO6-1)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO6-1)'
- en: Generate an enumerated list of the k-mers.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个 k-mer 的枚举列表。
- en: '[![2](assets/2.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO6-2)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO6-2)'
- en: Select the positions of those k-mers equal to the subsequence.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 选择与子序列相等的那些 k-mer 的位置。
- en: '[![3](assets/3.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO6-3)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO6-3)'
- en: Print the results.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 打印结果。
- en: I find the imperative version easier to read, but would recommend you use whichever
    you find most intuitive. Whichever solution you prefer, the interesting point
    is that k-mers can prove extremely useful in many situations, such as for partial
    sequence comparison.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现命令式版本更易于阅读，但建议您使用您认为最直观的版本。无论您更喜欢哪个解决方案，有趣的是 k-mer 在许多情况下都可以证明极其有用，例如用于部分序列比较。
- en: 'Solution 5: Finding Overlapping Patterns Using Regular Expressions'
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 5：使用正则表达式查找重叠模式
- en: 'To this point, I’ve been writing fairly complex solutions to find a pattern
    of characters inside a string. This is precisely the domain of regular expressions,
    and so it’s a bit silly to write manual solutions. I showed earlier in this chapter
    that the `re.finditer()` function does not find overlapping matches and so returns
    just two hits when I know there are three:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我一直在编写相当复杂的解决方案来查找字符串中的字符模式。这恰好是正则表达式的领域，因此手动编写解决方案有点愚蠢。在本章的早些时候，我展示了
    `re.finditer()` 函数不会找到重叠的匹配项，因此当我知道有三个匹配项时，它只返回两个：
- en: '[PRE54]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: I’m going to show you that the solution is quite simple, but I want to stress
    that I did not know the solution until I searched the internet. The key to finding
    the answer was knowing what search terms to use—something like *regex overlapping
    patterns* turns up several useful results. The point of this aside is that no
    one knows all the answers, and you will constantly be searching for solutions
    to problems you never knew even existed. It’s not what you know that’s important,
    but what you can learn.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向您展示解决方案非常简单，但我想强调的是，直到我在互联网上搜索之前，我并不知道解决方案。找到答案的关键是知道要使用什么搜索词——诸如*正则表达式重叠模式*之类的内容会提供几个有用的结果。这一旁白的重点在于，没有人知道所有的答案，您将不断搜索解决问题的方法，甚至是您以前从未意识到的问题。重要的不是您知道什么，而是您能学到什么。
- en: The problem turns out to be that the regex engine *consumes* strings as they
    match. That is, once the engine matches the first *ATAT*, it starts searching
    again at the end of the match. The solution is to wrap the search pattern in a
    *look-ahead assertion* using the syntax `?=(<*pattern*>`) so that the engine won’t
    consume the matched string. Note that this is a *positive* look-ahead; there are
    also *negative* look-ahead assertions as well as both positive and negative look-behind
    assertions.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 问题实际上是正则表达式引擎*消耗*匹配的字符串。也就是说，一旦引擎匹配了第一个*ATAT*，它就从匹配的末尾重新开始搜索。解决方案是使用语法 `?=(<*pattern*>`)
    将搜索模式包装在*正向查找断言*中，这样引擎就不会消耗匹配的字符串。请注意，这是*正向*查找断言；还有*负向*查找断言以及正向和负向查找断言。
- en: 'So if the subsequence is *ATAT*, then I want the pattern to be `?=(ATAT)`.
    The problem now is that the regex engine won’t *save* the match—I’ve just told
    it to look for this pattern but haven’t told it to do anything with the text that
    is found. I need to further wrap the assertion in parentheses to create a *capture
    group*:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果子序列是 *ATAT*，那么我想要模式为 `?=(ATAT)`。现在的问题是正则表达式引擎不会 *保存* 匹配结果 —— 我只是告诉它寻找这个模式，但没有告诉它对找到的文本做任何处理。我需要进一步将断言包裹在括号中以创建一个
    *捕获组*：
- en: '[PRE55]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'I can use a list comprehension over this iterator to call the `match.start()`
    function on each of the `re.Match` objects, adding 1 to correct the position:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用列表推导式遍历此迭代器，在每个 `re.Match` 对象上调用 `match.start()` 函数，并加 1 以校正位置：
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here is the final solution that I would suggest as the best way to solve this
    problem:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我建议作为解决这个问题的最佳方式的最终解决方案：
- en: '[PRE57]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Benchmarking
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试
- en: 'It’s always interesting for me to see which solution runs the fastest. I’ll
    use `hyperfine` again to run each version 1,000 times:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，看到哪种解决方案运行速度最快总是很有趣。我将再次使用 `hyperfine` 运行每个版本 1,000 次：
- en: '[PRE58]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The differences aren’t significant enough, in my opinion, to sway me to choose
    based solely on performance. My preference would be to use regular expressions
    given that they are specifically designed to find patterns of text.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，这些差异并不显著，不能仅凭性能来决定我的选择。我更倾向于使用正则表达式，因为它们专门设计用于查找文本模式。
- en: Going Further
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步探讨
- en: Expand the program to look for a subsequence *pattern*. For example, you might
    search for simple sequence repeats (also known as *SSRs* or microsatellites) such
    as `GA(26)`, which would mean “*GA* repeated 26 times.” Or a repeat such as `(GA)15GT(GA)2`,
    which means “*GA* repeated 15 times, followed by *GT*, followed by *GA*, repeated
    2 times.” Also, consider how you might find subsequences expressed using the IUPAC
    codes mentioned in [Chapter 1](ch01.html#ch01). For instance, *R* represents either
    *A* or *G*, so *ARC* can match the sequences *AAC* and *AGC*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展程序以查找子序列 *模式*。例如，您可以搜索简单的序列重复（也称为 *SSR* 或微卫星），如 `GA(26)`，它表示“*GA* 重复 26 次”。或者像
    `(GA)15GT(GA)2` 这样的重复，它表示“*GA* 重复 15 次，然后是 *GT*，然后是 *GA*，重复 2 次。” 还要考虑如何找到使用第一章提到的
    IUPAC 代码表示的子序列。例如，*R* 表示 *A* 或 *G*，因此 *ARC* 可以匹配序列 *AAC* 和 *AGC*。
- en: Review
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习
- en: 'Key points from this chapter:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的关键点：
- en: The `str.find()` and `str.index()` methods can determine if a subsequence is
    present in a given string.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str.find()` 和 `str.index()` 方法可以确定给定字符串中是否存在子序列。'
- en: Sets can be used to create unique collections of elements.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合可以用来创建独特的元素集合。
- en: By definition, k-mers are subsequences and are relatively quick to extract and
    compare.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照定义，k-mers 是子序列，相对快速地提取和比较。
- en: Regular expressions can find overlapping sequences by using a look-ahead assertion
    combined with a capture group.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式可以通过使用前瞻断言结合捕获组来找到重叠的序列。
