- en: 'Chapter 8\. Find a Motif in DNA: Exploring Sequence Similarity'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [the Rosalind SUBS challenge](https://oreil.ly/hoUhB), I’ll be searching
    for any occurrences of one sequence inside another. A shared subsequence might
    represent a conserved element such as a marker, gene, or regulatory sequence.
    Conserved sequences between two organisms might suggest some inherited or convergent
    trait. I’ll explore how to write a solution using the `str` (string) class in
    Python and will compare strings to lists. Then I’ll explore how to express these
    ideas using higher-order functions and will continue the discussion of k-mers
    I started in [Chapter 7](ch07.html#ch07). Finally, I’ll show how regular expressions
    can find patterns and will point out problems with overlapping matches.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I’ll demonstrate:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use `str.find()`, `str.index()`, and string slices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use sets to create unique collections of elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to combine higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to find subsequences using k-mers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to find possibly overlapping sequences using regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code and tests for this chapter are in *08_subs*. I suggest you start by
    copying the first solution to the program `subs.py` and requesting help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The program should report the starting locations where the subsequence can
    be found in the sequence. As shown in [Figure 8-1](#fig_8.1), the subsequence
    *ATAT* can be found at positions 2, 4, and 10 in the sequence *GATATATGCATATACTT*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![mpfb 0801](assets/mpfb_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. The subsequence *ATAT* can be found at positions 2, 4, and 10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Run the tests to see if you understand what will be expected, then start your
    program from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how I define the program’s parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `Args` class will have two string fields, `seq` and `subseq`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The function returns an `Args` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Package and return the arguments using `Args`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have your `main()` print the sequence and subsequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the expected inputs and verify that it prints the arguments
    correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now you have a program that should pass the first two tests. If you think you
    can finish this on your own, please proceed; otherwise, I’ll show you one way
    to find the location of one string inside another.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Subsequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate how to find the subsequence, I’ll start by defining the following
    sequence and subsequence in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'I can use `in` to determine if one sequence is a subset of another. This also
    works for membership in lists, sets, or keys of a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s good information, but it doesn’t tell me *where* the string can be found.
    Luckily there’s the `str.find()` function, which says `subseq` can be found starting
    at index 1 (which is the second character):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I know from the Rosalind description that the answer should be 2, 4, and 10.
    I just found 2, so how can I find the next? I can’t just call the same function
    again because I’ll get the same answer. I need to look further into the sequence.
    Maybe `help(str.find)` could be of some use?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It appears I can specify a *start* position. I’ll use 1 greater than the position
    where the first subsequence was found, which was 1, so starting at 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Great. That’s the next answer—well, 4 is the next answer, but you know what
    I mean. I’ll try that again, this time starting at 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'That was the last value I expected. What happens if I try using a start of
    10? As the documentation shows, this will return `-1` to indicate the subsequence
    cannot be found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Can you think of a way to iterate through the sequence, remembering the last
    position where the subsequence was found until it cannot be found?
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option would be to use `str.index()`, but only if the subsequence is
    present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the next occurrence, you could slice the sequence using the last known
    position. You’ll have to add this position to the starting position, but you’re
    essentially doing the same operation of moving further into the sequence to find
    if the subsequence is present and where:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you read **`help(str.index)`**, you’ll see that, like `str.find()`, the
    function takes a second optional start position of the index at which to start
    looking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A third approach would be to use k-mers. If the subsequence is present, then
    it is by definition a k-mer, where *k* is the length of the subsequence. Use your
    code from [Chapter 7](ch07.html#ch07) to extract all the k-mers and their positions
    from the sequence, and note the positions of the k-mers that match the subsequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, since I’m looking for a pattern of text, I could use a regular expression.
    In [Chapter 5](ch05.html#ch05), I used the `re.findall()` function to find all
    the *G*s and *C*s in DNA. I can similarly use this method to find all the subsequences
    in the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'That seems to have a couple of problems. One is that it only returned two of
    the subsequences when I know there are three. The other problem is that this provides
    no information about *where* the matches are found. Fear not, the `re.finditer()`
    function solves this second problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now it’s apparent that it finds the first and last subsequences. Why doesn’t
    it find the second instance? It turns out regular expressions don’t handle overlapping
    patterns very well, but some additions to the search pattern can fix this. I’ll
    leave it to you and some internet searching to see if you can figure out a solution.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve presented four different options for how to solve this problem. See if
    you can write solutions using each approach. The point is to explore the corners
    of Python, storing away tasty bits and tricks that might prove decisive in some
    future program you write. It’s OK to spend hours or days working this out. Keep
    at it until you have solutions that pass both `pytest` and `make test`.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the solutions share the same `get_args()` shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 1: Using the str.find() Method'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is my first solution using the `str.find()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the `last` position to `0`, the start of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a list to hold all the positions where the subsequence is found.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Create an infinite loop using `while`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `str.find()` to look for the subsequence using the last known position.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: If the return is `-1`, the subsequence is not found, so exit the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Append one greater than the index to the list of found positions.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Update the last known position with one greater than the found index.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO2-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the found positions using `*` to expand the list into the elements. The
    function will use a space to separate multiple values.
  prefs: []
  type: TYPE_NORMAL
- en: 'This solution turns on keeping track of the *last* place the subsequence was
    found. I initialize this to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'I use this with `str.find()` to look for the subsequence starting at the last
    known position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as `seq.find()` returns a value other than `-1`, I update the last
    position to one greater to search starting at the next character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Another call to the function finds the last instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `seq.find()` returns `-1` to indicate that the pattern can no longer
    be found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This solution would be immediately understandable to someone with a background
    in the C programming language. It’s a very *imperative* approach with lots of
    detailed logic for updating the state of the algorithm. *State* is how data in
    a program changes over time. For instance, properly updating and using the last
    known position is key to making this approach work. Later approaches use far less
    explicit coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 2: Using the str.index() Method'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This next solution is a variation that slices the sequence using the last known
    position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Unpack the sequence and subsequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Ask if the subsequence appears in a slice of the sequence starting at the last
    found position. The `while` loop will execute as long as this condition is true.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `str.index()` to get the starting position of the subsequence. The `last`
    variable gets updated by adding 1 to the subsequence index to create the next
    starting position.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Append this position to the list of found positions.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `map()` to coerce all the found integer positions to strings, then join
    them on spaces to print.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here again, I rely on tracking the last place a subsequence was found. I start
    at position 0, or the beginning of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `while True` loop in the first solution is a common way to start an infinite
    loop. Here, the `while` loop will only execute as long as the subsequence is found
    in the slice of the sequence, meaning I don’t have to manually decide when to
    `break` out of the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The found positions, in this case, are a list of integer values. In the first
    solution, I used `*found` to splat the list and relied on `print()` to coerce
    the values to strings and join them on spaces. If instead I were to try to create
    a new string from `found` using `str.join()`, I would run into problems. The `str.join()`
    function joins many *strings* into a single string and so raises an exception
    when you give it nonstring values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'I could use a list comprehension to turn each number `n` into a string using
    the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be written using a `map()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'I can leave out the `lambda` entirely because the `str()` function expects
    a single argument, and `map()` will naturally supply each value from `found` as
    the argument to `str()`. This is my preferred way to turn a list of integers into
    a list of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Solution 3: A Purely Functional Approach'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This next solution combines many of the preceding ideas using a purely functional
    approach. To start, consider the `while` loops in the first two solutions used
    to append nonnegative values to the `found` list. Does that sound like something
    a list comprehension could do? The range of values to iterate includes all the
    positions `n` from 0 to the end of the sequence minus the length of the subsequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'A list comprehension can use these values with `str.find()` to search for the
    subsequence in the sequence starting at each position `n`. Starting at positions
    0 and 1, the subsequence can be found at index 1. Starting at positions 2 and
    3, the subsequence can be found at index 3. This continues until `-1` indicates
    the subsequence is not present for those positions `n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'I only want the nonnegative values, so I use `filter()` to remove them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Which could also be written by reversing the comparison in the `lambda`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'I show you this because I’d like to use `partial()` with the `operator.le()`
    (less than or equal) function because I don’t like `lambda` expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'I’d like to change the list comprehension to a `map()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'but again I want to get rid of the `lambda` by using `partial()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'I can use `set()` to get a distinct list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'These are almost the correct values, but they are the *index* positions, which
    are zero-based. I need the values one greater, so I can make a function to add
    1 and apply this using a `map()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In these limited examples, the results are properly sorted; however, one can
    never rely on the order of values from a set. I must use the `sorted()` function
    to ensure they are properly sorted numerically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, I need to print these values, which still exist as a list of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s almost right. As in the first solution, I need to splat the results
    to get `print()` to see the individual elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s a lot of closing parentheses. This code is starting to look a little
    like Lisp. If you combine all these ideas, you wind up with the same answer as
    the imperative solution but now by combining only functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Unpack the sequence and subsequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Generate a range of numbers up to the length of the sequence less the length
    of the subsequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a partial `ok()` function that will return `True` if a given number is
    greater than or equal to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a partial `find()` function that will look for the subsequence in the
    sequence when provided with a start parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a partial `add1()` function that will return one greater than the argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Apply all the numbers from the range to the `find()` function, filter out negative
    values, make the result unique by using the set() function, add one to the values,
    and sort the numbers before printing.
  prefs: []
  type: TYPE_NORMAL
- en: This solution uses only *pure* functions and would be fairly easy to understand
    for a person with a background in the Haskell programming language. If it seems
    like a jumble of confusion to you, I’d encourage you to spend some time working
    in the REPL with each piece until you understand how all these functions fit together
    perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 4: Using K-mers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I mentioned that you might try finding the answer using k-mers, which I showed
    in [Chapter 7](ch07.html#ch07). If the subsequence exists in the sequence, then
    it must be a k-mer, where *k* equals the length of the subsequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are all the 4-mers in the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the 4-mers that are the same as the subsequence I’m looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'I need to know the positions as well as the k-mers. The `enumerate()` function
    will return both the index and value of all the elements in a sequence. Here are
    the first four:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'I can use this with `filter()`, but now the `lambda` is receiving a tuple of
    the index and value so I will need to look at the second field (which is at index
    1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'I really only care about getting the index for the matching k-mers. I could
    rewrite this using a `map()` with an `if` expression to return the index position
    when it’s a match, and `None` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'I’m frustrated that the standard `map()` function can only pass a single value
    to the `lambda`. What I need is some way to splat the tuple, like `*t`, to turn
    it into two values. Luckily, I’ve studied the `itertools` module documentation
    and found the `starmap()` function, so named because it will add a *star* to the
    `lambda` argument to splat it. This allows me to unpack a tuple value like `(0,
    ''GATA'')` into the variables `i` with the index value of `0` and `kmer` with
    the value `''GATA''`. With these, I can compare the `kmer` to the subsequence
    and also add 1 to the index (`i`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This probably seems like an odd choice until I show you that `filter()`, if
    passed `None` for the `lambda`, will use the truthiness of each value, so that
    `None` values will be excluded. Because this line of code is getting rather long,
    I’ll write the function `f()` for `map()` on a separate line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'I can express a k-mer solution using imperative techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: When looking for k-mers, `k` is the length of the subsequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use a list comprehension to generate all the k-mers from the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through the index and value of all the k-mers, where the k-mer is equal
    to the subsequence. Return one greater than the index position.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the found positions.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can also express these ideas using purely functional techniques. Note that
    `mypy` insists on a type annotation for the `found` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Generate an enumerated list of the k-mers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Select the positions of those k-mers equal to the subsequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_find_a_motif_in_dna___span_class__keep_together__exploring_sequence_similarity__span__CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the results.
  prefs: []
  type: TYPE_NORMAL
- en: I find the imperative version easier to read, but would recommend you use whichever
    you find most intuitive. Whichever solution you prefer, the interesting point
    is that k-mers can prove extremely useful in many situations, such as for partial
    sequence comparison.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 5: Finding Overlapping Patterns Using Regular Expressions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To this point, I’ve been writing fairly complex solutions to find a pattern
    of characters inside a string. This is precisely the domain of regular expressions,
    and so it’s a bit silly to write manual solutions. I showed earlier in this chapter
    that the `re.finditer()` function does not find overlapping matches and so returns
    just two hits when I know there are three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: I’m going to show you that the solution is quite simple, but I want to stress
    that I did not know the solution until I searched the internet. The key to finding
    the answer was knowing what search terms to use—something like *regex overlapping
    patterns* turns up several useful results. The point of this aside is that no
    one knows all the answers, and you will constantly be searching for solutions
    to problems you never knew even existed. It’s not what you know that’s important,
    but what you can learn.
  prefs: []
  type: TYPE_NORMAL
- en: The problem turns out to be that the regex engine *consumes* strings as they
    match. That is, once the engine matches the first *ATAT*, it starts searching
    again at the end of the match. The solution is to wrap the search pattern in a
    *look-ahead assertion* using the syntax `?=(<*pattern*>`) so that the engine won’t
    consume the matched string. Note that this is a *positive* look-ahead; there are
    also *negative* look-ahead assertions as well as both positive and negative look-behind
    assertions.
  prefs: []
  type: TYPE_NORMAL
- en: 'So if the subsequence is *ATAT*, then I want the pattern to be `?=(ATAT)`.
    The problem now is that the regex engine won’t *save* the match—I’ve just told
    it to look for this pattern but haven’t told it to do anything with the text that
    is found. I need to further wrap the assertion in parentheses to create a *capture
    group*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'I can use a list comprehension over this iterator to call the `match.start()`
    function on each of the `re.Match` objects, adding 1 to correct the position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the final solution that I would suggest as the best way to solve this
    problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Benchmarking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s always interesting for me to see which solution runs the fastest. I’ll
    use `hyperfine` again to run each version 1,000 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The differences aren’t significant enough, in my opinion, to sway me to choose
    based solely on performance. My preference would be to use regular expressions
    given that they are specifically designed to find patterns of text.
  prefs: []
  type: TYPE_NORMAL
- en: Going Further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Expand the program to look for a subsequence *pattern*. For example, you might
    search for simple sequence repeats (also known as *SSRs* or microsatellites) such
    as `GA(26)`, which would mean “*GA* repeated 26 times.” Or a repeat such as `(GA)15GT(GA)2`,
    which means “*GA* repeated 15 times, followed by *GT*, followed by *GA*, repeated
    2 times.” Also, consider how you might find subsequences expressed using the IUPAC
    codes mentioned in [Chapter 1](ch01.html#ch01). For instance, *R* represents either
    *A* or *G*, so *ARC* can match the sequences *AAC* and *AGC*.
  prefs: []
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Key points from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The `str.find()` and `str.index()` methods can determine if a subsequence is
    present in a given string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets can be used to create unique collections of elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By definition, k-mers are subsequences and are relatively quick to extract and
    compare.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions can find overlapping sequences by using a look-ahead assertion
    combined with a capture group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
