- en: 'Chapter 6\. Finding the Hamming Distance: Counting Point Mutations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Hamming distance, named after the same Richard Hamming mentioned in the
    Preface, is the number of edits required to change one string into another. It’s
    one metric for gauging sequence similarity. I have written a couple of other metrics
    for this, starting in [Chapter 1](ch01.html#ch01) with tetranucleotide frequency
    and continuing in [Chapter 5](ch05.html#ch05) with GC content. While the latter
    can be practically informative as coding regions tend to be GC-rich, tetranucleotide
    frequency falls pretty short of being useful. For example, the sequences *AAACCCGGGTTT*
    and *CGACGATATGTC* are wildly different yet produce the same base frequencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Taken alone, tetranucleotide frequency makes these sequences seem identical,
    but it’s quite obvious that they would produce entirely different protein sequences
    and so would be functionally unlike. [Figure 6-1](#fig_6.1) depicts an alignment
    of the 2 sequences indicating that only 3 of the 12 bases are shared, meaning
    they are only 25% similar.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 0601](assets/mpfb_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. An alignment of two sequences with vertical bars showing matching
    bases
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Another way to express this is to say that 9 of the 12 bases need to be changed
    to turn one of the sequences into the other. This is the Hamming distance, and
    it’s somewhat equivalent in bioinformatics to single-nucleotide polymorphisms
    (SNPs, pronounced *snips*) or single-nucleotide variations (SNVs, pronounced *snivs*).
    This algorithm only accounts for the change of one base to another value and falls
    far short of something like sequence alignment that can identify insertions and
    deletions. For instance, [Figure 6-2](#fig_6.2) shows that the sequences *AAACCCGGGTTT*
    and *AACCCGGGTTTA* are 92% similar when aligned (on the left), as they differ
    by a single base. The Hamming distance (on the right), though, shows only 8 bases
    are in common, which means they are only 66% similar.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 0602](assets/mpfb_0602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2\. The alignment of these sequences shows them to be nearly identical,
    while the Hamming distance finds they’re only 66% similar
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This program will always compare strings strictly from their beginnings, which
    limits the practical application to real-world bioinformatics. Still, it turns
    out that this naïve algorithm is a useful metric for sequence similarity, and
    writing the implementation presents many interesting solutions in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use the `abs()` and `min()` functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to combine the elements from two lists of possibly unequal lengths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write `map()` using `lambda` or existing functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use functions from the `operator` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `itertools.starmap()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should work in the *06_hamm* directory of the repository. I suggest you
    start by getting a feel for how the solutions work, so copy one of them to the
    `hamm.py` program and request the help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The program requires two positional arguments, which are the two sequences
    to compare, and the program should print the Hamming distance. For example, I
    would need to make seven edits to change one of these sequences to the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tests (either with **`pytest`** or **`make test`**) to see a passing
    suite. Once you feel you understand what’s expected, remove this file and start
    from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the parameters so that the program requires two positional arguments
    which are the two sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The program arguments will have two string values for the two sequences.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The two sequences are required positional string values.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiate the `Args` object using the two sequences.
  prefs: []
  type: TYPE_NORMAL
- en: The order in which you define positional parameters must match the order in
    which the arguments are provided on the command line. That is, the first positional
    parameter will hold the first positional argument, the second positional parameter
    will match the second positional argument, etc. The order in which you define
    optional parameters does not matter, and optional parameters may be defined before
    or after positional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `main()` function to print the two sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By this point, you should have a program that prints the usage, validates that
    the user supplies two sequences, and prints the sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run **`pytest -xvv`** (the two `v`s increase the verbosity of the output),
    you should find that the program passes the first three tests. It should fail
    `test_input1` with a message like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The inputs for the test come from the file *./tests/inputs/1.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The file is opened and read for the two sequences and the expected result.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The program is run with the two sequences.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `assert` fails when it finds the output from the program does not match
    the expected answer.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, the program printed the two sequences when it should have printed
    `7`.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating the Characters of Two Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now to find the Hamming distance between the two sequences. To start, consider
    these two sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The distance is 2 because you would either need to add *GT* to the first sequence
    or remove *GT* from the second sequence to make them the same. I would suggest
    that the baseline distance is the difference in their lengths. Note that the Rosalind
    challenge assumes two strings of equal lengths, but I want to use this exercise
    to consider strings of different lengths.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the order in which you do the subtraction, you might end up with
    a negative number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `abs()` function to get the absolute value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now I will consider how to iterate the characters they have in common. I can
    use the `min()` function to find the length of the shorter sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And I can use this with the `range()` function to get the indexes of the common
    characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When these two characters are *not* equal, the `distance` variable should be
    incremented because I would have to change one of the values to match the other.
    Remember that the Rosalind challenge always compares the two sequences from their
    beginnings. For instance, the sequences *ATTG* and *TTG* differ by one base, as
    I can either remove *A* from the first or add it to the second to make them match,
    but the rules of this particular challenge would say that the correct answer is
    3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: I believe this should be enough information for you to craft a solution that
    passes the test suite. Once you have a working solution, explore some other ways
    you might write your algorithm, and keep checking your work using the test suite.
    In addition to running the tests via **`pytest`**, be sure to use the **`make
    test`** option to verify that your code also passes the various linting and type-checking
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section works through eight variations on how to find the Hamming distance,
    starting with an entirely manual calculation that takes several lines of code
    and ending with a solution that combines several functions in a single line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 1: Iterating and Counting'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first solution follows from the suggestions in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the two sequences into variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Since I’ll use the lengths more than once, I store them in variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The base distance is the difference between the two lengths.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the shorter length to find the indexes in common.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Check the letters at each position.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Increment the distance by 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the distance.
  prefs: []
  type: TYPE_NORMAL
- en: This solution is very explicit, laying out every individual step needed to compare
    all the characters of two strings. The following solutions will start to shorten
    many of the steps, so be sure you are comfortable with exactly what I’ve shown
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 2: Creating a Unit Test'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first solution leaves me feeling vaguely uncomfortable because the code
    to calculate the Hamming distance should be in a function with tests. I’ll start
    by creating a function called `hamming()` after the `main()` function. As a matter
    of style, I like to put `get_args()` first so I can read it immediately when I
    open the program. My `main()` function always comes second, and all other functions
    and tests after that.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll start by imagining the inputs and output of my function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The function will accept two strings as positional arguments and will return
    an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: To start, the function will always return `0`.
  prefs: []
  type: TYPE_NORMAL
- en: I want to stress the fact that the function does not *print* the answer but
    rather *returns it as a result*. If you wrote this function to `print()` the distance,
    you would not be able to write a unit test. You would have to rely entirely on
    the integration test that looks to see if the program prints the correct answer.
    As much as possible, I would encourage you to write pure functions that act only
    on the arguments and have no side effects. Printing is a side effect, and, while
    the program does need to print the answer eventually, this function’s job is solely
    to return an integer when given two strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve already shown a few test cases I can encode. Feel free to add other tests
    of your own devising:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: I always think it’s good practice to send empty strings for string inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The difference is due only to length.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the example from the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: I’m aware that this may seem a bit extreme, because this function is essentially
    the entire program. I’m almost duplicating the integration test, I know, but I’m
    using this to point out best practices for writing programs. The `hamming()` function
    is a good unit of code, and it belongs in a function with a test. In a much larger
    program, this would be one of perhaps dozens to hundreds of other functions, and
    each should be *encapsulated*, *documented*, and *tested*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following test-driven principles, run **`pytest`** on the program to ensure
    that the test fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now copy the code from `main()` to fix the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that your function is correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can incorporate it into your `main()` function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the return value from the function for the two given sequences.
  prefs: []
  type: TYPE_NORMAL
- en: This hides the complexity of the program inside a named, documented, tested
    unit, shortening the main body of the program and improving the readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 3: Using the zip() Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following solution uses the `zip()` function to combine the elements from
    two sequences. The result is a list of tuples containing the characters from each
    position (see [Figure 6-3](#fig_6.3)). Note that `zip()` is another lazy function,
    so I’ll use `list()` to coerce the values in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![mpfb 0603](assets/mpfb_0603.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3\. The tuples are composed of characters in common positions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If I use the *AC* and *ACGT* sequences, you’ll notice that `zip()` stops with
    the shorter sequence, as shown in [Figure 6-4](#fig_6.4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![mpfb 0604](assets/mpfb_0604.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4\. The `zip()` function will stop at the shortest sequence
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'I can use a `for` loop to iterate over each pair. So far in my `for` loops,
    I’ve used a single variable to represent each element in a list like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Chapter 1](ch01.html#ch01), I showed how to *unpack* the values from a
    tuple into separate variables. The Python `for` loop allows me to unpack each
    tuple into the two characters, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `zip()` function obviates a couple of lines from the first implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the absolute difference of the lengths.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `zip()` to pair up the characters of the two strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Check if the two characters are not equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Increment the distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 4: Using the zip_longest() Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next solution imports the `zip_longest()` function from the `itertools`
    module. As the name implies, it will zip the lists to the length of the longest
    list. [Figure 6-5](#fig_6.5) shows that the function will insert `None` values
    when a shorter sequence has been exhausted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![mpfb 0605](assets/mpfb_0605.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-5\. The `zip_longest()` function will stop at the longest sequence
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'I no longer need to start by subtracting the lengths of the sequences. Instead,
    I’ll initialize a `distance` variable to `0` and then use `zip_longest()` to create
    tuples of bases to compare:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the distance to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Zip to the longest sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Compare the characters.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Increment the counter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 5: Using a List Comprehension'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the solutions up to this point have used a `for` loop. I hope you’re starting
    to anticipate that I’m going to show you how to convert this into a list comprehension
    next. When the goal is to create a new list or reduce a list of values to some
    answer, it’s often shorter and preferable to use a list comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first version is going to use an `if` expression to return a `1` if the
    two characters are the same or a `0` if they are not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The Hamming distance, then, is the sum of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to express this idea is to only produce the `1`s by using a *guard*
    clause, which is a conditional statement at the end of the list comprehension
    that decides whether or not a particular element is allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `if` statement is the guard that will produce the value `1` if the two characters
    are not equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could also use the Boolean/integer coercion I showed in [Chapter 5](ch05.html#ch05),
    where each `True` value will be treated as `1` and `False` is `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Any of these ideas will reduce the function to a single line of code that passes
    the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Solution 6: Using the filter() Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Chapters [4](ch04.html#ch04) and [5](ch05.html#ch05) show that a list comprehension
    with a guard can also be expressed using the `filter()` function. The syntax is
    a little ugly because Python doesn’t allow the unpacking of the tuples from `zip_longest()`
    into separate variables. That is, I want to write a `lambda` that unpacks `char1`
    and `char2` into separate variables, but this is not possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, I will usually call the `lambda` variable `tup` or `t` to remind me
    this is a tuple. I will use the positional tuple notation to compare the element
    in the zeroth position to the element in the first position. `filter()` will only
    produce those tuples where the elements are different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The Hamming distance then is the length of this list. Note that the `len()`
    function will not prompt `filter()` to produce values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is one of those instances where the code must use `list()` to force the
    lazy `filter()` function to generate the results. Here is how I can incorporate
    these ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `filter()` to find tuple pairs of different characters.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Return the length of the resulting list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 7: Using the map() Function with zip_longest()'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This solution uses `map()` instead of `filter()` only to show you that the
    same inability to unpack the tuples also applies. I’d like to use `map()` to produce
    a list of Boolean values indicating whether the character pairs match or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `lambda` is identical to the one to `filter()` that was used as the *predicate*
    to determine which elements are allowed to pass. Here the code *transforms* the
    elements into the result of applying the `lambda` function to the arguments, as
    shown in [Figure 6-6](#fig_6.6). Remember that `map()` will always return the
    same number of elements it consumes, but `filter()` may return fewer or none at
    all.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 0606](assets/mpfb_0606.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-6\. The `map()` function transforms each tuple into a Boolean value
    representing the inequality of the two elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'I can sum these Booleans to get the number of mismatched pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the function with this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Even though these functions have gone from 10 or more lines of code to a single
    line, it still makes sense for this to be a function with a descriptive name and
    tests. Eventually, you’ll start creating modules of reusable code to share across
    your projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 8: Using the starmap() and operator.ne() Functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I confess that I showed the last few solutions solely to build up to this last
    solution. Let me start by showing how I can assign a `lambda` to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not recommended syntax, and `pylint` will definitely fail your code
    on this and recommend a `def` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Both will create a function called `not_same()` that will accept a tuple and
    return whether the two elements are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If, however, I wrote the function to accept two positional arguments, the same
    error I saw before would crop up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'What I need is a version of `map()` that can splat the incoming tuple (as I
    first showed in [Chapter 1](ch01.html#ch01)) by adding `*` (*star*, *asterisk*,
    or *splat*) to the tuple to expand it into its elements, which is exactly what
    the function `itertools.starmap()` does (see [Figure 6-7](#fig_6.7)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '![mpfb 0607](assets/mpfb_0607.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-7\. The `starmap()` function applies a splat to the incoming tuple
    to turn it into the two values that the `lambda` expects
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'But wait, there’s more! I don’t even need to write my own `not_same()` function
    because I already have `operator.ne()` (not equal), which I usually write using
    the `!=` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'An *operator* is a special binary function (accepting two arguments) where
    the function name is usually some symbol like `+` that sits between the arguments.
    In the case of `+`, Python has to decide if this means `operator.add()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'or `operator.concat()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The point is that I already have an existing function that expects two arguments
    and returns whether they are equal, and I can use `starmap()` to properly expand
    the tuples into the needed arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, the Hamming distance is the sum of the unmatched pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Zip the sequences, transform the tuples to Boolean comparisons, and sum.
  prefs: []
  type: TYPE_NORMAL
- en: This final solution relies entirely on fitting four functions that I didn’t
    write. I believe the best code is code you don’t write (or test or document).
    While I prefer this purely functional solution, you may feel this code is overly
    clever. You should use whatever version you’ll be able to understand a year later.
  prefs: []
  type: TYPE_NORMAL
- en: Going Further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without looking at the source code, write a version of `zip_longest()`. Be sure
    to start with a test, then write the function that satisfies the test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expand your program to handle more than two input sequences. Have your program
    print the Hamming distance between every pair of sequences. That means the program
    will print *n* choose *k* numbers which will be *n*! / *k*!(*n* – *k*)!. For three
    sequences, your program will print 3! / (2!(3 – 2)!) = 6 / 2 = 3 distance pairs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try writing a sequence alignment algorithm that will show there is, for instance,
    just one difference between the sequences *AAACCCGGGTTT* and *AACCCGGGTTTA*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This was a rather deep rabbit hole to go down just to find the Hamming distance,
    but it highlights lots of interesting bits about Python functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The built-in `zip()` function will combine two or more lists into a list of
    tuples, grouping elements at common positions. It stops at the shortest sequence,
    so use the `itertools.zip_longest()` function if you want to go to the longest
    sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both `map()` and `filter()` apply a function to some iterable of values. The
    `map()` function will return a new sequence transformed by the function, while
    `filter()` will only return those elements that return a truthy value when the
    function is applied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function passed to `map()` and `filter()` can be an anonymous function created
    by `lambda` or an existing function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `operator` module contains many functions like `ne()` (not equal) that can
    be used with `map()` and `filter()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `functools.starmap()` function works just like `map()` but will splat the
    function’s incoming values to expand them into a list of values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
