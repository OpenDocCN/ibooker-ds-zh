["```py\nlibrary(klaR)\nnaive_model <- NaiveBayes(outcome ~ purpose_ + home_ + emp_len_,\n                          data = na.omit(loan_data))\nnaive_model$table\n$purpose_\n          var\ngrouping   credit_card debt_consolidation home_improvement major_purchase\n  paid off  0.18759649         0.55215915       0.07150104     0.05359270\n  default   0.15151515         0.57571347       0.05981209     0.03727229\n          var\ngrouping      medical      other small_business\n  paid off 0.01424728 0.09990737     0.02099599\n  default  0.01433549 0.11561025     0.04574126\n\n$home_\n          var\ngrouping    MORTGAGE       OWN      RENT\n  paid off 0.4894800 0.0808963 0.4296237\n  default  0.4313440 0.0832782 0.4853778\n\n$emp_len_\n          var\ngrouping     < 1 Year   > 1 Year\n  paid off 0.03105289 0.96894711\n  default  0.04728508 0.95271492\n```", "```py\npredictors = ['purpose_', 'home_', 'emp_len_']\noutcome = 'outcome'\nX = pd.get_dummies(loan_data[predictors], prefix='', prefix_sep='')\ny = loan_data[outcome]\n\nnaive_model = MultinomialNB(alpha=0.01, fit_prior=True)\nnaive_model.fit(X, y)\n```", "```py\nnew_loan <- loan_data[147, c('purpose_', 'home_', 'emp_len_')]\nrow.names(new_loan) <- NULL\nnew_loan\n       \t purpose_    home_  emp_len_\n\t1 small_business MORTGAGE  > 1 Year\n```", "```py\nnew_loan = X.loc[146:146, :]\n```", "```py\npredict(naive_model, new_loan)\n$class\n[1] default\nLevels: paid off default\n\n$posterior\n      paid off   default\n[1,] 0.3463013 0.6536987\n```", "```py\nprint('predicted class: ', naive_model.predict(new_loan)[0])\n\nprobabilities = pd.DataFrame(naive_model.predict_proba(new_loan),\n                             columns=loan_data[outcome].cat.categories)\nprint('predicted probabilities', probabilities)\n--\npredicted class:  default\npredicted probabilities\n    default  paid off\n0  0.653696  0.346304\n```", "```py\nlibrary(MASS)\nloan_lda <- lda(outcome ~ borrower_score + payment_inc_ratio,\n                     data=loan3000)\nloan_lda$scaling\n                          LD1\nborrower_score \t   7.17583880\npayment_inc_ratio -0.09967559\n```", "```py\nloan3000.outcome = loan3000.outcome.astype('category')\n\npredictors = ['borrower_score', 'payment_inc_ratio']\noutcome = 'outcome'\n\nX = loan3000[predictors]\ny = loan3000[outcome]\n\nloan_lda = LinearDiscriminantAnalysis()\nloan_lda.fit(X, y)\npd.DataFrame(loan_lda.scalings_, index=X.columns)\n```", "```py\npred <- predict(loan_lda)\nhead(pred$posterior)\n   paid off   default\n1 0.4464563 0.5535437\n2 0.4410466 0.5589534\n3 0.7273038 0.2726962\n4 0.4937462 0.5062538\n5 0.3900475 0.6099525\n6 0.5892594 0.4107406\n```", "```py\npred = pd.DataFrame(loan_lda.predict_proba(loan3000[predictors]),\n                    columns=loan_lda.classes_)\npred.head()\n```", "```py\ncenter <- 0.5 * (loan_lda$mean[1, ] + loan_lda$mean[2, ])\nslope <- -loan_lda$scaling[1] / loan_lda$scaling[2]\nintercept <- center[2] - center[1] * slope\n\nggplot(data=lda_df, aes(x=borrower_score, y=payment_inc_ratio,\n                        color=prob_default)) +\n  geom_point(alpha=.6) +\n  scale_color_gradientn(colors=c('#ca0020', '#f7f7f7', '#0571b0')) +\n  scale_x_continuous(expand=c(0,0)) +\n  scale_y_continuous(expand=c(0,0), lim=c(0, 20)) +\n  geom_abline(slope=slope, intercept=intercept, color='darkgreen')\n```", "```py\n# Use scalings and center of means to determine decision boundary\ncenter = np.mean(loan_lda.means_, axis=0)\nslope = - loan_lda.scalings_[0] / loan_lda.scalings_[1]\nintercept = center[1] - center[0] * slope\n\n# payment_inc_ratio for borrower_score of 0 and 20\nx_0 = (0 - intercept) / slope\nx_20 = (20 - intercept) / slope\n\nlda_df = pd.concat([loan3000, pred['default']], axis=1)\nlda_df.head()\n\nfig, ax = plt.subplots(figsize=(4, 4))\ng = sns.scatterplot(x='borrower_score', y='payment_inc_ratio',\n                    hue='default', data=lda_df,\n                    palette=sns.diverging_palette(240, 10, n=9, as_cmap=True),\n                    ax=ax, legend=False)\n\nax.set_ylim(0, 20)\nax.set_xlim(0.15, 0.8)\nax.plot((x_0, x_20), (0, 20), linewidth=3)\nax.plot(*loan_lda.means_.transpose())\n```", "```py\nlogistic_model <- glm(outcome ~ payment_inc_ratio + purpose_ +\n                        home_ + emp_len_ + borrower_score,\n                      data=loan_data, family='binomial')\nlogistic_model\n\nCall:  glm(formula = outcome ~ payment_inc_ratio + purpose_ + home_ +\n    emp_len_ + borrower_score, family = \"binomial\", data = loan_data)\n\nCoefficients:\n               (Intercept)           payment_inc_ratio\n                   1.63809                     0.07974\npurpose_debt_consolidation    purpose_home_improvement\n                   0.24937                     0.40774\n    purpose_major_purchase             purpose_medical\n                   0.22963                     0.51048\n             purpose_other      purpose_small_business\n                   0.62066                     1.21526\n                  home_OWN                   home_RENT\n                   0.04833                     0.15732\n         emp_len_ > 1 Year              borrower_score\n                  -0.35673                    -4.61264\n\nDegrees of Freedom: 45341 Total (i.e. Null);  45330 Residual\nNull Deviance:\t    62860\nResidual Deviance: 57510 \tAIC: 57540\n```", "```py\npredictors = ['payment_inc_ratio', 'purpose_', 'home_', 'emp_len_',\n              'borrower_score']\noutcome = 'outcome'\nX = pd.get_dummies(loan_data[predictors], prefix='', prefix_sep='',\n                   drop_first=True)\ny = loan_data[outcome]\n\nlogit_reg = LogisticRegression(penalty='l2', C=1e42, solver='liblinear')\nlogit_reg.fit(X, y)\n```", "```py\npred <- predict(logistic_model)\nsummary(pred)\n     Min.   1st Qu.    Median      Mean   3rd Qu.      Max.\n-2.704774 -0.518825 -0.008539  0.002564  0.505061  3.509606\n```", "```py\npred = pd.DataFrame(logit_reg.predict_log_proba(X),\n                    columns=loan_data[outcome].cat.categories)\npred.describe()\n```", "```py\nprob <- 1/(1 + exp(-pred))\n> summary(prob)\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.\n0.06269 0.37313 0.49787 0.50000 0.62365 0.97096\n```", "```py\npred = pd.DataFrame(logit_reg.predict_proba(X),\n                    columns=loan_data[outcome].cat.categories)\npred.describe()\n```", "```py\nsummary(logistic_model)\n\nCall:\nglm(formula = outcome ~ payment_inc_ratio + purpose_ + home_ +\n    emp_len_ + borrower_score, family = \"binomial\", data = loan_data)\n\nDeviance Residuals:\n     Min        1Q    Median        3Q       Max\n-2.51951  -1.06908  -0.05853   1.07421   2.15528\n\nCoefficients:\n                            Estimate Std. Error z value Pr(>|z|)\n(Intercept)                 1.638092   0.073708  22.224  < 2e-16 ***\npayment_inc_ratio           0.079737   0.002487  32.058  < 2e-16 ***\npurpose_debt_consolidation  0.249373   0.027615   9.030  < 2e-16 ***\npurpose_home_improvement    0.407743   0.046615   8.747  < 2e-16 ***\npurpose_major_purchase      0.229628   0.053683   4.277 1.89e-05 ***\npurpose_medical             0.510479   0.086780   5.882 4.04e-09 ***\npurpose_other               0.620663   0.039436  15.738  < 2e-16 ***\npurpose_small_business      1.215261   0.063320  19.192  < 2e-16 ***\nhome_OWN                    0.048330   0.038036   1.271    0.204\nhome_RENT                   0.157320   0.021203   7.420 1.17e-13 ***\nemp_len_ > 1 Year          -0.356731   0.052622  -6.779 1.21e-11 ***\nborrower_score             -4.612638   0.083558 -55.203  < 2e-16 ***\n---\nSignif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 62857  on 45341  degrees of freedom\nResidual deviance: 57515  on 45330  degrees of freedom\nAIC: 57539\n\nNumber of Fisher Scoring iterations: 4\n```", "```py\ny_numbers = [1 if yi == 'default' else 0 for yi in y]\nlogit_reg_sm = sm.GLM(y_numbers, X.assign(const=1),\n                      family=sm.families.Binomial())\nlogit_result = logit_reg_sm.fit()\nlogit_result.summary()\n```", "```py\nlogistic_gam <- gam(outcome ~ s(payment_inc_ratio) + purpose_ +\n                    home_ + emp_len_ + s(borrower_score),\n                    data=loan_data, family='binomial')\n```", "```py\nimport statsmodels.formula.api as smf\nformula = ('outcome ~ bs(payment_inc_ratio, df=4) + purpose_ + ' +\n           'home_ + emp_len_ + bs(borrower_score, df=4)')\nmodel = smf.glm(formula=formula, data=loan_data, family=sm.families.Binomial())\nresults = model.fit()\n```", "```py\nterms <- predict(logistic_gam, type='terms')\npartial_resid <- resid(logistic_model) + terms\ndf <- data.frame(payment_inc_ratio = loan_data[, 'payment_inc_ratio'],\n                 terms = terms[, 's(payment_inc_ratio)'],\n                 partial_resid = partial_resid[, 's(payment_inc_ratio)'])\nggplot(df, aes(x=payment_inc_ratio, y=partial_resid, solid = FALSE)) +\n  geom_point(shape=46, alpha=0.4) +\n  geom_line(aes(x=payment_inc_ratio, y=terms),\n            color='red', alpha=0.5, size=1.5) +\n  labs(y='Partial Residual')\n```", "```py\npred <- predict(logistic_gam, newdata=train_set)\npred_y <- as.numeric(pred > 0)\ntrue_y <- as.numeric(train_set$outcome=='default')\ntrue_pos <- (true_y==1) & (pred_y==1)\ntrue_neg <- (true_y==0) & (pred_y==0)\nfalse_pos <- (true_y==0) & (pred_y==1)\nfalse_neg <- (true_y==1) & (pred_y==0)\nconf_mat <- matrix(c(sum(true_pos), sum(false_pos),\n                     sum(false_neg), sum(true_neg)), 2, 2)\ncolnames(conf_mat) <- c('Yhat = 1', 'Yhat = 0')\nrownames(conf_mat) <- c('Y = 1', 'Y = 0')\nconf_mat\n      Yhat = 1 Yhat = 0\nY = 1 14295    8376\nY = 0 8052     14619\n```", "```py\npred = logit_reg.predict(X)\npred_y = logit_reg.predict(X) == 'default'\ntrue_y = y == 'default'\ntrue_pos = true_y & pred_y\ntrue_neg = ~true_y & ~pred_y\nfalse_pos = ~true_y & pred_y\nfalse_neg = true_y & ~pred_y\n\nconf_mat = pd.DataFrame([[np.sum(true_pos), np.sum(false_neg)],\n                         [np.sum(false_pos), np.sum(true_neg)]],\n                       index=['Y = default', 'Y = paid off'],\n                       columns=['Yhat = default', 'Yhat = paid off'])\nconf_mat\n```", "```py\n# precision\nconf_mat[1, 1] / sum(conf_mat[,1])\n# recall\nconf_mat[1, 1] / sum(conf_mat[1,])\n# specificity\nconf_mat[2, 2] / sum(conf_mat[2,])\n```", "```py\nconf_mat = confusion_matrix(y, logit_reg.predict(X))\nprint('Precision', conf_mat[0, 0] / sum(conf_mat[:, 0]))\nprint('Recall', conf_mat[0, 0] / sum(conf_mat[0, :]))\nprint('Specificity', conf_mat[1, 1] / sum(conf_mat[1, :]))\n\nprecision_recall_fscore_support(y, logit_reg.predict(X),\n                                labels=['default', 'paid off'])\n```", "```py\nidx <- order(-pred)\nrecall <- cumsum(true_y[idx] == 1) / sum(true_y == 1)\nspecificity <- (sum(true_y == 0) - cumsum(true_y[idx] == 0)) / sum(true_y == 0)\nroc_df <- data.frame(recall = recall, specificity = specificity)\nggplot(roc_df, aes(x=specificity, y=recall)) +\n  geom_line(color='blue') +\n  scale_x_reverse(expand=c(0, 0)) +\n  scale_y_continuous(expand=c(0, 0)) +\n  geom_line(data=data.frame(x=(0:100) / 100), aes(x=x, y=1-x),\n            linetype='dotted', color='red')\n```", "```py\nfpr, tpr, thresholds = roc_curve(y, logit_reg.predict_proba(X)[:,0],\n                                 pos_label='default')\nroc_df = pd.DataFrame({'recall': tpr, 'specificity': 1 - fpr})\n\nax = roc_df.plot(x='specificity', y='recall', figsize=(4, 4), legend=False)\nax.set_ylim(0, 1)\nax.set_xlim(1, 0)\nax.plot((1, 0), (0, 1))\nax.set_xlabel('specificity')\nax.set_ylabel('recall')\n```", "```py\nsum(roc_df$recall[-1] * diff(1 - roc_df$specificity))\n    [1] 0.6926172\n```", "```py\nprint(np.sum(roc_df.recall[:-1] * np.diff(1 - roc_df.specificity)))\nprint(roc_auc_score([1 if yi == 'default' else 0 for yi in y],\n                    logit_reg.predict_proba(X)[:, 0]))\n```", "```py\nmean(full_train_set$outcome=='default')\n[1] 0.1889455\n```", "```py\nprint('percentage of loans in default: ',\n      100 * np.mean(full_train_set.outcome == 'default'))\n```", "```py\nfull_model <- glm(outcome ~ payment_inc_ratio + purpose_ + home_ +\n                            emp_len_+ dti + revol_bal + revol_util,\n                 data=full_train_set, family='binomial')\npred <- predict(full_model)\nmean(pred > 0)\n[1] 0.003942094\n```", "```py\npredictors = ['payment_inc_ratio', 'purpose_', 'home_', 'emp_len_',\n              'dti', 'revol_bal', 'revol_util']\noutcome = 'outcome'\nX = pd.get_dummies(full_train_set[predictors], prefix='', prefix_sep='',\n                   drop_first=True)\ny = full_train_set[outcome]\n\nfull_model = LogisticRegression(penalty='l2', C=1e42, solver='liblinear')\nfull_model.fit(X, y)\nprint('percentage of loans predicted to default: ',\n      100 * np.mean(full_model.predict(X) == 'default'))\n```", "```py\nwt <- ifelse(full_train_set$outcome=='default',\n             1 / mean(full_train_set$outcome == 'default'), 1)\nfull_model <- glm(outcome ~ payment_inc_ratio + purpose_ + home_ +\n                            emp_len_+ dti + revol_bal + revol_util,\n                  data=full_train_set, weight=wt, family='quasibinomial')\npred <- predict(full_model)\nmean(pred > 0)\n[1] 0.5767208\n```", "```py\ndefault_wt = 1 / np.mean(full_train_set.outcome == 'default')\nwt = [default_wt if outcome == 'default' else 1\n      for outcome in full_train_set.outcome]\n\nfull_model = LogisticRegression(penalty=\"l2\", C=1e42, solver='liblinear')\nfull_model.fit(X, y, sample_weight=wt)\nprint('percentage of loans predicted to default (weighting): ',\n      100 * np.mean(full_model.predict(X) == 'default'))\n```"]