- en: Chapter 11\. Sorting Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up to this point we have been concerned mainly with tools to access and operate
    on array data with NumPy. This chapter covers algorithms related to sorting values
    in NumPy arrays. These algorithms are a favorite topic in introductory computer
    science courses: if you‚Äôve ever taken one, you probably have had dreams (or, depending
    on your temperament, nightmares) about *insertion sorts*, *selection sorts*, *merge
    sorts*, *quick sorts*, *bubble sorts*, and many, many more. All are means of accomplishing
    a similar task: sorting the values in a list or array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has a couple of built-in functions and methods for sorting lists and
    other iterable objects. The `sorted` function accepts a list and returns a sorted
    version of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'By contrast, the `sort` method of lists will sort the list in-place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Python‚Äôs sorting methods are quite flexible, and can handle any iterable object.
    For example, here we sort a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These built-in sorting methods are convenient, but as previously discussed,
    the dynamism of Python values means that they are less performant than routines
    designed specifically for uniform arrays of numbers. This is where NumPy‚Äôs sorting
    routines come in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fast Sorting in NumPy: np.sort and np.argsort'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `np.sort` function is analogous to Python‚Äôs built-in `sorted` function,
    and will efficiently return a sorted copy of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly to the `sort` method of Python lists, you can also sort an array
    in-place using the array `sort` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A related function is `argsort`, which instead returns the *indices* of the
    sorted elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The first element of this result gives the index of the smallest element, the
    second value gives the index of the second smallest, and so on. These indices
    can then be used (via fancy indexing) to construct the sorted array if desired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You‚Äôll see an application of `argsort` later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting Along Rows or Columns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A useful feature of NumPy‚Äôs sorting algorithms is the ability to sort along
    specific rows or columns of a multidimensional array using the `axis` argument.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that this treats each row or column as an independent array, and
    any relationships between the row or column values will be lost!
  prefs: []
  type: TYPE_NORMAL
- en: 'Partial Sorts: Partitioning'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes we‚Äôre not interested in sorting the entire array, but simply want
    to find the *k* smallest values in the array. NumPy enables this with the `np.partition`
    function. `np.partition` takes an array and a number *k*; the result is a new
    array with the smallest *k* values to the left of the partition and the remaining
    values to the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the first three values in the resulting array are the three smallest
    in the array, and the remaining array positions contain the remaining values.
    Within the two partitions, the elements have arbitrary order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly to sorting, we can partition along an arbitrary axis of a multidimensional
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The result is an array where the first two slots in each row contain the smallest
    values from that row, with the remaining values filling the remaining slots.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, just as there is an `np.argsort` function that computes indices of
    the sort, there is an `np.argpartition` function that computes indices of the
    partition. We‚Äôll see both of these in action in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: k-Nearest Neighbors'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let‚Äôs quickly see how we might use the `argsort` function along multiple axes
    to find the nearest neighbors of each point in a set. We‚Äôll start by creating
    a random set of 10 points on a two-dimensional plane. Using the standard convention,
    we‚Äôll arrange these in a <math alttext="10 times 2"><mrow><mn>10</mn> <mo>√ó</mo>
    <mn>2</mn></mrow></math> array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To get an idea of how these points look, let‚Äôs generate a quick scatter plot
    (see [Figure¬†11-1](#fig_0208-sorting_files_in_output_30_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![output 30 0](assets/output_30_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-1\. Visualization of points in the k-neighbors example
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now we‚Äôll compute the distance between each pair of points. Recall that the
    squared distance between two points is the sum of the squared differences in each
    dimension; using the efficient broadcasting ([Chapter¬†8](ch08.xhtml#section-0205-computation-on-arrays-broadcasting))
    and aggregation ([Chapter¬†7](ch07.xhtml#section-0204-computation-on-arrays-aggregates))
    routines provided by NumPy we can compute the matrix of square distances in a
    single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This operation has a lot packed into it, and it might be a bit confusing if
    you‚Äôre unfamiliar with NumPy‚Äôs broadcasting rules. When you come across code like
    this, it can be useful to break it down into its component steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As a quick check of our logic, we should see that the diagonal of this matrix
    (i.e., the set of distances between each point and itself) is all zeros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With the pairwise square distances converted, we can now use `np.argsort` to
    sort along each row. The leftmost columns will then give the indices of the nearest
    neighbors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the first column gives the numbers 0 through 9 in order: this is
    due to the fact that each point‚Äôs closest neighbor is itself, as we would expect.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By using a full sort here, we‚Äôve actually done more work than we need to in
    this case. If we‚Äôre simply interested in the nearest <math alttext="k"><mi>k</mi></math>
    neighbors, all we need to do is partition each row so that the smallest <math
    alttext="k plus 1"><mrow><mi>k</mi> <mo>+</mo> <mn>1</mn></mrow></math> squared
    distances come first, with larger distances filling the remaining positions of
    the array. We can do this with the `np.argpartition` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In order to visualize this network of neighbors, let‚Äôs quickly plot the points
    along with lines representing the connections from each point to its two nearest
    neighbors (see [Figure¬†11-2](#fig_0208-sorting_files_in_output_44_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![output 44 0](assets/output_44_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-2\. Visualization of the nearest neighbors of each point
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Each point in the plot has lines drawn to its two nearest neighbors. At first
    glance, it might seem strange that some of the points have more than two lines
    coming out of them: this is due to the fact that if point A is one of the two
    nearest neighbors of point B, this does not necessarily imply that point B is
    one of the two nearest neighbors of point A.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the broadcasting and row-wise sorting of this approach might seem
    less straightforward than writing a loop, it turns out to be a very efficient
    way of operating on this data in Python. You might be tempted to do the same type
    of operation by manually looping through the data and sorting each set of neighbors
    individually, but this would almost certainly lead to a slower algorithm than
    the vectorized version we used. The beauty of this approach is that it‚Äôs written
    in a way that‚Äôs agnostic to the size of the input data: we could just as easily
    compute the neighbors among 100 or 1,000,000 points in any number of dimensions,
    and the code would look the same.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I‚Äôll note that when doing very large nearest neighbor searches, there
    are tree-based and/or approximate algorithms that can scale as <math alttext="script
    upper O left-bracket upper N log upper N right-bracket"><mrow><mi>ùí™</mi> <mo>[</mo>
    <mi>N</mi> <mo form="prefix">log</mo> <mi>N</mi> <mo>]</mo></mrow></math> or better
    rather than the <math alttext="script upper O left-bracket upper N squared right-bracket"><mrow><mi>ùí™</mi>
    <mo>[</mo> <msup><mi>N</mi> <mn>2</mn></msup> <mo>]</mo></mrow></math> of the
    brute-force algorithm. One example of this is the KD-Tree, [implemented in Scikit-Learn](https://oreil.ly/lUFb8).
  prefs: []
  type: TYPE_NORMAL
