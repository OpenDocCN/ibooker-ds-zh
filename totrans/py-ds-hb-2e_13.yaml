- en: Chapter 11\. Sorting Arrays
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç¬¬11ç« . æ•°ç»„æ’åº
- en: 'Up to this point we have been concerned mainly with tools to access and operate
    on array data with NumPy. This chapter covers algorithms related to sorting values
    in NumPy arrays. These algorithms are a favorite topic in introductory computer
    science courses: if youâ€™ve ever taken one, you probably have had dreams (or, depending
    on your temperament, nightmares) about *insertion sorts*, *selection sorts*, *merge
    sorts*, *quick sorts*, *bubble sorts*, and many, many more. All are means of accomplishing
    a similar task: sorting the values in a list or array.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬ä¸»è¦å…³æ³¨ä½¿ç”¨NumPyè®¿é—®å’Œæ“ä½œæ•°ç»„æ•°æ®çš„å·¥å…·ã€‚æœ¬ç« æ¶µç›–äº†ä¸NumPyæ•°ç»„ä¸­å€¼æ’åºç›¸å…³çš„ç®—æ³•ã€‚è¿™äº›ç®—æ³•æ˜¯è®¡ç®—æœºç§‘å­¦å¯¼è®ºè¯¾ç¨‹çš„çƒ­é—¨è¯é¢˜ï¼šå¦‚æœä½ æ›¾ç»å‚åŠ è¿‡è¿™æ ·çš„è¯¾ç¨‹ï¼Œä½ å¯èƒ½æ›¾ç»æ¢¦æƒ³è¿‡ï¼ˆæˆ–è€…ï¼Œæ ¹æ®ä½ çš„æ€§æ ¼ï¼Œå™©æ¢¦ï¼‰*æ’å…¥æ’åº*ã€*é€‰æ‹©æ’åº*ã€*å½’å¹¶æ’åº*ã€*å¿«é€Ÿæ’åº*ã€*å†’æ³¡æ’åº*ç­‰ç­‰ã€‚æ‰€æœ‰è¿™äº›æ–¹æ³•éƒ½æ˜¯å®Œæˆç›¸ä¼¼ä»»åŠ¡çš„æ‰‹æ®µï¼šå¯¹åˆ—è¡¨æˆ–æ•°ç»„ä¸­çš„å€¼è¿›è¡Œæ’åºã€‚
- en: 'Python has a couple of built-in functions and methods for sorting lists and
    other iterable objects. The `sorted` function accepts a list and returns a sorted
    version of it:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Pythonæœ‰å‡ ä¸ªç”¨äºæ’åºåˆ—è¡¨å’Œå…¶ä»–å¯è¿­ä»£å¯¹è±¡çš„å†…ç½®å‡½æ•°å’Œæ–¹æ³•ã€‚`sorted`å‡½æ•°æ¥å—ä¸€ä¸ªåˆ—è¡¨å¹¶è¿”å›å…¶æ’åºç‰ˆæœ¬ï¼š
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'By contrast, the `sort` method of lists will sort the list in-place:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸æ¯”ä¹‹ä¸‹ï¼Œåˆ—è¡¨çš„`sort`æ–¹æ³•ä¼šå°±åœ°å¯¹åˆ—è¡¨è¿›è¡Œæ’åºï¼š
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Pythonâ€™s sorting methods are quite flexible, and can handle any iterable object.
    For example, here we sort a string:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Pythonçš„æ’åºæ–¹æ³•éå¸¸çµæ´»ï¼Œå¯ä»¥å¤„ç†ä»»ä½•å¯è¿­ä»£å¯¹è±¡ã€‚ä¾‹å¦‚ï¼Œè¿™é‡Œæˆ‘ä»¬å¯¹ä¸€ä¸ªå­—ç¬¦ä¸²è¿›è¡Œæ’åºï¼š
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These built-in sorting methods are convenient, but as previously discussed,
    the dynamism of Python values means that they are less performant than routines
    designed specifically for uniform arrays of numbers. This is where NumPyâ€™s sorting
    routines come in.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›å†…ç½®çš„æ’åºæ–¹æ³•å¾ˆæ–¹ä¾¿ï¼Œä½†æ­£å¦‚å‰é¢è®¨è®ºçš„é‚£æ ·ï¼ŒPythonå€¼çš„åŠ¨æ€æ€§æ„å‘³ç€å®ƒä»¬çš„æ€§èƒ½æ¯”ä¸“é—¨è®¾è®¡ç”¨äºå‡åŒ€æ•°ç»„çš„ä¾‹ç¨‹è¦å·®ã€‚è¿™å°±æ˜¯NumPyæ’åºä¾‹ç¨‹çš„ç”¨æ­¦ä¹‹åœ°ã€‚
- en: 'Fast Sorting in NumPy: np.sort and np.argsort'
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'NumPyä¸­çš„å¿«é€Ÿæ’åº: np.sort å’Œ np.argsort'
- en: 'The `np.sort` function is analogous to Pythonâ€™s built-in `sorted` function,
    and will efficiently return a sorted copy of an array:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.sort`å‡½æ•°ç±»ä¼¼äºPythonçš„å†…ç½®`sorted`å‡½æ•°ï¼Œå¹¶ä¸”èƒ½å¤Ÿé«˜æ•ˆåœ°è¿”å›æ•°ç»„çš„æ’åºå‰¯æœ¬ï¼š'
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Similarly to the `sort` method of Python lists, you can also sort an array
    in-place using the array `sort` method:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ç±»ä¼¼äºPythonåˆ—è¡¨çš„`sort`æ–¹æ³•ï¼Œä½ ä¹Ÿå¯ä»¥ä½¿ç”¨æ•°ç»„çš„`sort`æ–¹æ³•åŸåœ°å¯¹æ•°ç»„è¿›è¡Œæ’åºï¼š
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A related function is `argsort`, which instead returns the *indices* of the
    sorted elements:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸å…³çš„å‡½æ•°æ˜¯`argsort`ï¼Œå®ƒè¿”å›æ’åºå…ƒç´ çš„*ç´¢å¼•*ï¼š
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The first element of this result gives the index of the smallest element, the
    second value gives the index of the second smallest, and so on. These indices
    can then be used (via fancy indexing) to construct the sorted array if desired:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æœçš„ç¬¬ä¸€ä¸ªå…ƒç´ ç»™å‡ºäº†æœ€å°å…ƒç´ çš„ç´¢å¼•ï¼Œç¬¬äºŒä¸ªå€¼ç»™å‡ºäº†ç¬¬äºŒå°çš„ç´¢å¼•ï¼Œä¾æ­¤ç±»æ¨ã€‚å¦‚æœéœ€è¦çš„è¯ï¼Œè¿™äº›ç´¢å¼•å¯ä»¥ç”¨ï¼ˆé€šè¿‡èŠ±å¼ç´¢å¼•ï¼‰æ¥æ„é€ æ’åºåçš„æ•°ç»„ï¼š
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Youâ€™ll see an application of `argsort` later in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å°†åœ¨æœ¬ç« åé¢çœ‹åˆ°`argsort`çš„åº”ç”¨ã€‚
- en: Sorting Along Rows or Columns
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ²¿è¡Œæˆ–åˆ—æ’åº
- en: 'A useful feature of NumPyâ€™s sorting algorithms is the ability to sort along
    specific rows or columns of a multidimensional array using the `axis` argument.
    For example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: NumPyæ’åºç®—æ³•çš„ä¸€ä¸ªæœ‰ç”¨ç‰¹æ€§æ˜¯å¯ä»¥ä½¿ç”¨`axis`å‚æ•°æ²¿ç€å¤šç»´æ•°ç»„çš„ç‰¹å®šè¡Œæˆ–åˆ—è¿›è¡Œæ’åºã€‚ä¾‹å¦‚ï¼š
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Keep in mind that this treats each row or column as an independent array, and
    any relationships between the row or column values will be lost!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œè¿™å°†æŠŠæ¯è¡Œæˆ–åˆ—è§†ä¸ºç‹¬ç«‹çš„æ•°ç»„ï¼Œè¡Œæˆ–åˆ—å€¼ä¹‹é—´çš„ä»»ä½•å…³ç³»éƒ½å°†ä¸¢å¤±ï¼
- en: 'Partial Sorts: Partitioning'
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'éƒ¨åˆ†æ’åº: åˆ†åŒº'
- en: 'Sometimes weâ€™re not interested in sorting the entire array, but simply want
    to find the *k* smallest values in the array. NumPy enables this with the `np.partition`
    function. `np.partition` takes an array and a number *k*; the result is a new
    array with the smallest *k* values to the left of the partition and the remaining
    values to the right:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰æ—¶å€™æˆ‘ä»¬å¹¶ä¸æƒ³å¯¹æ•´ä¸ªæ•°ç»„è¿›è¡Œæ’åºï¼Œè€Œåªæ˜¯æƒ³æ‰¾å‡ºæ•°ç»„ä¸­æœ€å°çš„*k*ä¸ªå€¼ã€‚NumPyé€šè¿‡`np.partition`å‡½æ•°å®ç°äº†è¿™ä¸€ç‚¹ã€‚`np.partition`æ¥å—ä¸€ä¸ªæ•°ç»„å’Œä¸€ä¸ªæ•°*k*ï¼›ç»“æœæ˜¯ä¸€ä¸ªæ–°æ•°ç»„ï¼Œæœ€å°çš„*k*ä¸ªå€¼ä½äºåˆ†åŒºçš„å·¦ä¾§ï¼Œå‰©ä½™çš„å€¼ä½äºå³ä¾§ï¼š
- en: '[PRE10]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that the first three values in the resulting array are the three smallest
    in the array, and the remaining array positions contain the remaining values.
    Within the two partitions, the elements have arbitrary order.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ç»“æœæ•°ç»„ä¸­çš„å‰ä¸‰ä¸ªå€¼æ˜¯æ•°ç»„ä¸­æœ€å°çš„ä¸‰ä¸ªå€¼ï¼Œå‰©ä¸‹çš„æ•°ç»„ä½ç½®åŒ…å«å‰©ä½™çš„å€¼ã€‚åœ¨è¿™ä¸¤ä¸ªåˆ†åŒºä¸­ï¼Œå…ƒç´ çš„é¡ºåºæ˜¯ä»»æ„çš„ã€‚
- en: 'Similarly to sorting, we can partition along an arbitrary axis of a multidimensional
    array:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ç±»ä¼¼äºæ’åºï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥æ²¿ç€å¤šç»´æ•°ç»„çš„ä»»æ„è½´è¿›è¡Œåˆ†åŒºï¼š
- en: '[PRE11]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The result is an array where the first two slots in each row contain the smallest
    values from that row, with the remaining values filling the remaining slots.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æœæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œå…¶ä¸­æ¯è¡Œçš„å‰ä¸¤ä¸ªæ§½åŒ…å«è¯¥è¡Œçš„æœ€å°å€¼ï¼Œå…¶ä½™å€¼å¡«å……å…¶ä½™æ§½ä½ã€‚
- en: Finally, just as there is an `np.argsort` function that computes indices of
    the sort, there is an `np.argpartition` function that computes indices of the
    partition. Weâ€™ll see both of these in action in the following section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œå°±åƒæœ‰ä¸€ä¸ªè®¡ç®—æ’åºç´¢å¼•çš„`np.argsort`å‡½æ•°ä¸€æ ·ï¼Œæœ‰ä¸€ä¸ªè®¡ç®—åˆ†åŒºç´¢å¼•çš„`np.argpartition`å‡½æ•°ã€‚æˆ‘ä»¬å°†åœ¨æ¥ä¸‹æ¥çš„éƒ¨åˆ†ä¸­çœ‹åˆ°è¿™ä¸¤è€…çš„ä½œç”¨ã€‚
- en: 'Example: k-Nearest Neighbors'
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç¤ºä¾‹ï¼šk-æœ€è¿‘é‚»ç®—æ³•
- en: 'Letâ€™s quickly see how we might use the `argsort` function along multiple axes
    to find the nearest neighbors of each point in a set. Weâ€™ll start by creating
    a random set of 10 points on a two-dimensional plane. Using the standard convention,
    weâ€™ll arrange these in a <math alttext="10 times 2"><mrow><mn>10</mn> <mo>Ã—</mo>
    <mn>2</mn></mrow></math> array:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å¿«é€Ÿçœ‹çœ‹å¦‚ä½•æ²¿ç€å¤šä¸ªè½´ä½¿ç”¨`argsort`å‡½æ•°æ¥æ‰¾åˆ°é›†åˆä¸­æ¯ä¸ªç‚¹çš„æœ€è¿‘é‚»å±…ã€‚æˆ‘ä»¬å°†ä»åœ¨äºŒç»´å¹³é¢ä¸Šåˆ›å»ºçš„éšæœº10ä¸ªç‚¹é›†å¼€å§‹ã€‚æŒ‰ç…§æ ‡å‡†çº¦å®šï¼Œæˆ‘ä»¬å°†è¿™äº›ç‚¹æ’åˆ—åœ¨ä¸€ä¸ª<math
    alttext="10 times 2"><mrow><mn>10</mn> <mo>Ã—</mo> <mn>2</mn></mrow></math>æ•°ç»„ä¸­ï¼š
- en: '[PRE12]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To get an idea of how these points look, letâ€™s generate a quick scatter plot
    (see [FigureÂ 11-1](#fig_0208-sorting_files_in_output_30_0)).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†äº†è§£è¿™äº›ç‚¹çš„å¤–è§‚ï¼Œè®©æˆ‘ä»¬ç”Ÿæˆä¸€ä¸ªå¿«é€Ÿçš„æ•£ç‚¹å›¾ï¼ˆè§[å›¾11-1](#fig_0208-sorting_files_in_output_30_0)ï¼‰ã€‚
- en: '[PRE13]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![output 30 0](assets/output_30_0.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![output 30 0](assets/output_30_0.png)'
- en: Figure 11-1\. Visualization of points in the k-neighbors example
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾11-1\. k-æœ€è¿‘é‚»ç¤ºä¾‹ä¸­çš„ç‚¹çš„å¯è§†åŒ–
- en: 'Now weâ€™ll compute the distance between each pair of points. Recall that the
    squared distance between two points is the sum of the squared differences in each
    dimension; using the efficient broadcasting ([ChapterÂ 8](ch08.xhtml#section-0205-computation-on-arrays-broadcasting))
    and aggregation ([ChapterÂ 7](ch07.xhtml#section-0204-computation-on-arrays-aggregates))
    routines provided by NumPy we can compute the matrix of square distances in a
    single line of code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å°†è®¡ç®—æ¯å¯¹ç‚¹ä¹‹é—´çš„è·ç¦»ã€‚å›æƒ³ä¸€ä¸‹ï¼Œä¸¤ç‚¹ä¹‹é—´çš„å¹³æ–¹è·ç¦»æ˜¯æ¯ä¸ªç»´åº¦ä¸Šå¹³æ–¹å·®çš„å’Œï¼›ä½¿ç”¨NumPyæä¾›çš„é«˜æ•ˆå¹¿æ’­ï¼ˆ[ç¬¬8ç« ](ch08.xhtml#section-0205-computation-on-arrays-broadcasting)ï¼‰å’Œèšåˆï¼ˆ[ç¬¬7ç« ](ch07.xhtml#section-0204-computation-on-arrays-aggregates)ï¼‰ä¾‹ç¨‹ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä¸€è¡Œä»£ç ä¸­è®¡ç®—å‡ºå¹³æ–¹è·ç¦»çŸ©é˜µï¼š
- en: '[PRE14]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This operation has a lot packed into it, and it might be a bit confusing if
    youâ€™re unfamiliar with NumPyâ€™s broadcasting rules. When you come across code like
    this, it can be useful to break it down into its component steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªæ“ä½œåŒ…å«äº†å¾ˆå¤šå†…å®¹ï¼Œå¦‚æœä½ ä¸ç†Ÿæ‚‰NumPyçš„å¹¿æ’­è§„åˆ™ï¼Œå¯èƒ½ä¼šæ„Ÿåˆ°æœ‰äº›å›°æƒ‘ã€‚å½“ä½ é‡åˆ°è¿™æ ·çš„ä»£ç æ—¶ï¼Œå°†å…¶åˆ†è§£ä¸ºå„ä¸ªæ­¥éª¤å¯èƒ½ä¼šå¾ˆæœ‰ç”¨ï¼š
- en: '[PRE15]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As a quick check of our logic, we should see that the diagonal of this matrix
    (i.e., the set of distances between each point and itself) is all zeros:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºæˆ‘ä»¬é€»è¾‘çš„å¿«é€Ÿæ£€æŸ¥ï¼Œæˆ‘ä»¬åº”è¯¥çœ‹åˆ°è¿™ä¸ªçŸ©é˜µçš„å¯¹è§’çº¿ï¼ˆå³æ¯ä¸ªç‚¹ä¸è‡ªèº«ä¹‹é—´çš„è·ç¦»é›†åˆï¼‰å…¨ä¸ºé›¶ï¼š
- en: '[PRE18]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With the pairwise square distances converted, we can now use `np.argsort` to
    sort along each row. The leftmost columns will then give the indices of the nearest
    neighbors:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦è½¬æ¢ä¸ºæˆå¯¹çš„å¹³æ–¹è·ç¦»ï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥ä½¿ç”¨`np.argsort`æ²¿ç€æ¯ä¸€è¡Œæ’åºã€‚æœ€å·¦è¾¹çš„åˆ—å°†ç»™å‡ºæœ€è¿‘é‚»å±…çš„ç´¢å¼•ï¼š
- en: '[PRE19]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Notice that the first column gives the numbers 0 through 9 in order: this is
    due to the fact that each pointâ€™s closest neighbor is itself, as we would expect.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œç¬¬ä¸€åˆ—æŒ‰é¡ºåºç»™å‡ºäº†æ•°å­—0åˆ°9ï¼šè¿™æ˜¯å› ä¸ºæ¯ä¸ªç‚¹çš„æœ€è¿‘é‚»å±…æ˜¯å®ƒè‡ªå·±ï¼Œè¿™æ˜¯æˆ‘ä»¬é¢„æœŸçš„ç»“æœã€‚
- en: 'By using a full sort here, weâ€™ve actually done more work than we need to in
    this case. If weâ€™re simply interested in the nearest <math alttext="k"><mi>k</mi></math>
    neighbors, all we need to do is partition each row so that the smallest <math
    alttext="k plus 1"><mrow><mi>k</mi> <mo>+</mo> <mn>1</mn></mrow></math> squared
    distances come first, with larger distances filling the remaining positions of
    the array. We can do this with the `np.argpartition` function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œä½¿ç”¨å®Œå…¨æ’åºï¼Œå®é™…ä¸Šåšäº†æ¯”éœ€è¦çš„æ›´å¤šçš„å·¥ä½œã€‚å¦‚æœæˆ‘ä»¬åªæ˜¯å¯¹æœ€è¿‘çš„<math alttext="k"><mi>k</mi></math>ä¸ªé‚»å±…æ„Ÿå…´è¶£ï¼Œæˆ‘ä»¬åªéœ€å¯¹æ¯ä¸€è¡Œè¿›è¡Œåˆ†åŒºï¼Œä½¿å¾—æœ€å°çš„<math
    alttext="k plus 1"><mrow><mi>k</mi> <mo>+</mo> <mn>1</mn></mrow></math>ä¸ªå¹³æ–¹è·ç¦»é¦–å…ˆå‡ºç°ï¼Œå‰©ä½™çš„è·ç¦»å¡«å……æ•°ç»„çš„å…¶ä½™ä½ç½®ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨`np.argpartition`å‡½æ•°å®ç°è¿™ä¸€ç‚¹ï¼š
- en: '[PRE20]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In order to visualize this network of neighbors, letâ€™s quickly plot the points
    along with lines representing the connections from each point to its two nearest
    neighbors (see [FigureÂ 11-2](#fig_0208-sorting_files_in_output_44_0)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†å¯è§†åŒ–è¿™äº›é‚»å±…çš„ç½‘ç»œï¼Œè®©æˆ‘ä»¬å¿«é€Ÿç»˜åˆ¶è¿™äº›ç‚¹ä»¥åŠä»£è¡¨ä»æ¯ä¸ªç‚¹åˆ°å…¶ä¸¤ä¸ªæœ€è¿‘é‚»å±…çš„è¿æ¥çš„çº¿æ¡ï¼ˆè§[å›¾11-2](#fig_0208-sorting_files_in_output_44_0)ï¼‰ã€‚
- en: '[PRE21]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![output 44 0](assets/output_44_0.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![output 44 0](assets/output_44_0.png)'
- en: Figure 11-2\. Visualization of the nearest neighbors of each point
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾11-2\. æ¯ä¸ªç‚¹çš„æœ€è¿‘é‚»å±…çš„å¯è§†åŒ–
- en: 'Each point in the plot has lines drawn to its two nearest neighbors. At first
    glance, it might seem strange that some of the points have more than two lines
    coming out of them: this is due to the fact that if point A is one of the two
    nearest neighbors of point B, this does not necessarily imply that point B is
    one of the two nearest neighbors of point A.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯ä¸ªå›¾ä¸­çš„ç‚¹éƒ½æœ‰çº¿è¿æ¥åˆ°å…¶ä¸¤ä¸ªæœ€è¿‘çš„é‚»å±…ã€‚ä¹ä¸€çœ‹ï¼Œä¸€äº›ç‚¹æœ‰è¶…è¿‡ä¸¤æ¡çº¿è¿æ¥å¯èƒ½ä¼šæ˜¾å¾—å¥‡æ€ªï¼šè¿™æ˜¯å› ä¸ºå¦‚æœç‚¹Aæ˜¯ç‚¹Bçš„ä¸¤ä¸ªæœ€è¿‘é‚»ä¹‹ä¸€ï¼Œè¿™å¹¶ä¸ä¸€å®šæ„å‘³ç€ç‚¹Bæ˜¯ç‚¹Açš„ä¸¤ä¸ªæœ€è¿‘é‚»ä¹‹ä¸€ã€‚
- en: 'Although the broadcasting and row-wise sorting of this approach might seem
    less straightforward than writing a loop, it turns out to be a very efficient
    way of operating on this data in Python. You might be tempted to do the same type
    of operation by manually looping through the data and sorting each set of neighbors
    individually, but this would almost certainly lead to a slower algorithm than
    the vectorized version we used. The beauty of this approach is that itâ€™s written
    in a way thatâ€™s agnostic to the size of the input data: we could just as easily
    compute the neighbors among 100 or 1,000,000 points in any number of dimensions,
    and the code would look the same.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡è¿™ç§æ–¹æ³•çš„å¹¿æ’­å’Œè¡Œæ’åºå¯èƒ½æ¯”ç¼–å†™å¾ªç¯ä¸é‚£ä¹ˆç›´è§‚ï¼Œä½†äº‹å®è¯æ˜è¿™æ˜¯ä¸€ç§éå¸¸é«˜æ•ˆçš„åœ¨Pythonä¸­å¤„ç†è¿™äº›æ•°æ®çš„æ–¹æ³•ã€‚æ‚¨å¯èƒ½ä¼šå°è¯•é€šè¿‡æ‰‹åŠ¨å¾ªç¯éå†æ•°æ®å¹¶é€ä¸ªæ’åºæ¯ç»„é‚»å±…æ¥æ‰§è¡Œç›¸åŒç±»å‹çš„æ“ä½œï¼Œä½†è¿™å‡ ä¹è‚¯å®šä¼šå¯¼è‡´æ¯”æˆ‘ä»¬ä½¿ç”¨çš„å‘é‡åŒ–ç‰ˆæœ¬æ›´æ…¢çš„ç®—æ³•ã€‚è¿™ç§æ–¹æ³•çš„ç¾å¦™ä¹‹å¤„åœ¨äºå®ƒä»¥ä¸€ç§å¯¹è¾“å…¥æ•°æ®å¤§å°ä¸å¯çŸ¥çš„æ–¹å¼ç¼–å†™ï¼šæˆ‘ä»¬å¯ä»¥è½»æ¾åœ°åœ¨ä»»æ„ç»´åº¦ä¸­è®¡ç®—100ä¸ªæˆ–1,000,000ä¸ªç‚¹ä¹‹é—´çš„é‚»å±…ï¼Œä»£ç çœ‹èµ·æ¥éƒ½ä¸€æ ·ã€‚
- en: Finally, Iâ€™ll note that when doing very large nearest neighbor searches, there
    are tree-based and/or approximate algorithms that can scale as <math alttext="script
    upper O left-bracket upper N log upper N right-bracket"><mrow><mi>ğ’ª</mi> <mo>[</mo>
    <mi>N</mi> <mo form="prefix">log</mo> <mi>N</mi> <mo>]</mo></mrow></math> or better
    rather than the <math alttext="script upper O left-bracket upper N squared right-bracket"><mrow><mi>ğ’ª</mi>
    <mo>[</mo> <msup><mi>N</mi> <mn>2</mn></msup> <mo>]</mo></mrow></math> of the
    brute-force algorithm. One example of this is the KD-Tree, [implemented in Scikit-Learn](https://oreil.ly/lUFb8).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆ‘è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨è¿›è¡Œéå¸¸å¤§çš„æœ€è¿‘é‚»æœç´¢æ—¶ï¼Œæœ‰åŸºäºæ ‘çš„å’Œ/æˆ–è¿‘ä¼¼ç®—æ³•å¯ä»¥æ‰©å±•ä¸º<math alttext="script upper O left-bracket
    upper N log upper N right-bracket"><mrow><mi>ğ’ª</mi> <mo>[</mo> <mi>N</mi> <mo
    form="prefix">log</mo> <mi>N</mi> <mo>]</mo></mrow></math>æˆ–æ›´å¥½ï¼Œè€Œä¸æ˜¯ç²—æš´ç®—æ³•çš„<math alttext="script
    upper O left-bracket upper N squared right-bracket"><mrow><mi>ğ’ª</mi> <mo>[</mo>
    <msup><mi>N</mi> <mn>2</mn></msup> <mo>]</mo></mrow></math>ã€‚è¿™ç§ç®—æ³•çš„ä¸€ä¸ªä¾‹å­æ˜¯KD-Treeï¼Œ[åœ¨Scikit-Learnä¸­å®ç°](https://oreil.ly/lUFb8)ã€‚
