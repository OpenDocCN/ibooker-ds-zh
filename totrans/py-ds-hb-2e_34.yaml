- en: Chapter 30\. Customizing Colorbars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Plot legends identify discrete labels of discrete points. For continuous labels
    based on the color of points, lines, or regions, a labeled colorbar can be a great
    tool. In Matplotlib, a colorbar is drawn as a separate axes that can provide a
    key for the meaning of colors in a plot. Because the book is printed in black
    and white, this chapter has an accompanying [online supplement](https://oreil.ly/PDSH_GitHub)
    where you can view the figures in full color. We’ll start by setting up the notebook
    for plotting and importing the functions we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen several times already, the simplest colorbar can be created
    with the `plt.colorbar` function (see [Figure 30-1](#fig_0407-customizing-colorbars_files_in_output_5_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Full-color figures are available in the [supplemental materials on GitHub](https://oreil.ly/PDSH_GitHub).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll now discuss a few ideas for customizing these colorbars and using them
    effectively in various situations.
  prefs: []
  type: TYPE_NORMAL
- en: '![output 5 0](assets/output_5_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 30-1\. A simple colorbar legend
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Customizing Colorbars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The colormap can be specified using the `cmap` argument to the plotting function
    that is creating the visualization (see [Figure 30-2](#fig_0407-customizing-colorbars_files_in_output_8_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![output 8 0](assets/output_8_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 30-2\. A blue-scale colormap
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The names of available colormaps are in the `plt.cm` namespace; using IPython’s
    tab completion feature will give you a full list of built-in possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'But being *able* to choose a colormap is just the first step: more important
    is how to *decide* among the possibilities! The choice turns out to be much more
    subtle than you might initially expect.'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the Colormap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A full treatment of color choice within visualizations is beyond the scope of
    this book, but for entertaining reading on this subject and others, see the article
    [“Ten Simple Rules for Better Figures”](https://oreil.ly/g4GLV) by Nicholas Rougier,
    Michael Droettboom, and Philip Bourne. Matplotlib’s online documentation also
    has an [interesting discussion](https://oreil.ly/Ll1ir) of colormap choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Broadly, you should be aware of three different categories of colormaps:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Sequential colormaps*'
  prefs: []
  type: TYPE_NORMAL
- en: These are made up of one continuous sequence of colors (e.g., `binary` or `viridis`).
  prefs: []
  type: TYPE_NORMAL
- en: '*Divergent colormaps*'
  prefs: []
  type: TYPE_NORMAL
- en: These usually contain two distinct colors, which show positive and negative
    deviations from a mean (e.g., `RdBu` or `PuOr`).
  prefs: []
  type: TYPE_NORMAL
- en: '*Qualitative colormaps*'
  prefs: []
  type: TYPE_NORMAL
- en: These mix colors with no particular sequence (e.g., `rainbow` or `jet`).
  prefs: []
  type: TYPE_NORMAL
- en: The `jet` colormap, which was the default in Matplotlib prior to version 2.0,
    is an example of a qualitative colormap. Its status as the default was quite unfortunate,
    because qualitative maps are often a poor choice for representing quantitative
    data. Among the problems is the fact that qualitative maps usually do not display
    any uniform progression in brightness as the scale increases.
  prefs: []
  type: TYPE_NORMAL
- en: We can see this by converting the `jet` colorbar into black and white (see [Figure 30-3](#fig_0407-customizing-colorbars_files_in_output_12_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![output 12 0](assets/output_12_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 30-3\. The `jet` colormap and its uneven luminance scale
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice the bright stripes in the grayscale image. Even in full color, this uneven
    brightness means that the eye will be drawn to certain portions of the color range,
    which will potentially emphasize unimportant parts of the dataset. It’s better
    to use a colormap such as `viridis` (the default as of Matplotlib 2.0), which
    is specifically constructed to have an even brightness variation across the range;
    thus, it not only plays well with our color perception, but also will translate
    well to grayscale printing (see [Figure 30-4](#fig_0407-customizing-colorbars_files_in_output_14_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![output 14 0](assets/output_14_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 30-4\. The viridis colormap and its even luminance scale
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For other situations, such as showing positive and negative deviations from
    some mean, dual-color colorbars such as `RdBu` (*Red–Blue*) are helpful. However,
    as you can see in [Figure 30-5](#fig_0407-customizing-colorbars_files_in_output_16_0),
    it’s important to note that the positive/negative information will be lost upon
    translation to grayscale!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![output 16 0](assets/output_16_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 30-5\. The `RdBu` colormap and its luminance
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We’ll see examples of using some of these colormaps as we continue.
  prefs: []
  type: TYPE_NORMAL
- en: There are a large number of colormaps available in Matplotlib; to see a list
    of them, you can use IPython to explore the `plt.cm` submodule. For a more principled
    approach to colors in Python, you can refer to the tools and documentation within
    the Seaborn library (see [Chapter 36](ch36.xhtml#section-0414-visualization-with-seaborn)).
  prefs: []
  type: TYPE_NORMAL
- en: Color Limits and Extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Matplotlib allows for a large range of colorbar customization. The colorbar
    itself is simply an instance of `plt.Axes`, so all of the axes and tick formatting
    tricks we’ve seen so far are applicable. The colorbar has some interesting flexibility:
    for example, we can narrow the color limits and indicate the out-of-bounds values
    with a triangular arrow at the top and bottom by setting the `extend` property.
    This might come in handy, for example, if displaying an image that is subject
    to noise (see [Figure 30-6](#fig_0407-customizing-colorbars_files_in_output_19_0)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![output 19 0](assets/output_19_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 30-6\. Specifying colormap extensions^([1](ch30.xhtml#idm45858757122240))
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that in the left panel, the default color limits respond to the noisy
    pixels, and the range of the noise completely washes out the pattern we are interested
    in. In the right panel, we manually set the color limits and add extensions to
    indicate values that are above or below those limits. The result is a much more
    useful visualization of our data.
  prefs: []
  type: TYPE_NORMAL
- en: Discrete Colorbars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Colormaps are by default continuous, but sometimes you’d like to represent discrete
    values. The easiest way to do this is to use the `plt.cm.get_cmap` function and
    pass the name of a suitable colormap along with the number of desired bins (see
    [Figure 30-7](#fig_0407-customizing-colorbars_files_in_output_22_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![output 22 0](assets/output_22_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 30-7\. A discretized colormap
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The discrete version of a colormap can be used just like any other colormap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Handwritten Digits'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an example of where this can be applied, let’s look at an interesting visualization
    of some handwritten digits from the digits dataset, included in Scikit-Learn;
    it consists of nearly 2,000 <math alttext="8 times 8"><mrow><mn>8</mn> <mo>×</mo>
    <mn>8</mn></mrow></math> thumbnails showing various handwritten digits.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let’s start by downloading the digits dataset and visualizing several
    of the example images with `plt.imshow` (see [Figure 30-8](#fig_0407-customizing-colorbars_files_in_output_25_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![output 25 0](assets/output_25_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 30-8\. Sample of handwritten digits data
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Because each digit is defined by the hue of its 64 pixels, we can consider
    each digit to be a point lying in 64-dimensional space: each dimension represents
    the brightness of one pixel. Visualizing such high-dimensional data can be difficult,
    but one way to approach this task is to use a *dimensionality reduction* technique
    such as manifold learning to reduce the dimensionality of the data while maintaining
    the relationships of interest. Dimensionality reduction is an example of unsupervised
    machine learning, and we will discuss it in more detail in [Chapter 37](ch37.xhtml#section-0501-what-is-machine-learning).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deferring the discussion of these details, let’s take a look at a two-dimensional
    manifold learning projection of the digits data (see [Chapter 46](ch46.xhtml#section-0510-manifold-learning)
    for details):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use our discrete colormap to view the results, setting the `ticks` and
    `clim` to improve the aesthetics of the resulting colorbar (see [Figure 30-9](#fig_0407-customizing-colorbars_files_in_output_29_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![output 29 0](assets/output_29_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 30-9\. Manifold embedding of handwritten digit pixels
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The projection also gives us some insights on the relationships within the
    dataset: for example, the ranges of 2 and 3 nearly overlap in this projection,
    indicating that some handwritten 2s and 3s are difficult to distinguish, and may
    be more likely to be confused by an automated classification algorithm. Other
    values, like 0 and 1, are more distantly separated, and may be less likely to
    be confused.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll return to manifold learning and digit classification in [Part V](part05.xhtml#section-0500-machine-learning).
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch30.xhtml#idm45858757122240-marker)) A full-size version of this figure
    can be found on [GitHub](https://oreil.ly/PDSH_GitHub).
  prefs: []
  type: TYPE_NORMAL
