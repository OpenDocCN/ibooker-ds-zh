- en: Chapter 3\. Debugging and Profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the enhanced interactive tools discussed in the previous chapter,
    Jupyter provides a number of ways to explore and understand the code you are running,
    such as by tracking down bugs in the logic or unexpected slow execution. This
    chapter will discuss some of these tools.
  prefs: []
  type: TYPE_NORMAL
- en: Errors and Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code development and data analysis always require a bit of trial and error,
    and IPython contains tools to streamline this process. This section will briefly
    cover some options for controlling Python’s exception reporting, followed by exploring
    tools for debugging errors in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Controlling Exceptions: %xmode'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the time when a Python script fails, it will raise an exception. When
    the interpreter hits one of these exceptions, information about the cause of the
    error can be found in the *traceback*, which can be accessed from within Python.
    With the `%xmode` magic function, IPython allows you to control the amount of
    information printed when the exception is raised. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Calling `func2` results in an error, and reading the printed trace lets us see
    exactly what happened. In the default mode, this trace includes several lines
    showing the context of each step that led to the error. Using the `%xmode` magic
    function (short for *exception mode*), we can change what information is printed.
  prefs: []
  type: TYPE_NORMAL
- en: '`%xmode` takes a single argument, the mode, and there are three possibilities:
    `Plain`, `Context`, and `Verbose`. The default is `Context`, which gives output
    like that just shown. `Plain` is more compact and gives less information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Verbose` mode adds some extra information, including the arguments to
    any functions that are called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This extra information can help you narrow in on why the exception is being
    raised. So why not use the `Verbose` mode all the time? As code gets complicated,
    this kind of traceback can get extremely long. Depending on the context, sometimes
    the brevity of `Plain` or `Context` mode is easier to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debugging: When Reading Tracebacks Is Not Enough'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard Python tool for interactive debugging is `pdb`, the Python debugger.
    This debugger lets the user step through the code line by line in order to see
    what might be causing a more difficult error. The IPython-enhanced version of
    this is `ipdb`, the IPython debugger.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to launch and use both these debuggers; we won’t cover them
    fully here. Refer to the online documentation of these two utilities to learn
    more.
  prefs: []
  type: TYPE_NORMAL
- en: In IPython, perhaps the most convenient interface to debugging is the `%debug`
    magic command. If you call it after hitting an exception, it will automatically
    open an interactive debugging prompt at the point of the exception. The `ipdb`
    prompt lets you explore the current state of the stack, explore the available
    variables, and even run Python commands!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the most recent exception, then do some basic tasks. We’ll print
    the values of `a` and `b`, then type `quit` to quit the debugging session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The interactive debugger allows much more than this, though—we can even step
    up and down through the stack and explore the values of variables there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to quickly find out not only what caused the error, but what
    function calls led up to the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’d like the debugger to launch automatically whenever an exception is
    raised, you can use the `%pdb` magic function to turn on this automatic behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if you have a script that you’d like to run from the beginning in interactive
    mode, you can run it with the command `%run -d`, and use the `next` command to
    step through the lines of code interactively.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more available commands for interactive debugging than I’ve shown
    here. [Table 3-1](#table-3-1) contains a description of some of the more common
    and useful ones.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-1\. Partial list of debugging commands
  prefs: []
  type: TYPE_NORMAL
- en: '| Command | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `l(ist)` | Show the current location in the file |'
  prefs: []
  type: TYPE_TB
- en: '| `h(elp)` | Show a list of commands, or find help on a specific command |'
  prefs: []
  type: TYPE_TB
- en: '| `q(uit)` | Quit the debugger and the program |'
  prefs: []
  type: TYPE_TB
- en: '| `c(ontinue)` | Quit the debugger, continue in the program |'
  prefs: []
  type: TYPE_TB
- en: '| `n(ext)` | Go to the next step of the program |'
  prefs: []
  type: TYPE_TB
- en: '| `<enter>` | Repeat the previous command |'
  prefs: []
  type: TYPE_TB
- en: '| `p(rint)` | Print variables |'
  prefs: []
  type: TYPE_TB
- en: '| `s(tep)` | Step into a subroutine |'
  prefs: []
  type: TYPE_TB
- en: '| `r(eturn)` | Return out of a subroutine |'
  prefs: []
  type: TYPE_TB
- en: For more information, use the `help` command in the debugger, or take a look
    at `ipdb`’s [online documentation](https://oreil.ly/TVSAT).
  prefs: []
  type: TYPE_NORMAL
- en: Profiling and Timing Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the process of developing code and creating data processing pipelines, there
    are often trade-offs you can make between various implementations. Early in developing
    your algorithm, it can be counterproductive to worry about such things. As Donald
    Knuth famously quipped, “We should forget about small efficiencies, say about
    97% of the time: premature optimization is the root of all evil.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'But once you have your code working, it can be useful to dig into its efficiency
    a bit. Sometimes it’s useful to check the execution time of a given command or
    set of commands; other times it’s useful to examine a multiline process and determine
    where the bottleneck lies in some complicated series of operations. IPython provides
    access to a wide array of functionality for this kind of timing and profiling
    of code. Here we’ll discuss the following IPython magic commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%time`'
  prefs: []
  type: TYPE_NORMAL
- en: Time the execution of a single statement
  prefs: []
  type: TYPE_NORMAL
- en: '`%timeit`'
  prefs: []
  type: TYPE_NORMAL
- en: Time repeated execution of a single statement for more accuracy
  prefs: []
  type: TYPE_NORMAL
- en: '`%prun`'
  prefs: []
  type: TYPE_NORMAL
- en: Run code with the profiler
  prefs: []
  type: TYPE_NORMAL
- en: '`%lprun`'
  prefs: []
  type: TYPE_NORMAL
- en: Run code with the line-by-line profiler
  prefs: []
  type: TYPE_NORMAL
- en: '`%memit`'
  prefs: []
  type: TYPE_NORMAL
- en: Measure the memory use of a single statement
  prefs: []
  type: TYPE_NORMAL
- en: '`%mprun`'
  prefs: []
  type: TYPE_NORMAL
- en: Run code with the line-by-line memory profiler
  prefs: []
  type: TYPE_NORMAL
- en: The last four commands are not bundled with IPython; to use them, you’ll need
    to get the `line_profiler` and `memory_profiler` extensions, which we will discuss
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Timing Code Snippets: %timeit and %time'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw the `%timeit` line magic and `%%timeit` cell magic in the introduction
    to magic functions in [“IPython Magic Commands”](ch02.xhtml#section-0103-magic-commands);
    these can be used to time the repeated execution of snippets of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that because this operation is so fast, `%timeit` automatically does a
    large number of repetitions. For slower commands, `%timeit` will automatically
    adjust and perform fewer repetitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes repeating an operation is not the best option. For example, if we
    have a list that we’d like to sort, we might be misled by a repeated operation;
    sorting a pre-sorted list is much faster than sorting an unsorted list, so the
    repetition will skew the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For this, the `%time` magic function may be a better choice. It also is a good
    choice for longer-running commands, when short, system-related delays are unlikely
    to affect the result. Let’s time the sorting of an unsorted and a presorted list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice how much faster the presorted list is to sort, but notice also how much
    longer the timing takes with `%time` versus `%timeit`, even for the presorted
    list! This is a result of the fact that `%timeit` does some clever things under
    the hood to prevent system calls from interfering with the timing. For example,
    it prevents cleanup of unused Python objects (known as *garbage collection*) that
    might otherwise affect the timing. For this reason, `%timeit` results are usually
    noticeably faster than `%time` results.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `%time`, as with `%timeit`, using the `%%` cell magic syntax allows timing
    of multiline scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For more information on `%time` and `%timeit`, as well as their available options,
    use the IPython help functionality (e.g., type `%time?` at the IPython prompt).
  prefs: []
  type: TYPE_NORMAL
- en: 'Profiling Full Scripts: %prun'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A program is made up of many single statements, and sometimes timing these statements
    in context is more important than timing them on their own. Python contains a
    built-in code profiler (which you can read about in the Python documentation),
    but IPython offers a much more convenient way to use this profiler, in the form
    of the magic function `%prun`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By way of example, we’ll define a simple function that does some calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can call `%prun` with a function call to see the profiled results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The result is a table that indicates, in order of total time on each function
    call, where the execution is spending the most time. In this case, the bulk of
    the execution time is in the list comprehension inside `sum_of_lists`. From here,
    we could start thinking about what changes we might make to improve the performance
    of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on `%prun`, as well as its available options, use the IPython
    help functionality (i.e., type `%prun?` at the IPython prompt).
  prefs: []
  type: TYPE_NORMAL
- en: Line-by-Line Profiling with %lprun
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The function-by-function profiling of `%prun` is useful, but sometimes it’s
    more convenient to have a line-by-line profile report. This is not built into
    Python or IPython, but there is a `line_profiler` package available for installation
    that can do this. Start by using Python’s packaging tool, `pip`, to install the
    `line_profiler` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can use IPython to load the `line_profiler` IPython extension, offered
    as part of this package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `%lprun` command will do a line-by-line profiling of any function.
    In this case, we need to tell it explicitly which functions we’re interested in
    profiling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The information at the top gives us the key to reading the results: the time
    is reported in microseconds, and we can see where the program is spending the
    most time. At this point, we may be able to use this information to modify aspects
    of the script and make it perform better for our desired use case.'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on `%lprun`, as well as its available options, use the
    IPython help functionality (i.e., type `%lprun?` at the IPython prompt).
  prefs: []
  type: TYPE_NORMAL
- en: 'Profiling Memory Use: %memit and %mprun'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another aspect of profiling is the amount of memory an operation uses. This
    can be evaluated with another IPython extension, the `memory_profiler`. As with
    the `line_profiler`, we start by `pip`-installing the extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can use IPython to load it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The memory profiler extension contains two useful magic functions: `%memit`
    (which offers a memory-measuring equivalent of `%timeit`) and `%mprun` (which
    offers a memory-measuring equivalent of `%lprun`). The `%memit` magic function
    can be used rather simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We see that this function uses about 140 MB of memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a line-by-line description of memory use, we can use the `%mprun` magic
    function. Unfortunately, this works only for functions defined in separate modules
    rather than the notebook itself, so we’ll start by using the `%%file` cell magic
    to create a simple module called `mprun_demo.py`, which contains our `sum_of_lists`
    function, with one addition that will make our memory profiling results more clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now import the new version of this function and run the memory line
    profiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `Increment` column tells us how much each line affects the total
    memory budget: observe that when we create and delete the list `L`, we are adding
    about 30 MB of memory usage. This is on top of the background memory usage from
    the Python interpreter itself.'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on `%memit` and `%mprun`, as well as their available options,
    use the IPython help functionality (e.g., type `%memit?` at the IPython prompt).
  prefs: []
  type: TYPE_NORMAL
- en: More IPython Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this set of chapters, we’ve just scratched the surface of using IPython to
    enable data science tasks. Much more information is available both in print and
    on the web, and here I’ll list some other resources that you may find helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Web Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[The IPython website](http://ipython.org)'
  prefs: []
  type: TYPE_NORMAL
- en: The IPython website provides links to documentation, examples, tutorials, and
    a variety of other resources.
  prefs: []
  type: TYPE_NORMAL
- en: '[The nbviewer website](http://nbviewer.jupyter.org)'
  prefs: []
  type: TYPE_NORMAL
- en: This site shows static renderings of any Jupyter notebook available on the internet.
    The front page features some example notebooks that you can browse to see what
    other folks are using IPython for!
  prefs: []
  type: TYPE_NORMAL
- en: '[A curated collection of Jupyter notebooks](https://github.com/jupyter/jupyter/wiki)'
  prefs: []
  type: TYPE_NORMAL
- en: This ever-growing list of notebooks, powered by nbviewer, shows the depth and
    breadth of numerical analysis you can do with IPython. It includes everything
    from short examples and tutorials to full-blown courses and books composed in
    the notebook format!
  prefs: []
  type: TYPE_NORMAL
- en: Video tutorials
  prefs: []
  type: TYPE_NORMAL
- en: Searching the internet, you will find many video tutorials on IPython. I’d especially
    recommend seeking tutorials from the PyCon, SciPy, and PyData conferences by Fernando
    Perez and Brian Granger, two of the primary creators and maintainers of IPython
    and Jupyter.
  prefs: []
  type: TYPE_NORMAL
- en: Books
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[*Python for Data Analysis* (O’Reilly)](https://oreil.ly/ik2g7)'
  prefs: []
  type: TYPE_NORMAL
- en: Wes McKinney’s book includes a chapter that covers using IPython as a data scientist.
    Although much of the material overlaps what we’ve discussed here, another perspective
    is always helpful.
  prefs: []
  type: TYPE_NORMAL
- en: '*Learning IPython for Interactive Computing and Data Visualization* (Packt)'
  prefs: []
  type: TYPE_NORMAL
- en: This short book by Cyrille Rossant offers a good introduction to using IPython
    for data analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '*IPython Interactive Computing and Visualization Cookbook* (Packt)'
  prefs: []
  type: TYPE_NORMAL
- en: Also by Cyrille Rossant, this book is a longer and more advanced treatment of
    using IPython for data science. Despite its name, it’s not just about IPython;
    it also goes into some depth on a broad range of data science topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, a reminder that you can find help on your own: IPython’s `?`-based
    help functionality (discussed in [Chapter 1](ch01.xhtml#section-0101-help-and-documentation))
    can be useful if you use it well and use it often. As you go through the examples
    here and elsewhere, this can be used to familiarize yourself with all the tools
    that IPython has to offer.'
  prefs: []
  type: TYPE_NORMAL
