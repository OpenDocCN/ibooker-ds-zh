["```py\nIn [1]: %matplotlib inline\n        import matplotlib.pyplot as plt\n        plt.style.use('seaborn-whitegrid')\n        import numpy as np\n```", "```py\nIn [2]: def make_hello(N=1000, rseed=42):\n            # Make a plot with \"HELLO\" text; save as PNG\n            fig, ax = plt.subplots(figsize=(4, 1))\n            fig.subplots_adjust(left=0, right=1, bottom=0, top=1)\n            ax.axis('off')\n            ax.text(0.5, 0.4, 'HELLO', va='center', ha='center',\n                    weight='bold', size=85)\n            fig.savefig('hello.png')\n            plt.close(fig)\n\n            # Open this PNG and draw random points from it\n            from matplotlib.image import imread\n            data = imread('hello.png')[::-1, :, 0].T\n            rng = np.random.RandomState(rseed)\n            X = rng.rand(4 * N, 2)\n            i, j = (X * data.shape).astype(int).T\n            mask = (data[i, j] < 1)\n            X = X[mask]\n            X[:, 0] *= (data.shape[0] / data.shape[1])\n            X = X[:N]\n            return X[np.argsort(X[:, 0])]\n```", "```py\nIn [3]: X = make_hello(1000)\n        colorize = dict(c=X[:, 0], cmap=plt.cm.get_cmap('rainbow', 5))\n        plt.scatter(X[:, 0], X[:, 1], **colorize)\n        plt.axis('equal');\n```", "```py\nIn [4]: def rotate(X, angle):\n            theta = np.deg2rad(angle)\n            R = [[np.cos(theta), np.sin(theta)],\n                 [-np.sin(theta), np.cos(theta)]]\n            return np.dot(X, R)\n\n        X2 = rotate(X, 20) + 5\n        plt.scatter(X2[:, 0], X2[:, 1], **colorize)\n        plt.axis('equal');\n```", "```py\nIn [5]: from sklearn.metrics import pairwise_distances\n        D = pairwise_distances(X)\n        D.shape\nOut[5]: (1000, 1000)\n```", "```py\nIn [6]: plt.imshow(D, zorder=2, cmap='viridis', interpolation='nearest')\n        plt.colorbar();\n```", "```py\nIn [7]: D2 = pairwise_distances(X2)\n        np.allclose(D, D2)\nOut[7]: True\n```", "```py\nIn [8]: from sklearn.manifold import MDS\n        model = MDS(n_components=2, dissimilarity='precomputed', random_state=1701)\n        out = model.fit_transform(D)\n        plt.scatter(out[:, 0], out[:, 1], **colorize)\n        plt.axis('equal');\n```", "```py\nIn [9]: def random_projection(X, dimension=3, rseed=42):\n            assert dimension >= X.shape[1]\n            rng = np.random.RandomState(rseed)\n            C = rng.randn(dimension, dimension)\n            e, V = np.linalg.eigh(np.dot(C, C.T))\n            return np.dot(X, V[:X.shape[1]])\n\n        X3 = random_projection(X, 3)\n        X3.shape\nOut[9]: (1000, 3)\n```", "```py\nIn [10]: from mpl_toolkits import mplot3d\n         ax = plt.axes(projection='3d')\n         ax.scatter3D(X3[:, 0], X3[:, 1], X3[:, 2],\n                      **colorize);\n```", "```py\nIn [11]: model = MDS(n_components=2, random_state=1701)\n         out3 = model.fit_transform(X3)\n         plt.scatter(out3[:, 0], out3[:, 1], **colorize)\n         plt.axis('equal');\n```", "```py\nIn [12]: def make_hello_s_curve(X):\n             t = (X[:, 0] - 2) * 0.75 * np.pi\n             x = np.sin(t)\n             y = X[:, 1]\n             z = np.sign(t) * (np.cos(t) - 1)\n             return np.vstack((x, y, z)).T\n\n         XS = make_hello_s_curve(X)\n```", "```py\nIn [13]: from mpl_toolkits import mplot3d\n         ax = plt.axes(projection='3d')\n         ax.scatter3D(XS[:, 0], XS[:, 1], XS[:, 2],\n                      **colorize);\n```", "```py\nIn [14]: from sklearn.manifold import MDS\n         model = MDS(n_components=2, random_state=2)\n         outS = model.fit_transform(XS)\n         plt.scatter(outS[:, 0], outS[:, 1], **colorize)\n         plt.axis('equal');\n```", "```py\nIn [15]: from sklearn.manifold import LocallyLinearEmbedding\n         model = LocallyLinearEmbedding(\n             n_neighbors=100, n_components=2,\n             method='modified', eigen_solver='dense')\n         out = model.fit_transform(XS)\n\n         fig, ax = plt.subplots()\n         ax.scatter(out[:, 0], out[:, 1], **colorize)\n         ax.set_ylim(0.15, -0.15);\n```", "```py\nIn [16]: from sklearn.datasets import fetch_lfw_people\n         faces = fetch_lfw_people(min_faces_per_person=30)\n         faces.data.shape\nOut[16]: (2370, 2914)\n```", "```py\nIn [17]: fig, ax = plt.subplots(4, 8, subplot_kw=dict(xticks=[], yticks=[]))\n         for i, axi in enumerate(ax.flat):\n             axi.imshow(faces.images[i], cmap='gray')\n```", "```py\nIn [18]: from sklearn.decomposition import PCA\n         model = PCA(100, svd_solver='randomized').fit(faces.data)\n         plt.plot(np.cumsum(model.explained_variance_ratio_))\n         plt.xlabel('n components')\n         plt.ylabel('cumulative variance');\n```", "```py\nIn [19]: from sklearn.manifold import Isomap\n         model = Isomap(n_components=2)\n         proj = model.fit_transform(faces.data)\n         proj.shape\nOut[19]: (2370, 2)\n```", "```py\nIn [20]: from matplotlib import offsetbox\n\n         def plot_components(data, model, images=None, ax=None,\n                             thumb_frac=0.05, cmap='gray'):\n             ax = ax or plt.gca()\n\n             proj = model.fit_transform(data)\n             ax.plot(proj[:, 0], proj[:, 1], '.k')\n\n             if images is not None:\n                 min_dist_2 = (thumb_frac * max(proj.max(0) - proj.min(0))) ** 2\n                 shown_images = np.array([2 * proj.max(0)])\n                 for i in range(data.shape[0]):\n                     dist = np.sum((proj[i] - shown_images) ** 2, 1)\n                     if np.min(dist) < min_dist_2:\n                         # don't show points that are too close\n                         continue\n                     shown_images = np.vstack([shown_images, proj[i]])\n                     imagebox = offsetbox.AnnotationBbox(\n                         offsetbox.OffsetImage(images[i], cmap=cmap),\n                                               proj[i])\n                     ax.add_artist(imagebox)\n```", "```py\nIn [21]: fig, ax = plt.subplots(figsize=(10, 10))\n         plot_components(faces.data,\n                         model=Isomap(n_components=2),\n                         images=faces.images[:, ::2, ::2])\n```", "```py\nIn [22]: from sklearn.datasets import fetch_openml\n         mnist = fetch_openml('mnist_784')\n         mnist.data.shape\nOut[22]: (70000, 784)\n```", "```py\nIn [23]: mnist_data = np.asarray(mnist.data)\n         mnist_target = np.asarray(mnist.target, dtype=int)\n\n         fig, ax = plt.subplots(6, 8, subplot_kw=dict(xticks=[], yticks=[]))\n         for i, axi in enumerate(ax.flat):\n             axi.imshow(mnist_data[1250 * i].reshape(28, 28), cmap='gray_r')\n```", "```py\nIn [24]: # Use only 1/30 of the data: full dataset takes a long time!\n         data = mnist_data[::30]\n         target = mnist_target[::30]\n\n         model = Isomap(n_components=2)\n         proj = model.fit_transform(data)\n\n         plt.scatter(proj[:, 0], proj[:, 1], c=target,\n                                 cmap=plt.cm.get_cmap('jet', 10))\n         plt.colorbar(ticks=range(10))\n         plt.clim(-0.5, 9.5);\n```", "```py\nIn [25]: # Choose 1/4 of the \"1\" digits to project\n         data = mnist_data[mnist_target == 1][::4]\n\n         fig, ax = plt.subplots(figsize=(10, 10))\n         model = Isomap(n_neighbors=5, n_components=2, eigen_solver='dense')\n         plot_components(data, model, images=data.reshape((-1, 28, 28)),\n                         ax=ax, thumb_frac=0.05, cmap='gray_r')\n```"]