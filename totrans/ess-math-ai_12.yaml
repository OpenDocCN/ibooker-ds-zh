- en: Chapter 12\. Mathematical Logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Humans bend the rules…*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Historically in the AI field, logic based agents come before machine learning
    and neural network based agents. The reason we went over machine learning, neural
    networks, probabilistic reasoning, graph representations, and operations reseach
    before logic is that we want to tie it all into one narrative of reasoning within
    an agent, as opposed to thinking of logic as old and neural networks as modern.
    We want to view the recent advancements as enhancing the way a logical AI agent
    represents and reasons about the world. A good way to think about this is similar
    to enlightenment: An AI agent used to reason using the rigid rules of hand coded
    knowledge base and hand coded rules to make inferences and decisions, then suddenly
    it gets enlightened and becomes endowed with more reasoning tools, networks, and
    neurons that allow it to expand both its knowledge base and inference methods.
    This way, it has more expressive power and can navigate more complex and uncertain
    situations. Moreover, combining all the tools together would allow an agent the
    option to sometimes break the rules of a more rigid logic framework and employ
    a more flexible one depending on the situation, just like humans. Bending, breaking,
    and even changing the rules are distinctive human attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary meaning of the word *logic* sets the tone for this chapter and
    justifies its progression.
  prefs: []
  type: TYPE_NORMAL
- en: Logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A framework that organizes the rules and processes used for sound thinking and
    reasoning. It is a framework that lays down the principles of validity under which
    to conduct reasoning and inference.
  prefs: []
  type: TYPE_NORMAL
- en: The most important words to pay attention to in the above definition are *framework*
    and *principles for inference*. A logic system codifies within an agent the principles
    that govern reliable inference and correct proofs. Designing agents who are able
    to gather knowledge, reason logically, with a flexible logic system that accomodates
    uncertainty about the environment that they exist in, and make inferences and
    decisions based on this logical reasoning lies at the heart of artificial intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: We discuss the various systems of mathematical logic that we can program into
    an agent. The goal is to give the AI agent the ability to make inferences that
    enable it to act appropriately. These logical frameworks require knowledge bases
    to accompany the inference rules of varying sizes. They also have varying degrees
    of expressive and deductive powers.
  prefs: []
  type: TYPE_NORMAL
- en: Various Logic Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For each of the different logical frameworks (*propositional, first order,
    temporal, probabilistic, and fuzzy*) that we are about to highlight in this chapter,
    we will answer two questions about how they operate within an agent endowed with
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: What objects exist in the agent’s world? Meaning, how does the agent perceive
    the composition of its world?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the agent perceive the objects’ states? Meaning, what values can the
    agent assign to each object in its world under the particular logic framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is easy to think about this if we liken our agent to an [ant and how it
    experiences world](http://astronomy.nmsu.edu/geas/lectures/lecture28/slide03.xhtml):
    Because of the ant’s predetermined framework of perception and allowed movements,
    the ant experiences the world, along with its curvature, as two dimensional. If
    the ant gets enhanced and endowed with a more expressive framework of perception
    and allowed movements (for example wings), then it will experience the three dimensional
    world.'
  prefs: []
  type: TYPE_NORMAL
- en: Propositional Logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What objects exist in the agent’s world?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Simple or complex statements, called propositions, hence the name propositional
    logic.*'
  prefs: []
  type: TYPE_NORMAL
- en: How does the agent perceive the objects’ states?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*True (1), False (0), or unknown*. Propositional logic is also called Boolean
    logic because the objects in it can only assume two states. Paradoxes in propositional
    logic are statements that cannot classified as true or false, according the logic
    framework’s *truth table*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are examples of statements and their states:'
  prefs: []
  type: TYPE_NORMAL
- en: It is raining (can take true or false states)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Eiffel tower is in Paris (always true)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is suspicious activity in the park (can take true or false states)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This sentence is false (paradox)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I am happy *and* I am sad (always false, unless you ask my husband)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I am happy *or* I am sad (always true)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the score is 13 then the student fails (truth depends on failing thresholds,
    so we need a statement in the knowledge base that says: All students with score
    below 16 fail, and set its value at true).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1+2 is equivalent to 2+1 (always true within an agent endowed with arithmetic
    rules).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paris is romantic (in propositional logic this has to be either true or false
    but in fuzzy logic it can assume a value on a zero to one scale, for example 0.8,
    which corresponds better with the way we perceive our world, on a scale as opposed
    to absolutes. Of course I would assign the value true for this statement if I
    am programming an agent and confined to propositional logic, but someone who hates
    Paris would assign false. Oh well).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The objects in a propositional logic’s world are simple statements and complex
    statements. We can form complex statements from simple ones using five allowed
    operators: Not (negation); and; or; implies (which is the same as *if then*);
    equivalent to (which is the same as *if and only if*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have five rules to determine whether a statement is true or false:'
  prefs: []
  type: TYPE_NORMAL
- en: The negation of a statement is true if and only if the statement is false.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi> <mi>t</mi>
    <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>1</mn></msub></mrow></math>
    *and* <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi>
    <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>2</mn></msub></mrow></math>
    is true if and only if both <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi>
    <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>1</mn></msub></mrow></math> and <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi>
    <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>2</mn></msub></mrow></math> are true.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi> <mi>t</mi>
    <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>1</mn></msub></mrow></math>
    *or* <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi>
    <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>2</mn></msub></mrow></math>
    is true if and only if either <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi>
    <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>1</mn></msub></mrow></math> or <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi>
    <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>2</mn></msub></mrow></math> are true (or if both are true).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi> <mi>t</mi>
    <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>1</mn></msub></mrow></math>
    *implies* <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi>
    <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>2</mn></msub></mrow></math>
    is true except when <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi> <mi>t</mi>
    <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>1</mn></msub></mrow></math> is true and <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi>
    <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>2</mn></msub></mrow></math> is false.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi> <mi>t</mi>
    <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>1</mn></msub></mrow></math>
    *equivalent to* <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi> <mi>t</mi>
    <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>2</mn></msub></mrow></math> if and only if <math alttext="s t a t e m e n
    t 1"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi>
    <mi>n</mi> <msub><mi>t</mi> <mn>1</mn></msub></mrow></math> and <math alttext="s
    t a t e m e n t 2"><mrow><mi>s</mi> <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi>
    <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>2</mn></msub></mrow></math>
    are both true or both false.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can summarize the above rules in a *truth table* accounting for all the
    possibilities for the states of <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi>
    <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>1</mn></msub></mrow></math> and <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi>
    <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>2</mn></msub></mrow></math> and for their joining using the five allowed operators.
    In the following truth table we use <math alttext="upper S 1"><msub><mi>S</mi>
    <mn>1</mn></msub></math> for <math alttext="s t a t e m e n t 1"><mrow><mi>s</mi>
    <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>1</mn></msub></mrow></math> and <math alttext="upper S 2"><msub><mi>S</mi>
    <mn>2</mn></msub></math> for <math alttext="s t a t e m e n t 2"><mrow><mi>s</mi>
    <mi>t</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi>
    <mn>2</mn></msub></mrow></math> to save space:'
  prefs: []
  type: TYPE_NORMAL
- en: '| <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> | <math
    alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> | not <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> | <math alttext="upper S 1"><msub><mi>S</mi>
    <mn>1</mn></msub></math> and <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    | <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> or <math
    alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> | <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> implies <math alttext="upper S
    2"><msub><mi>S</mi> <mn>2</mn></msub></math> | <math alttext="upper S 1"><msub><mi>S</mi>
    <mn>1</mn></msub></math> equivalent to <math alttext="upper S 2"><msub><mi>S</mi>
    <mn>2</mn></msub></math> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| F | F | T | F | F | T | T |'
  prefs: []
  type: TYPE_TB
- en: '| F | T | T | F | T | T | F |'
  prefs: []
  type: TYPE_TB
- en: '| T | F | F | F | T | F | F |'
  prefs: []
  type: TYPE_TB
- en: '| T | T | F | T | T | T | T |'
  prefs: []
  type: TYPE_TB
- en: 'We can compute the truth of any complex statement using the above table by
    simple recursive evaluation. For example, if we are in a world where <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> is true, <math alttext="upper S
    2"><msub><mi>S</mi> <mn>2</mn></msub></math> is false, and <math alttext="upper
    S 3"><msub><mi>S</mi> <mn>3</mn></msub></math> is true, then the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '*not* <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *and*
    ( <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> *or* <math
    alttext="upper S 3"><msub><mi>S</mi> <mn>3</mn></msub></math> ) <math alttext="long
    left right double arrow"><mo>⟺</mo></math> F *and*(F *or* T) = F *and* T = F.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to reason and prove theorems using propositional logic, it is helpful
    to establish logical equivalences, meaning statements that have the exact same
    truth tables so they can replace each other in a reasoning process. The following
    are some examples of logical equivalences:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Commutativity of *and*: <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *and* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> <math
    alttext="long left right double arrow"><mo>⟺</mo></math> <math alttext="upper
    S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> *and* <math alttext="upper S 1"><msub><mi>S</mi>
    <mn>1</mn></msub></math> .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Commutativity of *or*: <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *or* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> <math
    alttext="long left right double arrow"><mo>⟺</mo></math> <math alttext="upper
    S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> *or* <math alttext="upper S 1"><msub><mi>S</mi>
    <mn>1</mn></msub></math> .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Double negation elimination: not (not <math alttext="upper S 1"><msub><mi>S</mi>
    <mn>1</mn></msub></math> ) <math alttext="long left right double arrow"><mo>⟺</mo></math>
    <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contraposition: <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *implies* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    <math alttext="long left right double arrow"><mo>⟺</mo></math> not( <math alttext="upper
    S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> ) *implies* not( <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implication elimination: <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *implies* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    <math alttext="long left right double arrow"><mo>⟺</mo></math> not( <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ) *or* <math alttext="upper S 2"><msub><mi>S</mi>
    <mn>2</mn></msub></math> .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'De Morgan’s law: not( <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *and* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> ) <math
    alttext="long left right double arrow"><mo>⟺</mo></math> not( <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ) *or* not( <math alttext="upper
    S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'De Morgan’s law: not( <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *or* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> ) <math
    alttext="long left right double arrow"><mo>⟺</mo></math> not( <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ) *and* not( <math alttext="upper
    S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s demonstrate that <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *implies* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    <math alttext="long left right double arrow"><mo>⟺</mo></math> not( <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ) *or* <math alttext="upper S 2"><msub><mi>S</mi>
    <mn>2</mn></msub></math> by showing that they have the same truth table, since
    this equivalence is not so intuitive for some people:'
  prefs: []
  type: TYPE_NORMAL
- en: '| <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> | not
    ( <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ) | <math
    alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> | not( <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ) *or* <math alttext="upper S 2"><msub><mi>S</mi>
    <mn>2</mn></msub></math> | <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *implies* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| F | T | F | T | T |'
  prefs: []
  type: TYPE_TB
- en: '| F | T | T | T | T |'
  prefs: []
  type: TYPE_TB
- en: '| T | F | T | T | T |'
  prefs: []
  type: TYPE_TB
- en: '| T | F | F | F | F |'
  prefs: []
  type: TYPE_TB
- en: 'One example that demonstrates how logical equivalences are useful is the *proof
    by contradiction* way of reasoning: To prove that the statement <math alttext="upper
    S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> implies the statement <math alttext="upper
    S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> , we can assume that we have <math
    alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> but at the same
    time we do not have <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    , then we arrive at something false or absurd, which proves that we cannot assume
    <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> without concluding
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> as well. We
    can verify the validity of this way of proving that <math alttext="upper S 1"><msub><mi>S</mi>
    <mn>1</mn></msub></math> implies <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    using propositional logic equivalences:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *implies*
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> = true <math
    alttext="long left right double arrow"><mo>⟺</mo></math>
  prefs: []
  type: TYPE_NORMAL
- en: not( <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> ) *or*
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> = true (implication
    removal) <math alttext="long left right double arrow"><mo>⟺</mo></math>
  prefs: []
  type: TYPE_NORMAL
- en: not(not( <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    ) *or* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> )=
    not(true) <math alttext="long left right double arrow"><mo>⟺</mo></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *and* not(
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> )= false (De
    Morgan and double negation).
  prefs: []
  type: TYPE_NORMAL
- en: 'We endow propositional logic framework with *rules of inference*, so that we
    are able to reason sequentially from one statement (simple or complex) to the
    next and arrive at a desired goal or at a correct proof of a statement. These
    are some of the rules of inference that accompany propositional logic:'
  prefs: []
  type: TYPE_NORMAL
- en: If <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *implies*
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> is true and
    we are given <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    , then we can infer <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *and*
    <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> is true then
    we can infer <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    . Similarly, we can also infer <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math> *is equivalent
    to* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math> then we
    can infer ( <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *implies* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    ) *and* ( <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    *implies* <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversely, if ( <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *implies* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    ) *and* ( <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    *implies* <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    ) then we can infer that ( <math alttext="upper S 1"><msub><mi>S</mi> <mn>1</mn></msub></math>
    *is equivalent to* <math alttext="upper S 2"><msub><mi>S</mi> <mn>2</mn></msub></math>
    ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We finally emphasize that propositional logic does not scale to large size environments
    and cannot efficiently capture universal relationship patterns. However, propositional
    logic provides the foundation of first order logic and higher order logic, since
    those build on top of propositional logic’s machinery.
  prefs: []
  type: TYPE_NORMAL
- en: From Few Axioms To A Whole Theory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The above inference rules are *sound*: They allow us to prove only true statements,
    in the sense that given a true statement and we can a sound inference rule with
    it, we arrive at a true statement. Therefore, the guarantee that sound inference
    rules provide is that they do not allow false statements to be inferred from true
    ones. We need slightly more than that guarantee.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A logical framework is *complete* when we are able to infer *all* possible
    true statements using only the system’s knowledge base (axioms) and its inference
    rules. The idea of *completeness* of a system is very important: In all mathematical
    systems, such as number theory, probability theory, set theory, or Euclidean geometry,
    we start with a set of axioms (Peano axioms for number theory and mathematical
    analysis, and probability axioms for probability theory) then we deduce theorems
    from these axioms using the logical rules of inference. One main question in any
    math theory is whether the axioms along with the rules of inference ensure its
    completeness and its consistency.'
  prefs: []
  type: TYPE_NORMAL
- en: '*No first-order theory, however, has the strength to uniquely describe a structure
    with an infinite domain, such as the natural numbers or the real line. Axiom systems
    that do fully describe these two structures (that is, categorical axiom systems)
    can be obtained in stronger logics such as second-order logic.*'
  prefs: []
  type: TYPE_NORMAL
- en: Codifying Logic Within An Agent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before moving on to first order logic, let’s recap what we learned in the context
    of an AI agent endowed with propositional logic. The following process is important
    and will be the same for more expressive logics:'
  prefs: []
  type: TYPE_NORMAL
- en: We program an initial knowledge base (axioms) in the form of true statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We program the inference rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The agent perceives certain statements about the current state of its world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The agent may or may not have a goal statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The agent uses the inference rules to infer new statements, and to decide what
    to do (move to the next room, open the door, set the alarm clock, *etc*.).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Completeness of the agent’s system (knowledge base together with the inference
    rules) is important here, since it allows the agent to infer *any* satisfiable
    goal statement given enough inference steps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Do Deterministic And Probabilistic Machine Learning Fit In?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The premise of machine learning (including) neural networks is that we do not
    program an initial knowledge base into the agent, and we do not program inference
    rules. What we program instead is a way to represent the input data, the desired
    outputs, and a hypothesis function that maps the input to the output. The agent
    then learns the parameters of the function using by optimizing the objective function
    (loss function). Finally the agent makes inferences on new input data using the
    function it learned. So in this context, the knowledge base and the rules can
    be separated by *during learning* or *during inference*. During learning, the
    knowledge base is the data and the hypothesis function, the goal is minimizing
    the loss, and the rules are the optimization process. After learning, the agent
    uses the learned function for inference.
  prefs: []
  type: TYPE_NORMAL
- en: We can think of probabilistic machine learning models in exactly the same way
    if we replace the deterministic hypothesis function by the joint probability distribution
    of the features of the data. Once the agent learns it, it can use it for inference.
    For example, Bayesian networks would play a similar role for uncertain knowledge
    as propositional logic for definite knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: First Order Logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What objects exist in the agent’s world?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Statements, objects, and relations among them.*'
  prefs: []
  type: TYPE_NORMAL
- en: How does the agent perceive the objects’ states?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*True (1), False (0), or unknown.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Propositional logic is great for illustrating how knowledge based agents work,
    and to explain the basic rules of a certain logic’s *language* and rules of inference.
    However, propositional logic is limited it what knowledge it can represent and
    how it can reason about it. For example, in propositional logic, the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '*All users who are older than eighteen can see this ad*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'is easy to express as an *implies* statement (which is the same as *if then*),
    since this kind of language exists in the propositional logic framework. This
    is how we can express the above statement as an inference in propositional logic:'
  prefs: []
  type: TYPE_NORMAL
- en: (User older than eighteen *implies* see the ad) *and* (User older than eighteen
    = T) then we can infer that (see the ad = T).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now think of a slightly different statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some of the users who are older than eighteen click on the ad*.'
  prefs: []
  type: TYPE_NORMAL
- en: Suddenly the language of propositional logic is not sufficient to express the
    quantity *some* in the above statement! An agent relying only on propositional
    logic will have to store the whole statement, as it is, in its knowledge base,
    then not know how to infer anything useful out of it. Meaning, suppose the agent
    gets the information that a user is indeed older than eighteen, it cannot predict
    whether the user will click on the ad or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a language (or a logical framework) that whose vocabulary includes
    *quantifiers* such as *there exist* and *for all*, so that we can write something
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '*For all* users who are older than eighteen, *there exists* a subset who clicks
    on the ad.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These two extra quantifiers are exactly what *first order logic* framework
    provides. This increase in vocabulary allows us to be more economical in what
    to store in the knowledge base, since we are able to break down the knowledge
    into objects and relations between them. For example, instead of storing:'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the users who are older than eighteen see the ad;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some of the users who are older than eighteen click on the ad;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some of the users who are older than eighteen buy the product;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some of the users who click on the ad buy the product;*'
  prefs: []
  type: TYPE_NORMAL
- en: 'as three separate statements in the knowledge base of an agent with only propositional
    logic framework (which we still don’t know how to infer anything useful from),
    we can store two statements in first order logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '*For all* users who are older than eighteen, see ad = T;'
  prefs: []
  type: TYPE_NORMAL
- en: '*For all* users with see ad =T, *there exists* a subset who clicks on the ad;'
  prefs: []
  type: TYPE_NORMAL
- en: '*For all* users who click on the ad, *there exists* a subset who buys the product.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that in both propositional and first order logics, given only the above
    statements we will not be able to infer whether a specific user who is older than
    eighteen will click on the ad or buy the product, or even the percentage of those
    doing that, but at least in first order logic we have the language to express
    the same knowledge more concisely, and in a way where we would be able to make
    some useful inferences. The most distinctive feature of first order logic from
    propositional logic is that it adds to its base language quantifiers such as *there
    exist* and *for all* on top of *not*, *and*, *or*, *implies*, and *is equivalent
    to* that already exist in propositional logic. This little addition opens the
    door to express objects separately from their descriptions and their relationships
    to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: The powerful thing about propositional and first order logics is that their
    inference rules are independent form both the domain and its knowledge base or
    set of axioms. Now in order to develop a knowledge base for a specific domain,
    such as a math field, or circuit engineering, we must study the domain carefully,
    choose the vocabulary, then formulate the set of axioms that is required to support
    the desired inferences.
  prefs: []
  type: TYPE_NORMAL
- en: Relationships between *for all* and *there exists*
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*For all* and *there exist* are connected to each other through neagtion. The
    following two statements are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: All users who are above eighteen see the ad.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There exist no one above eighteen who doesn’t see the ad.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In propositional logic language, the above two statements translate to:'
  prefs: []
  type: TYPE_NORMAL
- en: For all users such that user>18 is true, see the ad is true.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There exist no user such that user>18 and see the ad is false
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: not(There exist an x such that P is true) <math alttext="long left right double
    arrow"><mo>⟺</mo></math> For all x, P is false.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: not(for all x, P is true) <math alttext="long left right double arrow"><mo>⟺</mo></math>
    There exists an x such that P is false.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There exist an x such that P is true <math alttext="long left right double arrow"><mo>⟺</mo></math>
    not for all x P is false.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all x, P is true <math alttext="long left right double arrow"><mo>⟺</mo></math>
    There exist no x such that P is false.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We cannot leave this section without appreciating the expressive power we gained
    by moving to first order logic. This logic framework is now sufficient for such
    assertions and inferences to make sense:'
  prefs: []
  type: TYPE_NORMAL
- en: Universal approximation theorem for neural networks
  prefs: []
  type: TYPE_NORMAL
- en: 'Roughly speaking, the universal approximation theorem asserts that: *For all*
    continuous functions, *there exists* a neural network that can approximate the
    function to as closely as we wish. Note that this does not tell us how to construct
    such a network, it only asserts its existence. Still, this theorem is powerful
    enough to make us *unsurprised* about the success of neural networks in approximating
    all kinds of *input* to *output* functions in all kinds of applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Inferring relationships
  prefs: []
  type: TYPE_NORMAL
- en: 'Parents and children have inverse relationships to each other: If Sary is the
    child of Hala then Hala is the mother of Sary. Moreover, the relationship is in
    one direction: Sary cannot be the mother of Hala. In first order logic, we can
    assign two functions indicating the relationships: *mother of* and *child of*,
    variables that can be filled in by *Hala* and *Sary* or any other mother and child,
    and a relationship between the *functions* that holds for all their input variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '*For all* x,y, if mother(x,y)=T then mother(y,x)=F;'
  prefs: []
  type: TYPE_NORMAL
- en: and *for all* x,y, mother(x,y) <math alttext="long left right double arrow"><mo>⟺</mo></math>
    child(y,x).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if we equip an agent with this knowledge and tell it that Hala is the mother
    of Sary, or mother(Hala, Sary)=T, then it will be able to answer queries like:'
  prefs: []
  type: TYPE_NORMAL
- en: Is Hala the mother of Sary? T
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is Sary the mother of Hala? F
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is Sary the child of Hala? T
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is Hala the child of Sary? F
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is Laura the mother of Joseph? Unknown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we will have to store each statement separately in a propositional
    logic world which is outrageously inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: Probabilistic Logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What objects exist in the agent’s world?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Statements*'
  prefs: []
  type: TYPE_NORMAL
- en: How does the agent perceive the objects’ states?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A probability value between 0 and 1 that a statement is true.*'
  prefs: []
  type: TYPE_NORMAL
- en: Probability is the extension of first order logic that allows us to quantify
    our uncertainty about the truth of a statement. Rather than asserting whether
    a statement is true or false, we assign the degree of our belief in the truth
    of the statement a score between zero and one. Propositional and first order logics
    provide a set of inference rules that allow us to determine the truth of some
    statements given the assumption that some other statements are true. Probability
    theory provides a set of inference rules that allow us to determine how likely
    a statement is true given the likelihood of truth of other statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'This extension to dealing with uncertainty results in a more expressive framework
    than first order logic. The axioms of probability allow us to extend traditional
    logic truth tables and inference rules: For example, P(A)+P(not (A))=1: If A is
    true then P(A)=1 and P(not A)=0, which is consistent with first order logic about
    a statement and its negation.'
  prefs: []
  type: TYPE_NORMAL
- en: Viewing probability theory as a natural extension of first order logic is satisfying
    to a mind that needs to connect things together as opposed to viewing them as
    disparate things. Viewing it this way also naturally leads to Bayesian reasoning
    about data, since we update an agent’s prior distribution as we gather more knowledge
    and make better inferences. This binds all our subjects together in the most *logical*
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzy Logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What objects exist in the agent’s world? Statements with a degree of truth between
    [0,1]. . How does the agent perceive the objects’ states? A known interval value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The worlds of propositional and first order logic are black and white, true
    or false. They allow us to start with true statements and infer other true statements.
    This setting is perfect for mathematics where everything can either be right or
    wrong (true or false), or for a video game with very clear boundaries for its
    SIMS. In the real world many statements can be vague whether they are fully true
    (1) or fully false (0), meaning they exit on a *scale of truth* as opposed to
    at the edges: *Paris is romantic*; *She is happy*; *The Dark Knight movie is good*.
    *Fuzzy logic* allows this and assigns values to statements between 0 and 1 as
    opposed to strict 0 or strict 1:'
  prefs: []
  type: TYPE_NORMAL
- en: Paris is romantic (0.8); She is happy (0.6); The Dark Knight movie is good (0.9).
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we make inference in a vague world where truth comes on a sliding scale?
    It definitely is not as straightforward as inference in true and false worlds.
    For example, how true is the statement: Paris is romantic *and* she is happy given
    the above truth values? We need new rules to assign these values, and we need
    to know the context, or a domain knowledge. Another option is word vectors, which
    we discussed in [Chapter 7](ch07.xhtml#ch07). These vectors carry the meaning
    of words in different dimensions, so we can compute the cosine similarity between
    the vector representing the word Paris and the vector representing the point romantic,
    and assign that as the truth value of the statement Paris is romantic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the degree of belief in probability theory is not the same as the
    scale of truth in fuzzy logic. In probabilistic logic, the statements themselves
    are unambiguous. What we want to infer is the probability that the unambiguous
    statement is true. Probability theory does not reason about statements that are
    not entirely true or false: We do not calculate the probability that Paris is
    romantic, but we calculate the probability that a person randomly asked whether
    Paris is romantic, would answer true or false.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One interesting thing about fuzzy logic is that it kicks two principles present
    in other logics to the curb: The principle that if a statement is true then its
    negation is false, and the principle that two contradictory cannot be true at
    the same time. This actually opens the door to inconsistency and *open universe*.
    In a way fuzzy logic doesn’t attempt to correct vagueness, instead it embraces
    it and leverages it to allow functioning in a world where the boundaries are unclear.'
  prefs: []
  type: TYPE_NORMAL
- en: Temporal Logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are other types of special purpose logics, where certain objects, such
    as *time* in this section, are given special attention, having their own axioms
    and inference rules, because they are central to the knowledge that needs to be
    represented and the reasoning about it. *Temporal logic* puts time dependence
    and the axioms and inference rules about time dependence at the forefront of its
    structure, as opposed to adding statements that include time information to the
    knowledge base. In temporal logic, statements or facts are true at ceratain times,
    which could be time points or time intervals, and these times are ordered.
  prefs: []
  type: TYPE_NORMAL
- en: What objects exist in the agent’s world? Statements, objects, relations, times.
    . How does the agent perceive the objects’ states? True (1), False (0), or unknown.
  prefs: []
  type: TYPE_NORMAL
- en: 'In temporal logic, we can represent statements such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The alarm goes off when it is 7:00 a.m.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever a request is made to a server, access is eventually granted, but it
    can never be granted to two simultaneous requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison With Human Natural Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We spent the whole chapter going through logical systems that are able to express
    knowledge that humans’ natural languages seem to do effortlessly. I just wrote
    a whole book about math using only the English language, as opposed to any other
    technical language. How do we do it? How do humans represent and expand their
    knowledge base and what rules does natural language use for representation and
    reasoning that it is able to be so expressive? Moreover, the particular natural
    language used is not important: Any multi-lingual speaker knows the thought but
    not necessarily which particular language they are using to express that thought.
    There is an internal nonverbal representation for what people know or want to
    express. How does it work, and how can we unlock its secrets and give them to
    our machines?'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to human language, if we represent the same knowledge in two different
    formal logics, then we can infer the same facts (assuming the logics have completeness
    inference rules). The only difference would be which logic framework provides
    an easier route for inference.
  prefs: []
  type: TYPE_NORMAL
- en: That said, human natural language allows for ambiguity on many occasions and
    cannot make absolute mathematical assertions without the formality of mathematics
    and the formal logic it employs. I cannot ask a human who has no access to a gps
    system to predict the exact time it takes to drive from DC to NYC at on a specific
    day.
  prefs: []
  type: TYPE_NORMAL
- en: Summary And Looking Ahead
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An AI agent endowed with various types of logics can express knowledge about
    the world, reason about it, answer queries, and make inferences, that are allowed
    within the boundaries of these logics.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed various logic frameworks, including propositional logic, first
    order logic, probabilistic logic, fuzzy logic, and temporal logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next natural questions would be: What content should go into an agent’s
    knowledge base? And how to represent facts about the world? In what framework
    should knowledge be represented and inference made?'
  prefs: []
  type: TYPE_NORMAL
- en: Propositional logic?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First order logic?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hierarchical task networks for reasoning about plans?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bayesian networks for reasoning with uncertainty?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Causal diagrams and causal reasoning where an agent is allowed to selectively
    break the rules of logic?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Markov models for reasoning over time?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deep neural networks for reasoning about images, sounds, or other data?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another possible next step is to dive deeper into any of the logic frameworks
    that we disucssed, learning their inference rules and existing algorithms for
    inference, along with their strengths, weaknesses, and which kinds of knowledge
    bases they apply to. A recurring theme in these studies are investigating inference
    rules that provide a complete proof system, meaning a system where the axioms
    or the knowledge base along with the rules allow one to prove *all* possible true
    statements. Such rules include the *resolution inference rule* for propositional
    logic and the *generalized resoluton inference rule* for first order logic, which
    work for special types of knowledge bases. These are all important for theory
    (proving mathematical theorems), and technology (verifying and synthesizing) software
    and hardware. Finally, some logics are *strictly more expressive* than others,
    in the sense that some statements that we can represent in the more expressive
    logic cannot be expressed by any finite number statements using the language of
    the less expressive logic. For example, *higher order logic* (which we did not
    discuss in this chapter) is strictly more expressive than first order logic (which
    we did discuss in this chapter, and which is powerful enough to support entire
    math theories).
  prefs: []
  type: TYPE_NORMAL
