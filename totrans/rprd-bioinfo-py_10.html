<html><head></head><body><section data-pdf-bookmark="Chapter 9. Overlap Graphs: Sequence Assembly Using Shared K-mers" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch09">&#13;
<h1><span class="label">Chapter 9. </span>Overlap Graphs: Sequence Assembly <span class="keep-together">Using Shared K-mers</span></h1>&#13;
&#13;
&#13;
<p>A <em>graph</em> is a structure used to represent pairwise relationships between objects.<a data-primary="overlap graphs" data-secondary="about graphs" data-seealso="graphs in Python" data-type="indexterm" id="idm45963633141624"/><a data-primary="overlap graphs" data-secondary="about" data-type="indexterm" id="idm45963633140408"/><a data-primary="graphs in Python" data-secondary="sequence overlap graphs" data-see="overlap graphs" data-type="indexterm" id="idm45963633139464"/>&#13;
As described in <a href="https://oreil.ly/kDu52">the Rosalind GRPH challenge</a>, the goal of this exercise is to find pairs of sequences that can be joined using an overlap from the end of one sequence to the beginning of another.<a data-primary="k-mers" data-secondary="sequence assembly" data-tertiary="about" data-type="indexterm" id="idm45963633137224"/><a data-primary="sequence assembly" data-secondary="about" data-type="indexterm" id="idm45963633136008"/><a data-primary="DNA" data-secondary="sequence assembly" data-see="sequence assembly" data-type="indexterm" id="idm45963633135064"/>&#13;
The practical application of this would be to join short DNA reads into longer contiguous sequences (<em>contigs</em>) or even whole genomes.<a data-primary="contigs as contiguous sequences" data-type="indexterm" id="idm45963633133144"/>&#13;
To begin, I’ll only be concerned about joining two sequences, but a second version of the program will use a graph structure that can join any number of sequences to approximate a complete assembly.&#13;
In this implementation, the overlapping regions used to join sequences are required to be exact matches.&#13;
Real-world assemblers must allow for variation in the size and composition of the overlapping <span class="keep-together">sequences.</span></p>&#13;
&#13;
<p>You will learn:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>How to use k-mers to create overlap graphs</p>&#13;
</li>&#13;
<li>&#13;
<p>How to log runtime messages to a file</p>&#13;
</li>&#13;
<li>&#13;
<p>How to use <code>collections.defaultdict()</code></p>&#13;
</li>&#13;
<li>&#13;
<p>How to use set intersection to find common elements between collections</p>&#13;
</li>&#13;
<li>&#13;
<p>How to use <code>itertools.product()</code> to create Cartesian products of lists</p>&#13;
</li>&#13;
<li>&#13;
<p>How to use the <code>iteration_utilities.starfilter()</code> function</p>&#13;
</li>&#13;
<li>&#13;
<p>How to use Graphviz to model and visualize graph structures</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Getting Started" data-type="sect1"><div class="sect1" id="idm45963633122648">&#13;
<h1>Getting Started</h1>&#13;
&#13;
<p>The code and tests for this exercise are in the <em>09_grph</em> directory.<a data-primary="sequence assembly" data-secondary="getting started" data-type="indexterm" id="idm45963633120872"/><a data-primary="k-mers" data-secondary="sequence assembly" data-tertiary="getting started" data-type="indexterm" id="idm45963633119928"/><a data-primary="overlap graphs" data-secondary="getting started" data-type="indexterm" id="idm45963633118712"/>&#13;
Start by copying one of the solutions to the program <code>grph.py</code> and requesting the usage:</p>&#13;
&#13;
<pre data-type="programlisting">$ cd 09_grph/&#13;
$ cp solution1.py grph.py&#13;
$ ./grph.py -h&#13;
usage: grph.py [-h] [-k size] [-d] FILE&#13;
&#13;
Overlap Graphs&#13;
&#13;
positional arguments:&#13;
  FILE                  FASTA file <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO1-1" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO1-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
optional arguments:&#13;
  -h, --help            show this help message and exit&#13;
  -k size, --overlap size&#13;
                        Size of overlap (default: 3) <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO1-2" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO1-2"><img alt="2" src="assets/2.png"/></a>&#13;
  -d, --debug           Debug (default: False) <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO1-3" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO1-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO1-1" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The positional parameter is a required FASTA-formatted file of sequences.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO1-2" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The <code>-k</code> option controls the length of the overlapping strings and defaults to <code>3</code>.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO1-3" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>This is a <em>flag</em> or Boolean parameter. Its value will be <code>True</code> when the argument is present, and <code>False</code> otherwise.</p></dd>&#13;
</dl>&#13;
&#13;
<p>The sample input shown on the Rosalind page is also the content of the first sample input file:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat tests/inputs/1.fa&#13;
&gt;Rosalind_0498&#13;
AAATAAA&#13;
&gt;Rosalind_2391&#13;
AAATTTT&#13;
&gt;Rosalind_2323&#13;
TTTTCCC&#13;
&gt;Rosalind_0442&#13;
AAATCCC&#13;
&gt;Rosalind_5013&#13;
GGGTGGG</pre>&#13;
&#13;
<p>The Rosalind problem always assumes an overlapping window of three bases.&#13;
I see no reason for this parameter to be hardcoded, so my version includes a <code>k</code> parameter to indicate the size of the overlap window.&#13;
When <code>k</code> is the default value of <code>3</code>, for instance, three pairs of the sequences can be joined:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./grph.py tests/inputs/1.fa&#13;
Rosalind_2391 Rosalind_2323&#13;
Rosalind_0498 Rosalind_2391&#13;
Rosalind_0498 Rosalind_0442</pre>&#13;
&#13;
<p><a data-type="xref" href="#fig_9.1">Figure 9-1</a> shows how these sequences overlap by three common bases.</p>&#13;
&#13;
<figure><div class="figure" id="fig_9.1">&#13;
<img alt="mpfb 0901" src="assets/mpfb_0901.png"/>&#13;
<h6><span class="label">Figure 9-1. </span>Three pairs of sequences form overlap graphs when joining on 3-mers</h6>&#13;
</div></figure>&#13;
&#13;
<p>As shown in <a data-type="xref" href="#fig_9.2">Figure 9-2</a>, only one of these pairs can be joined when the overlap window increases to four bases:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./grph.py -k 4 tests/inputs/1.fa&#13;
Rosalind_2391 Rosalind_2323</pre>&#13;
&#13;
<figure><div class="figure" id="fig_9.2">&#13;
<img alt="mpfb 0902" src="assets/mpfb_0902.png"/>&#13;
<h6><span class="label">Figure 9-2. </span>Only one pair of sequences forms an overlap graph when joining on 4-mers</h6>&#13;
</div></figure>&#13;
&#13;
<p>Finally, the <code>--debug</code> option is a <em>flag</em>, which is a Boolean parameter that has a <code>True</code> value when the argument is present and <code>False</code> otherwise.<a data-primary="flags" data-secondary="--debug option" data-type="indexterm" id="idm45963633085048"/><a data-primary="debugging" data-secondary="--debug option flag" data-type="indexterm" id="idm45963633084104"/><a data-primary="overlap graphs" data-secondary="getting started" data-tertiary="debug option" data-type="indexterm" id="idm45963633083160"/><a data-primary="k-mers" data-secondary="sequence assembly" data-tertiary="debug option" data-type="indexterm" id="idm45963633081944"/><a data-primary="sequence assembly" data-secondary="getting started" data-tertiary="debug option" data-type="indexterm" id="idm45963633080728"/>&#13;
When present, this option instructs the program to print runtime logging messages to a file called <em>.log</em> in the current working directory.<a data-primary="log file of runtime messages" data-type="indexterm" id="idm45963633078808"/><a data-primary="overlap graphs" data-secondary="log file of runtime messages" data-type="indexterm" id="idm45963633078120"/><a data-primary="k-mers" data-secondary="sequence assembly" data-tertiary="log file of runtime messages" data-type="indexterm" id="idm45963633077160"/><a data-primary="sequence assembly" data-secondary="log file of runtime messages" data-type="indexterm" id="idm45963633075928"/><a data-primary="debugging" data-secondary="log file of runtime messages" data-type="indexterm" id="idm45963633074968"/>&#13;
This is not a requirement of the Rosalind challenge, but I think it’s important for you to know how to log messages.&#13;
To see it in action, run the program with the option:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./grph.py tests/inputs/1.fa --debug&#13;
Rosalind_2391 Rosalind_2323&#13;
Rosalind_0498 Rosalind_2391&#13;
Rosalind_0498 Rosalind_0442</pre>&#13;
<div data-type="note" epub:type="note">&#13;
<p>The <code>--debug</code> flag can be placed before or after the positional argument, and <code>argparse</code> will correctly interpret its meaning. Other argument parsers require that all options and flags come before positional arguments. <em>Vive la différence.</em></p>&#13;
</div>&#13;
&#13;
<p>There should now be a <em>.log</em> file with the following contents, the meaning of which will become more apparent later:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat .log&#13;
DEBUG:root:STARTS&#13;
defaultdict(&lt;class 'list'&gt;,&#13;
            {'AAA': ['Rosalind_0498', 'Rosalind_2391', 'Rosalind_0442'],&#13;
             'GGG': ['Rosalind_5013'],&#13;
             'TTT': ['Rosalind_2323']})&#13;
DEBUG:root:ENDS&#13;
defaultdict(&lt;class 'list'&gt;,&#13;
            {'AAA': ['Rosalind_0498'],&#13;
             'CCC': ['Rosalind_2323', 'Rosalind_0442'],&#13;
             'GGG': ['Rosalind_5013'],&#13;
             'TTT': ['Rosalind_2391']})</pre>&#13;
&#13;
<p>Once you understand how your program should work, start over with a new <code>grph.py</code> program:</p>&#13;
&#13;
<pre data-type="programlisting">$ new.py -fp 'Overlap Graphs' grph.py&#13;
Done, see new script "grph.py".</pre>&#13;
&#13;
<p>Here is how I define and validate the arguments:</p>&#13;
&#13;
<pre data-type="programlisting">from typing import List, NamedTuple, TextIO&#13;
&#13;
&#13;
class Args(NamedTuple): <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-1" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Command-line arguments """&#13;
    file: TextIO&#13;
    k: int&#13;
    debug: bool&#13;
&#13;
&#13;
# --------------------------------------------------&#13;
def get_args() -&gt; Args:&#13;
    """ Get command-line arguments """&#13;
&#13;
    parser = argparse.ArgumentParser(&#13;
        description='Overlap Graphs',&#13;
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)&#13;
&#13;
    parser.add_argument('file', <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-2" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-2"><img alt="2" src="assets/2.png"/></a>&#13;
                        metavar='FILE',&#13;
                        type=argparse.FileType('rt'),&#13;
                        help='FASTA file')&#13;
&#13;
    parser.add_argument('-k', <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-3" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-3"><img alt="3" src="assets/3.png"/></a>&#13;
                        '--overlap',&#13;
                        help='Size of overlap',&#13;
                        metavar='size',&#13;
                        type=int,&#13;
                        default=3)&#13;
&#13;
    parser.add_argument('-d', '--debug', help='Debug', action='store_true') <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-4" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-4"><img alt="4" src="assets/4.png"/></a>&#13;
&#13;
    args = parser.parse_args()&#13;
&#13;
    if args.overlap &lt; 1: <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-5" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-5"><img alt="5" src="assets/5.png"/></a>&#13;
        parser.error(f'-k "{args.overlap}" must be &gt; 0') <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-6" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-6"><img alt="6" src="assets/6.png"/></a>&#13;
&#13;
    return Args(args.file, args.overlap, args.debug) <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-7" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-7"><img alt="7" src="assets/7.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-1" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The <code>Args</code> class contains three fields: a <code>file</code> which is a filehandle; a <code>k</code> which should be a positive integer; and <code>debug</code>, which is a Boolean value.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-2" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Use the <code>argparse.FileType</code> to ensure this is a readable text file.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-3" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Define an integer argument that defaults to <code>3</code>.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-4" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Define a Boolean flag that will store a <code>True</code> value when present.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-5" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Check if the <code>k</code> (overlap) value is negative.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-6" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Use <code>parser.error()</code> to kill the program and generate a useful error message.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-7" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Return the validated arguments.</p></dd>&#13;
</dl>&#13;
&#13;
<p>I would like to stress how much is happening in these lines to ensure that the arguments to the program are correct.&#13;
Argument values should be validated <em>as soon as possible</em> after the program starts.<a data-primary="arguments" data-secondary="validating soon after program starts" data-type="indexterm" id="idm45963633025752"/>&#13;
I’ve encountered too many programs that, for instance, never validate a file argument and then, deep in the bowels of the program, attempt to open a nonexistent file and wind up throwing a cryptic exception that no mere mortal could debug.&#13;
If you want <em>reproducible</em> programs, the first order of business is documenting and validating all the arguments.<a data-primary="best practices" data-secondary="arguments documented and validated" data-type="indexterm" id="idm45963633023880"/><a data-primary="reproducible programs" data-secondary="arguments documented and validated" data-type="indexterm" id="idm45963633022920"/></p>&#13;
&#13;
<p>Modify your <code>main()</code> to the following:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    print(args.file.name)</pre>&#13;
&#13;
<p>Run your program with the first test input file and verify that you see this:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./grph.py tests/inputs/1.fa&#13;
tests/inputs/1.fa</pre>&#13;
&#13;
<p>Try running your program with invalid values for <code>k</code> and the file input, then run <span class="keep-together"><code><b>pytest</b></code></span> to verify that your program passes the first four tests.&#13;
The failing test expects three pairs of sequence IDs that can be joined, but the program printed the name of the input file.&#13;
Before I talk about how to create overlap graphs, I want to introduce <em>logging</em> as this can prove useful for debugging a program.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Managing Runtime Messages with STDOUT, STDERR, and Logging" data-type="sect2"><div class="sect2" id="idm45963633016232">&#13;
<h2>Managing Runtime Messages with STDOUT, STDERR, and Logging</h2>&#13;
&#13;
<p>I’ve shown how to print strings and data structures to the console.<a data-primary="k-mers" data-secondary="sequence assembly" data-tertiary="log file of runtime messages" data-type="indexterm" id="idm45963633014840"/><a data-primary="log file of runtime messages" data-type="indexterm" id="ch09-log"/><a data-primary="overlap graphs" data-secondary="log file of runtime messages" data-type="indexterm" id="ch09-log2"/><a data-primary="sequence assembly" data-secondary="log file of runtime messages" data-type="indexterm" id="ch09-log3"/><a data-primary="debugging" data-secondary="log file of runtime messages" data-type="indexterm" id="ch09-log4"/>&#13;
You just did it by printing the input filename to verify that the program is working.&#13;
Printing such messages while writing and debugging a program might be facetiously called <em>log-driven development</em>.&#13;
This is a simple and effective way to debug a program going back<a data-primary="Turing, Alan" data-type="indexterm" id="idm45963633008136"/><a data-primary="Shannon, Claude" data-type="indexterm" id="idm45963633007464"/> <span class="keep-together">decades.</span><sup><a data-type="noteref" href="ch09.html#idm45963633006072" id="idm45963633006072-marker">1</a></sup></p>&#13;
&#13;
<p>By default, <code>print()</code> will emit messages to <code>STDOUT</code> (<em>standard out</em>), which Python represents using <code>sys.stdout</code>.<a data-primary="print() function" data-secondary="STDOUT by default" data-type="indexterm" id="idm45963633002936"/><a data-primary="STDOUT (standard out)" data-secondary="print() default" data-type="indexterm" id="idm45963633001992"/><a data-primary="command line (Unix)" data-secondary="STDOUT" data-type="indexterm" id="idm45963633001048"/><a data-primary="Unix command line" data-secondary="STDOUT" data-type="indexterm" id="idm45963633000104"/><a data-primary="output from program" data-secondary="STDOUT" data-type="indexterm" id="idm45963632999160"/>&#13;
I can use the <code>print()</code> function’s <code>file</code> option to change this to <code>STDERR</code> (<em>standard error</em>) by indicating <code>sys.stderr</code>.&#13;
Consider the following Python program:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat log.py&#13;
#!/usr/bin/env python3&#13;
&#13;
import sys&#13;
&#13;
print('This is STDOUT.') <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO3-1" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO3-1"><img alt="1" src="assets/1.png"/></a>&#13;
print('This is also STDOUT.', file=sys.stdout) <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO3-2" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO3-2"><img alt="2" src="assets/2.png"/></a>&#13;
print('This is STDERR.', file=sys.stderr) <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO3-3" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO3-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO3-1" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The default <code>file</code> value is <code>STDOUT</code>.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO3-2" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>I can specify standard out using the <code>file</code> option.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO3-3" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>This will print messages to standard error.<a data-primary="STDERR (standard error)" data-type="indexterm" id="idm45963632979112"/><a data-primary="debugging" data-secondary="STDERR (standard error)" data-type="indexterm" id="idm45963632978440"/></p></dd>&#13;
</dl>&#13;
&#13;
<p>When I run this, it would appear that all output is printed to standard out:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./log.py&#13;
This is STDOUT.&#13;
This is also STDOUT.&#13;
This is STDERR.</pre>&#13;
&#13;
<p>In the <code>bash</code> shell, I can separate and capture the two streams, however, using file redirection with <code>&gt;</code>.<a data-primary="output from program" data-secondary="&gt; redirect output" data-type="indexterm" id="idm45963632974632"/><a data-primary="&gt; (redirect output)" data-primary-sortas="# redirect output" data-type="indexterm" id="idm45963632973688"/><a data-primary="file output via redirect output (&gt;)" data-type="indexterm" id="idm45963632972744"/>&#13;
Standard out can be captured using the filehandle 1 and standard error using 2.<a data-primary="filehandle" data-secondary="capturing STDOUT and STDERR" data-type="indexterm" id="idm45963632971832"/>&#13;
If you run the following command, you should see no output on the console:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./log.py 1&gt;out 2&gt;err</pre>&#13;
&#13;
<p>There should now be two new files, one called <em>out</em> with the two lines that were printed to standard out:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat out&#13;
This is STDOUT.&#13;
This is also STDOUT.</pre>&#13;
&#13;
<p>and another called <em>err</em> with the one line printed to standard error:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat err&#13;
This is STDERR.</pre>&#13;
&#13;
<p>Just knowing how to print to and capture these two filehandles may prove sufficient for your debugging efforts. However, there may be times when you want more levels of printing than two, and you may want to control where these messages are written from your code rather than by using shell redirection.&#13;
Enter <em>logging</em>, a way to control whether, when, how, and where runtime messages are printed.&#13;
The Python <code>logging</code> module handles all of this, so start by importing this module:</p>&#13;
&#13;
<pre data-type="programlisting">import logging</pre>&#13;
&#13;
<p>For this program, I’ll print debugging messages to a file called <em>.log</em> (in the current working directory) if the <code>--debug</code> flag is present.&#13;
Modify your <code>main()</code> to this:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
&#13;
    logging.basicConfig( <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-1" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-1"><img alt="1" src="assets/1.png"/></a>&#13;
        filename='.log', <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-2" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-2"><img alt="2" src="assets/2.png"/></a>&#13;
        filemode='w', <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-3" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-3"><img alt="3" src="assets/3.png"/></a>&#13;
        level=logging.DEBUG if args.debug else logging.CRITICAL) <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-4" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-4"><img alt="4" src="assets/4.png"/></a>&#13;
&#13;
    logging.debug('input file = "%s"', args.file.name) <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-5" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-5"><img alt="5" src="assets/5.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-1" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>This will <em>globally</em> affect all subsequent calls to the <code>logging</code> module’s functions.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-2" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>All output will be written to the file <em>.log</em> in the current working directory. I chose a filename starting with a dot so that it will normally be hidden from view.<a data-primary=".&lt;filename&gt; (dotfiles)" data-primary-sortas="# dotfiles" data-type="indexterm" id="idm45963632944136"/><a data-primary="dotfiles (.&lt;filename&gt;)" data-type="indexterm" id="idm45963632943192"/></p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-3" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The output file will be opened with the <code>w</code> (<em>write</em>) option, meaning it will be<a data-primary="open() function" data-secondary="write, read, append" data-tertiary="log file" data-type="indexterm" id="idm45963632938888"/> <em>overwritten</em> on each run. Use the <code>a</code> mode to <em>append</em>, but be warned that the file will grow for every run and will never be truncated or removed except by you.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-4" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>This sets the minimum logging level (see <a data-type="xref" href="#table_9.1">Table 9-1</a>). Messages at any level below the set level will be ignored.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-5" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Use the <code>logging.debug()</code> function to print a message to the log file when the logging level is set to <code>DEBUG</code> or higher.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note">&#13;
<p>In the previous example, I used the older <code>printf()</code> style of formatting for the call to <code>logging.debug()</code>. The placeholders are noted with symbols like <code>%s</code> for a string, and the values to substitute are passed as arguments. You can also use <code>str.format()</code> and f-strings for the log message, but <code>pylint</code> may suggest you use the <code>printf()</code> style.</p>&#13;
</div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45963632924456">&#13;
<h5>Dotfiles</h5>&#13;
<p>Files and directories with names starting with a dot are normally hidden when you use <strong><code>ls</code></strong>.<a data-primary=".&lt;filename&gt; (dotfiles)" data-primary-sortas="# dotfiles" data-type="indexterm" id="idm45963632922520"/><a data-primary="dotfiles (.&lt;filename&gt;)" data-type="indexterm" id="idm45963632921576"/>&#13;
You must use the <code>-a</code> option to <code>ls</code> to see <em>all</em> files.&#13;
I’m naming the log file <em>.log</em> so I won’t normally see it.&#13;
You may also notice a <em>.gitignore</em> file in this directory.&#13;
This file contains filenames and patterns of files and directories I do <em>not</em> want Git to add to my repo.&#13;
Included is the <em>.log</em> file.&#13;
Whenever you want to be sure data like configuration files, passwords, large sequence files, etc. will not be included by <strong><code>git add</code></strong>, put their names (or file globs that would match them) in this file.</p>&#13;
</div></aside>&#13;
&#13;
<p>A key concept to logging is the notion of logging levels.<a data-primary="log file of runtime messages" data-secondary="logging levels" data-type="indexterm" id="idm45963632916056"/><a data-primary="debugging" data-secondary="log file of runtime messages" data-tertiary="logging levels" data-type="indexterm" id="idm45963632915096"/><a data-primary="k-mers" data-secondary="sequence assembly" data-tertiary="log file of runtime messages" data-type="indexterm" id="idm45963632913864"/><a data-primary="overlap graphs" data-secondary="log file of runtime messages" data-tertiary="logging levels" data-type="indexterm" id="idm45963632912632"/><a data-primary="sequence assembly" data-secondary="log file of runtime messages" data-tertiary="logging levels" data-type="indexterm" id="idm45963632911400"/>&#13;
As shown in <a data-type="xref" href="#table_9.1">Table 9-1</a>, the <em>critical</em> level is the highest, and the <em>debug</em> level is the lowest (the <em>notset</em> level has certain particularities).&#13;
To learn more, I recommend you read <strong><code>help(logging)</code></strong> in the REPL or <a href="https://oreil.ly/bWgOp">the module’s online documentation</a>.<a data-primary="debugging" data-secondary="log file of runtime messages" data-tertiary="documentation" data-type="indexterm" id="idm45963631328776"/><a data-primary="log file of runtime messages" data-secondary="documentation" data-type="indexterm" id="idm45963631327544"/><a data-primary="overlap graphs" data-secondary="log file of runtime messages" data-tertiary="documentation" data-type="indexterm" id="idm45963631326584"/><a data-primary="sequence assembly" data-secondary="log file of runtime messages" data-tertiary="documentation" data-type="indexterm" id="idm45963631325352"/><a data-primary="resources" data-secondary="log file documentation" data-type="indexterm" id="idm45963631324120"/>&#13;
For this program, I’ll only use the lowest (debug) setting.&#13;
When the <code>--debug</code> flag is present, the logging level is set to <code>logging.DEBUG</code> and all messages to <code>logging.debug()</code> are printed in the log file.&#13;
When the flag is absent, the logging level is set to <code>logging.CRITICAL</code> and only messages logged with <code>logging.critical()</code> will pass through.&#13;
You might think I should use the <code>logging.NOTSET</code> value, but note that this is lower than <code>logging.DEBUG</code> and so all debug messages would pass through.</p>&#13;
<table id="table_9.1">&#13;
<caption><span class="label">Table 9-1. </span>The logging levels available in Python’s <code>logging</code> module</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Level</th>&#13;
<th>Numeric value</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>CRITICAL</p></td>&#13;
<td><p>50</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>ERROR</p></td>&#13;
<td><p>40</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>WARNING</p></td>&#13;
<td><p>30</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>INFO</p></td>&#13;
<td><p>20</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>DEBUG</p></td>&#13;
<td><p>10</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>NOTSET</p></td>&#13;
<td><p>0</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>To see this in action, run your program as follows:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./grph.py --debug tests/inputs/1.fa</pre>&#13;
&#13;
<p>It would appear the program did nothing, but there should now be a <em>.log</em> file with the following contents:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat .log&#13;
DEBUG:root:input file = "tests/inputs/1.fa"</pre>&#13;
&#13;
<p>Run the program again without the <code>--debug</code> flag, and note that the <em>.log</em> file is empty as it was overwritten when opened but no content was ever logged.&#13;
If you were to use the typical print-based debugging technique, then you’d have to find and remove (or comment out) all the <code>print()</code> statements in your program to turn off your debugging.&#13;
If, instead, you use <code>logging.debug()</code>, then you can debug your program while logging at the debug level and then deploy your program to only log critical messages.&#13;
Further, you can write the log messages to various locations depending on the environment, and all of this happens <em>programmatically</em> inside your code rather than relying on shell redirection to put log messages into the right place.</p>&#13;
&#13;
<p>There are no tests to ensure your program creates log files.&#13;
This is only to show you how to use logging.&#13;
Note that calls to functions like <code>logging.critical()</code> and <span class="keep-together"><code>logging.debug()</code></span> are controlled by the <em>global</em> scope of the <code>logging</code> module.&#13;
I don’t generally like programs to be controlled by global settings, but this is one exception I’ll make, mostly because I don’t have a choice.&#13;
I encourage you to liberally sprinkle <span class="keep-together"><code>logging.debug()</code></span> calls throughout your code to see the kinds of output you can generate.&#13;
Consider how you could use logging while writing a program on your laptop versus deploying it to a remote computing cluster to run unattended.<a data-startref="ch09-log" data-type="indexterm" id="idm45963631295992"/><a data-startref="ch09-log2" data-type="indexterm" id="idm45963631295320"/><a data-startref="ch09-log3" data-type="indexterm" id="idm45963631294648"/><a data-startref="ch09-log4" data-type="indexterm" id="idm45963631293976"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Finding Overlaps" data-type="sect2"><div class="sect2" id="idm45963631292984">&#13;
<h2>Finding Overlaps</h2>&#13;
&#13;
<p>The next order of business is to read the input FASTA file.<a data-primary="overlap graphs" data-secondary="finding overlaps" data-type="indexterm" id="idm45963631291640"/><a data-primary="k-mers" data-secondary="sequence assembly" data-tertiary="finding overlaps" data-type="indexterm" id="idm45963631290696"/><a data-primary="sequence assembly" data-secondary="finding overlaps" data-type="indexterm" id="idm45963631289480"/><a data-primary="FASTA format" data-secondary="finding sequence overlaps" data-type="indexterm" id="idm45963631288536"/><a data-primary="FASTA format" data-secondary="parsing with Bio.SeqIO" data-type="indexterm" id="idm45963631287576"/><a data-primary="Biopython library" data-secondary="Bio.SeqIO" data-tertiary="FASTA parsed" data-type="indexterm" id="idm45963631286632"/>&#13;
I first showed how to do this in <a data-type="xref" href="ch05.html#ch05">Chapter 5</a>.&#13;
Again I’ll use the <code>Bio.SeqIO</code> module for this by adding the following import:<a data-primary="Biopython library" data-secondary="Bio.Seq" data-tertiary="finding overlaps" data-type="indexterm" id="idm45963631283928"/></p>&#13;
&#13;
<pre data-type="programlisting">from Bio import SeqIO</pre>&#13;
&#13;
<p>I can modify <code>main()</code> to the following (omitting any logging calls):</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
&#13;
    for rec in SeqIO.parse(args.file, 'fasta'):&#13;
        print(rec.id, rec.seq)</pre>&#13;
&#13;
<p>And then run this on the first input file to ensure the program works properly:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./grph.py tests/inputs/1.fa&#13;
Rosalind_0498 AAATAAA&#13;
Rosalind_2391 AAATTTT&#13;
Rosalind_2323 TTTTCCC&#13;
Rosalind_0442 AAATCCC&#13;
Rosalind_5013 GGGTGGG</pre>&#13;
<div data-type="note" epub:type="note">&#13;
<p>In each exercise, I try to show how to write a program logically, step-by-step. I want you to learn to make very small changes to your program with some end goal in mind, then run your program to see the output. You should run the tests often to see what needs to be fixed, adding your own tests as you see fit. Also, consider making frequent commits of the program when it’s working well so you can revert if you end up breaking it. Taking small steps and running your program often are key elements to learning to code.</p>&#13;
</div>&#13;
&#13;
<p>Now think about how you might get the first and last <em>k</em> bases from each sequence.&#13;
Could you use the code for extracting k-mers that I first showed in <a data-type="xref" href="ch07.html#ch07">Chapter 7</a>?&#13;
For instance, try to get your program to print this:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./grph.py tests/inputs/1.fa&#13;
Rosalind_0498 AAATAAA first AAA last AAA&#13;
Rosalind_2391 AAATTTT first AAA last TTT&#13;
Rosalind_2323 TTTTCCC first TTT last CCC&#13;
Rosalind_0442 AAATCCC first AAA last CCC&#13;
Rosalind_5013 GGGTGGG first GGG last GGG</pre>&#13;
&#13;
<p>Think about which <em>first</em> strings match which <em>end</em> strings.&#13;
For instance, sequence 0498 ends with <em>AAA</em>, and sequence 0442 starts with <em>AAA</em>.&#13;
These are sequences that can be joined into an overlap graph.</p>&#13;
&#13;
<p>Change the value of <code>k</code> to <code>4</code>:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./grph.py tests/inputs/1.fa -k 4&#13;
Rosalind_0498 AAATAAA first AAAT last TAAA&#13;
Rosalind_2391 AAATTTT first AAAT last TTTT&#13;
Rosalind_2323 TTTTCCC first TTTT last TCCC&#13;
Rosalind_0442 AAATCCC first AAAT last TCCC&#13;
Rosalind_5013 GGGTGGG first GGGT last TGGG</pre>&#13;
&#13;
<p>Now you can see that only two sequences, 2391 and 2323, can be joined by their overlapping sequence <em>TTTT</em>.&#13;
Vary <code>k</code> from <code>1</code> to <code>10</code> and examine the first and last regions.&#13;
Do you have enough information to write a solution?&#13;
If not, let’s keep thinking about this.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Grouping Sequences by the Overlap" data-type="sect2"><div class="sect2" id="idm45963631266984">&#13;
<h2>Grouping Sequences by the Overlap</h2>&#13;
&#13;
<p>The <code>for</code> loop reads the sequences individually.<a data-primary="overlap graphs" data-secondary="grouping sequences by overlap" data-type="indexterm" id="ch09-ovgl"/><a data-primary="k-mers" data-secondary="sequence assembly" data-tertiary="grouping sequences by overlap" data-type="indexterm" id="ch09-ovgl2"/><a data-primary="sequence assembly" data-secondary="grouping sequences by overlap" data-type="indexterm" id="ch09-ovgl3"/>&#13;
While reading any one sequence to find the starting and ending overlap regions, I necessarily do not have enough information to say which other sequences can be joined.&#13;
I’m going to have to create some data structure to hold the overlapping regions for <em>all</em> the sequences.&#13;
Only then can I go back and figure out which ones can be joined.&#13;
This gets at a key element of sequence assemblers—most need prodigious amounts of memory to gather all the information needed from all the input sequences, of which there may be millions to billions.<a data-primary="overlap graphs" data-secondary="about sequence assemblers" data-type="indexterm" id="idm45963631260120"/><a data-primary="k-mers" data-secondary="sequence assembly" data-tertiary="about" data-type="indexterm" id="idm45963631259160"/><a data-primary="sequence assembly" data-secondary="about" data-type="indexterm" id="idm45963631257944"/></p>&#13;
&#13;
<p>I chose to use two dictionaries, one for the <em>start</em> and one for the <em>end</em> regions.&#13;
I decided the keys would be the <em>k</em>-length sequences, like <em>AAA</em> when <code>k</code> is <code>3</code>, and the values would be a list of the sequence IDs sharing this region.&#13;
I can use string slices with the value <code>k</code> to extract these leading and trailing sequences:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; k = 3&#13;
&gt;&gt;&gt; seq = 'AAATTTT'&#13;
&gt;&gt;&gt; seq[:k] <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO5-1" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO5-1"><img alt="1" src="assets/1.png"/></a>&#13;
'AAA'&#13;
&gt;&gt;&gt; seq[-k:] <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO5-2" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO5-2"><img alt="2" src="assets/2.png"/></a>&#13;
'TTT'</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO5-1" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>A slice of the first <code>k</code> bases.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO5-2" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>A slice of the last <code>k</code> bases, using negative indexing to start from the end of the sequence.</p></dd>&#13;
</dl>&#13;
&#13;
<p>These are k-mers, which I used in the last chapter.&#13;
They keep showing up, so it makes sense to write a <code>find_kmers()</code> function to extract k-mers from a sequence.&#13;
I’ll start by defining the function’s signature:</p>&#13;
&#13;
<pre data-type="programlisting">def find_kmers(seq: str, k: int) -&gt; List[str]: <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO6-1" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO6-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Find k-mers in string """&#13;
&#13;
    return [] <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO6-2" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO6-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO6-1" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The function will accept a string (the sequence) and an integer value <code>k</code> and will return a list of strings.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO6-2" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>For now, return the empty list.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Now I write a test to imagine how I’d use this function:</p>&#13;
&#13;
<pre data-type="programlisting">def test_find_kmers() -&gt; None:&#13;
    """Test find_kmers"""&#13;
&#13;
    assert find_kmers('', 1) == [] <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO7-1" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO7-1"><img alt="1" src="assets/1.png"/></a>&#13;
    assert find_kmers('ACTG', 1) == ['A', 'C', 'T', 'G'] <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO7-2" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO7-2"><img alt="2" src="assets/2.png"/></a>&#13;
    assert find_kmers('ACTG', 2) == ['AC', 'CT', 'TG']&#13;
    assert find_kmers('ACTG', 3) == ['ACT', 'CTG']&#13;
    assert find_kmers('ACTG', 4) == ['ACTG']&#13;
    assert find_kmers('ACTG', 5) == [] <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO7-3" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO7-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO7-1" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Pass the empty string as the sequence to ensure the function returns the empty list.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO7-2" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO7-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Check all the values for <code>k</code> using a short sequence.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO7-3" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO7-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>There are no 5-mers for a string of length 4.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Try writing your version before you read ahead.&#13;
Here is the function I wrote:</p>&#13;
&#13;
<pre data-type="programlisting">def find_kmers(seq: str, k: int) -&gt; List[str]:&#13;
    """Find k-mers in string"""&#13;
&#13;
    n = len(seq) - k + 1 <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO8-1" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO8-1"><img alt="1" src="assets/1.png"/></a>&#13;
    return [] if n &lt; 1 else [seq[i:i + k] for i in range(n)] <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO8-2" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO8-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO8-1" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO8-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Find the number <code>n</code> of <em>k</em>-length substrings in a string <code>seq</code>.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO8-2" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO8-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>If <code>n</code> is a negative number, return the empty list; otherwise, return the k-mers using a list comprehension.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Now I have a handy way to get the leading and trailing k-mers from a sequence:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from grph import find_kmers&#13;
&gt;&gt;&gt; kmers = find_kmers('AAATTTT', 3)&#13;
&gt;&gt;&gt; kmers&#13;
['AAA', 'AAT', 'ATT', 'TTT', 'TTT']&#13;
&gt;&gt;&gt; kmers[0] <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO9-1" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO9-1"><img alt="1" src="assets/1.png"/></a>&#13;
'AAA'&#13;
&gt;&gt;&gt; kmers[-1] <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO9-2" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO9-2"><img alt="2" src="assets/2.png"/></a>&#13;
'TTT'</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO9-1" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO9-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The first element is the leading k-mer.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO9-2" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO9-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The last element is the trailing k-mer.</p></dd>&#13;
</dl>&#13;
&#13;
<p>The first and last k-mers give me the overlap sequences I need for the keys of my dictionary.&#13;
I want the values of the dictionaries to be a list of the sequence IDs that share these k-mers.&#13;
The <code>collections.defaultdict()</code> function I introduced in <a data-type="xref" href="ch01.html#ch01">Chapter 1</a> is a good one to use for this because it allows me to easily instantiate each dictionary entry with an empty list.&#13;
I need to import it and the <code>pprint.pformat()</code> function for logging purposes, so I add the following:</p>&#13;
&#13;
<pre data-type="programlisting">from collections import defaultdict&#13;
from pprint import pformat</pre>&#13;
&#13;
<p>Here is how I can use these ideas:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
&#13;
    logging.basicConfig(&#13;
        filename='.log',&#13;
        filemode='w',&#13;
        level=logging.DEBUG if args.debug else logging.CRITICAL)&#13;
&#13;
    start, end = defaultdict(list), defaultdict(list) <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-1" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-1"><img alt="1" src="assets/1.png"/></a>&#13;
    for rec in SeqIO.parse(args.file, 'fasta'): <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-2" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-2"><img alt="2" src="assets/2.png"/></a>&#13;
        if kmers := find_kmers(str(rec.seq), args.k): <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-3" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-3"><img alt="3" src="assets/3.png"/></a>&#13;
            start[kmers[0]].append(rec.id) <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-4" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-4"><img alt="4" src="assets/4.png"/></a>&#13;
            end[kmers[-1]].append(rec.id) <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-5" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-5"><img alt="5" src="assets/5.png"/></a>&#13;
&#13;
    logging.debug(f'STARTS\n{pformat(start)}') <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-6" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-6"><img alt="6" src="assets/6.png"/></a>&#13;
    logging.debug(f'ENDS\n{pformat(end)}')</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-1" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Create dictionaries for the start and end regions that will have lists as the default values.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-2" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Iterate the FASTA records.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-3" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Coerce the <code>Seq</code> object to a string and find the k-mers. The <code>:=</code> syntax assigns the return value to <code>kmers</code>, then the <code>if</code> evaluates if <code>kmers</code> is truthy. If the function returns no kmers, then the following block will not execute.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-4" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Use the first k-mer as a key into the <code>start</code> dictionary and append this sequence ID to the list.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-5" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Do likewise for the <code>end</code> dictionary using the last k-mer.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-6" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Use the <code>pprint.pformat()</code> function to format the dictionaries for logging.</p></dd>&#13;
</dl>&#13;
&#13;
<p>I’ve used the <code>pprint.pprint()</code> function in earlier chapters to print complex data structures in a prettier format than the default <code>print()</code> function.&#13;
I can’t use <code>pprint()</code> here because it would print to <code>STDOUT</code> (or <code>STDERR</code>).&#13;
Instead, I need to format the data structure for the <code>logging.debug()</code> function to log.</p>&#13;
&#13;
<p>Now run the program again with the first input and the <code>--debug</code> flag, then inspect the log file:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./grph.py tests/inputs/1.fa -d&#13;
$ cat .log&#13;
DEBUG:root:STARTS <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-1" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-1"><img alt="1" src="assets/1.png"/></a>&#13;
defaultdict(&lt;class 'list'&gt;,&#13;
            {'AAA': ['Rosalind_0498', 'Rosalind_2391', 'Rosalind_0442'], <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-2" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-2"><img alt="2" src="assets/2.png"/></a>&#13;
             'GGG': ['Rosalind_5013'],&#13;
             'TTT': ['Rosalind_2323']})&#13;
DEBUG:root:ENDS <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-3" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-3"><img alt="3" src="assets/3.png"/></a>&#13;
defaultdict(&lt;class 'list'&gt;,&#13;
            {'AAA': ['Rosalind_0498'], <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-4" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-4"><img alt="4" src="assets/4.png"/></a>&#13;
             'CCC': ['Rosalind_2323', 'Rosalind_0442'],&#13;
             'GGG': ['Rosalind_5013'],&#13;
             'TTT': ['Rosalind_2391']})</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-1" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>A dictionary of the various starting sequences and the IDs.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-2" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Three sequences start with <em>AAA</em>: 0498, 2391, and 0442.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-3" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>A dictionary of the various ending sequences and the IDs.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-4" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>There is just one sequence ending with <em>AAA</em>, which is 0498.</p></dd>&#13;
</dl>&#13;
&#13;
<p>The correct pairs for this input file and the overlapping 3-mers are as follows:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Rosalind_0498, Rosalind_2391: <em>AAA</em></p>&#13;
</li>&#13;
<li>&#13;
<p>Rosalind_0498, Rosalind_0442: <em>AAA</em></p>&#13;
</li>&#13;
<li>&#13;
<p>Rosalind_2391, Rosalind_2323: <em>TTT</em></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>When you combine, for instance, the sequence ending with <em>AAA</em> (0498) with those starting with this sequence (0498, 2391, 0442), you wind up with the following pairs:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Rosalind_0498, Rosalind_0498</p>&#13;
</li>&#13;
<li>&#13;
<p>Rosalind_0498, Rosalind_2391</p>&#13;
</li>&#13;
<li>&#13;
<p>Rosalind_0498, Rosalind_0442</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Since I can’t join a sequence to itself, the first pair is disqualified.&#13;
Find the next <em>end</em> and <em>start</em> sequence in common, then iterate all the sequence pairs.&#13;
I’ll leave you to finish this exercise by finding all the start and end keys that are in common and then combining all the sequence IDs to print the pairs that can be joined.&#13;
The pairs can be in any order and still pass the tests.&#13;
I just want to wish you good luck.&#13;
We’re all counting on you.<a data-startref="ch09-ovgl" data-type="indexterm" id="idm45963631113864"/><a data-startref="ch09-ovgl2" data-type="indexterm" id="idm45963631113192"/><a data-startref="ch09-ovgl3" data-type="indexterm" id="idm45963631112520"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solutions" data-type="sect1"><div class="sect1" id="idm45963631111368">&#13;
<h1>Solutions</h1>&#13;
&#13;
<p>I have two variations to share with you.&#13;
The first solves the Rosalind problem to show how to combine any two sequences.&#13;
The second extends the graphs to create a full assembly of all the sequences.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 1: Using Set Intersections to Find Overlaps" data-type="sect2"><div class="sect2" id="idm45963631109736">&#13;
<h2>Solution 1: Using Set Intersections to Find Overlaps</h2>&#13;
&#13;
<p>In the following solution, I introduce how to use set intersections to find the k-mers shared between the start and end dictionaries:<a data-primary="overlap graphs" data-secondary="solution 1 set intersections" data-type="indexterm" id="ch09-sol1"/><a data-primary="k-mers" data-secondary="sequence assembly" data-tertiary="solution 1 set intersections" data-type="indexterm" id="ch09-sol12"/><a data-primary="sequence assembly" data-secondary="solution 1 set intersections" data-type="indexterm" id="ch09-sol13"/></p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
&#13;
    logging.basicConfig(&#13;
        filename='.log',&#13;
        filemode='w',&#13;
        level=logging.DEBUG if args.debug else logging.CRITICAL)&#13;
&#13;
    start, end = defaultdict(list), defaultdict(list)&#13;
    for rec in SeqIO.parse(args.file, 'fasta'):&#13;
        if kmers := find_kmers(str(rec.seq), args.k):&#13;
            start[kmers[0]].append(rec.id)&#13;
            end[kmers[-1]].append(rec.id)&#13;
&#13;
    logging.debug('STARTS\n{}'.format(pformat(start)))&#13;
    logging.debug('ENDS\n{}'.format(pformat(end)))&#13;
&#13;
    for kmer in set(start).intersection(set(end)): <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO12-1" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO12-1"><img alt="1" src="assets/1.png"/></a>&#13;
        for pair in starfilter(op.ne, product(end[kmer], start[kmer])): <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO12-2" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO12-2"><img alt="2" src="assets/2.png"/></a>&#13;
            print(*pair) <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO12-3" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO12-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO12-1" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO12-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Find the keys in common between the <code>start</code> and <code>end</code> dictionaries.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO12-2" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO12-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Iterate through the pairs of the ending and starting sequences that are not equal to each other.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO12-3" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO12-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Print the pair of sequences.</p></dd>&#13;
</dl>&#13;
&#13;
<p>The last three lines took me a few attempts to write, so let me explain how I got there.&#13;
Given these dictionaries:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from pprint import pprint&#13;
&gt;&gt;&gt; from Bio import SeqIO&#13;
&gt;&gt;&gt; from collections import defaultdict&#13;
&gt;&gt;&gt; from grph import find_kmers&#13;
&gt;&gt;&gt; k = 3&#13;
&gt;&gt;&gt; start, end = defaultdict(list), defaultdict(list)&#13;
&gt;&gt;&gt; for rec in SeqIO.parse('tests/inputs/1.fa', 'fasta'):&#13;
...     if kmers := find_kmers(str(rec.seq), k):&#13;
...         start[kmers[0]].append(rec.id)&#13;
...         end[kmers[-1]].append(rec.id)&#13;
...&#13;
&gt;&gt;&gt; pprint(start)&#13;
{'AAA': ['Rosalind_0498', 'Rosalind_2391', 'Rosalind_0442'],&#13;
 'GGG': ['Rosalind_5013'],&#13;
 'TTT': ['Rosalind_2323']}&#13;
&gt;&gt;&gt; pprint(end)&#13;
{'AAA': ['Rosalind_0498'],&#13;
 'CCC': ['Rosalind_2323', 'Rosalind_0442'],&#13;
 'GGG': ['Rosalind_5013'],</pre>&#13;
&#13;
<p>I started with this idea:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; for kmer in end: <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-1" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-1"><img alt="1" src="assets/1.png"/></a>&#13;
...     if kmer in start: <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-2" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-2"><img alt="2" src="assets/2.png"/></a>&#13;
...         for seq_id in end[kmer]: <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-3" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-3"><img alt="3" src="assets/3.png"/></a>&#13;
...             for other in start[kmer]: <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-4" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-4"><img alt="4" src="assets/4.png"/></a>&#13;
...                 if seq_id != other: <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-5" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-5"><img alt="5" src="assets/5.png"/></a>&#13;
...                     print(seq_id, other) <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-6" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-6"><img alt="6" src="assets/6.png"/></a>&#13;
...&#13;
Rosalind_0498 Rosalind_2391&#13;
Rosalind_0498 Rosalind_0442&#13;
Rosalind_2391 Rosalind_2323</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-1" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Iterate over the k-mers (which are the <em>keys</em>) of the <code>end</code> dictionary.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-2" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>See if this k-mer is in the <code>start</code> dictionary.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-3" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Iterate through each ending sequence ID for this k-mer.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-4" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Iterate through each starting sequence ID for this k-mer.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-5" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Make sure the sequences are not the same.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-6" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Print the sequence IDs.</p></dd>&#13;
</dl>&#13;
&#13;
<p>While that works just fine, I let this sit for a while and came back to it, asking myself exactly what I was trying to do.&#13;
The first two lines are trying to find the keys that are in common between the two dictionaries.&#13;
Set intersection is an easier way to achieve this.&#13;
If I use the <code>set()</code> function on a dictionary, it creates a set using the keys of the dictionary:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; set(start)&#13;
{'TTT', 'GGG', 'AAA'}&#13;
&gt;&gt;&gt; set(end)&#13;
{'TTT', 'CCC', 'AAA', 'GGG'}</pre>&#13;
&#13;
<p>I can then call the <code>set.intersection()</code> function to find the keys in common:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; set(start).intersection(set(end))&#13;
{'TTT', 'GGG', 'AAA'}</pre>&#13;
&#13;
<p>In the preceding code, the next lines find all the combinations of the ending and starting sequence IDs.&#13;
This is more easily done using the <code>itertools.product()</code> function, which will create the Cartesian product of any number of lists.<a data-primary="product() function" data-type="indexterm" id="idm45963631048936"/>&#13;
For example, consider the sequences that overlap on the k-mer <em>AAA</em>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from itertools import product&#13;
&gt;&gt;&gt; kmer = 'AAA'&#13;
&gt;&gt;&gt; pairs = list(product(end[kmer], start[kmer]))&#13;
&gt;&gt;&gt; pprint(pairs)&#13;
[('Rosalind_0498', 'Rosalind_0498'),&#13;
 ('Rosalind_0498', 'Rosalind_2391'),&#13;
 ('Rosalind_0498', 'Rosalind_0442')]</pre>&#13;
&#13;
<p class="pagebreak-before">I want to exclude any pairs where the two values are the same.&#13;
I could write a <span class="keep-together"><code>filter()</code></span> for this:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(filter(lambda p: p[0] != p[1], pairs)) <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO14-1" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO14-1"><img alt="1" src="assets/1.png"/></a>&#13;
[('Rosalind_0498', 'Rosalind_2391'), ('Rosalind_0498', 'Rosalind_0442')]</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO14-1" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO14-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The <code>lambda</code> receives the pair <code>p</code> and checks that the zeroth and first elements are not equal.</p></dd>&#13;
</dl>&#13;
&#13;
<p>This works adequately, but I’m not satisfied with the code.&#13;
I really hate that I can’t unpack the tuple values in the <code>lambda</code> to <code>filter()</code>.&#13;
Immediately I started thinking about how the <code>itertools.starmap()</code> function I used in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch06.html#ch06">6</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch08.html#ch08">8</a> can do this, so I searched the internet for <em>Python starfilter</em> and found the function <a href="https://oreil.ly/c6KKV"><code>iteration_utilities.starfilter()</code></a>.<a data-primary="starfilter() function" data-type="indexterm" id="idm45963631032040"/>&#13;
I installed this module and imported the function:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from iteration_utilities import starfilter&#13;
&gt;&gt;&gt; list(starfilter(lambda a, b: a != b, pairs))&#13;
[('Rosalind_0498', 'Rosalind_2391'), ('Rosalind_0498', 'Rosalind_0442')]</pre>&#13;
&#13;
<p>This is an improvement, but I can make it cleaner by using the <code>operator.ne()</code> (not equal) function, which will obviate the <code>lambda</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import operator as op&#13;
&gt;&gt;&gt; list(starfilter(op.ne, pairs))&#13;
[('Rosalind_0498', 'Rosalind_2391'), ('Rosalind_0498', 'Rosalind_0442')]</pre>&#13;
&#13;
<p>Finally, I splat each of the pairs to make <code>print()</code> see the individual strings rather than the list container:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; for pair in starfilter(op.ne, pairs):&#13;
...     print(*pair)&#13;
...&#13;
Rosalind_0498 Rosalind_2391&#13;
Rosalind_0498 Rosalind_0442</pre>&#13;
&#13;
<p>I could have shortened this even more, but I fear this gets a little too dense:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; print('\n'.join(map(' '.join, starfilter(op.ne, pairs))))&#13;
Rosalind_0498 Rosalind_2391&#13;
Rosalind_0498 Rosalind_0442</pre>&#13;
&#13;
<p>In the end, there’s a fair amount of code in the <code>main()</code> function that, in a larger program, I would probably move to a function with a unit test.&#13;
In this case, the integration tests cover all the functionality, so it would be overkill.<a data-startref="ch09-sol1" data-type="indexterm" id="idm45963631023816"/><a data-startref="ch09-sol12" data-type="indexterm" id="idm45963631023144"/><a data-startref="ch09-sol13" data-type="indexterm" id="idm45963631022472"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 2: Using a Graph to Find All Paths" data-type="sect2"><div class="sect2" id="idm45963631021480">&#13;
<h2>Solution 2: Using a Graph to Find All Paths</h2>&#13;
&#13;
<p>This next solution approximates a full assembly of the sequences using a graph to link all the overlapping sequences.<a data-primary="overlap graphs" data-secondary="solution 2 graph to find all paths" data-type="indexterm" id="ch09-grph"/><a data-primary="k-mers" data-secondary="sequence assembly" data-tertiary="solution 2 graphing all paths" data-type="indexterm" id="ch09-grph2"/><a data-primary="sequence assembly" data-secondary="solution 2 graph to find all paths" data-type="indexterm" id="ch09-grph3"/><a data-primary="graphs in Python" data-type="indexterm" id="ch09-grph4"/>&#13;
While not part of the original challenge, it is, nonetheless, interesting to contemplate while also proving surprisingly simple to implement and even visualize.&#13;
Since <em>GRPH</em> is the challenge name, it makes sense to investigate how to represent a graph in Python code.</p>&#13;
&#13;
<p>I can manually align all the sequences as shown in <a data-type="xref" href="#fig_9.3">Figure 9-3</a>.&#13;
This reveals a graph structure where sequence Rosalind_0498 can join to either Rosalind_2391 or <span class="keep-together">Rosalind_0442</span>, and there follows a chain from Rosalind_0498 to Rosalind_2391 to Rosalind_2323.</p>&#13;
&#13;
<figure><div class="figure" id="fig_9.3">&#13;
<img alt="mpfb 0903" src="assets/mpfb_0903.png"/>&#13;
<h6><span class="label">Figure 9-3. </span>All the sequences in the first input file can be joined using 3-mers</h6>&#13;
</div></figure>&#13;
&#13;
<p>To encode this, I use the <a href="https://graphviz.org">Graphviz tool</a> both to represent and to visualize a graph structure.<a data-primary="graphs in Python" data-secondary="Graphviz tool" data-type="indexterm" id="idm45963631008808"/><a data-primary="Graphviz graphing tool" data-type="indexterm" id="idm45963631007864"/><a data-primary="resources" data-secondary="Graphviz graphing tool" data-type="indexterm" id="idm45963631007192"/>&#13;
Note that you will need to install Graphviz on your machine for this to work.&#13;
For instance, on macOS you can use the Homebrew package manager (<strong><code>brew install graphviz</code></strong>), while on Ubuntu Linux you can use <strong><code>apt install graphviz</code></strong>.</p>&#13;
&#13;
<p>The output from Graphviz will be a text file in the <a href="https://graphviz.org/doc/info/lang.html">Dot language format</a>, which can be turned into a pictorial graph by the Graphviz <code>dot</code> tool.<a data-primary="Graphviz graphing tool" data-secondary="Dot language format" data-type="indexterm" id="idm45963631003080"/><a data-primary="resources" data-secondary="Graphviz graphing tool" data-tertiary="Dot language format" data-type="indexterm" id="idm45963631002136"/><a data-primary="Dot language format" data-type="indexterm" id="idm45963631000920"/>&#13;
The second solution in the repository has options to control the output filename and whether the image should be opened:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./solution2_graph.py -h&#13;
usage: solution2_graph.py [-h] [-k size] [-o FILE] [-v] [-d] FILE&#13;
&#13;
Overlap Graphs&#13;
&#13;
positional arguments:&#13;
  FILE                  FASTA file&#13;
&#13;
optional arguments:&#13;
  -h, --help            show this help message and exit&#13;
  -k size, --overlap size&#13;
                        Size of overlap (default: 3)&#13;
  -o FILE, --outfile FILE&#13;
                        Output filename (default: graph.txt) <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO15-1" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO15-1"><img alt="1" src="assets/1.png"/></a>&#13;
  -v, --view            View outfile (default: False) <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO15-2" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO15-2"><img alt="2" src="assets/2.png"/></a>&#13;
  -d, --debug           Debug (default: False)</pre>&#13;
<dl class="calloutlist pagebreak-before">&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO15-1" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO15-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The default output filename is <em>graph.txt</em>. A <em>.pdf</em> file will also be generated automatically, which is the visual rendition of the graph.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO15-2" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO15-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>This option controls whether the PDF should be opened automatically when the program finishes.</p></dd>&#13;
</dl>&#13;
&#13;
<p>If you run this program on the first test input, you will see the same output as before so that it will pass the test suite:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./solution2_graph.py tests/inputs/1.fa -o 1.txt&#13;
Rosalind_2391 Rosalind_2323&#13;
Rosalind_0498 Rosalind_2391&#13;
Rosalind_0498 Rosalind_0442</pre>&#13;
&#13;
<p>There should now also be a new output file called <em>1.txt</em> containing a graph structure encoded in the Dot language:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat 1.txt&#13;
digraph {&#13;
	Rosalind_0498&#13;
	Rosalind_2391&#13;
	Rosalind_0498 -&gt; Rosalind_2391&#13;
	Rosalind_0498&#13;
	Rosalind_0442&#13;
	Rosalind_0498 -&gt; Rosalind_0442&#13;
	Rosalind_2391&#13;
	Rosalind_2323&#13;
	Rosalind_2391 -&gt; Rosalind_2323&#13;
}</pre>&#13;
&#13;
<p>You can use the <code>dot</code> program to turn this into a visualization.&#13;
Here is a command to save the graph to a PNG file:</p>&#13;
&#13;
<pre data-type="programlisting">$ dot -O -Tpng 1.txt</pre>&#13;
&#13;
<p><a data-type="xref" href="#fig_9.4">Figure 9-4</a> shows the resulting visualization of the graph joining all the sequences in the first FASTA file, recapitulating the manual alignment from <a data-type="xref" href="#fig_9.3">Figure 9-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig_9.4">&#13;
<img alt="mpfb 0904" src="assets/mpfb_0904.png"/>&#13;
<h6><span class="label">Figure 9-4. </span>The output from the <code>dot</code> program showing an assembly of the sequences in the first input file when joined on 3-mers</h6>&#13;
</div></figure>&#13;
&#13;
<p>If you run the program with the <code>-v|--view</code> flag, this image should be shown automatically. In graph terminology, each sequence is a <em>node</em>, and the relationship between two sequences is an <em>edge</em>.</p>&#13;
&#13;
<p>Graphs may or may not have directionality.<a data-primary="graphs in Python" data-secondary="directionality" data-type="indexterm" id="idm45963630975592"/>&#13;
<a data-type="xref" href="#fig_9.4">Figure 9-4</a> includes arrows implying that there is a relationship that flows from one node to another; therefore, this is a <em>directed graph</em>. The following code shows how I create and visualize this graph.&#13;
Note that I import <code>graphiz.Digraph</code> to create the directed graph and that this code omits the logging code that is part of the actual solution:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    start, end = defaultdict(list), defaultdict(list)&#13;
    for rec in SeqIO.parse(args.file, 'fasta'):&#13;
        if kmers := find_kmers(str(rec.seq), args.k):&#13;
            start[kmers[0]].append(rec.id)&#13;
            end[kmers[-1]].append(rec.id)&#13;
&#13;
    dot = Digraph() <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-1" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-1"><img alt="1" src="assets/1.png"/></a>&#13;
    for kmer in set(start).intersection(set(end)): <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-2" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-2"><img alt="2" src="assets/2.png"/></a>&#13;
        for s1, s2 in starfilter(op.ne, product(end[kmer], start[kmer])): <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-3" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-3"><img alt="3" src="assets/3.png"/></a>&#13;
            print(s1, s2) <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-4" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-4"><img alt="4" src="assets/4.png"/></a>&#13;
            dot.node(s1) <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-5" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-5"><img alt="5" src="assets/5.png"/></a>&#13;
            dot.node(s2)&#13;
            dot.edge(s1, s2) <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-6" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-6"><img alt="6" src="assets/6.png"/></a>&#13;
&#13;
    args.outfile.close() <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-7" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-7"><img alt="7" src="assets/7.png"/></a>&#13;
    dot.render(args.outfile.name, view=args.view) <a class="co" href="#callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-8" id="co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-8"><img alt="8" src="assets/8.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-1" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Create a directed graph.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-2" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Iterate through the shared k-mers.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-3" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Find sequence pairs sharing a k-mer, and unpack the two sequence IDs into <code>s1</code> and <code>s2</code>.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-4" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Print the output for the test.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-5" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Add nodes for each sequence.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-6" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Add an edge connecting the nodes.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-7" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Close the output filehandle so that the graph can write to the filename.</p></dd>&#13;
<dt><a class="co" href="#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-8" id="callout_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Write the graph structure to the output filename. Use the <code>view</code> option to open the image, depending on the <code>args.view</code> option.</p></dd>&#13;
</dl>&#13;
&#13;
<p>These few lines of code have an outsized effect on the output of the program.&#13;
For instance, <a data-type="xref" href="#fig_9.5">Figure 9-5</a> shows that this program can essentially create a full assembly of the 100 sequences in the second input file.</p>&#13;
&#13;
<figure><div class="figure" id="fig_9.5">&#13;
<img alt="mpfb 0905" src="assets/mpfb_0905.png"/>&#13;
<h6><span class="label">Figure 9-5. </span>The graph of the second test input file</h6>&#13;
</div></figure>&#13;
&#13;
<p>This image (though downsized to fit on the page) speaks volumes about the complexity and completeness of the data; for instance, the sequence pair in the upper-right corner—Rosalind_1144 and Rosalind_2208—cannot be joined to any other sequences.&#13;
I would encourage you to try increasing <code>k</code> to <code>4</code> and inspecting the resulting graph to see a profoundly different result.</p>&#13;
&#13;
<p>Graphs are truly powerful data structures.&#13;
As noted in the introduction to this chapter, graphs encode pairwise relationships.&#13;
It’s amazing to see the assembly of the 100 sequences in <a data-type="xref" href="#fig_9.5">Figure 9-5</a> emerge with so few lines of code.&#13;
While it’s possible to abuse Python lists and dictionaries to represent graphs, the Graphviz tool makes this much simpler.</p>&#13;
&#13;
<p>I used a directed graph for this exercise, but that wasn’t necessarily required.&#13;
This could have been an undirected graph, too, but I like the arrows.&#13;
I would note that you might encounter the term <em>directed acyclic graph</em> (DAG) to <a data-primary="graphs in Python" data-secondary="directed acyclic graphs" data-type="indexterm" id="idm45963630923256"/><a data-primary="directed acyclic graphs (DAGs)" data-type="indexterm" id="idm45963630922312"/>indicate a directed graph that has no cycles, which is when a node joins back to itself.&#13;
Cycles might point to an incorrect assembly in the case of a linear genome but might be required for a circular genome, as in bacteria.&#13;
If you find these ideas interesting, you should investigate De Bruijn graphs, which are often built from overlapping k-mers.<a data-primary="graphs in Python" data-secondary="De Bruijn from overlapping k-mers" data-type="indexterm" id="idm45963630921128"/><a data-primary="k-mers" data-secondary="sequence assembly" data-tertiary="De Bruijn graphs from overlapping k-mers" data-type="indexterm" id="idm45963630920168"/><a data-startref="ch09-grph" data-type="indexterm" id="idm45963630918920"/><a data-startref="ch09-grph2" data-type="indexterm" id="idm45963630918248"/><a data-startref="ch09-grph3" data-type="indexterm" id="idm45963630917576"/><a data-startref="ch09-grph4" data-type="indexterm" id="idm45963630916904"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Going Further" data-type="sect1"><div class="sect1" id="idm45963630915752">&#13;
<h1>Going Further</h1>&#13;
&#13;
<p>Add a Hamming distance option that will allow the overlapping sequence to have the indicated edit distance. That is, a distance of 1 will allow for the overlap of sequences with a single base difference.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review" data-type="sect1"><div class="sect1" id="idm45963630913944">&#13;
<h1>Review</h1>&#13;
&#13;
<p>Key points from this chapter:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>To find overlapping regions, I used k-mers to find the first and last <em>k</em> bases of each sequence.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>logging</code> module makes it easy to turn on and off the logging of runtime messages to a file.</p>&#13;
</li>&#13;
<li>&#13;
<p>I used <code>defaultdict(list)</code> to create a dictionary that would auto-vivify any key not present with a default value of the empty list.</p>&#13;
</li>&#13;
<li>&#13;
<p>Set intersection can find common elements between collections, such as the keys shared between two dictionaries.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>itertools.product()</code> function found all the possible pairs of sequences.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>iteration_utilities.starfilter()</code> function will splat the argument to the <code>lambda</code> for <code>filter()</code>, just as the <code>itertools.starmap()</code> function does for <code>map()</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>The Graphviz tool can efficiently represent and visualize complex graph <span class="keep-together">structures.</span></p>&#13;
</li>&#13;
<li>&#13;
<p>Graphs can be textually represented using the Dot language, and the <code>dot</code> program can generate visualizations of graphs in various formats.</p>&#13;
</li>&#13;
<li>&#13;
<p>Overlap graphs can be used to create a complete assembly of two or more sequences.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45963633006072"><sup><a href="ch09.html#idm45963633006072-marker">1</a></sup> Imagine debugging a program without even a console. In the 1950s, Claude Shannon was visiting Alan Turing’s lab in England. During their conversation, a horn began sounding at regular intervals. Turing said this indicated his code was stuck in a loop. Without a console, this was how he monitored the progress of his programs.</p></div></div></section></body></html>