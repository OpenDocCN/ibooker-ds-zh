<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 11. Sorting Arrays" data-type="chapter" epub:type="chapter"><div class="chapter" id="section-0208-sorting">
<h1><span class="label">Chapter 11. </span>Sorting Arrays</h1>
<p><a data-primary="NumPy" data-secondary="sorting arrays" data-type="indexterm" id="ix_ch11-asciidoc0"/><a data-primary="sorting arrays" data-type="indexterm" id="ix_ch11-asciidoc1"/>Up to this point we have been concerned mainly with tools to access and
operate on array data with NumPy. <a data-primary="sorting arrays" data-secondary="basics" data-type="indexterm" id="idm45858795540448"/>This chapter covers algorithms related
to sorting values in NumPy arrays. These algorithms are a favorite topic
in introductory computer science courses: if you’ve ever
taken one, you probably have had dreams (or, depending on your
temperament, nightmares) about <em>insertion sorts</em>, <em>selection sorts</em>,
<em>merge sorts</em>, <em>quick sorts</em>, <em>bubble sorts</em>, and many, many more. All
are means of accomplishing a similar task: sorting the values in a list
or array.</p>
<p>Python has a couple of built-in functions and methods for sorting lists
and other iterable objects. The <code>sorted</code> function accepts a list and
returns a sorted version of it:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="n">L</code> <code class="o">=</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">9</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">6</code><code class="p">]</code>
        <code class="nb">sorted</code><code class="p">(</code><code class="n">L</code><code class="p">)</code>  <code class="c1"># returns a sorted copy</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">9</code><code class="p">]</code></pre>
<p>By contrast, the <code>sort</code> method of lists will sort the list in-place:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="n">L</code><code class="o">.</code><code class="n">sort</code><code class="p">()</code>  <code class="c1"># acts in-place and returns None</code>
        <code class="nb">print</code><code class="p">(</code><code class="n">L</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">9</code><code class="p">]</code></pre>
<p>Python’s sorting methods are quite flexible, and can handle
any iterable object. For example, here we sort a string:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="nb">sorted</code><code class="p">(</code><code class="s1">'python'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="p">[</code><code class="s1">'h'</code><code class="p">,</code> <code class="s1">'n'</code><code class="p">,</code> <code class="s1">'o'</code><code class="p">,</code> <code class="s1">'p'</code><code class="p">,</code> <code class="s1">'t'</code><code class="p">,</code> <code class="s1">'y'</code><code class="p">]</code></pre>
<p>These built-in sorting methods are convenient, but as previously
discussed, the dynamism of Python values means that they are less performant
than routines designed specifically for uniform arrays of numbers. This
is where NumPy’s sorting routines 
<span class="keep-together">come in.</span></p>
<section data-pdf-bookmark="Fast Sorting in NumPy: np.sort and np.argsort" data-type="sect1"><div class="sect1" id="ch_0208-sorting_fast-sorting-in-numpy-np.sort-and-np.argsort">
<h1>Fast Sorting in NumPy: np.sort and np.argsort</h1>
<p><a data-primary="np.sort() function" data-type="indexterm" id="idm45858795329712"/><a data-primary="sorting arrays" data-secondary="fast sorting with np.sort and np.argsort" data-type="indexterm" id="idm45858795360176"/>The <code>np.sort</code> function is analogous to Python’s built-in
<code>sorted</code> function, and will efficiently return a sorted copy of an
array:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>

        <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mi">2</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code>
        <code class="n">np</code><code class="o">.</code><code class="n">sort</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code></pre>
<p>Similarly to the <code>sort</code> method of Python lists, you can also sort an
array in-place using the array <code>sort</code> method:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">x</code><code class="o">.</code><code class="n">sort</code><code class="p">()</code>
        <code class="nb">print</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="p">[</code><code class="mi">1</code> <code class="mi">2</code> <code class="mi">3</code> <code class="mi">4</code> <code class="mi">5</code><code class="p">]</code></pre>
<p><a data-primary="np.argsort() function" data-type="indexterm" id="idm45858795203920"/>A related function is <code>argsort</code>, which instead returns the <em>indices</em> of
the sorted elements:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mi">2</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code>
        <code class="n">i</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">argsort</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
        <code class="nb">print</code><code class="p">(</code><code class="n">i</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="p">[</code><code class="mi">1</code> <code class="mi">0</code> <code class="mi">3</code> <code class="mi">2</code> <code class="mi">4</code><code class="p">]</code></pre>
<p>The first element of this result gives the index of the smallest
element, the second value gives the index of the second smallest, and so
on. These indices can then be used (via fancy indexing) to construct the
sorted array if desired:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">x</code><code class="p">[</code><code class="n">i</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code></pre>
<p>You’ll see an application of <code>argsort</code> later in this
chapter.</p>
</div></section>
<section data-pdf-bookmark="Sorting Along Rows or Columns" data-type="sect1"><div class="sect1" id="ch_0208-sorting_sorting-along-rows-or-columns">
<h1>Sorting Along Rows or Columns</h1>
<p><a data-primary="column(s)" data-secondary="sorting arrays along" data-type="indexterm" id="idm45858795096064"/><a data-primary="rows, sorting arrays along" data-type="indexterm" id="idm45858795078768"/><a data-primary="sorting arrays" data-secondary="along rows or columns" data-type="indexterm" id="idm45858795078160"/>A useful feature of NumPy’s sorting algorithms is the
ability to sort along specific rows or columns of a multidimensional
array using the <code>axis</code> argument. For example:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">rng</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">default_rng</code><code class="p">(</code><code class="n">seed</code><code class="o">=</code><code class="mi">42</code><code class="p">)</code>
        <code class="n">X</code> <code class="o">=</code> <code class="n">rng</code><code class="o">.</code><code class="n">integers</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="p">(</code><code class="mi">4</code><code class="p">,</code> <code class="mi">6</code><code class="p">))</code>
        <code class="nb">print</code><code class="p">(</code><code class="n">X</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="p">[[</code><code class="mi">0</code> <code class="mi">7</code> <code class="mi">6</code> <code class="mi">4</code> <code class="mi">4</code> <code class="mi">8</code><code class="p">]</code>
         <code class="p">[</code><code class="mi">0</code> <code class="mi">6</code> <code class="mi">2</code> <code class="mi">0</code> <code class="mi">5</code> <code class="mi">9</code><code class="p">]</code>
         <code class="p">[</code><code class="mi">7</code> <code class="mi">7</code> <code class="mi">7</code> <code class="mi">7</code> <code class="mi">5</code> <code class="mi">1</code><code class="p">]</code>
         <code class="p">[</code><code class="mi">8</code> <code class="mi">4</code> <code class="mi">5</code> <code class="mi">3</code> <code class="mi">1</code> <code class="mi">9</code><code class="p">]]</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="c1"># sort each column of X</code>
        <code class="n">np</code><code class="o">.</code><code class="n">sort</code><code class="p">(</code><code class="n">X</code><code class="p">,</code> <code class="n">axis</code><code class="o">=</code><code class="mi">0</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">],</code>
               <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">8</code><code class="p">],</code>
               <code class="p">[</code><code class="mi">7</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">9</code><code class="p">],</code>
               <code class="p">[</code><code class="mi">8</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">9</code><code class="p">]])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="c1"># sort each row of X</code>
         <code class="n">np</code><code class="o">.</code><code class="n">sort</code><code class="p">(</code><code class="n">X</code><code class="p">,</code> <code class="n">axis</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">8</code><code class="p">],</code>
                <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">9</code><code class="p">],</code>
                <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">7</code><code class="p">],</code>
                <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">9</code><code class="p">]])</code></pre>
<p>Keep in mind that this treats each row or column as an independent
array, and any relationships between the row or column values will be
lost!</p>
</div></section>
<section data-pdf-bookmark="Partial Sorts: Partitioning" data-type="sect1"><div class="sect1" id="ch_0208-sorting_partial-sorts-partitioning">
<h1>Partial Sorts: Partitioning</h1>
<p><a data-primary="partitioning (partial sorts)" data-type="indexterm" id="idm45858794799824"/><a data-primary="sorting arrays" data-secondary="partitioning" data-type="indexterm" id="idm45858794798960"/>Sometimes we’re not interested in sorting the entire array,
but simply want to find the <em>k</em> smallest values in the array. NumPy
enables this with the <code>np.partition</code> function. <code>np.partition</code> takes an
array and a number <em>k</em>; the result is a new array with the smallest <em>k</em>
values to the left of the partition and the remaining values to the
right:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mi">7</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">4</code><code class="p">])</code>
         <code class="n">np</code><code class="o">.</code><code class="n">partition</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="mi">3</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mi">2</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">7</code><code class="p">])</code></pre>
<p>Notice that the first three values in the resulting array are the three
smallest in the array, and the remaining array positions contain the
remaining values. Within the two partitions, the elements have arbitrary
order.</p>
<p>Similarly to sorting, we can partition along an arbitrary axis of a
multidimensional array:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">partition</code><code class="p">(</code><code class="n">X</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="n">axis</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">8</code><code class="p">],</code>
                <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">9</code><code class="p">],</code>
                <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">7</code><code class="p">],</code>
                <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">9</code><code class="p">]])</code></pre>
<p>The result is an array where the first two slots in each row contain the
smallest values from that row, with the remaining values filling the
remaining slots.</p>
<p>Finally, just as there is an <code>np.argsort</code> function that computes indices
of the sort, there is an <code>np.argpartition</code> function that computes
indices of the partition. We’ll see both of these in action
in the following section.</p>
</div></section>
<section data-pdf-bookmark="Example: k-Nearest Neighbors" data-type="sect1"><div class="sect1" id="ch_0208-sorting_example-k-nearest-neighbors">
<h1>Example: k-Nearest Neighbors</h1>
<p><a data-primary="k-nearest neighbors classifier" data-type="indexterm" id="ix_ch11-asciidoc2"/><a data-primary="sorting arrays" data-secondary="k-nearest neighbors example" data-type="indexterm" id="ix_ch11-asciidoc3"/>Let’s quickly see how we might use the <code>argsort</code> function
along multiple axes to find the nearest neighbors of each point in a
set. We’ll start by creating a random set of 10 points on a
two-dimensional plane. Using the standard convention, we’ll
arrange these in a <math alttext="10 times 2">
<mrow>
<mn>10</mn>
<mo>×</mo>
<mn>2</mn>
</mrow>
</math> array:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="n">X</code> <code class="o">=</code> <code class="n">rng</code><code class="o">.</code><code class="n">random</code><code class="p">((</code><code class="mi">10</code><code class="p">,</code> <code class="mi">2</code><code class="p">))</code></pre>
<p>To get an idea of how these points look, let’s generate a
quick scatter plot (see <a data-type="xref" href="#fig_0208-sorting_files_in_output_30_0">Figure 11-1</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="o">%</code><code class="k">matplotlib</code> inline
         <code class="kn">import</code> <code class="nn">matplotlib.pyplot</code> <code class="k">as</code> <code class="nn">plt</code>
         <code class="n">plt</code><code class="o">.</code><code class="n">style</code><code class="o">.</code><code class="n">use</code><code class="p">(</code><code class="s1">'seaborn-whitegrid'</code><code class="p">)</code>
         <code class="n">plt</code><code class="o">.</code><code class="n">scatter</code><code class="p">(</code><code class="n">X</code><code class="p">[:,</code> <code class="mi">0</code><code class="p">],</code> <code class="n">X</code><code class="p">[:,</code> <code class="mi">1</code><code class="p">],</code> <code class="n">s</code><code class="o">=</code><code class="mi">100</code><code class="p">);</code></pre>
<figure><div class="figure" id="fig_0208-sorting_files_in_output_30_0">
<img alt="output 30 0" height="377" src="assets/output_30_0.png" width="600"/>
<h6><span class="label">Figure 11-1. </span>Visualization of points in the <span class="roman">k</span>-neighbors example</h6>
</div></figure>
<p>Now we’ll compute the distance between each pair of points.
Recall that the squared distance between two points is the sum of the
squared differences in each dimension; using the efficient broadcasting
(<a data-type="xref" href="ch08.xhtml#section-0205-computation-on-arrays-broadcasting">Chapter 8</a>) and aggregation
(<a data-type="xref" href="ch07.xhtml#section-0204-computation-on-arrays-aggregates">Chapter 7</a>) routines provided by NumPy we can
compute the matrix of square distances in a single line of code:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="n">dist_sq</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">sum</code><code class="p">((</code><code class="n">X</code><code class="p">[:,</code> <code class="n">np</code><code class="o">.</code><code class="n">newaxis</code><code class="p">]</code> <code class="o">-</code> <code class="n">X</code><code class="p">[</code><code class="n">np</code><code class="o">.</code><code class="n">newaxis</code><code class="p">,</code> <code class="p">:])</code> <code class="o">**</code> <code class="mi">2</code><code class="p">,</code> <code class="n">axis</code><code class="o">=-</code><code class="mi">1</code><code class="p">)</code></pre>
<p>This operation has a lot packed into it, and it might be a bit confusing
if you’re unfamiliar with NumPy’s broadcasting
rules. When you come across code like this, it can be useful to break it
down into its component steps:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="c1"># for each pair of points, compute differences in their coordinates</code>
         <code class="n">differences</code> <code class="o">=</code> <code class="n">X</code><code class="p">[:,</code> <code class="n">np</code><code class="o">.</code><code class="n">newaxis</code><code class="p">]</code> <code class="o">-</code> <code class="n">X</code><code class="p">[</code><code class="n">np</code><code class="o">.</code><code class="n">newaxis</code><code class="p">,</code> <code class="p">:]</code>
         <code class="n">differences</code><code class="o">.</code><code class="n">shape</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="p">(</code><code class="mi">10</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="c1"># square the coordinate differences</code>
         <code class="n">sq_differences</code> <code class="o">=</code> <code class="n">differences</code> <code class="o">**</code> <code class="mi">2</code>
         <code class="n">sq_differences</code><code class="o">.</code><code class="n">shape</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="p">(</code><code class="mi">10</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">18</code><code class="p">]:</code> <code class="c1"># sum the coordinate differences to get the squared distance</code>
         <code class="n">dist_sq</code> <code class="o">=</code> <code class="n">sq_differences</code><code class="o">.</code><code class="n">sum</code><code class="p">(</code><code class="o">-</code><code class="mi">1</code><code class="p">)</code>
         <code class="n">dist_sq</code><code class="o">.</code><code class="n">shape</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">18</code><code class="p">]:</code> <code class="p">(</code><code class="mi">10</code><code class="p">,</code> <code class="mi">10</code><code class="p">)</code></pre>
<p>As a quick check of our logic, we should see that the diagonal of this
matrix (i.e., the set of distances between each point and itself) is all
zeros:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">19</code><code class="p">]:</code> <code class="n">dist_sq</code><code class="o">.</code><code class="n">diagonal</code><code class="p">()</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">19</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mf">0.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">])</code></pre>
<p>With the pairwise square distances converted, we can now use
<code>np.argsort</code> to sort along each row. The leftmost columns will then give
the indices of the nearest 
<span class="keep-together">neighbors</span>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">20</code><code class="p">]:</code> <code class="n">nearest</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">argsort</code><code class="p">(</code><code class="n">dist_sq</code><code class="p">,</code> <code class="n">axis</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code>
         <code class="nb">print</code><code class="p">(</code><code class="n">nearest</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">20</code><code class="p">]:</code> <code class="p">[[</code><code class="mi">0</code> <code class="mi">9</code> <code class="mi">3</code> <code class="mi">5</code> <code class="mi">4</code> <code class="mi">8</code> <code class="mi">1</code> <code class="mi">6</code> <code class="mi">2</code> <code class="mi">7</code><code class="p">]</code>
          <code class="p">[</code><code class="mi">1</code> <code class="mi">7</code> <code class="mi">2</code> <code class="mi">6</code> <code class="mi">4</code> <code class="mi">8</code> <code class="mi">3</code> <code class="mi">0</code> <code class="mi">9</code> <code class="mi">5</code><code class="p">]</code>
          <code class="p">[</code><code class="mi">2</code> <code class="mi">7</code> <code class="mi">1</code> <code class="mi">6</code> <code class="mi">4</code> <code class="mi">3</code> <code class="mi">8</code> <code class="mi">0</code> <code class="mi">9</code> <code class="mi">5</code><code class="p">]</code>
          <code class="p">[</code><code class="mi">3</code> <code class="mi">0</code> <code class="mi">4</code> <code class="mi">5</code> <code class="mi">9</code> <code class="mi">6</code> <code class="mi">1</code> <code class="mi">2</code> <code class="mi">8</code> <code class="mi">7</code><code class="p">]</code>
          <code class="p">[</code><code class="mi">4</code> <code class="mi">6</code> <code class="mi">3</code> <code class="mi">1</code> <code class="mi">2</code> <code class="mi">7</code> <code class="mi">0</code> <code class="mi">5</code> <code class="mi">9</code> <code class="mi">8</code><code class="p">]</code>
          <code class="p">[</code><code class="mi">5</code> <code class="mi">9</code> <code class="mi">3</code> <code class="mi">0</code> <code class="mi">4</code> <code class="mi">6</code> <code class="mi">8</code> <code class="mi">1</code> <code class="mi">2</code> <code class="mi">7</code><code class="p">]</code>
          <code class="p">[</code><code class="mi">6</code> <code class="mi">4</code> <code class="mi">2</code> <code class="mi">1</code> <code class="mi">7</code> <code class="mi">3</code> <code class="mi">0</code> <code class="mi">5</code> <code class="mi">9</code> <code class="mi">8</code><code class="p">]</code>
          <code class="p">[</code><code class="mi">7</code> <code class="mi">2</code> <code class="mi">1</code> <code class="mi">6</code> <code class="mi">4</code> <code class="mi">3</code> <code class="mi">8</code> <code class="mi">0</code> <code class="mi">9</code> <code class="mi">5</code><code class="p">]</code>
          <code class="p">[</code><code class="mi">8</code> <code class="mi">0</code> <code class="mi">1</code> <code class="mi">9</code> <code class="mi">3</code> <code class="mi">4</code> <code class="mi">7</code> <code class="mi">2</code> <code class="mi">6</code> <code class="mi">5</code><code class="p">]</code>
          <code class="p">[</code><code class="mi">9</code> <code class="mi">0</code> <code class="mi">5</code> <code class="mi">3</code> <code class="mi">4</code> <code class="mi">8</code> <code class="mi">6</code> <code class="mi">1</code> <code class="mi">2</code> <code class="mi">7</code><code class="p">]]</code></pre>
<p>Notice that the first column gives the numbers 0 through 9 in order:
this is due to the fact that each point’s closest neighbor
is itself, as we would expect.</p>
<p>By using a full sort here, we’ve actually done more work
than we need to in this case. If we’re simply interested in
the nearest <math alttext="k">
<mi>k</mi>
</math> neighbors, all we need to do is partition
each row so that the smallest <math alttext="k plus 1">
<mrow>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</math> squared distances come
first, with larger distances filling the remaining positions of the
array. We can do this with the <code>np.argpartition</code> function:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">21</code><code class="p">]:</code> <code class="n">K</code> <code class="o">=</code> <code class="mi">2</code>
         <code class="n">nearest_partition</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">argpartition</code><code class="p">(</code><code class="n">dist_sq</code><code class="p">,</code> <code class="n">K</code> <code class="o">+</code> <code class="mi">1</code><code class="p">,</code> <code class="n">axis</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code></pre>
<p>In order to visualize this network of neighbors, let’s
quickly plot the points along with lines representing the connections
from each point to its two nearest neighbors (see <a data-type="xref" href="#fig_0208-sorting_files_in_output_44_0">Figure 11-2</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">22</code><code class="p">]:</code> <code class="n">plt</code><code class="o">.</code><code class="n">scatter</code><code class="p">(</code><code class="n">X</code><code class="p">[:,</code> <code class="mi">0</code><code class="p">],</code> <code class="n">X</code><code class="p">[:,</code> <code class="mi">1</code><code class="p">],</code> <code class="n">s</code><code class="o">=</code><code class="mi">100</code><code class="p">)</code>

         <code class="c1"># draw lines from each point to its two nearest neighbors</code>
         <code class="n">K</code> <code class="o">=</code> <code class="mi">2</code>

         <code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="n">X</code><code class="o">.</code><code class="n">shape</code><code class="p">[</code><code class="mi">0</code><code class="p">]):</code>
             <code class="k">for</code> <code class="n">j</code> <code class="ow">in</code> <code class="n">nearest_partition</code><code class="p">[</code><code class="n">i</code><code class="p">,</code> <code class="p">:</code><code class="n">K</code><code class="o">+</code><code class="mi">1</code><code class="p">]:</code>
                 <code class="c1"># plot a line from X[i] to X[j]</code>
                 <code class="c1"># use some zip magic to make it happen:</code>
                 <code class="n">plt</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="o">*</code><code class="nb">zip</code><code class="p">(</code><code class="n">X</code><code class="p">[</code><code class="n">j</code><code class="p">],</code> <code class="n">X</code><code class="p">[</code><code class="n">i</code><code class="p">]),</code> <code class="n">color</code><code class="o">=</code><code class="s1">'black'</code><code class="p">)</code></pre>
<figure><div class="figure" id="fig_0208-sorting_files_in_output_44_0">
<img alt="output 44 0" height="234" src="assets/output_44_0.png" width="600"/>
<h6><span class="label">Figure 11-2. </span>Visualization of the nearest neighbors of each point</h6>
</div></figure>
<p>Each point in the plot has lines drawn to its two nearest neighbors. At
first glance, it might seem strange that some of the points have more
than two lines coming out of them: this is due to the fact that if point
A is one of the two nearest neighbors of point B, this does not
necessarily imply that point B is one of the two nearest neighbors of
point A.</p>
<p>Although the broadcasting and row-wise sorting of this approach might
seem less straightforward than writing a loop, it turns out to be a very
efficient way of operating on this data in Python. You might be tempted
to do the same type of operation by manually looping through the data
and sorting each set of neighbors individually, but this would almost
certainly lead to a slower algorithm than the vectorized version we
used. The beauty of this approach is that it’s written in a
way that’s agnostic to the size of the input data: we could
just as easily compute the neighbors among 100 or 1,000,000 points in
any number of dimensions, and the code would look the same.</p>
<p>Finally, I’ll note that when doing very large nearest
neighbor searches, there are tree-based and/or approximate algorithms
that can scale as <math alttext="script upper O left-bracket upper N log upper N right-bracket">
<mrow>
<mi>𝒪</mi>
<mo>[</mo>
<mi>N</mi>
<mo form="prefix">log</mo>
<mi>N</mi>
<mo>]</mo>
</mrow>
</math> or better rather
than the <math alttext="script upper O left-bracket upper N squared right-bracket">
<mrow>
<mi>𝒪</mi>
<mo>[</mo>
<msup><mi>N</mi> <mn>2</mn> </msup>
<mo>]</mo>
</mrow>
</math> of the brute-force algorithm.
One example of this is the KD-Tree,
<a href="https://oreil.ly/lUFb8">implemented
in Scikit-Learn</a><a data-startref="ix_ch11-asciidoc3" data-type="indexterm" id="idm45858793724256"/><a data-startref="ix_ch11-asciidoc2" data-type="indexterm" id="idm45858793723648"/>.<a data-startref="ix_ch11-asciidoc1" data-type="indexterm" id="idm45858793722912"/><a data-startref="ix_ch11-asciidoc0" data-type="indexterm" id="idm45858793722240"/></p>
</div></section>
</div></section></div></body></html>