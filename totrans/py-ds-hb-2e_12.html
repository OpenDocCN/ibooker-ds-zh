<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 10. Fancy Indexing" data-type="chapter" epub:type="chapter"><div class="chapter" id="section-0207-fancy-indexing">
<h1><span class="label">Chapter 10. </span>Fancy Indexing</h1>
<p><a data-primary="fancy indexing" data-type="indexterm" id="ix_ch10-asciidoc0"/><a data-primary="NumPy" data-secondary="fancy indexing" data-type="indexterm" id="ix_ch10-asciidoc1"/>The previous chapters discussed how to access and modify portions of
arrays using simple indices (e.g., <code>arr[0]</code>), slices (e.g., <code>arr[:5]</code>),
and Boolean masks (e.g., <code>arr[arr &gt; 0]</code>). In this chapter,
we’ll look at another style of array indexing, known as
<em>fancy</em> or <em>vectorized</em> indexing, in which we pass arrays of indices in
place of single scalars. This allows us to very quickly access and
modify complicated subsets of an array’s values.</p>
<section data-pdf-bookmark="Exploring Fancy Indexing" data-type="sect1"><div class="sect1" id="ch_0207-fancy-indexing_exploring-fancy-indexing">
<h1>Exploring Fancy Indexing</h1>
<p><a data-primary="fancy indexing" data-secondary="basics" data-type="indexterm" id="idm45858797640832"/>Fancy indexing is conceptually simple: it means passing an array of
indices to access multiple array elements at once. For example, consider
the following array:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>
        <code class="n">rng</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">default_rng</code><code class="p">(</code><code class="n">seed</code><code class="o">=</code><code class="mi">1701</code><code class="p">)</code>

        <code class="n">x</code> <code class="o">=</code> <code class="n">rng</code><code class="o">.</code><code class="n">integers</code><code class="p">(</code><code class="mi">100</code><code class="p">,</code> <code class="n">size</code><code class="o">=</code><code class="mi">10</code><code class="p">)</code>
        <code class="nb">print</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="p">[</code><code class="mi">90</code> <code class="mi">40</code>  <code class="mi">9</code> <code class="mi">30</code> <code class="mi">80</code> <code class="mi">67</code> <code class="mi">39</code> <code class="mi">15</code> <code class="mi">33</code> <code class="mi">79</code><code class="p">]</code></pre>
<p>Suppose we want to access three different elements. We could do it like
this:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="p">[</code><code class="n">x</code><code class="p">[</code><code class="mi">3</code><code class="p">],</code> <code class="n">x</code><code class="p">[</code><code class="mi">7</code><code class="p">],</code> <code class="n">x</code><code class="p">[</code><code class="mi">2</code><code class="p">]]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="p">[</code><code class="mi">30</code><code class="p">,</code> <code class="mi">15</code><code class="p">,</code> <code class="mi">9</code><code class="p">]</code></pre>
<p>Alternatively, we can pass a single list or array of indices to obtain
the same result:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="n">ind</code> <code class="o">=</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">4</code><code class="p">]</code>
        <code class="n">x</code><code class="p">[</code><code class="n">ind</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mi">30</code><code class="p">,</code> <code class="mi">15</code><code class="p">,</code> <code class="mi">80</code><code class="p">])</code></pre>
<p>When using arrays of indices, the shape of the result reflects the shape
of the <em>index arrays</em> rather than the shape of the <em>array being
indexed</em>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="n">ind</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">7</code><code class="p">],</code>
                        <code class="p">[</code><code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">]])</code>
        <code class="n">x</code><code class="p">[</code><code class="n">ind</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mi">30</code><code class="p">,</code> <code class="mi">15</code><code class="p">],</code>
               <code class="p">[</code><code class="mi">80</code><code class="p">,</code> <code class="mi">67</code><code class="p">]])</code></pre>
<p>Fancy indexing also works in multiple dimensions. Consider the following
array:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">X</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">12</code><code class="p">)</code><code class="o">.</code><code class="n">reshape</code><code class="p">((</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">))</code>
        <code class="n">X</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code> <code class="mi">0</code><code class="p">,</code>  <code class="mi">1</code><code class="p">,</code>  <code class="mi">2</code><code class="p">,</code>  <code class="mi">3</code><code class="p">],</code>
               <code class="p">[</code> <code class="mi">4</code><code class="p">,</code>  <code class="mi">5</code><code class="p">,</code>  <code class="mi">6</code><code class="p">,</code>  <code class="mi">7</code><code class="p">],</code>
               <code class="p">[</code> <code class="mi">8</code><code class="p">,</code>  <code class="mi">9</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">11</code><code class="p">]])</code></pre>
<p>Like with standard indexing, the first index refers to the row, and the
second to the column:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">row</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">])</code>
        <code class="n">col</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mi">2</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code>
        <code class="n">X</code><code class="p">[</code><code class="n">row</code><code class="p">,</code> <code class="n">col</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code> <code class="mi">2</code><code class="p">,</code>  <code class="mi">5</code><code class="p">,</code> <code class="mi">11</code><code class="p">])</code></pre>
<p>Notice that the first value in the result is <code>X[0, 2]</code>, the second is
<code>X[1, 1]</code>, and the third is <code>X[2, 3]</code>. The pairing of indices in fancy
indexing follows all the broadcasting rules that were mentioned in
<a data-type="xref" href="ch08.xhtml#section-0205-computation-on-arrays-broadcasting">Chapter 8</a>. So, for example, if we combine a column vector
and a row vector within the indices, we get a two-dimensional result:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">X</code><code class="p">[</code><code class="n">row</code><code class="p">[:,</code> <code class="n">np</code><code class="o">.</code><code class="n">newaxis</code><code class="p">],</code> <code class="n">col</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code> <code class="mi">2</code><code class="p">,</code>  <code class="mi">1</code><code class="p">,</code>  <code class="mi">3</code><code class="p">],</code>
               <code class="p">[</code> <code class="mi">6</code><code class="p">,</code>  <code class="mi">5</code><code class="p">,</code>  <code class="mi">7</code><code class="p">],</code>
               <code class="p">[</code><code class="mi">10</code><code class="p">,</code>  <code class="mi">9</code><code class="p">,</code> <code class="mi">11</code><code class="p">]])</code></pre>
<p>Here, each row value is matched with each column vector, exactly as we
saw in broadcasting of arithmetic operations. For example:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">row</code><code class="p">[:,</code> <code class="n">np</code><code class="o">.</code><code class="n">newaxis</code><code class="p">]</code> <code class="o">*</code> <code class="n">col</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">],</code>
               <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code>
               <code class="p">[</code><code class="mi">4</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">6</code><code class="p">]])</code></pre>
<p>It is always important to remember with fancy indexing that the return
value reflects the <em>broadcasted shape of the indices</em>, rather than the
shape of the array being indexed.</p>
</div></section>
<section data-pdf-bookmark="Combined Indexing" data-type="sect1"><div class="sect1" id="ch_0207-fancy-indexing_combined-indexing">
<h1>Combined Indexing</h1>
<p><a data-primary="fancy indexing" data-secondary="combined with other indexing schemes" data-type="indexterm" id="idm45858797108320"/>For even more powerful operations, fancy indexing can be combined with
the other indexing schemes we’ve seen. For example, given
the array <code>X</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="nb">print</code><code class="p">(</code><code class="n">X</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="p">[[</code> <code class="mi">0</code>  <code class="mi">1</code>  <code class="mi">2</code>  <code class="mi">3</code><code class="p">]</code>
         <code class="p">[</code> <code class="mi">4</code>  <code class="mi">5</code>  <code class="mi">6</code>  <code class="mi">7</code><code class="p">]</code>
         <code class="p">[</code> <code class="mi">8</code>  <code class="mi">9</code> <code class="mi">10</code> <code class="mi">11</code><code class="p">]]</code></pre>
<p>We can combine fancy and simple indices:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">X</code><code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">]]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mi">10</code><code class="p">,</code>  <code class="mi">8</code><code class="p">,</code>  <code class="mi">9</code><code class="p">])</code></pre>
<p>We can also combine fancy indexing with slicing:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">X</code><code class="p">[</code><code class="mi">1</code><code class="p">:,</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">]]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code> <code class="mi">6</code><code class="p">,</code>  <code class="mi">4</code><code class="p">,</code>  <code class="mi">5</code><code class="p">],</code>
                <code class="p">[</code><code class="mi">10</code><code class="p">,</code>  <code class="mi">8</code><code class="p">,</code>  <code class="mi">9</code><code class="p">]])</code></pre>
<p>And we can combine fancy indexing with masking:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="n">mask</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="kc">True</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code> <code class="kc">True</code><code class="p">,</code> <code class="kc">False</code><code class="p">])</code>
         <code class="n">X</code><code class="p">[</code><code class="n">row</code><code class="p">[:,</code> <code class="n">np</code><code class="o">.</code><code class="n">newaxis</code><code class="p">],</code> <code class="n">mask</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code> <code class="mi">0</code><code class="p">,</code>  <code class="mi">2</code><code class="p">],</code>
                <code class="p">[</code> <code class="mi">4</code><code class="p">,</code>  <code class="mi">6</code><code class="p">],</code>
                <code class="p">[</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">10</code><code class="p">]])</code></pre>
<p>All of these indexing options combined lead to a very flexible set of
operations for efficiently accessing and modifying array values.</p>
</div></section>
<section data-pdf-bookmark="Example: Selecting Random Points" data-type="sect1"><div class="sect1" id="ch_0207-fancy-indexing_example-selecting-random-points">
<h1>Example: Selecting Random Points</h1>
<p><a data-primary="fancy indexing" data-secondary="selecting random points" data-type="indexterm" id="idm45858796839792"/>One common use of fancy indexing is the selection of subsets of rows
from a matrix. For example, we might have an <math alttext="upper N">
<mi>N</mi>
</math> ×
<math alttext="upper D">
<mi>D</mi>
</math> matrix representing <math alttext="upper N">
<mi>N</mi>
</math> points in
<math alttext="upper D">
<mi>D</mi>
</math> dimensions, such as the following points drawn from a
two-dimensional normal distribution:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="n">mean</code> <code class="o">=</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">]</code>
         <code class="n">cov</code> <code class="o">=</code> <code class="p">[[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">],</code>
                <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">5</code><code class="p">]]</code>
         <code class="n">X</code> <code class="o">=</code> <code class="n">rng</code><code class="o">.</code><code class="n">multivariate_normal</code><code class="p">(</code><code class="n">mean</code><code class="p">,</code> <code class="n">cov</code><code class="p">,</code> <code class="mi">100</code><code class="p">)</code>
         <code class="n">X</code><code class="o">.</code><code class="n">shape</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="p">(</code><code class="mi">100</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code></pre>
<p>Using the plotting tools we will discuss in
<a data-type="xref" href="part04.xhtml#section-0400-introduction-to-matplotlib">Part IV</a>,
we can visualize these points as a scatter plot (<a data-type="xref" href="#fig_0207-fancy-indexing_files_in_output_31_0">Figure 10-1</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="o">%</code><code class="k">matplotlib</code> inline
         <code class="kn">import</code> <code class="nn">matplotlib.pyplot</code> <code class="k">as</code> <code class="nn">plt</code>
         <code class="n">plt</code><code class="o">.</code><code class="n">style</code><code class="o">.</code><code class="n">use</code><code class="p">(</code><code class="s1">'seaborn-whitegrid'</code><code class="p">)</code>

         <code class="n">plt</code><code class="o">.</code><code class="n">scatter</code><code class="p">(</code><code class="n">X</code><code class="p">[:,</code> <code class="mi">0</code><code class="p">],</code> <code class="n">X</code><code class="p">[:,</code> <code class="mi">1</code><code class="p">]);</code></pre>
<figure><div class="figure" id="fig_0207-fancy-indexing_files_in_output_31_0">
<img alt="output 31 0" height="383" src="assets/output_31_0.png" width="600"/>
<h6><span class="label">Figure 10-1. </span>Normally distributed points</h6>
</div></figure>
<p>Let’s use fancy indexing to select 20 random points.
We’ll do this by first choosing 20 random indices with no
repeats, and using these indices to select a portion of the original
array:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="n">indices</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">choice</code><code class="p">(</code><code class="n">X</code><code class="o">.</code><code class="n">shape</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code> <code class="mi">20</code><code class="p">,</code> <code class="n">replace</code><code class="o">=</code><code class="kc">False</code><code class="p">)</code>
         <code class="n">indices</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mi">82</code><code class="p">,</code> <code class="mi">84</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">55</code><code class="p">,</code> <code class="mi">14</code><code class="p">,</code> <code class="mi">33</code><code class="p">,</code>  <code class="mi">4</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">34</code><code class="p">,</code> <code class="mi">92</code><code class="p">,</code> <code class="mi">99</code><code class="p">,</code> <code class="mi">64</code><code class="p">,</code>  <code class="mi">8</code><code class="p">,</code> <code class="mi">76</code><code class="p">,</code> <code class="mi">68</code><code class="p">,</code> <code class="mi">18</code><code class="p">,</code> <code class="mi">59</code><code class="p">,</code>
                <code class="mi">80</code><code class="p">,</code> <code class="mi">87</code><code class="p">,</code> <code class="mi">90</code><code class="p">])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="n">selection</code> <code class="o">=</code> <code class="n">X</code><code class="p">[</code><code class="n">indices</code><code class="p">]</code>  <code class="c1"># fancy indexing here</code>
         <code class="n">selection</code><code class="o">.</code><code class="n">shape</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="p">(</code><code class="mi">20</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code></pre>
<p>Now to see which points were selected, let’s overplot large
circles at the locations of the selected points (see <a data-type="xref" href="#fig_0207-fancy-indexing_files_in_output_36_0">Figure 10-2</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="n">plt</code><code class="o">.</code><code class="n">scatter</code><code class="p">(</code><code class="n">X</code><code class="p">[:,</code> <code class="mi">0</code><code class="p">],</code> <code class="n">X</code><code class="p">[:,</code> <code class="mi">1</code><code class="p">],</code> <code class="n">alpha</code><code class="o">=</code><code class="mf">0.3</code><code class="p">)</code>
         <code class="n">plt</code><code class="o">.</code><code class="n">scatter</code><code class="p">(</code><code class="n">selection</code><code class="p">[:,</code> <code class="mi">0</code><code class="p">],</code> <code class="n">selection</code><code class="p">[:,</code> <code class="mi">1</code><code class="p">],</code>
                     <code class="n">facecolor</code><code class="o">=</code><code class="s1">'none'</code><code class="p">,</code> <code class="n">edgecolor</code><code class="o">=</code><code class="s1">'black'</code><code class="p">,</code> <code class="n">s</code><code class="o">=</code><code class="mi">200</code><code class="p">);</code></pre>
<figure><div class="figure" id="fig_0207-fancy-indexing_files_in_output_36_0">
<img alt="output 36 0" height="381" src="assets/output_36_0.png" width="600"/>
<h6><span class="label">Figure 10-2. </span>Random selection among points</h6>
</div></figure>
<p>This sort of strategy is often used to quickly partition datasets, as is
often needed in train/test splitting for validation of statistical
models (see
<a data-type="xref" href="ch39.xhtml#section-0503-hyperparameters-and-model-validation">Chapter 39</a>), and in sampling approaches to answering
statistical questions.</p>
</div></section>
<section data-pdf-bookmark="Modifying Values with Fancy Indexing" data-type="sect1"><div class="sect1" id="ch_0207-fancy-indexing_modifying-values-with-fancy-indexing">
<h1>Modifying Values with Fancy Indexing</h1>
<p><a data-primary="fancy indexing" data-secondary="modifying values with" data-type="indexterm" id="idm45858796475952"/>Just as fancy indexing can be used to access parts of an array, it can
also be used to modify parts of an array. For example, imagine we have
an array of indices and we’d like to set the corresponding
items in an array to some value:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">18</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code>
         <code class="n">i</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mi">2</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">4</code><code class="p">])</code>
         <code class="n">x</code><code class="p">[</code><code class="n">i</code><code class="p">]</code> <code class="o">=</code> <code class="mi">99</code>
         <code class="nb">print</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">18</code><code class="p">]:</code> <code class="p">[</code> <code class="mi">0</code> <code class="mi">99</code> <code class="mi">99</code>  <code class="mi">3</code> <code class="mi">99</code>  <code class="mi">5</code>  <code class="mi">6</code>  <code class="mi">7</code> <code class="mi">99</code>  <code class="mi">9</code><code class="p">]</code></pre>
<p>We can use any assignment-type operator for this. For example:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">19</code><code class="p">]:</code> <code class="n">x</code><code class="p">[</code><code class="n">i</code><code class="p">]</code> <code class="o">-=</code> <code class="mi">10</code>
         <code class="nb">print</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">19</code><code class="p">]:</code> <code class="p">[</code> <code class="mi">0</code> <code class="mi">89</code> <code class="mi">89</code>  <code class="mi">3</code> <code class="mi">89</code>  <code class="mi">5</code>  <code class="mi">6</code>  <code class="mi">7</code> <code class="mi">89</code>  <code class="mi">9</code><code class="p">]</code></pre>
<p>Notice, though, that repeated indices with these operations can cause
some potentially unexpected results. Consider the following:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">20</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">zeros</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code>
         <code class="n">x</code><code class="p">[[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">]]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">4</code><code class="p">,</code> <code class="mi">6</code><code class="p">]</code>
         <code class="nb">print</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">20</code><code class="p">]:</code> <code class="p">[</code><code class="mf">6.</code> <code class="mf">0.</code> <code class="mf">0.</code> <code class="mf">0.</code> <code class="mf">0.</code> <code class="mf">0.</code> <code class="mf">0.</code> <code class="mf">0.</code> <code class="mf">0.</code> <code class="mf">0.</code><code class="p">]</code></pre>
<p>Where did the 4 go? This operation first assigns <code>x[0] = 4</code>, followed by
<code>x[0] = 6</code>. The result, of course, is that <code>x[0]</code> contains the value 6.</p>
<p>Fair enough, but consider this operation:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">21</code><code class="p">]:</code> <code class="n">i</code> <code class="o">=</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">4</code><code class="p">]</code>
         <code class="n">x</code><code class="p">[</code><code class="n">i</code><code class="p">]</code> <code class="o">+=</code> <code class="mi">1</code>
         <code class="n">x</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">21</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mf">6.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">,</code> <code class="mf">0.</code><code class="p">])</code></pre>
<p>You might expect that <code>x[3]</code> would contain the value 2 and <code>x[4]</code> would
contain the value 3, as this is how many times each index is repeated.
Why is this not the case? Conceptually, this is because <code>x[i] += 1</code> is
meant as a shorthand of <code>x[i] = x[i] + 1</code>. <code>x[i] + 1</code> is evaluated, and
then the result is assigned to the indices in <code>x</code>. With this in mind, it
is not the augmentation that happens multiple times, but the assignment,
which leads to the rather nonintuitive results.</p>
<p>So what if you want the other behavior where the operation is repeated?
For this, you can use the <code>at</code> method of ufuncs and do the following:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">22</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">zeros</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code>
         <code class="n">np</code><code class="o">.</code><code class="n">add</code><code class="o">.</code><code class="n">at</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">i</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code>
         <code class="nb">print</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">22</code><code class="p">]:</code> <code class="p">[</code><code class="mf">0.</code> <code class="mf">0.</code> <code class="mf">1.</code> <code class="mf">2.</code> <code class="mf">3.</code> <code class="mf">0.</code> <code class="mf">0.</code> <code class="mf">0.</code> <code class="mf">0.</code> <code class="mf">0.</code><code class="p">]</code></pre>
<p>The <code>at</code> method does an in-place application of the given operator at
the specified indices (here, <code>i</code>) with the specified value (here, 1).
Another method that is similar in spirit is the <code>reduceat</code> method of
ufuncs, which you can read about in the <a href="https://oreil.ly/7ys9D">NumPy documentation</a>.</p>
</div></section>
<section data-pdf-bookmark="Example: Binning Data" data-type="sect1"><div class="sect1" id="ch_0207-fancy-indexing_example-binning-data">
<h1>Example: Binning Data</h1>
<p><a data-primary="fancy indexing" data-secondary="binning data" data-type="indexterm" id="idm45858796067664"/><a data-primary="histograms" data-secondary="binning data to create" data-type="indexterm" id="idm45858796066688"/>You could use these ideas to efficiently do custom binned computations
on data. For example, imagine we have 100 values and would like to
quickly find where they fall within an array of bins. We could compute
this using <code>ufunc.at</code> like this:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">23</code><code class="p">]:</code> <code class="n">rng</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">default_rng</code><code class="p">(</code><code class="n">seed</code><code class="o">=</code><code class="mi">1701</code><code class="p">)</code>
         <code class="n">x</code> <code class="o">=</code> <code class="n">rng</code><code class="o">.</code><code class="n">normal</code><code class="p">(</code><code class="n">size</code><code class="o">=</code><code class="mi">100</code><code class="p">)</code>

         <code class="c1"># compute a histogram by hand</code>
         <code class="n">bins</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">linspace</code><code class="p">(</code><code class="o">-</code><code class="mi">5</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">20</code><code class="p">)</code>
         <code class="n">counts</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">zeros_like</code><code class="p">(</code><code class="n">bins</code><code class="p">)</code>

         <code class="c1"># find the appropriate bin for each x</code>
         <code class="n">i</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">searchsorted</code><code class="p">(</code><code class="n">bins</code><code class="p">,</code> <code class="n">x</code><code class="p">)</code>

         <code class="c1"># add 1 to each of these bins</code>
         <code class="n">np</code><code class="o">.</code><code class="n">add</code><code class="o">.</code><code class="n">at</code><code class="p">(</code><code class="n">counts</code><code class="p">,</code> <code class="n">i</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code></pre>
<p>The counts now reflect the number of points within each bin—in other
words, a histogram (see <a data-type="xref" href="#fig_0207-fancy-indexing_files_in_output_52_0">Figure 10-3</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">24</code><code class="p">]:</code> <code class="c1"># plot the results</code>
         <code class="n">plt</code><code class="o">.</code><code class="n">plot</code><code class="p">(</code><code class="n">bins</code><code class="p">,</code> <code class="n">counts</code><code class="p">,</code> <code class="n">drawstyle</code><code class="o">=</code><code class="s1">'steps'</code><code class="p">);</code></pre>
<figure><div class="figure" id="fig_0207-fancy-indexing_files_in_output_52_0">
<img alt="output 52 0" height="293" src="assets/output_52_0.png" width="600"/>
<h6><span class="label">Figure 10-3. </span>A histogram computed by hand</h6>
</div></figure>
<p>Of course, it would be inconvenient to have to do this each time you
want to plot a histogram. This is why Matplotlib provides the <code>plt.hist</code>
routine, which does the same in a single line:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">plt</code><code class="o">.</code><code class="n">hist</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">bins</code><code class="p">,</code> <code class="n">histtype</code><code class="o">=</code><code class="s1">'step'</code><code class="p">);</code></pre>
<p>This function will create a nearly identical plot to the one just shown.
To compute the binning, Matplotlib uses the <code>np.histogram</code> function,
which does a very similar computation to what we did before.
Let’s compare the two here:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">25</code><code class="p">]:</code> <code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s2">"NumPy histogram (</code><code class="si">{</code><code class="nb">len</code><code class="p">(</code><code class="n">x</code><code class="p">)</code><code class="si">}</code><code class="s2"> points):"</code><code class="p">)</code>
         <code class="o">%</code><code class="k">timeit</code> counts, edges = np.histogram(x, bins)

         <code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s2">"Custom histogram (</code><code class="si">{</code><code class="nb">len</code><code class="p">(</code><code class="n">x</code><code class="p">)</code><code class="si">}</code><code class="s2"> points):"</code><code class="p">)</code>
         <code class="o">%</code><code class="k">timeit</code> np.add.at(counts, np.searchsorted(bins, x), 1)
<code class="n">Out</code><code class="p">[</code><code class="mi">25</code><code class="p">]:</code> <code class="n">NumPy</code> <code class="n">histogram</code> <code class="p">(</code><code class="mi">100</code> <code class="n">points</code><code class="p">):</code>
         <code class="mf">33.8</code> <code class="n">µs</code> <code class="err">±</code> <code class="mi">311</code> <code class="n">ns</code> <code class="n">per</code> <code class="n">loop</code> <code class="p">(</code><code class="n">mean</code> <code class="err">±</code> <code class="n">std</code><code class="o">.</code> <code class="n">dev</code><code class="o">.</code> <code class="n">of</code> <code class="mi">7</code> <code class="n">runs</code><code class="p">,</code> <code class="mi">10000</code> <code class="n">loops</code> <code class="n">each</code><code class="p">)</code>
         <code class="n">Custom</code> <code class="n">histogram</code> <code class="p">(</code><code class="mi">100</code> <code class="n">points</code><code class="p">):</code>
         <code class="mf">17.6</code> <code class="n">µs</code> <code class="err">±</code> <code class="mi">113</code> <code class="n">ns</code> <code class="n">per</code> <code class="n">loop</code> <code class="p">(</code><code class="n">mean</code> <code class="err">±</code> <code class="n">std</code><code class="o">.</code> <code class="n">dev</code><code class="o">.</code> <code class="n">of</code> <code class="mi">7</code> <code class="n">runs</code><code class="p">,</code> <code class="mi">100000</code> <code class="n">loops</code> <code class="n">each</code><code class="p">)</code></pre>
<p>Our own one-line algorithm is twice as fast as the optimized algorithm
in NumPy! How can this be? If you dig into the <code>np.histogram</code> source
code (you can do this in IPython by typing <code>np.histogram??</code>),
you’ll see that it’s quite a bit more involved
than the simple search-and-count that we’ve done; this is
because NumPy’s algorithm is more flexible, and particularly
is designed for better performance when the number of data points
becomes large:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">26</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="n">rng</code><code class="o">.</code><code class="n">normal</code><code class="p">(</code><code class="n">size</code><code class="o">=</code><code class="mi">1000000</code><code class="p">)</code>
         <code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s2">"NumPy histogram (</code><code class="si">{</code><code class="nb">len</code><code class="p">(</code><code class="n">x</code><code class="p">)</code><code class="si">}</code><code class="s2"> points):"</code><code class="p">)</code>
         <code class="o">%</code><code class="k">timeit</code> counts, edges = np.histogram(x, bins)

         <code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s2">"Custom histogram (</code><code class="si">{</code><code class="nb">len</code><code class="p">(</code><code class="n">x</code><code class="p">)</code><code class="si">}</code><code class="s2"> points):"</code><code class="p">)</code>
         <code class="o">%</code><code class="k">timeit</code> np.add.at(counts, np.searchsorted(bins, x), 1)
<code class="n">Out</code><code class="p">[</code><code class="mi">26</code><code class="p">]:</code> <code class="n">NumPy</code> <code class="n">histogram</code> <code class="p">(</code><code class="mi">1000000</code> <code class="n">points</code><code class="p">):</code>
         <code class="mf">84.4</code> <code class="n">ms</code> <code class="err">±</code> <code class="mf">2.82</code> <code class="n">ms</code> <code class="n">per</code> <code class="n">loop</code> <code class="p">(</code><code class="n">mean</code> <code class="err">±</code> <code class="n">std</code><code class="o">.</code> <code class="n">dev</code><code class="o">.</code> <code class="n">of</code> <code class="mi">7</code> <code class="n">runs</code><code class="p">,</code> <code class="mi">10</code> <code class="n">loops</code> <code class="n">each</code><code class="p">)</code>
         <code class="n">Custom</code> <code class="n">histogram</code> <code class="p">(</code><code class="mi">1000000</code> <code class="n">points</code><code class="p">):</code>
         <code class="mi">128</code> <code class="n">ms</code> <code class="err">±</code> <code class="mf">2.04</code> <code class="n">ms</code> <code class="n">per</code> <code class="n">loop</code> <code class="p">(</code><code class="n">mean</code> <code class="err">±</code> <code class="n">std</code><code class="o">.</code> <code class="n">dev</code><code class="o">.</code> <code class="n">of</code> <code class="mi">7</code> <code class="n">runs</code><code class="p">,</code> <code class="mi">10</code> <code class="n">loops</code> <code class="n">each</code><code class="p">)</code></pre>
<p><a data-primary="algorithmic efficiency, dataset size and" data-type="indexterm" id="idm45858795681120"/>What this comparison shows is that algorithmic efficiency is almost
never a simple question. An algorithm efficient for large datasets will
not always be the best choice for small datasets, and vice versa (see
<a data-type="xref" href="ch11.xhtml#section-0208-sorting">Chapter 11</a>). But the
advantage of coding this algorithm yourself is that with an
understanding of these basic methods, the sky is the limit:
you’re no longer constrained to built-in routines, but can
create your own approaches to exploring the data. Key to efficiently
using Python in data-intensive applications is not only knowing about
general convenience routines like <code>np.histogram</code> and when
they’re appropriate, but also knowing how to make use of
lower-level functionality when you need more pointed behavior.<a data-startref="ix_ch10-asciidoc1" data-type="indexterm" id="idm45858795634496"/><a data-startref="ix_ch10-asciidoc0" data-type="indexterm" id="idm45858795633824"/></p>
</div></section>
</div></section></div></body></html>