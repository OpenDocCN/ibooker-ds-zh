- en: Chapter 2\. Enhanced Interactive Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much of the power of IPython and Jupyter comes from the additional interactive
    tools they make available. This chapter will cover a number of those tools, including
    so-called magic commands, tools for exploring input and output history, and tools
    to interact with the shell.
  prefs: []
  type: TYPE_NORMAL
- en: IPython Magic Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous chapter showed how IPython lets you use and explore Python efficiently
    and interactively. Here we’ll begin discussing some of the enhancements that IPython
    adds on top of the normal Python syntax. These are known in IPython as *magic
    commands*, and are prefixed by the `%` character. These magic commands are designed
    to succinctly solve various common problems in standard data analysis. Magic commands
    come in two flavors: *line magics*, which are denoted by a single `%` prefix and
    operate on a single line of input, and *cell magics*, which are denoted by a double
    `%%` prefix and operate on multiple lines of input. I’ll demonstrate and discuss
    a few brief examples here, and come back to a more focused discussion of several
    useful magic commands later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running External Code: %run'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you begin developing more extensive code, you will likely find yourself working
    in IPython for interactive exploration, as well as a text editor to store code
    that you want to reuse. Rather than running this code in a new window, it can
    be convenient to run it within your IPython session. This can be done with the
    `%run` magic command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine you’ve created a *myscript.py* file with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can execute this from your IPython session as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note also that after you’ve run this script, any functions defined within it
    are available for use in your IPython session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There are several options to fine-tune how your code is run; you can see the
    documentation in the normal way, by typing **`%run?`** in the IPython interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Timing Code Execution: %timeit'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another example of a useful magic function is `%timeit`, which will automatically
    determine the execution time of the single-line Python statement that follows
    it. For example, we may want to check the performance of a list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The benefit of `%timeit` is that for short commands it will automatically perform
    multiple runs in order to attain more robust results. For multiline statements,
    adding a second `%` sign will turn this into a cell magic that can handle multiple
    lines of input. For example, here’s the equivalent construction with a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can immediately see that list comprehensions are about 10% faster than the
    equivalent `for` loop construction in this case. We’ll explore `%timeit` and other
    approaches to timing and profiling code in [“Profiling and Timing Code”](ch03.xhtml#section-0107-timing-and-profiling).
  prefs: []
  type: TYPE_NORMAL
- en: 'Help on Magic Functions: ?, %magic, and %lsmagic'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like normal Python functions, IPython magic functions have docstrings, and
    this useful documentation can be accessed in the standard manner. So, for example,
    to read the documentation of the `%timeit` magic function, simply type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Documentation for other functions can be accessed similarly. To access a general
    description of available magic functions, including some examples, you can type
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For a quick and simple list of all available magic functions, type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Finally, I’ll mention that it is quite straightforward to define your own magic
    functions if you wish. I won’t discuss it here, but if you are interested, see
    the references listed in [“More IPython Resources”](ch03.xhtml#section-0108-more-ipython-resources).
  prefs: []
  type: TYPE_NORMAL
- en: Input and Output History
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously you saw that the IPython shell allows you to access previous commands
    with the up and down arrow keys, or equivalently the Ctrl-p/Ctrl-n shortcuts.
    Additionally, in both the shell and notebooks, IPython exposes several ways to
    obtain the output of previous commands, as well as string versions of the commands
    themselves. We’ll explore those here.
  prefs: []
  type: TYPE_NORMAL
- en: IPython’s In and Out Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By now I imagine you’re becoming familiar with the `In [1]:`/`Out[1]:` style
    of prompts used by IPython. But it turns out that these are not just pretty decoration:
    they give a clue as to how you can access previous inputs and outputs in your
    current session. Suppose we start a session that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve imported the built-in `math` package, then computed the sine and the
    cosine of the number 2\. These inputs and outputs are displayed in the shell with
    `In`/`Out` labels, but there’s more—IPython actually creates some Python variables
    called `In` and `Out` that are automatically updated to reflect this history:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `In` object is a list, which keeps track of the commands in order (the
    first item in the list is a placeholder so that `In [1]` can refer to the first
    command):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Out` object is not a list but a dictionary mapping input numbers to their
    outputs (if any):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that not all operations have outputs: for example, `import` statements
    and `print` statements don’t affect the output. The latter may be surprising,
    but makes sense if you consider that `print` is a function that returns `None`;
    for brevity, any command that returns `None` is not added to `Out`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be useful when you want to interact with past results. For example,
    let’s check the sum of `sin(2) ** 2` and `cos(2) ** 2` using the previously computed
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The result is `1.0`, as we’d expect from the well-known trigonometric identity.
    In this case, using these previous results probably is not necessary, but it can
    become quite handy if you execute a very expensive computation and forget to assign
    the result to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Underscore Shortcuts and Previous Outputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standard Python shell contains just one simple shortcut for accessing previous
    output: the variable `_` (i.e., a single underscore) is kept updated with the
    previous output. This works in IPython as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'But IPython takes this a bit further—you can use a double underscore to access
    the second-to-last output, and a triple underscore to access the third-to-last
    output (skipping any commands with no output):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'IPython stops there: more than three underscores starts to get a bit hard to
    count, and at that point it’s easier to refer to the output by line number.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more shortcut I should mention, however—a shorthand for `Out[*X*]`
    is `_*X*` (i.e., a single underscore followed by the line number):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Suppressing Output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes you might wish to suppress the output of a statement (this is perhaps
    most common with the plotting commands that we’ll explore in [Part IV](part04.xhtml#section-0400-introduction-to-matplotlib)).
    Or maybe the command you’re executing produces a result that you’d prefer not
    to store in your output history, perhaps so that it can be deallocated when other
    references are removed. The easiest way to suppress the output of a command is
    to add a semicolon to the end of the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is computed silently, and the output is neither displayed on the
    screen nor stored in the `Out` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Related Magic Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For accessing a batch of previous inputs at once, the `%history` magic command
    is very helpful. Here is how you can print the first four inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As usual, you can type `%history?` for more information and a description of
    options available (see [Chapter 1](ch01.xhtml#section-0101-help-and-documentation)
    for details on the `?` functionality). Other useful magic commands are `%rerun`,
    which will re-execute some portion of the command history, and `%save`, which
    saves some set of the command history to a file).
  prefs: []
  type: TYPE_NORMAL
- en: IPython and Shell Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working interactively with the standard Python interpreter, one of the
    frustrations is the need to switch between multiple windows to access Python tools
    and system command-line tools. IPython bridges this gap and gives you a syntax
    for executing shell commands directly from within the IPython terminal. The magic
    happens with the exclamation point: anything appearing after `!` on a line will
    be executed not by the Python kernel, but by the system command line.'
  prefs: []
  type: TYPE_NORMAL
- en: The following discussion assumes you’re on a Unix-like system, such as Linux
    or macOS. Some of the examples that follow will fail on Windows, which uses a
    different type of shell by default, though if you use the [*Windows Subsystem
    for Linux*](https://oreil.ly/H5MEE) the examples here should run correctly. If
    you’re unfamiliar with shell commands, I’d suggest reviewing the [Unix shell tutorial](https://oreil.ly/RrD2Y)
    put together by the always excellent Software Carpentry Foundation.
  prefs: []
  type: TYPE_NORMAL
- en: Quick Introduction to the Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A full introduction to using the shell/terminal/command line is well beyond
    the scope of this chapter, but for the uninitiated I will offer a quick introduction
    here. The shell is a way to interact textually with your computer. Ever since
    the mid-1980s, when Microsoft and Apple introduced the first versions of their
    now ubiquitous graphical operating systems, most computer users have interacted
    with their operating systems through the familiar menu selections and drag-and-drop
    movements. But operating systems existed long before these graphical user interfaces,
    and were primarily controlled through sequences of text input: at the prompt,
    the user would type a command, and the computer would do what the user told it
    to. Those early prompt systems were the precursors of the shells and terminals
    that most data scientists still use today.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Someone unfamiliar with the shell might ask why you would bother with this,
    when many of the same results can be accomplished by simply clicking on icons
    and menus. A shell user might reply with another question: why hunt for icons
    and menu items when you can accomplish things much more easily by typing? While
    it might sound like a typical tech preference impasse, when moving beyond basic
    tasks it quickly becomes clear that the shell offers much more control of advanced
    tasks—though admittedly the learning curve can be intimidating.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, here is a sample of a Linux/macOS shell session where a user
    explores, creates, and modifies directories and files on their system (`osx:~
    $` is the prompt, and everything after the `$` is the typed command; text that
    is preceded by a `#` is meant just as description, rather than something you would
    actually type in):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice that all of this is just a compact way to do familiar operations (navigating
    a directory structure, creating a directory, moving a file, etc.) by typing commands
    rather than clicking icons and menus. With just a few commands (`pwd`, `ls`, `cd`,
    `mkdir`, and `cp`) you can do many of the most common file operations, but it’s
    when you go beyond these basics that the shell approach becomes really powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Shell Commands in IPython
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any standard shell command can be used directly in IPython by prefixing it
    with the `!` character. For example, the `ls`, `pwd`, and `echo` commands can
    be run as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Passing Values to and from the Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Shell commands can not only be called from IPython, but can also be made to
    interact with the IPython namespace. For example, you can save the output of any
    shell command to a Python list using the assignment operator, `=`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'These results are not returned as lists, but as a special shell return type
    defined in IPython:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This looks and acts a lot like a Python list but has additional functionality,
    such as the `grep` and `fields` methods and the `s`, `n`, and `p` properties that
    allow you to search, filter, and display the results in convenient ways. For more
    information on these, you can use IPython’s built-in help features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Communication in the other direction—passing Python variables into the shell—is
    possible using the `{*varname*}` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The curly braces contain the variable name, which is replaced by the variable’s
    contents in the shell command.
  prefs: []
  type: TYPE_NORMAL
- en: Shell-Related Magic Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you play with IPython’s shell commands for a while, you might notice that
    you cannot use `!cd` to navigate the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason is that shell commands in the notebook are executed in a temporary
    subshell that does not maintain state from command to command. If you’d like to
    change the working directory in a more enduring way, you can use the `%cd` magic
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, by default you can even use this without the `%` sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is known as an *automagic* function, and the ability to execute such commands
    without an explicit `%` can be toggled with the `%automagic` magic function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides `%cd`, other available shell-like magic functions are `%cat`, `%cp`,
    `%env`, `%ls`, `%man`, `%mkdir`, `%more`, `%mv`, `%pwd`, `%rm`, and `%rmdir`,
    any of which can be used without the `%` sign if `automagic` is on. This makes
    it so that you can almost treat the IPython prompt as if it’s a normal shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This access to the shell from within the same terminal window as your Python
    session lets you more naturally combine Python and the shell in your workflows
    with fewer context switches.
  prefs: []
  type: TYPE_NORMAL
