<html><head></head><body><section data-pdf-bookmark="Chapter 16. FASTX grep: Creating a Utility Program to Select Sequences" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch16">&#13;
<h1><span class="label">Chapter 16. </span>FASTX grep: Creating a Utility Program <span class="keep-together">to Select Sequences</span></h1>&#13;
&#13;
&#13;
<p>A colleague asked me once to find all the RNA sequences in a FASTQ file that had a description or name containing the string <em>LSU</em> (for <em>long subunit</em> RNA).&#13;
Although it’s possible to solve this problem for FASTQ files by using the <code>grep</code> program<sup><a data-type="noteref" href="ch16.html#idm45963628251688" id="idm45963628251688-marker">1</a></sup> to find all the lines of a file matching some pattern, writing a solution in Python allows you to create a program that could be expanded to handle other formats, like FASTA, as well as to select records based on other criteria, such as length or GC content.&#13;
Additionally, you can add options to change the output sequence format and introduce conveniences for the user like guessing the input file’s format based on the file extension.</p>&#13;
&#13;
<p>In this chapter, you will learn:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>About the structure of a FASTQ file</p>&#13;
</li>&#13;
<li>&#13;
<p>How to perform a case-insensitive regular expression match</p>&#13;
</li>&#13;
<li>&#13;
<p>About DWIM (Do What I Mean) and DRY (Don’t Repeat Yourself) ideas in code</p>&#13;
</li>&#13;
<li>&#13;
<p>How to use <code>and</code> and <code>or</code> operations to reduce Boolean values and bits</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before" data-pdf-bookmark="Finding Lines in a File Using grep" data-type="sect1"><div class="sect1" id="idm45963628244360">&#13;
<h1>Finding Lines in a File Using grep</h1>&#13;
&#13;
<p>The <code>grep</code> program can find all the lines in a file matching a given pattern.<a data-primary="grep" data-type="indexterm" id="idm45963628242280"/><a data-primary="regular expressions (regexes)" data-secondary="grep" data-type="indexterm" id="idm45963628241608"/><a data-primary="command line (Unix)" data-secondary="grep" data-type="indexterm" id="idm45963628240648"/><a data-primary="Unix command line" data-secondary="grep" data-type="indexterm" id="idm45963628239704"/>&#13;
If I search for <em>LSU</em> in one of the FASTQ files, it finds two header lines containing this pattern:</p>&#13;
&#13;
<pre data-type="programlisting">$ grep LSU tests/inputs/lsu.fq&#13;
@ITSLSUmock2p.ITS_M01380:138:000000000-C9GKM:1:1101:14440:2042 2:N:0&#13;
@ITSLSUmock2p.ITS_M01384:138:000000000-C9GKM:1:1101:14440:2043 2:N:0</pre>&#13;
&#13;
<p>If the goal were only to find how many sequences contain this string, I could pipe this into <code>wc</code> (word count) to count the lines using the <code>-l</code> option:</p>&#13;
&#13;
<pre data-type="programlisting">$ grep LSU tests/inputs/lsu.fq | wc -l&#13;
       2</pre>&#13;
&#13;
<p>Since my goal is to extract the sequence records where the header contains the substring <em>LSU</em>, I have to do a little more work.&#13;
As long as the input files are in FASTQ format, I can still use <code>grep</code>, but this requires a better understanding of the format.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Structure of a FASTQ Record" data-type="sect1"><div class="sect1" id="idm45963628233128">&#13;
<h1>The Structure of a FASTQ Record</h1>&#13;
&#13;
<p>The FASTQ sequence format is a common way to receive sequence data from a sequencer as it includes both the base calls and the quality scores for each base.<a data-primary="FASTX grep created" data-secondary="about FASTQ" data-type="indexterm" id="ch16-fastq"/><a data-primary="FASTQ sequence format" data-secondary="about" data-type="indexterm" id="ch16-fastq2"/>&#13;
That is, sequencers generally report both a base and a measure of certainty that the base is correct.&#13;
Some sequencing technologies have trouble, for instance, with homopolymer runs, like a poly(<em>A</em>) run of many <em>A</em>s where the sequencer may be unable to count the correct number.&#13;
Many sequencers also lose confidence in base calls as the reads grow longer.&#13;
Quality scores are an important means for rejecting or truncating low-quality reads.</p>&#13;
<div data-type="note" epub:type="note">&#13;
<p>Depending on the sequencer, some bases can be hard to distinguish, and the ambiguity may be reported using IUPAC codes I describe in <a data-type="xref" href="ch01.html#ch01">Chapter 1</a>, such as <em>R</em> for <em>A</em> or <em>G</em> or <em>N</em> for any base.<a data-primary="IUPAC codes" data-type="indexterm" id="idm45963628224056"/></p>&#13;
</div>&#13;
&#13;
<p>The FASTQ format is somewhat similar to the FASTA format used in many of the problems in the Rosalind challenges.<a data-primary="FASTA format" data-secondary="FASTQ compared" data-seealso="FASTX program created" data-type="indexterm" id="idm45963628222680"/><a data-primary="FASTQ sequence format" data-secondary="FASTA compared" data-seealso="FASTX program created" data-type="indexterm" id="idm45963628221464"/>&#13;
As a reminder, FASTA records start with a <code>&gt;</code> symbol followed by a header line that identifies the sequence and may contain metadata.<a data-primary="FASTA format" data-secondary="about" data-type="indexterm" id="idm45963628219528"/>&#13;
The sequence itself follows, which may be one (possibly long) line of text or might be split over multiple lines.&#13;
In contrast, FASTQ records must always be exactly four lines, as shown in <a data-type="xref" href="#fig_16.1">Figure 16-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig_16.1">&#13;
<img alt="mpfb 1601" src="assets/mpfb_1601.png"/>&#13;
<h6><span class="label">Figure 16-1. </span>The elements of a FASTQ record—although the long lines are wrapped in this display, the actual record contains exactly four lines</h6>&#13;
</div></figure>&#13;
&#13;
<p>Let’s take a closer look at the contents of this figure:</p>&#13;
<ol>&#13;
<li>&#13;
<p>The first line starts with the <code>@</code> symbol and contains the header information.</p>&#13;
</li>&#13;
<li>&#13;
<p>The second line contains the sequence with no line breaks.</p>&#13;
</li>&#13;
<li>&#13;
<p>The third line begins with the <code>+</code> symbol. Often it will be only this symbol, but sometimes the header information may be repeated.</p>&#13;
</li>&#13;
<li>&#13;
<p>The fourth line contains the quality scores for each base in the sequence and also has no line breaks.</p>&#13;
</li>&#13;
<li>&#13;
<p>The sequence ID is all characters up to the first space.</p>&#13;
</li>&#13;
<li>&#13;
<p>Additional metadata may follow the ID and is included in the description.</p>&#13;
</li>&#13;
<li>&#13;
<p>Each base in the sequence has a partner in the quality line representing the confidence that this base is correct.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>A FASTQ header has the same structure as the header in a FASTA record, with the exception that it starts with the <code>@</code> sign instead of the <code>&gt;</code>.&#13;
The sequence identifier is usually all the characters after <code>@</code> up to the first space.&#13;
The second line containing the sequence cannot contain any line breaks, and each base in the sequence has a corresponding quality value in the fourth line.&#13;
The quality scores on the fourth line use the ASCII values of the characters to encode the certainty of the base call.&#13;
These scores are represented using the printable characters from the ASCII table first introduced in <a data-type="xref" href="ch03.html#ch03">Chapter 3</a>.<a data-primary="ASCII (American Standard Code for Information Interchange) table" data-type="indexterm" id="idm45963628203512"/></p>&#13;
&#13;
<p>The first 32 values in the ASCII table are unprintable control characters and the space.&#13;
The printable characters start at 33, with punctuation followed by numbers.&#13;
The first letter, <em>A</em>, is not found until 65, and uppercase characters precede lowercase.&#13;
The following is the output from the <code>asciitbl.py</code> program included in the repository that shows the ordinal values of the 128 values from the ASCII table:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./asciitbl.py&#13;
  0 NA      26 NA      52 4       78 N      104 h&#13;
  1 NA      27 NA      53 5       79 O      105 i&#13;
  2 NA      28 NA      54 6       80 P      106 j&#13;
  3 NA      29 NA      55 7       81 Q      107 k&#13;
  4 NA      30 NA      56 8       82 R      108 l&#13;
  5 NA      31 NA      57 9       83 S      109 m&#13;
  6 NA      32 SPACE   58 :       84 T      110 n&#13;
  7 NA      33 !       59 ;       85 U      111 o&#13;
  8 NA      34 "       60 &lt;       86 V      112 p&#13;
  9 NA      35 #       61 =       87 W      113 q&#13;
 10 NA      36 $       62 &gt;       88 X      114 r&#13;
 11 NA      37 %       63 ?       89 Y      115 s&#13;
 12 NA      38 &amp;       64 @       90 Z      116 t&#13;
 13 NA      39 '       65 A       91 [      117 u&#13;
 14 NA      40 (       66 B       92 \      118 v&#13;
 15 NA      41 )       67 C       93 ]      119 w&#13;
 16 NA      42 *       68 D       94 ^      120 x&#13;
 17 NA      43 +       69 E       95 _      121 y&#13;
 18 NA      44 ,       70 F       96 `      122 z&#13;
 19 NA      45 -       71 G       97 a      123 {&#13;
 20 NA      46 .       72 H       98 b      124 |&#13;
 21 NA      47 /       73 I       99 c      125 }&#13;
 22 NA      48 0       74 J      100 d      126 ~&#13;
 23 NA      49 1       75 K      101 e      127 DEL&#13;
 24 NA      50 2       76 L      102 f&#13;
 25 NA      51 3       77 M      103 g</pre>&#13;
&#13;
<p>Look at the quality line of the FASTQ record in <a data-type="xref" href="#fig_16.1">Figure 16-1</a> and see how the characters change from higher values like uppercase letters at the beginning to lower values like punctuation and numbers toward the end.&#13;
Note that the <code>@</code> and <code>+</code> symbols on the fourth line represent possible quality values and so would not be metacharacters denoting the beginning of a record or the separator line.&#13;
For this reason, FASTQ records can’t use newlines to break the sequence (like in FASTA records) or quality lines: the symbols <code>@</code> and <code>+</code> might end up as the first character on a line, making it impossible to find the start of a record.&#13;
Combine this with the utterly useless third line that often consists of a single <code>+</code> symbol, and which sometimes needlessly recapitulates all the header information, and you see why biologists should never be allowed to define a file format.</p>&#13;
<div data-type="note" epub:type="note">&#13;
<p>There are multiple encoding standards using various ranges to represent the quality scores.</p>&#13;
</div>&#13;
&#13;
<p>Because FASTQ records must be four lines long, I can use the <code>-A|--after-context</code> option for <code>grep</code> to specify the number of lines of trailing context after each match:<a data-primary="grep" data-secondary="FASTQ records" data-type="indexterm" id="idm45963628192120"/><a data-primary="regular expressions (regexes)" data-secondary="grep" data-tertiary="FASTQ records" data-type="indexterm" id="idm45963628191176"/><a data-primary="FASTQ sequence format" data-secondary="grep for analyzing" data-type="indexterm" id="idm45963628189944"/></p>&#13;
&#13;
<pre data-type="programlisting">$ grep -A 4 LSU tests/inputs/lsu.fq | head -4&#13;
@ITSLSUmock2p.ITS_M01380:138:000000000-C9GKM:1:1101:14440:2042 2:N:0&#13;
CAAGTTACTTCCTCTAAATGACCAAGCCTAGTGTAGAACCATGTCGTCAGTGTCAGTCTGAGTGTAGATCT\&#13;
CGGTGGTCGCCGTATCATTAAAAAAAAAAATGTAATACTACTAGTAATTATTAATATTATAATTTTGTCTA\&#13;
TTAGCATCTTATTATAGATAGAAGATATTATTCATATTTCACTATCTTATACTGATATCAGCTTTATCAGA\&#13;
TCACACTCTAGTGAAGATTGTTCTTAACTGAAATTTCCTTCTTCATACAGACACATTAATCTTACCTA&#13;
+&#13;
EFGGGGGGGGGCGGGGGFCFFFGGGGGFGGGGGGGGGGGFGGGGGGGFGFFFCFGGFFGGGGGGGGGFGGG\&#13;
GFGGGDG&lt;FD@4@CFFGGGGCFFAFEFEG+,9,,,,99,,,5,,49,4,8,4,444,4,4,,,,,,,,,,,\&#13;
,,,8,,,,63,,,,,,,,376,3,,,,,,,8,,,,,,,,,+++++++++++++3++25+++0+*+0+*0+*\&#13;
**))*0))1/+++**************.****.*******0*********/(,(/).)))1)).).).</pre>&#13;
&#13;
<p>This works as long as the substring of interest occurs only in the header, which is the first line of a record.&#13;
If <code>grep</code> managed to find a match in any other line in the record, it would print that line plus the following three, yielding unusable garbage.&#13;
Given that I would like to control exactly which parts of the record to search and the fact that the input files might be in FASTQ, FASTA, or any number of other formats, it quickly becomes evident that <code>grep</code> won’t take me very far.<a data-startref="ch16-fastq" data-type="indexterm" id="idm45963628185832"/><a data-startref="ch16-fastq2" data-type="indexterm" id="idm45963628185160"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Getting Started" data-type="sect1"><div class="sect1" id="idm45963628184168">&#13;
<h1>Getting Started</h1>&#13;
&#13;
<p>First, I’ll show you how my solution works, and then I’ll challenge you to implement your version.<a data-primary="FASTX grep created" data-secondary="getting started" data-type="indexterm" id="idm45963628182792"/>&#13;
All the code and tests for this exercise are in the <em>16_fastx_grep</em> directory of the repository.&#13;
Start by changing into this directory and copying the solution to <code>fastx_grep.py</code>:</p>&#13;
&#13;
<pre data-type="programlisting">$ cd 16_fastx_grep&#13;
$ cp solution.py fastx_grep.py</pre>&#13;
&#13;
<p>The <code>grep</code> usage shows that it accepts two positional arguments, a pattern and one or more files:</p>&#13;
&#13;
<pre data-type="programlisting">$ grep -h&#13;
usage: grep [-abcDEFGHhIiJLlmnOoqRSsUVvwxZ] [-A num] [-B num] [-C[num]]&#13;
	[-e pattern] [-f file] [--binary-files=value] [--color=when]&#13;
	[--context[=num]] [--directories=action] [--label] [--line-buffered]&#13;
	[--null] [pattern] [file ...]</pre>&#13;
&#13;
<p>Request help from the <code>fastx_grep.py</code> program and see that it has a similar interface that requires a pattern and one or more input files.&#13;
Additionally, this program can parse different input file formats, produce various output formats, write the output to a file, and perform case-insensitive matching:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./fastx_grep.py -h&#13;
usage: fastx_grep.py [-h] [-f str] [-O str] [-o FILE] [-i]&#13;
                     PATTERN FILE [FILE ...]&#13;
&#13;
Grep through FASTX files&#13;
&#13;
positional arguments:&#13;
  PATTERN               Search pattern <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-1" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-1"><img alt="1" src="assets/1.png"/></a>&#13;
  FILE                  Input file(s) <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-2" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-2"><img alt="2" src="assets/2.png"/></a>&#13;
&#13;
optional arguments:&#13;
  -h, --help            show this help message and exit&#13;
  -f str, --format str  Input file format (default: ) <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-3" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-3"><img alt="3" src="assets/3.png"/></a>&#13;
  -O str, --outfmt str  Output file format (default: ) <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-4" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-4"><img alt="4" src="assets/4.png"/></a>&#13;
  -o FILE, --outfile FILE&#13;
                        Output file (default: &lt;_io.TextIOWrapper <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-5" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-5"><img alt="5" src="assets/5.png"/></a>&#13;
                        name='&lt;stdout&gt;' mode='w' encoding='utf-8'&gt;)&#13;
  -i, --insensitive     Case-insensitive search (default: False) <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-6" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-6"><img alt="6" src="assets/6.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-1" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The regular expression (pattern) is the first positional argument.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-2" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>One or more positional file arguments are required second.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-3" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The input file format of the sequences, either <em>fasta</em> or <em>fastq</em>. The default is to guess from the file extension.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-4" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>The output file format, one of <em>fasta</em>, <em>fastq</em>, or <em>fasta-2line</em>. The default is to use the same as the input file.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-5" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>The output filename; the default is <code>STDOUT</code>.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-6" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO1-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Whether to perform case-insensitive matches; the default is <code>False</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>This program has a more complicated set of arguments than many of the programs from <a data-type="xref" href="part01.html#part_one">Part I</a>.&#13;
As usual, I like to use a <code>NamedTuple</code> to model the options:</p>&#13;
&#13;
<pre data-type="programlisting">from typing import List, NamedTuple, TextIO&#13;
&#13;
&#13;
class Args(NamedTuple):&#13;
    """ Command-line arguments """&#13;
    pattern: str <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-1" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-1"><img alt="1" src="assets/1.png"/></a>&#13;
    files: List[TextIO] <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-2" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-2"><img alt="2" src="assets/2.png"/></a>&#13;
    input_format: str <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-3" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-3"><img alt="3" src="assets/3.png"/></a>&#13;
    output_format: str <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-4" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-4"><img alt="4" src="assets/4.png"/></a>&#13;
    outfile: TextIO <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-5" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-5"><img alt="5" src="assets/5.png"/></a>&#13;
    insensitive: bool <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-6" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-6"><img alt="6" src="assets/6.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-1" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The regular expression to use.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-2" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>One or more input files.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-3" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The format of the input file, such as FASTA or FASTQ.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-4" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>The format of the output file.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-5" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>The name of the output file.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-6" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO2-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Whether to perform case-insensitive searching.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Here is how I define the program’s parameters:</p>&#13;
&#13;
<pre data-type="programlisting">def get_args() -&gt; Args:&#13;
    """ Get command-line arguments """&#13;
&#13;
    parser = argparse.ArgumentParser(&#13;
        description='Grep through FASTX files',&#13;
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)&#13;
&#13;
    parser.add_argument('pattern', <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-1" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-1"><img alt="1" src="assets/1.png"/></a>&#13;
                        metavar='PATTERN',&#13;
                        type=str,&#13;
                        help='Search pattern')&#13;
&#13;
    parser.add_argument('file',&#13;
                        metavar='FILE',&#13;
                        nargs='+',&#13;
                        type=argparse.FileType('rt'), <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-2" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-2"><img alt="2" src="assets/2.png"/></a>&#13;
                        help='Input file(s)')&#13;
&#13;
    parser.add_argument('-f',&#13;
                        '--format',&#13;
                        help='Input file format',&#13;
                        metavar='str',&#13;
                        choices=['fasta', 'fastq'], <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-3" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-3"><img alt="3" src="assets/3.png"/></a>&#13;
                        default='')&#13;
&#13;
    parser.add_argument('-O',&#13;
                        '--outfmt',&#13;
                        help='Output file format',&#13;
                        metavar='str',&#13;
                        choices=['fasta', 'fastq', 'fasta-2line'], <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-4" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-4"><img alt="4" src="assets/4.png"/></a>&#13;
                        default='')&#13;
&#13;
    parser.add_argument('-o',&#13;
                        '--outfile',&#13;
                        help='Output file',&#13;
                        type=argparse.FileType('wt'), <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-5" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-5"><img alt="5" src="assets/5.png"/></a>&#13;
                        metavar='FILE',&#13;
                        default=sys.stdout)&#13;
&#13;
    parser.add_argument('-i', <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-6" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-6"><img alt="6" src="assets/6.png"/></a>&#13;
                        '--insensitive',&#13;
                        help='Case-insensitive search',&#13;
                        action='store_true')&#13;
&#13;
    args = parser.parse_args()&#13;
&#13;
    return Args(pattern=args.pattern,&#13;
                files=args.file,&#13;
                input_format=args.format,&#13;
                output_format=args.outfmt,&#13;
                outfile=args.outfile,&#13;
                insensitive=args.insensitive)</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-1" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The pattern will be a string.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-2" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The inputs must be readable text files.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-3" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Use <code>choices</code> to constrain the input values. The default will be guessed from the input file extension.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-4" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Constrain values using <code>choices</code>; default to using the input format. The <em>fasta-2line</em> option will not break long sequences over multiple lines and so will use only two lines per record.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-5" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>The output file will be a writable text file. The default is <code>STDOUT</code>.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-6" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO3-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>A flag to indicate case-insensitive searching. The default is <code>False</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>If you run the following command to search for <em>LSU</em> in the <em>lsu.fq</em> test file, you should see eight lines of output representing two FASTQ records:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./fastx_grep.py LSU tests/inputs/lsu.fq | wc -l&#13;
       8</pre>&#13;
&#13;
<p>If you search for lowercase <em>lsu</em>, however, you should see no output:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./fastx_grep.py lsu tests/inputs/lsu.fq | wc -l&#13;
       0</pre>&#13;
&#13;
<p>Use the <code>-i|--insensitive</code> flag to perform a case-insensitive search:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./fastx_grep.py -i lsu tests/inputs/lsu.fq  | wc -l&#13;
       8</pre>&#13;
&#13;
<p>You can use the <code>-o|--outfile</code> option to write the results to a file instead of <code>STDOUT</code>:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./fastx_grep.py -o out.fq -i lsu tests/inputs/lsu.fq&#13;
$ wc -l out.fq&#13;
       8 out.fq</pre>&#13;
&#13;
<p>If you look at the <em>out.fq</em> file, you’ll see it’s in FASTQ format just like the original input.&#13;
You can use the <code>-O|--outfmt</code> option to change this to something like FASTA and look at the output file to verify the format:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./fastx_grep.py -O fasta -o out.fa -i lsu tests/inputs/lsu.fq&#13;
$ head -3 out.fa&#13;
&gt;ITSLSUmock2p.ITS_M01380:138:000000000-C9GKM:1:1101:14440:2042 2:N:0&#13;
CAAGTTACTTCCTCTAAATGACCAAGCCTAGTGTAGAACCATGTCGTCAGTGTCAGTCTG&#13;
AGTGTAGATCTCGGTGGTCGCCGTATCATTAAAAAAAAAAATGTAATACTACTAGTAATT</pre>&#13;
&#13;
<p>Try using the <em>fasta-2line</em> output format to see how the long sequences are not broken over multiple lines.&#13;
Note that the program also works on FASTA input without my having to indicate the file format because it is guessed from the <em>.fa</em> file extension:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./fastx_grep.py -o out.fa -i lsu tests/inputs/lsu.fa&#13;
$ ../15_seqmagique/seqmagique.py out.fa&#13;
name      min_len    max_len    avg_len    num_seqs&#13;
out.fa        281        301     291.00           2</pre>&#13;
&#13;
<p>Run <strong><code>pytest -v</code></strong> to see all the tests for the program, which include guessing the file format, handling empty files, searching lowercase and uppercase input both with and without case-sensitivity, writing output files, and writing different output formats.&#13;
When you think you understand all the options your program must handle, start over:</p>&#13;
&#13;
<pre data-type="programlisting">$ new.py -fp 'Grep through FASTX files' fastx_grep.py&#13;
Done, see new script "fastx_grep.py".</pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Guessing the File Format" data-type="sect2"><div class="sect2" id="idm45963628062472">&#13;
<h2>Guessing the File Format</h2>&#13;
&#13;
<p>If you look at <em>out.fa</em> created in the preceding section, you’ll see it’s in FASTA format, matching the input format, but I never indicated the input file format.<a data-primary="FASTX grep created" data-secondary="file format determination" data-type="indexterm" id="idm45963628060584"/>&#13;
The program intelligently checks the file extension of the input file and guesses at the format using the assumptions in <a data-type="xref" href="#table_16.1">Table 16-1</a>.<a data-primary="FASTA format" data-secondary="file extensions" data-type="indexterm" id="idm45963628058520"/><a data-primary="FASTQ sequence format" data-secondary="file extensions" data-type="indexterm" id="idm45963628057576"/><a data-primary="file extensions" data-type="indexterm" id="idm45963628056632"/>&#13;
Similarly, if no output format is specified, then the input file format is assumed to be the desired output format.&#13;
This is an example of the <em>DWIM</em> principle in software development: Do What I Mean.<a data-primary="DWIM principle (Do What I Mean)" data-type="indexterm" id="idm45963628055192"/></p>&#13;
<table id="table_16.1">&#13;
<caption><span class="label">Table 16-1. </span>Common file extensions for FASTA/Q files</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Extension</th>&#13;
<th>Format</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><em>.fasta</em></p></td>&#13;
<td><p>FASTA</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><em>.fa</em></p></td>&#13;
<td><p>FASTA</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><em>.fna</em></p></td>&#13;
<td><p>FASTA (nucleotides)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><em>.faa</em></p></td>&#13;
<td><p>FASTA (amino acids)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><em>.fq</em></p></td>&#13;
<td><p>FASTQ</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><em>.fastq</em></p></td>&#13;
<td><p>FASTQ</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Your program will similarly need to guess the format of the input files.&#13;
I created a <code>guess_format()</code> function that takes the name of a file and returns a string of either <code>fasta</code> or <code>fastq</code>.&#13;
Here is a stub for the function:</p>&#13;
&#13;
<pre data-type="programlisting">def guess_format(filename: str) -&gt; str:&#13;
    """ Guess format from extension """&#13;
&#13;
    return ''</pre>&#13;
&#13;
<p>Here is the test I wrote.&#13;
After defining the arguments, I would recommend you start with this function.&#13;
Do not proceed until your code passes this:</p>&#13;
&#13;
<pre data-type="programlisting">def test_guess_format() -&gt; None:&#13;
    """ Test guess_format """&#13;
&#13;
    assert guess_format('/foo/bar.fa') == 'fasta'&#13;
    assert guess_format('/foo/bar.fna') == 'fasta'&#13;
    assert guess_format('/foo/bar.faa') == 'fasta'&#13;
    assert guess_format('/foo/bar.fasta') == 'fasta'&#13;
    assert guess_format('/foo/bar.fq') == 'fastq'&#13;
    assert guess_format('/foo/bar.fastq') == 'fastq'&#13;
    assert guess_format('/foo/bar.fx') == ''</pre>&#13;
&#13;
<p>It might help to sketch out how the program should work:</p>&#13;
&#13;
<pre data-type="programlisting">def main():&#13;
    get the program arguments&#13;
&#13;
    for each input file:&#13;
        guess the input format or complain that it can't be guessed&#13;
        figure out the output format from the args or use the input format&#13;
&#13;
        for each record in the input file:&#13;
            if the sequence ID or description matches the pattern:&#13;
                write the sequence to the output file in the output format</pre>&#13;
&#13;
<p>For instance, I can run the program on three input files by using the shell glob <code>*.f[aq]</code> to indicate all the files with an extension starting with the letter <em>f</em> and followed by either <em>a</em> or <em>q</em>:</p>&#13;
&#13;
<pre data-type="programlisting">$ ls tests/inputs/*.f[aq]&#13;
tests/inputs/empty.fa  tests/inputs/lsu.fa    tests/inputs/lsu.fq</pre>&#13;
&#13;
<p>This should write four sequences to the file <em>out.fa</em>:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./fastx_grep.py -O fasta -o out.fa -i lsu tests/inputs/*.f[aq]&#13;
$ ../15_seqmagique/seqmagique.py out.fa&#13;
name      min_len    max_len    avg_len    num_seqs&#13;
out.fa        281        301     291.00           4</pre>&#13;
<div data-type="note" epub:type="note">&#13;
<p>This is a complex program that may take you quite a while to finish. There is value in your struggle, so just keep writing and running the tests, which you should also read to understand how to challenge your program.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect1"><div class="sect1" id="idm45963628027816">&#13;
<h1>Solution</h1>&#13;
&#13;
<p>In my experience, this is a realistically complicated program that captures many patterns I write often.<a data-primary="FASTX grep created" data-secondary="solution" data-type="indexterm" id="ch16-sol"/>&#13;
It starts by validating and processing some number of input files.&#13;
I’m a truly <a data-primary="programmer virtues" data-type="indexterm" id="idm45963628024984"/><a data-primary="Programming Perl (Christiansen et al.)" data-type="indexterm" id="idm45963628024312"/><a data-primary="Christiansen, Tom" data-type="indexterm" id="idm45963628023624"/>lazy programmer<sup><a data-type="noteref" href="ch16.html#idm45963628022792" id="idm45963628022792-marker">2</a></sup> who always wants to give as little information as possible to my programs, so I’m happy to write a little code to guess the file formats <span class="keep-together">for me.</span></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="notoc" data-pdf-bookmark="Guessing the File Format from the File Extension" data-type="sect2"><div class="sect2" id="idm45963628019992">&#13;
<h2>Guessing the File Format from the File Extension</h2>&#13;
&#13;
<p>I’ll start with the function for guessing a file’s format from the file extension:<a data-primary="FASTX grep created" data-secondary="solution" data-tertiary="file format determination" data-type="indexterm" id="idm45963628018328"/><a data-primary="FASTX grep created" data-secondary="file format determination" data-type="indexterm" id="idm45963628017096"/></p>&#13;
&#13;
<pre data-type="programlisting">def guess_format(filename: str) -&gt; str:&#13;
    """ Guess format from extension """&#13;
&#13;
    ext = re.sub('^[.]', '', os.path.splitext(filename)[1]) <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO4-1" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO4-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
    return 'fasta' if re.match('f(ast|a|n)?a$', ext) else 'fastq' if re.match( <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO4-2" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO4-2"><img alt="2" src="assets/2.png"/></a>&#13;
        'f(ast)?q$', ext) else ''</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO4-1" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Use the <code>os.path.splitext()</code> function to get the file extension and remove the leading dot.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO4-2" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Return the string <code>fasta</code> if the extension matches one of the patterns for FASTA files from <a data-type="xref" href="#table_16.1">Table 16-1</a>, <code>fastq</code> if it matches a FASTQ pattern, and the empty string otherwise.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Recall that <code>os.path.splitext()</code> will return both the root of the filename and the extension as a 2-tuple:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import os&#13;
&gt;&gt;&gt; os.path.splitext('/foo/bar.fna')&#13;
('/foo/bar', '.fna')</pre>&#13;
&#13;
<p>Since I’m only interested in the second part, I can use the <code>_</code> to assign the first member of the tuple to a throwaway:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; _, ext = os.path.splitext('/foo/bar.fna')&#13;
&gt;&gt;&gt; ext&#13;
'.fna'</pre>&#13;
&#13;
<p>Instead, I chose to index the tuple to select only the extension:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; ext = os.path.splitext('/foo/bar.fna')[1]&#13;
&gt;&gt;&gt; ext&#13;
'.fna'</pre>&#13;
&#13;
<p>Since I don’t want the leading dot, I could use a string slice to remove this, but this looks cryptic and unreadable to me:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; ext = os.path.splitext('/foo/bar.fna')[1][1:]&#13;
&gt;&gt;&gt; ext&#13;
'fna'</pre>&#13;
&#13;
<p>Instead, I’d prefer to use the <code>re.sub()</code> function I first introduced in <a data-type="xref" href="ch02.html#ch02">Chapter 2</a>.&#13;
The pattern I’m looking for is a literal dot at the beginning of the string.&#13;
The caret <code>^</code> indicates the start of the string, and the <code>.</code> is a metacharacter that means one of anything.&#13;
To show that I want a literal dot, I must either place a backslash in front of it like <code>^\.</code> or place it inside a character class as in <code>^[.]</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import re&#13;
&gt;&gt;&gt; ext = re.sub('^[.]', '', os.path.splitext('/foo/bar.fna')[1]) <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO5-1" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO5-1"><img alt="1" src="assets/1.png"/></a>&#13;
&gt;&gt;&gt; ext&#13;
'fna'</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO5-1" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Use <code>re.sub()</code> to remove a literal dot at the beginning of the file extension.</p></dd>&#13;
</dl>&#13;
&#13;
<p>As shown in <a data-type="xref" href="#table_16.1">Table 16-1</a>, there are four common extensions for FASTA files which I can represent using one compact regular expression.&#13;
Recall that there are two functions in the <code>re</code> module for searching:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>re.match()</code> finds a match from the beginning of a string.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>re.search()</code> finds a match anywhere inside a string.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In this example, I’m using the <code>re.match()</code> function to ensure that the pattern (the first argument) is found at the beginning of the extension (the second argument):</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; re.match('f(ast|a|n)?a$', ext)&#13;
&lt;re.Match object; span=(0, 3), match='fna'&gt;</pre>&#13;
&#13;
<p>To get the same results from <code>re.search()</code>, I would need to use a caret at the beginning to anchor the pattern to the start of the string:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; re.search('^f(ast|a|n)?a$', ext)&#13;
&lt;re.Match object; span=(0, 3), match='fna'&gt;</pre>&#13;
&#13;
<p><a data-type="xref" href="#fig_16.2">Figure 16-2</a> describes each part of the regular expression.</p>&#13;
&#13;
<figure><div class="figure" id="fig_16.2">&#13;
<img alt="mpfb 1602" src="assets/mpfb_1602.png"/>&#13;
<h6><span class="label">Figure 16-2. </span>A regular expression for matching the four FASTA patterns</h6>&#13;
</div></figure>&#13;
&#13;
<p>It may help to see this drawn as a finite state machine diagram, as shown in <a data-type="xref" href="#fig_16.3">Figure 16-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig_16.3">&#13;
<img alt="mpfb 1603" src="assets/mpfb_1603.png"/>&#13;
<h6><span class="label">Figure 16-3. </span>A finite state machine diagram for matching the four FASTA patterns</h6>&#13;
</div></figure>&#13;
&#13;
<p>As there are only two patterns for FASTQ files, the pattern is somewhat simpler:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; re.search('^f(ast)?q$', 'fq')&#13;
&lt;re.Match object; span=(0, 2), match='fq'&gt;&#13;
&gt;&gt;&gt; re.search('^f(ast)?q$', 'fastq')&#13;
&lt;re.Match object; span=(0, 5), match='fastq'&gt;</pre>&#13;
&#13;
<p><a data-type="xref" href="#fig_16.4">Figure 16-4</a> explains this regular expression.</p>&#13;
&#13;
<figure><div class="figure" id="fig_16.4">&#13;
<img alt="mpfb 1604" src="assets/mpfb_1604.png"/>&#13;
<h6><span class="label">Figure 16-4. </span>A regular expression for matching the two FASTQ patterns</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-type="xref" href="#fig_16.5">Figure 16-5</a> shows the same idea expressed as a finite state machine.</p>&#13;
&#13;
<figure><div class="figure" id="fig_16.5">&#13;
<img alt="mpfb 1605" src="assets/mpfb_1605.png"/>&#13;
<h6><span class="label">Figure 16-5. </span>A finite state machine diagram for matching the two FASTQ patterns</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="notoc" data-pdf-bookmark="I Love It When a Plan Comes Together" data-type="sect2"><div class="sect2" id="idm45963627962952">&#13;
<h2>I Love It When a Plan Comes Together</h2>&#13;
&#13;
<p>Following is how I wrote <code>main()</code> using the structure I introduced in the first part of the chapter:<a data-primary="FASTX grep created" data-secondary="solution" data-tertiary="main()" data-type="indexterm" id="idm45963627960856"/></p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    regex = re.compile(args.pattern, re.IGNORECASE if args.insensitive else 0) <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-1" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
    for fh in args.files: <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-2" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-2"><img alt="2" src="assets/2.png"/></a>&#13;
        input_format = args.input_format or guess_format(fh.name) <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-3" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-3"><img alt="3" src="assets/3.png"/></a>&#13;
&#13;
        if not input_format: <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-4" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-4"><img alt="4" src="assets/4.png"/></a>&#13;
            sys.exit(f'Please specify file format for "{fh.name}"')&#13;
&#13;
        output_format = args.output_format or input_format <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-5" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-5"><img alt="5" src="assets/5.png"/></a>&#13;
&#13;
        for rec in SeqIO.parse(fh, input_format): <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-6" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-6"><img alt="6" src="assets/6.png"/></a>&#13;
            if any(map(regex.search, [rec.id, rec.description])): <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-7" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-7"><img alt="7" src="assets/7.png"/></a>&#13;
                SeqIO.write(rec, args.outfile, output_format) <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-8" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-8"><img alt="8" src="assets/8.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-1" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Compile a regular expression to find the given pattern.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-2" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Iterate through the input files.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-3" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Use the input format or guess it from the filename.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-4" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Exit with an error if there is no input file format.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-5" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Use the output format or use the input format.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-6" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Iterate through each sequence in the file.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-7" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>See if either the sequence ID or description matches the pattern.</p></dd>&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-8" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO6-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>If so, write the sequence to the output file.</p></dd>&#13;
</dl>&#13;
&#13;
<p>There are several items I’d like to highlight, and I’ll start with my use of <code>sys.exit()</code> to halt the program in the middle of processing the files if I’m unable to decide on the output file format.<a data-primary="sys.exit() for errors" data-type="indexterm" id="idm45963627918984"/><a data-primary="errors" data-secondary="sys.exit() for halting program" data-type="indexterm" id="idm45963627918312"/><a data-primary="exit status after execution" data-secondary="sys.exit() for errors" data-type="indexterm" id="idm45963627917352"/>&#13;
This is a value I don’t necessarily expect from the user, and one that I’m hoping I can figure out when the program is running.&#13;
If I can’t, then I need to return an error message to the user and an exit value to the operating system to indicate a failure.&#13;
I need the user to start over and correct the missing information before I can continue.</p>&#13;
&#13;
<p>I also want to point out my use of the <code>any()</code> function, which has a corollary in the <code>all()</code> function.<a data-primary="any() function for boolean" data-type="indexterm" id="idm45963627914504"/><a data-primary="booleans" data-secondary="any() function for single from list" data-type="indexterm" id="idm45963627913816"/><a data-primary="all() function for boolean" data-type="indexterm" id="idm45963627912856"/><a data-primary="booleans" data-secondary="all() function for single from list" data-type="indexterm" id="idm45963627912168"/><a data-primary="FASTX grep created" data-secondary="solution" data-tertiary="any() function for boolean" data-type="indexterm" id="idm45963627911208"/><a data-primary="FASTX grep created" data-secondary="solution" data-tertiary="all() function for boolean" data-type="indexterm" id="idm45963627909976"/>&#13;
Both functions reduce a list of truthy values to a single Boolean value.&#13;
The <code>all()</code> function will return <code>True</code> if <em>all</em> the values are truthy, and <code>False</code> otherwise:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; all([True, True, True])&#13;
True&#13;
&gt;&gt;&gt; all([True, False, True])&#13;
False</pre>&#13;
&#13;
<p>While the <code>any()</code> function will return <code>True</code> if <em>any</em> of the values are truthy and <code>False</code> otherwise:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; any([True, False, True])&#13;
True&#13;
&gt;&gt;&gt; any([False, False, False])&#13;
False</pre>&#13;
&#13;
<p>I use this with the compiled regular expression to search the record’s ID and description fields.&#13;
That regex is also using the <code>re.IGNORECASE</code> flag to turn on case-insensitive matching.<a data-primary="regular expressions (regexes)" data-secondary="IGNORECASE flag" data-type="indexterm" id="idm45963627901880"/>&#13;
To explain this, I’d like to go on a tangent into how Python combines Boolean values using <code>and</code> and <code>or</code> and bits using the respective bitwise operators <code>&amp;</code> <span class="keep-together">and <code>|</code></span>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="notoc" data-pdf-bookmark="Combining Regular Expression Search Flags" data-type="sect2"><div class="sect2" id="idm45963627897976">&#13;
<h2>Combining Regular Expression Search Flags</h2>&#13;
&#13;
<p>By default, regular expressions are case-sensitive, but this program needs to handle both case-sensitive and case-insensitive searching.<a data-primary="regular expressions (regexes)" data-secondary="mixed case strings" data-type="indexterm" id="idm45963627896248"/><a data-primary="regular expressions (regexes)" data-secondary="search flags combined" data-type="indexterm" id="ch16-sfcm"/><a data-primary="bit manipulation of flags" data-type="indexterm" id="ch16-sfcm2"/><a data-primary="FASTX grep created" data-secondary="solution" data-tertiary="bit manipulation of flags" data-type="indexterm" id="ch16-sfcm3"/>&#13;
For example, if I search for lowercase <em>lsu</em> but the record header has only uppercase <em>LSU</em>, I would expect this to fail:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import re&#13;
&gt;&gt;&gt; type(re.search('lsu', 'This contains LSU'))&#13;
&lt;class 'NoneType'&gt;</pre>&#13;
&#13;
<p>One way to disregard case is to force both the search pattern and string to uppercase or lowercase:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; re.search('lsu'.upper(), 'This contains LSU'.upper())&#13;
&lt;re.Match object; span=(14, 17), match='LSU'&gt;</pre>&#13;
&#13;
<p>Another method is to provide an optional flag to the <code>re.search()</code> function:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; re.search('lsu', 'This contains LSU', re.IGNORECASE)&#13;
&lt;re.Match object; span=(14, 17), match='LSU'&gt;</pre>&#13;
&#13;
<p>This can be shortened to <code>re.I</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; re.search('lsu', 'This contains LSU', re.I)&#13;
&lt;re.Match object; span=(14, 17), match='LSU'&gt;</pre>&#13;
&#13;
<p>In the program, I use this when I compile the regular expression:</p>&#13;
&#13;
<pre data-type="programlisting">regex = re.compile(args.pattern, re.IGNORECASE if args.insensitive else 0) <a class="co" href="#callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO7-1" id="co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO7-1"><img alt="1" src="assets/1.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO7-1" id="callout_fastx_grep__creating_a_utility_program__span_class__keep_together__to_select_sequences__span__CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>If <code>args.insensitive</code> is <code>True</code>, then use the <code>re.IGNORECASE</code> option when compiling the pattern; otherwise, use <code>0</code>, which means no options.<a data-primary="regular expressions (regexes)" data-secondary="compile() function" data-type="indexterm" id="idm45963627876680"/></p></dd>&#13;
</dl>&#13;
&#13;
<p>I first showed how to compile a regular expression in <a data-type="xref" href="ch11.html#ch11">Chapter 11</a>.&#13;
The advantage is that Python only has to parse the pattern once, which usually makes your code run faster.&#13;
Here I need to decide whether to change to case-insensitive matching using an optional flag.&#13;
I can alter many aspects of the regular expression matching with other such flags, which can be combined using the bitwise or <code>|</code> operator.&#13;
I think it’s best to start with the documentation from <code>help(re)</code>:</p>&#13;
&#13;
<pre data-type="programlisting">Each function other than purge and escape can take an optional 'flags' argument&#13;
consisting of one or more of the following module constants, joined by "|".&#13;
A, L, and U are mutually exclusive.&#13;
    A  ASCII       For string patterns, make \w, \W, \b, \B, \d, \D&#13;
                   match the corresponding ASCII character categories&#13;
                   (rather than the whole Unicode categories, which is the&#13;
                   default).&#13;
                   For bytes patterns, this flag is the only available&#13;
                   behaviour and needn't be specified.&#13;
    I  IGNORECASE  Perform case-insensitive matching.&#13;
    L  LOCALE      Make \w, \W, \b, \B, dependent on the current locale.&#13;
    M  MULTILINE   "^" matches the beginning of lines (after a newline)&#13;
                   as well as the string.&#13;
                   "$" matches the end of lines (before a newline) as well&#13;
                   as the end of the string.&#13;
    S  DOTALL      "." matches any character at all, including the newline.&#13;
    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.&#13;
    U  UNICODE     For compatibility only. Ignored for string patterns (it&#13;
                   is the default), and forbidden for bytes patterns.</pre>&#13;
&#13;
<p>Looking closely, I can find that <code>re.IGNORECASE</code> is an <a href="https://oreil.ly/J6Wsy"><code>enum</code></a> or <em>enumeration</em> of possible values:<a data-primary="regular expressions (regexes)" data-secondary="search flags combined" data-tertiary="enumerations" data-type="indexterm" id="idm45963627868856"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; type(re.IGNORECASE)&#13;
&lt;enum 'RegexFlag'&gt;</pre>&#13;
&#13;
<p>According to the <a href="https://oreil.ly/nONMy">documentation</a>, this is “a subclass of <code>enum.IntFlag</code>,” which is <a href="https://oreil.ly/l1dyG">described thusly</a>:</p>&#13;
<blockquote>&#13;
<p>Base class for creating enumerated constants that can be combined using the bitwise operators without losing their <code>IntFlag</code> membership. <code>IntFlag</code> members are also subclasses of <code>int</code>.</p></blockquote>&#13;
&#13;
<p>This means that <code>re.IGNORECASE</code> is deep down an <code>int</code>, just like <code>False</code> is actually <code>0</code> and <code>True</code> is actually <code>1</code>.<a data-primary="integers (int)" data-secondary="re.IGNORECASE as" data-type="indexterm" id="idm45963627859192"/>&#13;
I used a little detective work to figure out the integer values of the flags by adding <code>0</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; for flag in sorted([re.A, re.I, re.L, re.M, re.S, re.X, re.U]):&#13;
...     print(f'{flag:15} {flag + 0:5} {0 + flag:#011b}')&#13;
...&#13;
re.IGNORECASE       2 0b000000010&#13;
re.LOCALE           4 0b000000100&#13;
re.MULTILINE        8 0b000001000&#13;
re.DOTALL          16 0b000010000&#13;
re.UNICODE         32 0b000100000&#13;
re.VERBOSE         64 0b001000000&#13;
re.ASCII          256 0b100000000</pre>&#13;
&#13;
<p>Note how each value is a power of 2 so that each flag can be represented by a single, unique bit.&#13;
This makes it possible to combine flags using the <code>|</code> operator mentioned in the documentation.<a data-primary="bitwise operators" data-secondary="or (|)" data-type="indexterm" id="idm45963627855432"/><a data-primary="| (bitwise or)" data-primary-sortas="# bitwise or" data-type="indexterm" id="idm45963627854488"/><a data-primary="booleans" data-secondary="bitwise or operator (|)" data-type="indexterm" id="idm45963627853544"/><a data-primary="or, bitwise (|)" data-type="indexterm" id="idm45963627852600"/>&#13;
To demonstrate, I can use the prefix <code>0b</code> to represent a string of raw bytes.&#13;
Here are the binary representations of the numbers 1 and 2.&#13;
Note that each uses just a single bit set to 1:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; one = 0b001&#13;
&gt;&gt;&gt; two = 0b010</pre>&#13;
&#13;
<p>If I use <code>|</code> to <em>or</em> the bits together, each of the three bits is combined using the truth table shown in <a data-type="xref" href="#table_16.2">Table 16-2</a>.</p>&#13;
<table id="table_16.2">&#13;
<caption><span class="label">Table 16-2. </span>Truth table for <em>or</em> (<code>|</code>)</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>First</th>&#13;
<th>Second</th>&#13;
<th>Result</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>T</p></td>&#13;
<td><p>T</p></td>&#13;
<td><p>T</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>T</p></td>&#13;
<td><p>F</p></td>&#13;
<td><p>T</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>F</p></td>&#13;
<td><p>T</p></td>&#13;
<td><p>T</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>F</p></td>&#13;
<td><p>F</p></td>&#13;
<td><p>F</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>As shown in <a data-type="xref" href="#fig_16.6">Figure 16-6</a>, Python will look at each bit and select 1 if either bit is 1, and 0 only if both bits are 0, resulting in <code>0b011</code>, which is the binary representation of the number 3 because the bits for positions 1 and 2 are both set:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; one | two&#13;
3</pre>&#13;
&#13;
<figure><div class="figure" id="fig_16.6">&#13;
<img alt="mpfb 1606" src="assets/mpfb_1606.png"/>&#13;
<h6><span class="label">Figure 16-6. </span>When or-ing each column of bits, a 1 in any position yields a 1; if all bits are 0, the result is 0</h6>&#13;
</div></figure>&#13;
&#13;
<p>When using the <code>&amp;</code> operator, Python will only yield a 1 when both bits are 1; otherwise, it will return 0, as shown in <a data-type="xref" href="#table_16.3">Table 16-3</a>.<a data-primary="bitwise operators" data-secondary="and (&amp;)" data-type="indexterm" id="idm45963627828168"/><a data-primary="and, bitwise (&amp;)" data-type="indexterm" id="idm45963627827224"/><a data-primary="&amp; (bitwise and)" data-primary-sortas="# bitwise and" data-type="indexterm" id="idm45963627826552"/><a data-primary="booleans" data-secondary="bitwise and operator (&amp;)" data-type="indexterm" id="idm45963627825608"/></p>&#13;
<table id="table_16.3">&#13;
<caption><span class="label">Table 16-3. </span>Truth table for and (<code>&amp;</code>)</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>First</th>&#13;
<th>Second</th>&#13;
<th>Result</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>T</p></td>&#13;
<td><p>T</p></td>&#13;
<td><p>T</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>T</p></td>&#13;
<td><p>F</p></td>&#13;
<td><p>F</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>F</p></td>&#13;
<td><p>T</p></td>&#13;
<td><p>F</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>F</p></td>&#13;
<td><p>F</p></td>&#13;
<td><p>F</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Therefore, using <code>&amp;</code> to combine <code>one</code> and <code>two</code> will result in the value <code>0b000</code>, which is the binary representation of 0:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; one &amp; two&#13;
0</pre>&#13;
&#13;
<p>I can use the <code>|</code> operator to join multiple regular expression bitflags.&#13;
For example, <code>re.IGNORECASE</code> is 2, which is represented as <code>0b010</code>, and <code>re.LOCALE</code> is 4, which is represented as <code>0b100</code>.&#13;
Bitwise or combines these as <code>0b110</code>, which is the number 6:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; 0b010 | 0b100&#13;
6</pre>&#13;
&#13;
<p>I can verify that this is true:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; (re.IGNORECASE | re.LOCALE) == 6&#13;
True</pre>&#13;
&#13;
<p>To return to the <code>re.compile()</code> function, the default is to match case:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; regex = re.compile('lsu')&#13;
&gt;&gt;&gt; type(regex.search('This contains LSU'))&#13;
&lt;class 'NoneType'&gt;</pre>&#13;
&#13;
<p>If the user wants case-insensitive searching, then I want to execute something like this:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; regex = re.compile('lsu', re.IGNORECASE)&#13;
&gt;&gt;&gt; regex.search('This contains LSU')&#13;
&lt;re.Match object; span=(14, 17), match='LSU'&gt;</pre>&#13;
&#13;
<p>One way to avoid this would be to use an <code>if</code> statement:</p>&#13;
&#13;
<pre data-type="programlisting">regex = None&#13;
if args.insensitive:&#13;
    regex = re.compile(args.pattern, re.IGNORECASE)&#13;
else:&#13;
    regex = re.compile(args.pattern)</pre>&#13;
&#13;
<p>I dislike this solution as it violates the <em>DRY</em> principle: Don’t Repeat Yourself.<a data-primary="DRY principle (Don’t Repeat Yourself)" data-type="indexterm" id="idm45963627797656"/>&#13;
I can write an <code>if</code> expression to choose either the <code>re.IGNORECASE</code> flag or some default value that means <em>no flags</em>, which turns out to be the number 0:</p>&#13;
&#13;
<pre data-type="programlisting">regex = re.compile(args.pattern, re.IGNORECASE if args.insensitive else 0)</pre>&#13;
&#13;
<p>If I wanted to expand this program to include any of the additional search flags from the documentation, I could use <code>|</code> to combine them.&#13;
Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch06.html#ch06">6</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch12.html#ch12">12</a> talk about the idea of <em>reducing</em> multiple values to a single value.&#13;
For instance, I can use addition to reduce a list of numbers to their sum, or multiplication to create the product, and reduce a list of strings to a single value using the <code>str.join()</code> function.&#13;
I can similarly use bitwise <code>|</code> to reduce all the regex flags:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; (re.A | re.I | re.L | re.M | re.S | re.X | re.U) + 0&#13;
382</pre>&#13;
&#13;
<p>Because these flags use unique bits, it’s possible to find out exactly which flags were used to generate a particular value by using the <code>&amp;</code> operator to determine if a given bit is on.&#13;
For instance, earlier I showed how to combine the flags <code>re.IGNORECASE</code> and <code>re.LOCALE</code> using <code>|</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; flags = re.IGNORECASE | re.LOCALE</pre>&#13;
&#13;
<p>To see if a given flag is present in the <code>flags</code> variable, I use <code>&amp;</code>. It will be returned when I <em>and</em> it because only the 1 bits present in both values will be returned:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; flags &amp; re.IGNORECASE&#13;
re.IGNORECASE</pre>&#13;
&#13;
<p>If I <em>and</em> a flag that’s not present in the combined values, the result is 0:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; (flags &amp; re.VERBOSE) + 0&#13;
0</pre>&#13;
&#13;
<p>That’s a lot of information about combining bits.&#13;
So, if you don’t know, now you know.<a data-startref="ch16-sfcm" data-type="indexterm" id="idm45963627780728"/><a data-startref="ch16-sfcm2" data-type="indexterm" id="idm45963627780056"/><a data-startref="ch16-sfcm3" data-type="indexterm" id="idm45963627779384"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="notoc" data-pdf-bookmark="Reducing Boolean Values" data-type="sect2"><div class="sect2" id="idm45963627778392">&#13;
<h2>Reducing Boolean Values</h2>&#13;
&#13;
<p>I’d like to bring this back to the <code>any()</code> function I used in this program.<a data-primary="FASTX grep created" data-secondary="solution" data-tertiary="any() function for boolean" data-type="indexterm" id="idm45963627776344"/><a data-primary="any() function for boolean" data-type="indexterm" id="idm45963627775112"/><a data-primary="booleans" data-secondary="any() function for single from list" data-type="indexterm" id="idm45963627774424"/>&#13;
As with the bitwise combinations of integer values, I can similarly reduce multiple Boolean values.&#13;
That is, here is the same information as in <a data-type="xref" href="#table_16.2">Table 16-2</a>, using the <code>or</code> operator to combine Booleans:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; True or True&#13;
True&#13;
&gt;&gt;&gt; True or False&#13;
True&#13;
&gt;&gt;&gt; False or True&#13;
True&#13;
&gt;&gt;&gt; False or False&#13;
False</pre>&#13;
&#13;
<p>This is the same as using <code>any()</code> with a list of Booleans.&#13;
If <em>any</em> of the values is truthy, then the whole expression is <code>True</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; any([True, True])&#13;
True&#13;
&gt;&gt;&gt; any([True, False])&#13;
True&#13;
&gt;&gt;&gt; any([False, True])&#13;
True&#13;
&gt;&gt;&gt; any([False, False])&#13;
False</pre>&#13;
&#13;
<p>And here is the same data as in <a data-type="xref" href="#table_16.3">Table 16-3</a>, using <code>and</code> to combine Booleans:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; True and True&#13;
True&#13;
&gt;&gt;&gt; True and False&#13;
False&#13;
&gt;&gt;&gt; False and True&#13;
False&#13;
&gt;&gt;&gt; False and False&#13;
False</pre>&#13;
&#13;
<p>This is the same as using <code>all()</code>.<a data-primary="booleans" data-secondary="all() function for single from list" data-type="indexterm" id="idm45963627764952"/><a data-primary="all() function for boolean" data-type="indexterm" id="idm45963627763992"/><a data-primary="FASTX grep created" data-secondary="solution" data-tertiary="all() function for boolean" data-type="indexterm" id="idm45963627763304"/>&#13;
Only if <em>all</em> of the values are truthy will the whole expression be <code>True</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; all([True, True])&#13;
True&#13;
&gt;&gt;&gt; all([True, False])&#13;
False&#13;
&gt;&gt;&gt; all([False, True])&#13;
False&#13;
&gt;&gt;&gt; all([False, False])&#13;
False</pre>&#13;
&#13;
<p class="pagebreak-before">Here is the line of code where I use this idea:</p>&#13;
&#13;
<pre data-type="programlisting">if any(map(regex.search, [rec.id, rec.description])):</pre>&#13;
&#13;
<p>The <code>map()</code> function feeds each of the <code>rec.id</code> and <code>rec.description</code> values to the <code>regex.search()</code> function, resulting in a list of values that can be interpreted for their truthiness.&#13;
If any of these is truthy—meaning I found a match in at least one of the fields—then <code>any()</code> will return <code>True</code> and the sequence should be written to the output file.<a data-startref="ch16-sol" data-type="indexterm" id="idm45963627755320"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Going Further" data-type="sect1"><div class="sect1" id="idm45963627754168">&#13;
<h1>Going Further</h1>&#13;
&#13;
<p>Sometimes the sequence header contains key/value metadata like “Organism=Oryza sativa.” Add an option to search these values. Be sure you add an input file example to the <em>tests/inputs</em> directory and the appropriate tests to <em>tests/fastx_grep_test.py</em>.</p>&#13;
&#13;
<p>Expand the program to handle additional input sequence formats like GenBank, EMBL, and SwissProt. Again, be sure to add example files and tests to ensure that your program works.</p>&#13;
&#13;
<p>Alter the program to select sequences with some minimum length and quality score.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review" data-type="sect1"><div class="sect1" id="idm45963627750328">&#13;
<h1>Review</h1>&#13;
&#13;
<p>Key points from this chapter:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The FASTQ file format requires each record to be represented by four lines: a header, the sequence, a separator, and the quality scores.</p>&#13;
</li>&#13;
<li>&#13;
<p>Regular expression matches can accept flags that control, for example, whether to perform a case-insensitive match. By default, regexes are case-sensitive.</p>&#13;
</li>&#13;
<li>&#13;
<p>To indicate multiple regex flags, use the <code>|</code> (<em>or</em>) bitwise operator to combine the integer values of the flags.</p>&#13;
</li>&#13;
<li>&#13;
<p>Boolean values can be reduced using <code>and</code> and <code>or</code> operations as well as the <code>any()</code> and <code>all()</code> functions.</p>&#13;
</li>&#13;
<li>&#13;
<p>The DWIM (Do What I Mean) aesthetic means you try to anticipate what your user would want a program to do naturally and intelligently.</p>&#13;
</li>&#13;
<li>&#13;
<p>The DRY (Don’t Repeat Yourself) principle means that you never duplicate the same idea in your code but rather isolate it to one locus or function.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45963628251688"><sup><a href="ch16.html#idm45963628251688-marker">1</a></sup> Some say this is short for <em>global regular expression print</em>.</p><p data-type="footnote" id="idm45963628022792"><sup><a href="ch16.html#idm45963628022792-marker">2</a></sup> According to <a class="orm:hideurl" href="https://oreil.ly/XnvaC"><em>Programming Perl</em></a> by Tom Christiansen et al. (O’Reilly, 2012), the three great virtues of a programmer are laziness, impatience, and hubris.</p></div></div></section></body></html>