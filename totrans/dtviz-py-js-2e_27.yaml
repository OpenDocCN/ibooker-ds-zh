- en: Chapter 21\. The Menu Bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapters showed how to build the visual components of our interactive
    Nobel Prize visualization, the time chart to display all Nobel Prize winners by
    year, a map to show geographic distributions, a list to display the currently
    selected winners, and a bar chart to compare absolute and per capita wins by country.
    In this chapter, we will see how the user interacts with the visualization by
    using selectors and buttons (see [Figure 21-1](#ui_target)) to create a filtered
    dataset that is then reflected by the visual components. For example, selecting
    Physics in the category-select box filters will display only Physics prize winners
    in the Nobel Prize visualization (Nobel-viz) elements. The filters in our menu
    bar are cumulative, so we can, for example, select only those female chemists
    from France to have won the Nobel Prize.^([1](ch21.xhtml#idm45607736427392))
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 2101](assets/dpj2_2101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-1\. This chapter’s target menu bar
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the sections ahead, I will show you how to use D3 to build the menu bar and
    how JavaScript callbacks are used to respond to user-driven changes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating HTML Elements with D3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many people think of D3 as a specialized tool for creating SVG visualizations
    composed of graphical primitives such as lines and circles. Though D3 is great
    for this (the best there is), it’s equally at home creating conventional HTML
    elements such as tables or selector boxes. For tricky, data-driven HTML complexes
    like hierarchical menus, D3’s nested data-joins are an ideal way to create the
    DOM elements and the callbacks to deal with user selections.
  prefs: []
  type: TYPE_NORMAL
- en: We saw in [Chapter 20](ch20.xhtml#chapter_d3_bios) how easy it is to create
    `table` rows from a selected dataset or fill in the details of a biography box
    with a winner’s data. In this chapter, we’ll show how to populate selectors with
    options based on changing datasets and how to attach callback functions to user
    interface elements such as selectors and radio boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you have stable HTML elements (e.g., a select box whose options are not dependent
    on changing data), it’s best to write them in HTML and then use D3 to attach any
    callback functions you need to deal with user input. As with CSS styling, you
    should do as much as possible in vanilla HTML. It keeps the codebase cleaner and
    is easier to understand by other devs and non-devs. In this chapter, I stretch
    this rule a bit to demonstrate the creation of HTML elements, but it’s pretty
    much always the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Menu Bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in [“The HTML Skeleton”](ch16.xhtml#html_skeleton), our Nobel-viz
    is built on HTML `<div>` placeholders, fleshed out with JavaScript and D3\. As
    shown in [Example 21-1](#d3menu_skeleton), our menu bar is built on the `nobel-menu`
    `<div>`, placed above the main chart holder, and consists of three selector filters
    (by the winners’ category, gender, and country) and a couple of radio buttons
    to select the country prize-winning metric (absolute or per capita).
  prefs: []
  type: TYPE_NORMAL
- en: Example 21-1\. The HTML skeleton for the menu bar
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now we’ll add the UI elements in turn, starting with the selector filters.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Category Selector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to build the category selector, we’re going to need a list of option
    strings. Let’s create that list using the `CATEGORIES` list defined in *nbviz_core.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_the_menu_bar_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates the category selector’s list `['All Categories', 'Chemistry', 'Economics',
    …​ ]` by concatenating the list `['All Categories']` and the list `['Chemistry',
    'Economics', …​ ]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re now going to use this category list to make the options tags. We’ll first
    use D3 to grab the `#cat-select` select tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With `catSelect` to hand, let’s use a standard D3 data-join to turn our `catList`
    list of categories into HTML `option` tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_the_menu_bar_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: After data binding, append an `option` for each `catList` member.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_the_menu_bar_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We are setting the `option`’s `value` attribute and text to a category (e.g.,
    `<option value="Peace">Peace</option>`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the preceding `append` operations is the following `cat-select`
    DOM element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our selector, we can use D3’s `on` method to attach an event-handler
    callback function, triggered when the selector is changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_the_menu_bar_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`this` is the select tag, with the `value` property as the selected category
    option.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_the_menu_bar_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We call the `filterByCategory` method defined in *nbviz_core.js* to filter our
    dataset for prizes in the category selected.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_the_menu_bar_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`onDataChange` triggers the visual-component update methods that will change
    to reflect our newly filtered dataset.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 21-2](#d3ui_select) is a schematic of our select callback. Selecting
    Physics calls the anonymous callback function attached to our selector’s change
    event. This function initiates the update of the Nobel-viz’s visual elements.'
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 2102](assets/dpj2_2102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-2\. The category select callback
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Within the category selector’s callback, we first call the `filterByCategory`
    method^([2](ch21.xhtml#idm45607735804864)) to select only the Physics winners
    and the `onDataChange` method to trigger an update of all the visual components.
    Where applicable, these will reflect the changed data. For example, the map’s
    distribution circular indicators will resize, vanishing in the case of countries
    with no Nobel Physics winners.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Gender Selector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already added the HTML for our gender selector and its options, in
    the menu bar’s description in *index.xhtml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'All we need to do now is select the gender `select` tag and add a callback
    function to handle user selections. We can easily achieve this using D3’s `on`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_the_menu_bar_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Calling the gender dimension’s filter without an argument resets it to allow
    all genders.
  prefs: []
  type: TYPE_NORMAL
- en: First, we select the selector’s option value. We then use this value to filter
    the current dataset. Finally, we call `onDataChange` to trigger any changes to
    the Nobel-viz’s visual components caused by the new dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'To place the gender `select` tag, we use a little CSS, giving it a left margin
    of 20 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Adding the Country Selector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding the country selector is a little more involved than adding those of category
    and gender. The distribution of Nobel Prizes by country has a long tail (see [Figure 17-1](ch17.xhtml#target_barchart)),
    with lots of countries having one or two prizes. We could include all of these
    in our selector, but it would make it rather long and cumbersome. A better way
    is to add groups for the single- and double-winning countries, keeping the number
    of select options manageable and adding a little narrative to the chart, namely
    the distributions of small winners over time, which might conceivably say something
    about changing trends in the Nobel Prize award allocation.^([3](ch21.xhtml#idm45607735600416))
  prefs: []
  type: TYPE_NORMAL
- en: In order to add our single- and double-country winner groups, we will need the
    crossfiltered country dimension to get the group sizes by country. This means
    creating the country selector after our Nobel Prize dataset has loaded. To do
    this, we put it in an `nbviz.initUI` method, called in our main *nbviz_main.js*
    script after the crossfilter dimensions have been created (see [“Filtering Data
    with Crossfilter”](ch16.xhtml#crossfilter)).
  prefs: []
  type: TYPE_NORMAL
- en: The following code creates a selection list. Countries with three or more winners
    get their own selection slot, below the All Winners selection. Single- and double-country
    winners are added to their respective lists, which will be used to filter the
    dataset if the user selects the Single Winning Countries or Double Winning Countries
    from the selector’s options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_the_menu_bar_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sorted group array of form (`{key:"United States", value:336}, …​`) where `value`
    is the number of winners from that country.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_the_menu_bar_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: An object with lists to store single and double winners.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_the_menu_bar_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Countries with more than two winners get their own slot in the `selectData`
    list.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_the_menu_bar_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Single- and double-winning countries are added to their respective lists based
    on the group size (value) of 1 or 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our `selectData` list with corresponding `fewWinners` arrays,
    we can use it to create the options for our country selector. We first use D3
    to grab the country selector’s `select` tag and then add the options to it using
    standard data binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With our `selectData` options appended, the selector looks like [Figure 21-3](#d3ui_nats_select).
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 2103](assets/dpj2_2103.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-3\. Selector for prizes by country
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now all we need is a callback function, triggered when an option is selected,
    to filter our main dataset by country. The following code shows how it’s done.
    First, we get the select’s `value` property (1), a country or one of `ALL_WINNERS`,
    `DOUBLE_WINNERS`, or `SINGLE_WINNERS`. We then construct a list of countries to
    send to our national filter method, `nbviz.filterByCountries` (defined in *nbviz_core.js*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_the_menu_bar_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: These conditionals make a `countries` array, depending on the `country` string.
    This array is empty, single-valued, or with one of `fewWinners` arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_the_menu_bar_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Calls `filterByCountries` to filter our main Nobel-winners dataset using the
    array of countries.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_the_menu_bar_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Triggers an update to all the Nobel-viz’s elements.
  prefs: []
  type: TYPE_NORMAL
- en: The `filterByCountries` function is shown in [Example 21-2](#d3ui_filter_by_countries).
    An empty `countryNames` argument resets the filter; otherwise, we filter the country
    dimension `countryDim` for all those countries in `countryNames` ![1](assets/1.png).
  prefs: []
  type: TYPE_NORMAL
- en: Example 21-2\. Filter by countries function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_the_menu_bar_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Resets the filter if the `countryNames` array is empty (the user chose All Countries).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_the_menu_bar_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we create a filter function on our `crossfilter` country dimension, which
    returns `true` if a country is in the `countryNames` list (containing either a
    single country or all single or double winners).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_the_menu_bar_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Keeps a record of any single selected country in order—for example, to highlight
    it in the map and bar chart.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve built the filter selectors for our category, gender, and country
    dimensions, all we need to do is add the callback function to deal with changes
    to the prize-winning metric radio button.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring Up the Metric Radio Button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The metric radio button has already been built in HTML, consisting of a form
    with `radio` inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_the_menu_bar_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`&nbsp;` is used to create a nonbreaking space between the form and its label.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_the_menu_bar_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Inputs of type `radio` sharing the same name (`mode`, in this case) are grouped
    together, and activating one deactivates all others. They are differentiated by
    value (`0` and `1` in this case). Here we use the `checked` attribute to activate
    value `0` initially.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the radio button form in place, we need only select all its inputs and
    add a callback function to deal with any button presses triggering a change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_the_menu_bar_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Update the value of `valuePerCapita` before calling `onDataChange` and triggering
    a redraw of the visual elements.
  prefs: []
  type: TYPE_NORMAL
- en: We are storing the current state of the button with our `valuePerCapita` integer.
    When the user selects a radio box, this value is changed and a redraw with the
    new metric is triggered with `onDataChange`.
  prefs: []
  type: TYPE_NORMAL
- en: We now have the menu bar elements to our Nobel-viz, allowing users to refine
    the displayed dataset and drill down to subsets they are most curious about.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to add selectors and radio-button elements to our
    Nobel Prize visualization. There are a number of other user interface HTML tags,
    such as button groups, groups of checkboxes, time pickers, and plain buttons.^([4](ch21.xhtml#idm45607734742848))
    But implementing these controllers involves the same patterns as shown in this
    chapter. A list of data is used to append and insert DOM elements, setting properties
    where appropriate, and callback functions are bound to any change events. This
    is a very powerful method that plays very well with such D3 (and JS) idioms as
    method chaining and anonymous functions. It will quickly become a very natural
    part of your D3 workflow.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch21.xhtml#idm45607736427392-marker)) Remarkably, Marie Curie and her
    daughter Irène Joliot-Curie hold this distinction.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch21.xhtml#idm45607735804864-marker)) Defined in the *nbviz_core.js* script.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch21.xhtml#idm45607735600416-marker)) It does show that among single winners,
    the Nobel Prize for Peace predominates, followed by Literature.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch21.xhtml#idm45607734742848-marker)) There are also native sliders in
    HTML5, where before one relied on jQuery plug-ins.
  prefs: []
  type: TYPE_NORMAL
