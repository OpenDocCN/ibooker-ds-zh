- en: Chapter 1\. Getting Started in IPython and Jupyter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In writing Python code for data science, I generally go between three modes
    of working: I use the IPython shell for trying out short sequences of commands,
    the Jupyter Notebook for longer interactive analysis and for sharing content with
    others, and interactive development environments (IDEs) like Emacs or VSCode for
    creating reusable Python packages. This chapter focuses on the first two modes:
    the IPython shell and the Jupyter Notebook. Use of an IDE for software development
    is an important third tool in the data scientist’s repertoire, but we will not
    directly address that here.'
  prefs: []
  type: TYPE_NORMAL
- en: Launching the IPython Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The text in this part, like most of this book, is not designed to be absorbed
    passively. I recommend that as you read through it, you follow along and experiment
    with the tools and syntax we cover: the muscle memory you build through doing
    this will be far more useful than the simple act of reading about it. Start by
    launching the IPython interpreter by typing **`ipython`** on the command line;
    alternatively, if you’ve installed a distribution like Anaconda or EPD, there
    may be a launcher specific to your system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you do this, you should see a prompt like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With that, you’re ready to follow along.
  prefs: []
  type: TYPE_NORMAL
- en: Launching the Jupyter Notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Jupyter Notebook is a browser-based graphical interface to the IPython shell,
    and builds on it a rich set of dynamic display capabilities. As well as executing
    Python/IPython statements, notebooks allow the user to include formatted text,
    static and dynamic visualizations, mathematical equations, JavaScript widgets,
    and much more. Furthermore, these documents can be saved in a way that lets other
    people open them and execute the code on their own systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though you’ll view and edit Jupyter notebooks through your web browser window,
    they must connect to a running Python process in order to execute code. You can
    start this process (known as a “kernel”) by running the following command in your
    system shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This command launches a local web server that will be visible to your browser.
    It immediately spits out a log showing what it is doing; that log will look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Upon issuing the command, your default browser should automatically open and
    navigate to the listed local URL; the exact address will depend on your system.
    If the browser does not open automatically, you can open a window and manually
    open this address (*http://localhost:8888/lab/* in this example).
  prefs: []
  type: TYPE_NORMAL
- en: Help and Documentation in IPython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you read no other section in this chapter, read this one: I find the tools
    discussed here to be the most transformative contributions of IPython to my daily
    workflow.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a technologically minded person is asked to help a friend, family member,
    or colleague with a computer problem, most of the time it’s less a matter of knowing
    the answer than of knowing how to quickly find an unknown answer. In data science
    it’s the same: searchable web resources such as online documentation, mailing
    list threads, and Stack Overflow answers contain a wealth of information, even
    (especially?) about topics you’ve found yourself searching on before. Being an
    effective practitioner of data science is less about memorizing the tool or command
    you should use for every possible situation, and more about learning to effectively
    find the information you don’t know, whether through a web search engine or another
    means.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most useful functions of IPython/Jupyter is to shorten the gap between
    the user and the type of documentation and search that will help them do their
    work effectively. While web searches still play a role in answering complicated
    questions, an amazing amount of information can be found through IPython alone.
    Some examples of the questions IPython can help answer in a few keystrokes include:'
  prefs: []
  type: TYPE_NORMAL
- en: How do I call this function? What arguments and options does it have?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does the source code of this Python object look like?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is in this package I imported?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What attributes or methods does this object have?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here we’ll discuss the tools provided in the IPython shell and Jupyter Notebook
    to quickly access this information, namely the `?` character to explore documentation,
    the `??` characters to explore source code, and the Tab key for autocompletion.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Documentation with ?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python language and its data science ecosystem are built with the user
    in mind, and one big part of that is access to documentation. Every Python object
    contains a reference to a string, known as a *docstring*, which in most cases
    will contain a concise summary of the object and how to use it. Python has a built-in
    `help` function that can access this information and print the results. For example,
    to see the documentation of the built-in `len` function, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Depending on your interpreter, this information may be displayed as inline text
    or in a separate pop-up window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because finding help on an object is so common and useful, IPython and Jupyter
    introduce the `?` character as a shorthand for accessing this documentation and
    other relevant information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This notation works for just about anything, including object methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'or even objects themselves, with the documentation from their type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Importantly, this will even work for functions or other objects you create
    yourself! Here we’ll define a small function with a docstring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that to create a docstring for our function, we simply placed a string
    literal in the first line. Because docstrings are usually multiple lines, by convention
    we used Python’s triple-quote notation for multiline strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll use the `?` to find this docstring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This quick access to documentation via docstrings is one reason you should get
    in the habit of always adding such inline documentation to the code you write.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Source Code with ??
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because the Python language is so easily readable, another level of insight
    can usually be gained by reading the source code of the object you’re curious
    about. IPython and Jupyter provide a shortcut to the source code with the double
    question mark (`??`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For simple functions like this, the double question mark can give quick insight
    into the under-the-hood details.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you play with this much, you’ll notice that sometimes the `??` suffix doesn’t
    display any source code: this is generally because the object in question is not
    implemented in Python, but in C or some other compiled extension language. If
    this is the case, the `??` suffix gives the same output as the `?` suffix. You’ll
    find this particularly with many of Python’s built-in objects and types, including
    the `len` function from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using `?` and/or `??` is a powerful and quick way of finding information about
    what any Python function or module does.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Modules with Tab Completion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another useful interface is the use of the Tab key for autocompletion and exploration
    of the contents of objects, modules, and namespaces. In the examples that follow,
    I’ll use `<TAB>` to indicate when the Tab key should be pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Tab completion of object contents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every Python object has various attributes and methods associated with it.
    Like the `help` function mentioned earlier, Python has a built-in `dir` function
    that returns a list of these, but the tab-completion interface is much easier
    to use in practice. To see a list of all available attributes of an object, you
    can type the name of the object followed by a period (`.`) character and the Tab
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To narrow down the list, you can type the first character or several characters
    of the name, and the Tab key will find the matching attributes and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is only a single option, pressing the Tab key will complete the line
    for you. For example, the following will instantly be replaced with `L.count`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Though Python has no strictly enforced distinction between public/external
    attributes and private/internal attributes, by convention a preceding underscore
    is used to denote the latter. For clarity, these private methods and special methods
    are omitted from the list by default, but it’s possible to list them by explicitly
    typing the underscore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For brevity, I’ve only shown the first few columns of the output. Most of these
    are Python’s special double-underscore methods (often nicknamed “dunder” methods).
  prefs: []
  type: TYPE_NORMAL
- en: Tab completion when importing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tab completion is also useful when importing objects from packages. Here we’ll
    use it to find all possible imports in the `itertools` package that start with
    `co`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can use tab-completion to see which imports are available on
    your system (this will change depending on which third-party scripts and modules
    are visible to your Python session):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Beyond tab completion: Wildcard matching'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tab completion is useful if you know the first few characters of the name of
    the object or attribute you’re looking for, but is little help if you’d like to
    match characters in the middle or at the end of the name. For this use case, IPython
    and Jupyter provide a means of wildcard matching for names using the `*` character.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can use this to list every object in the namespace whose name
    ends with `Warning`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `*` character matches any string, including the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, suppose we are looking for a string method that contains the word
    `find` somewhere in its name. We can search for it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: I find this type of flexible wildcard search can be useful for finding a particular
    command when getting to know a new package or reacquainting myself with a familiar
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Keyboard Shortcuts in the IPython Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you spend any amount of time on a computer, you’ve probably found a use
    for keyboard shortcuts in your workflow. Most familiar perhaps are Cmd-c and Cmd-v
    (or Ctrl-c and Ctrl-v), used for copying and pasting in a wide variety of programs
    and systems. Power users tend to go even further: popular text editors like Emacs,
    Vim, and others provide users an incredible range of operations through intricate
    combinations of keystrokes.'
  prefs: []
  type: TYPE_NORMAL
- en: The IPython shell doesn’t go this far, but does provide a number of keyboard
    shortcuts for fast navigation while typing commands. While some of these shortcuts
    do work in the browser-based notebooks, this section is primarily about shortcuts
    in the IPython shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you get accustomed to these, they can be very useful for quickly performing
    certain commands without moving your hands from the “home” keyboard position.
    If you’re an Emacs user or if you have experience with Linux-style shells, the
    following will be very familiar. I’ll group these shortcuts into a few categories:
    *navigation shortcuts*, *text entry shortcuts*, *command history shortcuts*, and
    *miscellaneous shortcuts*.'
  prefs: []
  type: TYPE_NORMAL
- en: Navigation Shortcuts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the use of the left and right arrow keys to move backward and forward
    in the line is quite obvious, there are other options that don’t require moving
    your hands from the “home” keyboard position:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Keystroke | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-a | Move cursor to beginning of line |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-e | Move cursor to end of the line |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-b or the left arrow key | Move cursor back one character |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-f or the right arrow key | Move cursor forward one character |'
  prefs: []
  type: TYPE_TB
- en: Text Entry Shortcuts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While everyone is familiar with using the Backspace key to delete the previous
    character, reaching for the key often requires some minor finger gymnastics, and
    it only deletes a single character at a time. In IPython there are several shortcuts
    for removing some portion of the text you’re typing; the most immediately useful
    of these are the commands to delete entire lines of text. You’ll know these have
    become second-nature if you find yourself using a combination of Ctrl-b and Ctrl-d
    instead of reaching for Backspace to delete the previous character!
  prefs: []
  type: TYPE_NORMAL
- en: '| Keystroke | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Backspace key | Delete previous character in line |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-d | Delete next character in line |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-k | Cut text from cursor to end of line |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-u | Cut text from beginning of line to cursor |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-y | Yank (i.e., paste) text that was previously cut |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-t | Transpose (i.e., switch) previous two characters |'
  prefs: []
  type: TYPE_TB
- en: Command History Shortcuts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perhaps the most impactful shortcuts discussed here are the ones IPython provides
    for navigating the command history. This command history goes beyond your current
    IPython session: your entire command history is stored in a SQLite database in
    your IPython profile directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most straightforward way to access previous commands is by using the up
    and down arrow keys to step through the history, but other options exist as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Keystroke | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-p (or the up arrow key) | Access previous command in history |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-n (or the down arrow key) | Access next command in history |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-r | Reverse-search through command history |'
  prefs: []
  type: TYPE_TB
- en: 'The reverse-search option can be particularly useful. Recall that earlier we
    defined a function called `square`. Let’s reverse-search our Python history from
    a new IPython shell and find this definition again. When you press Ctrl-r in the
    IPython terminal, you’ll see the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you start typing characters at this prompt, IPython will autofill the most
    recent command, if any, that matches those characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'At any point, you can add more characters to refine the search, or press Ctrl-r
    again to search further for another command that matches the query. If you followed
    along earlier, pressing Ctrl-r twice more gives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have found the command you’re looking for, press Return and the search
    will end. You can then use the retrieved command and carry on with your session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that you can use Ctrl-p/Ctrl-n or the up/down arrow keys to search through
    your history in a similar way, but only by matching characters at the beginning
    of the line. That is, if you type **`def`** and then press Ctrl-p, it will find
    the most recent command (if any) in your history that begins with the characters
    `def`.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous Shortcuts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, there are a few miscellaneous shortcuts that don’t fit into any of
    the preceding categories, but are nevertheless useful to know:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Keystroke | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-l | Clear terminal screen |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-c | Interrupt current Python command |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-d | Exit IPython session |'
  prefs: []
  type: TYPE_TB
- en: The Ctrl-c shortcut in particular can be useful when you inadvertently start
    a very long-running job.
  prefs: []
  type: TYPE_NORMAL
- en: While some of the shortcuts discussed here may seem a bit obscure at first,
    they quickly become automatic with practice. Once you develop that muscle memory,
    I suspect you will even find yourself wishing they were available in other contexts.
  prefs: []
  type: TYPE_NORMAL
