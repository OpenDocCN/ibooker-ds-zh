- en: 'Chapter 13\. Location Restriction Sites: Using, Testing, and Sharing Code'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *palindromic* sequence in DNA is one in which the 5’ to 3’ base pair sequence
    is identical on both strands. For example, [Figure 13-1](#fig_13.1) shows that
    the reverse complement of the DNA sequence *GCATGC* is the sequence itself.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1301](assets/mpfb_1301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-1\. A reverse palindrome is equal to its reverse complement
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'I can verify this in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As described in [the Rosalind REVP challenge](https://oreil.ly/w3Tdm), restriction
    enzymes recognize and cut within specific palindromic sequences of DNA known as
    restriction sites. They typically have a length of between 4 and 12 nucleotides.
    The goal of this exercise is to find the locations in a DNA sequence of every
    putative restriction enzyme. The code to solve this problem could be massively
    complicated, but a clear understanding of some functional programming techniques
    helps to create a short, elegant solution. I will explore `map()`, `zip()`, and
    `enumerate()` as well as many small, tested functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to find a reverse palindrome
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create modules to share common functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About the `PYTHONPATH` environment variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code and tests for this exercise are in the *13_revp* directory. Start
    by copying a solution to the program `revp.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspect the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The only required argument is a single positional file of FASTA-formatted DNA
    sequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the first test input file. The contents are identical to the
    example on the Rosalind page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with this input and verify that you see the position (using
    1-based counting) and length of every reverse palindrome in the string having
    a length between 4 and 12, as illustrated in [Figure 13-2](#fig_13.2). Note that
    the order of the results is unimportant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![mpfb 1302](assets/mpfb_1302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-2\. The locations of the eight reverse palindromes found in the sequence
    *TCAATGCATGCGGGTCTATATGCAT*.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Run the tests to verify that the program passes, then start over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a way to define the program’s parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The only parameter is a file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Define a parameter that must be a readable text file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have the `main()` function print the input filename for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Manually verify that the program will produce the correct usage, will reject
    bogus files, and will print a valid input’s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Run **`make test`** and you should find you pass some tests. Now you’re ready
    to write the bones of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Finding All Subsequences Using K-mers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is to read the sequences from the FASTA input file. I can use
    `SeqIO.parse()` to create a lazy iterator and then use `next()` to get the first
    sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is unsafe to use if the file is empty, such as *tests/inputs/empty.fa*.
    If you try to open this file in the same way and call `next()`, Python will raise
    a `StopIteration` exception. In your code, I recommend you use a `for` loop that
    detects the exhaustion of the iterator and gracefully exits.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'I need to find all the sequences between 4 and 12 bases long. This sounds like
    another job for k-mers, so I’ll bring in the `find_kmers()` function from [Chapter 9](ch09.html#ch09):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'I can use `range()` to generate all the numbers between 4 and 12, remembering
    that the end position is not included so I have to go up to 13. As there are many
    k-mers for each `k`, I’ll print the value of `k` and how many k-mers are found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Finding All Reverse Complements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I showed many ways to find the reverse complement in [Chapter 3](ch03.html#ch03),
    with the conclusion that `Bio.Seq.reverse_complement()` is probably the easiest
    method. Start by finding all the 12-mers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a list of the reverse complements, you could use a list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Or use `map()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Either way, you should have 12 reverse complements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Putting It All Together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should have just about everything you need to complete this challenge. First,
    pair all the k-mers with their reverse complements, find those that are the same,
    and print their positions. You could iterate through them with a `for` loop, or
    you might consider using the `zip()` function that we first looked at in [Chapter 6](ch06.html#ch06)
    to create the pairs. This is an interesting challenge, and I’m sure you can figure
    out a working solution before you read my versions.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’ll show three variations to find the restriction sites, which increasingly
    rely on functions to hide the complexities of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 1: Using the zip() and enumerate() Functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In my first solution, I first use `zip()` to pair the k-mers and reverse complements.
    Assume `k=4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'I also need to know the positions of the pairs, which I can get from `enumerate()`.
    If I inspect the pairs, I see that some of them (4, 6, 16, 17, and 20) are the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'I can use a list comprehension with a guard to find all the positions where
    the pairs are the same. Note I add 1 to the index values to get 1-based positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 11](ch11.html#ch11), I introduced the functions `fst()` and `snd()`
    for getting the first or second elements from a 2-tuple. I’d like to use those
    here so I don’t have to use indexing with the tuples. I also keep using the `find_kmers()`
    function from previous chapters. It seems like it’s time to put these functions
    into a separate module so I can import them as needed rather than copying them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you inspect the `common.py` module, you’ll see these functions and their
    tests. I can run `pytest` to ensure they all pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `common.py` is in the current directory, I can import any functions
    I like from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how I incorporated these ideas in the first solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate over the records in the FASTA file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through all the values of `k`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Find the k-mers for this `k`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Find the reverse complements of the k-mers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through the positions and pairs of k-mer/reverse complement.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Check if the first element of the pair is the same as the second element.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the position plus 1 (to correct for 0-based indexing) and the size of
    the sequence `k`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 2: Using the operator.eq() Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though I like the `fst()` and `snd()` functions and want to highlight how to
    share modules and functions, I’m duplicating the `operator.eq()` function. I first
    introduced this module in [Chapter 6](ch06.html#ch06) to use the `operator.ne()`
    (not equal) function, and I’ve also used the `operator.le()` (less than or equal)
    and `operator.add()` functions elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can rewrite part of the preceding solution like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the functional version of the `==` operator to compare the elements of the
    pair. Note the need to splat the pair to expand the tuple into its two values.
  prefs: []
  type: TYPE_NORMAL
- en: 'I prefer a list comprehension with a guard to condense this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use a guard for the equality comparison, and correct the position inside a list
    comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 3: Writing a revp() Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this final solution, it behooves me to write a `revp()` function and create
    a test. This will make the program more readable and will also make it easier
    to move this function into something like the `common.py` module for sharing in
    other projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, I imagine the signature of my function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: I want to pass in a sequence and a value for `k` to get back a list of locations
    where reverse palindromes of the given size are found.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: For now, return the empty list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the test I wrote. Note that I decided that the function should correct
    the indexes to 1-based counting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If I add these to my `revp.py` program and run `pytest revp.py`, I’ll see that
    the test fails as it should. Now I can fill in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If I run `pytest` again, I should get a passing test. The `main()` function
    is now more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through each value of `k`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through each reverse palindrome of size `k` found in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the position and size of the reverse palindrome.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that it’s possible to use more than one iterator inside a list comprehension.
    I can collapse the two `for` loops into a single one, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: First iterate the `k` values, then use those to iterate the `revp()` values,
    returning both as a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'I would probably not use this construct. It reminds me of my old coworker,
    Joe, who would joke: “If it was hard to write, it should be hard to read!”'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’d like to take a moment to look at the integration test in *tests/revp_test.py*.
    The first two tests are always the same, checking for the existence of the expected
    program and that the program will produce some usage statement when requested.
    For a program that accepts files as inputs such as this one, I include a test
    that the program rejects an invalid file. I usually challenge other inputs too,
    like passing strings when integers are expected, to ensure the arguments are rejected.
  prefs: []
  type: TYPE_NORMAL
- en: 'After I’ve checked that the arguments to the program are all validated, I start
    passing good input values to see that the program works as expected. This requires
    that I use valid, known input and verify that the program produces the correct,
    expected output. In this case, I encode the inputs and outputs using files in
    the *tests/inputs* directory. For instance, the expected output for the input
    file *1.fa* is found in *1.fa.out*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the first input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'and the expected output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The second input file is significantly larger than the first. This is common
    with the Rosalind problems, and so it would be ugly to try to include the input
    and output values as literal strings in the test program. The expected output
    for the second file is 70 lines long. The last test is for an empty file, and
    the expected output is the empty string. While that may seem obvious, the point
    is to check that the program does not throw an exception on an empty input file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *tests/revp_test.py*, I wrote a `run()` helper function that takes the name
    of the input file, reads the expected output filename, and runs the program with
    the input to check the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The function takes the name of the input file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The output file is the name of the input file plus *.out*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the output file exists.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Run the program with the input file and capture the return value and output.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the program reported a successful run.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Read the expected output file, breaking the contents on lines and creating a
    set of the resulting strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Break the output of the program on lines and create a set to compare to the
    expected results. Sets allow me to disregard the order of the lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'This simplifies the tests. Note that the `INPUT*` and `EMPTY` variables are
    declared at the top of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: I would encourage you to spend some time reading the **_test.py* files for every
    program. I hope that you will integrate testing into your development workflow,
    and I’m sure you can find ample code to copy from my tests, which will save you
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Going Further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The minimum (4) and maximum (12) values for the length of the sites are hardcoded
    in the program. Add command-line parameters to pass these as integer options using
    those default values. Change the code to use the given values, and add tests to
    ensure the correct sites are found for different ranges of these values.
  prefs: []
  type: TYPE_NORMAL
- en: Write a program that can identify English palindromes such as “A man, a plan,
    a canal—Panama!” Start by creating a new repository. Find several interesting
    palindromes to use in your tests. Be sure to provide phrases that are not palindromes
    and verify that your algorithm rejects those, too. Release your code to the internet,
    and reap the fame, glory, and profit of writing open source software.
  prefs: []
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Key points from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You can reuse functions by placing them into a module and importing them as
    needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PYTHONPATH` environment variable indicates directories which Python should
    search when looking for modules of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
