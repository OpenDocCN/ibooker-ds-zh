- en: 'Chapter 18\. FASTX Sampler: Randomly Subsampling Sequence Files'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第18章. FASTX Sampler：随机子抽样序列文件
- en: Sequence datasets in genomics and metagenomics can get dauntingly large, requiring
    copious time and compute resources to analyze. Many sequencers can produce tens
    of millions of reads per sample, and many experiments involve tens to hundreds
    of samples, each with multiple technical replicates resulting in gigabytes to
    terabytes of data. Reducing the size of the input files by randomly subsampling
    sequences allows you to explore data more quickly. In this chapter, I will show
    how to use Python’s `random` module to select some portion of the reads from FASTA/FASTQ
    sequence files.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在基因组学和宏基因组学中，序列数据集可能会变得非常庞大，需要大量时间和计算资源来进行分析。许多测序仪每个样本可以生成数千万个读取，许多实验涉及数十到数百个样本，每个样本具有多个技术重复，导致数据达到几个GB到TB的量级。通过随机子抽样序列减少输入文件的大小，可以更快地探索数据。在本章中，我将展示如何使用Python的`random`模块从FASTA/FASTQ序列文件中选择部分读取。
- en: 'You will learn about:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学习到：
- en: Nondeterministic sampling
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非确定性抽样
- en: Getting Started
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'The code and tests for this exercise are in the *18_fastx_sampler* directory.
    Start by copying the solution for a program called `sampler.py`:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的代码和测试位于*18_fastx_sampler*目录中。首先复制名为`sampler.py`的程序解决方案：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The FASTA input files for testing this program will be generated by the `synth.py`
    program you wrote in [Chapter 17](ch17.html#ch17). If you didn’t finish writing
    that program, be sure to copy the solution to that filename before executing **`make
    fasta`** to create three FASTA files with 1K, 10K, and 100K reads, each between
    75 and 200 bp in length, with filenames of *n1k.fa*, *n10k.fa*, and *n100k.fa*,
    respectively. Use `seqmagique.py` to verify that the files are correct:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 用于测试该程序的FASTA输入文件将由您在[第17章](ch17.html#ch17)中编写的`synth.py`程序生成。如果您没有完成编写该程序，请务必在执行**`make
    fasta`**以创建包含1K、10K和100K读取数的三个75到200 bp长度文件（分别命名为*n1k.fa*、*n10k.fa*和*n100k.fa*）之前将解决方案复制到该文件名中。使用`seqmagique.py`来验证文件的正确性：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run `sampler.py` to select the default of 10% of the sequences from the smallest
    file. If you use a random seed of `1`, you should get 95 reads:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`sampler.py`以选择最小文件中默认的10%序列。如果使用随机种子`1`，您应该得到95个读取：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The results can be found in a file called *n1k.fa* in an output directory named
    *out*. One way to verify this is to use **`grep -c`** to count how many times
    it finds the symbol `>` at the start of each record:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以在名为*out*的输出目录中的*n1k.fa*文件中找到。验证方法之一是使用**`grep -c`**来计算每个记录开头的符号`>`出现的次数：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that there is a pernicious error waiting for you if you happen to forget
    the quotes around `>`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您忘记在`>`周围加上引号，则会等待您一个顽固的错误：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Wait, what just happened? Remember that `>` is the `bash` operator to *redirect*
    the `STDOUT` from one program into a file. In the preceding command, I ran `grep`
    without enough arguments and redirected the output into *out/n1k.fa*. The output
    you see is the usage that is printed to `STDERR`. Nothing was printed to `STDOUT`,
    so this null output overwrote the *out/n1k.fa* file and it is now empty:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，发生了什么？请记住`>`是`bash`中将`STDOUT`从一个程序重定向到文件的运算符。在前面的命令中，我没有足够的参数运行`grep`并将输出重定向到*out/n1k.fa*。您看到的输出是打印到`STDERR`的用法。什么也没有打印到`STDOUT`，所以这个空输出覆盖了*out/n1k.fa*文件，现在它是空的：
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'I point this out because I have lost several sequence files due to this gem.
    The data has been lost permanently, so I must rerun the earlier command to regenerate
    the file. After doing that, I recommend instead that you use `seqmagique.py` to
    verify the contents:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我特别指出这一点是因为我曾经由于这个问题丢失了几个序列文件。数据已经永久丢失，所以我必须重新运行之前的命令来重新生成文件。在这之后，我建议您使用`seqmagique.py`来验证内容：
- en: '[PRE6]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Reviewing the Program Parameters
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾程序参数
- en: 'This is a fairly complex program with many options. Run the `sampler.py` program
    to request help. Notice that the only required arguments are the input files,
    as all the options are set to reasonable defaults:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常复杂的程序，具有许多选项。运行`sampler.py`程序请求帮助。请注意，唯一需要的参数是输入文件，因为所有选项都设置为合理的默认值：
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO1-1)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO1-1)'
- en: One or more *FASTA* or *FASTQ* files are required.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个或多个*FASTA*或*FASTQ*文件。
- en: '[![2](assets/2.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO1-2)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO1-2)'
- en: The default sequence format of the input files is *FASTA*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文件的默认序列格式是*FASTA*。
- en: '[![3](assets/3.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO1-3)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO1-3)'
- en: By default, the program will select 10% of the reads.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，程序将选择10%的读取。
- en: '[![4](assets/4.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO1-4)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO1-4)'
- en: This option will stop sampling when a given maximum is reached.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项会在达到指定的最大值时停止抽样。
- en: '[![5](assets/5.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO1-5)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO1-5)'
- en: This option sets the random seed to reproduce the selections.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项将随机种子设置为重现选择。
- en: '[![6](assets/6.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO1-6)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO1-6)'
- en: The default directory for the output files is *out*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文件的默认目录是*out*。
- en: 'As with previous programs, the program will reject invalid or unreadable input
    files, and the random seed argument must be an integer value. The `-p|--percent`
    option should be a floating-point value between 0 and 1 (not inclusive), and the
    program will reject anything outside of that range. I manually validate this argument
    and use `parser.error()`, as in Chapters [4](ch04.html#ch04) and [9](ch09.html#ch09):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与先前的程序一样，程序将拒绝无效或不可读的输入文件，随机种子参数必须是一个整数值。`-p|--percent`选项应该是介于0和1之间（不包括0和1）的浮点值，程序将拒绝超出此范围的任何内容。我手动验证此参数并使用`parser.error()`，就像第[4](ch04.html#ch04)章和第[9](ch09.html#ch09)章一样：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `-f|--format` option will only accept the values `fasta` or `fastq` and
    will default to the first. I use the `choices` option with `argparse`, as in Chapters
    [15](ch15.html#ch15) and [16](ch16.html#ch16), to automatically reject unwanted
    values. For instance, the program will reject a value of `fastb`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f|--format`选项只接受值`fasta`或`fastq`，默认为第一个。我使用`argparse`的`choices`选项，就像第[15](ch15.html#ch15)章和第[16](ch16.html#ch16)章一样，自动拒绝不需要的值。例如，程序将拒绝`fastb`的值：'
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, the `-m|--max` option defaults to `0`, meaning that the program will
    sample about `--percent` of the reads with no upper limit. Practically speaking,
    you may have input files with tens of millions of reads but you only want at most
    100K from each. Use this option to halt sampling when the desired number is reached.
    For instance, I can use `-m 30` to stop sampling at 30 reads:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`-m|--max`选项默认为`0`，意味着程序会无上限地抽样约`--percent`的读取。实际上，你可能有数千万个读取的输入文件，但你只希望每个文件最多有10万个。使用这个选项在达到所需数量时停止抽样。例如，我可以使用`-m
    30`在30个读取时停止抽样：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When you think you understand how the program should work, start over with
    your version:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当您认为理解程序应该如何工作时，请重新开始使用您的版本：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Defining the Parameters
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义参数
- en: 'The arguments to the program contain many different data types, which I represent
    with the following class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的参数包含许多不同的数据类型，我用以下类表示：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO2-1)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO2-1)'
- en: The files are a list of open filehandles.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO2-2)'
- en: '[![2](assets/2.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO2-2)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 文件是一组打开的文件句柄列表。
- en: The input file format is a string.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文件格式是一个字符串。
- en: '[![3](assets/3.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO2-3)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO2-3)'
- en: The percentage of reads is a floating-point value.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 读取的百分比是一个浮点值。
- en: '[![4](assets/4.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO2-4)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO2-4)'
- en: The maximum number of reads is an integer.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最大读取数是一个整数。
- en: '[![5](assets/5.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO2-5)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO2-5)'
- en: The random seed value is an optional integer.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 随机种子值是一个可选的整数。
- en: '[![6](assets/6.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO2-6)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO2-6)'
- en: The output directory name is a string.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出目录名称是一个字符串。
- en: 'Here is how I define the arguments with `argparse`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我如何使用`argparse`定义参数的方式：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-1)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-1)'
- en: Define the file inputs as one or more readable text files.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件输入定义为一个或多个可读文本文件。
- en: '[![2](assets/2.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-2)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-2)'
- en: Use `choices` to restrict the file formats and default to `fasta`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`choices`来限制文件格式，默认为`fasta`。
- en: '[![3](assets/3.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-3)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-3)'
- en: The percent argument is a floating-point value with a default of 10%.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 百分比参数是浮点数，默认为10%。
- en: '[![4](assets/4.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-4)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-4)'
- en: The maximum number of reads should be an integer with a default of `0`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最大读取次数应为整数，默认为`0`。
- en: '[![5](assets/5.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-5)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-5)'
- en: The random seed value is optional but should be a valid integer if present.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 随机种子值是可选的，但如果存在则应为有效整数。
- en: '[![6](assets/6.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-6)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-6)'
- en: The output directory is a string with a default value of `out`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 输出目录是一个字符串，默认值为`out`。
- en: '[![7](assets/7.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-7)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-7)'
- en: Verify that the percentage is between 0 and 1.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 验证百分比应在0到1之间。
- en: '[![8](assets/8.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-8)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-8)'
- en: Create the output directory if it does not exist.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出目录不存在，则创建该输出目录。
- en: '[![9](assets/9.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-9)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-9)'
- en: Return the `Args` object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`Args`对象。
- en: Note that, while the program will accept both FASTA and FASTQ inputs, it should
    only write FASTA-formatted output files.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然程序接受FASTA和FASTQ输入，但应仅编写FASTA格式的输出文件。
- en: Nondeterministic Sampling
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非确定性采样
- en: Since there is no inherent ordering to sequences, one might be tempted to take
    the first however many sequences indicated by the user. For instance, I could
    use `head` to select some number of lines from each file. This would work on FASTQ
    files as long as this number is a divisor of four, but such an approach could
    create an invalid file for most any other sequence format, like multiline FASTA
    or Swiss-Prot.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于序列没有固有的排序，人们可能会试图获取用户指定的前几个序列。例如，我可以使用`head`从每个文件中选择一些行。这对FASTQ文件有效，只要该数字是四的倍数，但这种方法可能会为大多数其他序列格式（如多行FASTA或Swiss-Prot）创建无效文件。
- en: I’ve shown several programs that read and select sequences from files, so I
    could repurpose one of those to select records until the desired number is reached.
    When I was first asked to write this program by my boss, I did exactly this. The
    output was unusable, however, because I had not realized that the input was a
    synthetic dataset created by a colleague to simulate a *metagenome*, which is
    an environmental sample comprised of unknown organisms. The input file was created
    by concatenating various reads from known genomes so that, for instance, the first
    10K reads were from a bacteria, the next 10K from another bacteria, the next 10K
    from representative archaea, the next 10K from viruses, and so on. Taking just
    the first *N* records failed to include the diversity of the input. It was not
    only a boring program to write, but worse, it always generated the same output
    and so could not be used to generate different subsamples. This is an example
    of a *deterministic* program because the outputs were always the same given the
    same inputs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我展示了几个从文件中读取并选择序列的程序，因此我可以重新使用其中一个来选择记录，直到达到所需的数量。当老板首次要求我编写这个程序时，我确实这样做了。然而，输出是无用的，因为我没有意识到输入是同事创建的合成数据集，用于模拟*宏基因组*，即由未知生物组成的环境样本。输入文件是通过连接来自已知基因组的各种读取而创建的，因此，例如，前10K读取来自细菌，接下来的10K来自另一种细菌，接下来的10K来自代表性古细菌，接下来的10K来自病毒，依此类推。仅获取前*N*条记录未能包含输入的多样性。编写这个程序不仅无聊，而且更糟糕的是，它总是生成相同的输出，因此无法用于生成不同的子样本。这是一个*确定性*程序的示例，因为给定相同的输入，输出始终相同。
- en: Since I needed to find a way to randomly select some percentage of the reads,
    my first thought was to count the reads so I could figure out how many would be,
    for instance, 10%. To do this, I stored all the sequences in a list, used `len()`
    to figure out how many were present, and then randomly selected 10% of the numbers
    in this range. While such an approach might work for very small input files, I
    hope you can see how this fails to scale in any meaningful way. It’s not uncommon
    to encounter input files with tens of millions of reads. Keeping all that data
    in something like a Python list could easily require more memory than is available
    on a machine.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我需要找到一种方法来随机选择一定百分比的读取，我的第一个想法是计算读取的数量，以便我可以弄清楚有多少是，例如，10%。为此，我将所有序列存储在一个列表中，使用`len()`来确定存在多少个，然后随机选择该范围内的10%的数字。虽然这种方法对于非常小的输入文件可能有效，但我希望您能看出它在任何有意义的方式上都无法扩展。遇到包含数千万读取的输入文件并不罕见。在类似Python列表的数据结构中保持所有这些数据可能需要比机器上可用内存更多的内存。
- en: Eventually, I settled on a solution that reads one sequence at a time and randomly
    decides whether to choose or reject it. That is, for each sequence I randomly
    select a number from a *continuous uniform distribution* between 0 and 1, meaning
    that all values in this range are equally likely to be selected. If that number
    is less than or equal to the given percentage, I select the read. This approach
    only ever holds one sequence record in memory at a time, and so should scale at
    least linearly or *O(n)*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我选择了一种方案，每次只读取一个序列，然后随机决定是选择还是拒绝它。也就是说，对于每个序列，我从一个*连续均匀分布*中随机选择一个数字，该分布在0到1之间，意味着这个范围内的所有值被选中的可能性是相等的。如果该数字小于或等于给定的百分比，我选择这个读取。这种方法一次只在内存中保持一个序列记录，因此应该至少是线性或*O(n)*可扩展的。
- en: 'To demonstrate the selection process, I’ll import the `random` module and select
    a number between 0 and 1 using the `random.random()` function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示选择过程，我将导入`random`模块，并使用`random.random()`函数选择0到1之间的一个数字：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It’s unlikely that you’ll get the same number as I do. We have to agree on
    a seed to both produce the same value. Use the integer `1`, and you should get
    this number:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 很难让你得到和我一样的数字。我们必须就种子达成一致，才能产生相同的值。使用整数`1`，你应该得到这个数字：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `random.random()` function uses a uniform distribution. The `random` module
    can also sample from other distributions, like normal or Gaussian. Consult `help(random)`
    to see these other functions and how to use them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`random.random()`函数使用均匀分布。`random`模块还可以从其他分布中进行采样，如正态或高斯分布。查阅`help(random)`以了解这些其他函数及其使用方法。'
- en: As I iterate through the sequences in each file, I use this function to select
    a number. If the number is less than or equal to the selected percentage, I want
    to write the sequence to an output file. That is, the `random.random()` function
    ought to produce a number less than or equal to `.10` about 10% of the time. In
    this way, I’m using a *nondeterministic* approach to sampling because the selected
    reads will be different each time I run the program (assuming I do not set a random
    seed). This allows me to generate many different subsamples from the same input
    file, which could prove useful in generating technical replicates for analyses.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我遍历每个文件中的序列时，我使用此函数来选择一个数字。如果该数字小于或等于所选百分比，我希望将该序列写入输出文件。也就是说，`random.random()`函数应该大约有10%的时间产生小于或等于`.10`的数字。通过这种方式，我使用了一种*非确定性*的采样方法，因为每次运行程序时（假设我没有设置随机种子），所选的读取将会有所不同。这使我能够从同一输入文件中生成许多不同的子样本，这在生成技术重复用于分析时可能会很有用。
- en: Structuring the Program
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序的结构化
- en: 'You may feel somewhat overwhelmed by the complexity of this program, so I’ll
    present pseudocode you may find helpful:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会对这个程序的复杂性感到有些不知所措，因此我将提供您可能会发现有帮助的伪代码：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: I would encourage you to run the `solution.py` program on one file and then
    on several files and try to reverse-engineer the output. Keep running the test
    suite to ensure your program is on track.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励您在一个文件上运行`solution.py`程序，然后在多个文件上运行，并尝试逆向工程输出。继续运行测试套件以确保您的程序正常运行。
- en: I hope you can see how similar in structure this program is to many previous
    programs that process some number of input files and create some output. For example,
    in [Chapter 2](ch02.html#ch02) you processed files of DNA sequences to produce
    files of RNA sequences in an output directory. In [Chapter 15](ch15.html#ch15),
    you processed sequence files to produce a summary table of statistics. In [Chapter 16](ch16.html#ch16),
    you processed sequence files to select those records matching a pattern and wrote
    the selected sequences to an output file. The programs in Chapters [2](ch02.html#ch02)
    and [16](ch16.html#ch16) most closely resemble what you need to do here, so I
    recommend you borrow from those solutions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您能看到此程序在结构上与许多先前处理某些输入文件并创建某些输出的程序非常相似。例如，在[第2章](ch02.html#ch02)中，您处理了DNA序列文件以在输出目录中生成RNA序列文件。在[第15章](ch15.html#ch15)中，您处理了序列文件以生成统计摘要表。在[第16章](ch16.html#ch16)中，您处理了序列文件以选择符合某一模式的记录，并将选定的序列写入输出文件。第2章和第16章中的程序最接近您需要在这里做的事情，因此我建议您借鉴这些解决方案。
- en: Solutions
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: I want to share two versions of a solution. The first works to solve the exact
    problem as described. The second solution goes beyond the original requirements
    because I want to show you how to overcome two common problems you may face in
    processing large bioinformatics datasets, namely opening too many filehandles
    and reading compressed files.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我想分享两个解决方案的版本。第一个解决方案致力于解决所描述的确切问题。第二个解决方案超出了原始要求，因为我想向您展示如何解决处理大型生物信息数据集时可能面临的两个常见问题，即打开过多文件句柄和读取压缩文件。
- en: 'Solution 1: Reading Regular Files'
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 1：读取常规文件
- en: 'If you are dealing with a limited number of uncompressed input files, the following
    solution is appropriate:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您处理的是少量未压缩的输入文件，则以下解决方案是合适的：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](assets/1.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-1)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-1)'
- en: Set the random seed, if present. The default `None` value will be the same as
    not setting the seed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 设置随机种子（如果存在）。默认的`None`值与不设置种子相同。
- en: '[![2](assets/2.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-2)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-2)'
- en: Initialize a variable to note the total number of sequences selected.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化一个变量以记录选择的总序列数。
- en: '[![3](assets/3.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-3)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-3)'
- en: Iterate through each input filehandle.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历每个输入文件句柄。
- en: '[![4](assets/4.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-4)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-4)'
- en: Construct the output filename by joining the output directory with the file’s
    basename.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将输出目录与文件的基本名称连接来构造输出文件名。
- en: '[![5](assets/5.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-5)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-5)'
- en: Open the output filehandle for writing text.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 打开输出文件句柄以写入文本。
- en: '[![6](assets/6.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-6)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-6)'
- en: Initialize a variable to note how many sequences have been taken from this file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化一个变量以记录从此文件中获取的序列数。
- en: '[![7](assets/7.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-7)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-7)'
- en: Iterate through each sequence record in the input file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历输入文件中的每个序列记录。
- en: '[![8](assets/8.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-8)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-8)'
- en: If the record is randomly selected, increment the counter and write the sequence
    to the output file.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果记录是随机选择的，则递增计数器并将序列写入输出文件。
- en: '[![9](assets/9.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-9)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-9)'
- en: If there is a maximum limit defined and the number of records selected is equal
    to this, exit the inner `for` loop.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了最大限制并且选择的记录数等于此限制，则退出内部`for`循环。
- en: '[![10](assets/10.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-10)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-10)'
- en: Close the output filehandle and increment the number of total records taken.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭输出文件句柄并递增总记录数。
- en: '[![11](assets/11.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-11)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[![11](assets/11.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-11)'
- en: Note the number of files processed and inform the user of the final status.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意处理的文件数并告知用户最终状态。
- en: 'Solution 2: Reading a Large Number of Compressed Files'
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 2：读取大量压缩文件
- en: The original problem does not involve reading compressed files, but you will
    often find that data will be stored in this way to save bandwidth in transferring
    data and disk space in storing it. Python can directly read files compressed with
    tools like `zip` and `gzip`, so it’s not necessary to uncompress the input files
    before processing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的问题不涉及读取压缩文件，但通常会发现数据以这种方式存储，以节省数据传输的带宽和存储数据的磁盘空间。Python可以直接读取使用诸如`zip`和`gzip`等工具压缩的文件，因此在处理之前不需要解压缩输入文件。
- en: 'Additionally, if you are processing hundreds to thousands of input files, you
    will find that using `type=argparse.FileType()` will cause your program to fail
    because you may exceed the maximum number of open files your operating system
    will allow. In that case, you should declare `Args.files` as `List[str]` and create
    the parameter like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果您正在处理数百到数千个输入文件，您会发现使用`type=argparse.FileType()`将导致程序失败，因为您可能会超出操作系统允许的最大打开文件数。在这种情况下，您应将`Args.files`声明为`List[str]`并像这样创建参数：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](assets/1.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO5-1)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO5-1)'
- en: Set the parameter type to one or more string values.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将参数类型设置为一个或多个字符串值。
- en: 'This means you will have to validate the input files yourself, which you can
    do in the `get_args()` function, like so:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您需要自行验证输入文件，可以在`get_args()`函数中执行，如下所示：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO6-1)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO6-1)'
- en: Find all the arguments that are not valid files.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 查找所有不是有效文件的参数。
- en: '[![2](assets/2.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO6-2)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO6-2)'
- en: Use `parser.error()` to report the bad inputs.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`parser.error()`报告不良输入。
- en: 'The `main()` processing needs to change slightly as now `args.files` will be
    a list of strings. You will need to open the filehandles yourself with `open()`,
    and this is the crucial change to your program needed to handle compressed files.
    I will use a simple heuristic that examines the file extension for `.gz` to determine
    if a file is zipped and will instead use the `gzip.open()` function to open it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`处理需要稍作更改，因为现在`args.files`将是一个字符串列表。您需要自行使用`open()`打开文件句柄，这是处理压缩文件所需的关键更改。我使用了一个简单的启发式方法来检查文件扩展名是否为`.gz`，以确定文件是否被压缩，并将使用`gzip.open()`函数来打开它：'
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](assets/1.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO7-1)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO7-1)'
- en: '`args.files` is now a list of strings, not filehandles.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`args.files`现在是一个字符串列表，而不是文件句柄。'
- en: '[![2](assets/2.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO7-2)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO7-2)'
- en: Get the file extension.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 获取文件扩展名。
- en: '[![3](assets/3.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO7-3)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO7-3)'
- en: If the file extension is `.gz`, use `gzip.open()` to open the file; otherwise,
    use the normal `open()` function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件扩展名是`.gz`，则使用`gzip.open()`打开文件；否则，使用普通的`open()`函数。
- en: 'Finally, there are times when `nargs=''+''` will also not work. For one project,
    I had to download over 350,000 XML files. Passing all these as arguments will
    lead to an “Argument list too long” error from the command line itself. My workaround
    is to accept the directory names as arguments:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有时`nargs='+'`也不起作用。对于一个项目，我不得不下载超过35万个XML文件。将所有这些作为参数传递将导致命令行本身出现“Argument
    list too long”的错误。我的解决方法是将目录名称作为参数接受：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'I then use Python to recursively search the directories for files. For this
    code, I added `from pathlib import Path` so that I could use the `Path.rglob()`
    function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我使用Python递归搜索目录中的文件。对于这段代码，我添加了`from pathlib import Path`，以便我可以使用`Path.rglob()`函数：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The program can continue as before because Python does not have a problem storing
    several hundred thousand items in a list.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以像以前一样继续运行，因为Python在列表中存储几十万项没有问题。
- en: Going Further
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步探索
- en: This program always produces FASTA output. Add an `--outfmt` output format option
    so that you can specify the output format. Consider detecting the input file format
    and writing the output format in the same way as you did in [Chapter 16](ch16.html#ch16).
    Be sure to add the appropriate tests to verify that your program works.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序始终产生FASTA格式的输出。添加一个`--outfmt`输出格式选项，以便您可以指定输出格式。考虑检测输入文件格式，并像您在[第16章](ch16.html#ch16)中所做的那样以相同的方式编写输出格式。务必添加适当的测试以验证程序的功能。
- en: Review
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**复习**'
- en: The `>` record marker in a FASTA file is also the redirect operator in `bash`,
    so care must be taken to quote this value on the command line.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FASTA文件中的`>`记录标记也是`bash`中的重定向操作符，因此在命令行中必须谨慎引用此值。
- en: Deterministic approaches always produce the same output for the given input.
    Nondeterministic approaches produce different outputs for the same inputs.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定性方法始终为给定输入产生相同的输出。非确定性方法对相同的输入产生不同的输出。
- en: The `random` module has functions to select numbers from various distributions,
    such as the uniform and normal distributions.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`random`模块具有从各种分布（如均匀分布和正态分布）中选择数字的函数。'
