- en: 'Chapter 18\. FASTX Sampler: Randomly Subsampling Sequence Files'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sequence datasets in genomics and metagenomics can get dauntingly large, requiring
    copious time and compute resources to analyze. Many sequencers can produce tens
    of millions of reads per sample, and many experiments involve tens to hundreds
    of samples, each with multiple technical replicates resulting in gigabytes to
    terabytes of data. Reducing the size of the input files by randomly subsampling
    sequences allows you to explore data more quickly. In this chapter, I will show
    how to use Python’s `random` module to select some portion of the reads from FASTA/FASTQ
    sequence files.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: Nondeterministic sampling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code and tests for this exercise are in the *18_fastx_sampler* directory.
    Start by copying the solution for a program called `sampler.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The FASTA input files for testing this program will be generated by the `synth.py`
    program you wrote in [Chapter 17](ch17.html#ch17). If you didn’t finish writing
    that program, be sure to copy the solution to that filename before executing **`make
    fasta`** to create three FASTA files with 1K, 10K, and 100K reads, each between
    75 and 200 bp in length, with filenames of *n1k.fa*, *n10k.fa*, and *n100k.fa*,
    respectively. Use `seqmagique.py` to verify that the files are correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `sampler.py` to select the default of 10% of the sequences from the smallest
    file. If you use a random seed of `1`, you should get 95 reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The results can be found in a file called *n1k.fa* in an output directory named
    *out*. One way to verify this is to use **`grep -c`** to count how many times
    it finds the symbol `>` at the start of each record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there is a pernicious error waiting for you if you happen to forget
    the quotes around `>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait, what just happened? Remember that `>` is the `bash` operator to *redirect*
    the `STDOUT` from one program into a file. In the preceding command, I ran `grep`
    without enough arguments and redirected the output into *out/n1k.fa*. The output
    you see is the usage that is printed to `STDERR`. Nothing was printed to `STDOUT`,
    so this null output overwrote the *out/n1k.fa* file and it is now empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'I point this out because I have lost several sequence files due to this gem.
    The data has been lost permanently, so I must rerun the earlier command to regenerate
    the file. After doing that, I recommend instead that you use `seqmagique.py` to
    verify the contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Reviewing the Program Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a fairly complex program with many options. Run the `sampler.py` program
    to request help. Notice that the only required arguments are the input files,
    as all the options are set to reasonable defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: One or more *FASTA* or *FASTQ* files are required.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The default sequence format of the input files is *FASTA*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the program will select 10% of the reads.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This option will stop sampling when a given maximum is reached.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This option sets the random seed to reproduce the selections.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The default directory for the output files is *out*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with previous programs, the program will reject invalid or unreadable input
    files, and the random seed argument must be an integer value. The `-p|--percent`
    option should be a floating-point value between 0 and 1 (not inclusive), and the
    program will reject anything outside of that range. I manually validate this argument
    and use `parser.error()`, as in Chapters [4](ch04.html#ch04) and [9](ch09.html#ch09):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-f|--format` option will only accept the values `fasta` or `fastq` and
    will default to the first. I use the `choices` option with `argparse`, as in Chapters
    [15](ch15.html#ch15) and [16](ch16.html#ch16), to automatically reject unwanted
    values. For instance, the program will reject a value of `fastb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `-m|--max` option defaults to `0`, meaning that the program will
    sample about `--percent` of the reads with no upper limit. Practically speaking,
    you may have input files with tens of millions of reads but you only want at most
    100K from each. Use this option to halt sampling when the desired number is reached.
    For instance, I can use `-m 30` to stop sampling at 30 reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When you think you understand how the program should work, start over with
    your version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Defining the Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The arguments to the program contain many different data types, which I represent
    with the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The files are a list of open filehandles.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The input file format is a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The percentage of reads is a floating-point value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The maximum number of reads is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The random seed value is an optional integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The output directory name is a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how I define the arguments with `argparse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Define the file inputs as one or more readable text files.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `choices` to restrict the file formats and default to `fasta`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The percent argument is a floating-point value with a default of 10%.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The maximum number of reads should be an integer with a default of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The random seed value is optional but should be a valid integer if present.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The output directory is a string with a default value of `out`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Verify that the percentage is between 0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Create the output directory if it does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO3-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Return the `Args` object.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, while the program will accept both FASTA and FASTQ inputs, it should
    only write FASTA-formatted output files.
  prefs: []
  type: TYPE_NORMAL
- en: Nondeterministic Sampling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since there is no inherent ordering to sequences, one might be tempted to take
    the first however many sequences indicated by the user. For instance, I could
    use `head` to select some number of lines from each file. This would work on FASTQ
    files as long as this number is a divisor of four, but such an approach could
    create an invalid file for most any other sequence format, like multiline FASTA
    or Swiss-Prot.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve shown several programs that read and select sequences from files, so I
    could repurpose one of those to select records until the desired number is reached.
    When I was first asked to write this program by my boss, I did exactly this. The
    output was unusable, however, because I had not realized that the input was a
    synthetic dataset created by a colleague to simulate a *metagenome*, which is
    an environmental sample comprised of unknown organisms. The input file was created
    by concatenating various reads from known genomes so that, for instance, the first
    10K reads were from a bacteria, the next 10K from another bacteria, the next 10K
    from representative archaea, the next 10K from viruses, and so on. Taking just
    the first *N* records failed to include the diversity of the input. It was not
    only a boring program to write, but worse, it always generated the same output
    and so could not be used to generate different subsamples. This is an example
    of a *deterministic* program because the outputs were always the same given the
    same inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Since I needed to find a way to randomly select some percentage of the reads,
    my first thought was to count the reads so I could figure out how many would be,
    for instance, 10%. To do this, I stored all the sequences in a list, used `len()`
    to figure out how many were present, and then randomly selected 10% of the numbers
    in this range. While such an approach might work for very small input files, I
    hope you can see how this fails to scale in any meaningful way. It’s not uncommon
    to encounter input files with tens of millions of reads. Keeping all that data
    in something like a Python list could easily require more memory than is available
    on a machine.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, I settled on a solution that reads one sequence at a time and randomly
    decides whether to choose or reject it. That is, for each sequence I randomly
    select a number from a *continuous uniform distribution* between 0 and 1, meaning
    that all values in this range are equally likely to be selected. If that number
    is less than or equal to the given percentage, I select the read. This approach
    only ever holds one sequence record in memory at a time, and so should scale at
    least linearly or *O(n)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the selection process, I’ll import the `random` module and select
    a number between 0 and 1 using the `random.random()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s unlikely that you’ll get the same number as I do. We have to agree on
    a seed to both produce the same value. Use the integer `1`, and you should get
    this number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `random.random()` function uses a uniform distribution. The `random` module
    can also sample from other distributions, like normal or Gaussian. Consult `help(random)`
    to see these other functions and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: As I iterate through the sequences in each file, I use this function to select
    a number. If the number is less than or equal to the selected percentage, I want
    to write the sequence to an output file. That is, the `random.random()` function
    ought to produce a number less than or equal to `.10` about 10% of the time. In
    this way, I’m using a *nondeterministic* approach to sampling because the selected
    reads will be different each time I run the program (assuming I do not set a random
    seed). This allows me to generate many different subsamples from the same input
    file, which could prove useful in generating technical replicates for analyses.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring the Program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may feel somewhat overwhelmed by the complexity of this program, so I’ll
    present pseudocode you may find helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: I would encourage you to run the `solution.py` program on one file and then
    on several files and try to reverse-engineer the output. Keep running the test
    suite to ensure your program is on track.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you can see how similar in structure this program is to many previous
    programs that process some number of input files and create some output. For example,
    in [Chapter 2](ch02.html#ch02) you processed files of DNA sequences to produce
    files of RNA sequences in an output directory. In [Chapter 15](ch15.html#ch15),
    you processed sequence files to produce a summary table of statistics. In [Chapter 16](ch16.html#ch16),
    you processed sequence files to select those records matching a pattern and wrote
    the selected sequences to an output file. The programs in Chapters [2](ch02.html#ch02)
    and [16](ch16.html#ch16) most closely resemble what you need to do here, so I
    recommend you borrow from those solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I want to share two versions of a solution. The first works to solve the exact
    problem as described. The second solution goes beyond the original requirements
    because I want to show you how to overcome two common problems you may face in
    processing large bioinformatics datasets, namely opening too many filehandles
    and reading compressed files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 1: Reading Regular Files'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are dealing with a limited number of uncompressed input files, the following
    solution is appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Set the random seed, if present. The default `None` value will be the same as
    not setting the seed.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a variable to note the total number of sequences selected.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through each input filehandle.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Construct the output filename by joining the output directory with the file’s
    basename.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Open the output filehandle for writing text.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a variable to note how many sequences have been taken from this file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through each sequence record in the input file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-8)'
  prefs: []
  type: TYPE_NORMAL
- en: If the record is randomly selected, increment the counter and write the sequence
    to the output file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-9)'
  prefs: []
  type: TYPE_NORMAL
- en: If there is a maximum limit defined and the number of records selected is equal
    to this, exit the inner `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](assets/10.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-10)'
  prefs: []
  type: TYPE_NORMAL
- en: Close the output filehandle and increment the number of total records taken.
  prefs: []
  type: TYPE_NORMAL
- en: '[![11](assets/11.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO4-11)'
  prefs: []
  type: TYPE_NORMAL
- en: Note the number of files processed and inform the user of the final status.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 2: Reading a Large Number of Compressed Files'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The original problem does not involve reading compressed files, but you will
    often find that data will be stored in this way to save bandwidth in transferring
    data and disk space in storing it. Python can directly read files compressed with
    tools like `zip` and `gzip`, so it’s not necessary to uncompress the input files
    before processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, if you are processing hundreds to thousands of input files, you
    will find that using `type=argparse.FileType()` will cause your program to fail
    because you may exceed the maximum number of open files your operating system
    will allow. In that case, you should declare `Args.files` as `List[str]` and create
    the parameter like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Set the parameter type to one or more string values.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means you will have to validate the input files yourself, which you can
    do in the `get_args()` function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Find all the arguments that are not valid files.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `parser.error()` to report the bad inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main()` processing needs to change slightly as now `args.files` will be
    a list of strings. You will need to open the filehandles yourself with `open()`,
    and this is the crucial change to your program needed to handle compressed files.
    I will use a simple heuristic that examines the file extension for `.gz` to determine
    if a file is zipped and will instead use the `gzip.open()` function to open it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`args.files` is now a list of strings, not filehandles.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the file extension.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_fastx_sampler__randomly_subsampling_sequence_files_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: If the file extension is `.gz`, use `gzip.open()` to open the file; otherwise,
    use the normal `open()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there are times when `nargs=''+''` will also not work. For one project,
    I had to download over 350,000 XML files. Passing all these as arguments will
    lead to an “Argument list too long” error from the command line itself. My workaround
    is to accept the directory names as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'I then use Python to recursively search the directories for files. For this
    code, I added `from pathlib import Path` so that I could use the `Path.rglob()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The program can continue as before because Python does not have a problem storing
    several hundred thousand items in a list.
  prefs: []
  type: TYPE_NORMAL
- en: Going Further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This program always produces FASTA output. Add an `--outfmt` output format option
    so that you can specify the output format. Consider detecting the input file format
    and writing the output format in the same way as you did in [Chapter 16](ch16.html#ch16).
    Be sure to add the appropriate tests to verify that your program works.
  prefs: []
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `>` record marker in a FASTA file is also the redirect operator in `bash`,
    so care must be taken to quote this value on the command line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deterministic approaches always produce the same output for the given input.
    Nondeterministic approaches produce different outputs for the same inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `random` module has functions to select numbers from various distributions,
    such as the uniform and normal distributions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
