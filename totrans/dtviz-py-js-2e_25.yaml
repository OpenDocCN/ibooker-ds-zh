- en: Chapter 19\. Mapping with D3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building and customizing map visualizations is one of D3’s core strengths. It
    has some very sophisticated libraries, allowing for all kinds of projections,
    from the workhorse Mercator and orthographic to more esoteric ones such as Conic
    Equidistant. Mapping seems to be something of an obsession for Mike Bostock and
    Jason Davies, D3’s core devs, and their attention to detail is striking. If you
    have a mapping problem, chances are D3 can do the heavy lifting required.^([1](ch19.xhtml#idm45607741792448))
    In this chapter, we’ll use our Nobel Prize visualization (Nobel-viz) map ([Figure 19-1](#d3maps_target))
    to introduce the core D3 mapping concepts.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1503](assets/dpj2_1503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19-1\. This chapter’s target element
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Available Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most popular mapping format is the aging [shapefile](https://oreil.ly/XV4Cb),
    developed for geographic information system (GIS) software. There are many free
    and proprietary desktop programs^([2](ch19.xhtml#idm45607741786480)) to manipulate
    and produce shapefiles.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, shapefiles were not designed for the web, which would far rather
    deal in a JSON-based map format, and demands small, efficient representations
    to limit bandwidth and related lag.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that there are many convenient ways to convert shapefiles to
    our preferred TopoJSON format,^([3](ch19.xhtml#idm45607741781184)) meaning you
    can manipulate your shapefiles in software and then convert them to a web-friendly
    format. The standard way of finding maps for web dataviz is to first look for
    TopoJSON or GeoJSON versions, then search among the richer pool of shapefiles,
    and, as a last resort, roll your own using a shapefile, or equivalent, editor.
    Depending on how much map visualization you intend to do, there will probably
    be an off-the-shelf solution. For things like world maps or continental projections
    (e.g., the popular Albers USA), you can usually find a number of solutions with
    different degrees of accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: For our Nobel map, we want a global mapping, at least showing all 58 Nobel Prize–winning
    nations, with labeled shapes for pretty much all of them. Luckily, D3 provides
    a number of example world maps, one at 50m grid resolution, the other a smaller
    110m resolution map. The latter is fine for our fairly crude requirements.^([4](ch19.xhtml#idm45607741779664))
  prefs: []
  type: TYPE_NORMAL
- en: D3’s Mapping Data Formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: D3 makes use of two JSON-based geometric data formats, [GeoJSON](https://geojson.org)
    and [TopoJSON](https://oreil.ly/709GD), an extension of GeoJSON devised by Mike
    Bostock that encodes topology. GeoJSON is more intuitive to read, but TopoJSON
    is far more efficient in most cases. Typically, maps are converted to TopoJSON
    for web delivery, where size is an important consideration. The TopoJSON is then
    converted to GeoJSON via D3 on the browser, to simplify SVG path creation, feature
    optimization, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There is a nice summation of the differences between TopoJSON and GeoJSON on
    [Stack Overflow](https://oreil.ly/DvcaG).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at the two formats now. Understanding their basic structure
    is important and a little effort there will pay off, especially as your mapping
    endeavors become more ambitious.
  prefs: []
  type: TYPE_NORMAL
- en: GeoJSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GeoJSON files contain one `type` object, one of Point, MultiPoint, LineString,
    MultiLineString, Polygon, MultiPolygon, GeometryCollection, Feature, or FeatureCollection.
    The case of the type member values must be [CamelCase](https://oreil.ly/wS4q9),
    as shown here. They may also contain a `crs` member, specifying a particular coordinate
    reference system.
  prefs: []
  type: TYPE_NORMAL
- en: FeatureCollections are the largest GeoJSON container, and maps with more than
    one region are usually specified with these. FeatureCollections contain a `features`
    array, each element of which is a GeoJSON object of a type listed in the previous
    paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 19-1](#d3maps_geojson) shows a typical FeatureCollection containing
    an array of country maps, the boundaries of which are specified by Polygons.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-1\. The GeoJSON mapping data format
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_mapping_with_d3_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Each GeoJSON file contains a single object with a type and containing…​
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_mapping_with_d3_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: …​an array of features—​in this case, country objects…​
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_mapping_with_d3_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: …​with coordinate-based, polygonal geometry.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_mapping_with_d3_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the geographic coordinates are given in [longitude, latitude] pairs,
    the reverse of conventional geographic positioning. This is because GeoJSON uses
    an [X,Y] coordinate scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Although GeoJSON is more succinct than shapefiles and in the preferred JSON
    format, there is a lot of redundancy in the encoding of maps. For example, shared
    boundaries are specified twice and the floating-point coordinate format is fairly
    inflexible and, for many jobs, too precise. The TopoJSON format was designed to
    address these issues and produce a far more efficient way of delivering maps to
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: TopoJSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developed by Mike Bostock, TopoJSON is an extension to GeoJSON that encodes
    topology, stitching geometries together from a shared pool of line segments called
    arcs. Because they reuse these arcs, TopoJSON files are typically 80% smaller
    than their GeoJSON equivalents! In addition, taking a topological approach to
    map representation enables a number of techniques that use topology. One of these
    is topology-preserving shape simplification,^([5](ch19.xhtml#idm45607741574800))
    which can eliminate 95% of map points while retaining sufficient detail. Cartograms
    and automatic map coloring are also facilitated. [Example 19-2](#d3maps_topojson_basic)
    shows the structure of a TopoJSON file.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-2\. Structure of our TopoJSON world map
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_mapping_with_d3_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: TopoJSON objects have a `Topology` type and must contain an `objects` object
    and an array of `arcs`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_mapping_with_d3_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the objects are `countries` and `land`, both being arc-defined
    `GeometryCollections`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_mapping_with_d3_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Each geometry (in this case defining a country shape) is defined by a number
    of arc paths, comprising continuous arcs referenced by their index in the `arcs`
    array ![4](assets/4.png).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_mapping_with_d3_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: An array of component arcs used to construct the objects. The arcs are referenced
    by index.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_mapping_with_d3_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Numbers needed to quantize positions as integers rather than floats.
  prefs: []
  type: TYPE_NORMAL
- en: The smaller size of the TopoJSON format is obviously a big advantage if you
    have to fetch it to your web browser. Often only the GeoJSON format is available,
    so the ability to convert this to TopoJSON is a handy one. D3 provides a small
    command-line utility to do just this. Called `geo2topo`, it is part of the TopoJSON
    package and can be installed via `node`.
  prefs: []
  type: TYPE_NORMAL
- en: Converting Maps to TopoJSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can install TopoJSON via the `node` repositories (see [Chapter 1](ch01.xhtml#chapter_install)),
    using the `-g` flag to make it a global^([6](ch19.xhtml#idm45607741352656)) install:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With `topojson` installed, converting an existing GeoJSON into TopoJSON is
    as easy as can be. Here we call `geo2topo` from the command line on a GeoJSON
    *geo_input.json* file, specifying an output file *topo_output.json*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can pipe the result to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`geo2topo` has a number of useful options, such as quantization, which allows
    you to specify your map’s precision. Playing around with this option can result
    in a much smaller file with little perceptible reduction in quality. You can see
    the full spec on the [geo2topo command-line reference](https://oreil.ly/mp0RN).
    If you want to convert your map files programmatically, there is a handy Python
    library for the job, *topojson.py*. You can find it on [GitHub](https://oreil.ly/8t7Ko).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve got our map data in a light, efficient, web-optimized format,
    let’s see how we use JavaScript to turn it into interactive web maps.
  prefs: []
  type: TYPE_NORMAL
- en: D3 Geo, Projections, and Paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: D3 has a client-side *topojson* library, dedicated to dealing with TopoJSON
    data. This converts the optimized, arc-based TopoJSON to the coordinate-based
    GeoJSON, ready to be manipulated by D3’s `projection`s and `paths`, objects in
    the *d3.geo* library.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 19-3](#d3maps_topojsoncode) shows the process of extracting the GeoJSON
    features needed by our Nobel map from the TopoJSON *world-100m.json* map. This
    provides us with the coordinate-based polygons representing our countries and
    their borders.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to extract the GeoJSON features we require from the TopoJSON `world`
    object just delivered to the browser, we use *topojson*’s `feature` and `mesh`
    methods. `feature` returns the GeoJSON Feature or FeatureCollection for the specified
    object and `mesh` the GeoJSON MutliLineString geometry object representing the
    mesh for the specified object.
  prefs: []
  type: TYPE_NORMAL
- en: The `feature` and `mesh` methods take as their first argument the TopoJSON object
    and as their second a reference to the feature we want to extract (`land` and
    `countries` in [Example 19-3](#d3maps_topojsoncode)). In our world map, `countries`
    is a FeatureCollection with a `features` array of countries ([Example 19-3](#d3maps_topojsoncode),
    ![2](assets/2.png)).
  prefs: []
  type: TYPE_NORMAL
- en: The `mesh` method has a third argument, which specifies a filter function, taking
    as arguments the two geometry objects (`a` and `b`) sharing the mesh arc. If the
    arc is unshared, then `a` and `b` are the same, allowing us to filter out external
    borders in our world map ([Example 19-3](#d3maps_topojsoncode), ![3](assets/3.png)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-3\. Extracting our TopoJSON features
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_mapping_with_d3_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Load the map data using D3’s helper functions and send on to a `ready` function
    to initiate the map chart.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_mapping_with_d3_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Uses `topojson` to extract our desired features from the TopoJSON data, delivering
    them in the GeoJSON format.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_mapping_with_d3_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Filters for only internal borders, shared between countries. If an arc is only
    used by one geometry (in this case, a country), then a and b are identical.
  prefs: []
  type: TYPE_NORMAL
- en: Map presentation in D3 generally follows a standard pattern. We first create
    a D3 `projection`, using one of D3’s many and varied alternatives. We then create
    a `path` using this `projection`. This `path` is then used to convert the features
    and meshes extracted from our TopoJSON object into the SVG paths displayed in
    the browser window. Let’s now look at the rich subject of D3 `projection`s.
  prefs: []
  type: TYPE_NORMAL
- en: Projections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Probably the chief challenge for maps, since the time it was appreciated that
    the Earth is spheroidal, is that of representing a three-dimensional globe, or
    significant parts of it, in a two-dimensional form. In 1569, the Flemish cartographer
    Gerardus Mercator famously resolved this by extending lines from the Earth’s center
    to significant boundary coordinates and then projecting them onto a surrounding
    cylinder. This had the useful property of representing lines of constant course,
    known as *rhumb lines*, as straight line segments, a very useful feature for the
    seafaring navigators intended to use the map. Unfortunately, the projection process
    distorts distances and size, magnifying the scale as one moves from the equator
    to the pole. As a result of this, the huge African continent appears not much
    bigger than Greenland when in reality it is around 14 times the size.
  prefs: []
  type: TYPE_NORMAL
- en: All projections are, like Mercator’s, a compromise, and what’s great about D3
    is that the rich array of choices means one can balance these compromises to find
    the right projection for the job.^([7](ch19.xhtml#idm45607741031424)) [Figure 19-2](#d3maps_projections)
    shows some alternative `projection`s for our Nobel map, including the equirectangular
    one chosen for the final visualization. The constraint was to show all Nobel Prize–winning
    countries within the rectangular window and to try to maximize the space available,
    particularly in Europe where there are many countries that are small geographically
    but have a relatively large prize haul.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a D3 `projection`, just use one of the applicable *d3.geo* methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: D3 `projection`s have a number of useful methods. It’s common to use the `translate`
    method to translate the map by half the width and height of the container, overriding
    the default of [480, 250]. You can also set the precision, which affects the degree
    of *adaptive resampling* used in the `projection`. Adaptive resampling is a clever
    technique to increase the accuracy of projected lines while still performing efficiently.^([8](ch19.xhtml#idm45607741009120))
    The scale of the map and its center’s longitude and latitude can be set by the
    `scale` and `center` methods.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1902](assets/dpj2_1902.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19-2\. Some alternative mapping projections for the Nobel map
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Putting the `projection` methods together, the following code is that used
    by our Nobel-viz world equirectangular map. Note that it’s hand-tweaked to maximize
    the space given to Nobel Prize–winning countries. The two poles are truncated,
    there being no winners in either the Arctic or Antarctic (note that equirectangular
    maps assume a width/height ratio of 2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_mapping_with_d3_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Enlarged slightly; the default height is 480 and scale 153.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_mapping_with_d3_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Centered at 15 degrees east, 15 degrees north.
  prefs: []
  type: TYPE_NORMAL
- en: With our equirectangular `projection` defined, let’s see how you use it to create
    a `path`, which will in turn be used to create the SVG maps.
  prefs: []
  type: TYPE_NORMAL
- en: Paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you’ve settled on an appropriate `projection` for your map, you use it
    to create a D3 geographic `path` generator, which is a specialized variant of
    the SVG `path` generator (`d3.svg.path`). This `path` takes any GeoJSON feature
    or geometry object, such as a FeatureCollection, Polygon, or Point, and returns
    the SVG path data string for the `d` element. For example, with our map `borders`
    object, the geographic border coordinates describing a `MultiLineString` are converted
    into path coordinates for SVG.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, we create our `path` and set its `projection` in one go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically, we use the `path` as a function to generate the `d` attribute to
    an SVG path, using GeoJSON data bound using the `datum` method (used to bind a
    single object—not array—and shorthand for `data([object])`). So to use the borders
    data we just extracted using `topojson.mesh` to draw our country borders, we use
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_mapping_with_d3_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We want to insert the borders SVG before (below) the map’s `graticule` (grid)
    overlay.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 19-3](#d3maps_paths) shows output from the Chrome Console for the TopoJSON
    `borders` object, extracted from our world-map data, and the resultant path generated
    by our *d3.geo* `path`, using the equirectangular `projection`.'
  prefs: []
  type: TYPE_NORMAL
- en: The geo-path generator is the mainstay of D3 map presentations. I recommend
    playing around with different `projection`s with simple geometries to get a feel
    for things, investigating the astonishing number of examples found at [*bl.ocks.org*](https://bl.ocks.org/mbostock)
    and the docs on [D3’s GitHub page](https://oreil.ly/2qgyf), and checking out this
    [great little demo](https://oreil.ly/NansT).
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1903](assets/dpj2_1903.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19-3\. Path generator, from geometry to SVG path
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now let’s look at one of the useful *d3.geo* components you’ll use in your maps,
    the `graticule` (or map grid).
  prefs: []
  type: TYPE_NORMAL
- en: graticules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A useful component of *d3.geo* and one used in our Nobel map is the `graticule`,
    one of the geo shape generators.^([9](ch19.xhtml#idm45607740753936)) This creates
    a global mesh of meridians (lines of longitude) and parallels (lines of latitude),
    spaced by default at 10 degrees. When our `path` is applied to this `graticule`,
    it generates a suitably projected grid, as shown back in [Figure 19-1](#d3maps_target).
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 19-4](#d3maps_graticule) shows how to add a `graticule` to your map.
    Note that if you want your grid to overlay your map paths, then its SVG path should
    come after the map paths in the DOM tree. As you’ll see, you can use D3’s `insert`
    method to enforce this order.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-4\. Creating a `graticule`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_mapping_with_d3_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `graticule`, setting the grid spacing to 20 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_mapping_with_d3_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Note the `datum` shorthand for data(`[graticule]`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_mapping_with_d3_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `path` generator to receive the `graticule` data and return a grid path.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our grid overlay and the ability to turn our map file into
    SVG paths with the required `projection`, let’s put the elements together.
  prefs: []
  type: TYPE_NORMAL
- en: Putting the Elements Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the `projection`, `path`, and `graticule` components discussed, we’ll
    now create the basic map. This map is intended to respond to user events, highlighting
    those countries represented by the selected winners, and reflecting the number
    of winners with a filled red circle at the countries’ centers. We’ll deal with
    this interactive update separately.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 19-5](#d3maps_basic_map_code) shows the code required to build a basic
    global map. It follows what should now be a familiar pattern, getting the `mapContainer`
    from its `div` container (ID `nobel-map`), appending an `<svg>` tag to it, and
    then proceeding to add SVG elements, which in this case are D3-generated map paths.'
  prefs: []
  type: TYPE_NORMAL
- en: Our map has fixed components (e.g., the choice of `projection` and `path`) that
    are not dependent on any data change and are defined outside the initializing
    `nbviz.initMap` method. `nbviz.initMap` is called when the visualization is initialized
    with data from the server. It receives the TopoJSON `world` object and uses it
    to build the basic map with the `path` object. [Figure 19-4](#d3maps_basic_map)
    shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-5\. Building the map basics
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_mapping_with_d3_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`world` TopoJSON object with the country features with a `names` array connecting
    country names to country feature IDs (e.g., `{id:36, name: ''Australia''}`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_mapping_with_d3_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Object that, if given country-name key, returns its respective GeoJSON geometry.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_mapping_with_d3_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we insert this `path` before the `graticule` grid, keeping the grid
    overlay on top.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_mapping_with_d3_CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Uses `datum` to assign the whole `land` object to our `path`.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1904](assets/dpj2_1904.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19-4\. The basic map
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'With our map shapes in place, we can use a little CSS to style [Figure 19-4](#d3maps_basic_map),
    adding a light azure for the oceans and light gray for the land. The `graticule`
    is a half-transparent dark gray and the country boundaries white:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With the SVG map assembled, let’s see how we use the winners dataset to draw
    the Nobel Prize–winning countries and the red indicator for number of wins.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first time our Nobel map gets updated is when the visualization is initialized.
    At this point the selected dataset is unfiltered, containing all the Nobel Prize
    winners. Subsequently, in response to filters applied by the user (e.g., all the
    Chemistry winners or those from France), the dataset will change and our map changes
    to reflect that.
  prefs: []
  type: TYPE_NORMAL
- en: 'So updating the map involves sending it a dataset of the Nobel Prize–winning
    countries with their current prize haul, dependent on the user filters applied.
    To do this, we use an `updateMap` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `countryData` array has this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_mapping_with_d3_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The number of winners for the US in the currently selected dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to convert this array before sending it to our D3 map. The following
    code does this job, providing an array of country objects with properties `geo`
    (the country’s GeoJSON geometry), `name` (the country name), and `number` (the
    country’s number of Nobel Prize winners):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_mapping_with_d3_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Filters out countries with no winners—​we only display winning countries on
    the map.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_mapping_with_d3_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Uses the country’s key (its name in this case) to retrieve its GeoJSON feature.
  prefs: []
  type: TYPE_NORMAL
- en: We want to display a red circular indicator at the center of our winning countries,
    indicating the number of prizes won. The circles’ areas should be proportional
    to the number of prizes won (absolute or per capita), which means (by circle area
    = pi × radius-squared) their radius should be a function of the square root of
    that prize number. D3 provides a handy `sqrt` scale for just such a need, allowing
    you to set a domain (min and max prize number in this case) and a range (min and
    max indicator radius).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see a quick example of the `sqrt` scale in action. In the following code,
    we set a scale with a domain between 0 and 100 and a zero-based range with a maximum
    area of 25 (5 × 5). This means calling the scale with 50 (half the range) should
    give the square root of half the maximum area (12.5):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To create our indicator radius scale, we create a `sqrt` scale using the maximum
    and minimum radii specified in *nbviz_core.js* to set its range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to get the domain to our scales, we use this `mapData` to get the
    maximum number of winners per country and use that value as the domain’s upper
    value, with `0` for its lower:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To add our country shapes to the existing map, we bind `mapData` to a selection
    on the `countries` group of class `country` and implement an update pattern (see
    [“Updating the DOM with Data”](ch17.xhtml#d3bar_update)) to first add any country
    shapes required by the `mapData`. Instead of removing unbound country paths, we
    use the CSS `opacity` property to make the bound countries visible and the unbound
    invisible. A two-second transition is used to make these countries fade in and
    out appropriately. [Example 19-6](#d3maps_update_countries_code) shows the update
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-6\. Updating the country shapes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_mapping_with_d3_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the GeoJSON data to create country map shapes using our `path` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_mapping_with_d3_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: UI placeholders, which set the SVG paths to class *active* on mouse-over. Note
    that we use the `function` keyword here as opposed to the usual arrow notation
    shorthand (`⇒`). This is because we wish to use D3 to access the DOM element (map
    region) entered by the mouse using the `this` keyword, which is not available
    with arrow functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_mapping_with_d3_CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: A customized `exit` function that fades out (sets opacity to 0) the country
    shape over 2000 (`TRANS_DURATION`) milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_mapping_with_d3_CO10-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Any new countries are faded in (opacity 1) over 2000 (`TRANS_DURATION`) ms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we add a CSS `country` class to freshly entered countries, setting
    their color to a light green. In addition to this, the mouse events are used to
    class the country `active` if the cursor is over it, highlighting it with a darker
    green. Here are the CSS classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The update pattern shown in [Example 19-6](#d3maps_update_countries_code) will
    smoothly transition from old to new datasets, produced in response to user-applied
    filters and passed to `updateMap`. All we need now is to add similarly responsive
    filled circular indicators, centered on the active countries and reflecting their
    current value, either an absolute or relative (per capita) measure of their Nobel
    Prize haul.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Value Indicators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To add our circular value indicators, we want an update pattern that mirrors
    that used to create our country SVG paths. We want to bind to the `mapData` dataset
    and append, update, and remove our indicator circles accordingly. As with the
    country shapes, we’ll adjust the indicators’ opacity to add and remove them from
    the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'The indicators need to be placed at the center of their respective countries.
    D3’s `path` generator provides a number of useful utility methods for dealing
    with GeoJSON geometries. One of them is `centroid`, which computes the projected
    centroid for the specified feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: While `path.centroid` does a pretty good job as a rule, and is very useful for
    labeling shape, boundaries, and so on, it can produce strange results, particularly
    with highly concave geometries. Handily, the world country data we stored in [“Getting
    Country Data for the Nobel Dataviz”](ch05.xhtml#country_data) contains the central
    coordinates of all our Nobel Prize countries.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll first write a little method to retrieve those given a `mapData` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_mapping_with_d3_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the latitude and longitude of our country’s center by name, using the stored
    world country data.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_mapping_with_d3_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use our equirectangular `projection` to turn these into SVG coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Example 19-7](#d3maps_centroid_code), we bind our `mapData` to
    the selection of all elements of class `centroid` in the `centroids` group we
    added in [Example 19-5](#d3maps_basic_map_code). The data is bound via the `name`
    key.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-7\. Adding prize-haul indicators to the Nobel countries’ centroids
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_mapping_with_d3_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Binds the map data to the centroid elements using the `name` key.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_mapping_with_d3_CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Uses the `getCentroid` function to return pixel positions for the geocoordinates
    of the countries’ centers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_mapping_with_d3_CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This 2000 ms transition fades the circular marker in by increasing its opacity
    while simultaneously transitioning to its new radius.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a bit of CSS, we can make the indicators red and slightly transparent,
    allowing map details and, where they are densely packed in Europe, other indicators
    to show through. If the country is selected by the user, using the country filter
    on the UI bar, it is classed as `active` and given a golden hue. Here’s the CSS
    to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_mapping_with_d3_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This allows mouse events to propagate to country shapes below the circles, allowing
    the user to still click on them.
  prefs: []
  type: TYPE_NORMAL
- en: The active centroid indicators we just added are the last element of our Nobel
    Prize map. Now let’s take a look at the complete article.
  prefs: []
  type: TYPE_NORMAL
- en: Our Completed Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the country and indicator update patterns in place, our map should respond
    to user-driven filtering with a smooth transition. [Figure 19-5](#d3maps_transition)
    shows the result of selecting Nobel Prizes for Economics. Only winning countries
    remain highlighted and the value indicators are resized, reflecting American dominance
    of this category.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1905](assets/dpj2_1905.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19-5\. (left) Shows the map with the full Nobel dataset; (right) prizes
    are filtered by category, showing the Economics winners (and the dominance of
    the US economists)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The map as it stands in not interactive but does show when a user hovers over
    a particular country with a mouse, by calling the `mouseenter` and `mouseout`
    callback functions and adding or removing an `active` class. These callbacks could
    easily be used to add more functionality to the map, such as tooltips or the use
    of the countries as clickable data filters. Let’s now use these to build a simple
    tooltip, to show the country the mouse is hovering over and some simple prize
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Simple Tooltip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tooltips and other interactive widgets are the kind of thing commonly demanded
    of data visualizers and though they can get quite involved, particularly if they
    themselves are interactive (e.g., menus that appear on mouse hover), there are
    some simple recipes that are very handy to know. In this section, I’ll show how
    to build a simple but pretty effective tooltip. [Figure 19-6](#d3map_tooltip)
    shows what we’re aiming to build.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1504](assets/dpj2_1504.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19-6\. A simple tooltip for our Nobel Prize map
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s remind ourselves of our current `countries` update, where `mouseenter`
    and `mouseout` event handlers are added during a data-join:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to add a tooltip to our map, we need to do three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a tooltip box in HTML with placeholders for the information we want to
    display—​in this case, country name and number of wins in the selected prize category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display this HTML box over the mouse when the user moves it into a country and
    hide it when they move the mouse out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the box when displayed using the data bound to the country underneath
    the mouse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We create the HTML for the tooltip by adding a content block to the Nobel-viz
    map section, with ID `map-tooltip`, an `<h2>` header for its title, and a `<p>`
    tag for the tooltip’s text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also need some CSS for the tooltip’s look and feel, added to our *style.css*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_mapping_with_d3_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Setting `pointer-events` to `none` effectively lets you click on things underneath
    the tooltip.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_mapping_with_d3_CO14-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Initially, the tooltip is hidden far to the (virtual) left of the browser window,
    using a large negative x index.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our tooltip’s HTML in place and the element hidden to the left of the
    browser window (`left` is –9999 pixels), we just need to extend our `mousein`
    and `mouseout` callback functions to display or hide the tooltip. The `mousein`
    function, called when the user moves the mouse into a country, does most of the
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_mapping_with_d3_CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: D3’s `pointer` method returns the mouse coordinates from the `event` object
    (here, relative to the parent map group) in pixels, which we can use to position
    the tooltip.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_mapping_with_d3_CO15-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We get the computed width and height of the tooltip box, which has been adjusted
    to accommodate our country title and prize string.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_mapping_with_d3_CO15-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the mouse coordinates and the width and height of the tooltip box to
    position the box centered horizontally and roughly above the mouse cursor (the
    width and height don’t include our 10 pixels of padding around the tooltip’s `<div>`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_mapping_with_d3_CO15-4)'
  prefs: []
  type: TYPE_NORMAL
- en: When the mouse leaves a country, we vanish the tooltip by placing it to the
    far left of the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `mouseenter` callback function written, we now only need a `mouseout`
    to hide the tooltip by placing it far to the left of the browser window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_mapping_with_d3_CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: When the mouse leaves the country we shift the tooltip far to the left, out
    of the browser viewport, and remove the `'active'` class from the country, returning
    it to the default country color.
  prefs: []
  type: TYPE_NORMAL
- en: With the `mouseenter` and `mouseout` functions operating in concert, you should
    see the tooltip appearing and disappearing where needed, just as shown in [Figure 19-6](#d3map_tooltip).
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the map module is imported, it appends a callback function to the callbacks
    array in the core module. When data is updated in response to user interaction,
    this callback function is called and the bar chart updated with new country data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_mapping_with_d3_CO17-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This anonymous function is called in the core module when data is updated.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve built the map component of our Nobel dataviz, let’s summarize
    what we’ve learned before moving on to show how user input drives the visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'D3 mapping is a rich area, with many varied projections and lots of utility
    methods to help with manipulating geometries. But building a map follows a fairly
    standard procedure, as demonstrated in the chapter: you first choose your projection—say,
    a Mercator or maybe the [Albers conic projection](https://oreil.ly/Nz6Ar) commonly
    used for mapping the US. You then use this projection to create a D3 `path` generator,
    which turns GeoJSON features into SVG paths, creating the map you see. The GeoJSON
    will normally be extracted from more efficient TopoJSON data.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also demonstrated how easy it is with D3 to interactively highlight
    your map and deal with cursor movements. Taken together, the basic set of skills
    should allow you to start building your own mapping visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve constructed all of our SVG-based graphical elements, let’s see
    how well D3 works with conventional HTML elements by building our winners list
    and an individual’s biography box.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch19.xhtml#idm45607741792448-marker)) The math of geometric projections,
    for example, can get complicated fast.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch19.xhtml#idm45607741786480-marker)) I use and thoroughly recommend the
    open source [QGIS](https://www.qgis.org/en/site).
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch19.xhtml#idm45607741781184-marker)) Python’s *topojson.py* and the TopoJSON
    command-line program.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch19.xhtml#idm45607741779664-marker)) As we’ll see, it does lack a couple
    of our Nobel Prize countries, but these are too small to be clickable and we have
    the coordinates of their centers, allowing for a visual cue to be overlaid.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch19.xhtml#idm45607741574800-marker)) See [this site by Mike Bostock](https://bost.ocks.org/mike/simplify)
    for a very cool example.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch19.xhtml#idm45607741352656-marker)) By installing globally, you can
    use the `geo2topo` command in any directory.
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch19.xhtml#idm45607741031424-marker)) The [extended set of D3 `projection`s](https://oreil.ly/14vLd)
    is part of an extension of D3, not in the main library.
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch19.xhtml#idm45607741009120-marker)) See [*https://oreil.ly/oAppn*](https://oreil.ly/oAppn)
    for a nice demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch19.xhtml#idm45607740753936-marker)) See [the D3 GitHub](https://oreil.ly/KqnF6)
    for a full list.
  prefs: []
  type: TYPE_NORMAL
