["```py\nIn [1]: %matplotlib inline\n        import matplotlib.pyplot as plt\n        plt.style.use('seaborn-whitegrid')\n        import numpy as np\n```", "```py\nIn [2]: from sklearn.datasets import make_blobs\n        X, y_true = make_blobs(n_samples=300, centers=4,\n                               cluster_std=0.60, random_state=0)\n        plt.scatter(X[:, 0], X[:, 1], s=50);\n```", "```py\nIn [3]: from sklearn.cluster import KMeans\n        kmeans = KMeans(n_clusters=4)\n        kmeans.fit(X)\n        y_kmeans = kmeans.predict(X)\n```", "```py\nIn [4]: plt.scatter(X[:, 0], X[:, 1], c=y_kmeans, s=50, cmap='viridis')\n\n        centers = kmeans.cluster_centers_\n        plt.scatter(centers[:, 0], centers[:, 1], c='black', s=200);\n```", "```py\nIn [5]: from sklearn.metrics import pairwise_distances_argmin\n\n        def find_clusters(X, n_clusters, rseed=2):\n            # 1\\. Randomly choose clusters\n            rng = np.random.RandomState(rseed)\n            i = rng.permutation(X.shape[0])[:n_clusters]\n            centers = X[i]\n\n            while True:\n                # 2a. Assign labels based on closest center\n                labels = pairwise_distances_argmin(X, centers)\n\n                # 2b. Find new centers from means of points\n                new_centers = np.array([X[labels == i].mean(0)\n                                        for i in range(n_clusters)])\n\n                # 2c. Check for convergence\n                if np.all(centers == new_centers):\n                    break\n                centers = new_centers\n\n            return centers, labels\n\n        centers, labels = find_clusters(X, 4)\n        plt.scatter(X[:, 0], X[:, 1], c=labels,\n                    s=50, cmap='viridis');\n```", "```py\nIn [6]: centers, labels = find_clusters(X, 4, rseed=0)\n        plt.scatter(X[:, 0], X[:, 1], c=labels,\n                    s=50, cmap='viridis');\n```", "```py\nIn [7]: labels = KMeans(6, random_state=0).fit_predict(X)\n        plt.scatter(X[:, 0], X[:, 1], c=labels,\n                    s=50, cmap='viridis');\n```", "```py\nIn [8]: from sklearn.datasets import make_moons\n        X, y = make_moons(200, noise=.05, random_state=0)\n```", "```py\nIn [9]: labels = KMeans(2, random_state=0).fit_predict(X)\n        plt.scatter(X[:, 0], X[:, 1], c=labels,\n                    s=50, cmap='viridis');\n```", "```py\nIn [10]: from sklearn.cluster import SpectralClustering\n         model = SpectralClustering(n_clusters=2,\n                                    affinity='nearest_neighbors',\n                                    assign_labels='kmeans')\n         labels = model.fit_predict(X)\n         plt.scatter(X[:, 0], X[:, 1], c=labels,\n                     s=50, cmap='viridis');\n```", "```py\nIn [11]: from sklearn.datasets import load_digits\n         digits = load_digits()\n         digits.data.shape\nOut[11]: (1797, 64)\n```", "```py\nIn [12]: kmeans = KMeans(n_clusters=10, random_state=0)\n         clusters = kmeans.fit_predict(digits.data)\n         kmeans.cluster_centers_.shape\nOut[12]: (10, 64)\n```", "```py\nIn [13]: fig, ax = plt.subplots(2, 5, figsize=(8, 3))\n         centers = kmeans.cluster_centers_.reshape(10, 8, 8)\n         for axi, center in zip(ax.flat, centers):\n             axi.set(xticks=[], yticks=[])\n             axi.imshow(center, interpolation='nearest', cmap=plt.cm.binary)\n```", "```py\nIn [14]: from scipy.stats import mode\n\n         labels = np.zeros_like(clusters)\n         for i in range(10):\n             mask = (clusters == i)\n             labels[mask] = mode(digits.target[mask])[0]\n```", "```py\nIn [15]: from sklearn.metrics import accuracy_score\n         accuracy_score(digits.target, labels)\nOut[15]: 0.7935447968836951\n```", "```py\nIn [16]: from sklearn.metrics import confusion_matrix\n         import seaborn as sns\n         mat = confusion_matrix(digits.target, labels)\n         sns.heatmap(mat.T, square=True, annot=True, fmt='d',\n                     cbar=False, cmap='Blues',\n                     xticklabels=digits.target_names,\n                     yticklabels=digits.target_names)\n         plt.xlabel('true label')\n         plt.ylabel('predicted label');\n```", "```py\nIn [17]: from sklearn.manifold import TSNE\n\n         # Project the data: this step will take several seconds\n         tsne = TSNE(n_components=2, init='random',\n                     learning_rate='auto',random_state=0)\n         digits_proj = tsne.fit_transform(digits.data)\n\n         # Compute the clusters\n         kmeans = KMeans(n_clusters=10, random_state=0)\n         clusters = kmeans.fit_predict(digits_proj)\n\n         # Permute the labels\n         labels = np.zeros_like(clusters)\n         for i in range(10):\n             mask = (clusters == i)\n             labels[mask] = mode(digits.target[mask])[0]\n\n         # Compute the accuracy\n         accuracy_score(digits.target, labels)\nOut[17]: 0.9415692821368948\n```", "```py\nIn [18]: # Note: this requires the PIL package to be installed\n         from sklearn.datasets import load_sample_image\n         china = load_sample_image(\"china.jpg\")\n         ax = plt.axes(xticks=[], yticks=[])\n         ax.imshow(china);\n```", "```py\nIn [19]: china.shape\nOut[19]: (427, 640, 3)\n```", "```py\nIn [20]: data = china / 255.0  # use 0...1 scale\n         data = data.reshape(-1, 3)\n         data.shape\nOut[20]: (273280, 3)\n```", "```py\nIn [21]: def plot_pixels(data, title, colors=None, N=10000):\n             if colors is None:\n                 colors = data\n\n             # choose a random subset\n             rng = np.random.default_rng(0)\n             i = rng.permutation(data.shape[0])[:N]\n             colors = colors[i]\n             R, G, B = data[i].T\n\n             fig, ax = plt.subplots(1, 2, figsize=(16, 6))\n             ax[0].scatter(R, G, color=colors, marker='.')\n             ax[0].set(xlabel='Red', ylabel='Green', xlim=(0, 1), ylim=(0, 1))\n\n             ax[1].scatter(R, B, color=colors, marker='.')\n             ax[1].set(xlabel='Red', ylabel='Blue', xlim=(0, 1), ylim=(0, 1))\n\n             fig.suptitle(title, size=20);\n```", "```py\nIn [22]: plot_pixels(data, title='Input color space: 16 million possible colors')\n```", "```py\nIn [23]: from sklearn.cluster import MiniBatchKMeans\n         kmeans = MiniBatchKMeans(16)\n         kmeans.fit(data)\n         new_colors = kmeans.cluster_centers_[kmeans.predict(data)]\n\n         plot_pixels(data, colors=new_colors,\n                     title=\"Reduced color space: 16 colors\")\n```", "```py\nIn [24]: china_recolored = new_colors.reshape(china.shape)\n\n         fig, ax = plt.subplots(1, 2, figsize=(16, 6),\n                                subplot_kw=dict(xticks=[], yticks=[]))\n         fig.subplots_adjust(wspace=0.05)\n         ax[0].imshow(china)\n         ax[0].set_title('Original Image', size=16)\n         ax[1].imshow(china_recolored)\n         ax[1].set_title('16-color Image', size=16);\n```"]