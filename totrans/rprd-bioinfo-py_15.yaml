- en: Chapter 14\. Finding Open Reading Frames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The [ORF challenge](https://oreil.ly/DPWXc) is the last Rosalind problem I’ll
    tackle in this book. The goal is to find all the possible open reading frames
    (ORFs) in a sequence of DNA. An ORF is a region of nucleotides between the start
    codon and the stop codon. The solution will consider both the forward and reverse
    complement as well as frameshifts. Although there are existing tools such as TransDecoder
    to find coding regions, writing a bespoke solution brings together many skills
    from previous chapters, including reading a FASTA file, creating the reverse complement
    of a sequence, using string slices, finding k-mers, using multiple `for` loops/iterations,
    translating DNA, and using regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to truncate a sequence to a length evenly divisible by a codon size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `str.find()` and `str.partition()` functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to document a regular expression using code formatting, comments, and Python’s
    implicit string concatenation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code, tests, and solutions for this challenge are located in the *14_orf*
    directory. Start by copying the first solution to the program `orf.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you request the usage, you’ll see the program takes a single positional
    argument of a FASTA-formatted file of sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The first test input file has the same content as the example on the Rosalind
    page. Note that I’ve broken the sequence file here, but it’s a single line in
    the input file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with this input file and note the output. The order of the
    ORFs is not important:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test suite to ensure the program passes the tests. When you are satisfied
    with how your program should work, start over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you probably need no help in defining a single positional file
    argument, but here is the code you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_open_reading_frames_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Define a positional argument that must be a readable text file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `main()` to print the incoming filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the program prints the usage, rejects bad files, and prints the
    filename for a valid argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: At this point, your program should pass the first three tests. Next, I’ll talk
    about how to make the program find ORFs.
  prefs: []
  type: TYPE_NORMAL
- en: Translating Proteins Inside Each Frame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It might be helpful to write a bit of pseudocode to help sketch out what needs
    to happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use a `for` loop to iterate through the input sequences using `Bio.SeqIO`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program to verify that this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'I need to transcribe this to mRNA, which entails changing all the *T*s to *U*s.
    I’ll let you use whatever solution from [Chapter 2](ch02.html#ch02) you like so
    long as your program can now print this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, refer to [Chapter 3](ch03.html#ch03) and have your program print both
    the forward and reverse complements of this sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to [Chapter 7](ch07.html#ch07) to translate the forward and reverse complements
    to proteins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, rather than reading each mRNA sequence from the beginning, implement frameshifts
    by reading them starting from the zeroth, first, and second characters, which
    you can do using a string slice. If you use Biopython to translate the mRNA slice,
    you may encounter the warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Partial codon, len(sequence) not a multiple of three. Explicitly trim the
    sequence or add trailing N before translation. This may become an error in the
    future.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To fix this, I created a function to truncate a sequence to the nearest even
    division by a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 14-1](#fig_14.1) shows the results of shifting through the string `0123456789`
    and truncating each result to a length that is evenly divisible by 3.'
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1401](assets/mpfb_1401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-1\. Truncating the various frameshifts to a length that is evenly
    divisible by the codon size 3
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Here is a test you could use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Change your program to print the protein translations for the three shifts
    for both the forward and reverse complements of the mRNA. Be sure to print the
    entire translation, including all stop (`*`) codons, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Finding the ORFs in a Protein Sequence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the program can find all the protein sequences from each frameshift
    of the mRNA, it’s time to look for the open reading frames in the proteins. Your
    code will need to consider every interval from each start codon to the first subsequent
    stop codon. The codon *AUG* is the most common start codon, and it codes for the
    amino acid methionine (*M*). There are three possible stop codons shown with the
    asterisk (`*`). For example, [Figure 14-2](#fig_14.2) shows that the amino acid
    sequence *MAMAPR** contains two start codons and one stop codon and so has two
    possible proteins of *MAMAPR* and *MAPR*. Although it is common for tools to report
    only the longer sequence, the Rosalind challenge expects all possible sequences.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1402](assets/mpfb_1402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-2\. The protein sequence MAMAPR* has two overlapping open reading
    frames
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'I decided to write a function called `find_orfs()` that will accept an amino
    acid string and return a list of ORFs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_open_reading_frames_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The function accepts a string of amino acids and returns a list of possible
    protein strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_open_reading_frames_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: For now, return the empty list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a test for this function. If you can implement the `find_orfs()` that
    passes this test, then you should be able to pass the integration test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_open_reading_frames_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The empty string should produce no ORFs.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_open_reading_frames_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A single start codon with no stop codon should produce no ORFs.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_open_reading_frames_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: A single stop codon with no preceding start codon should produce no ORFs.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_finding_open_reading_frames_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The function should return the start codon even if there are no intervening
    bases before the stop codon.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_finding_open_reading_frames_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This sequence contains two ORFs.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_finding_open_reading_frames_CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: This sequence also contains only two ORFs.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_finding_open_reading_frames_CO3-7)'
  prefs: []
  type: TYPE_NORMAL
- en: This sequence contains three putative ORFs in two separate sections.
  prefs: []
  type: TYPE_NORMAL
- en: Once you can find all the ORFs in each mRNA sequence, you should collect them
    into a distinct list. I suggest you use a `set()` for this. Though my solution
    prints the ORFs in sorted order, this is not a requirement for the test. The solution
    will bring together many of the skills you’ve already learned. The craft of writing
    longer and longer programs lies in composing smaller pieces that you understand
    and test. Keep plugging away at your program until you pass all the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’ll present three solutions to finding ORFs using two string functions and
    regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 1: Using the str.index() Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start, here is how I wrote the `truncate()` function that will assuage the
    `Bio.Seq.translate()` function when I try to translate the various frame-shifted
    mRNA sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_open_reading_frames_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Find the length of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_open_reading_frames_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The end of the desired subsequence is the length minus the length modulo `k`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_open_reading_frames_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Return the subsequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, here is one way to write the `find_orfs()` that uses the `str.index()`
    function to find each starting *M* codon followed by a `*` stop codon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_open_reading_frames_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a list to hold the ORFs.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_open_reading_frames_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a loop to iterate while there are start codons present.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_open_reading_frames_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `str.index()` to find the location of the start codon.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_finding_open_reading_frames_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: See if the stop codon is present after the start codon’s position.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_finding_open_reading_frames_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the index of the stop codon after the start codon.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_finding_open_reading_frames_CO5-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Use a string slice to grab the protein.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_finding_open_reading_frames_CO5-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Set the amino acid string to the index after the position of the start codon
    to find the next start codon.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_finding_open_reading_frames_CO5-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Leave the `while` loop if there is no stop codon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how I incorporate these ideas into the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_open_reading_frames_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through the input sequences.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_open_reading_frames_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Transcribe the DNA sequence to mRNA.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_open_reading_frames_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty set to hold all the ORFs.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_finding_open_reading_frames_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through the forward and reverse complement of the mRNA.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_finding_open_reading_frames_CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through the frameshifts.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_finding_open_reading_frames_CO6-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Attempt to translate the truncated, frame-shifted mRNA into a protein sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_finding_open_reading_frames_CO6-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through each ORF found in the protein sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_finding_open_reading_frames_CO6-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Add the ORF to the set to maintain a unique list.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_finding_open_reading_frames_CO6-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the sorted ORFs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 2: Using the str.partition() Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is another approach to writing the `find_orfs()` function that uses `str.partition()`.
    This function breaks a string into the part before some substring, the substring,
    and the part after. For instance, the string *MAMAPR*MP** can be partitioned on
    the stop codon (`*`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If the protein sequence does not contain a stop codon, the function returns
    the entire sequence in the first position and empty strings for the others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this version, I use two infinite loops. The first tries to partition the
    given amino acid sequence on the stop codon. If this is not successful, I exit
    the loop. [Figure 14-3](#fig_14.3) shows that the protein sequence *MAMAPR*MP**
    contains two sections that have start and end codons.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1403](assets/mpfb_1403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-3\. The protein sequence MAMAPR*MP* has three ORFs in two sections
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The second loop checks the first partition to find all the subsequences starting
    with the *M* start codon. So in the partition *MAMAPR*, it finds the two sequences
    *MAMAPR* and *MAPR*. The code then truncates the amino acid sequence to the last
    partition, *MP**, to repeat the operation until all ORFs have been found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_open_reading_frames_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a list for the ORFs to return.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_open_reading_frames_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create the first infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_open_reading_frames_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Partition the amino acid sequence on the stop codon.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_finding_open_reading_frames_CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The middle will be empty if the stop codon is not present, so break from the
    outer loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_finding_open_reading_frames_CO7-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Set a variable to remember the last position of a start codon.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_finding_open_reading_frames_CO7-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a second infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_finding_open_reading_frames_CO7-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `str.find()` method to locate the index of the start codon.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_finding_open_reading_frames_CO7-8)'
  prefs: []
  type: TYPE_NORMAL
- en: The value -1 indicates that the start codon is not present, so leave the inner
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_finding_open_reading_frames_CO7-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Add the substring from the start index to the list of ORFs.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](assets/10.png)](#co_finding_open_reading_frames_CO7-10)'
  prefs: []
  type: TYPE_NORMAL
- en: Move the last known position to after the current start position.
  prefs: []
  type: TYPE_NORMAL
- en: '[![11](assets/11.png)](#co_finding_open_reading_frames_CO7-11)'
  prefs: []
  type: TYPE_NORMAL
- en: Truncate the protein sequence to the last part of the initial partition.
  prefs: []
  type: TYPE_NORMAL
- en: '[![12](assets/12.png)](#co_finding_open_reading_frames_CO7-12)'
  prefs: []
  type: TYPE_NORMAL
- en: Return the ORFs to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 3: Using a Regular Expression'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this final solution, I’ll once again point out that a regular expression
    is probably the most fitting solution to find a pattern of text. This pattern
    always starts with *M*, and I can use the `re.findall()` function to find the
    four *M*s in this protein sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The Rosalind challenge does not consider noncanonical start codons, so an ORF
    will always start with an *M* and extend to the first stop codon. In between these,
    there can be zero or more not-stop codons which I can represent using a negated
    character class of `[^*]` that excludes the stop codon followed by a `*` to indicate
    that there can be *zero or more* of the preceding pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'I need to add the stop codon `*` to this pattern. Because the literal asterisk
    is a metacharacter, I must use a backslash to escape it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'I can also place the asterisk inside a character class where it has no meta
    meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 14-4](#fig_14.4) shows this pattern using a finite state machine diagram.'
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1404](assets/mpfb_1404.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-4\. A finite state machine diagram of the regular expression to find
    an open reading frame
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'I can see that this pattern is close to working, but it’s only finding two
    of the three ORFs because the first one overlaps the second one. As in Chapters
    [8](ch08.html#ch08) and [11](ch11.html#ch11), I can wrap the pattern in a positive
    look-ahead assertion. Further, I will use parentheses to create a capture group
    around the ORF up to the stop codon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is one version of the `find_orfs()` that uses this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'While this passes `test_find_orfs()`, this is a complicated regex that I will
    have to relearn every time I come back to it. An alternate way to write this is
    to place each functional piece of the regex on a separate line, followed by an
    end-of-line comment, and rely on Python’s implicit string concatenation (first
    shown in [Chapter 2](ch02.html#ch02)) to join these into a single string. This
    is my preferred method to find the ORFs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_open_reading_frames_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The parentheses group the following lines such that Python will automatically
    join the strings into a single string. Be sure there are no commas or Python will
    create a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_open_reading_frames_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the pattern with the `re.findall()` function.
  prefs: []
  type: TYPE_NORMAL
- en: This is a longer function, but it will be much easier to understand the next
    time I see it. One downside is that `yapf` that I use to format my code will remove
    the vertical alignment of the comments, so I must manually format this section.
    Still, I think it’s worth it to have more self-documenting code.
  prefs: []
  type: TYPE_NORMAL
- en: Going Further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Expand the program to process multiple input files, writing all the unique ORFs
    to an indicated output file.
  prefs: []
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Key points from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Bio.Seq.translate()` function will print warnings if the input sequence
    is not evenly divisible by three, so I wrote a `truncate()` function to trim the
    protein.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `str.find()` and `str.partition()` functions each present ways to find subsequences
    in a string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A regular expression remains my preferred method to find a pattern in some text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complicated regex can be written over multiple lines with comments so that
    Python will implicitly concatenate them into a single string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
