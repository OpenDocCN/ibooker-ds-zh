- en: Chapter 4\. Webdev 101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces the core web-development knowledge you will need to
    understand the web pages you scrape for data and to structure those you want to
    deliver as the skeleton of your JavaScripted visualizations. As you’ll see, a
    little knowledge goes a long way in modern webdev, particularly when your focus
    is building self-contained visualizations and not entire websites (see [“Single-Page
    Apps”](#spas) for more details).
  prefs: []
  type: TYPE_NORMAL
- en: 'The usual caveats apply: this chapter is part reference, part tutorial. There
    will probably be stuff here you know already, so feel free to skip over it and
    get to the new material.'
  prefs: []
  type: TYPE_NORMAL
- en: The Big Picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The humble web page, the basic building block of the World Wide Web (WWW)—that
    fraction of the internet consumed by humans—​is constructed from files of various
    types. Apart from the multimedia files (images, videos, sound, etc.), the key
    elements are textual, consisting of Hypertext Markup Language (HTML), Cascading
    Style Sheets (CSS), and JavaScript. These three, along with any necessary data
    files, are delivered using the Hypertext Transfer Protocol (HTTP) and used to
    build the page you see and interact with in your browser window, which is described
    by the Document Object Model (DOM), a hierarchical tree off which your content
    hangs. A basic understanding of how these elements interact is vital to building
    modern web visualizations, and the aim of this chapter is to get you quickly up
    to speed.
  prefs: []
  type: TYPE_NORMAL
- en: Web development is a big field, and the aim here is not to turn you into a full-fledged
    web developer. I assume you want to limit the amount of webdev you have to do
    as much as possible, focusing only on that fraction necessary to build a modern
    visualization. In order to build the sort of visualizations showcased at [*d3js.org*](https://d3js.org),
    published in the *New York Times*, or incorporated in basic interactive data dashboards,
    you actually need surprisingly little webdev fu. The result of your labors should
    be easy to add to a larger website by someone dedicated to that job. In the case
    of small, personal websites, it’s easy enough to incorporate the visualization
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Single-Page Apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Single-page applications* (SPAs) are web applications (or whole sites) that
    are dynamically assembled using JavaScript, often building upon a lightweight
    HTML backbone and CSS styles that can be applied dynamically using class and ID
    attributes. Many modern data visualizations fit this description, including the
    Nobel Prize visualization this book builds toward.'
  prefs: []
  type: TYPE_NORMAL
- en: Often self-contained, the SPA’s root folder can be easily incorporated in an
    existing website or stand alone, requiring only an HTTP server such as Apache
    or NGINX.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking of our data visualizations in terms of SPAs removes a lot of the cognitive
    overhead from the webdev aspect of JavaScript visualizations, allowing us to focus
    on programming challenges. The skills required to put the visualization on the
    web are still fairly basic and quickly amortized. Often it will be someone else’s
    job.
  prefs: []
  type: TYPE_NORMAL
- en: Tooling Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you’ll see, the webdev needed to make modern data visualizations requires
    no more than a decent text editor, modern browser, and a terminal ([Figure 4-1](#webdev101_tools)).
    I’ll cover what I see as the minimal requirements for a webdev-ready editor and
    nonessential but nice-to-have features.
  prefs: []
  type: TYPE_NORMAL
- en: 'My browser development tools of choice are [Chrome’s web-developer kit](https://oreil.ly/52Z3e),
    freely available on all platforms. It has a lot of tab-delineated functionality,
    the following of which I’ll cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Elements* tab, which allows you to explore the structure of a web page,
    its HTML content, CSS styles, and DOM presentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Sources* tab, where most of your JavaScript debugging will take place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll need a terminal for output, starting your local web server, and maybe
    sketching ideas with the IPython interpreter. These days I tend to use browser-based
    [Jupyter notebooks](https://jupyter.org) as my Python dataviz *sketchpad*—one
    of the key advantages being that the session persists in the form of a notebook
    (*.ipynb*) file, which you can use to restart the session at later dates. You
    also get to iteratively explore your data with embedded charts. We’ll be putting
    this to good use in [Part III](part03.xhtml#part_clean_explore).
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 0401](assets/dpj2_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. Primary webdev tools
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Before dealing with what you do need, let’s deal with a few things you don’t
    need when setting out, laying a couple of myths to rest on the way.
  prefs: []
  type: TYPE_NORMAL
- en: The Myth of IDEs, Frameworks, and Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a common assumption among the prospective JavaScripter that to program
    for the web requires a complex toolset, primarily an Intelligent Development Environment
    (IDE), as used by enterprise—​and other—​coders everywhere. This is potentially
    expensive and presents another learning curve. The good news is that you can create
    professional-level web dataviz with nothing more than a decent text editor. In
    fact, until you start dealing with modern JavaScript frameworks (and I would hold
    off on that while you get your webdev legs) an IDE doesn’t provide much advantage,
    while usually being less performant. More good news is that the free as in beer
    lightweight [Visual Studio Code IDE (VSCode)](https://code.visualstudio.com) has
    become the de facto standard for web development. If you already use VSCode or
    want a few more bells and whistles, it’s a good workhorse for following this book.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a common myth that one cannot be productive in JavaScript without
    using a framework of some kind.^([1](ch04.xhtml#idm45607793744992)) At the moment,
    a number of these frameworks are vying for control of the JS ecosystem, most sponsored
    by the various huge companies that created them. These frameworks come and go
    at a dizzying rate, and my advice for anyone starting out in JavaScript is to
    ignore them entirely while you develop your core skills. Use small, targeted libraries,
    such as those in the jQuery ecosystem or Underscore’s functional programming extensions,
    and see how far you can get before needing a *my way or the highway* framework.
    Only lock yourself into a framework to meet a clear and present need, not because
    the current JS groupthink is raving about how great it is.^([2](ch04.xhtml#idm45607793740624))
    Another important consideration is that D3, the prime web dataviz library, doesn’t
    really play well with any of the bigger frameworks I know, particularly the ones
    that want control over the DOM. Making D3 framework-compliant is an advanced skill.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing you’ll find if you hang around webdev forums, Reddit lists, and
    Stack Overflow is a huge range of tools constantly clamoring for attention. There
    are JS+CSS minifiers and watchers to automatically detect file changes and reload
    web pages during development, among others. While a few of these have their place,
    in my experience there are a lot of flaky tools that probably cost more time in
    hair-tearing than they gain in productivity. To reiterate, you can be very productive
    without these things and should only reach for one to scratch an urgent itch.
    Some are keepers, but very few are even remotely essential for data visualization
    work.
  prefs: []
  type: TYPE_NORMAL
- en: A Text-Editing Workhorse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First and foremost among your webdev tools is a text editor that you are comfortable
    with and which can, at the very least, do syntax highlighting for multiple languages—​in
    our case, HTML, CSS, JavaScript, and Python. You can get away with a plain, nonhighlighting
    editor, but in the long run it will prove to be a pain. Things like syntax highlighting,
    code linting, intelligent indentation, and the like remove a huge cognitive load
    from the process of programming, so much so that I see their absence as a limiting
    factor. These are my minimal requirements for a text editor:'
  prefs: []
  type: TYPE_NORMAL
- en: Syntax highlighting for all languages you use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurable indentation levels and types for languages (e.g., Python 4 soft
    tabs, JavaScript 2 soft tabs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple windows/panes/tabs to allow easy navigation around your codebase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A decent [code linter](https://oreil.ly/6BOEU) (see [Figure 4-2](#webdev101_linter))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using a relatively advanced text editor, all the above should come
    as standard with the exception of code linting, which may require a bit of configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 0402](assets/dpj2_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. A running code linter analyzes the JavaScript continuously, highlighting
    syntax errors in red and adding an ! to the left of the offending line
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Browser with Development Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the reasons a full-fledged IDE is less vital in modern webdev is that
    the best place to do debugging is in the web browser itself, and such is the pace
    of change there that any IDE attempting to emulate that context will have its
    work cut out for it. On top of this, modern web browsers have evolved a powerful
    set of debugging and development tools. The best among these is [Chrome DevTools](https://oreil.ly/jBLc9),
    which offers a huge amount of functionality, from sophisticated (certainly to
    a Pythonista) debugging (parametric breakpoints, variable watches, etc.) to memory
    and processor optimization profiling, device emulation (want to know what your
    web page looks like on a smartphone or tablet?), and a whole lot more. Chrome
    DevTools is my debugger of choice and will be used in this book. Like everything
    covered, it’s free to use.
  prefs: []
  type: TYPE_NORMAL
- en: Terminal or Command Prompt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The terminal or command line is where you initiate the various servers and probably
    output useful logging information. It’s also where you’ll try out Python modules
    or run a Python interpreter (IPython being in many ways the best).
  prefs: []
  type: TYPE_NORMAL
- en: Building a Web Page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are four elements to a typical web visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: An HTML skeleton, with placeholders for our programmatic visualization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cascading Style Sheets (CSS), which define the look and feel (e.g., border widths,
    colors, font sizes, placement of content blocks)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript to build the visualization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data to be transformed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first three of these are just text files, created using our favorite editor
    and delivered to the browser by the web server (see [Chapter 12](ch12.xhtml#chapter_delivery_intro)).
    Let’s examine each in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Serving Pages with HTTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The delivery of the HTML, CSS, and JS files that are used to make a particular
    web page (and any related data files, multimedia, etc.) is negotiated between
    a server and browser using the Hypertext Transfer Protocol. HTTP provides a number
    of methods, the most commonly used being GET, which requests a web resource, retrieving
    data from the server if all goes well or throwing an error if it doesn’t. We’ll
    be using GET, along with Python’s requests module, to scrape some web page content
    in [Chapter 6](ch06.xhtml#chapter_heavy_scraping).
  prefs: []
  type: TYPE_NORMAL
- en: 'To negotiate the browser-generated HTTP requests, you’ll need a server. In
    development, you can run a little server locally using Python’s built-in web server
    (one of the batteries included), part of the `http` module. You start the server
    at the command line, with an optional port number (default 8000), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This server is now serving content locally on port 8080\. You can access the
    site it is serving by going to the URL *http://localhost:8080* in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: The `http.server` module is a nice thing to have and OK for demos and the like,
    but it lacks a lot of basic functionality. For this reason, as we’ll see in [Part IV](part04.xhtml#part_delivery),
    it’s better to master the use of a proper development (and production) server
    like Flask (this book’s server of choice).
  prefs: []
  type: TYPE_NORMAL
- en: The DOM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HTML files you send through HTTP are converted at the browser end into a
    Document Object Model, or DOM, which can in turn be adapted by JavaScript because
    this programmatic DOM is the basis of dataviz libraries like D3\. The DOM is a
    tree structure, represented by hierarchical nodes, the top node being the main
    web page or document.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, the HTML you write or generate with a template is converted by
    the browser into a tree hierarchy of nodes, each one representing an HTML element.
    The top node is called the *Document Object*, and all other nodes descend in a
    parent-child fashion. Programmatically manipulating the DOM is at the heart of
    such libraries as jQuery and the mighty D3, so it’s vital to have a good mental
    model of what’s going on. A great way to get the feel for the DOM is to use a
    web tool such as *Chrome DevTools* (my recommended toolset) to inspect branches
    of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever you see rendered on the web page, the bookkeeping of the object’s state
    (displayed or hidden, matrix transform, etc.) is being done with the DOM. D3’s
    powerful innovation was to attach data directly to the DOM and use it to drive
    visual changes (Data-Driven Documents).
  prefs: []
  type: TYPE_NORMAL
- en: The HTML Skeleton
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A typical web visualization uses an HTML skeleton, and builds the visualization
    on top of it using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: HTML is the language used to describe the content of a web page. It was first
    proposed by physicist Tim Berners-Lee in 1980 while he was working at the CERN
    particle accelerator complex in Switzerland. It uses tags such as `<div>`, `<img>`,
    and `<h>` to structure the content of the page, while CSS is used to define the
    look and feel.^([3](ch04.xhtml#idm45607793670928)) The advent of HTML5 has reduced
    the boilerplate considerably, but the essence has remained essentially unchanged
    over those thirty years.
  prefs: []
  type: TYPE_NORMAL
- en: Fully specced HTML used to involve a lot of rather confusing header tags, but
    with HTML5 some thought was put into a more user-friendly minimalism. This is
    pretty much the minimal requirement for a starting template:^([4](ch04.xhtml#idm45607793668384))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So we need only declare the document HTML, our character set 8-bit Unicode,
    and a `<body>` tag below which to add our page content. This is a big improvement
    on the bookkeeping required before and provides a very low threshold to entry
    as far as creating the documents that will be turned into web pages goes. Note
    the comment tag form: `<!-- comment -->`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'More realistically, we would probably want to add some CSS and JavaScript.
    You can add both directly to an HTML document by using the `<style>` and `<script>`
    tags like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This single-page HTML form is often used in examples such as the visualizations
    at [*d3js.org*](https://d3js.org). It’s convenient to have a single page to deal
    with when demonstrating code or keeping track of files, but generally I’d suggest
    separating the HTML, CSS, and JavaScript elements into separate files. The big
    win here, apart from easier navigation as the codebase gets larger, is that you
    can take full advantage of your editor’s specific language enhancements such as
    solid syntax highlighting and code linting (essentially syntax checking on the
    fly). While some editors and libraries claim to deal with embedded CSS and JavaScript,
    I haven’t found an adequate one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use CSS and JavaScript files, we just include them in the HTML using `<link>`
    and `<script>` tags like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Marking Up Content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visualizations often use a small subset of the available HTML tags, usually
    building the page programmatically by attaching elements to the DOM tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common tag is the `<div>`, marking a block of content. `<div>`s can
    contain other `<div>`s, allowing for a tree hierarchy, the branches of which are
    used during element selection and to propagate user interface (UI) events such
    as mouse clicks. Here’s a simple `<div>` hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of `id` and `class` attributes. These are used when you’re selecting
    DOM elements and to apply CSS styles. IDs are unique identifiers; each element
    should have only one and there should be only one occurrence of any particular
    ID per page. The class can be applied to multiple elements, allowing bulk selection,
    and each element can have multiple classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For textual content, the main tags are `<p>`, `<h*>`, and `<br>`. You’ll be
    using these a lot. This code produces [Figure 4-3](#webdev101_h2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![dpj2 0403](assets/dpj2_0403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. An h2 header and text
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Header tags are reverse-ordered by size from the largest `<h1>`.
  prefs: []
  type: TYPE_NORMAL
- en: '`<div>`, `<h*>`, and `<p>` are what is known as *block elements*. They normally
    begin and end with a new line. The other class of tag is *inline elements*, which
    display without line breaks. Images `<img>`, hyperlinks `<a>`, and table cells
    `<td>` are among these, which include the `<span>` tag for inline text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdev_101_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we don’t need a closing tag for images.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdev_101_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The span and link are continuous in the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other useful tags include lists, ordered `<ol>` and unordered `<ul>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdev_101_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Here we apply a CSS style directly (inline) on the `div` tag. See [“Positioning
    and Sizing Containers with Flex”](#sect_flexboxes) for an introduction to the
    `flex` display property.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-4](#webdev101_lists) shows the rendered lists.'
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 0404](assets/dpj2_0404.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4\. HTML lists
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'HTML also has a dedicated `<table>` tag, useful if you want to present raw
    data in your visualization. This HTML produces the header and row in [Figure 4-5](#webdev101_table):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdev_101_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The header row
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdev_101_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The first row of data
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 0405](assets/dpj2_0405.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-5\. An HTML table
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you are making web visualizations, the most often used of the previous
    tags are the textual tags, which provide instructions, information boxes, and
    so on. But the meat of our JavaScript efforts will probably be devoted to building
    DOM branches rooted on the Scalable Vector Graphics (SVG) `<svg>` and `<canvas>`
    tags. On most modern browsers, the `<canvas>` tag also supports a 3D *WebGL* context,
    allowing *OpenGL* visualizations to be embedded in the page.^([5](ch04.xhtml#idm45607792973152))
  prefs: []
  type: TYPE_NORMAL
- en: We’ll deal with SVG, the focus of this book and the format used by the mighty
    D3 library, in [“Scalable Vector Graphics”](#sect_svg). Now let’s look at how
    we add style to our content blocks.
  prefs: []
  type: TYPE_NORMAL
- en: CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*CSS*, short for Cascading Style Sheets, is a language for describing the look
    and feel of a web page. Though you can hardcode style attributes into your HTML,
    it’s generally considered bad practice.^([6](ch04.xhtml#idm45607792962112)) It’s
    much better to label your tag with an `id` or `class` and use that to apply styles
    in the stylesheet.'
  prefs: []
  type: TYPE_NORMAL
- en: The key word in CSS is *cascading*. CSS follows a precedence rule so that in
    the case of a clash, the latest style overrides earlier ones. This means the order
    of inclusion for sheets is important. Usually, you want your stylesheet to be
    loaded last so that you can override both the browser defaults and styles defined
    by any libraries you are using.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-6](#css) shows how CSS is used to apply styles to the HTML elements.
    First, you select the element using hashes (#) to indicate a unique ID and dots
    (.) to select members of a class. You then define one or more property/value pairs.
    Note that the `font-family` property can be a list of fallbacks, in order of preference.
    Here we want the browser default `font-family` of `serif` (capped strokes) to
    be replaced with the more modern `sans-serif`, with `Helvetica Neue` as our first
    choice.'
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 0406](assets/dpj2_0406.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-6\. Styling the page with CSS
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Understanding CSS precedence rules is key to successfully applying styles.
    In a nutshell, the order is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`!important` after CSS property trumps all.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The more specific the better (i.e., IDs override classes).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The order of declaration: last declaration wins, subject to *1* and *2*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, for example, say we have a `<span>` of class `alert`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting the following in our *style.css* file will make the alert text red
    and bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then add this to the *style.css*, the ID color black will override the
    class color red, while the class `font-weight` remains bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To enforce the color red for alerts, we can use the `!important` directive:^([7](ch04.xhtml#idm45607792857568))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then add another stylesheet, *style2.css*, after *style.css*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'with *style2.css* containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: then the `font-weight` of the alert will be reverted to `normal` because the
    new class style was declared last.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript is the only browser-based programming language, with an interpreter
    included in all modern browsers. In order to do anything remotely advanced (and
    that includes all modern web visualizations), you should have a JavaScript grounding.
    [TypeScript](https://www.typescriptlang.org) is a superset of JavaScript that
    provides strong typing and is currently gaining a lot of traction. TypeScript
    compiles to and presupposes competence in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 99% of all coded web visualization examples, the ones you should aim to be learning
    from, are in JavaScript, and voguish alternatives have a way of fading with time.
    In essence, good competence in (if not mastery of) JavaScript is a prerequisite
    for interesting web visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: The good news for Pythonistas is that JavaScript is actually quite a nice language
    once you’ve tamed a few of its more awkward quirks.^([8](ch04.xhtml#idm45607792772048))
    As I showed in [Chapter 2](ch02.xhtml#chapter_language_bridge), JavaScript and
    Python have a lot in common and it’s usually easy to translate from one to the
    other.
  prefs: []
  type: TYPE_NORMAL
- en: Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data needed to fuel your web visualization will be provided by the web server
    as static files (e.g., JSON or CSV files) or dynamically through some kind of
    web API (e.g., [RESTful APIs](https://oreil.ly/RwvhM)), usually retrieving the
    data server-side from a database. We’ll be covering all these forms in [Part IV](part04.xhtml#part_delivery).
  prefs: []
  type: TYPE_NORMAL
- en: Although a lot of data used to be delivered in [XML form](https://oreil.ly/2IvEi),
    modern web visualization is predominantly about JSON and, to a lesser extent,
    CSV or TSV files.
  prefs: []
  type: TYPE_NORMAL
- en: '[JSON](https://oreil.ly/kCBDk) (short for JavaScript Object Notation) is the
    de facto web visualization data standard and I recommend you learn to love it.
    It obviously plays very nicely with JavaScript, but its structure will also be
    familiar to Pythonistas. As we saw in [“JSON”](ch03.xhtml#read_write_json), reading
    and writing JSON data with Python is a snap. Here’s a little example of some JSON
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Chrome DevTools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The arms race in JavaScript engines in recent years, which has produced huge
    increases in performance, has been matched by an increasingly sophisticated range
    of development tools built into the various browsers. Firefox’s Firebug led the
    pack for a while but [Chrome DevTools](https://oreil.ly/djHBp) have surpassed
    it, and are adding functionality all the time. There’s now a huge amount you can
    do with Chrome’s tabbed tools, but here I’ll introduce the two most useful tabs,
    the HTML+CSS-focused *Elements* and the JavaScript-focused *Sources*. Both of
    these work in complement to Chrome’s developer console, demonstrated in [“JavaScript”](ch02.xhtml#bridge_js_interact).
  prefs: []
  type: TYPE_NORMAL
- en: The Elements Tab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To access the Elements tab, select More Tools→Developer Tools from the righthand
    options menu or use the Ctrl-Shift-I keyboard shortcut (Cmd-Option-I in Mac).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-7](#webdev101_elements) shows the Elements tab at work. You can select
    DOM elements on the page by using the lefthand magnifying glass and see their
    HTML branch in the left panel. The right panel allows you to see CSS styles applied
    to the element and look at any event listeners that are attached or DOM properties.'
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 0407](assets/dpj2_0407.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-7\. Chrome DevTools Elements tab
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: One really cool feature of the Elements tab is that you can interactively change
    element styling for both CSS styles and attributes.^([9](ch04.xhtml#idm45607792668960))
    This is a great way to refine the look and feel of your data visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: Chrome’s Elements tab provides a great way to explore the structure of a page,
    finding out how the different elements are positioned. This is good way to get
    your head around positioning content blocks with the `position` and `float` properties.
    Seeing how the pros apply CSS styles is a really good way to up your game and
    learn some useful tricks.
  prefs: []
  type: TYPE_NORMAL
- en: The Sources Tab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Sources tab allows you to see any JavaScript included in the page. [Figure 4-8](#webdev101_sources)
    shows the tab at work. In the lefthand panel, you can select a script or an HTML
    file with embedded `<script>` tagged JavaScript. As shown, you can place a breakpoint
    in the code, load the page, and, on break, see the call stack and any scoped or
    global variables. These breakpoints are parametric, so you can set conditions
    for them to trigger, which is handy if you want to catch and step through a particular
    configuration. On break, you have the standard to step in, out, and over functions,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 0408](assets/dpj2_0408.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-8\. Chrome DevTools Sources tab
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Sources tab is a fantastic resource and greatly reduces the need for console
    logging^([10](ch04.xhtml#idm45607792628480)) when trying to debug JavaScript.
    In fact, where JS debugging was once a major pain point, it is now almost a pleasure.
  prefs: []
  type: TYPE_NORMAL
- en: Other Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s a huge amount of functionality in those Chrome DevTools tabs, and they
    are being updated almost daily. You can do memory and CPU timelines and profiling,
    monitor your network downloads, and test out your pages for different form factors.
    But you’ll spend the large majority of your time as a data visualizer in the Elements
    and Sources tabs.
  prefs: []
  type: TYPE_NORMAL
- en: A Basic Page with Placeholders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have covered the major elements of a web page, let’s put them together.
    Most web visualizations start off as HTML and CSS skeletons, with placeholder
    elements ready to be fleshed out with a little JavaScript plus data (see [“Single-Page
    Apps”](#spas)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll first need our HTML skeleton, using the code in [Example 4-1](#skel_html).
    This consists of a tree of `<div>` content blocks defining three chart elements:
    a header, main, and sidebar section. We’ll save this file as *index.xhtml*.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-1\. The file index.xhtml, our HTML skeleton
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our HTML skeleton, we want to style it using some CSS. This
    will use the classes and IDs of our content blocks to adjust size, position, background
    color, etc. To apply our CSS, in [Example 4-1](#skel_html) we import a *style.css*
    file, shown in [Example 4-2](#skel_css).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-2\. The style.css file, providing our CSS styling
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdev_101_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This `dev` class is a handy way to see the border of any visual blocks, which
    is useful for visualization work.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdev_101_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Makes `chart-components` the relative parent.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_webdev_101_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Makes the `main` and `sidebar` positions relative to `chart-components`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_webdev_101_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Positions this block flush with the right wall of `chart-components`.
  prefs: []
  type: TYPE_NORMAL
- en: We use absolute positioning of the main and sidebar chart elements ([Example 4-2](#skel_css)).
    There are various ways to position the content blocks with CSS, but absolute positioning
    gives you explicit control over their placement, which is a must if you want to
    get the look just right.
  prefs: []
  type: TYPE_NORMAL
- en: After specifying the size of the `chart-components` container, the `main` and
    `sidebar` child elements are sized and positioned using percentages of their parent.
    This means any changes to the size of `chart-components` will be reflected in
    its children.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our HTML and CSS defined, we can examine the skeleton by firing up Python’s
    single-line HTTP server in the project directory containing the *index.xhtml*
    and *style.css* files defined in Examples [4-1](#skel_html) and [4-2](#skel_css),
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 4-9](#placeholder) shows the resulting page with the Elements tab open,
    displaying the page’s DOM tree.'
  prefs: []
  type: TYPE_NORMAL
- en: The chart’s content blocks are now positioned and sized correctly, ready for
    JavaScript to add some engaging content.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 0409](assets/dpj2_0409.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-9\. Building a basic web page
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Positioning and Sizing Containers with Flex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Historically positioning and sizing content (usually `<div>` containers) with
    CSS was somewhat of a dark art. It didn’t help that there were a lot of cross-browser
    incompatibilities and disagreements about what constituted padding or margins.
    But even allowing for that, the CSS properties used seemed pretty ad-hoc. Often
    achieving what seems to be a perfectly reasonable positioning or sizing ambition
    turned out to involve arcane CSS knowledge, hidden in the deep recesses of a Stack
    Overflow thread. One example being centering a `div` in the horizontal and vertical.^([11](ch04.xhtml#idm45607792243232))
    This has all changed with the advent of the CSS flex-box, which uses some powerful
    new CSS properties to provide almost all the sizing and positioning you’ll ever
    need.
  prefs: []
  type: TYPE_NORMAL
- en: Flex-boxes aren’t quite one CSS property to rule them all—the absolute positioning
    demonstrated in the previous section still has its place, particularly with data
    visualizations—but they are a collection of very powerful properties which, more
    often than not, represent the simplest, and sometimes the only, way to achieve
    a particular placing/sizing mission. Effects that used to require CSS expertise
    are now well within the grasp of a relative newbie and the icing on the cake is
    that flex-boxes play really well with variable screen ratios—the power of the
    flex. With that in mind, let’s see what can be done with the basic set of flex
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll use a little HTML to create a container `div` with three child
    `div`s (boxes). The child boxes will be of class `box` with an ID to enable specific
    CSS to be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The initial CSS gives the container a red border, width, and height (600x400).
    The boxes are 100 pixels wide and high (80 pixels plus 10 pixels padding) and
    have a green border. A novel CSS property is the container’s `display: flex`,
    which establishes a flex display context. The result of this can be seen in [Figure 4-10](#flex-boxes)
    (`display: flex`), which shows the boxes presented in a row rather than the default
    column, where each box occupies its own row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![dpj2 0410](assets/dpj2_0410.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-10\. Positioning and sizing with flex-boxes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Flex displays respond to children with the `flex` property by expanding their
    size to fit the available space. If we make the boxes flexible, they respond by
    expanding to fill the container row. [Figure 4-10](#flex-boxes) (flex-direction:
    row) shows the result. Note that the `flex` property overrides the boxes’ width
    property, allowing them to expand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `flex-direction` property is `row` by default. By setting it to `column`,
    the boxes are placed in a column and the height property is overridden to allow
    them to expand to fit the container’s height. [Figure 4-10](#flex-boxes) (direction
    column) shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Removing or commenting out the width and height properties from the boxes makes
    them fully flexible, able to expand in the horizontal and vertical, producing
    [Figure 4-10](#flex-boxes) (full flex):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to reverse the order of the flex-boxes, there are a `row-reverse`
    and `column-reverse` `flex-direction`. [Figure 4-10](#flex-boxes) (column reverse)
    shows the result of reversing the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of the boxes’ `flex` property represents a sizing weight. Initially
    all the boxes have a weight of one, which makes them of equal size. If we give
    the first box a weight of two, it will occupy half (2 / (1 + 1 + 2)) the available
    space in the row or column direction specified. [Figure 4-10](#flex-boxes) (#box1
    flex 2) shows the result of increasing `box1`’s flex value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we return the 100-pixel height and width (including padding) constraints
    to the boxes and remove their `flex` property, we can demonstrate the power of
    flex display positioning. We’ll also need to remove the flex directive from `box1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With fixed-size content, flex displays have a number of properties that allow
    precise placement of the content. This sort of manipulation used to involve all
    manner of tricky CSS hacks. First, let’s distribute the boxes evenly in their
    container, using row-based spacing. The magic property is `justify-content` with
    the value `space-between`; [Figure 4-10](#flex-boxes) (space between) shows the
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a `space-around` complement to `space-between`, which spaces the content
    by adding equal padding to left and right. [Figure 4-10](#flex-boxes) (space around)
    shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'By combining the `justify-content` and `align-items` properties, we can achieve
    the holy grail of CSS positioning, centering the content in the vertical and the
    horizontal. We’ll add a gap of 20 pixels between the boxes using the flex display’s
    `gap` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 4-10](#flex-boxes) (centered with `gap`) shows our content sitting
    squarely in the middle of its container.'
  prefs: []
  type: TYPE_NORMAL
- en: Another great thing about the flex display is that it is fully recursive. `div`s
    can both *have* a display flex property and *be* flex content. This makes achieving
    complex content layouts a breeze. Let’s see a little demonstration of nested flex-boxes,
    to make the point clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll first use some HTML to build a nested tree of boxes (including the main
    container box). We’ll give each box and container an ID and class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The following CSS gives the main container a height of 800 pixels (it will fill
    the available width by default), a flex display, and a flex-direction of column,
    making it stack its flex content.
  prefs: []
  type: TYPE_NORMAL
- en: There are three containers to be stacked, which are both flexible and provide
    a flex display for their content. The boxes have a red border and are fully flexible
    (no width or height specified). By default all boxes have a flex weight of one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The middle container has a fixed width box (width 66%) and uses `justify-content:
    center` to center it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom container has a flex value of 2, making it twice the height of its
    siblings. It has two boxes of equal weight, one of which (box 5) contains two
    boxes that are stacked (`flex-direction: column`). The fairly complex layout (see
    [Figure 4-11](#flex-boxes-nested)) is achieved with impressively little CSS and
    is easily adapted by changing a few flex display properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![dpj2 0411](assets/dpj2_0411.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-11\. Nested flex-boxes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Flex-boxes provide a very powerful sizing and positioning context for your HTML
    content that responds to container size and can be easily adapted. If you want
    your content in a column rather than a row, then a single property change makes
    it so. For more precise positioning and sizing control there is the [CSS grid
    layout](https://oreil.ly/lVilF), but I would recommend focusing your initial energies
    on the flex display—it represents the best return on your learning investment
    in CSS right now. For further examples, see the [CSS-Tricks article](https://oreil.ly/JJgbG)
    on flex-boxes and [this handy cheat sheet](https://flexboxsheet.com).
  prefs: []
  type: TYPE_NORMAL
- en: Filling the Placeholders with Content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With our content blocks defined in HTML and positioned with CSS, a modern data
    visualization uses JavaScript to construct its interactive charts, menus, tables,
    and the like. There are many ways to create visual content (aside from image or
    multimedia tags) in your modern browser, the main ones being:'
  prefs: []
  type: TYPE_NORMAL
- en: Scalable Vector Graphics (SVG) using special HTML tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing to a 2D `canvas` context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing to a 3D `canvas` WebGL context, allowing a subset of OpenGL commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using modern CSS to create animations, graphic primitives, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because SVG is the language of choice for D3, in many ways the biggest JavaScript
    dataviz library, many of the cool web data visualizations you have seen, such
    as those by the *New York Times*, are built using it. Broadly speaking, unless
    you anticipate having lots (>1,000) of moving elements in your visualization or
    need to use a specific `canvas`-based library, SVG is probably the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: By using vectors instead of pixels to express its primitives, SVG will generally
    produce cleaner graphics that respond smoothly to scaling operations. It’s also
    much better at handling text, a crucial consideration for many visualizations.
    Another key advantage of SVG is that user interaction (e.g., mouse hovering or
    clicking) is native to the browser, being part of the standard DOM event handling.^([12](ch04.xhtml#idm45607791382032))
    A final point in its favor is that because the graphic components are built on
    the DOM, you can inspect and adapt them using your browser’s development tools
    (see [“Chrome DevTools”](#chrome_tab)). This can make debugging and refining your
    visualizations much easier than trying to find errors in the `canvas`’s relatively
    black box.
  prefs: []
  type: TYPE_NORMAL
- en: '`canvas` graphics contexts come into their own when you need to move beyond
    simple graphic primitives like circles and lines, such as when incorporating images
    like PNGs and JPGs. `canvas` is usually considerably more performant than SVG,
    so anything with lots of moving elements^([13](ch04.xhtml#idm45607791376208))
    is better off rendered to a canvas. If you want to be really ambitious or move
    beyond 2D graphics, you can even unleash the awesome power of modern graphics
    cards by using a special form of `canvas` context, the OpenGL-based WebGL context.
    Just bear in mind that what would be simple user interaction with SVG (e.g., clicking
    on a visual element) often has to be derived from mouse coordinates manually,
    which adds a tricky layer of complexity.'
  prefs: []
  type: TYPE_NORMAL
- en: The Nobel Prize data visualization realized at the end of this book’s toolchain
    is built primarily with D3, so SVG graphics are the focus of this book. Being
    comfortable with SVG is fundamental to modern web-based dataviz, so let’s explore
    a little primer.
  prefs: []
  type: TYPE_NORMAL
- en: Scalable Vector Graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All SVG creations start with an `<svg>` root tag. All graphical elements, such
    as circles and lines, and groups thereof, are defined on this branch of the DOM
    tree. [Example 4-3](#webdev_svg_tag) shows a little SVG context we’ll use in upcoming
    demonstrations, a light-gray rectangle with ID `chart`. We also include the D3
    library, loaded from [*d3js.org*](https://d3js.org) and a *script.js* JavaScript
    file in the project folder.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-3\. A basic SVG context
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve got our little SVG canvas in place, let’s start doing some drawing.
  prefs: []
  type: TYPE_NORMAL
- en: The <g> Element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can group shapes within our `<svg>` element by using the group `<g>` element.
    As we’ll see in [“Working with Groups”](#sect_groups), shapes contained in a group
    can be manipulated together, including changing their position, scale, or opacity.
  prefs: []
  type: TYPE_NORMAL
- en: Circles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating SVG visualizations, from the humblest little static bar chart to full-fledged
    interactive, geographic masterpieces, involves putting together elements from
    a fairly small set of graphical primitives such as lines, circles, and the very
    powerful paths. Each of these elements will have its own DOM tag, which will update
    as it changes.^([14](ch04.xhtml#idm45607791323968)) For example, its *x* and *y*
    attributes will change to reflect any translations within its `<svg>` or group
    (`<g>`) context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a circle to our `<svg>` context to demonstrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'With a little CSS to provide the circle’s fill color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This produces [Figure 4-12](#svg_circle). Note that the *y* coordinate is measured
    from the top of the `<svg>` `'#chart'` container, a common graphic convention.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 0412](assets/dpj2_0412.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-12\. An SVG circle
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now let’s see how we go about applying styles to SVG elements.
  prefs: []
  type: TYPE_NORMAL
- en: Applying CSS Styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The circle in [Figure 4-12](#svg_circle) is fill-colored light blue using CSS
    styling rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In modern browsers, you can set most visual SVG styles using CSS, including
    `fill`, `stroke`, `stroke-width`, and `opacity`. So if we wanted a thick, semitransparent
    green line (with ID `total`) we could use the following CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also set the styles as attributes of the tags, though CSS is generally
    preferable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Which SVG features can be set by CSS and which can’t is a source of some confusion
    and plenty of gotchas. The SVG spec distinguishes between element [properties](https://oreil.ly/K0enr)
    and attributes, the former being more likely to be found among the valid CSS styles.
    You can investigate the valid CSS properties using Chrome’s Elements tab and its
    autocomplete. Also, be prepared for some surprises. For example, SVG text is colored
    by the `fill`, not `color`, property.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `fill` and `stroke`, there are various color conventions you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: Named HTML colors, such as lightblue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using HTML hex codes (#RRGGBB); for example, white is #FFFFFF'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RGB values; for example, red = rgb(255, 0, 0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RGBA values, where A is an alpha channel (0–1); for example, half-transparent
    blue is rgba(0, 0, 255, 0.5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to adjusting the color’s alpha channel with RGBA, you can fade the
    SVG elements using their `opacity` property. Opacity is used a lot in D3 animations.
  prefs: []
  type: TYPE_NORMAL
- en: Stroke width is measured in pixels by default but can use points.
  prefs: []
  type: TYPE_NORMAL
- en: Lines, Rectangles, and Polygons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll add a few more elements to our chart to produce [Figure 4-13](#svg_axes).
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 0413](assets/dpj2_0413.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-13\. Adding a few elements to our dummy chart
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'First, we’ll add a couple of simple axis lines to our chart, using the `<line>`
    tag. Line positions are defined by a start coordinate (x1, y1) and an end one
    (x2, y2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also add a dummy legend box in the top-right corner using an SVG rectangle.
    Rectangles are defined by *x* and *y* coordinates relative to their parent container,
    and a width and height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create irregular polygons using the `<polygon>` tag, which takes a
    list of coordinate pairs. Let’s make a triangle marker in the bottom right of
    our chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll style the elements with a little CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve got a few graphical primitives in place, let’s see how we add
    some text to our dummy chart.
  prefs: []
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the key strengths of SVG over the rasterized `canvas` context is how
    it handles text. Vector-based text tends to look a lot clearer than its pixelated
    counterparts and benefits from smooth scaling too. You can also adjust stroke
    and fill properties, just like any SVG element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a bit of text to our dummy chart: a title and labeled y-axis (see
    [Figure 4-14](#svg_text)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 0414](assets/dpj2_0414.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-14\. Some SVG text
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We place text using *x* and *y* coordinates. One important property is the `text-anchor`,
    which stipulates where the text is placed relative to its x position. The options
    are `start`, `middle`, and `end`; `start` is the default.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `text-anchor` property to center our chart title. We set the
    *x* coordinates at half the chart width and then set the `text-anchor` to `middle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As with all SVG primitives, we can apply scaling and rotation transforms to
    our text. To label our y-axis, we’ll need to rotate the text to the vertical ([Example 4-4](#svg_text_rotate)).
    By convention, rotations are clockwise by degree, so we’ll want a counterclockwise,
    –90 degree rotation. By default rotations are around the (0,0) point of the element’s
    container (`<svg>` or group `<g>`). We want to rotate our text around its own
    position, so first translate the rotation point using the extra arguments to the
    `rotate` function. We also want to first set the `text-anchor` to the end of the
    `y axis label` string to rotate about its endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-4\. Rotating text
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In [Example 4-4](#svg_text_rotate), we make use of the text’s `dy` attribute,
    which, along with `dx`, can be used to make fine adjustments to the text’s position.
    In this case, we want to lower it so that when rotated counterclockwise it will
    be to the right of the y-axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'SVG text elements can also be styled with CSS. Here we set the `font-family`
    of the chart to `sans-serif` and the `font-size` to `16px`, using the `title`
    ID to make that a little bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `text` elements inherit `font-family` and `font-size` from the
    chart’s CSS; you don’t have to specify a `text` element.
  prefs: []
  type: TYPE_NORMAL
- en: Paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Paths are the most complicated and powerful SVG element, enabling the creation
    of multiline, multicurve component paths that can be closed and filled, creating
    pretty much any shape you want. A simple example is adding a little chart line
    to our dummy chart to produce [Figure 4-15](#svg_path).
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 0415](assets/dpj2_0415.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-15\. A red line path from the chart axis
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The red path in [Figure 4-15](#svg_path) is produced by the following SVG:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `path`’s `d` attribute specifies the series of operations needed to make
    the red line. Let’s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '“M20 130”: move to coordinate (20, 130)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“L60 70”: draw a line to (60, 70)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“L110 100”: draw a line to (110, 100)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“L160 45”: draw a line to (160, 45)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can imagine `d` as a set of instructions to a pen to move to a point, with
    `M` raising the pen from the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'A little CSS styling is needed. Note that the `fill` is set to `none`; otherwise,
    to create a fill area, the path would be closed, drawing a line from its end to
    beginning points, and any enclosed areas filled in with the default color black:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As well as the `moveto ''M''` and `lineto ''L''`, the path has a number of
    other commands to draw arcs, Bézier curves, and the like. SVG arcs and curves
    are commonly used in dataviz work, with many of D3’s libraries making use of them.^([15](ch04.xhtml#idm45607790535824))
    [Figure 4-16](#svg_arc) shows some SVG elliptical arcs created by the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdev_101_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Having moved to position (40, 40), draw an elliptical arc with x-radius 30,
    y-radius 40, and endpoint (80, 80).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_webdev_101_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The first flag (0) sets the x axis rotation, in this case the conventional zero.
    See [the Mozilla developer site](https://oreil.ly/KGCDZ) for a visual demonstration.
    The last two flags (0, 1) are `large-arc-flag`, specifying which arc of the ellipse
    to use, and `sweep-flag`, which specifies which of the two possible ellipses defined
    by start and endpoints to use.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 0416](assets/dpj2_0416.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-16\. Some SVG elliptical arcs
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The key flags used in the elliptical arc (`large-arc-flag` and `sweep-flag`)
    are, like most things geometric, better demonstrated than described. [Figure 4-17](#svg_arc_flags)
    shows the effect of changing the flags for the same relative beginning and endpoints,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '![dpj2 0417](assets/dpj2_0417.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-17\. Changing the elliptic-arc flags
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As well as lines and arcs, the `path` element offers a number of Bézier curves,
    including quadratic, cubic, and compounds of the two. With a little work, these
    can create any line path you want. There’s a nice run-through [on SitePoint](https://oreil.ly/PRdVF)
    with good illustrations.
  prefs: []
  type: TYPE_NORMAL
- en: For the definitive list of `path` elements and their arguments, go [to the World
    Wide Web Consortium (W3C) source](https://oreil.ly/s7YSY). And for a nice round-up,
    see [Jakob Jenkov’s introduction](https://oreil.ly/fdERF).
  prefs: []
  type: TYPE_NORMAL
- en: Scaling and Rotating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As befits their vector nature, all SVG elements can be transformed by geometric
    operations. The most commonly used are `rotate`, `translate`, and `scale`, but
    you can also apply skewing using `skewX` and `skewY` or use the powerful, multipurpose
    *matrix* transform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s demonstrate the most popular transforms, using a set of identical rectangles.
    The transformed rectangles in [Figure 4-18](#svg_transform) are achieved like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '![dpj2 0418](assets/dpj2_0418.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-18\. Some SVG transforms: rotate(45), scale(0.5), scale(0.5), then
    rotate(45)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The order in which transforms are applied is important. A rotation of 45 degrees
    clockwise followed by a translation along the x-axis will see the element moved
    southeasterly, whereas the reverse operation moves it to the left and then rotates
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often when you are constructing a visualization, it’s helpful to group the
    visual elements. A couple of particular uses are:'
  prefs: []
  type: TYPE_NORMAL
- en: When you require local coordinate schemes (e.g., if you have a text label for
    an icon and you want to specify its position relative to the icon, not the whole
    `<svg>` canvas).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to apply a scaling and/or rotation transformation to a subset of
    the visual elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SVG has a group `<g>` tag for this, which you can think of as a mini canvas
    within the `<svg>` canvas. Groups can contain groups, allowing for very flexible
    geometric mappings.^([16](ch04.xhtml#idm45607790321024))
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 4-5](#svg_group_code) groups shapes in the center of the canvas, producing
    [Figure 4-19](#svg_group). Note that the position of `circle`, `rect`, and `path`
    elements is relative to the translated group.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-5\. Grouping SVG shapes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '![dpj2 0419](assets/dpj2_0419.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-19\. Grouping shapes with SVG `` <g>` `` tag
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If we now apply a transform to the group, all shapes within it will be affected.
    [Figure 4-20](#svg_group_transform) shows the result of scaling [Figure 4-19](#svg_group)
    by a factor of 0.75 and then rotating it 90 degrees, which we achieve by adapting
    the transform attribute, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '![dpj2 0420](assets/dpj2_0420.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-20\. Transforming an SVG group
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Layering and Transparency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The order in which the SVG elements are added to the DOM tree is important,
    with later elements taking precedence, layering over others. In [Figure 4-19](#svg_group),
    for example, the triangle path obscures the red circle and blue rectangle and
    is in turn obscured by the yellow circle.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating the DOM ordering is an important part of JavaScripted dataviz (e.g.,
    D3’s `insert` method allows you to place an SVG element before an existing one).
  prefs: []
  type: TYPE_NORMAL
- en: 'Element transparency can be manipulated using the alpha channel of `rgba(R,G,B,A)`
    colors or the more convenient `opacity` property. Both can be set using CSS. For
    overlaid elements, opacity is cumulative, as demonstrated by the color triangle
    in [Figure 4-21](#svg_transparency), produced by the following SVG:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The SVG elements demonstrated here were handcoded in HTML, but in data visualization
    work they are almost always added programmatically. Thus the basic D3 workflow
    is to add SVG elements to a visualization, using data files to specify their attributes
    and properties.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 0421](assets/dpj2_0421.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-21\. Manipulating opacity with SVG
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: JavaScripted SVG
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fact that SVG graphics are described by DOM tags has a number of advantages
    over a black box such as the `<canvas>` context. For example, it allows nonprogrammers
    to create or adapt graphics and is a boon for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: In web dataviz, pretty much all your SVG elements will be created with JavaScript,
    through a library such as D3\. You can inspect the results of this scripting using
    the browser’s Elements tab (see [“Chrome DevTools”](#chrome_tab)), which is a
    great way to refine and debug your work (e.g., nailing an annoying visual glitch).
  prefs: []
  type: TYPE_NORMAL
- en: As a little taster for things to come, let’s use D3 to scatter a few red circles
    on an SVG canvas. The dimensions of the canvas and circles are contained in a
    `data` object sent to a `chartCircles` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use a little HTML placeholder for the `<svg>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'With our placeholder SVG `chart` element in place, a little D3 in the *script.js*
    file is used to turn some data into the scattered circles (see [Figure 4-22](#webdev101_d3_circles)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_webdev_101_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the modern shorthand arrow-based anonymous function, equivalent to the
    long form on the previous line. D3 makes use of a lot of these for accessing the
    properties of bound data objects, so this new syntax is a big win.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 0422](assets/dpj2_0422.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-22\. D3-generated circles
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We’ll see exactly how D3 works its magic in [Chapter 17](ch17.xhtml#chapter_d3_intro).
    For now, let’s summarize what we’ve learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided a basic set of modern web-development skills for the budding
    data visualizer. It showed how the various elements of a web page (HTML, CSS stylesheets,
    JavaScript, and media files) are delivered by HTTP and, on being received by the
    browser, combined to become the web page the user sees. We saw how content blocks
    are described, using HTML tags such as `div` and `p`, and then styled and positioned
    using CSS. We also covered Chrome’s Elements and Sources tabs, which are the key
    browser development tools. Finally we had a little primer in SVG, the language
    in which most modern web data visualizations are expressed. These skills will
    be extended when our toolchain reaches its D3 visualization and new ones will
    be introduced in context.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch04.xhtml#idm45607793744992-marker)) There are some interesting alternatives
    to full-blown frameworks currently generating a buzz, such as [Alpine.js and htmx](https://oreil.ly/daXEB),
    which play well with Python web servers like Django and [Flask](https://oreil.ly/3zlEU).
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch04.xhtml#idm45607793740624-marker)) I bear the scars so you don’t have
    to.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch04.xhtml#idm45607793670928-marker)) You can code style in HTML tags
    using the `style` attribute, but it’s generally bad practice. It’s better to use
    classes and ids defined in CSS.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch04.xhtml#idm45607793668384-marker)) As demonstrated [by Mike Bostock](https://oreil.ly/MgWtS),
    with a hat-tip to Paul Irish.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch04.xhtml#idm45607792973152-marker)) OpenGL (Open Graphics Language)
    and its web counterpart WebGL are cross-platform APIs for rendering 2D and 3D
    vector graphics (see the [Wikipedia page](https://oreil.ly/eytfV) for details).
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch04.xhtml#idm45607792962112-marker)) This is not the same as programmatically
    setting styles, which is a hugely powerful technique that allows styles to adapt
    to user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch04.xhtml#idm45607792857568-marker)) This is generally considered bad
    practice and is usually an indication of poorly structured CSS. Use with extreme
    caution, as it can make life very difficult for code developers.
  prefs: []
  type: TYPE_NORMAL
- en: '^([8](ch04.xhtml#idm45607792772048-marker)) These are succinctly discussed
    in Douglas Crockford’s famously short *JavaScript: The Good Parts* (O’Reilly).'
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch04.xhtml#idm45607792668960-marker)) Being able to play with attributes
    is particularly useful when trying to get Scalable Vector Graphics (SVG) to work.
  prefs: []
  type: TYPE_NORMAL
- en: ^([10](ch04.xhtml#idm45607792628480-marker)) Logging is a great way of tracking
    data flow through your app. I recommend you adopt a consistent approach here.
  prefs: []
  type: TYPE_NORMAL
- en: ^([11](ch04.xhtml#idm45607792243232-marker)) Here’s [a thread showing the many
    and varied solutions to the problem](https://oreil.ly/casbD), none of which could
    be called elegant.
  prefs: []
  type: TYPE_NORMAL
- en: ^([12](ch04.xhtml#idm45607791382032-marker)) With a `canvas` graphic context,
    you generally have to contrive your own event handling.
  prefs: []
  type: TYPE_NORMAL
- en: ^([13](ch04.xhtml#idm45607791376208-marker)) This number changes with time and
    the browser in question, but as a rough rule of thumb, SVG often starts to strain
    in the low thousands.
  prefs: []
  type: TYPE_NORMAL
- en: ^([14](ch04.xhtml#idm45607791323968-marker)) You should be able to use your
    browser’s development tools to see the tag attributes updating in real time.
  prefs: []
  type: TYPE_NORMAL
- en: ^([15](ch04.xhtml#idm45607790535824-marker)) [Mike Bostock’s chord diagram](https://oreil.ly/ujCxf)
    is a nice example, and uses D3’s `chord` function.
  prefs: []
  type: TYPE_NORMAL
- en: ^([16](ch04.xhtml#idm45607790321024-marker)) For example, a body group can contain
    an arm group, which can contain a hand group, which can contain finger elements.
  prefs: []
  type: TYPE_NORMAL
