- en: Chapter 7\. Introduction to NumPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter aims to introduce the Numeric Python library (NumPy) to those unacquainted.
    NumPy is the key building block of pandas, the powerhouse data analysis library
    that we will be using in the upcoming chapters to clean and explore our recently
    scraped Nobel Prize dataset (see [Chapter 6](ch06.xhtml#chapter_heavy_scraping)).
    A basic understanding of NumPy’s core elements and principles is important if
    you are to get the most out of pandas. Therefore, the emphasis of the chapter
    is to provide a foundation for the upcoming introduction to pandas.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy is a Python module that allows access to very fast, multidimensional array
    manipulation, implemented by low-level libraries written in C and Fortran.^([1](ch07.xhtml#idm45607782330608))
    Python’s native performance with large quantities of data is relatively slow,
    but NumPy allows you to perform parallel operations on large arrays all at once,
    making it very fast. Given that NumPy is the chief building block of most of the
    heavyweight Python data-processing libraries, pandas included, it’s hard to argue
    with its status as linchpin of the Python data-processing world.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to pandas, NumPy’s huge ecosystem includes Science Python (SciPy),
    which supplements NumPy with hardcore science and engineering modules; scikit-learn,
    which adds a host of modern machine-learning algorithms in such domains as classification
    and feature extraction; and many other specialized libraries that use NumPy’s
    multidimensional arrays as their primary data objects. In this sense, basic NumPy
    mastery can massively extend your Python range in the data-processing realm.
  prefs: []
  type: TYPE_NORMAL
- en: The key to understanding NumPy is its arrays. If you understand how these work
    and how to manipulate them, then a lot of other stuff should follow painlessly.^([2](ch07.xhtml#idm45607782324304))
    The next few sections will cover basic array manipulation with a few examples
    of NumPy in action, setting the scene for the introduction of pandas’s datasets
    in [Chapter 8](ch08.xhtml#chapter_intro_to_pandas).
  prefs: []
  type: TYPE_NORMAL
- en: The NumPy Array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Everything in NumPy is built around its homogeneous^([3](ch07.xhtml#idm45607782320288)),
    multidimensional `ndarray` object. Operations on these arrays are performed using
    very fast, compiled libraries, allowing NumPy to massively outperform native Python.
    Among other things you can perform standard arithmetic on these arrays, much as
    you would a Python `int` or `float`.^([4](ch07.xhtml#idm45607782315648)) In the
    following code, a whole array is added to itself as easily and as quickly as adding
    two integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introduction_to_numpy_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The standard way to use the NumPy library and much preferred to `"from numpy
    import *"`.^([5](ch07.xhtml#idm45607782280784))
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introduction_to_numpy_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Automatically converts a Python list of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, NumPy can leverage the massively parallel computation available
    to modern CPUs allowing, for example, large matrices (2D arrays) to be crunched
    in acceptable times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key properties of the NumPy `ndarray` are its number of dimensions (`ndim`),
    shape (`shape`), and numeric type (`dtype`). The same array of numbers can be
    reshaped in place, which will sometimes involve changing the array’s number of
    dimensions. Let’s demonstrate some reshaping with a little eight-member array.
    We’ll use a `print_array_details` method to output the key array properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we’ll create our one-dimensional array. As the printed details show,
    by default this has a 64-bit integer numeric type (`int64`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `reshape` method, we can change the shape and number of dimensions
    of `a`. Let’s reshape `a` into a two-dimensional array composed of two four-member
    arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'An eight-member array can also be reshaped into a three-dimensional array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The shape and numeric type can be specified on creation of the array or later.
    The easiest way to change an array’s numeric type is by using the `astype` method
    to make a resized copy of the original with the new type:^([6](ch07.xhtml#idm45607781871408))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introduction_to_numpy_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The array will convert a nested list of numbers into a suitably shaped multidimensional
    form.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As well as creating arrays with lists of numbers, NumPy provides some utility
    functions to create arrays with a specific shape. `zeros` and `ones` are the most
    common functions used, creating prefilled arrays. Here’s a couple of examples.
    Note that the default `dtype` of these methods is a 64-bit float (`float64`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The faster `empty` method just takes a memory block without the fill overhead,
    leaving the initialization up to you. This means you don’t know and can’t guarantee
    what values the array has, unlike `np.zeros`, so use with caution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful utility function is `random`, found along with some useful siblings
    in NumPy’s `random` module. This creates a shaped random array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introduction_to_numpy_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: A 2×3 array of random numbers within the range 0 `<=` x < 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The handy `linspace` creates a specified number of evenly spaced samples over
    a set interval. `arange` is similar but uses a step-size argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that unlike `arange`, `linspace` is inclusive of the upper value and that
    the array’s datatype is the default `float64`.
  prefs: []
  type: TYPE_NORMAL
- en: Array Indexing and Slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One-dimensional arrays are indexed and sliced much as Python lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Indexing multidimensional arrays is similar to the *1-D* form. Each dimension
    has its own indexing/slicing operation and these are specified in a comma-separated
    tuple.^([7](ch07.xhtml#idm45607781252528)) [Figure 7-1](#numpy_indexing) shows
    how this works.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 0701](assets/dpj2_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. Multidimensional indexing with NumPy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Note that if the number of objects in the selection tuple is less than the
    number of dimensions, the remaining dimensions are assumed to be fully selected
    (:). Ellipsis can also be used as a shorthand for full selection of all indices,
    expanding to the required number of : objects. We will use a three-dimensional
    array to demonstrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'NumPy has a handy `array_equal` method, which compares arrays by shape and
    elements. We can use it to show the equivalence of the following array selections,
    taking the second subarray of axis 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing for equivalence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A Few Basic Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the really cool things about NumPy arrays is that you can perform basic
    (and not so basic) math operations in much the same way that you would with normal
    numeric variables. [Figure 7-2](#numpy_maths) shows the use of some overloaded
    arithmetic operators on a two-dimensional array. The simple mathematical operations
    are applied to all members of the array. Note that where the array is divided
    by a floating-point value (2.0), the result is automatically converted to a float
    type (`float64`). Being able to manipulate arrays as easily as single numbers
    is a huge strength of NumPy and a large part of its expressive power.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 0702](assets/dpj2_0702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. A few basic math operations on a two-dimensional NumPy array
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Boolean operators work in a similar way to the arithmetic ones. As we’ll see
    in the next chapter, this is a very useful way to create the Boolean masks often
    used in pandas. Here’s a little example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Arrays also have a number of useful methods, a selection of which is demonstrated
    in [Example 7-1](#numpy_array_methods). You can get a comprehensive rundown in
    [the official NumPy docs](https://oreil.ly/qmnDX).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-1\. Some array methods
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introduction_to_numpy_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Average along second axis.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introduction_to_numpy_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The standard deviation of [0, 1, 2, 3],…​
  prefs: []
  type: TYPE_NORMAL
- en: There are also a large number of built-in array functions. [Example 7-2](#numpy_maths2)
    demonstrates a selection of these, and you will find a comprehensive list of NumPy’s
    built-in mathematical routines [at the official NumPy site](https://oreil.ly/vvfzm).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-2\. Some NumPy array math functions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introduction_to_numpy_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Note the floating-point rounding error for sin(pi).
  prefs: []
  type: TYPE_NORMAL
- en: Creating Array Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether you’re using pandas or one of the many Python data-processing libraries,
    such as SciPy, scikit-learn, or PyTorch, chances are the core data structure being
    used is the NumPy array. The ability to craft little array processing functions
    is therefore a great addition to your data-processing toolkit and the data visualization
    toolchain. Often a short internet search will turn up a community solution, but
    there’s a lot of satisfaction to be gained from crafting your own, besides being
    a great way to learn. Let’s see how we can harness the NumPy array to calculate
    a [moving average](https://oreil.ly/ajLZJ). A moving average is a series of averages
    based on a moving window of the last *n* values, where *n* is variable, also known
    as a *moving mean* or *rolling mean*.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating a Moving Average
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Example 7-3](#numpy_moving_average) shows the few lines needed to calculate
    a moving average on a one-dimensional NumPy array.^([8](ch07.xhtml#idm45607780652944))
    As you can see, it’s nice and concise, but there’s a fair amount going on in those
    few lines. Let’s break it down a bit.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-3\. A moving average with NumPy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The function receives an array *a* and number *n* specifying the size of the
    moving window.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first calculate the cumulative sum of the array using NumPy’s built-in method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting at the *n*th index of the cumulative sum array, we subtract the *i*–*n*th
    value for all *i*, which means *i* now has the sum of the last *n* values of *a*,
    inclusive. Here’s an example with a window of size three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Comparing the array `a` with the final array `csum`, index 5 is now the sum
    of the window [3, 4, 5].
  prefs: []
  type: TYPE_NORMAL
- en: Because a moving average only makes sense for index (*n*–1) onward, it only
    remains to return these values, divided by the window size *n* to give the average.
  prefs: []
  type: TYPE_NORMAL
- en: The `moving_average` function takes a bit of time to get but is a good example
    of the concision and expressiveness that can be achieved with NumPy arrays and
    array slicing. You could easily write the function in vanilla Python, but it would
    likely be a fair bit more involved and, crucially, be much slower for arrays of
    significant size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting the function to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter laid the foundations of NumPy, focusing on its building block,
    the NumPy array or `ndarray`. Being proficient with NumPy is a core skill for
    any Pythonista working with data. It underpins most of Python’s hardcore data-processing
    stack, so for this reason alone, you should be comfortable with its array manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: Being comfortable with NumPy will make pandas work that much easier and open
    up the rich NumPy ecosystem of scientific, engineering, machine learning, and
    statistical algorithmics to your pandas workflow. Although pandas hides its NumPy
    arrays behind data containers such as its DataFrame and Series, which are adapted
    to deal with heterogeneous data, these containers behave for the most part like
    NumPy arrays and will generally do the right thing when asked. Knowing that `ndarray`s
    are at its core also helps when you are trying to frame problems for pandas—​ultimately
    the requested data manipulation has to play nicely with NumPy. Now that we’ve
    got its building blocks in place, let’s see how pandas extends the homogeneous
    NumPy array into the realm of heterogeneous data, where much of data visualization
    work takes place.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch07.xhtml#idm45607782330608-marker)) Python’s scripted ease of use comes
    at the cost of raw speed. By wrapping fast, low-level libraries, initiatives like
    NumPy aim for simple, cruft-free programming and blinding performance.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch07.xhtml#idm45607782324304-marker)) NumPy is used to implement some
    very advanced math, so don’t expect to understand everything you see online—​just
    the building blocks.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch07.xhtml#idm45607782320288-marker)) This means NumPy deals with arrays
    of the same datatype (dtype) rather than Python lists, for example, which can
    have strings, numbers, dates, etc.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch07.xhtml#idm45607782315648-marker)) This assumes the arrays meet shape
    and type constraints.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch07.xhtml#idm45607782280784-marker)) Importing all module variables into
    your namespace using `*` is almost always a bad idea.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch07.xhtml#idm45607781871408-marker)) A more memory-efficient and performant
    way involves manipulating the array’s view, but it does involve some extra steps.
    See [this Stack Overflow article](https://oreil.ly/FOQWt) for some examples and
    a discussion of the pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch07.xhtml#idm45607781252528-marker)) There is a shorthand dot notation
    (e.g., `[..1:3]`) to select all indices.
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch07.xhtml#idm45607780652944-marker)) NumPy has a `convolve` method, which
    is the easiest way to calculate a simple moving average but less instructive.
    Also, pandas has a number of specialized methods for this.
  prefs: []
  type: TYPE_NORMAL
