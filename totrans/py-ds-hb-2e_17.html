<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 14. Data Indexing and Selection" data-type="chapter" epub:type="chapter"><div class="chapter" id="section-0302-data-indexing-and-selection">
<h1><span class="label">Chapter 14. </span>Data Indexing and Selection</h1>
<p><a data-primary="indexing" data-secondary="Pandas" data-type="indexterm" id="ix_ch14-asciidoc0"/><a data-primary="Pandas" data-secondary="data indexing and selection" data-type="indexterm" id="ix_ch14-asciidoc1"/>In <a data-type="xref" href="part02.xhtml#section-0200-introduction-to-numpy">Part II</a>, we looked in detail
at methods and tools to access, set, and modify values in NumPy arrays.
These included indexing (e.g., <code>arr[2, 1]</code>), slicing (e.g.,
<code>arr[:, 1:5]</code>), masking (e.g., <code>arr[arr &gt; 0]</code>), fancy indexing (e.g.,
<code>arr[0, [1, 5]]</code>), and combinations thereof (e.g., <code>arr[:, [1, 5]]</code>).
Here we’ll look at similar means of accessing and modifying
values in Pandas <code>Series</code> and <code>DataFrame</code> objects. If you have used the
NumPy patterns, the corresponding patterns in Pandas will feel very
familiar, though there are a few quirks to be aware of.</p>
<p>We’ll start with the simple case of the one-dimensional
<code>Series</code> object, and then move on to the more complicated
two-dimensional <code>DataFrame</code> object.</p>
<section data-pdf-bookmark="Data Selection in Series" data-type="sect1"><div class="sect1" id="ch_0302-data-indexing-and-selection_data-selection-in-series">
<h1>Data Selection in Series</h1>
<p><a data-primary="Pandas" data-secondary="data selection in Series" data-type="indexterm" id="ix_ch14-asciidoc2"/><a data-primary="Series object (Pandas)" data-secondary="data indexing/selection in" data-type="indexterm" id="ix_ch14-asciidoc3"/>As you saw in the previous chapter, a <code>Series</code> object acts in many ways
like a one-dimensional NumPy array, and in many ways like a standard
Python dictionary. If you keep these two overlapping analogies in mind,
it will help you understand the patterns of data indexing and selection
in these arrays.</p>
<section data-pdf-bookmark="Series as Dictionary" data-type="sect2"><div class="sect2" id="ch_0302-data-indexing-and-selection_series-as-dictionary">
<h2>Series as Dictionary</h2>
<p><a data-primary="Series object (Pandas)" data-secondary="as dictionary" data-secondary-sortas="dictionary" data-type="indexterm" id="idm45858789978544"/>Like a dictionary, the <code>Series</code> object provides a mapping from a
collection of keys to a collection of values:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>
        <code class="n">data</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">([</code><code class="mf">0.25</code><code class="p">,</code> <code class="mf">0.5</code><code class="p">,</code> <code class="mf">0.75</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">],</code>
                         <code class="n">index</code><code class="o">=</code><code class="p">[</code><code class="s1">'a'</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">,</code> <code class="s1">'c'</code><code class="p">,</code> <code class="s1">'d'</code><code class="p">])</code>
        <code class="n">data</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="n">a</code>    <code class="mf">0.25</code>
        <code class="n">b</code>    <code class="mf">0.50</code>
        <code class="n">c</code>    <code class="mf">0.75</code>
        <code class="n">d</code>    <code class="mf">1.00</code>
        <code class="n">dtype</code><code class="p">:</code> <code class="n">float64</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="n">data</code><code class="p">[</code><code class="s1">'b'</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="mf">0.5</code></pre>
<p>We can also use dictionary-like Python expressions and methods to
examine the keys/indices and values:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="s1">'a'</code> <code class="ow">in</code> <code class="n">data</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="kc">True</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="n">data</code><code class="o">.</code><code class="n">keys</code><code class="p">()</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="n">Index</code><code class="p">([</code><code class="s1">'a'</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">,</code> <code class="s1">'c'</code><code class="p">,</code> <code class="s1">'d'</code><code class="p">],</code> <code class="n">dtype</code><code class="o">=</code><code class="s1">'object'</code><code class="p">)</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="nb">list</code><code class="p">(</code><code class="n">data</code><code class="o">.</code><code class="n">items</code><code class="p">())</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="p">[(</code><code class="s1">'a'</code><code class="p">,</code> <code class="mf">0.25</code><code class="p">),</code> <code class="p">(</code><code class="s1">'b'</code><code class="p">,</code> <code class="mf">0.5</code><code class="p">),</code> <code class="p">(</code><code class="s1">'c'</code><code class="p">,</code> <code class="mf">0.75</code><code class="p">),</code> <code class="p">(</code><code class="s1">'d'</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">)]</code></pre>
<p><code>Series</code> objects can also be modified with a dictionary-like syntax.
Just as you can extend a dictionary by assigning to a new key, you can
extend a <code>Series</code> by assigning to a new index value:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">data</code><code class="p">[</code><code class="s1">'e'</code><code class="p">]</code> <code class="o">=</code> <code class="mf">1.25</code>
        <code class="n">data</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">a</code>    <code class="mf">0.25</code>
        <code class="n">b</code>    <code class="mf">0.50</code>
        <code class="n">c</code>    <code class="mf">0.75</code>
        <code class="n">d</code>    <code class="mf">1.00</code>
        <code class="n">e</code>    <code class="mf">1.25</code>
        <code class="n">dtype</code><code class="p">:</code> <code class="n">float64</code></pre>
<p>This easy mutability of the objects is a convenient feature: under the
hood, Pandas is making decisions about memory layout and data copying
that might need to take place, and the user generally does not need to
worry about these issues.</p>
</div></section>
<section data-pdf-bookmark="Series as One-Dimensional Array" data-type="sect2"><div class="sect2" id="ch_0302-data-indexing-and-selection_series-as-one-dimensional-array">
<h2>Series as One-Dimensional Array</h2>
<p><a data-primary="Series object (Pandas)" data-secondary="one-dimensional array" data-type="indexterm" id="idm45858789629712"/>A <code>Series</code> builds on this dictionary-like interface and provides
array-style item selection via the same basic mechanisms as NumPy
arrays—that is, slices, masking, and fancy indexing. Examples of these
are as follows:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="c1"># slicing by explicit index</code>
        <code class="n">data</code><code class="p">[</code><code class="s1">'a'</code><code class="p">:</code><code class="s1">'c'</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">a</code>    <code class="mf">0.25</code>
        <code class="n">b</code>    <code class="mf">0.50</code>
        <code class="n">c</code>    <code class="mf">0.75</code>
        <code class="n">dtype</code><code class="p">:</code> <code class="n">float64</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="c1"># slicing by implicit integer index</code>
        <code class="n">data</code><code class="p">[</code><code class="mi">0</code><code class="p">:</code><code class="mi">2</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">a</code>    <code class="mf">0.25</code>
        <code class="n">b</code>    <code class="mf">0.50</code>
        <code class="n">dtype</code><code class="p">:</code> <code class="n">float64</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="c1"># masking</code>
        <code class="n">data</code><code class="p">[(</code><code class="n">data</code> <code class="o">&gt;</code> <code class="mf">0.3</code><code class="p">)</code> <code class="o">&amp;</code> <code class="p">(</code><code class="n">data</code> <code class="o">&lt;</code> <code class="mf">0.8</code><code class="p">)]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">b</code>    <code class="mf">0.50</code>
        <code class="n">c</code>    <code class="mf">0.75</code>
        <code class="n">dtype</code><code class="p">:</code> <code class="n">float64</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="c1"># fancy indexing</code>
         <code class="n">data</code><code class="p">[[</code><code class="s1">'a'</code><code class="p">,</code> <code class="s1">'e'</code><code class="p">]]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">a</code>    <code class="mf">0.25</code>
         <code class="n">e</code>    <code class="mf">1.25</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">float64</code></pre>
<p>Of these, slicing may be the source of the most confusion. Notice that
when slicing with an explicit index (e.g.,
<code>data['a':'c']</code>), the
final index is <em>included</em> in the slice, while when slicing with an
implicit index (e.g., <code>data[0:2]</code>), the final index is <em>excluded</em> from
the slice.</p>
</div></section>
<section data-pdf-bookmark="Indexers: loc and iloc" data-type="sect2"><div class="sect2" id="ch_0302-data-indexing-and-selection_indexers-loc-and-iloc">
<h2>Indexers: loc and iloc</h2>
<p><a data-primary="iloc attribute (Pandas)" data-type="indexterm" id="idm45858789431936"/><a data-primary="loc attribute (Pandas)" data-type="indexterm" id="idm45858789431232"/>If your <code>Series</code> has an explicit integer index, an indexing operation
such as <code>data[1]</code> will use the explicit indices, while a slicing
operation like <code>data[1:3]</code> will use the implicit Python-style indices:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">data</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">([</code><code class="s1">'a'</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">,</code> <code class="s1">'c'</code><code class="p">],</code> <code class="n">index</code><code class="o">=</code><code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code>
         <code class="n">data</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="mi">1</code>    <code class="n">a</code>
         <code class="mi">3</code>    <code class="n">b</code>
         <code class="mi">5</code>    <code class="n">c</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="nb">object</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="c1"># explicit index when indexing</code>
         <code class="n">data</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="s1">'a'</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="c1"># implicit index when slicing</code>
         <code class="n">data</code><code class="p">[</code><code class="mi">1</code><code class="p">:</code><code class="mi">3</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="mi">3</code>    <code class="n">b</code>
         <code class="mi">5</code>    <code class="n">c</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="nb">object</code></pre>
<p><a data-primary="Series object (Pandas)" data-secondary="indexer attributes" data-type="indexterm" id="idm45858789298624"/>Because of this potential confusion in the case of integer indexes,
Pandas provides some special <em>indexer</em> attributes that explicitly expose
certain indexing schemes. These are not functional methods, but
attributes that expose a particular slicing interface to the data in the
<code>Series</code>.</p>
<p>First, the <code>loc</code> attribute allows indexing and slicing that always
references the explicit index:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="n">data</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="s1">'a'</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="n">data</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="mi">1</code><code class="p">:</code><code class="mi">3</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="mi">1</code>    <code class="n">a</code>
         <code class="mi">3</code>    <code class="n">b</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="nb">object</code></pre>
<p>The <code>iloc</code> attribute allows indexing and slicing that always references
the implicit Python-style index:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="n">data</code><code class="o">.</code><code class="n">iloc</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="s1">'b'</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="n">data</code><code class="o">.</code><code class="n">iloc</code><code class="p">[</code><code class="mi">1</code><code class="p">:</code><code class="mi">3</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="mi">3</code>    <code class="n">b</code>
         <code class="mi">5</code>    <code class="n">c</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="nb">object</code></pre>
<p>One guiding principle of Python code is that “explicit is better than
implicit.” The explicit nature of <code>loc</code> and <code>iloc</code> makes them helpful
in maintaining clean and readable code; especially in the case of
integer indexes, using them consistently can prevent subtle bugs due to
the mixed indexing/slicing convention.<a data-startref="ix_ch14-asciidoc3" data-type="indexterm" id="idm45858789110896"/><a data-startref="ix_ch14-asciidoc2" data-type="indexterm" id="idm45858789110256"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Data Selection in DataFrames" data-type="sect1"><div class="sect1" id="ch_0302-data-indexing-and-selection_data-selection-in-dataframes">
<h1>Data Selection in DataFrames</h1>
<p><a data-primary="DataFrame object (Pandas)" data-secondary="data selection in" data-type="indexterm" id="idm45858789107968"/>Recall <a data-primary="Pandas" data-secondary="data selection in DataFrame" data-type="indexterm" id="ix_ch14-asciidoc4"/>that a <code>DataFrame</code> acts in many ways like a two-dimensional or
structured array, and in other ways like a dictionary of <code>Series</code>
structures sharing the same index. These analogies can be helpful to
keep in mind as we explore data selection within this structure.</p>
<section data-pdf-bookmark="DataFrame as Dictionary" data-type="sect2"><div class="sect2" id="ch_0302-data-indexing-and-selection_dataframe-as-dictionary">
<h2>DataFrame as Dictionary</h2>
<p><a data-primary="DataFrame object (Pandas)" data-secondary="as dictionary" data-secondary-sortas="dictionary" data-type="indexterm" id="idm45858789102640"/><a data-primary="Series object (Pandas)" data-secondary="DataFrame as dictionary of" data-type="indexterm" id="idm45858789101424"/>The first analogy we will consider is the <code>DataFrame</code> as a dictionary of
related <code>Series</code> objects. Let’s return to our example of
areas and populations of states:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">18</code><code class="p">]:</code> <code class="n">area</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">({</code><code class="s1">'California'</code><code class="p">:</code> <code class="mi">423967</code><code class="p">,</code> <code class="s1">'Texas'</code><code class="p">:</code> <code class="mi">695662</code><code class="p">,</code>
                           <code class="s1">'Florida'</code><code class="p">:</code> <code class="mi">170312</code><code class="p">,</code> <code class="s1">'New York'</code><code class="p">:</code> <code class="mi">141297</code><code class="p">,</code>
                           <code class="s1">'Pennsylvania'</code><code class="p">:</code> <code class="mi">119280</code><code class="p">})</code>
         <code class="n">pop</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">({</code><code class="s1">'California'</code><code class="p">:</code> <code class="mi">39538223</code><code class="p">,</code> <code class="s1">'Texas'</code><code class="p">:</code> <code class="mi">29145505</code><code class="p">,</code>
                          <code class="s1">'Florida'</code><code class="p">:</code> <code class="mi">21538187</code><code class="p">,</code> <code class="s1">'New York'</code><code class="p">:</code> <code class="mi">20201249</code><code class="p">,</code>
                          <code class="s1">'Pennsylvania'</code><code class="p">:</code> <code class="mi">13002700</code><code class="p">})</code>
         <code class="n">data</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">({</code><code class="s1">'area'</code><code class="p">:</code><code class="n">area</code><code class="p">,</code> <code class="s1">'pop'</code><code class="p">:</code><code class="n">pop</code><code class="p">})</code>
         <code class="n">data</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">18</code><code class="p">]:</code>                 <code class="n">area</code>       <code class="n">pop</code>
         <code class="n">California</code>    <code class="mi">423967</code>  <code class="mi">39538223</code>
         <code class="n">Texas</code>         <code class="mi">695662</code>  <code class="mi">29145505</code>
         <code class="n">Florida</code>       <code class="mi">170312</code>  <code class="mi">21538187</code>
         <code class="n">New</code> <code class="n">York</code>      <code class="mi">141297</code>  <code class="mi">20201249</code>
         <code class="n">Pennsylvania</code>  <code class="mi">119280</code>  <code class="mi">13002700</code></pre>
<p class="pagebreak-before less_space">The individual <code>Series</code> that make up the columns of the <code>DataFrame</code> can
be accessed via dictionary-style indexing of the column name:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">19</code><code class="p">]:</code> <code class="n">data</code><code class="p">[</code><code class="s1">'area'</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">19</code><code class="p">]:</code> <code class="n">California</code>      <code class="mi">423967</code>
         <code class="n">Texas</code>           <code class="mi">695662</code>
         <code class="n">Florida</code>         <code class="mi">170312</code>
         <code class="n">New</code> <code class="n">York</code>        <code class="mi">141297</code>
         <code class="n">Pennsylvania</code>    <code class="mi">119280</code>
         <code class="n">Name</code><code class="p">:</code> <code class="n">area</code><code class="p">,</code> <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>Equivalently, we can use attribute-style access with column names that
are strings:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">20</code><code class="p">]:</code> <code class="n">data</code><code class="o">.</code><code class="n">area</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">20</code><code class="p">]:</code> <code class="n">California</code>      <code class="mi">423967</code>
         <code class="n">Texas</code>           <code class="mi">695662</code>
         <code class="n">Florida</code>         <code class="mi">170312</code>
         <code class="n">New</code> <code class="n">York</code>        <code class="mi">141297</code>
         <code class="n">Pennsylvania</code>    <code class="mi">119280</code>
         <code class="n">Name</code><code class="p">:</code> <code class="n">area</code><code class="p">,</code> <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>Though this is a useful shorthand, keep in mind that it does not work
for all cases! For example, if the column names are not strings, or if
the column names conflict with methods of the <code>DataFrame</code>, this
attribute-style access is not possible. <a data-primary="pop() method" data-type="indexterm" id="idm45858788826784"/>For example, the <code>DataFrame</code> has
a <code>pop</code> method, so <code>data.pop</code> will point to this rather than the <code>pop</code>
column:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">21</code><code class="p">]:</code> <code class="n">data</code><code class="o">.</code><code class="n">pop</code> <code class="ow">is</code> <code class="n">data</code><code class="p">[</code><code class="s2">"pop"</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">21</code><code class="p">]:</code> <code class="kc">False</code></pre>
<p>In particular, you should avoid the temptation to try column assignment
via attributes (i.e., use <code>data['pop'] = z</code>
rather than <code>data.pop = z</code>).</p>
<p>Like with the <code>Series</code> objects discussed earlier, this dictionary-style
syntax can also be used to modify the object, in this case adding a new
column:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">22</code><code class="p">]:</code> <code class="n">data</code><code class="p">[</code><code class="s1">'density'</code><code class="p">]</code> <code class="o">=</code> <code class="n">data</code><code class="p">[</code><code class="s1">'pop'</code><code class="p">]</code> <code class="o">/</code> <code class="n">data</code><code class="p">[</code><code class="s1">'area'</code><code class="p">]</code>
         <code class="n">data</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">22</code><code class="p">]:</code>                 <code class="n">area</code>       <code class="n">pop</code>     <code class="n">density</code>
         <code class="n">California</code>    <code class="mi">423967</code>  <code class="mi">39538223</code>   <code class="mf">93.257784</code>
         <code class="n">Texas</code>         <code class="mi">695662</code>  <code class="mi">29145505</code>   <code class="mf">41.896072</code>
         <code class="n">Florida</code>       <code class="mi">170312</code>  <code class="mi">21538187</code>  <code class="mf">126.463121</code>
         <code class="n">New</code> <code class="n">York</code>      <code class="mi">141297</code>  <code class="mi">20201249</code>  <code class="mf">142.970120</code>
         <code class="n">Pennsylvania</code>  <code class="mi">119280</code>  <code class="mi">13002700</code>  <code class="mf">109.009893</code></pre>
<p>This shows a preview of the straightforward syntax of element-by-element
arithmetic between <code>Series</code> objects; we’ll dig into this
further in <a data-type="xref" href="ch15.xhtml#section-0303-operations-in-pandas">Chapter 15</a>.</p>
</div></section>
<section data-pdf-bookmark="DataFrame as Two-Dimensional Array" data-type="sect2"><div class="sect2" id="ch_0302-data-indexing-and-selection_dataframe-as-two-dimensional-array">
<h2>DataFrame as Two-Dimensional Array</h2>
<p><a data-primary="DataFrame object (Pandas)" data-secondary="as two-dimensional array" data-secondary-sortas="two-dimensional" data-type="indexterm" id="ix_ch14-asciidoc5"/>As mentioned previously, we can also view the <code>DataFrame</code> as an enhanced
two-dimensional array. We can examine the raw underlying data array
using the <code>values</code> attribute:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">23</code><code class="p">]:</code> <code class="n">data</code><code class="o">.</code><code class="n">values</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">23</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mf">4.23967000e+05</code><code class="p">,</code> <code class="mf">3.95382230e+07</code><code class="p">,</code> <code class="mf">9.32577842e+01</code><code class="p">],</code>
                <code class="p">[</code><code class="mf">6.95662000e+05</code><code class="p">,</code> <code class="mf">2.91455050e+07</code><code class="p">,</code> <code class="mf">4.18960717e+01</code><code class="p">],</code>
                <code class="p">[</code><code class="mf">1.70312000e+05</code><code class="p">,</code> <code class="mf">2.15381870e+07</code><code class="p">,</code> <code class="mf">1.26463121e+02</code><code class="p">],</code>
                <code class="p">[</code><code class="mf">1.41297000e+05</code><code class="p">,</code> <code class="mf">2.02012490e+07</code><code class="p">,</code> <code class="mf">1.42970120e+02</code><code class="p">],</code>
                <code class="p">[</code><code class="mf">1.19280000e+05</code><code class="p">,</code> <code class="mf">1.30027000e+07</code><code class="p">,</code> <code class="mf">1.09009893e+02</code><code class="p">]])</code></pre>
<p>With this picture in mind, many familiar array-like operations can be
done on the <code>DataFrame</code> itself. For example, we can transpose the full
<code>DataFrame</code> to swap rows and columns:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">24</code><code class="p">]:</code> <code class="n">data</code><code class="o">.</code><code class="n">T</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">24</code><code class="p">]:</code>            <code class="n">California</code>         <code class="n">Texas</code>       <code class="n">Florida</code>      <code class="n">New</code> <code class="n">York</code>  <code class="n">Pennsylvania</code>
         <code class="n">area</code>     <code class="mf">4.239670e+05</code>  <code class="mf">6.956620e+05</code>  <code class="mf">1.703120e+05</code>  <code class="mf">1.412970e+05</code>  <code class="mf">1.192800e+05</code>
         <code class="n">pop</code>      <code class="mf">3.953822e+07</code>  <code class="mf">2.914550e+07</code>  <code class="mf">2.153819e+07</code>  <code class="mf">2.020125e+07</code>  <code class="mf">1.300270e+07</code>
         <code class="n">density</code>  <code class="mf">9.325778e+01</code>  <code class="mf">4.189607e+01</code>  <code class="mf">1.264631e+02</code>  <code class="mf">1.429701e+02</code>  <code class="mf">1.090099e+02</code></pre>
<p>When it comes to indexing of a <code>DataFrame</code> object, however, it is clear
that the dictionary-style indexing of columns precludes our ability to
simply treat it as a NumPy array. In particular, passing a single index
to an array accesses a row:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">25</code><code class="p">]:</code> <code class="n">data</code><code class="o">.</code><code class="n">values</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">25</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mf">4.23967000e+05</code><code class="p">,</code> <code class="mf">3.95382230e+07</code><code class="p">,</code> <code class="mf">9.32577842e+01</code><code class="p">])</code></pre>
<p>and passing a single “index” to a <code>DataFrame</code> accesses a column:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">26</code><code class="p">]:</code> <code class="n">data</code><code class="p">[</code><code class="s1">'area'</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">26</code><code class="p">]:</code> <code class="n">California</code>      <code class="mi">423967</code>
         <code class="n">Texas</code>           <code class="mi">695662</code>
         <code class="n">Florida</code>         <code class="mi">170312</code>
         <code class="n">New</code> <code class="n">York</code>        <code class="mi">141297</code>
         <code class="n">Pennsylvania</code>    <code class="mi">119280</code>
         <code class="n">Name</code><code class="p">:</code> <code class="n">area</code><code class="p">,</code> <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>Thus, for array-style indexing, we need another convention. Here Pandas
again uses the <code>loc</code> and <code>iloc</code> indexers mentioned earlier. Using the
<code>iloc</code> indexer, we can index the underlying array as if it were a simple
NumPy array (using the implicit Python-style index), but the <code>DataFrame</code>
index and column labels are maintained in the result:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">27</code><code class="p">]:</code> <code class="n">data</code><code class="o">.</code><code class="n">iloc</code><code class="p">[:</code><code class="mi">3</code><code class="p">,</code> <code class="p">:</code><code class="mi">2</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">27</code><code class="p">]:</code>               <code class="n">area</code>       <code class="n">pop</code>
         <code class="n">California</code>  <code class="mi">423967</code>  <code class="mi">39538223</code>
         <code class="n">Texas</code>       <code class="mi">695662</code>  <code class="mi">29145505</code>
         <code class="n">Florida</code>     <code class="mi">170312</code>  <code class="mi">21538187</code></pre>
<p>Similarly, using the <code>loc</code> indexer we can index the underlying data in
an array-like style but using the explicit index and column names:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">28</code><code class="p">]:</code> <code class="n">data</code><code class="o">.</code><code class="n">loc</code><code class="p">[:</code><code class="s1">'Florida'</code><code class="p">,</code> <code class="p">:</code><code class="s1">'pop'</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">28</code><code class="p">]:</code>               <code class="n">area</code>       <code class="n">pop</code>
         <code class="n">California</code>  <code class="mi">423967</code>  <code class="mi">39538223</code>
         <code class="n">Texas</code>       <code class="mi">695662</code>  <code class="mi">29145505</code>
         <code class="n">Florida</code>     <code class="mi">170312</code>  <code class="mi">21538187</code></pre>
<p>Any of the familiar NumPy-style data access patterns can be used within
these indexers. For example, in the <code>loc</code> indexer we can combine masking
and fancy indexing as follows:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">29</code><code class="p">]:</code> <code class="n">data</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="n">data</code><code class="o">.</code><code class="n">density</code> <code class="o">&gt;</code> <code class="mi">120</code><code class="p">,</code> <code class="p">[</code><code class="s1">'pop'</code><code class="p">,</code> <code class="s1">'density'</code><code class="p">]]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">29</code><code class="p">]:</code>                <code class="n">pop</code>     <code class="n">density</code>
         <code class="n">Florida</code>   <code class="mi">21538187</code>  <code class="mf">126.463121</code>
         <code class="n">New</code> <code class="n">York</code>  <code class="mi">20201249</code>  <code class="mf">142.970120</code></pre>
<p>Any of these indexing conventions may also be used to set or modify
values; this is done in the standard way that you might be accustomed to
from working with NumPy:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">30</code><code class="p">]:</code> <code class="n">data</code><code class="o">.</code><code class="n">iloc</code><code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">2</code><code class="p">]</code> <code class="o">=</code> <code class="mi">90</code>
         <code class="n">data</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">30</code><code class="p">]:</code>                 <code class="n">area</code>       <code class="n">pop</code>     <code class="n">density</code>
         <code class="n">California</code>    <code class="mi">423967</code>  <code class="mi">39538223</code>   <code class="mf">90.000000</code>
         <code class="n">Texas</code>         <code class="mi">695662</code>  <code class="mi">29145505</code>   <code class="mf">41.896072</code>
         <code class="n">Florida</code>       <code class="mi">170312</code>  <code class="mi">21538187</code>  <code class="mf">126.463121</code>
         <code class="n">New</code> <code class="n">York</code>      <code class="mi">141297</code>  <code class="mi">20201249</code>  <code class="mf">142.970120</code>
         <code class="n">Pennsylvania</code>  <code class="mi">119280</code>  <code class="mi">13002700</code>  <code class="mf">109.009893</code></pre>
<p>To build up your fluency in Pandas data manipulation, I suggest spending
some time with a simple <code>DataFrame</code> and exploring the types of indexing,
slicing, masking, and fancy indexing that are allowed by these various
indexing approaches.<a data-startref="ix_ch14-asciidoc5" data-type="indexterm" id="idm45858788176128"/></p>
</div></section>
<section data-pdf-bookmark="Additional Indexing Conventions" data-type="sect2"><div class="sect2" id="ch_0302-data-indexing-and-selection_additional-indexing-conventions">
<h2>Additional Indexing Conventions</h2>
<p>There are a couple of extra indexing conventions that might seem at odds
with the preceding discussion, but nevertheless can be useful in
practice. <a data-primary="DataFrame object (Pandas)" data-secondary="slicing" data-type="indexterm" id="idm45858788173904"/><a data-primary="slicing" data-secondary="Pandas conventions" data-type="indexterm" id="idm45858788173024"/>First, while <em>indexing</em> refers to columns, <em>slicing</em> refers to
rows:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">31</code><code class="p">]:</code> <code class="n">data</code><code class="p">[</code><code class="s1">'Florida'</code><code class="p">:</code><code class="s1">'New York'</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">31</code><code class="p">]:</code>             <code class="n">area</code>       <code class="n">pop</code>     <code class="n">density</code>
         <code class="n">Florida</code>   <code class="mi">170312</code>  <code class="mi">21538187</code>  <code class="mf">126.463121</code>
         <code class="n">New</code> <code class="n">York</code>  <code class="mi">141297</code>  <code class="mi">20201249</code>  <code class="mf">142.970120</code></pre>
<p>Such slices can also refer to rows by number rather than by index:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">32</code><code class="p">]:</code> <code class="n">data</code><code class="p">[</code><code class="mi">1</code><code class="p">:</code><code class="mi">3</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">32</code><code class="p">]:</code>            <code class="n">area</code>       <code class="n">pop</code>     <code class="n">density</code>
         <code class="n">Texas</code>    <code class="mi">695662</code>  <code class="mi">29145505</code>   <code class="mf">41.896072</code>
         <code class="n">Florida</code>  <code class="mi">170312</code>  <code class="mi">21538187</code>  <code class="mf">126.463121</code></pre>
<p><a data-primary="DataFrame object (Pandas)" data-secondary="masking" data-type="indexterm" id="idm45858788084944"/><a data-primary="masking" data-seealso="Boolean masks" data-type="indexterm" id="idm45858788083152"/>Similarly, direct masking operations are interpreted row-wise rather
than column-wise:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">33</code><code class="p">]:</code> <code class="n">data</code><code class="p">[</code><code class="n">data</code><code class="o">.</code><code class="n">density</code> <code class="o">&gt;</code> <code class="mi">120</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">33</code><code class="p">]:</code>             <code class="n">area</code>       <code class="n">pop</code>     <code class="n">density</code>
         <code class="n">Florida</code>   <code class="mi">170312</code>  <code class="mi">21538187</code>  <code class="mf">126.463121</code>
         <code class="n">New</code> <code class="n">York</code>  <code class="mi">141297</code>  <code class="mi">20201249</code>  <code class="mf">142.970120</code></pre>
<p>These two conventions are syntactically similar to those on a NumPy
array, and while they may not precisely fit the mold of the Pandas
conventions, they are included due to their practical utility<a data-startref="ix_ch14-asciidoc4" data-type="indexterm" id="idm45858788044224"/>.<a data-startref="ix_ch14-asciidoc1" data-type="indexterm" id="idm45858788009632"/><a data-startref="ix_ch14-asciidoc0" data-type="indexterm" id="idm45858788009024"/></p>
</div></section>
</div></section>
</div></section></div></body></html>