- en: Chapter 27\. Simple Scatter Plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another commonly used plot type is the simple scatter plot, a close cousin
    of the line plot. Instead of points being joined by line segments, here the points
    are represented individually with a dot, circle, or other shape. We’ll start by
    setting up the notebook for plotting and importing the packages we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Scatter Plots with plt.plot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter we looked at using `plt.plot`/`ax.plot` to produce line
    plots. It turns out that this same function can produce scatter plots as well
    (see [Figure 27-1](#fig_0402-simple-scatter-plots_files_in_output_4_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![output 4 0](assets/output_4_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 27-1\. Scatter plot example
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The third argument in the function call is a character that represents the type
    of symbol used for the plotting. Just as you can specify options such as `'-'`
    or `'--'` to control the line style, the marker style has its own set of short
    string codes. The full list of available symbols can be seen in the documentation
    of `plt.plot`, or in Matplotlib’s [online documentation](https://oreil.ly/tmYIL).
    Most of the possibilities are fairly intuitive, and a number of the more common
    ones are demonstrated here (see [Figure 27-2](#fig_0402-simple-scatter-plots_files_in_output_6_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![output 6 0](assets/output_6_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 27-2\. Demonstration of point numbers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For even more possibilities, these character codes can be used together with
    line and color codes to plot points along with a line connecting them (see [Figure 27-3](#fig_0402-simple-scatter-plots_files_in_output_8_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![output 8 0](assets/output_8_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 27-3\. Combining line and point markers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Additional keyword arguments to `plt.plot` specify a wide range of properties
    of the lines and markers, as you can see in [Figure 27-4](#fig_0402-simple-scatter-plots_files_in_output_10_0).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![output 10 0](assets/output_10_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 27-4\. Customizing line and point markers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: These kinds of options make `plt.plot` the primary workhorse for two-dimensional
    plots in Matplotlib. For a full description of the options available, refer to
    the [`plt.plot` documentation](https://oreil.ly/ON1xj).
  prefs: []
  type: TYPE_NORMAL
- en: Scatter Plots with plt.scatter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A second, more powerful method of creating scatter plots is the `plt.scatter`
    function, which can be used very similarly to the `plt.plot` function (see [Figure 27-5](#fig_0402-simple-scatter-plots_files_in_output_13_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![output 13 0](assets/output_13_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 27-5\. A simple scatter plot
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The primary difference of `plt.scatter` from `plt.plot` is that it can be used
    to create scatter plots where the properties of each individual point (size, face
    color, edge color, etc.) can be individually controlled or mapped to data.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s show this by creating a random scatter plot with points of many colors
    and sizes. In order to better see the overlapping results, we’ll also use the
    `alpha` keyword to adjust the transparency level (see [Figure 27-6](#fig_0402-simple-scatter-plots_files_in_output_15_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![output 15 0](assets/output_15_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 27-6\. Changing size and color in scatter points
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that the color argument is automatically mapped to a color scale (shown
    here by the `colorbar` command), and that the size argument is given in pixels.
    In this way, the color and size of points can be used to convey information in
    the visualization, in order to visualize multidimensional data.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we might use the Iris dataset from Scikit-Learn, where each sample
    is one of three types of flowers that has had the size of its petals and sepals
    carefully measured (see [Figure 27-7](#fig_0402-simple-scatter-plots_files_in_output_17_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![output 17 0](assets/output_17_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 27-7\. Using point properties to encode features of the Iris data^([1](ch27.xhtml#idm45858760750032))
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can see that this scatter plot has given us the ability to simultaneously
    explore four different dimensions of the data: the (*x*, *y*) location of each
    point corresponds to the sepal length and width, the size of the point is related
    to the petal width, and the color is related to the particular species of flower.
    Multicolor and multifeature scatter plots like this can be useful for both exploration
    and presentation of data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'plot Versus scatter: A Note on Efficiency'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aside from the different features available in `plt.plot` and `plt.scatter`,
    why might you choose to use one over the other? While it doesn’t matter as much
    for small amounts of data, as datasets get larger than a few thousand points,
    `plt.plot` can be noticeably more efficient than `plt.scatter`. The reason is
    that `plt.scatter` has the capability to render a different size and/or color
    for each point, so the renderer must do the extra work of constructing each point
    individually. With `plt.plot`, on the other hand, the markers for each point are
    guaranteed to be identical, so the work of determining the appearance of the points
    is done only once for the entire set of data. For large datasets, this difference
    can lead to vastly different performance, and for this reason, `plt.plot` should
    be preferred over `plt.scatter` for large datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing Uncertainties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For any scientific measurement, accurate accounting of uncertainties is nearly
    as important, if not more so, as accurate reporting of the number itself. For
    example, imagine that I am using some astrophysical observations to estimate the
    Hubble Constant, the local measurement of the expansion rate of the Universe.
    I know that the current literature suggests a value of around 70 (km/s)/Mpc, and
    I measure a value of 74 (km/s)/Mpc with my method. Are the values consistent?
    The only correct answer, given this information, is this: there is no way to know.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose I augment this information with reported uncertainties: the current
    literature suggests a value of 70 ± 2.5 (km/s)/Mpc, and my method has measured
    a value of 74 ± 5 (km/s)/Mpc. Now are the values consistent? That is a question
    that can be quantitatively answered.'
  prefs: []
  type: TYPE_NORMAL
- en: In visualization of data and results, showing these errors effectively can make
    a plot convey much more complete information.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Errorbars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One standard way to visualize uncertainties is using an errorbar. A basic errorbar
    can be created with a single Matplotlib function call, as shown in [Figure 27-8](#fig_0403-errorbars_files_in_output_4_0).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here the `fmt` is a format code controlling the appearance of lines and points,
    and it has the same syntax as the shorthand used in `plt.plot`, outlined in the
    previous chapter and earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![output 4 0](assets/output_4_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 27-8\. An errorbar example
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In addition to these basic options, the `errorbar` function has many options
    to fine-tune the outputs. Using these additional options you can easily customize
    the aesthetics of your errorbar plot. I often find it helpful, especially in crowded
    plots, to make the errorbars lighter than the points themselves (see [Figure 27-9](#fig_0403-errorbars_files_in_output_6_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![output 6 0](assets/output_6_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 27-9\. Customizing errorbars
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In addition to these options, you can also specify horizontal errorbars, one-sided
    errorbars, and many other variants. For more information on the options available,
    refer to the docstring of `plt.errorbar`.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some situations it is desirable to show errorbars on continuous quantities.
    Though Matplotlib does not have a built-in convenience routine for this type of
    application, it’s relatively easy to combine primitives like `plt.plot` and `plt.fill_between`
    for a useful result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we’ll perform a simple *Gaussian process regression*, using the Scikit-Learn
    API (see [Chapter 38](ch38.xhtml#section-0502-introducing-scikit-learn) for details).
    This is a method of fitting a very flexible nonparametric function to data with
    a continuous measure of the uncertainty. We won’t delve into the details of Gaussian
    process regression at this point, but will focus instead on how you might visualize
    such a continuous error measurement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We now have `xfit`, `yfit`, and `dyfit`, which sample the continuous fit to
    our data. We could pass these to the `plt.errorbar` function as in the previous
    section, but we don’t really want to plot 1,000 points with 1,000 errorbars. Instead,
    we can use the `plt.fill_between` function with a light color to visualize this
    continuous error (see [Figure 27-10](#fig_0403-errorbars_files_in_output_11_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![output 11 0](assets/output_11_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 27-10\. Representing continuous uncertainty with filled regions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Take a look at the `fill_between` call signature: we pass an x value, then
    the lower *y*-bound, then the upper *y*-bound, and the result is that the area
    between these regions is filled.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting figure gives an intuitive view into what the Gaussian process
    regression algorithm is doing: in regions near a measured data point, the model
    is strongly constrained, and this is reflected in the small model uncertainties.
    In regions far from a measured data point, the model is not strongly constrained,
    and the model uncertainties increase.'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the options available in `plt.fill_between` (and the
    closely related `plt.fill` function), see the function docstring or Matplotlib
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if this seems a bit too low-level for your taste, refer to [Chapter 36](ch36.xhtml#section-0414-visualization-with-seaborn),
    where we discuss the Seaborn package, which has a more streamlined API for visualizing
    this type of continuous errorbar.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch27.xhtml#idm45858760750032-marker)) A full-color version of this figure
    can be found on [GitHub](https://oreil.ly/PDSH_GitHub).
  prefs: []
  type: TYPE_NORMAL
