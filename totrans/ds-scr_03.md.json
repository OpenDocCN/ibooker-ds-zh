["```py\n# create a Python 3.6 environment named \"dsfs\"\nconda create -n dsfs python=3.6\n```", "```py\n#\n# To activate this environment, use:\n# > source activate dsfs\n#\n# To deactivate an active environment, use:\n# > source deactivate\n#\n```", "```py\nsource activate dsfs\n```", "```py\n(dsfs) ip-10-0-0-198:~ joelg$\n```", "```py\npython -m pip install ipython\n```", "```py\n# The pound sign marks the start of a comment. Python itself\n# ignores the comments, but they're helpful for anyone reading the code.\nfor i in [1, 2, 3, 4, 5]:\n    print(i)                    # first line in \"for i\" block\n    for j in [1, 2, 3, 4, 5]:\n        print(j)                # first line in \"for j\" block\n        print(i + j)            # last line in \"for j\" block\n    print(i)                    # last line in \"for i\" block\nprint(\"done looping\")\n```", "```py\nlong_winded_computation = (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 +\n                           13 + 14 + 15 + 16 + 17 + 18 + 19 + 20)\n```", "```py\nlist_of_lists = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\neasier_to_read_list_of_lists = [[1, 2, 3],\n                                [4, 5, 6],\n                                [7, 8, 9]]\n```", "```py\ntwo_plus_three = 2 + \\\n                 3\n```", "```py\nfor i in [1, 2, 3, 4, 5]:\n\n    # notice the blank line\n    print(i)\n```", "```py\nIndentationError: expected an indented block\n```", "```py\nimport re\nmy_regex = re.compile(\"[0-9]+\", re.I)\n```", "```py\nimport re as regex\nmy_regex = regex.compile(\"[0-9]+\", regex.I)\n```", "```py\nimport matplotlib.pyplot as plt\n\nplt.plot(...)\n```", "```py\nfrom collections import defaultdict, Counter\nlookup = defaultdict(int)\nmy_counter = Counter()\n```", "```py\nmatch = 10\nfrom re import *    # uh oh, re has a match function\nprint(match)        # \"<function match at 0x10281e6a8>\"\n```", "```py\ndef double(x):\n    \"\"\"\n This is where you put an optional docstring that explains what the\n function does. For example, this function multiplies its input by 2.\n \"\"\"\n    return x * 2\n```", "```py\ndef apply_to_one(f):\n    \"\"\"Calls the function f with 1 as its argument\"\"\"\n    return f(1)\n\nmy_double = double             # refers to the previously defined function\nx = apply_to_one(my_double)    # equals 2\n```", "```py\ny = apply_to_one(lambda x: x + 4)      # equals 5\n```", "```py\nanother_double = lambda x: 2 * x       # don't do this\n\ndef another_double(x):\n    \"\"\"Do this instead\"\"\"\n    return 2 * x\n```", "```py\ndef my_print(message = \"my default message\"):\n    print(message)\n\nmy_print(\"hello\")   # prints 'hello'\nmy_print()          # prints 'my default message'\n```", "```py\ndef full_name(first = \"What's-his-name\", last = \"Something\"):\n    return first + \" \" + last\n\nfull_name(\"Joel\", \"Grus\")     # \"Joel Grus\"\nfull_name(\"Joel\")             # \"Joel Something\"\nfull_name(last=\"Grus\")        # \"What's-his-name Grus\"\n```", "```py\nsingle_quoted_string = 'data science'\ndouble_quoted_string = \"data science\"\n```", "```py\ntab_string = \"\\t\"       # represents the tab character\nlen(tab_string)         # is 1\n```", "```py\nnot_tab_string = r\"\\t\"  # represents the characters '\\' and 't'\nlen(not_tab_string)     # is 2\n```", "```py\nmulti_line_string = \"\"\"This is the first line.\nand this is the second line\nand this is the third line\"\"\"\n```", "```py\nfirst_name = \"Joel\"\nlast_name = \"Grus\"\n```", "```py\nfull_name1 = first_name + \" \" + last_name             # string addition\nfull_name2 = \"{0} {1}\".format(first_name, last_name)  # string.format\n```", "```py\nfull_name3 = f\"{first_name} {last_name}\"\n```", "```py\ntry:\n    print(0 / 0)\nexcept ZeroDivisionError:\n    print(\"cannot divide by zero\")\n```", "```py\ninteger_list = [1, 2, 3]\nheterogeneous_list = [\"string\", 0.1, True]\nlist_of_lists = [integer_list, heterogeneous_list, []]\n\nlist_length = len(integer_list)     # equals 3\nlist_sum    = sum(integer_list)     # equals 6\n```", "```py\nx = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nzero = x[0]          # equals 0, lists are 0-indexed\none = x[1]           # equals 1\nnine = x[-1]         # equals 9, 'Pythonic' for last element\neight = x[-2]        # equals 8, 'Pythonic' for next-to-last element\nx[0] = -1            # now x is [-1, 1, 2, 3, ..., 9]\n```", "```py\nfirst_three = x[:3]                 # [-1, 1, 2]\nthree_to_end = x[3:]                # [3, 4, ..., 9]\none_to_four = x[1:5]                # [1, 2, 3, 4]\nlast_three = x[-3:]                 # [7, 8, 9]\nwithout_first_and_last = x[1:-1]    # [1, 2, ..., 8]\ncopy_of_x = x[:]                    # [-1, 1, 2, ..., 9]\n```", "```py\nevery_third = x[::3]                 # [-1, 3, 6, 9]\nfive_to_three = x[5:2:-1]            # [5, 4, 3]\n```", "```py\n1 in [1, 2, 3]    # True\n0 in [1, 2, 3]    # False\n```", "```py\nx = [1, 2, 3]\nx.extend([4, 5, 6])     # x is now [1, 2, 3, 4, 5, 6]\n```", "```py\nx = [1, 2, 3]\ny = x + [4, 5, 6]       # y is [1, 2, 3, 4, 5, 6]; x is unchanged\n```", "```py\nx = [1, 2, 3]\nx.append(0)      # x is now [1, 2, 3, 0]\ny = x[-1]        # equals 0\nz = len(x)       # equals 4\n```", "```py\nx, y = [1, 2]    # now x is 1, y is 2\n```", "```py\n_, y = [1, 2]    # now y == 2, didn't care about the first element\n```", "```py\nmy_list = [1, 2]\nmy_tuple = (1, 2)\nother_tuple = 3, 4\nmy_list[1] = 3      # my_list is now [1, 3]\n\ntry:\n    my_tuple[1] = 3\nexcept TypeError:\n    print(\"cannot modify a tuple\")\n```", "```py\ndef sum_and_product(x, y):\n    return (x + y), (x * y)\n\nsp = sum_and_product(2, 3)     # sp is (5, 6)\ns, p = sum_and_product(5, 10)  # s is 15, p is 50\n```", "```py\nx, y = 1, 2     # now x is 1, y is 2\nx, y = y, x     # Pythonic way to swap variables; now x is 2, y is 1\n```", "```py\nempty_dict = {}                     # Pythonic\nempty_dict2 = dict()                # less Pythonic\ngrades = {\"Joel\": 80, \"Tim\": 95}    # dictionary literal\n```", "```py\njoels_grade = grades[\"Joel\"]        # equals 80\n```", "```py\ntry:\n    kates_grade = grades[\"Kate\"]\nexcept KeyError:\n    print(\"no grade for Kate!\")\n```", "```py\njoel_has_grade = \"Joel\" in grades     # True\nkate_has_grade = \"Kate\" in grades     # False\n```", "```py\njoels_grade = grades.get(\"Joel\", 0)   # equals 80\nkates_grade = grades.get(\"Kate\", 0)   # equals 0\nno_ones_grade = grades.get(\"No One\")  # default is None\n```", "```py\ngrades[\"Tim\"] = 99                    # replaces the old value\ngrades[\"Kate\"] = 100                  # adds a third entry\nnum_students = len(grades)            # equals 3\n```", "```py\ntweet = {\n    \"user\" : \"joelgrus\",\n    \"text\" : \"Data Science is Awesome\",\n    \"retweet_count\" : 100,\n    \"hashtags\" : [\"#data\", \"#science\", \"#datascience\", \"#awesome\", \"#yolo\"]\n}\n```", "```py\ntweet_keys   = tweet.keys()     # iterable for the keys\ntweet_values = tweet.values()   # iterable for the values\ntweet_items  = tweet.items()    # iterable for the (key, value) tuples\n\n\"user\" in tweet_keys            # True, but not Pythonic\n\"user\" in tweet                 # Pythonic way of checking for keys\n\"joelgrus\" in tweet_values      # True (slow but the only way to check)\n```", "```py\nword_counts = {}\nfor word in document:\n    if word in word_counts:\n        word_counts[word] += 1\n    else:\n        word_counts[word] = 1\n```", "```py\nword_counts = {}\nfor word in document:\n    try:\n        word_counts[word] += 1\n    except KeyError:\n        word_counts[word] = 1\n```", "```py\nword_counts = {}\nfor word in document:\n    previous_count = word_counts.get(word, 0)\n    word_counts[word] = previous_count + 1\n```", "```py\nfrom collections import defaultdict\n\nword_counts = defaultdict(int)          # int() produces 0\nfor word in document:\n    word_counts[word] += 1\n```", "```py\ndd_list = defaultdict(list)             # list() produces an empty list\ndd_list[2].append(1)                    # now dd_list contains {2: [1]}\n\ndd_dict = defaultdict(dict)             # dict() produces an empty dict\ndd_dict[\"Joel\"][\"City\"] = \"Seattle\"     # {\"Joel\" : {\"City\": Seattle\"}}\n\ndd_pair = defaultdict(lambda: [0, 0])\ndd_pair[2][1] = 1                       # now dd_pair contains {2: [0, 1]}\n```", "```py\nfrom collections import Counter\nc = Counter([0, 1, 2, 0])          # c is (basically) {0: 2, 1: 1, 2: 1}\n```", "```py\n# recall, document is a list of words\nword_counts = Counter(document)\n```", "```py\n# print the 10 most common words and their counts\nfor word, count in word_counts.most_common(10):\n    print(word, count)\n```", "```py\nprimes_below_10 = {2, 3, 5, 7}\n```", "```py\ns = set()\ns.add(1)       # s is now {1}\ns.add(2)       # s is now {1, 2}\ns.add(2)       # s is still {1, 2}\nx = len(s)     # equals 2\ny = 2 in s     # equals True\nz = 3 in s     # equals False\n```", "```py\nstopwords_list = [\"a\", \"an\", \"at\"] + hundreds_of_other_words + [\"yet\", \"you\"]\n\n\"zip\" in stopwords_list     # False, but have to check every element\n\nstopwords_set = set(stopwords_list)\n\"zip\" in stopwords_set      # very fast to check\n```", "```py\nitem_list = [1, 2, 3, 1, 2, 3]\nnum_items = len(item_list)                # 6\nitem_set = set(item_list)                 # {1, 2, 3}\nnum_distinct_items = len(item_set)        # 3\ndistinct_item_list = list(item_set)       # [1, 2, 3]\n```", "```py\nif 1 > 2:\n    message = \"if only 1 were greater than two...\"\nelif 1 > 3:\n    message = \"elif stands for 'else if'\"\nelse:\n    message = \"when all else fails use else (if you want to)\"\n```", "```py\nparity = \"even\" if x % 2 == 0 else \"odd\"\n```", "```py\nx = 0\nwhile x < 10:\n    print(f\"{x} is less than 10\")\n    x += 1\n```", "```py\n# range(10) is the numbers 0, 1, ..., 9\nfor x in range(10):\n    print(f\"{x} is less than 10\")\n```", "```py\nfor x in range(10):\n    if x == 3:\n        continue  # go immediately to the next iteration\n    if x == 5:\n        break     # quit the loop entirely\n    print(x)\n```", "```py\none_is_less_than_two = 1 < 2          # equals True\ntrue_equals_false = True == False     # equals False\n```", "```py\nx = None\nassert x == None, \"this is the not the Pythonic way to check for None\"\nassert x is None, \"this is the Pythonic way to check for None\"\n```", "```py\ns = some_function_that_returns_a_string()\nif s:\n    first_char = s[0]\nelse:\n    first_char = \"\"\n```", "```py\nfirst_char = s and s[0]\n```", "```py\nsafe_x = x or 0\n```", "```py\nsafe_x = x if x is not None else 0\n```", "```py\nall([True, 1, {3}])   # True, all are truthy\nall([True, 1, {}])    # False, {} is falsy\nany([True, 1, {}])    # True, True is truthy\nall([])               # True, no falsy elements in the list\nany([])               # False, no truthy elements in the list\n```", "```py\nx = [4, 1, 2, 3]\ny = sorted(x)     # y is [1, 2, 3, 4], x is unchanged\nx.sort()          # now x is [1, 2, 3, 4]\n```", "```py\n# sort the list by absolute value from largest to smallest\nx = sorted([-4, 1, -2, 3], key=abs, reverse=True)  # is [-4, 3, -2, 1]\n\n# sort the words and counts from highest count to lowest\nwc = sorted(word_counts.items(),\n            key=lambda word_and_count: word_and_count[1],\n            reverse=True)\n```", "```py\neven_numbers = [x for x in range(5) if x % 2 == 0]  # [0, 2, 4]\nsquares      = [x * x for x in range(5)]            # [0, 1, 4, 9, 16]\neven_squares = [x * x for x in even_numbers]        # [0, 4, 16]\n```", "```py\nsquare_dict = {x: x * x for x in range(5)}  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}\nsquare_set  = {x * x for x in [1, -1]}      # {1}\n```", "```py\nzeros = [0 for _ in even_numbers]      # has the same length as even_numbers\n```", "```py\npairs = [(x, y)\n         for x in range(10)\n         for y in range(10)]   # 100 pairs (0,0) (0,1) ... (9,8), (9,9)\n```", "```py\nincreasing_pairs = [(x, y)                       # only pairs with x < y,\n                    for x in range(10)           # range(lo, hi) equals\n                    for y in range(x + 1, 10)]   # [lo, lo + 1, ..., hi - 1]\n```", "```py\nassert 1 + 1 == 2\nassert 1 + 1 == 2, \"1 + 1 should equal 2 but didn't\"\n```", "```py\ndef smallest_item(xs):\n    return min(xs)\n\nassert smallest_item([10, 20, 5, 40]) == 5\nassert smallest_item([1, 0, -1, 2]) == -1\n```", "```py\ndef smallest_item(xs):\n    assert xs, \"empty list has no smallest item\"\n    return min(xs)\n```", "```py\nclass CountingClicker:\n    \"\"\"A class can/should have a docstring, just like a function\"\"\"\n```", "```py\n    def __init__(self, count = 0):\n        self.count = count\n```", "```py\nclicker1 = CountingClicker()           # initialized to 0\nclicker2 = CountingClicker(100)        # starts with count=100\nclicker3 = CountingClicker(count=100)  # more explicit way of doing the same\n```", "```py\n    def __repr__(self):\n        return f\"CountingClicker(count={self.count})\"\n```", "```py\n    def click(self, num_times = 1):\n        \"\"\"Click the clicker some number of times.\"\"\"\n        self.count += num_times\n\n    def read(self):\n        return self.count\n\n    def reset(self):\n        self.count = 0\n```", "```py\nclicker = CountingClicker()\nassert clicker.read() == 0, \"clicker should start with count 0\"\nclicker.click()\nclicker.click()\nassert clicker.read() == 2, \"after two clicks, clicker should have count 2\"\nclicker.reset()\nassert clicker.read() == 0, \"after reset, clicker should be back to 0\"\n```", "```py\n# A subclass inherits all the behavior of its parent class.\nclass NoResetClicker(CountingClicker):\n    # This class has all the same methods as CountingClicker\n\n    # Except that it has a reset method that does nothing.\n    def reset(self):\n        pass\n\nclicker2 = NoResetClicker()\nassert clicker2.read() == 0\nclicker2.click()\nassert clicker2.read() == 1\nclicker2.reset()\nassert clicker2.read() == 1, \"reset shouldn't do anything\"\n```", "```py\ndef generate_range(n):\n    i = 0\n    while i < n:\n        yield i   # every call to yield produces a value of the generator\n        i += 1\n```", "```py\nfor i in generate_range(10):\n    print(f\"i: {i}\")\n```", "```py\ndef natural_numbers():\n    \"\"\"returns 1, 2, 3, ...\"\"\"\n    n = 1\n    while True:\n        yield n\n        n += 1\n```", "```py\nevens_below_20 = (i for i in generate_range(20) if i % 2 == 0)\n```", "```py\n# None of these computations *does* anything until we iterate\ndata = natural_numbers()\nevens = (x for x in data if x % 2 == 0)\neven_squares = (x ** 2 for x in evens)\neven_squares_ending_in_six = (x for x in even_squares if x % 10 == 6)\n# and so on\n```", "```py\nnames = [\"Alice\", \"Bob\", \"Charlie\", \"Debbie\"]\n\n# not Pythonic\nfor i in range(len(names)):\n    print(f\"name {i} is {names[i]}\")\n\n# also not Pythonic\ni = 0\nfor name in names:\n    print(f\"name {i} is {names[i]}\")\n    i += 1\n\n# Pythonic\nfor i, name in enumerate(names):\n    print(f\"name {i} is {name}\")\n```", "```py\nimport random\nrandom.seed(10)  # this ensures we get the same results every time\n\nfour_uniform_randoms = [random.random() for _ in range(4)]\n\n# [0.5714025946899135,       # random.random() produces numbers\n#  0.4288890546751146,       # uniformly between 0 and 1.\n#  0.5780913011344704,       # It's the random function we'll use\n#  0.20609823213950174]      # most often.\n```", "```py\nrandom.seed(10)         # set the seed to 10\nprint(random.random())  # 0.57140259469\nrandom.seed(10)         # reset the seed to 10\nprint(random.random())  # 0.57140259469 again\n```", "```py\nrandom.randrange(10)    # choose randomly from range(10) = [0, 1, ..., 9]\nrandom.randrange(3, 6)  # choose randomly from range(3, 6) = [3, 4, 5]\n```", "```py\nup_to_ten = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nrandom.shuffle(up_to_ten)\nprint(up_to_ten)\n# [7, 2, 6, 8, 9, 4, 10, 1, 3, 5]   (your results will probably be different)\n```", "```py\nmy_best_friend = random.choice([\"Alice\", \"Bob\", \"Charlie\"])     # \"Bob\" for me\n```", "```py\nlottery_numbers = range(60)\nwinning_numbers = random.sample(lottery_numbers, 6)  # [16, 36, 10, 6, 25, 9]\n```", "```py\nfour_with_replacement = [random.choice(range(10)) for _ in range(4)]\nprint(four_with_replacement)  # [9, 4, 4, 2]\n```", "```py\nimport re\n\nre_examples = [                        # All of these are True, because\n    not re.match(\"a\", \"cat\"),              #  'cat' doesn't start with 'a'\n    re.search(\"a\", \"cat\"),                 #  'cat' has an 'a' in it\n    not re.search(\"c\", \"dog\"),             #  'dog' doesn't have a 'c' in it.\n    3 == len(re.split(\"[ab]\", \"carbs\")),   #  Split on a or b to ['c','r','s'].\n    \"R-D-\" == re.sub(\"[0-9]\", \"-\", \"R2D2\") #  Replace digits with dashes.\n    ]\n\nassert all(re_examples), \"all the regex examples should be True\"\n```", "```py\nlist1 = ['a', 'b', 'c']\nlist2 = [1, 2, 3]\n\n# zip is lazy, so you have to do something like the following\n[pair for pair in zip(list1, list2)]    # is [('a', 1), ('b', 2), ('c', 3)]\n```", "```py\npairs = [('a', 1), ('b', 2), ('c', 3)]\nletters, numbers = zip(*pairs)\n```", "```py\nletters, numbers = zip(('a', 1), ('b', 2), ('c', 3))\n```", "```py\ndef add(a, b): return a + b\n\nadd(1, 2)      # returns 3\ntry:\n    add([1, 2])\nexcept TypeError:\n    print(\"add expects two inputs\")\nadd(*[1, 2])   # returns 3\n```", "```py\ndef doubler(f):\n    # Here we define a new function that keeps a reference to f\n    def g(x):\n        return 2 * f(x)\n\n    # And return that new function\n    return g\n```", "```py\ndef f1(x):\n    return x + 1\n\ng = doubler(f1)\nassert g(3) == 8,  \"(3 + 1) * 2 should equal 8\"\nassert g(-1) == 0, \"(-1 + 1) * 2 should equal 0\"\n```", "```py\ndef f2(x, y):\n    return x + y\n\ng = doubler(f2)\ntry:\n    g(1, 2)\nexcept TypeError:\n    print(\"as defined, g only takes one argument\")\n```", "```py\ndef magic(*args, **kwargs):\n    print(\"unnamed args:\", args)\n    print(\"keyword args:\", kwargs)\n\nmagic(1, 2, key=\"word\", key2=\"word2\")\n\n# prints\n#  unnamed args: (1, 2)\n#  keyword args: {'key': 'word', 'key2': 'word2'}\n```", "```py\ndef other_way_magic(x, y, z):\n    return x + y + z\n\nx_y_list = [1, 2]\nz_dict = {\"z\": 3}\nassert other_way_magic(*x_y_list, **z_dict) == 6, \"1 + 2 + 3 should be 6\"\n```", "```py\ndef doubler_correct(f):\n    \"\"\"works no matter what kind of inputs f expects\"\"\"\n    def g(*args, **kwargs):\n        \"\"\"whatever arguments g is supplied, pass them through to f\"\"\"\n        return 2 * f(*args, **kwargs)\n    return g\n\ng = doubler_correct(f2)\nassert g(1, 2) == 6, \"doubler should work now\"\n```", "```py\ndef add(a, b):\n    return a + b\n\nassert add(10, 5) == 15,                  \"+ is valid for numbers\"\nassert add([1, 2], [3]) == [1, 2, 3],     \"+ is valid for lists\"\nassert add(\"hi \", \"there\") == \"hi there\", \"+ is valid for strings\"\n\ntry:\n    add(10, \"five\")\nexcept TypeError:\n    print(\"cannot add an int to a string\")\n```", "```py\ndef add(a: int, b: int) -> int:\n    return a + b\n\nadd(10, 5)           # you'd like this to be OK\nadd(\"hi \", \"there\")  # you'd like this to be not OK\n```", "```py\n    def dot_product(x, y): ...\n\n    # we have not yet defined Vector, but imagine we had\n    def dot_product(x: Vector, y: Vector) -> float: ...\n    ```", "```py\n    error: Argument 1 to \"add\" has incompatible type \"str\"; expected \"int\"\n    ```", "```py\n    from typing import Union\n\n    def secretly_ugly_function(value, operation): ...\n\n    def ugly_function(value: int,\n                      operation: Union[str, int, float, bool]) -> int:\n        ...\n    ```", "```py\ndef total(xs: list) -> float:\n    return sum(total)\n```", "```py\nfrom typing import List  # note capital L\n\ndef total(xs: List[float]) -> float:\n    return sum(total)\n```", "```py\n# This is how to type-annotate variables when you define them.\n# But this is unnecessary; it's \"obvious\" x is an int.\nx: int = 5\n```", "```py\nvalues = []         # what's my type?\nbest_so_far = None  # what's my type?\n```", "```py\nfrom typing import Optional\n\nvalues: List[int] = []\nbest_so_far: Optional[float] = None  # allowed to be either a float or None\n```", "```py\n# the type annotations in this snippet are all unnecessary\nfrom typing import Dict, Iterable, Tuple\n\n# keys are strings, values are ints\ncounts: Dict[str, int] = {'data': 1, 'science': 2}\n\n# lists and generators are both iterable\nif lazy:\n    evens: Iterable[int] = (x for x in range(10) if x % 2 == 0)\nelse:\n    evens = [0, 2, 4, 6, 8]\n\n# tuples specify a type for each element\ntriple: Tuple[int, float, int] = (10, 2.3, 5)\n```", "```py\nfrom typing import Callable\n\n# The type hint says that repeater is a function that takes\n# two arguments, a string and an int, and returns a string.\ndef twice(repeater: Callable[[str, int], str], s: str) -> str:\n    return repeater(s, 2)\n\ndef comma_repeater(s: str, n: int) -> str:\n    n_copies = [s for _ in range(n)]\n    return ', '.join(n_copies)\n\nassert twice(comma_repeater, \"type hints\") == \"type hints, type hints\"\n```", "```py\nNumber = int\nNumbers = List[Number]\n\ndef total(xs: Numbers) -> Number:\n    return sum(xs)\n```"]