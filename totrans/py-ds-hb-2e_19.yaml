- en: Chapter 16\. Handling Missing Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The difference between data found in many tutorials and data in the real world
    is that real-world data is rarely clean and homogeneous. In particular, many interesting
    datasets will have some amount of data missing. To make matters even more complicated,
    different data sources may indicate missing data in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss some general considerations for missing data,
    look at how Pandas chooses to represent it, and explore some built-in Pandas tools
    for handling missing data in Python. Here and throughout the book, I will refer
    to missing data in general as *null*, `*NaN*`, or *NA* values.
  prefs: []
  type: TYPE_NORMAL
- en: Trade-offs in Missing Data Conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A number of approaches have been developed to track the presence of missing
    data in a table or `DataFrame`. Generally, they revolve around one of two strategies:
    using a *mask* that globally indicates missing values, or choosing a *sentinel
    value* that indicates a missing entry.'
  prefs: []
  type: TYPE_NORMAL
- en: In the masking approach, the mask might be an entirely separate Boolean array,
    or it might involve appropriation of one bit in the data representation to locally
    indicate the null status of a value.
  prefs: []
  type: TYPE_NORMAL
- en: In the sentinel approach, the sentinel value could be some data-specific convention,
    such as indicating a missing integer value with –9999 or some rare bit pattern,
    or it could be a more global convention, such as indicating a missing floating-point
    value with `NaN` (Not a Number), a special value that is part of the IEEE floating-point
    specification.
  prefs: []
  type: TYPE_NORMAL
- en: Neither of these approaches is without trade-offs. Use of a separate mask array
    requires allocation of an additional Boolean array, which adds overhead in both
    storage and computation. A sentinel value reduces the range of valid values that
    can be represented, and may require extra (often nonoptimized) logic in CPU and
    GPU arithmetic, because common special values like `NaN` are not available for
    all data types.
  prefs: []
  type: TYPE_NORMAL
- en: As in most cases where no universally optimal choice exists, different languages
    and systems use different conventions. For example, the R language uses reserved
    bit patterns within each data type as sentinel values indicating missing data,
    while the SciDB system uses an extra byte attached to every cell to indicate an
    NA state.
  prefs: []
  type: TYPE_NORMAL
- en: Missing Data in Pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way in which Pandas handles missing values is constrained by its reliance
    on the NumPy package, which does not have a built-in notion of NA values for non-floating-point
    data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps Pandas could have followed R’s lead in specifying bit patterns for
    each individual data type to indicate nullness, but this approach turns out to
    be rather unwieldy. While R has just 4 main data types, NumPy supports *far* more
    than this: for example, while R has a single integer type, NumPy supports 14 basic
    integer types once you account for available bit widths, signedness, and endianness
    of the encoding. Reserving a specific bit pattern in all available NumPy types
    would lead to an unwieldy amount of overhead in special-casing various operations
    for various types, likely even requiring a new fork of the NumPy package. Further,
    for the smaller data types (such as 8-bit integers), sacrificing a bit to use
    as a mask would significantly reduce the range of values it can represent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of these constraints and trade-offs, Pandas has two “modes” of storing
    and manipulating null values:'
  prefs: []
  type: TYPE_NORMAL
- en: The default mode is to use a sentinel-based missing data scheme, with sentinel
    values `NaN` or `None` depending on the type of the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, you can opt in to using the nullable data types (dtypes) Pandas
    provides (discussed later in this chapter), which results in the creation an accompanying
    mask array to track missing entries. These missing entries are then presented
    to the user as the special `pd.NA` value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In either case, the data operations and manipulations provided by the Pandas
    API will handle and propagate those missing entries in a predictable manner. But
    to develop some intuition into *why* these choices are made, let’s dive quickly
    into the trade-offs inherent in `None`, `NaN`, and `NA`. As usual, we’ll start
    by importing NumPy and Pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: None as a Sentinel Value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For some data types, Pandas uses `None` as a sentinel value. `None` is a Python
    object, which means that any array containing `None` must have `dtype=object`—that
    is, it must be a sequence of Python objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, observe what happens if you pass `None` to a NumPy array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This `dtype=object` means that the best common type representation NumPy could
    infer for the contents of the array is that they are Python objects. The downside
    of using `None` in this way is that operations on the data will be done at the
    Python level, with much more overhead than the typically fast operations seen
    for arrays with native types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, because Python does not support arithmetic operations with `None`,
    aggregations like `sum` or `min` will generally lead to an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For this reason, Pandas does not use `None` as a sentinel in its numerical arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'NaN: Missing Numerical Data'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The other missing data sentinel, `NaN` is different; it is a special floating-point
    value recognized by all systems that use the standard IEEE floating-point representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that NumPy chose a native floating-point type for this array: this means
    that unlike the object array from before, this array supports fast operations
    pushed into compiled code. Keep in mind that `NaN` is a bit like a data virus—it
    infects any other object it touches.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of the operation, the result of arithmetic with `NaN` will be another
    `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that aggregates over the values are well defined (i.e., they don’t
    result in an error) but not always useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'That said, NumPy does provide `NaN`-aware versions of aggregations that will
    ignore these missing values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The main downside of `NaN` is that it is specifically a floating-point value;
    there is no equivalent `NaN` value for integers, strings, or other types.
  prefs: []
  type: TYPE_NORMAL
- en: NaN and None in Pandas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`NaN` and `None` both have their place, and Pandas is built to handle the two
    of them nearly interchangeably, converting between them where appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For types that don’t have an available sentinel value, Pandas automatically
    typecasts when NA values are present. For example, if we set a value in an integer
    array to `np.nan`, it will automatically be upcast to a floating-point type to
    accommodate the NA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in addition to casting the integer array to floating point, Pandas
    automatically converts the `None` to a `NaN` value.
  prefs: []
  type: TYPE_NORMAL
- en: While this type of magic may feel a bit hackish compared to the more unified
    approach to NA values in domain-specific languages like R, the Pandas sentinel/casting
    approach works quite well in practice and in my experience only rarely causes
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 16-1](#table-16-1) lists the upcasting conventions in Pandas when NA
    values are introduced.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-1\. Pandas handling of NAs by type
  prefs: []
  type: TYPE_NORMAL
- en: '| Typeclass | Conversion when storing NAs | NA sentinel value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `floating` | No change | `np.nan` |'
  prefs: []
  type: TYPE_TB
- en: '| `object` | No change | `None` or `np.nan` |'
  prefs: []
  type: TYPE_TB
- en: '| `integer` | Cast to `float64` | `np.nan` |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean` | Cast to `object` | `None` or `np.nan` |'
  prefs: []
  type: TYPE_TB
- en: Keep in mind that in Pandas, string data is always stored with an `object` dtype.
  prefs: []
  type: TYPE_NORMAL
- en: Pandas Nullable Dtypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In early versions of Pandas, `NaN` and `None` as sentinel values were the only
    missing data representations available. The primary difficulty this introduced
    was with regard to the implicit type casting: for example, there was no way to
    represent a true integer array with missing data.'
  prefs: []
  type: TYPE_NORMAL
- en: To address this difficulty, Pandas later added *nullable dtypes*, which are
    distinguished from regular dtypes by capitalization of their names (e.g., `pd.Int32`
    versus `np.int32`). For backward compatibility, these nullable dtypes are only
    used if specifically requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is a `Series` of integers with missing data, created from
    a list containing all three available markers of missing data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This representation can be used interchangeably with the others in all the operations
    explored through the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Operating on Null Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen, Pandas treats `None`, `NaN`, and `NA` as essentially interchangeable
    for indicating missing or null values. To facilitate this convention, Pandas provides
    several methods for detecting, removing, and replacing null values in Pandas data
    structures. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isnull`'
  prefs: []
  type: TYPE_NORMAL
- en: Generates a Boolean mask indicating missing values
  prefs: []
  type: TYPE_NORMAL
- en: '`notnull`'
  prefs: []
  type: TYPE_NORMAL
- en: Opposite of `isnull`
  prefs: []
  type: TYPE_NORMAL
- en: '`dropna`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a filtered version of the data
  prefs: []
  type: TYPE_NORMAL
- en: '`fillna`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a copy of the data with missing values filled or imputed
  prefs: []
  type: TYPE_NORMAL
- en: We will conclude this chapter with a brief exploration and demonstration of
    these routines.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Null Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pandas data structures have two useful methods for detecting null data: `isnull`
    and `notnull`. Either one will return a Boolean mask over the data. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned in [Chapter 14](ch14.xhtml#section-0302-data-indexing-and-selection),
    Boolean masks can be used directly as a `Series` or `DataFrame` index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `isnull()` and `notnull()` methods produce similar Boolean results for `DataFrame`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Dropping Null Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to these masking methods, there are the convenience methods `dropna`
    (which removes NA values) and `fillna` (which fills in NA values). For a `Series`,
    the result is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For a `DataFrame`, there are more options. Consider the following `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We cannot drop single values from a `DataFrame`; we can only drop entire rows
    or columns. Depending on the application, you might want one or the other, so
    `dropna` includes a number of options for a `DataFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `dropna` will drop all rows in which *any* null value is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can drop NA values along a different axis. Using `axis=1`
    or `axis=''columns''` drops all columns containing a null value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: But this drops some good data as well; you might rather be interested in dropping
    rows or columns with *all* NA values, or a majority of NA values. This can be
    specified through the `how` or `thresh` parameters, which allow fine control of
    the number of nulls to allow through.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default is `how=''any''`, such that any row or column containing a null
    value will be dropped. You can also specify `how=''all''`, which will only drop
    rows/columns that contain *all* null values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For finer-grained control, the `thresh` parameter lets you specify a minimum
    number of non-null values for the row/column to be kept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first and last rows have been dropped because they each contain only
    two non-null values.
  prefs: []
  type: TYPE_NORMAL
- en: Filling Null Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes rather than dropping NA values, you’d like to replace them with a
    valid value. This value might be a single number like zero, or it might be some
    sort of imputation or interpolation from the good values. You could do this in-place
    using the `isnull` method as a mask, but because it is such a common operation
    Pandas provides the `fillna` method, which returns a copy of the array with the
    null values replaced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following `Series`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can fill NA entries with a single value, such as zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can specify a forward fill to propagate the previous value forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can specify a backward fill to propagate the next values backward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of a `DataFrame`, the options are similar, but we can also specify
    an `axis` along which the fills should take place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice that if a previous value is not available during a forward fill, the
    NA value remains.
  prefs: []
  type: TYPE_NORMAL
