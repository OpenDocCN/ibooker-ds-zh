- en: 'Chapter 18\. Combining Datasets: concat and append'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the most interesting studies of data come from combining different data
    sources. These operations can involve anything from very straightforward concatenation
    of two different datasets to more complicated database-style joins and merges
    that correctly handle any overlaps between the datasets. `Series` and `DataFrame`s
    are built with this type of operation in mind, and Pandas includes functions and
    methods that make this sort of data wrangling fast and straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Here we’ll take a look at simple concatenation of `Series` and `DataFrame`s
    with the `pd.concat` function; later we’ll dive into more sophisticated in-memory
    merges and joins implemented in Pandas.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with the standard imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience, we’ll define this function, which creates a `DataFrame` of
    a particular form that will be useful in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we’ll create a quick class that allows us to display multiple
    `DataFrame`s side by side. The code makes use of the special `_repr_html_` method,
    which IPython/Jupyter uses to implement its rich object display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The use of this will become clearer as we continue our discussion in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall: Concatenation of NumPy Arrays'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Concatenation of `Series` and `DataFrame` objects behaves similarly to concatenation
    of NumPy arrays, which can be done via the `np.concatenate` function, as discussed
    in [Chapter 5](ch05.xhtml#section-0202-the-basics-of-numpy-arrays). Recall that
    with it, you can combine the contents of two or more arrays into a single array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The first argument is a list or tuple of arrays to concatenate. Additionally,
    in the case of multidimensional arrays, it takes an `axis` keyword that allows
    you to specify the axis along which the result will be concatenated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Simple Concatenation with pd.concat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pd.concat` function provides a similar syntax to `np.concatenate` but
    contains a number of options that we’ll discuss momentarily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`pd.concat` can be used for a simple concatenation of `Series` or `DataFrame`
    objects, just as `np.concatenate` can be used for simple concatenations of arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It also works to concatenate higher-dimensional objects, such as `DataFrame`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s default behavior is to concatenate row-wise within the `DataFrame` (i.e.,
    `axis=0`). Like `np.concatenate`, `pd.concat` allows specification of an axis
    along which concatenation will take place. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We could have equivalently specified `axis=1`; here we’ve used the more intuitive
    `axis='columns'`.
  prefs: []
  type: TYPE_NORMAL
- en: Duplicate Indices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One important difference between `np.concatenate` and `pd.concat` is that Pandas
    concatenation *preserves indices*, even if the result will have duplicate indices!
    Consider this short example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice the repeated indices in the result. While this is valid within `DataFrame`s,
    the outcome is often undesirable. `pd.concat` gives us a few ways to handle it.
  prefs: []
  type: TYPE_NORMAL
- en: Treating repeated indices as an error
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you’d like to simply verify that the indices in the result of `pd.concat`
    do not overlap, you can include the `verify_integrity` flag. With this set to
    `True`, the concatenation will raise an exception if there are duplicate indices.
    Here is an example, where for clarity we’ll catch and print the error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Ignoring the index
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes the index itself does not matter, and you would prefer it to simply
    be ignored. This option can be specified using the `ignore_index` flag. With this
    set to `True`, the concatenation will create a new integer index for the resulting
    `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Adding MultiIndex keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another option is to use the `keys` option to specify a label for the data
    sources; the result will be a hierarchically indexed series containing the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can use the tools discussed in [Chapter 17](ch17.xhtml#section-0305-hierarchical-indexing)
    to transform this multiply indexed `Data⁠Frame` into the representation we’re
    interested in.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenation with Joins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the short examples we just looked at, we were mainly concatenating `DataFrame`s
    with shared column names. In practice, data from different sources might have
    different sets of column names, and `pd.concat` offers several options in this
    case. Consider the concatenation of the following two `DataFrame`s, which have
    some (but not all!) columns in common:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The default behavior is to fill entries for which no data is available with
    NA values. To change this, we can adjust the `join` parameter of the `concat`
    function. By default, the join is a union of the input columns (`join=''outer''`),
    but we can change this to an intersection of the columns using `join=''inner''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful pattern is to use the `reindex` method before concatenation
    for finer control over which columns are dropped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The append Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because direct array concatenation is so common, `Series` and `DataFrame` objects
    have an `append` method that can accomplish the same thing in fewer keystrokes.
    For example, in place of `pd.concat([df1, df2])`, you can use `df1.append(df2)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that unlike the `append` and `extend` methods of Python lists,
    the `append` method in Pandas does not modify the original object; instead it
    creates a new object with the combined data. It also is not a very efficient method,
    because it involves creation of a new index *and* data buffer. Thus, if you plan
    to do multiple `append` operations, it is generally better to build a list of
    `DataFrame` objects and pass them all at once to the `concat` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we’ll look at a more powerful approach to combining data
    from multiple sources: the database-style merges/joins implemented in `pd.merge`.
    For more information on `concat`, `append`, and related functionality, see [“Merge,
    Join, Concatenate and Compare” in the Pandas documentation](https://oreil.ly/cY16c).'
  prefs: []
  type: TYPE_NORMAL
