["```py\nIn [1]: import seaborn as sns\n        iris = sns.load_dataset('iris')\n        iris.head()\nOut[1]:    sepal_length  sepal_width  petal_length  petal_width species\n        0           5.1          3.5           1.4          0.2  setosa\n        1           4.9          3.0           1.4          0.2  setosa\n        2           4.7          3.2           1.3          0.2  setosa\n        3           4.6          3.1           1.5          0.2  setosa\n        4           5.0          3.6           1.4          0.2  setosa\n```", "```py\nIn [2]: %matplotlib inline\n        import seaborn as sns\n        sns.pairplot(iris, hue='species', height=1.5);\n```", "```py\nIn [3]: X_iris = iris.drop('species', axis=1)\n        X_iris.shape\nOut[3]: (150, 4)\n```", "```py\nIn [4]: y_iris = iris['species']\n        y_iris.shape\nOut[4]: (150,)\n```", "```py\nIn [5]: import matplotlib.pyplot as plt\n        import numpy as np\n\n        rng = np.random.RandomState(42)\n        x = 10 * rng.rand(50)\n        y = 2 * x - 1 + rng.randn(50)\n        plt.scatter(x, y);\n```", "```py\nIn [6]: from sklearn.linear_model import LinearRegression\n```", "```py\nIn [7]: model = LinearRegression(fit_intercept=True)\n        model\nOut[7]: LinearRegression()\n```", "```py\nIn [8]: X = x[:, np.newaxis]\n        X.shape\nOut[8]: (50, 1)\n```", "```py\nIn [9]: model.fit(X, y)\nOut[9]: LinearRegression()\n```", "```py\nIn [10]: model.coef_\nOut[10]: array([1.9776566])\n```", "```py\nIn [11]: model.intercept_\nOut[11]: -0.9033107255311146\n```", "```py\nIn [12]: xfit = np.linspace(-1, 11)\n```", "```py\nIn [13]: Xfit = xfit[:, np.newaxis]\n         yfit = model.predict(Xfit)\n```", "```py\nIn [14]: plt.scatter(x, y)\n         plt.plot(xfit, yfit);\n```", "```py\nIn [15]: from sklearn.model_selection import train_test_split\n         Xtrain, Xtest, ytrain, ytest = train_test_split(X_iris, y_iris,\n                                                         random_state=1)\n```", "```py\nIn [16]: from sklearn.naive_bayes import GaussianNB # 1\\. choose model class\n         model = GaussianNB()                       # 2\\. instantiate model\n         model.fit(Xtrain, ytrain)                  # 3\\. fit model to data\n         y_model = model.predict(Xtest)             # 4\\. predict on new data\n```", "```py\nIn [17]: from sklearn.metrics import accuracy_score\n         accuracy_score(ytest, y_model)\nOut[17]: 0.9736842105263158\n```", "```py\nIn [18]: from sklearn.decomposition import PCA  # 1\\. choose model class\n         model = PCA(n_components=2)            # 2\\. instantiate model\n         model.fit(X_iris)                      # 3\\. fit model to data\n         X_2D = model.transform(X_iris)         # 4\\. transform the data\n```", "```py\nIn [19]: iris['PCA1'] = X_2D[:, 0]\n         iris['PCA2'] = X_2D[:, 1]\n         sns.lmplot(x=\"PCA1\", y=\"PCA2\", hue='species', data=iris, fit_reg=False);\n```", "```py\nIn [20]: from sklearn.mixture import GaussianMixture      # 1\\. choose model class\n         model = GaussianMixture(n_components=3,\n                                 covariance_type='full')  # 2\\. instantiate model\n         model.fit(X_iris)                                # 3\\. fit model to data\n         y_gmm = model.predict(X_iris)                    # 4\\. determine labels\n```", "```py\nIn [21]: iris['cluster'] = y_gmm\n         sns.lmplot(x=\"PCA1\", y=\"PCA2\", data=iris, hue='species',\n                    col='cluster', fit_reg=False);\n```", "```py\nIn [22]: from sklearn.datasets import load_digits\n         digits = load_digits()\n         digits.images.shape\nOut[22]: (1797, 8, 8)\n```", "```py\nIn [23]: import matplotlib.pyplot as plt\n\n         fig, axes = plt.subplots(10, 10, figsize=(8, 8),\n                                  subplot_kw={'xticks':[], 'yticks':[]},\n                                  gridspec_kw=dict(hspace=0.1, wspace=0.1))\n\n         for i, ax in enumerate(axes.flat):\n             ax.imshow(digits.images[i], cmap='binary', interpolation='nearest')\n             ax.text(0.05, 0.05, str(digits.target[i]),\n                     transform=ax.transAxes, color='green')\n```", "```py\nIn [24]: X = digits.data\n         X.shape\nOut[24]: (1797, 64)\n```", "```py\nIn [25]: y = digits.target\n         y.shape\nOut[25]: (1797,)\n```", "```py\nIn [26]: from sklearn.manifold import Isomap\n         iso = Isomap(n_components=2)\n         iso.fit(digits.data)\n         data_projected = iso.transform(digits.data)\n         print(data_projected.shape)\nOut[26]: (1797, 2)\n```", "```py\nIn [27]: plt.scatter(data_projected[:, 0], data_projected[:, 1], c=digits.target,\n                     edgecolor='none', alpha=0.5,\n                     cmap=plt.cm.get_cmap('viridis', 10))\n         plt.colorbar(label='digit label', ticks=range(10))\n         plt.clim(-0.5, 9.5);\n```", "```py\nIn [28]: Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, random_state=0)\n```", "```py\nIn [29]: from sklearn.naive_bayes import GaussianNB\n         model = GaussianNB()\n         model.fit(Xtrain, ytrain)\n         y_model = model.predict(Xtest)\n```", "```py\nIn [30]: from sklearn.metrics import accuracy_score\n         accuracy_score(ytest, y_model)\nOut[30]: 0.8333333333333334\n```", "```py\nIn [31]: from sklearn.metrics import confusion_matrix\n\n         mat = confusion_matrix(ytest, y_model)\n\n         sns.heatmap(mat, square=True, annot=True, cbar=False, cmap='Blues')\n         plt.xlabel('predicted value')\n         plt.ylabel('true value');\n```", "```py\nIn [32]: fig, axes = plt.subplots(10, 10, figsize=(8, 8),\n                                  subplot_kw={'xticks':[], 'yticks':[]},\n                                  gridspec_kw=dict(hspace=0.1, wspace=0.1))\n\n         test_images = Xtest.reshape(-1, 8, 8)\n\n         for i, ax in enumerate(axes.flat):\n             ax.imshow(test_images[i], cmap='binary', interpolation='nearest')\n             ax.text(0.05, 0.05, str(y_model[i]),\n                     transform=ax.transAxes,\n                     color='green' if (ytest[i] == y_model[i]) else 'red')\n```"]