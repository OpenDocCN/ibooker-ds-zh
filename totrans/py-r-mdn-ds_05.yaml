- en: Chapter 3\. Python for useRs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。面向使用者的 Python
- en: Rick J. Scavetta
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 瑞克·J·斯卡维塔
- en: Welcome, brave useR, to the wonderful world of the Pythonista! For many useRs,
    this brave new world may appear more varied — and thus more inconsistent and confusing — than
    what they’re used to in R. But don’t fret over diversity — celebrate it! In this
    chapter I’ll help you navigate through the rich and diverse Python jungle, highlighting
    various paths (workflows) that your Python-using colleagues may have taken, and
    which you may choose to explore later on. Meanwhile, know that you’ll eventually
    find the path that best suits you and your work environment, this will change
    over time and may not be the one outlined here. Like any good trek, use this route
    as a guide, not a rule book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎，勇敢的使用者，来到 Pythonista 的美妙世界！对于许多使用者来说，这个新世界可能看起来更加多样化 —— 因此也更加不一致和令人困惑 ——
    比他们在 R 中习惯的要多。但不要因为多样性而担忧 —— 应该庆祝它！在本章中，我将帮助您导航通过丰富多样的 Python 丛林，突出您的 Python 同事可能采取的各种路径（工作流），您以后也可以选择探索。同时，请知道，您最终会找到最适合您和您的工作环境的路径，这会随时间而变化，可能并不是这里所概述的那一条。就像任何好的远足一样，把这条路线当作指南，而不是规则书。
- en: 'I’ll cover the essentials of the “four elements” that I mentioned in the introduction
    to this part: *Functions*, *Objects*, *Logical Expressions* and *Indexing*. But
    I’ll begin by addressing three questions.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我将讨论这一部分介绍中提到的“四要素”的基本内容：*函数*、*对象*、*逻辑表达式* 和 *索引*。但我首先要回答三个问题。
- en: 'Question 1: Which version and build (distribution) to use? There are a few
    different versions and builds of Python to choose from, in contrast to R.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 1：要使用哪个版本和构建（分发）？与 R 不同，Python 有几个不同的版本和构建可供选择。
- en: 'Question 2: Which tools to use? The wide variety of IDEs, text editors and
    notebooks, plus the many ways of implementing virtual environments adds more choices
    to make.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 2：要使用哪些工具？广泛的集成开发环境（IDE）、文本编辑器和笔记本，加上许多实现虚拟环境的方法，增加了更多选择。
- en: 'Question 3: How does Python *the language* compare to R *the language*? Wrapping
    your head around an OOP-centric world, with a host of classes, methods, functions
    and keywords provides another barrier to entry.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 3：Python *语言* 与 R *语言* 相比如何？理解面向对象编程为主导的世界，以及大量的类、方法、函数和关键字，是另一个入门的障碍。
- en: I’ll address each of these questions in turn. My goal is to get you comfortable
    enough with reading and writing Python so that you can continue your bilingual
    journey in [Part III](part03.xhtml#p03) and [Part IV](part04.xhtml#p04). I’m not
    setting out to provide a full-fledged, deep introduction to Python for Data Science.
    For that purpose, visit O’Reilly’s *Python for Data Analysis* and *Python Data
    Science Handbook*; this chapter will help you appreciate those books even more.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我将依次回答这些问题。我的目标是让您足够熟悉阅读和编写 Python，以便您可以在 [第三部分](part03.xhtml#p03) 和 [第四部分](part04.xhtml#p04)
    继续您的双语旅程。我并不打算为数据科学提供一个全面深入的 Python 入门。为此，请访问 O'Reilly 的 *Python 数据分析* 和 *Python
    数据科学手册*；这一章将帮助您更好地理解那些书籍。
- en: If you’re eager to just get on with it and start using Python, you can skip
    to the section on notebooks, [“Notebooks”](#nb), and visit [the Google Colab notebook](https://colab.research.google.com/drive/1qwgMIKc84JCYAj0zJZQSOgVZbk6nI9XX?usp=sharing)
    for the lesson on Python, or access this chapter’s script at our book repository
    on [GitHub](https://github.com/moderndatadesign/PyR4MDS).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你急于开始使用 Python，可以跳过到关于笔记本的部分，[“笔记本”](#nb)，并访问[Google Colab 笔记本](https://colab.research.google.com/drive/1qwgMIKc84JCYAj0zJZQSOgVZbk6nI9XX?usp=sharing)来学习
    Python 的课程，或者在我们的书库的 [GitHub](https://github.com/moderndatadesign/PyR4MDS) 上访问本章的脚本。
- en: Versions and builds
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本和构建
- en: Although there are a few different distributions of R, useRs mostly stick with
    vanilla R obtained from [r-project.org](https://www.r-project.org/)^([1](ch03.xhtml#idm45127457573352)).
    For Python, there are at least four common Python *builds* (aka distributions)
    to contend with. In each case you’ll also want to consider the Python *version*
    as well.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 R 有几种不同的分发版本，但大多数用户仍然使用从 [r-project.org](https://www.r-project.org/)^([1](ch03.xhtml#idm45127457573352))
    获取的基本版本。对于 Python，至少有四种常见的 Python *构建*（即分发版本）供选择。在每种情况下，您还需要考虑 Python *版本*。
- en: 'First, you’ll notice that you likely have a system version of Python already
    installed. On my machine, running macOS Big Sur (`v11.1`), I see this version
    of Python using the following terminal command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可能已经注意到系统已经安装了 Python 的一个版本。在我使用的 macOS Big Sur (`v11.1`) 上，可以通过以下终端命令查看
    Python 的版本：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Interestingly, masOS also `python3` built in:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，masOS 也内置了 `python3`：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These are the Python installations that macOS uses internally; there’s no need
    to touch them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 macOS 内部使用的 Python 安装；不需要触碰它们。
- en: Second, we have *vanilla* Python — the bare-bones, straight-from-the-source
    version of Python. At the time of writing this is version 3.9\. Version 2.x is
    no longer supported and you should be using 3.x for future data science projects.
    Until you’re sure all packages you’ll use are compatible with the latest version,
    it’s a safe bet to stick to the last minor update, 3.8 in this case. Indeed, you
    may have multiple minor versions on your system.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们有 *原始的* Python —— 纯净的、直接来自源代码的 Python 版本。在撰写本文时，这是版本 3.9。2.x 版本已不再受支持，您应该使用
    3.x 版本进行未来的数据科学项目。在您确定您将使用的所有软件包与最新版本兼容之前，最好坚持使用最后一个小更新，本例中为 3.8 版本。事实上，您的系统上可能有多个小版本。
- en: To install the specific version you want, visit the Python [website](https://www.python.org/)
    and follow the instructions on the [download page](https://www.python.org/downloads/).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装您想要的特定版本，请访问 Python [网站](https://www.python.org/) 并按照 [下载页面](https://www.python.org/downloads/)
    上的说明操作。
- en: Installation varies depending on your system. As such, [the official Python
    Usage and Installation guide](https://docs.python.org/3.8/using/index.html) is
    the authoritative resource. If you encounter installation issues, a good starting
    point is to perform a literal web search (encase in double quotes) for the generic
    part of the error message.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 安装方式因系统而异。因此，[官方 Python 使用和安装指南](https://docs.python.org/3.8/using/index.html)
    是权威资源。如果遇到安装问题，一个好的起点是对错误消息的通用部分进行文字搜索（用双引号括起来）。
- en: '[Table 3-1](#install_python) provides other sources, but you’re well-advised
    to just go to the source^([2](ch03.xhtml#idm45127455968680)).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-1](#install_python) 提供了其他信息源，但您最好直接访问源头^([2](ch03.xhtml#idm45127455968680))。'
- en: Table 3-1\. Installing Python
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1\. 安装 Python
- en: '| Platform | Site | Alternative |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 平台 | 站点 | 替代方案 |'
- en: '| --- | --- | --- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Linux | `python.org` | Python 3 is already installed. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| Linux | `python.org` | Python 3 已经安装好了。 |'
- en: '| macOS | `python.org` | Use `brew install python3` in the terminal. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| macOS | `python.org` | 在终端中使用 `brew install python3`。 |'
- en: '| Windows | `python.org` | Install Python from the Windows Store. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| Windows | `python.org` | 从 Windows Store 安装 Python。 |'
- en: 'Third, there are two common `Conda` builds: `Anaconda` (aka `Conda`) and `miniconda`.
    `Conda` offers package, dependency and environment management for several programming
    languages, including Python and R, although it is seldomly used for R. These open
    source builds include Python, a suite of packages useful for data science and
    a collection of IDEs (including RStudio). Anaconda comes in a free individual
    version plus various commercial versions. As the name suggests, [miniconda](https://docs.conda.io/en/latest/miniconda.html)
    is a minimal installer. We’ll see `miniconda` make a reappearance in the last
    part of the book.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，有两种常见的 `Conda` 构建：`Anaconda`（又称 `Conda`）和 `miniconda`。`Conda` 提供了多种编程语言（包括
    Python 和 R）的软件包、依赖项和环境管理，尽管它很少用于 R。这些开源构建包括 Python、一套对数据科学有用的软件包以及一系列集成开发环境（包括
    RStudio）。Anaconda 包括免费的个人版本和各种商业版本。顾名思义，[miniconda](https://docs.conda.io/en/latest/miniconda.html)
    是一个最小的安装程序。我们将在本书的最后部分再次看到 `miniconda` 的出现。
- en: The Anaconda [website](https://www.anaconda.com/products/individual#Downloads)
    has detailed instructions for installation. You’ll notice that Anaconda may not
    come packaged with the latest version of Python. For example, at the time of writing,
    Anaconda comes packaged with Python 3.8, not 3.9\. So this provides some justification
    for our preference of vanilla Python 3.8, as mentioned above. Anaconda is a popular
    build, but for our purposes we’ll stick with vanilla Python to avoid the extra
    bells & whistles that, at this point, would only serve to distract us. Thus, I
    won’t consider this option further but will mention some significant differences
    as needed if you choose to go down this path.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Anaconda [网站](https://www.anaconda.com/products/individual#Downloads) 上有详细的安装说明。您会注意到，Anaconda
    可能不会打包最新版本的 Python。例如，在撰写本文时，Anaconda 打包的是 Python 3.8，而不是 3.9。因此，这为我们上面提到的偏爱原始
    Python 3.8 提供了一些理由。Anaconda 是一个流行的构建，但对于我们的目的，我们将坚持使用原始的 Python，以避免那些在这一点上只会分散我们注意力的额外功能。因此，我不会进一步考虑这个选项，但如果您选择这条路，我会在需要时提到一些重要的区别。
- en: Fourth, you may decide to not use a local Python installation and instead use
    the popular online version of Python provided by the [Google Colab](https://colab.research.google.com/)
    Notebooks interface^([3](ch03.xhtml#idm45127456453464)). There are other online
    Notebook tools, but it’s beyond the scope of this book to detail all of them.
    Notebooks are akin to RMarkdown documents but JSON-based. We’ll discuss them in
    more detail later on.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，您可能决定不使用本地Python安装，而是使用由[Google Colab](https://colab.research.google.com/)提供的流行的在线Python版本的Notebooks接口^([3](ch03.xhtml#idm45127456453464)).
    还有其他在线Notebook工具，但详细介绍超出了本书的范围。Notebooks类似于RMarkdown文档，但基于JSON。我们将在后面更详细地讨论它们。
- en: I bet you can already guess that this early-stage diversity can result in downstream
    confusion when installation-specific issues arise. Moving forward, we’ll assume
    you have a local or cloud-based installation of Python ready to go.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌你已经能够猜到，这种早期阶段的多样性可能会在安装特定问题出现时导致混乱。未来，我们将假设您已经准备好本地或云端安装的Python。
- en: Standard tooling
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准工具
- en: 'Similar to R, there are many ways to access Python. Common methods include:
    on the command line, IDEs, cloud-based IDEs, text editors and Notebooks. For simplicity,
    I’m not going to focus on executing Python on the command line. If you’re familiar
    with executing scripts on the command line, this is familiar territory. If not,
    you’ll cross that bridge when you come to it.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与R类似，访问Python的方式有很多种。常见的方法包括：在命令行上、IDE、基于云的IDE、文本编辑器和Notebooks。为简单起见，我不打算专注于在命令行上执行Python。如果您熟悉在命令行上执行脚本，这是熟悉的领域。如果不熟悉，待会儿您会遇到的。
- en: IDEs include JupyterLab, Spyder, PyCharm and our beloved RStudio. Cloud-Native
    IDEs include AWS Cloud9\. These are all variations on a theme, and in my experience
    are not typically favoured by Pythonistas, although there is a trend towards using
    cloud-based tools. It may sound strange that IDEs are not that popular, why not
    use an IDE if you have a great one available? I think the answer is two-fold.
    First, no IDE managed to position itself as the dominant, *de facto*, choice among
    Pythonistas like RStudio has among useRs. Second, because Python use cases are
    so varied, including often being executed on the command line itself, coding with
    IDEs just wasn’t attractive for many Pythonistas, especially if they came from
    a coding background and felt comfortable without an IDE. For me, this feeds a
    bit into a narrative that says Python is both more difficult and better than R.
    Both are incorrect! Sorry :/ Nonetheless, you may be tempted to begin using Python
    with a comfortable-looking IDE. Here, we make the argument that text editors will
    serve you better in the long run. We’ll get back to RStudio in the last part of
    the book as we bring Python and R together in a single script. For now, try to
    resist the urge to default to an IDE but watch for developments in cloud-platforms
    that may direct future trends.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: IDE包括JupyterLab、Spyder、PyCharm和我们心爱的RStudio。云原生IDE包括AWS Cloud9。这些都是主题的变体，在我的经验中通常不受Python爱好者青睐，尽管有使用云端工具的趋势。听起来很奇怪，IDE并不那么受欢迎，如果有一个很好的IDE为什么不使用呢？我认为答案有两个方面。首先，没有一个IDE像RStudio在用户中那样成为*事实上*的首选。其次，由于Python的使用案例如此广泛，通常甚至在命令行本身执行，对于许多Python爱好者来说，使用IDE编码并不那么吸引，特别是如果他们来自编码背景并且在没有IDE的情况下感觉很舒适。对我来说，这在某种程度上反映了Python比R更难但更好的叙述。这两种说法都是错误的！抱歉
    :/ 尽管如此，您可能会因为看起来舒适的IDE而开始使用Python。在这里，我们认为文本编辑器从长远来看会更好地为您服务。在书的最后部分，当我们将Python和R合并到一个脚本中时，我们将回到RStudio。目前，试着抵制默认使用IDE的冲动，但请关注可能引导未来趋势的云平台的发展。
- en: Text editors
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本编辑器
- en: Text editors are the most common and seemly preferred tool for composing pure
    Python scripts. There are a host of fantastic text editors to choose from, waxing
    and waning in popularity year-on-year. [Sublime](https://www.sublimetext.com/),
    [Atom](https://atom.io/), [Visual Studio Code](https://code.visualstudio.com/)
    (VS Code) and even the ur-editors [vim](https://www.vim.org/) and [emacs](https://www.gnu.org/software/emacs/),
    among many others, are in common use. Nonetheless, VS Code, an open-source editor
    developed and strongly supported by Microsoft has emerged in the past few years
    as the top choice. A marketplace for extensions means that the editor provides
    strong and easy support for a variety of languages, including Python and R^([4](ch03.xhtml#idm45127454706696)).
    Thus, we’ll focus on VS Code. Your first exercise is to obtain and install [VS
    code](https://code.visualstudio.com/).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 文本编辑器是编写纯 Python 脚本最常见且看似首选的工具。有许多出色的文本编辑器可供选择，每年都在人气上升和下降。[Sublime](https://www.sublimetext.com/)、[Atom](https://atom.io/)、[Visual
    Studio Code](https://code.visualstudio.com/)（VS Code）甚至是古老的编辑器 [vim](https://www.vim.org/)
    和 [emacs](https://www.gnu.org/software/emacs/)，以及许多其他编辑器，都在广泛使用中。尽管如此，VS Code，这款由微软开发和强力支持的开源编辑器，在过去几年中已成为首选。扩展市场意味着编辑器为包括
    Python 和 R 在内的多种语言提供了强大且简便的支持^([4](ch03.xhtml#idm45127454706696))。因此，我们将专注于 VS
    Code。你的第一个练习是获取并安装 [VS Code](https://code.visualstudio.com/)。
- en: The first time you open VS Code, you’ll be greeted with the welcome screen shown
    in [Figure 3-1](#vsc_0)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次打开 VS Code 时，将会看到欢迎屏幕，如[图 3-1](#vsc_0))所示。
- en: '![](Images/prds_0301.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/prds_0301.png)'
- en: Figure 3-1\. The VS Code welcome screen.
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-1\. VS Code 欢迎屏幕。
- en: When you click on the blank document icon in the upper left, you’ll be requested
    to open a folder or clone a git repository (from GitHub, for example). We’ll choose
    an empty folder called `Intro_python` that we’ve already created. Opening this
    folder is like opening a project in RStudio. Here, we can click on the new document
    icon and we’ll be tasked with giving the new document a name. Call the file `helloworld.py`,
    like in [Figure 3-2](#vsc_2).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击左上角的空白文档图标时，将要求你打开一个文件夹或克隆一个 git 仓库（例如来自 GitHub）。我们将选择一个名为 `Intro_python`
    的空文件夹，这个文件夹我们已经创建好了。打开这个文件夹就像在 RStudio 中打开一个项目一样。在这里，我们可以点击新文档图标，并将被要求为新文档命名。就像在[图 3-2](#vsc_2)中一样，文件名为
    `helloworld.py`。
- en: '![](Images/prds_0302.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/prds_0302.png)'
- en: Figure 3-2\. Our first python script.
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-2\. 我们的第一个 Python 脚本。
- en: Because of the file extension, VS Code has automatically detected that you want
    to use a Python interpreter for this document. VS Code, like many other text editors,
    can execute code directly from the document if it knows which interpreter to use.
    Notice in [Figure 3-2](#vsc_2) (lower-right) that VS Code will automatically ask
    you to install the appropriate extensions for Python since we don’t have them
    installed (and that the footer bar has turned from purple to blue, noting the
    use of a Python interpreter). You are encouraged to visit the marketplace and
    consider other extensions on your own, but less is more, mostly. In [Figure 3-3](#vsc_3)
    the extension homepage is displayed as the package installs. Note that this extension
    is developed and maintained directly by Microsoft, like VS Code itself, so we’re
    in good hands^([5](ch03.xhtml#idm45127457567032)).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文件扩展名，VS Code 自动检测到你希望在此文档中使用 Python 解释器。与许多其他文本编辑器一样，如果它知道要使用的解释器，VS Code
    可以直接执行文档中的代码。请注意[图 3-2](#vsc_2)（右下角），VS Code 将自动要求你安装适用于 Python 的适当扩展，因为我们尚未安装它们（并且页脚从紫色变为蓝色，表示正在使用
    Python 解释器）。鼓励你访问市场并考虑自行选择其他扩展，但大多数情况下“少即是多”。在[图 3-3](#vsc_3)中，显示了扩展主页在安装包时的状态。请注意，这个扩展是由微软直接开发和维护的，就像
    VS Code 本身一样，所以我们是在可靠的手中^([5](ch03.xhtml#idm45127457567032))。
- en: '![](Images/prds_0303.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/prds_0303.png)'
- en: Figure 3-3\. Installing the VS Code Python extension.
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-3\. 安装 VS Code Python 扩展。
- en: After the extension is installed, you’ll be greeted with the extension welcome
    page, displayed in [Figure 3-4](#vsc_4). The blue footer now notes the actual
    Python version that you’re using. Remember that you may have many different versions
    installed on your system, here I’m using `v3.8.6`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 安装扩展后，将会看到扩展的欢迎页面，显示在[图 3-4](#vsc_4)中。蓝色页脚现在显示了你正在使用的实际 Python 版本。请记住，你的系统上可能安装了许多不同的版本，在这里我使用的是
    `v3.8.6`。
- en: '![](Images/prds_0304.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/prds_0304.png)'
- en: Figure 3-4\. The VS Code Python extension welcome screen.
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-4\. VS Code Python 扩展的欢迎屏幕。
- en: The first item on the extension’s welcome page is “Create a Jupyter Notebook”.
    We’ll get to that soon enough; for now, it’s worth noting that we can use VS Code
    for both scripts and Notebooks. Also note that the first bullet point in that
    item tells us that to open a Notebook we should *run* a command in the Command
    Palette, which you can access by the keyboard shortcut `shift + cmd + P` on a
    Mac (or `shift + ctrl + P` on a PC)^([6](ch03.xhtml#idm45127457564296)). Return
    back to the `helloworld.py` file and use this keyboard shortcut to open the Command
    Palette. This is where you’ll execute all variety of commands to make your life
    as a Pythonista easier. The Command Palette is a relatively new feature in RStudio
    but has been a standard way to navigate text editors for quite a while. Each extension
    you install from the marketplace will add more commands that you can access here.
    Our first command will be to `Create New Integrated Terminal (in Active Workspace)`.
    You can get this by simply beginning to type the command and then let auto-complete
    work its magic. Make sure you choose the `(in Active Workspace)` option. Remember,
    this is like an RStudio project, so we want to remain in our Active Workspace.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展程序欢迎页面的第一项是“创建一个Jupyter Notebook”。我们很快就会讨论到这一点；现在值得注意的是，我们可以在VS Code中同时使用脚本和Notebooks。还要注意该项目的第一个要点告诉我们，要打开Notebook，我们应该在命令面板中*运行*一个命令，您可以通过Mac上的键盘快捷键`shift
    + cmd + P`（或PC上的`shift + ctrl + P`）来访问该面板^([6](ch03.xhtml#idm45127457564296))。返回到`helloworld.py`文件并使用此键盘快捷键来打开命令面板。这是您执行各种命令以使您的Python生活更轻松的地方。命令面板是RStudio中相对较新的功能，但长期以来一直是导航文本编辑器的标准方式。从市场安装的每个扩展程序都将添加更多您可以在此处访问的命令。我们的第一个命令将是`Create
    New Integrated Terminal (in Active Workspace)`。您只需开始输入命令，然后让自动完成完成其工作即可。确保选择`(in
    Active Workspace)`选项。请记住，这就像是一个RStudio项目，所以我们希望保持在我们的Active Workspace中。
- en: You’ll notice that this opens a new terminal pane at the bottom of the screen
    ([Figure 3-5](#vsc_5)). OK, let’s admit that this is starting to look more and
    more like an IDE, but let’s not get too excited!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在屏幕底部打开一个新的终端窗格（[图 3-5](#vsc_5)）。好吧，我们承认，这开始看起来越来越像一个集成开发环境（IDE），但我们不要太兴奋！
- en: '![](Images/prds_0305.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/prds_0305.png)'
- en: Figure 3-5\. VS Code with the Command Panel and an integrated terminal pane.
  id: totrans-50
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-5\. 带有命令面板和集成终端窗格的VS Code。
- en: 'So by now we’ve settled on a text editor and we have our first (empty) Python
    script. It looks like we’re ready to go — but not quite! We must address two crucial
    factors that you’ll encounter each time you want to create a new Python project:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经选定了一个文本编辑器，并且有了我们的第一个（空的）Python脚本。看起来我们已经准备好了 — 但还不完全！每当你想创建一个新的Python项目时，必须解决两个关键因素：
- en: Virtual (development) environments, and
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟（开发）环境，以及
- en: Installing packages
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装包
- en: Virtual environments
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟环境
- en: Most useRs are accustomed to using RStudio projects, which keep the working
    directory tied to the project directory. These are convenient, in that we don’t
    need to hard-code paths and are encouraged to keep all data and scripts in one
    directory. You’ll already have that when opening an entire folder in a VS Code
    workspace.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数用户习惯于使用RStudio项目，这些项目将工作目录绑定到项目目录。这些项目非常方便，因为我们无需硬编码路径，并且被鼓励将所有数据和脚本保存在一个目录中。当您在VS
    Code工作空间中打开整个文件夹时，您已经拥有了这一点。
- en: A major downside of R projects and VS Code workspaces is that they don’t provide
    portable, reproducible development environments! Many useRs have a single, global
    installation of each package (see `.libPaths()`) and rarely specify a specific
    R version.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: R项目和VS Code工作空间的一个主要缺点是它们无法提供便携、可重现的开发环境！许多用户只有每个包的单个全局安装（参见`.libPaths()`），很少指定特定的R版本。
- en: 'Now, dear useR, let’s be honest with each other: if you haven’t already, at
    some point you’ll encounter the problem of package version conflicts. You’ve updated
    a package globally and now an old script is defunct because it’s calling a deprecated
    function, or using a function’s default arguments that have since changed, or
    for any number of other reasons due to package version conflicts. This is a surprisingly
    common occurrence in R and is a truly dismal practice when working over a long
    period of time or collaboratively. There have been many attempts to implement
    some kind of controlled development environment in R over the years. The most
    recent, and hopefully the solution that will finally stick, is `renv`. If you
    haven’t kept up with developments there, please visitthe [package website](https://rstudio.github.io/renv/articles/renv.html)
    from RStudio.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，亲爱的用户，让我们彼此诚实吧：如果你还没有遇到过包版本冲突的问题，那么在某个时候你会遇到的。你已经全局更新了一个包，现在一个旧脚本无法工作，因为它调用了一个不推荐使用的函数，或者使用了函数的默认参数，而这些参数已经改变，或者由于包版本冲突的任何其他原因。这在
    R 中是一个令人惊讶地常见的问题，在长时间或协作工作中，这实际上是一种真正令人沮丧的做法。多年来，有许多尝试在 R 中实现某种受控开发环境。最近的尝试，也希望这将最终解决问题的方法，是
    `renv`。如果你没有关注这方面的发展，请访问 RStudio 的 [包网站](https://rstudio.github.io/renv/articles/renv.html)。
- en: Pythonistas have long used virtual environments to maintain future compatibility
    of their projects, a sign of the programming-first approach of Python’s origins.
    Here, a virtual environment is simply a hidden sub-directory within a project
    folder, called e.g. `.venv`. The `.` is what makes it hidden. You have many hidden
    files and directories all over your computer and for the most part they’re hidden
    because you have no business sticking your fingers in there. Inside `.venv` you’ll
    find the packages used in *this* specific project, and information about which
    Python build *this* project uses. Since each project now contains a virtual environment
    with all the packages and the appropriate package versions (!), you’re guaranteed
    that the project will continue working indefinitely, so long as that virtual environment
    exists. We can visualize the potential dependency issues between different machines
    as in [Figure 3-6](#venv), which highlights the benefit of having a single “source
    of truth” regarding package versions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Python 爱好者长期以来一直使用虚拟环境来保持其项目的未来兼容性，这是 Python 起源于编程优先方法的标志。在这里，虚拟环境只是项目文件夹中一个隐藏的子目录，例如
    `.venv`。`.` 是使它隐藏的关键。你的计算机上有很多隐藏的文件和目录，大部分时间它们是隐藏的，因为你没有在那里乱动的理由。在 `.venv` 内部，你会找到用于
    *这个* 特定项目的包以及关于 *这个* 项目使用的 Python 版本的信息。由于每个项目现在都包含一个虚拟环境，其中包含所有的包和适当的包版本（！），只要虚拟环境存在，你就保证项目将持续无限期地工作。我们可以像
    [Figure 3-6](#venv) 中可视化不同机器之间的潜在依赖问题，这突显了拥有关于包版本的单一“真相源”的好处。
- en: '![](Images/prds_0306.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/prds_0306.png)'
- en: Figure 3-6\. Sources of conflict in Python environments.
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 3-6\. Python 环境中的冲突来源。
- en: Like everything in Python there are many ways to make a virtual environment.
    We can use the `venv` or `virtualenv` packages. If you’re using Anaconda you’ll
    use the `conda` alternative which we won’t cover here. There are some subtle differences
    between `venv` and `virtualenv`, but at this point in the story they are irrelevant;
    let’s just stick with `venv`. In your new terminal window execute one of the commands
    in [Table 3-2](#venv_create) depending on your platform, as I’ve done in [Figure 3-7](#vsc_6).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Python 中的一切一样，创建虚拟环境有很多方法。我们可以使用 `venv` 或 `virtualenv` 包。如果你在使用 Anaconda，你将使用
    `conda` 的替代方法，这里我们不涉及。`venv` 和 `virtualenv` 之间有一些细微的差异，但在这个故事的这一点上它们是无关紧要的；让我们只使用
    `venv`。在你的新终端窗口中执行 [Table 3-2](#venv_create) 中的一个命令，就像我在 [Figure 3-7](#vsc_6)
    中所做的那样。
- en: Table 3-2\. Creating (and activating) a virtual environment with venv.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Table 3-2\. 使用 venv 创建（和激活）虚拟环境。
- en: '| Platform | Create | Activate (prefer VS Code auto-activate) |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 平台 | 创建 | 激活（最好使用 VS Code 的自动激活） |'
- en: '| --- | --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| macOS X & Linux | `python3 -m venv .venv` | `source .venv/bin/activate` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| macOS X & Linux | `python3 -m venv .venv` | `source .venv/bin/activate` |'
- en: '| Windows | `py -3 -m venv .venv` | `.venv\scripts\activate` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| Windows | `py -3 -m venv .venv` | `.venv\scripts\activate` |'
- en: '![](Images/prds_0307.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/prds_0307.png)'
- en: Figure 3-7\. Creating a new virtual environment in our active workspace.
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 3-7\. 在我们的活动工作区创建一个新的虚拟环境。
- en: 'After *creating* the virtual environment, you must *activate* it. The terminal
    commands for this are given in [Table 3-2](#venv_create) but it’s more convenient
    to let VS Code do what it does best. It will automatically detect your new virtual
    environment and ask if you want to activate it (see [Figure 3-8](#vsc_7)). Go
    for it! Notice that the Python interpreter in the lower left will also explicitly
    mention `(.venv): venv` ([Figure 3-9](#vsc_9)).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '在*创建*虚拟环境之后，您必须*激活*它。关于此的终端命令在[表3-2](#venv_create)中给出，但让VS Code做它最擅长的事情更方便。它将自动检测到您的新虚拟环境，并询问您是否要激活它（见[图3-8](#vsc_7)）。走吧！注意左下角的Python解释器也会明确提到`(.venv):
    venv`（见[图3-9](#vsc_9)）。'
- en: '![](Images/prds_0308.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/prds_0308.png)'
- en: Figure 3-8\. Activating a virtual environment in VS Code.
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-8\. 在VS Code中激活虚拟环境。
- en: If you are asked to install the Linter pylint, go ahead and confirm that also.
    This is how VS Code will be able to spot errors in your scripts.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要求安装Linter pylint，请继续确认。这是VS Code将能够在您的脚本中发现错误的方式。
- en: 'We’ll get to package installation in a second, for now let’s try to execute
    our first “Hello, world!” command. Return to your empty `helloworld.py` file and
    type:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们马上就会开始安装包，现在让我们试着执行我们的第一个“Hello, world!”命令。返回到你的空`helloworld.py`文件并输入：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Actually the print is not necessary, but it makes what we’re trying to do explicit.
    That looks a lot like a simple R function, right? The `#%%` is also not necessary
    but it’s a lovely feature of the Python extension in VS Code, and is highly recommended!
    Typing `#%%` allows us to break up our long script into executable chunks. It’s
    akin to R Markdown chunks, but much simpler and used in plain Python scripts.
    To execute the command, press `shift + enter` or click on the `run cell` text,
    as seen in [Figure 3-9](#vsc_9).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，打印是不必要的，但它使我们尝试做的事情变得明确。这看起来很像一个简单的R函数，对吧？`#%%`也不是必需的，但它是VS Code中Python扩展的一个可爱功能，强烈推荐使用！键入`#%%`允许我们将长脚本分成可执行的块。这类似于R
    Markdown块，但更简单，并且用于普通的Python脚本。要执行命令，请按`shift + enter`或单击`run cell`文本，如[图3-9](#vsc_9)所示。
- en: '![](Images/prds_0309.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/prds_0309.png)'
- en: Figure 3-9\. Executing your first code in Python.
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-9\. 在Python中执行您的第一个代码。
- en: You’ll be promptly asked to install the ipyKernel, fig. [Figure 3-9](#vsc_9)
    (lower-right). Confirm that, and you’ll get the output present in the new upper-right
    pane, visible in [Figure 3-10](#vsc_11).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您将立即被要求安装ipyKernel，见图[图3-9](#vsc_9)（右下角）。确认后，您将获得新窗口中的输出，可见于[图3-10](#vsc_11)。
- en: '![](Images/prds_0310.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/prds_0310.png)'
- en: Figure 3-10\. Viewing command output in the interactive python viewer.
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-10\. 在交互式Python查看器中查看命令输出。
- en: Alright, *now* we’re in business. That seems like a lot of work, but once you
    do it a couple times you’ll develop a routine and get the hang of it!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，*现在*我们开始做生意了。看起来工作量很大，但是做几次后，你会形成一种常规并掌握要领！
- en: Installing packages
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装软件包
- en: So far in the story we have installed some version of Python and accessed a
    workspace, like an R project, from within VS Code. We’ve also created a virtual
    environment, which we’re now ready to populate with our favorite data science
    packages. If you took the `conda` route, you’ll have used different commands but
    you’ll also be set to go with the most common data science packages pre-installed.
    That sounds really nice, but you may find that when you need to collaborate with
    other Python developers, e.g. data engineers or system administrators, they probably
    won’t be using Anaconda. We feel that there’s also something to be said for getting
    to the heart of Python without all the bells and whistles that Anaconda provides.
    Thus we’ve gone the vanilla route.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这个故事中，我们安装了某个版本的Python，并在VS Code中访问了一个工作区，就像在R项目中一样。我们还创建了一个虚拟环境，现在准备用我们喜爱的数据科学包来填充它。如果你选择了`conda`这条路线，你会使用不同的命令，但也将预装最常见的数据科学包。这听起来非常不错，但你可能会发现，当你需要与其他Python开发人员合作时，比如数据工程师或系统管理员，他们可能不会使用Anaconda。我们觉得，了解Python的核心，而不是Anaconda提供的所有花里胡哨的东西，也有其优点。因此，我们选择了纯粹的路线。
- en: 'Before we get into packages, let’s review some necessary terminology. In R,
    a library is a collection of individual packages. The same holds true for Python,
    but the use of *library* and *package* is not as strict. e.g. `pandas`, the package
    which provides the `DataFrame` class of objects, is referred to as both a library
    and a package on the `pandas` website itself. This mixture of the terms is common
    among Pythonistas, so if you’re a stickler for names, don’t let it confuse or
    bother you. However, modules are useful to note. A package is a collection of
    modules. This is useful to know since we can load an entire package or just a
    specific module therein. Thus, in general: library > package > module.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论包之前，让我们复习一些必要的术语。在 R 中，库是一组单独的包。对于 Python 也是如此，但是 *库* 和 *包* 的使用并不那么严格。例如，`pandas`
    这个包提供了 `DataFrame` 类的对象，它在 `pandas` 网站上被称为库和包。这种术语混用在 Python 程序员中很常见，所以如果你是一个严谨的命名者，不要被困扰。不过，模块是值得注意的。包是模块的集合。这是有用的知识，因为我们可以加载整个包或其中的一个特定模块。因此，一般而言：库
    > 包 > 模块。
- en: In R, you’d install packages from CRAN with the `install.packages()` function
    from within R itself. In Python, there are two equivalents of CRAN, PyPI (the
    Python Package Installer) for when using vanilla Python and `conda`, for when
    using Anaconda or miniconda (we’ll also see how to install packages in Google
    Colab directly in the online Notebook later on). To install packages from PyPI
    using vanilla Python, you’ll have to execute a command in the terminal. Recall
    that we still have our active terminal window in VS Code open from earlier. Execute
    the command `pip install matplotlib` in the terminal to install the `matplotlib`
    package in your virtual environment, as depicted in [Figure 3-11](#vsc_12). `pip`
    is the package installer for Python and also comes in various versions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，你可以使用 `install.packages()` 函数从 CRAN 安装包。在 Python 中，有两个等效的 CRAN，即 PyPI（Python
    包安装器）用于使用原始 Python，以及 `conda`，用于使用 Anaconda 或 miniconda（稍后我们还将看到如何直接在在线笔记本中在 Google
    Colab 中安装包）。要使用原始 Python 从 PyPI 安装包，你需要在终端中执行命令。回想一下，我们之前还有一个活动的 VS Code 终端窗口。在终端中执行命令
    `pip install matplotlib` 以在你的虚拟环境中安装 `matplotlib` 包，如[图 3-11](#vsc_12)所示。`pip`
    是 Python 的包安装器，也有各种版本。
- en: '![](Images/prds_0311.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '!   ![](Images/prds_0311.png)'
- en: Figure 3-11\. Installing a package into a virtual environment using the command
    line.
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-11\. 使用命令行将包安装到虚拟环境中。
- en: Packages that you’ll install in practically every virtual environment include
    `numpy`, `pandas`, `matplotlib`, `seaborn` ad `scipy`. You won’t have to install
    all of them all the time since their package dependencies will take care of that.
    If they are already installed pip will tell you and will not install anything
    further. The most common error messages you’ll encounter here are when your package
    version is incompatible with your Python version. For this, you can either use
    a different Python kernel^([7](ch03.xhtml#idm45127453933224)) for your project,
    or specify the exact package version you want to install. Like in R, you just
    need to install the package once, but you’ll need to *import* it every time (i.e.
    *initialize* it) you activate your environment (see above). It seems convenient
    that package installation is done in the terminal, separate from importing in
    the script. You’ve probably see many stray `install.packages()` functions in R
    scripts, which is kind of annoying.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎在每个虚拟环境中都会安装的包包括 `numpy`、`pandas`、`matplotlib`、`seaborn` 和 `scipy`。你不需要一直安装它们，因为它们的包依赖项会自动处理。如果它们已经安装，pip
    会告诉你，并且不会安装任何其他内容。你在这里遇到的最常见的错误消息是你的包版本与你的 Python 版本不兼容。对于这个问题，你可以为你的项目使用不同的 Python
    内核^([7](ch03.xhtml#idm45127453933224))，或者指定你想要安装的确切包版本。就像在 R 中一样，你只需要安装包一次，但是每次你激活你的环境时都需要
    *导入* 它（即 *初始化* 它）（见上文）。包安装与在脚本中导入分开似乎很方便。你可能在 R 脚本中看到许多单独的 `install.packages()`
    函数，这有点烦人。
- en: 'There are two more important points I want to mention. First, check all the
    packages installed in your environment, and their versions, in the terminal with:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我想提及另外两个重要点。首先，在终端中使用以下命令检查环境中安装的所有包及其版本：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Second, pipe this output to a file called `requirements.txt` by executing the
    following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，通过执行以下命令将此输出导出到名为 `requirements.txt` 的文件中：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Other users can now use `requirements.txt` to install all the necessary packages
    by using the following command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 其他用户现在可以使用 `requirements.txt` 文件通过以下命令安装所有必要的包：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notebooks
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 笔记本
- en: If you’ve followed the tutorial thus far you’re ready to proceed to the third
    question and begin exploring the Python language. Nonetheless, it’s worthwhile
    reviewing Notebooks, so read on. If you had a hard time getting Python set up
    locally, don’t fret! Jupyter Notebooks is where you can take a deep breath, set
    your installation issues aside and jump in afresh.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果到目前为止您已经按照教程操作，那么您已经准备好进入第三个问题并开始探索Python语言。尽管如此，复习笔记本仍然是值得的，所以请继续阅读。如果您在本地设置Python时遇到困难，不要担心！Jupyter
    Notebooks是一个让您可以松一口气，将安装问题搁置一旁并重新开始的地方。
- en: Jupyter Notebooks are built on the backbone of IPython, which originated in
    2001\. Jupyter, which stands for JUlia, PYThon and R, now accommodates dozens
    of programming languages and can be used in the JupyterLab IDE or straight-up
    Notebooks in Jupyter. Notebooks allow you to write text using markdown, add code
    chunks and see the in-line output. It sounds a lot like R Markdown! Well, yes
    and no. Under the hood an R Markdown is a flat text file that gets rendered as
    an HTML, doc or pdf. Notebooks are exclusively JSON-based HTML and can natively
    handle interactive components. For useRs, this is kind of like an interactive
    R Markdown with a `shiny` run-time by default. This means that you don’t compose
    a Notebook as a flat text file, which is an important distinction when considering
    editing potential.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter Notebooks建立在IPython的基础上，IPython起源于2001年。Jupyter代表JUlia、PYThon和R，现在支持数十种编程语言，并且可以在JupyterLab
    IDE或Jupyter中直接使用笔记本。笔记本允许您使用Markdown编写文本，添加代码块并查看内联输出。这听起来很像R Markdown！嗯，是和不是。在底层，R
    Markdown是一个平面文本文件，可以呈现为HTML、doc或pdf。笔记本专门基于JSON的HTML，可以原生地处理交互式组件。对于使用R的人来说，默认情况下，这有点像带有`shiny`运行时的交互式R
    Markdown。这意味着您不会将笔记本作为平面文本文件来构成，这在考虑编辑潜力时是一个重要的区别。
- en: Coding in Python often consists of pure notebooks. For example, if you venture
    into cloud platforms that work with big data for ML, like AWS Sagemaker, Google
    AI Platform or Azure ML Studio, you’ll start with notebooks. As we’ve already
    seen, they’re supported by VS Code. Other online versions include Kaggle competitions
    and published Jupyter Notebooks. Another variety of online notebooks is found
    in the Google Colab service. This allows you to produce and distribute online
    notebooks with a Python backend and is what we’ll use for exploring notebooks.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python编码中，通常会使用纯粹的笔记本。例如，如果你涉足处理大数据用于机器学习的云平台，比如AWS Sagemaker、Google AI平台或Azure
    ML Studio，你将从笔记本开始。正如我们已经看到的，它们受到VS Code的支持。其他在线版本包括Kaggle竞赛和发布的Jupyter Notebooks。另一种在线笔记本的变体可以在Google
    Colab服务中找到。这使您能够使用Python后端生成和分发在线笔记本，这也是我们用来探索笔记本的工具。
- en: To get familiar working with Notebooks, use this online tutorial from Jupyter
    [here](https://jupyter.org/try). Just click on the [Notebook Basics panel](https://notebooks.gesis.org/binder/jupyter/user/ipython-ipython-in-depth-c0k4jcir/notebooks/binder/Index.ipynb)
    and pay particular attention to the keyboard shortcuts.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要熟悉使用笔记本，请使用Jupyter的这个在线教程[这里](https://jupyter.org/try)。只需点击[Notebook Basics
    panel](https://notebooks.gesis.org/binder/jupyter/user/ipython-ipython-in-depth-c0k4jcir/notebooks/binder/Index.ipynb)，特别注意键盘快捷键。
- en: You you want to follow along, you can find the Google Colab Notebook for this
    chapter [here](https://colab.research.google.com/drive/1qwgMIKc84JCYAj0zJZQSOgVZbk6nI9XX?usp=sharing).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想跟进，您可以在这一章节找到Google Colab笔记本[这里](https://colab.research.google.com/drive/1qwgMIKc84JCYAj0zJZQSOgVZbk6nI9XX?usp=sharing)。
- en: '![](Images/prds_0312.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/prds_0312.png)'
- en: Figure 3-12\. Examples for getting started with Python Notebooks in using Google
    Colab.
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-12。使用Google Colab开始使用Python笔记本的示例。
- en: How does Python, the language, compare to R?
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python语言与R语言有什么区别呢？
- en: 'By now you should have followed one of two paths. If you have installed Python
    locally, you should have:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经选择了两条路中的一条。如果您已经在本地安装了Python，您应该已经：
- en: A project directory where you’ll store your data and script files.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个项目目录，您将在其中存储数据和脚本文件。
- en: A virtual environment set up within that directory.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该目录中设置一个虚拟环境。
- en: The typical packages for data science installed in that virtual environment.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该虚拟环境中安装数据科学的典型软件包。
- en: If you’ve decided to go the Google Colab route, you should have accessed this
    chapter’s Notebook (see above).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定使用Google Colab，您应该已经访问了本章的笔记本（见上文）。
- en: Now it’s time to start our project by importing the packages we’ll use. Here,
    we’ll see again that there are a variety of ways of doing this, but most are standard.
    Let’s take a look. In the book’s [repository](https://github.com/moderndatadesign/PyR4MDS),
    you’ll find a practice script with the following commands, or you can follow along
    in the Google Colab Notebook.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候通过导入我们将使用的包来开始我们的项目了。在这里，我们会再次看到有多种方法可以做到这一点，但大多数方法都是标准的。让我们来看看。在书的[存储库](https://github.com/moderndatadesign/PyR4MDS)中，您会找到一个练习脚本，其中包含以下命令，或者您可以在
    Google Colab Notebook 中跟随。
- en: As we go through these commands we’ll introduce more new terminology — keywords,
    methods & attributes — and discuss what they are in the context of Python.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们逐步介绍这些命令，我们将引入更多新术语——关键字、方法和属性——并讨论它们在 Python 上下文中的含义。
- en: 'First, we can import an entire package:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以导入整个包：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This allows us to use functions from the `math` package. The `math` package
    is already installed, so we didn’t need to use `pip`, but we do need to import
    it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们使用 `math` 包中的函数。`math` 包已经安装好了，所以我们不需要使用 `pip`，但我们确实需要导入它。
- en: 'This is first time we encounter a common and important aspect of the Python
    language: *keywords*, which behave like R’s reserved word but are more numerous.
    Right now there are 35 keywords in Python that can be placed in distinct groups
    (See Appendix A). Here `import` is an *import keyword*. As a useR accustomed to
    functional programming, you’d use `library(math)` in R. So, in this case, you
    can think of keywords as shortcuts to functions, which in many cases they are.
    That’s just like operators in R (think `<-`, `+`, `==`, `&`, etc.), which are
    just shortcuts to functions under-the-hood. they’re not written in the classic
    function format, but they could be.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次接触 Python 语言的一个常见而重要的方面：*关键字*，它们类似于 R 语言中的保留字，但数量更多。现在 Python 中有 35 个关键字，可以分成不同的组（见附录
    A）。在这里，`import` 是一个*导入关键字*。作为习惯于函数式编程的 useR，在 R 中你会使用 `library(math)`。因此，在这种情况下，你可以把关键字看作是函数的快捷方式，实际上在很多情况下确实是这样。这就像
    R 中的运算符（比如 `<-`、`+`、`==`、`&` 等），它们在底层也是函数的快捷方式。它们不是用经典的函数格式写的，但它们本质上确实是函数。
- en: In short, keywords are reserved words that have very specific meanings. In this
    case, `import` stands in for a function to *import* all the functions from the
    `math` package. Many keywords act like this, but not all. We’ll see some examples
    in a second.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，关键字是具有非常具体含义的保留字。在这种情况下，`import` 代表着一个函数，用于*导入* `math` 包中的所有函数。很多关键字都是这样的，但不是全部。我们稍后会看到一些例子。
- en: 'But first, now that we have the functions from the math package, let’s try
    this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，既然我们已经从 math 包中得到了函数，让我们试试这个：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here we see that the `.` has a specific meaning: Inside the `math` package,
    access the `log()` function. The two arguments are the digit and base. So you
    can see why the R Tidyverse tends to use `_` instead of `.` notation and why the
    prevalence of a meaningless `.` in many R functions frustrates many users coming
    from OOP-centric languages.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到 `.` 具有特定的含义：在 `math` 包内部，访问 `log()` 函数。两个参数分别是数字和基数。所以你可以看到为什么 R Tidyverse
    倾向于使用 `_` 而不是 `.` 符号，以及为什么许多 R 函数中无意义的 `.` 符号会让许多从面向对象编程语言转来的用户感到沮丧。
- en: Second, we can import an entire package and give it a specific, typically standardized,
    *alias*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可以导入整个包并给它一个特定的、通常是标准化的*别名*。
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There’s our second keyword, `as`. Notice that it’s not really acting as a stand
    in for a function unless we recall that `<-` is also a function. If we stretch
    our imagination we can imagine this is like the following in R:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的第二个关键字，`as`。请注意，它实际上并没有像一个函数一样起作用，除非我们记得 `<-` 也是一个函数。如果我们发挥一下想象力，我们可以把它想象成在
    R 中的以下用法：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'UseRs wouldn’t ever do that, but it’s the closest analogous command^([8](ch03.xhtml#idm45127453751608)).
    The `as` keyword is always used with `import` to provide a convenient *alias*
    for accessing a package or module’s functions^([9](ch03.xhtml#idm45127453749672)).
    Thus, it’s an explicit way to call the exact function we want. Execute this function
    to import the data set for future work:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: useR 不会这样做，但这是与之最接近的类似命令^([8](ch03.xhtml#idm45127453751608))。`as` 关键字总是与 `import`
    一起使用，为访问包或模块的函数提供了一个便捷的*别名*^([9](ch03.xhtml#idm45127453749672))。因此，它是调用我们想要的确切函数的明确方式。执行此函数以导入数据集以供将来使用：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice the `.` again? The above command is equivalent to this command in R:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意再次出现的 `.`？上面的命令相当于在 R 中执行以下命令：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Third, we can import a specific *module* from a package:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们可以从一个包中导入一个特定的*模块*：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There’s our third keyword, `from`. It lets us go inside the `scipy` package
    and *import* only the `stats` module.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的第三个关键字`from`。它允许我们进入`scipy`包并*仅*导入`stats`模块。
- en: Fourth, we can import a specific module from a package, also giving it a specific,
    typically standardized, alias.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，我们可以从包中导入特定模块，并为其指定一个通常标准化的别名。
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we can also import only a specific function from a package:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以仅从包中导入特定函数：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Import a dataset
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入数据集
- en: 'Above, we saw how to import a data set using a function from the `pandas` package:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，我们看到如何使用`pandas`包的函数导入数据集：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Examine the data
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查数据
- en: It’s always good practice to look at our data before we start working on it.
    In R we’d use things like `summary()` and `str()`, or `glimpse()` if we had `dplyr`
    initialized. Let’s see how that works in Python.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始处理数据之前，查看数据总是一个良好的做法。在R中，我们会使用`summary()`和`str()`，或者如果我们初始化了`dplyr`，则会使用`glimpse()`。让我们看看这在Python中是如何工作的。
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What the what?? This is the first time we’ve encountered this nomenclature,
    and there’s that ever-present dot notation again! The functions `info()`, `describe()`
    and `head()` are *methods* of the object `plant_growth`. A method is a function
    that is called by an object. Like other functions we can also provide specific
    arguments, although in these cases we’ll stick with the default.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 什么？？这是我们第一次遇到这个术语，而且又出现了那个无处不在的点符号！`info()`、`describe()`和`head()`函数是`plant_growth`对象的*方法*。方法是由对象调用的函数。与其他函数一样，我们也可以提供特定的参数，尽管在这些情况下，我们将坚持使用默认值。
- en: Note, in particular the output from the `info()` method. Here, we see for the
    first time that indexing begins as 0 in Python, as is the case with many programming
    languages —  and why shouldn’t it!? This is an important aspect of Pythonic programming.
    We’ll see the consequences of this later on when we get to indexing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意`info()`方法的输出。在这里，我们首次看到Python中索引从0开始，这与许多编程语言相同 —— 那又为什么不呢？这是Python编程的一个重要方面。当我们进行索引时，稍后我们将看到这会产生什么后果。
- en: The output from `.info()` also tells us that we have a `pandas DataFrame`. We’ll
    explore different object classes soon.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`.info()`的输出还告诉我们，我们有一个`pandas DataFrame`。我们很快会探索不同的对象类。'
- en: How about looking at the shape (i.e. dimensions) and column names of the `plant_growth`
    object?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如何查看`plant_growth`对象的形状（即维度）和列名？
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this case, we are calling *attributes* of the object, they don’t receive
    any brackets. So here we see that any given object can call permissible methods
    and attributes, according to its class. You’ll know this from R, when the class
    of an object allows it to be used in specific functions for which there are methods
    available for it. Under the hood the same magic is happening. R is function-first,
    OOP-second. It’s there, just we don’t need to worry about it *as much* in functional
    programming. To give you an idea of how this works in R, consider a built-in data
    set, `sunspots`. It’s a `ts` class object (i.e. time-series).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在调用对象的*属性*，它们不接收任何括号。因此，我们可以看到，任何给定对象都可以调用其类允许的可允许的方法和属性。您将从R中知道这一点，当对象的类允许它在具体函数中使用时。在底层，相同的魔术正在发生。R首先是函数，其次是OOP。它在那里，只是我们在函数式编程中不需要*太多*担心它。为了让您了解在R中这是如何工作的，请考虑内置数据集`sunspots`。它是一个`ts`类对象（即时间序列）。
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can find the methods for the plot function using:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码查找绘图函数的方法：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There, you’ll see the `plot.ts()` method, which is what is actually called when
    you provide a `ts` class object to the `plot()` function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将看到`plot.ts()`方法，当您为`plot()`函数提供一个`ts`类对象时，实际上调用的就是它。
- en: Finally, you may miss being able to actually *see* that data set like we can
    with the RStudio view option. Not to worry! You can click on the table icon in
    the interactive Python kernel and see everything in your environment. If you click
    on the `DataFrame`, it will open up a view for you to examine it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可能会错过实际*查看*数据集的能力，就像我们可以使用RStudio的查看选项一样。别担心！您可以点击交互式Python内核中的表格图标，并查看环境中的所有内容。如果您单击`DataFrame`，它将为您打开一个视图以便您查看它。
- en: Data Structures & Descriptive Statistics
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构与描述性统计
- en: 'Alright, now that we’ve come to grips with methods and attributes, let’s take
    a look at how you would generate some descriptive statistics. A `pandas DataFrame`
    is very similar to an R `data.frame` or `tbl`. It’s a 2-dimensional table where
    each column is a `Series`, like how columns are vectors of the same length in
    R data frames. Just like a `DataFrame` itself, a `Series` also has methods and
    attributes. Recall that the `group` column is categorical. By now, this command
    should make sense to you:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们已经掌握了方法和属性，让我们看看如何生成一些描述性统计数据。`pandas DataFrame`非常类似于R中的`data.frame`或`tbl`。它是一个二维表格，其中每一列都是一个`Series`，就像在R数据框中列是相同长度的向量一样。就像`DataFrame`本身一样，`Series`也有方法和属性。记住`group`列是分类的。到现在为止，这个命令应该对你有意义：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `[]` will be familiar to you from R, they index according to the name of
    a column. The `.` then takes this single column and calls a method, `.value_counts()`,
    which in this case counts the number of observations for each value.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`[[]]`对你来说可能很熟悉，它们按列名索引。然后，这个单列调用一个方法`.value_counts()`，在本例中计算每个值的观察次数。'
- en: 'How about this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这样如何：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`np` says we’re going to use a function from the `numpy` package we imported
    earlier. Inside that function, we provide numerical values, the `weight` Series
    of the `plant_growth` DataFrame.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`np`表示我们将使用我们之前导入的`numpy`包中的一个函数。在该函数内部，我们提供数值，即`plant_growth` DataFrame的`weight`
    Series。'
- en: How about some summary statistics. Can you guess what this method will do?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 关于一些汇总统计数据，你能猜到这个方法会做什么吗？
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Just like with `dplyr`’s `group_by()` function, the `groupby()` method will
    allow downstream methods to be applied on each subset according to a categorical
    variable, in this case the `group` Series. The `describe()` method will provide
    a suite of summary statistics for each subset.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`dplyr`的`group_by()`函数一样，`groupby()`方法将允许按照分类变量对每个子集应用下游方法，在本例中是`group` Series。`describe()`方法将为每个子集提供一系列汇总统计信息。
- en: 'This version is more specific:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本更加具体：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can probably guess that the `.agg()` method stands for *aggregate*. Aggregation
    functions return a single value (typically) and in R we’d specify it using the
    `summarise()` function.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能猜到`.agg()`方法代表*聚合*。聚合函数返回一个单一值（通常）在R中，我们会使用`summarise()`函数来指定它。
- en: 'The input to the `.agg()` method, `{''weight'':[''mean'',''std'']}`, is a Dictionary
    (class `dict`). You can think of this as a key-value pair, defined here using
    `{}`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`.agg()`方法的输入，`{'weight':['mean','std']}`，这是一个字典（类`dict`）。你可以将其看作是一个键值对，在这里使用`{}`定义：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We could also have used the `dict()` function for the same purpose:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`dict()`函数来达到同样的目的：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Dictionaries are data storage objects in their own right, are part of standard
    vanilla Python, and as we see here are used as arguments to input in methods and
    functions. This is similar to how lists in R are used for both data storage and
    as a list of arguments in specific circumstances. Nonetheless, a Dictionary is
    better thought of as an *associative array* since indexing is only by key, and
    not number. I may go so far as to say that a dictionary is even more like an environment
    in R, since that contains many objects but no indexing, but that may be a bit
    of a stretch.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是数据存储对象本身，是标准的纯粹Python的一部分，并且正如我们在这里看到的，被用作输入方法和函数中的参数。这与R中列表的使用方式相似，在特定情况下用于数据存储和作为参数列表。然而，字典更适合被视为*关联数组*，因为索引仅由键而不是数字完成。我可以说字典更像是R中的环境，因为它包含了许多对象但没有索引，但这可能有点牵强。
- en: Let’s dig a bit deeper. The following commands produce the same output, but
    in different formats!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入挖掘一下。以下命令产生相同的输出，但格式不同！
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice the `[[]]` versus `[]`? It recalls a difference that you may have encountered
    in R when working with data frames that are not tibbles.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`[[]]`与`[]`的区别吗？它提醒了你在处理不是tibbles的数据框时可能遇到的差异。
- en: 'Data structures: Back to the basics'
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据结构：回到基础
- en: 'We’ve already seen three common types of data storage objects in Python, `pandas
    DataFrame`, `pandas Series` and `dict`. Only `dict` is from vanilla Python so
    before we more on, I want to look as some of the other basic structures: `lists`,
    `tuples` and `NumPy arrays`. I’m introducing these much later than you’d expect,
    that’s because I wanted to begin with data frames, which are intuitive and frequently
    used. So let’s make sure we have basics covered before we wrap up:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们已经看到了三种常见的数据存储对象，`pandas DataFrame`、`pandas Series`和`dict`。只有`dict`是来自原始Python的，因此在我们进一步探讨之前，我想看看其他一些基本结构：`lists`、`tuples`和`NumPy
    arrays`。我选择在比预期晚得多的时间介绍它们，因为我希望从直觉和频繁使用的数据框架开始。所以在结束之前，让我们确保掌握了基础知识：
- en: 'First, like in R, you’ll see four key data types in Python:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，就像在R中一样，你会看到Python中的四种关键数据类型：
- en: Table 3-3\. Data types in Python.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 表3-3\. Python中的数据类型。
- en: '| Type | Name | Example |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 名称 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `bool` | Binary | `True` and `False` |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | 二进制 | `True`和`False` |'
- en: '| `int` | Integer numbers | 7,9,2,-4 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 整数 | 7,9,2,-4 |'
- en: '| `float` | Real numbers | 3.14, 2.78, 6.45 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `float` | 实数 | 3.14, 2.78, 6.45 |'
- en: '| `str` | String | All Alphanumeric and special characters |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `str` | 字符串 | 所有字母数字字符和特殊字符 |'
- en: 'Next, you’ll encounter lists, one-dimensional objects. Unlike vectors in R,
    each element can be a different object, e.g. another 1 dimensional list. Here’s
    are two simple lists:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将遇到列表，这是一维对象。与R中的向量不同，每个元素可以是不同的对象，例如另一个一维列表。这里是两个简单的列表：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Notice that the `[]` define a list. We actually already saw that when we defined
    the `dict` earlier:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`[]`定义了一个列表。实际上，我们在前面定义`dict`时已经看到了这一点：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So both `[]` and `{}` alone are valid in Python and behave differently than
    in R. But remember, we did use `[]` earlier to index the data frame, which is
    very similar to R.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`[]`和`{}`单独在Python中是有效的并且具有不同的行为，与R中不同。但请记住，我们之前使用`[]`来索引数据框，这与R非常相似。
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we have tuples, which are like lists, except they are immutable, i.e.
    unchangeable, they are defined by `()`, as such:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有元组，它们类似于列表，但是不可变，即不能更改，它们由`()`定义，如下所示：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A common use of tuples is when a function returns multiple values. As an example,
    the `divmod()` function returns the result of integer division and modulus of
    two numbers:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的常见用法是函数返回多个值时使用。例如，`divmod()`函数返回两个数的整数除法和模数的结果：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The result is a tuple, but we can *unpack* the tuple and assign each output
    to a separate object:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个元组，但我们可以*解包*这个元组，并将每个输出分配给单独的对象：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That’s really convenient when defining custom functions. The equivalent in R
    would be to save the output to a list.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义自定义函数时，这非常方便。在R中的等价操作是将输出保存到列表中。
- en: Astute useRs may be familiar with the multiple assign operator, `%<-%` introduced
    by the `zeallot` package and popularized by the `keras`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 精明的用户可能熟悉由`zeallot`包引入并由`keras`流行化的多重赋值操作符`%<-%`。
- en: 'The last data structure I want to mention is the NumPy array. This is very
    similar to a 1-dimensional list, but allows for vectorization, among other things.
    e.g.:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我想提到的最后一个数据结构是NumPy数组。这与一维列表非常相似，但允许进行向量化等操作。例如：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'That’s very different from a useR would expect. If we were working on an NumPy
    array, we’d be back in familiar territory:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这与使用R的用法非常不同。如果我们正在处理NumPy数组，我们将回到熟悉的领域：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Indexing and Logical Expressions
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引和逻辑表达式
- en: Now that we have a variety of objects, lets look at how to index them. We already
    saw that we can use `[]` and even `[[]]` as we see in R, but there are a couple
    interesting differences. Remember that indexing always begins at 0 in Python!
    Also, notice that one of the most common operators in R, `:` make a reappearance
    in Python, but in a slightly different form, here it’s `[start:end]`
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了各种对象，让我们看看如何对它们进行索引。我们已经看到可以使用`[]`甚至`[[]]`，就像在R中看到的那样，但是有几个有趣的区别。请记住，Python中的索引始终从0开始！另外，请注意，在R中最常见的操作符之一，即`:`，在Python中以稍微不同的形式再次出现，这里是`[start:end]`。
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `:` operator doesn’t need a left and right-hand side. If one side is empty
    the index begins or proceeds to the end. The start in *inclusive* and the end,
    if specified, is *exclusive*. Thus `:2` takes index 0 & 1, `1:` takes index 1
    up to the last element, which is unspecified and thus inclusive.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`:`运算符不需要左右两侧。如果一侧为空，则索引从开始或继续到末尾。起始处是*包含*的，如果指定了结束，那么结束是*不包含*的。因此`:2`获取索引0和1，`1:`获取从索引1到最后一个未指定的元素，因此是包含的。'
- en: For 2-dimensional data frames, we encounter the pandas `.iloc`, “index location”
    and `.loc` “location” methods.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二维数据框架，我们遇到了pandas的`.iloc`，“索引位置”和`.loc`“位置”方法。
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: For the `.loc()`, we can introduce logical expressions, i.e. combinations of
    relational and logical operators to ask and combine `True`/`False` questions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`.loc()`，我们可以引入逻辑表达式，即关系运算符和逻辑运算符的组合，以提出和组合`True`/`False`问题。
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: For more detail on indexing and logical expressions, see the notes in the appendix.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有关索引和逻辑表达式的更多详细信息，请参阅附录中的笔记。
- en: Plotting
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘图
- en: 'Alright, let’s take a look at some data visualization of weight described by
    group. Here, we have a box plot:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们来看看描述由组别权重的一些数据可视化。在这里，我们有一个箱线图：
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Just the points:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 只是这些点：
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And just the means with their standard deviations:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 只是均值和它们的标准偏差：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice that I’m using the `seaborn` package (alias `sns`) for data visualizations
    and then using `show()` function from `matplotlib` to print the visualization
    to the screen.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我正在使用`seaborn`包（别名为`sns`）进行数据可视化，然后使用`matplotlib`的`show()`函数将可视化结果打印到屏幕上。
- en: Inferential statistics
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推断统计
- en: In this dataset, we have a specific set-up in that we have three groups and
    we’re interested in two specific two-group comparisons. We can accomplish this
    by establishing a linear model.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个数据集中，我们有一个特定的设置，即我们有三个组，并且我们对两个特定的两组比较感兴趣。我们可以通过建立线性模型来实现这一点。
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can get the coefficients of the model directly:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接获取模型的系数：
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, let’s take a look at a summary of our model:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看看我们模型的摘要：
- en: '[PRE47]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Alright, let’s wrap this up by using a typical statistical test for this type
    of data: a 1-way ANOVA. Notice that we’re using our model, `results`, that we
    fitted above.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们通过使用这种类型数据的典型统计测试来结束：单因素方差分析。请注意，我们正在使用我们上面拟合的模型`results`。
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If we want to do all pair-wise comparisons, we can turn to Tukey’s Honestly
    Significant Differences (HSD) post-hoc test:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要进行所有成对比较，我们可以转向图基的Tukey显著性差异（HSD）事后检验：
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this instance, we’re starting with the `statsmodel` library, taking the `stats`
    package and the `multicomp` module therein and extracting *from* that only the
    specific `pairwise_tukeyhsd()` function to *import*. In the second line we execute
    the function with a continuous variable as the first argument and the grouping
    variable as the second argument.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从`statsmodel`库开始，使用其中的`stats`包和`multicomp`模块，并从中提取特定的`pairwise_tukeyhsd()`函数以导入。在第二行，我们使用连续变量作为第一个参数和分组变量作为第二个参数执行该函数。
- en: Final thoughts
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的想法
- en: In R, there has been a convergence on common practices and workflows since circa
    2016\. In Python, there is a lot more diversity in how to get up and running right
    from the word go. This diversity may seem daunting but it’s just a reflection
    of Python’s origin story and use cases in the real-world.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，自2016年以来，已经形成了关于常见实践和工作流程的共识。在Python中，有更多的多样性可以在一开始就上手。这种多样性可能看起来令人生畏，但它只是Python起源故事和现实世界用例的反映。
- en: If you’re a useR accustomed to the world of functional programming, wrapping
    your head around OOP methods can also seem pretty daunting, but once you get over
    that hurdle you can start exploiting the power of Python where it truly shines,
    the topic of [Part III](part03.xhtml#p03).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是习惯于函数式编程世界的用户，那么掌握面向对象的方法也可能会显得非常困难，但一旦您跨越了这个障碍，您就可以开始利用Python真正闪耀的地方，即第三部分的话题。
- en: ^([1](ch03.xhtml#idm45127457573352-marker)) Indeed, the other builds are seldom
    mentioned in proper company
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.xhtml#idm45127457573352-marker)) 实际上，其他构建很少在合适的公司提到
- en: ^([2](ch03.xhtml#idm45127455968680-marker)) You’ll need to install [homebrew](https://brew.sh/)
    if you want to go that route for macOS.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch03.xhtml#idm45127455968680-marker)) 如果您想通过这种方式进入macOS，请安装[homebrew](https://brew.sh/)。
- en: ^([3](ch03.xhtml#idm45127456453464-marker)) You’ll need a Google account to
    access this free resource.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch03.xhtml#idm45127456453464-marker)) 您需要一个Google账户来访问这个免费资源。
- en: ^([4](ch03.xhtml#idm45127454706696-marker)) Again, although R is supported,
    useRs seldom work in VS Code.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch03.xhtml#idm45127454706696-marker)) 尽管R得到支持，但使用者很少在VS Code中工作。
- en: ^([5](ch03.xhtml#idm45127457567032-marker)) Well, we’re in *somebody’s* hands,
    at least!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch03.xhtml#idm45127457567032-marker)) 好吧，至少我们是*某人的*手下！
- en: ^([6](ch03.xhtml#idm45127457564296-marker)) Astute userRs may have noticed that
    a Command Palette, invoked with the same keyboard shortcuts, was added to RStudio
    v1.4 in late 2020.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch03.xhtml#idm45127457564296-marker)) 敏锐的用户可能已经注意到，在2020年底，RStudio v1.4增加了使用相同键盘快捷键调用的命令面板。
- en: ^([7](ch03.xhtml#idm45127453933224-marker)) The Python execution backend.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch03.xhtml#idm45127453933224-marker)) Python 执行后端。
- en: ^([8](ch03.xhtml#idm45127453751608-marker)) But remember this for when we start
    using Python & R together, because we’ll see something very similar.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch03.xhtml#idm45127453751608-marker)) 但是请记住，当我们开始同时使用 Python 和 R 时，因为我们会看到非常相似的东西。
- en: ^([9](ch03.xhtml#idm45127453749672-marker)) Referring back to `log()`, you’re
    more likely to use `np.log()` instead of `math.log()` since it accepts a wider
    variety of input types.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch03.xhtml#idm45127453749672-marker)) 回顾一下`log()`，你更有可能使用`np.log()`而不是`math.log()`，因为它接受更广泛的输入类型。
