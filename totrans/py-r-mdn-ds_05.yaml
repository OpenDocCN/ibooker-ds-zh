- en: Chapter 3\. Python for useRs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rick J. Scavetta
  prefs: []
  type: TYPE_NORMAL
- en: Welcome, brave useR, to the wonderful world of the Pythonista! For many useRs,
    this brave new world may appear more varied — and thus more inconsistent and confusing — than
    what they’re used to in R. But don’t fret over diversity — celebrate it! In this
    chapter I’ll help you navigate through the rich and diverse Python jungle, highlighting
    various paths (workflows) that your Python-using colleagues may have taken, and
    which you may choose to explore later on. Meanwhile, know that you’ll eventually
    find the path that best suits you and your work environment, this will change
    over time and may not be the one outlined here. Like any good trek, use this route
    as a guide, not a rule book.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll cover the essentials of the “four elements” that I mentioned in the introduction
    to this part: *Functions*, *Objects*, *Logical Expressions* and *Indexing*. But
    I’ll begin by addressing three questions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Question 1: Which version and build (distribution) to use? There are a few
    different versions and builds of Python to choose from, in contrast to R.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Question 2: Which tools to use? The wide variety of IDEs, text editors and
    notebooks, plus the many ways of implementing virtual environments adds more choices
    to make.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Question 3: How does Python *the language* compare to R *the language*? Wrapping
    your head around an OOP-centric world, with a host of classes, methods, functions
    and keywords provides another barrier to entry.'
  prefs: []
  type: TYPE_NORMAL
- en: I’ll address each of these questions in turn. My goal is to get you comfortable
    enough with reading and writing Python so that you can continue your bilingual
    journey in [Part III](part03.xhtml#p03) and [Part IV](part04.xhtml#p04). I’m not
    setting out to provide a full-fledged, deep introduction to Python for Data Science.
    For that purpose, visit O’Reilly’s *Python for Data Analysis* and *Python Data
    Science Handbook*; this chapter will help you appreciate those books even more.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re eager to just get on with it and start using Python, you can skip
    to the section on notebooks, [“Notebooks”](#nb), and visit [the Google Colab notebook](https://colab.research.google.com/drive/1qwgMIKc84JCYAj0zJZQSOgVZbk6nI9XX?usp=sharing)
    for the lesson on Python, or access this chapter’s script at our book repository
    on [GitHub](https://github.com/moderndatadesign/PyR4MDS).
  prefs: []
  type: TYPE_NORMAL
- en: Versions and builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although there are a few different distributions of R, useRs mostly stick with
    vanilla R obtained from [r-project.org](https://www.r-project.org/)^([1](ch03.xhtml#idm45127457573352)).
    For Python, there are at least four common Python *builds* (aka distributions)
    to contend with. In each case you’ll also want to consider the Python *version*
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you’ll notice that you likely have a system version of Python already
    installed. On my machine, running macOS Big Sur (`v11.1`), I see this version
    of Python using the following terminal command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, masOS also `python3` built in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These are the Python installations that macOS uses internally; there’s no need
    to touch them.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we have *vanilla* Python — the bare-bones, straight-from-the-source
    version of Python. At the time of writing this is version 3.9\. Version 2.x is
    no longer supported and you should be using 3.x for future data science projects.
    Until you’re sure all packages you’ll use are compatible with the latest version,
    it’s a safe bet to stick to the last minor update, 3.8 in this case. Indeed, you
    may have multiple minor versions on your system.
  prefs: []
  type: TYPE_NORMAL
- en: To install the specific version you want, visit the Python [website](https://www.python.org/)
    and follow the instructions on the [download page](https://www.python.org/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: Installation varies depending on your system. As such, [the official Python
    Usage and Installation guide](https://docs.python.org/3.8/using/index.html) is
    the authoritative resource. If you encounter installation issues, a good starting
    point is to perform a literal web search (encase in double quotes) for the generic
    part of the error message.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](#install_python) provides other sources, but you’re well-advised
    to just go to the source^([2](ch03.xhtml#idm45127455968680)).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-1\. Installing Python
  prefs: []
  type: TYPE_NORMAL
- en: '| Platform | Site | Alternative |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Linux | `python.org` | Python 3 is already installed. |'
  prefs: []
  type: TYPE_TB
- en: '| macOS | `python.org` | Use `brew install python3` in the terminal. |'
  prefs: []
  type: TYPE_TB
- en: '| Windows | `python.org` | Install Python from the Windows Store. |'
  prefs: []
  type: TYPE_TB
- en: 'Third, there are two common `Conda` builds: `Anaconda` (aka `Conda`) and `miniconda`.
    `Conda` offers package, dependency and environment management for several programming
    languages, including Python and R, although it is seldomly used for R. These open
    source builds include Python, a suite of packages useful for data science and
    a collection of IDEs (including RStudio). Anaconda comes in a free individual
    version plus various commercial versions. As the name suggests, [miniconda](https://docs.conda.io/en/latest/miniconda.html)
    is a minimal installer. We’ll see `miniconda` make a reappearance in the last
    part of the book.'
  prefs: []
  type: TYPE_NORMAL
- en: The Anaconda [website](https://www.anaconda.com/products/individual#Downloads)
    has detailed instructions for installation. You’ll notice that Anaconda may not
    come packaged with the latest version of Python. For example, at the time of writing,
    Anaconda comes packaged with Python 3.8, not 3.9\. So this provides some justification
    for our preference of vanilla Python 3.8, as mentioned above. Anaconda is a popular
    build, but for our purposes we’ll stick with vanilla Python to avoid the extra
    bells & whistles that, at this point, would only serve to distract us. Thus, I
    won’t consider this option further but will mention some significant differences
    as needed if you choose to go down this path.
  prefs: []
  type: TYPE_NORMAL
- en: Fourth, you may decide to not use a local Python installation and instead use
    the popular online version of Python provided by the [Google Colab](https://colab.research.google.com/)
    Notebooks interface^([3](ch03.xhtml#idm45127456453464)). There are other online
    Notebook tools, but it’s beyond the scope of this book to detail all of them.
    Notebooks are akin to RMarkdown documents but JSON-based. We’ll discuss them in
    more detail later on.
  prefs: []
  type: TYPE_NORMAL
- en: I bet you can already guess that this early-stage diversity can result in downstream
    confusion when installation-specific issues arise. Moving forward, we’ll assume
    you have a local or cloud-based installation of Python ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Standard tooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to R, there are many ways to access Python. Common methods include:
    on the command line, IDEs, cloud-based IDEs, text editors and Notebooks. For simplicity,
    I’m not going to focus on executing Python on the command line. If you’re familiar
    with executing scripts on the command line, this is familiar territory. If not,
    you’ll cross that bridge when you come to it.'
  prefs: []
  type: TYPE_NORMAL
- en: IDEs include JupyterLab, Spyder, PyCharm and our beloved RStudio. Cloud-Native
    IDEs include AWS Cloud9\. These are all variations on a theme, and in my experience
    are not typically favoured by Pythonistas, although there is a trend towards using
    cloud-based tools. It may sound strange that IDEs are not that popular, why not
    use an IDE if you have a great one available? I think the answer is two-fold.
    First, no IDE managed to position itself as the dominant, *de facto*, choice among
    Pythonistas like RStudio has among useRs. Second, because Python use cases are
    so varied, including often being executed on the command line itself, coding with
    IDEs just wasn’t attractive for many Pythonistas, especially if they came from
    a coding background and felt comfortable without an IDE. For me, this feeds a
    bit into a narrative that says Python is both more difficult and better than R.
    Both are incorrect! Sorry :/ Nonetheless, you may be tempted to begin using Python
    with a comfortable-looking IDE. Here, we make the argument that text editors will
    serve you better in the long run. We’ll get back to RStudio in the last part of
    the book as we bring Python and R together in a single script. For now, try to
    resist the urge to default to an IDE but watch for developments in cloud-platforms
    that may direct future trends.
  prefs: []
  type: TYPE_NORMAL
- en: Text editors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Text editors are the most common and seemly preferred tool for composing pure
    Python scripts. There are a host of fantastic text editors to choose from, waxing
    and waning in popularity year-on-year. [Sublime](https://www.sublimetext.com/),
    [Atom](https://atom.io/), [Visual Studio Code](https://code.visualstudio.com/)
    (VS Code) and even the ur-editors [vim](https://www.vim.org/) and [emacs](https://www.gnu.org/software/emacs/),
    among many others, are in common use. Nonetheless, VS Code, an open-source editor
    developed and strongly supported by Microsoft has emerged in the past few years
    as the top choice. A marketplace for extensions means that the editor provides
    strong and easy support for a variety of languages, including Python and R^([4](ch03.xhtml#idm45127454706696)).
    Thus, we’ll focus on VS Code. Your first exercise is to obtain and install [VS
    code](https://code.visualstudio.com/).
  prefs: []
  type: TYPE_NORMAL
- en: The first time you open VS Code, you’ll be greeted with the welcome screen shown
    in [Figure 3-1](#vsc_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/prds_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. The VS Code welcome screen.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you click on the blank document icon in the upper left, you’ll be requested
    to open a folder or clone a git repository (from GitHub, for example). We’ll choose
    an empty folder called `Intro_python` that we’ve already created. Opening this
    folder is like opening a project in RStudio. Here, we can click on the new document
    icon and we’ll be tasked with giving the new document a name. Call the file `helloworld.py`,
    like in [Figure 3-2](#vsc_2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/prds_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. Our first python script.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because of the file extension, VS Code has automatically detected that you want
    to use a Python interpreter for this document. VS Code, like many other text editors,
    can execute code directly from the document if it knows which interpreter to use.
    Notice in [Figure 3-2](#vsc_2) (lower-right) that VS Code will automatically ask
    you to install the appropriate extensions for Python since we don’t have them
    installed (and that the footer bar has turned from purple to blue, noting the
    use of a Python interpreter). You are encouraged to visit the marketplace and
    consider other extensions on your own, but less is more, mostly. In [Figure 3-3](#vsc_3)
    the extension homepage is displayed as the package installs. Note that this extension
    is developed and maintained directly by Microsoft, like VS Code itself, so we’re
    in good hands^([5](ch03.xhtml#idm45127457567032)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/prds_0303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. Installing the VS Code Python extension.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After the extension is installed, you’ll be greeted with the extension welcome
    page, displayed in [Figure 3-4](#vsc_4). The blue footer now notes the actual
    Python version that you’re using. Remember that you may have many different versions
    installed on your system, here I’m using `v3.8.6`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/prds_0304.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4\. The VS Code Python extension welcome screen.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The first item on the extension’s welcome page is “Create a Jupyter Notebook”.
    We’ll get to that soon enough; for now, it’s worth noting that we can use VS Code
    for both scripts and Notebooks. Also note that the first bullet point in that
    item tells us that to open a Notebook we should *run* a command in the Command
    Palette, which you can access by the keyboard shortcut `shift + cmd + P` on a
    Mac (or `shift + ctrl + P` on a PC)^([6](ch03.xhtml#idm45127457564296)). Return
    back to the `helloworld.py` file and use this keyboard shortcut to open the Command
    Palette. This is where you’ll execute all variety of commands to make your life
    as a Pythonista easier. The Command Palette is a relatively new feature in RStudio
    but has been a standard way to navigate text editors for quite a while. Each extension
    you install from the marketplace will add more commands that you can access here.
    Our first command will be to `Create New Integrated Terminal (in Active Workspace)`.
    You can get this by simply beginning to type the command and then let auto-complete
    work its magic. Make sure you choose the `(in Active Workspace)` option. Remember,
    this is like an RStudio project, so we want to remain in our Active Workspace.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that this opens a new terminal pane at the bottom of the screen
    ([Figure 3-5](#vsc_5)). OK, let’s admit that this is starting to look more and
    more like an IDE, but let’s not get too excited!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/prds_0305.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-5\. VS Code with the Command Panel and an integrated terminal pane.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'So by now we’ve settled on a text editor and we have our first (empty) Python
    script. It looks like we’re ready to go — but not quite! We must address two crucial
    factors that you’ll encounter each time you want to create a new Python project:'
  prefs: []
  type: TYPE_NORMAL
- en: Virtual (development) environments, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most useRs are accustomed to using RStudio projects, which keep the working
    directory tied to the project directory. These are convenient, in that we don’t
    need to hard-code paths and are encouraged to keep all data and scripts in one
    directory. You’ll already have that when opening an entire folder in a VS Code
    workspace.
  prefs: []
  type: TYPE_NORMAL
- en: A major downside of R projects and VS Code workspaces is that they don’t provide
    portable, reproducible development environments! Many useRs have a single, global
    installation of each package (see `.libPaths()`) and rarely specify a specific
    R version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, dear useR, let’s be honest with each other: if you haven’t already, at
    some point you’ll encounter the problem of package version conflicts. You’ve updated
    a package globally and now an old script is defunct because it’s calling a deprecated
    function, or using a function’s default arguments that have since changed, or
    for any number of other reasons due to package version conflicts. This is a surprisingly
    common occurrence in R and is a truly dismal practice when working over a long
    period of time or collaboratively. There have been many attempts to implement
    some kind of controlled development environment in R over the years. The most
    recent, and hopefully the solution that will finally stick, is `renv`. If you
    haven’t kept up with developments there, please visitthe [package website](https://rstudio.github.io/renv/articles/renv.html)
    from RStudio.'
  prefs: []
  type: TYPE_NORMAL
- en: Pythonistas have long used virtual environments to maintain future compatibility
    of their projects, a sign of the programming-first approach of Python’s origins.
    Here, a virtual environment is simply a hidden sub-directory within a project
    folder, called e.g. `.venv`. The `.` is what makes it hidden. You have many hidden
    files and directories all over your computer and for the most part they’re hidden
    because you have no business sticking your fingers in there. Inside `.venv` you’ll
    find the packages used in *this* specific project, and information about which
    Python build *this* project uses. Since each project now contains a virtual environment
    with all the packages and the appropriate package versions (!), you’re guaranteed
    that the project will continue working indefinitely, so long as that virtual environment
    exists. We can visualize the potential dependency issues between different machines
    as in [Figure 3-6](#venv), which highlights the benefit of having a single “source
    of truth” regarding package versions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/prds_0306.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-6\. Sources of conflict in Python environments.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Like everything in Python there are many ways to make a virtual environment.
    We can use the `venv` or `virtualenv` packages. If you’re using Anaconda you’ll
    use the `conda` alternative which we won’t cover here. There are some subtle differences
    between `venv` and `virtualenv`, but at this point in the story they are irrelevant;
    let’s just stick with `venv`. In your new terminal window execute one of the commands
    in [Table 3-2](#venv_create) depending on your platform, as I’ve done in [Figure 3-7](#vsc_6).
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-2\. Creating (and activating) a virtual environment with venv.
  prefs: []
  type: TYPE_NORMAL
- en: '| Platform | Create | Activate (prefer VS Code auto-activate) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| macOS X & Linux | `python3 -m venv .venv` | `source .venv/bin/activate` |'
  prefs: []
  type: TYPE_TB
- en: '| Windows | `py -3 -m venv .venv` | `.venv\scripts\activate` |'
  prefs: []
  type: TYPE_TB
- en: '![](Images/prds_0307.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-7\. Creating a new virtual environment in our active workspace.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'After *creating* the virtual environment, you must *activate* it. The terminal
    commands for this are given in [Table 3-2](#venv_create) but it’s more convenient
    to let VS Code do what it does best. It will automatically detect your new virtual
    environment and ask if you want to activate it (see [Figure 3-8](#vsc_7)). Go
    for it! Notice that the Python interpreter in the lower left will also explicitly
    mention `(.venv): venv` ([Figure 3-9](#vsc_9)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/prds_0308.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-8\. Activating a virtual environment in VS Code.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you are asked to install the Linter pylint, go ahead and confirm that also.
    This is how VS Code will be able to spot errors in your scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll get to package installation in a second, for now let’s try to execute
    our first “Hello, world!” command. Return to your empty `helloworld.py` file and
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Actually the print is not necessary, but it makes what we’re trying to do explicit.
    That looks a lot like a simple R function, right? The `#%%` is also not necessary
    but it’s a lovely feature of the Python extension in VS Code, and is highly recommended!
    Typing `#%%` allows us to break up our long script into executable chunks. It’s
    akin to R Markdown chunks, but much simpler and used in plain Python scripts.
    To execute the command, press `shift + enter` or click on the `run cell` text,
    as seen in [Figure 3-9](#vsc_9).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/prds_0309.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-9\. Executing your first code in Python.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You’ll be promptly asked to install the ipyKernel, fig. [Figure 3-9](#vsc_9)
    (lower-right). Confirm that, and you’ll get the output present in the new upper-right
    pane, visible in [Figure 3-10](#vsc_11).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/prds_0310.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-10\. Viewing command output in the interactive python viewer.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Alright, *now* we’re in business. That seems like a lot of work, but once you
    do it a couple times you’ll develop a routine and get the hang of it!
  prefs: []
  type: TYPE_NORMAL
- en: Installing packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in the story we have installed some version of Python and accessed a
    workspace, like an R project, from within VS Code. We’ve also created a virtual
    environment, which we’re now ready to populate with our favorite data science
    packages. If you took the `conda` route, you’ll have used different commands but
    you’ll also be set to go with the most common data science packages pre-installed.
    That sounds really nice, but you may find that when you need to collaborate with
    other Python developers, e.g. data engineers or system administrators, they probably
    won’t be using Anaconda. We feel that there’s also something to be said for getting
    to the heart of Python without all the bells and whistles that Anaconda provides.
    Thus we’ve gone the vanilla route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into packages, let’s review some necessary terminology. In R,
    a library is a collection of individual packages. The same holds true for Python,
    but the use of *library* and *package* is not as strict. e.g. `pandas`, the package
    which provides the `DataFrame` class of objects, is referred to as both a library
    and a package on the `pandas` website itself. This mixture of the terms is common
    among Pythonistas, so if you’re a stickler for names, don’t let it confuse or
    bother you. However, modules are useful to note. A package is a collection of
    modules. This is useful to know since we can load an entire package or just a
    specific module therein. Thus, in general: library > package > module.'
  prefs: []
  type: TYPE_NORMAL
- en: In R, you’d install packages from CRAN with the `install.packages()` function
    from within R itself. In Python, there are two equivalents of CRAN, PyPI (the
    Python Package Installer) for when using vanilla Python and `conda`, for when
    using Anaconda or miniconda (we’ll also see how to install packages in Google
    Colab directly in the online Notebook later on). To install packages from PyPI
    using vanilla Python, you’ll have to execute a command in the terminal. Recall
    that we still have our active terminal window in VS Code open from earlier. Execute
    the command `pip install matplotlib` in the terminal to install the `matplotlib`
    package in your virtual environment, as depicted in [Figure 3-11](#vsc_12). `pip`
    is the package installer for Python and also comes in various versions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/prds_0311.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-11\. Installing a package into a virtual environment using the command
    line.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Packages that you’ll install in practically every virtual environment include
    `numpy`, `pandas`, `matplotlib`, `seaborn` ad `scipy`. You won’t have to install
    all of them all the time since their package dependencies will take care of that.
    If they are already installed pip will tell you and will not install anything
    further. The most common error messages you’ll encounter here are when your package
    version is incompatible with your Python version. For this, you can either use
    a different Python kernel^([7](ch03.xhtml#idm45127453933224)) for your project,
    or specify the exact package version you want to install. Like in R, you just
    need to install the package once, but you’ll need to *import* it every time (i.e.
    *initialize* it) you activate your environment (see above). It seems convenient
    that package installation is done in the terminal, separate from importing in
    the script. You’ve probably see many stray `install.packages()` functions in R
    scripts, which is kind of annoying.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two more important points I want to mention. First, check all the
    packages installed in your environment, and their versions, in the terminal with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, pipe this output to a file called `requirements.txt` by executing the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Other users can now use `requirements.txt` to install all the necessary packages
    by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notebooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’ve followed the tutorial thus far you’re ready to proceed to the third
    question and begin exploring the Python language. Nonetheless, it’s worthwhile
    reviewing Notebooks, so read on. If you had a hard time getting Python set up
    locally, don’t fret! Jupyter Notebooks is where you can take a deep breath, set
    your installation issues aside and jump in afresh.
  prefs: []
  type: TYPE_NORMAL
- en: Jupyter Notebooks are built on the backbone of IPython, which originated in
    2001\. Jupyter, which stands for JUlia, PYThon and R, now accommodates dozens
    of programming languages and can be used in the JupyterLab IDE or straight-up
    Notebooks in Jupyter. Notebooks allow you to write text using markdown, add code
    chunks and see the in-line output. It sounds a lot like R Markdown! Well, yes
    and no. Under the hood an R Markdown is a flat text file that gets rendered as
    an HTML, doc or pdf. Notebooks are exclusively JSON-based HTML and can natively
    handle interactive components. For useRs, this is kind of like an interactive
    R Markdown with a `shiny` run-time by default. This means that you don’t compose
    a Notebook as a flat text file, which is an important distinction when considering
    editing potential.
  prefs: []
  type: TYPE_NORMAL
- en: Coding in Python often consists of pure notebooks. For example, if you venture
    into cloud platforms that work with big data for ML, like AWS Sagemaker, Google
    AI Platform or Azure ML Studio, you’ll start with notebooks. As we’ve already
    seen, they’re supported by VS Code. Other online versions include Kaggle competitions
    and published Jupyter Notebooks. Another variety of online notebooks is found
    in the Google Colab service. This allows you to produce and distribute online
    notebooks with a Python backend and is what we’ll use for exploring notebooks.
  prefs: []
  type: TYPE_NORMAL
- en: To get familiar working with Notebooks, use this online tutorial from Jupyter
    [here](https://jupyter.org/try). Just click on the [Notebook Basics panel](https://notebooks.gesis.org/binder/jupyter/user/ipython-ipython-in-depth-c0k4jcir/notebooks/binder/Index.ipynb)
    and pay particular attention to the keyboard shortcuts.
  prefs: []
  type: TYPE_NORMAL
- en: You you want to follow along, you can find the Google Colab Notebook for this
    chapter [here](https://colab.research.google.com/drive/1qwgMIKc84JCYAj0zJZQSOgVZbk6nI9XX?usp=sharing).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/prds_0312.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-12\. Examples for getting started with Python Notebooks in using Google
    Colab.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: How does Python, the language, compare to R?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By now you should have followed one of two paths. If you have installed Python
    locally, you should have:'
  prefs: []
  type: TYPE_NORMAL
- en: A project directory where you’ll store your data and script files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A virtual environment set up within that directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The typical packages for data science installed in that virtual environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you’ve decided to go the Google Colab route, you should have accessed this
    chapter’s Notebook (see above).
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to start our project by importing the packages we’ll use. Here,
    we’ll see again that there are a variety of ways of doing this, but most are standard.
    Let’s take a look. In the book’s [repository](https://github.com/moderndatadesign/PyR4MDS),
    you’ll find a practice script with the following commands, or you can follow along
    in the Google Colab Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: As we go through these commands we’ll introduce more new terminology — keywords,
    methods & attributes — and discuss what they are in the context of Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can import an entire package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to use functions from the `math` package. The `math` package
    is already installed, so we didn’t need to use `pip`, but we do need to import
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is first time we encounter a common and important aspect of the Python
    language: *keywords*, which behave like R’s reserved word but are more numerous.
    Right now there are 35 keywords in Python that can be placed in distinct groups
    (See Appendix A). Here `import` is an *import keyword*. As a useR accustomed to
    functional programming, you’d use `library(math)` in R. So, in this case, you
    can think of keywords as shortcuts to functions, which in many cases they are.
    That’s just like operators in R (think `<-`, `+`, `==`, `&`, etc.), which are
    just shortcuts to functions under-the-hood. they’re not written in the classic
    function format, but they could be.'
  prefs: []
  type: TYPE_NORMAL
- en: In short, keywords are reserved words that have very specific meanings. In this
    case, `import` stands in for a function to *import* all the functions from the
    `math` package. Many keywords act like this, but not all. We’ll see some examples
    in a second.
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, now that we have the functions from the math package, let’s try
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we see that the `.` has a specific meaning: Inside the `math` package,
    access the `log()` function. The two arguments are the digit and base. So you
    can see why the R Tidyverse tends to use `_` instead of `.` notation and why the
    prevalence of a meaningless `.` in many R functions frustrates many users coming
    from OOP-centric languages.'
  prefs: []
  type: TYPE_NORMAL
- en: Second, we can import an entire package and give it a specific, typically standardized,
    *alias*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s our second keyword, `as`. Notice that it’s not really acting as a stand
    in for a function unless we recall that `<-` is also a function. If we stretch
    our imagination we can imagine this is like the following in R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'UseRs wouldn’t ever do that, but it’s the closest analogous command^([8](ch03.xhtml#idm45127453751608)).
    The `as` keyword is always used with `import` to provide a convenient *alias*
    for accessing a package or module’s functions^([9](ch03.xhtml#idm45127453749672)).
    Thus, it’s an explicit way to call the exact function we want. Execute this function
    to import the data set for future work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `.` again? The above command is equivalent to this command in R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Third, we can import a specific *module* from a package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There’s our third keyword, `from`. It lets us go inside the `scipy` package
    and *import* only the `stats` module.
  prefs: []
  type: TYPE_NORMAL
- en: Fourth, we can import a specific module from a package, also giving it a specific,
    typically standardized, alias.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can also import only a specific function from a package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Import a dataset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Above, we saw how to import a data set using a function from the `pandas` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Examine the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s always good practice to look at our data before we start working on it.
    In R we’d use things like `summary()` and `str()`, or `glimpse()` if we had `dplyr`
    initialized. Let’s see how that works in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What the what?? This is the first time we’ve encountered this nomenclature,
    and there’s that ever-present dot notation again! The functions `info()`, `describe()`
    and `head()` are *methods* of the object `plant_growth`. A method is a function
    that is called by an object. Like other functions we can also provide specific
    arguments, although in these cases we’ll stick with the default.
  prefs: []
  type: TYPE_NORMAL
- en: Note, in particular the output from the `info()` method. Here, we see for the
    first time that indexing begins as 0 in Python, as is the case with many programming
    languages —  and why shouldn’t it!? This is an important aspect of Pythonic programming.
    We’ll see the consequences of this later on when we get to indexing.
  prefs: []
  type: TYPE_NORMAL
- en: The output from `.info()` also tells us that we have a `pandas DataFrame`. We’ll
    explore different object classes soon.
  prefs: []
  type: TYPE_NORMAL
- en: How about looking at the shape (i.e. dimensions) and column names of the `plant_growth`
    object?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we are calling *attributes* of the object, they don’t receive
    any brackets. So here we see that any given object can call permissible methods
    and attributes, according to its class. You’ll know this from R, when the class
    of an object allows it to be used in specific functions for which there are methods
    available for it. Under the hood the same magic is happening. R is function-first,
    OOP-second. It’s there, just we don’t need to worry about it *as much* in functional
    programming. To give you an idea of how this works in R, consider a built-in data
    set, `sunspots`. It’s a `ts` class object (i.e. time-series).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find the methods for the plot function using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There, you’ll see the `plot.ts()` method, which is what is actually called when
    you provide a `ts` class object to the `plot()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you may miss being able to actually *see* that data set like we can
    with the RStudio view option. Not to worry! You can click on the table icon in
    the interactive Python kernel and see everything in your environment. If you click
    on the `DataFrame`, it will open up a view for you to examine it.
  prefs: []
  type: TYPE_NORMAL
- en: Data Structures & Descriptive Statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Alright, now that we’ve come to grips with methods and attributes, let’s take
    a look at how you would generate some descriptive statistics. A `pandas DataFrame`
    is very similar to an R `data.frame` or `tbl`. It’s a 2-dimensional table where
    each column is a `Series`, like how columns are vectors of the same length in
    R data frames. Just like a `DataFrame` itself, a `Series` also has methods and
    attributes. Recall that the `group` column is categorical. By now, this command
    should make sense to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `[]` will be familiar to you from R, they index according to the name of
    a column. The `.` then takes this single column and calls a method, `.value_counts()`,
    which in this case counts the number of observations for each value.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`np` says we’re going to use a function from the `numpy` package we imported
    earlier. Inside that function, we provide numerical values, the `weight` Series
    of the `plant_growth` DataFrame.'
  prefs: []
  type: TYPE_NORMAL
- en: How about some summary statistics. Can you guess what this method will do?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Just like with `dplyr`’s `group_by()` function, the `groupby()` method will
    allow downstream methods to be applied on each subset according to a categorical
    variable, in this case the `group` Series. The `describe()` method will provide
    a suite of summary statistics for each subset.
  prefs: []
  type: TYPE_NORMAL
- en: 'This version is more specific:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can probably guess that the `.agg()` method stands for *aggregate*. Aggregation
    functions return a single value (typically) and in R we’d specify it using the
    `summarise()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The input to the `.agg()` method, `{''weight'':[''mean'',''std'']}`, is a Dictionary
    (class `dict`). You can think of this as a key-value pair, defined here using
    `{}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also have used the `dict()` function for the same purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Dictionaries are data storage objects in their own right, are part of standard
    vanilla Python, and as we see here are used as arguments to input in methods and
    functions. This is similar to how lists in R are used for both data storage and
    as a list of arguments in specific circumstances. Nonetheless, a Dictionary is
    better thought of as an *associative array* since indexing is only by key, and
    not number. I may go so far as to say that a dictionary is even more like an environment
    in R, since that contains many objects but no indexing, but that may be a bit
    of a stretch.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig a bit deeper. The following commands produce the same output, but
    in different formats!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `[[]]` versus `[]`? It recalls a difference that you may have encountered
    in R when working with data frames that are not tibbles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data structures: Back to the basics'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve already seen three common types of data storage objects in Python, `pandas
    DataFrame`, `pandas Series` and `dict`. Only `dict` is from vanilla Python so
    before we more on, I want to look as some of the other basic structures: `lists`,
    `tuples` and `NumPy arrays`. I’m introducing these much later than you’d expect,
    that’s because I wanted to begin with data frames, which are intuitive and frequently
    used. So let’s make sure we have basics covered before we wrap up:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, like in R, you’ll see four key data types in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-3\. Data types in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Name | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | Binary | `True` and `False` |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | Integer numbers | 7,9,2,-4 |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | Real numbers | 3.14, 2.78, 6.45 |'
  prefs: []
  type: TYPE_TB
- en: '| `str` | String | All Alphanumeric and special characters |'
  prefs: []
  type: TYPE_TB
- en: 'Next, you’ll encounter lists, one-dimensional objects. Unlike vectors in R,
    each element can be a different object, e.g. another 1 dimensional list. Here’s
    are two simple lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `[]` define a list. We actually already saw that when we defined
    the `dict` earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: So both `[]` and `{}` alone are valid in Python and behave differently than
    in R. But remember, we did use `[]` earlier to index the data frame, which is
    very similar to R.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have tuples, which are like lists, except they are immutable, i.e.
    unchangeable, they are defined by `()`, as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'A common use of tuples is when a function returns multiple values. As an example,
    the `divmod()` function returns the result of integer division and modulus of
    two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a tuple, but we can *unpack* the tuple and assign each output
    to a separate object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: That’s really convenient when defining custom functions. The equivalent in R
    would be to save the output to a list.
  prefs: []
  type: TYPE_NORMAL
- en: Astute useRs may be familiar with the multiple assign operator, `%<-%` introduced
    by the `zeallot` package and popularized by the `keras`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last data structure I want to mention is the NumPy array. This is very
    similar to a 1-dimensional list, but allows for vectorization, among other things.
    e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s very different from a useR would expect. If we were working on an NumPy
    array, we’d be back in familiar territory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Indexing and Logical Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a variety of objects, lets look at how to index them. We already
    saw that we can use `[]` and even `[[]]` as we see in R, but there are a couple
    interesting differences. Remember that indexing always begins at 0 in Python!
    Also, notice that one of the most common operators in R, `:` make a reappearance
    in Python, but in a slightly different form, here it’s `[start:end]`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `:` operator doesn’t need a left and right-hand side. If one side is empty
    the index begins or proceeds to the end. The start in *inclusive* and the end,
    if specified, is *exclusive*. Thus `:2` takes index 0 & 1, `1:` takes index 1
    up to the last element, which is unspecified and thus inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: For 2-dimensional data frames, we encounter the pandas `.iloc`, “index location”
    and `.loc` “location” methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: For the `.loc()`, we can introduce logical expressions, i.e. combinations of
    relational and logical operators to ask and combine `True`/`False` questions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: For more detail on indexing and logical expressions, see the notes in the appendix.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alright, let’s take a look at some data visualization of weight described by
    group. Here, we have a box plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Just the points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And just the means with their standard deviations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Notice that I’m using the `seaborn` package (alias `sns`) for data visualizations
    and then using `show()` function from `matplotlib` to print the visualization
    to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Inferential statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this dataset, we have a specific set-up in that we have three groups and
    we’re interested in two specific two-group comparisons. We can accomplish this
    by establishing a linear model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get the coefficients of the model directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s take a look at a summary of our model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright, let’s wrap this up by using a typical statistical test for this type
    of data: a 1-way ANOVA. Notice that we’re using our model, `results`, that we
    fitted above.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to do all pair-wise comparisons, we can turn to Tukey’s Honestly
    Significant Differences (HSD) post-hoc test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In this instance, we’re starting with the `statsmodel` library, taking the `stats`
    package and the `multicomp` module therein and extracting *from* that only the
    specific `pairwise_tukeyhsd()` function to *import*. In the second line we execute
    the function with a continuous variable as the first argument and the grouping
    variable as the second argument.
  prefs: []
  type: TYPE_NORMAL
- en: Final thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In R, there has been a convergence on common practices and workflows since circa
    2016\. In Python, there is a lot more diversity in how to get up and running right
    from the word go. This diversity may seem daunting but it’s just a reflection
    of Python’s origin story and use cases in the real-world.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re a useR accustomed to the world of functional programming, wrapping
    your head around OOP methods can also seem pretty daunting, but once you get over
    that hurdle you can start exploiting the power of Python where it truly shines,
    the topic of [Part III](part03.xhtml#p03).
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch03.xhtml#idm45127457573352-marker)) Indeed, the other builds are seldom
    mentioned in proper company
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch03.xhtml#idm45127455968680-marker)) You’ll need to install [homebrew](https://brew.sh/)
    if you want to go that route for macOS.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch03.xhtml#idm45127456453464-marker)) You’ll need a Google account to
    access this free resource.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch03.xhtml#idm45127454706696-marker)) Again, although R is supported,
    useRs seldom work in VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch03.xhtml#idm45127457567032-marker)) Well, we’re in *somebody’s* hands,
    at least!
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch03.xhtml#idm45127457564296-marker)) Astute userRs may have noticed that
    a Command Palette, invoked with the same keyboard shortcuts, was added to RStudio
    v1.4 in late 2020.
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch03.xhtml#idm45127453933224-marker)) The Python execution backend.
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch03.xhtml#idm45127453751608-marker)) But remember this for when we start
    using Python & R together, because we’ll see something very similar.
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch03.xhtml#idm45127453749672-marker)) Referring back to `log()`, you’re
    more likely to use `np.log()` instead of `math.log()` since it accepts a wider
    variety of input types.
  prefs: []
  type: TYPE_NORMAL
