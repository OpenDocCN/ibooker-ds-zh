- en: Chapter 11\. The Python Package Tracker
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 第 11 章\. Python 包追踪器
- en: In this chapter, we will create a typical business application that downloads
    data from the internet and stores it in a database before visualizing it in Excel.
    This will help you understand what role xlwings plays in such an application and
    allows you to see how easy it is to connect to external systems with Python. In
    an attempt to build a project that is close to a real-world application yet relatively
    simple to follow, I have come up with the Python Package Tracker, an Excel tool
    that shows the number of releases per year for a given Python package. Despite
    being a case study, you might actually find the tool useful to understand if a
    certain Python package is being actively developed or not.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个典型的业务应用程序，该应用程序从互联网上下载数据并将其存储在数据库中，然后在 Excel 中进行可视化。这将帮助您理解 xlwings
    在这种应用程序中的作用，并演示使用 Python 连接外部系统的简易性。为了尝试构建一个接近真实应用程序但相对简单易懂的项目，我想出了 Python 包追踪器，这是一个
    Excel 工具，显示给定 Python 包每年发布次数。尽管是案例研究，您实际上可能会发现该工具有助于了解特定 Python 包是否正在积极开发中。
- en: 'After getting acquainted with the application, we’ll go through a few topics
    that we need to understand to be able to follow its code: we’ll see how we can
    download data from the internet and how we can interact with databases before
    we learn about exception handling in Python, an important concept when it comes
    to application development. Once we’re done with these preliminaries, we’ll go
    through the components of the Python Package Tracker to see how everything fits
    together. To wrap this chapter up, we’ll look into how debugging xlwings code
    works. Like the last two chapters, this chapter requires you to have an installation
    of Microsoft Excel on either Windows or macOS. Let’s get started by taking the
    Python Package Tracker for a test drive!'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉了应用程序之后，我们将讨论几个需要理解的主题，以便能够跟进其代码：我们将看到如何从互联网上下载数据，以及如何与数据库交互，然后我们将学习 Python
    中的异常处理，这是应用程序开发中的重要概念。完成这些前提后，我们将查看 Python 包追踪器的组件，了解所有内容如何相互关联。最后，我们将探讨如何调试 xlwings
    代码的工作方式。与前两章一样，本章要求您在 Windows 或 macOS 上安装 Microsoft Excel。让我们开始使用 Python 包追踪器进行测试吧！
- en: What We Will Build
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建什么
- en: 'Head over to the companion repository, where you will find the packagetracker
    folder. There are a couple of files in that folder, but for now just open the
    Excel file packagetracker.xlsm and head over to the Database sheet: we first need
    to get some data into the database to have something to work with. As shown in
    [Figure 11-1](#filepos1490382), type in a package name, for example “xlwings,”
    then click on Add Package. You can choose any package name that exists on the
    [Python Package Index](https://pypi.org) (PyPI).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 转到配套代码库，您将找到 packagetracker 文件夹。该文件夹中有一些文件，但现在只需打开 Excel 文件 packagetracker.xlsm
    并转到数据库表：我们首先需要将一些数据输入数据库，以便有东西可以操作。如图 [Figure 11-1](#filepos1490382) 所示，输入一个包名称，例如“xlwings”，然后点击“添加包”。您可以选择任何存在于
    [Python 包索引](https://pypi.org)（PyPI）上的包名称。
- en: 'MACOS: CONFIRM ACCESS TO FOLDER'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: MACOS：确认对文件夹的访问权限
- en: When you add the very first package on macOS, you will have to confirm a pop-up
    so that the application can access the packagetracker folder. This is the same
    pop-up we already came across in [Chapter 9](index_split_024.html#filepos1235764).
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当您在 macOS 上添加第一个包时，您需要确认一个弹出窗口，以便应用程序可以访问 packagetracker 文件夹。这与我们在 [第 9 章](index_split_024.html#filepos1235764)
    中遇到的弹出窗口相同。
- en: '![](images/00051.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00051.jpg)'
- en: Figure 11-1\. The Python Package Tracker (Database sheet)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-1\. Python 包追踪器（数据库表）
- en: If everything works according to plan, you will see the message “Added xlwings
    successfully” to the right of where you typed in the package name. Also, you will
    see a Last updated timestamp under the Update Database section as well as an updated
    Log section where it says that it downloaded xlwings successfully and stored it
    to the database. Let’s do this one more time and add the pandas package so we
    have some more data to play around with. Now, switch to the Tracker sheet and
    select xlwings from the dropdown in cell B5 before clicking on Show History. Your
    screen should now look similar to [Figure 11-2](#filepos1491484), showing the
    latest release of the package as well as a chart with the number of releases over
    the years.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按计划进行，您将在输入包名称的右侧看到消息“成功添加了 xlwings”。此外，在“更新数据库”部分下，您还将看到最后更新的时间戳，以及更新的日志部分，显示已成功下载
    xlwings 并将其存储到数据库中。让我们再做一次，添加 pandas 包，这样我们就有更多的数据可以玩耍了。现在，切换到“Tracker”工作表，在单元格
    B5 的下拉菜单中选择 xlwings，然后点击“显示历史记录”。您的屏幕现在应该类似于[图 11-2](#filepos1491484)，显示了包的最新版本以及多年来发布次数的图表。
- en: '![](images/00068.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00068.jpg)'
- en: Figure 11-2\. The Python Package Tracker (Tracker sheet)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-2\. Python 包追踪器（Tracker 工作表）
- en: 'You could now go back to the Database sheet and add additional packages. Whenever
    you want to update the database with the latest information from PyPI, click on
    the Update Database button: this will synchronize your database with the latest
    data from PyPI.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以返回到“数据库”工作表，并添加其他包。每当您想要从 PyPI 更新数据库中的最新信息时，请点击“更新数据库”按钮：这将使您的数据库与来自 PyPI
    的最新数据同步。
- en: After taking a look at how the Python Package Tracker works from a user’s perspective,
    let’s now introduce its core functionality.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在从用户角度了解 Python 包追踪器的工作方式之后，现在让我们介绍其核心功能。
- en: Core Functionality
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 核心功能
- en: 'In this section, I will introduce you to the core functionality of the Python
    Package Tracker: how to fetch data via web APIs and how to query databases. I’ll
    also show you how to handle exceptions, a topic that will inevitably arise when
    writing application code. Let’s get started with web APIs!'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您介绍 Python 包追踪器的核心功能：如何通过 Web API 获取数据以及如何查询数据库。我还将向您展示如何处理异常，这是在编写应用程序代码时不可避免的主题。让我们从
    Web API 开始吧！
- en: Web APIs
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Web API
- en: 'Web APIs are one of the most popular ways for an application to fetch data
    from the internet: API stands for application programming interface and defines
    how you interact with an application programmatically. A web API, therefore, is
    an API that is accessed over a network, usually the internet. To understand how
    web APIs work, let’s take a step back and see what happens (in simplified terms)
    when you open a web page in your browser: after entering a URL into the address
    bar, your browser sends a GET request to the server, asking for the web page you
    want. A GET request is a method of the HTTP protocol that your browser uses to
    communicate with the server. When the server receives the request, it responds
    by sending back the requested HTML document, which your browser displays: voilà,
    your web page has loaded. The HTTP protocol has various other methods; the most
    common one—apart from the GET request—is the POST request, which is used to send
    data to the server (for example, when you fill in a contact form on a web page).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Web API 是应用程序从互联网获取数据的最流行方式之一：API 代表应用程序编程接口，并定义了如何以编程方式与应用程序进行交互。因此，Web API
    是通过网络访问的 API，通常是互联网。为了了解 Web API 的工作原理，让我们退后一步，看看当您在浏览器中打开网页时（简化说），会发生什么：在地址栏中输入
    URL 后，浏览器向服务器发送 GET 请求，请求您想要的网页。GET 请求是 HTTP 协议的一种方法，您的浏览器用它来与服务器通信。当服务器收到请求时，它会通过发送请求的
    HTML 文档作出响应，您的浏览器则显示该文档：您的网页已加载完成。HTTP 协议还有各种其他方法；除了 GET 请求之外，最常见的方法是 POST 请求，用于将数据发送到服务器（例如，当您在网页上填写联系表单时）。
- en: 'While it makes sense for servers to send back a nicely formatted HTML page
    to interact with humans, applications don’t care about design and are only interested
    in the data. Therefore, a GET request to a web API works like requesting a web
    page, but you usually get back the data in JSON instead of HTML format. JSON stands
    for JavaScript Object Notation and is a data structure that is understood by pretty
    much every programming language, which makes it ideal to exchange data between
    different systems. Although the notation is using JavaScript syntax, it’s very
    close to how you use (nested) dictionaries and lists in Python. The differences
    are the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器向人类发送精美格式的HTML页面以进行交互是有意义的，但应用程序不关心设计，只关心数据。因此，对web API的GET请求类似于请求网页，但通常会以JSON格式而不是HTML格式返回数据。JSON代表JavaScript对象表示法，是一种几乎所有编程语言都能理解的数据结构，这使其成为在不同系统之间交换数据的理想选择。尽管其符号使用JavaScript语法，但它与Python中使用（嵌套）字典和列表的方式非常接近。它们的区别如下：
- en: JSON only accepts double quotes for strings
  id: totrans-19
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JSON只接受双引号作为字符串的引号符号
- en: JSON uses `null` where Python uses `None`
  id: totrans-20
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JSON中使用`null`表示Python中的`None`
- en: JSON uses lowercase `true` and `false` while they are capitalized in Python
  id: totrans-21
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JSON中使用小写的`true`和`false`，而Python中使用大写
- en: JSON only accepts strings as keys whereas Python dictionaries accept a wide
    range of objects as keys
  id: totrans-22
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JSON只接受字符串作为键，而Python字典可以接受广泛的对象作为键
- en: 'The `json` module from the standard library allows you to convert a Python
    dictionary to a JSON string and vice versa:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的`json`模块允许你将Python字典转换为JSON字符串，反之亦然：
- en: '`In``[``1``]:``import``json`'
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``1``]:``import``json`'
- en: '`In``[``2``]:``# A Python dictionary...``user_dict``=``{``"name"``:``"Jane
    Doe"``,``"age"``:``23``,``"married"``:``False``,``"children"``:``None``,``"hobbies"``:``[``"hiking"``,``"reading"``]}`'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``2``]:``# 一个Python字典...``user_dict``=``{``"name"``:``"Jane Doe"``,``"age"``:``23``,``"married"``:``False``,``"children"``:``None``,``"hobbies"``:``[``"hiking"``,``"reading"``]}`'
- en: '`In``[``3``]:``# ...converted to a JSON string``# by json.dumps ("dump string").
    The "indent" parameter is``# optional and prettifies the printing.``user_json``=``json``.``dumps``(``user_dict``,``indent``=``4``)``print``(``user_json``)`'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``3``]:``# ...通过json.dumps（“dump string”）转换为JSON字符串。 “indent”参数是可选的，可以美化打印。``user_json``=``json``.``dumps``(``user_dict``,``indent``=``4``)``print``(``user_json``)`'
- en: '`{     "name": "Jane Doe",     "age": 23,     "married": false,     "children":
    null,     "hobbies": [         "hiking",         "reading"     ] }`'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`{     "name": "Jane Doe",     "age": 23,     "married": false,     "children":
    null,     "hobbies": [         "hiking",         "reading"     ] }`'
- en: '`In``[``4``]:``# Convert the JSON string back to a native Python data structure``json``.``loads``(``user_json``)`'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``4``]:``# 将JSON字符串转换回本地Python数据结构``json``.``loads``(``user_json``)`'
- en: '`Out[4]: {''name'': ''Jane Doe'',          ''age'': 23,          ''married'':
    False,          ''children'': None,          ''hobbies'': [''hiking'', ''reading'']}`'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[4]: {''name'': ''Jane Doe'',          ''age'': 23,          ''married'':
    False,          ''children'': None,          ''hobbies'': [''hiking'', ''reading'']}`'
- en: REST API
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: REST API
- en: Instead of web API, you will often see the term REST or RESTful API. REST stands
    for representational state transfer and defines a web API that adheres to certain
    constraints. At its core, the idea of REST is that you access information in the
    form of stateless resources. Stateless means that every request to a REST API
    is completely independent of any other request and needs to always provide the
    full set of information that it requests. Note that the term REST API is often
    misused to mean any sort of web API, even if it doesn’t adhere to the REST constraints.
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通常不是web API，你会经常看到术语REST或RESTful API。REST代表表述性状态传递，并定义了遵循特定约束的web API。其核心思想是通过无状态资源访问信息。无状态意味着对REST
    API的每个请求都完全独立于任何其他请求，并且始终需要提供其请求的完整信息集。请注意，术语REST API经常被误用来表示任何类型的web API，即使它不遵循REST约束。
- en: 'Consuming web APIs is usually really simple (we’ll see how this works with
    Python in a moment), and almost every service offers one. If you want to download
    your favorite Spotify playlist, you would issue the following GET request (see
    the [Spotify Web API Reference](https://oreil.ly/zcyUh)):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用web API通常非常简单（我们稍后将看到如何在Python中使用），几乎每个服务都提供这样的接口。如果你想下载你最喜爱的Spotify播放列表，你可以发出以下GET请求（参见[Spotify
    Web API Reference](https://oreil.ly/zcyUh)）：
- en: '`GET https://api.spotify.com/v1/playlists/``playlist_id`'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`GET https://api.spotify.com/v1/playlists/``playlist_id`'
- en: 'Or, if you want to get information about your latest Uber trips, you would
    run the following GET request (see the [Uber REST API](https://oreil.ly/FTp-Y)):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你想获取关于你最新Uber行程的信息，你可以执行以下GET请求（参见[Uber REST API](https://oreil.ly/FTp-Y)）：
- en: '`GET https://api.uber.com/v1.2/history`'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`GET https://api.uber.com/v1.2/history`'
- en: 'To use these APIs, though, you need to be authenticated, which usually means
    that you require an account and a token that you can send along with your requests.
    For the Python Package Tracker, we’ll need to fetch data from PyPI to get information
    about the releases of a specific package. Fortunately, PyPI’s web API doesn’t
    require any authentication, so we have one thing less to worry about. When you
    have a look at the [PyPI JSON API docs](https://oreil.ly/yTVjL), you will see
    that there are only two endpoints, i.e., URL fragments that are appended to the
    common base URL, [https://pypi.org/pypi](https://pypi.org/pypi):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然要使用这些 API，您需要进行身份验证，通常意味着您需要一个帐户和一个令牌，可以将其与您的请求一起发送。对于 Python Package Tracker，我们需要从
    PyPI 获取数据，以获取有关特定软件包发布的信息。幸运的是，PyPI 的 Web API 不需要任何身份验证，所以我们少了一件事情需要担心。当您查看 [PyPI
    JSON API 文档](https://oreil.ly/yTVjL) 时，您会发现只有两个端点，即追加到常见基础 URL [https://pypi.org/pypi](https://pypi.org/pypi)
    的 URL 片段：
- en: '`GET /``project_name``/json GET /``project_name``/``version``/json`'
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`GET /``project_name``/json GET /``project_name``/``version``/json'
- en: 'The second endpoint gives you the same information as the first one, but for
    a specific version only. For the Python Package Tracker, the first endpoint is
    all we need to get the details about the past releases of a package, so let’s
    see how this works. In Python, a simple way to interact with a web API is by using
    the Requests package that comes preinstalled with Anaconda. Run the following
    commands to fetch PyPI data about pandas:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个端点为您提供与第一个相同的信息，但仅适用于特定版本。对于 Python Package Tracker，第一个端点就足以获取有关软件包过去发布的详细信息，让我们看看这是如何工作的。在
    Python 中，与 Web API 交互的简单方法是使用预安装在 Anaconda 中的 Requests 包。运行以下命令以获取有关 pandas 的
    PyPI 数据：
- en: '`In``[``5``]:``import``requests`'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``5``]:``import``requests`'
- en: '`In``[``6``]:``response``=``requests``.``get``(``"https://pypi.org/pypi/pandas/json"``)``response``.``status_code`'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``6``]:``response``=``requests``.``get``(``"https://pypi.org/pypi/pandas/json"``)``response``.``status_code`'
- en: '`Out[6]: 200`'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[6]: 200`'
- en: 'Every response comes with an HTTP status code: for example, `200` means OK
    and `404` means Not Found. You can look up the full list of HTTP response status
    codes in the [Mozilla web docs](https://oreil.ly/HySVq). You may be familiar with
    the status code `404` as your browser sometimes displays it when you click on
    a dead link or type in an address that doesn’t exist. Similarly, you will also
    get a `404` status code if you run a GET request with a package name that doesn’t
    exist on PyPI. To look at the content of the response, it’s easiest to call the
    `json` method of the response object, which will transform the JSON string of
    the response into a Python dictionary:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每个响应都带有 HTTP 状态码：例如，`200` 表示 OK，`404` 表示未找到。您可以在 [Mozilla Web 文档](https://oreil.ly/HySVq)
    中查找完整的 HTTP 响应状态代码列表。您可能熟悉状态码 `404`，因为有时您的浏览器在单击无效链接或键入不存在的地址时会显示它。类似地，如果您使用不存在于
    PyPI 上的软件包名称运行 GET 请求，您也将收到 `404` 状态码。要查看响应的内容，最简单的方法是调用响应对象的 `json` 方法，它将把响应的
    JSON 字符串转换为 Python 字典：
- en: '`In``[``7``]:``response``.``json``()`'
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``7``]:``response``.``json``()`'
- en: 'The response is very long, so I am printing a short subset here to allow you
    to understand the structure:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '-   响应非常长，因此我只打印了一小部分以便您了解结构：'
- en: '`Out[7]: {             ''info'': {                 ''bugtrack_url'': None,
                    ''license'': ''BSD'',                 ''maintainer'': ''The PyData
    Development Team'',                 ''maintainer_email'': ''pydata@googlegroups.com'',
                    ''name'': ''pandas''             },             ''releases'':
    {                 ''0.1'': [                     {                         ''filename'':
    ''pandas-0.1.tar.gz'',                         ''size'': 238458,                        
    ''upload_time'': ''2009-12-25T23:58:31''                     },                    
    {                         ''filename'': ''pandas-0.1.win32-py2.5.exe'',                        
    ''size'': 313639,                         ''upload_time'': ''2009-12-26T17:14:35''
                        }                 ]             }         }`'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[7]: {             ''info'': {                 ''bugtrack_url'': None,
                    ''license'': ''BSD'',                 ''maintainer'': ''The PyData
    Development Team'',                 ''maintainer_email'': ''pydata@googlegroups.com'',
                    ''name'': ''pandas''             },             ''releases'':
    {                 ''0.1'': [                     {                         ''filename'':
    ''pandas-0.1.tar.gz'',                         ''size'': 238458,                        
    ''upload_time'': ''2009-12-25T23:58:31''                     },                    
    {                         ''filename'': ''pandas-0.1.win32-py2.5.exe'',                        
    ''size'': 313639,                         ''upload_time'': ''2009-12-26T17:14:35''
                        }                 ]             }         }`'
- en: 'To get a list with all releases and their dates, something we need for the
    Python Package Tracker, we can run the following code to loop through the `releases`
    dictionary:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有发布和它们的日期列表，这是Python包追踪器所需的内容，我们可以运行以下代码来遍历`releases`字典：
- en: '`In``[``8``]:``releases``=``[]``for``version``,``files``in``response``.``json``()[``''releases''``]``.``items``():``releases``.``append``(``f``"{version}:
    {files[0][''upload_time'']}"``)``releases``[:``3``]``# show the first 3 elements
    of the list`'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``8``]:``releases``=``[]``for``version``,``files``in``response``.``json``()[``''releases''``]``.``items``():``releases``.``append``(``f``"{version}:
    {files[0][''upload_time'']}"``)``releases``[:``3``]``# 显示列表的前3个元素`'
- en: '`Out[8]: [''0.1: 2009-12-25T23:58:31'',          ''0.10.0: 2012-12-17T16:52:06'',
             ''0.10.1: 2013-01-22T05:22:09'']`'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[8]: [''0.1: 2009-12-25T23:58:31'',          ''0.10.0: 2012-12-17T16:52:06'',
             ''0.10.1: 2013-01-22T05:22:09'']`'
- en: Note that we are arbitrarily picking the release timestamp from the package
    that appears first in the list. A specific release often has multiple packages
    to account for different versions of Python and operating systems. To wrap this
    topic up, you may remember from [Chapter 5](index_split_015.html#filepos482650)
    that pandas has a `read_json` method to return a DataFrame directly from a JSON
    string. This, however, wouldn’t help us here as the response from PyPI isn’t in
    a structure that can be directly transformed into a DataFrame.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们是从列表中首先出现的包中随意选择发布时间戳。一个特定的发布版本通常有多个包，以适应不同版本的Python和操作系统。总结这个话题时，您可能会记得第[5章](index_split_015.html#filepos482650)中提到pandas具有一个`read_json`方法，可以直接从JSON字符串返回DataFrame。然而，在这里它对我们没有帮助，因为PyPI的响应不是一个可以直接转换为DataFrame的结构。
- en: This was a short introduction to web APIs to understand their use in the code
    base of the Python Package Tracker. Let’s now see how we can communicate with
    databases, the other external system that we make use of in our application!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于Web API的简短介绍，以便理解它们在Python包追踪器的代码库中的使用。现在让我们看看如何与数据库进行通信，这是我们应用程序中使用的另一个外部系统！
- en: Databases
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库
- en: 'To be able to use the data from PyPI even when you’re not connected to the
    internet, you need to store it after downloading. While you could store your JSON
    responses as text files on disk, a far more comfortable solution is to use a database:
    this allows you to query your data in an easy way. The Python Package Tracker
    is using [SQLite](https://sqlite.org), a relational database. Relational database
    systems get their name from relation, which refers to the database table itself
    (and not to the relation between tables, which is a common misconception): their
    highest goal is data integrity, which they achieve by splitting the data up into
    different tables (a process called normalization) and by applying constraints
    to avoid inconsistent and redundant data. Relational databases use SQL (Structured
    Query Language) to perform database queries and are among the most popular server-based
    relational database systems are [SQL Server](https://oreil.ly/XZOI9), [Oracle](https://oreil.ly/VKWE0),
    [PostgreSQL](https://oreil.ly/VAEqY), and [MySQL](https://mysql.com). As an Excel
    user, you may also be familiar with the file-based [Microsoft Access](https://oreil.ly/bRh6Q)
    database.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在没有连接到互联网时，也可以使用PyPI数据，您需要在下载后进行存储才能使用。虽然您可以将JSON响应存储为磁盘上的文本文件，但更舒适的解决方案是使用数据库：这使您可以轻松地查询数据。Python包追踪器正在使用[SQLite](https://sqlite.org)，一个关系数据库。关系数据库系统得名于关系，它指的是数据库表本身（而不是表之间的关系，这是一个常见的误解）：它们的最高目标是数据完整性，通过将数据分割成不同的表（这个过程称为规范化）并应用约束条件来避免不一致和冗余数据。关系数据库使用SQL（结构化查询语言）执行数据库查询，并且是最受欢迎的基于服务器的关系数据库系统之一有[SQL
    Server](https://oreil.ly/XZOI9)，[Oracle](https://oreil.ly/VKWE0)，[PostgreSQL](https://oreil.ly/VAEqY)和[MySQL](https://mysql.com)。作为Excel用户，您可能也熟悉基于文件的[Microsoft
    Access](https://oreil.ly/bRh6Q)数据库。
- en: NOSQL DATABASES
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: NOSQL数据库
- en: 'These days, relational databases have strong competition from NoSQL databases
    that store redundant data in an attempt to achieve the following advantages:'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如今，关系数据库面临着来自NoSQL数据库的强大竞争，后者存储冗余数据以实现以下优势：
- en: No table joins
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无需表联接
- en: Since relational databases split their data across multiple tables, you often
    need to combine the information from two or more tables by joining them, which
    sometimes can be slow. This is not required with NoSQL databases, which can result
    in better performance for certain types of queries.
  id: totrans-56
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于关系数据库将它们的数据分布在多个表中，您通常需要通过联接这些表来合并两个或多个表中的信息，这可能会导致速度较慢。对于NoSQL数据库来说这不是必需的，它可以在某些类型的查询中实现更好的性能。
- en: No database migrations
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无数据库迁移
- en: With relational database systems, every time you make a change to the table
    structure, e.g., by adding a new column to a table, you must run a database migration.
    A migration is a script that brings the database into the desired new structure.
    This makes the deployment of new versions of an application more complex, potentially
    resulting in downtime, something that is easier to avoid with NoSQL databases.
  id: totrans-58
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于关系型数据库系统，每次对表结构进行更改（例如向表添加新列），都必须运行数据库迁移。迁移是将数据库带入所需新结构的脚本。这使得应用程序的新版本部署更加复杂，可能导致停机，这是使用
    NoSQL 数据库更容易避免的。
- en: Easier to scale
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 更易于扩展
- en: NoSQL databases are easier to distribute across multiple servers as there are
    no tables that are dependent on each other. This means that an application that
    uses a NoSQL database may scale better when your user base skyrockets.
  id: totrans-60
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: NoSQL 数据库更容易在多个服务器上分发，因为没有依赖于彼此的表。这意味着使用 NoSQL 数据库的应用程序在用户基数激增时可能更好地扩展。
- en: 'NoSQL databases come in many flavors: some databases are simple key-value stores,
    i.e., work similarly to a dictionary in Python (e.g., [Redis](https://redis.io));
    others allow the storage of documents, often in JSON format (e.g., [MongoDB](https://mongodb.com)).
    Some databases even combine the relational and NoSQL worlds: PostgreSQL, which
    happens to be one of the most popular databases in the Python community, is traditionally
    a relational database but also allows you to store data in JSON format—without
    losing the ability to query it via SQL.'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: NoSQL 数据库有多种类型：有些数据库是简单的键值存储，即类似于 Python 中的字典（例如，[Redis](https://redis.io)）；其他允许以文档形式存储数据，通常以
    JSON 格式（例如，[MongoDB](https://mongodb.com)）。一些数据库甚至结合了关系型和 NoSQL 的特性：PostgreSQL
    是 Python 社区中最流行的数据库之一，传统上是关系型数据库，但也允许您以 JSON 格式存储数据——而不会失去通过 SQL 查询的能力。
- en: SQLite, the database we’re going to use, is a file-based database like Microsoft
    Access. However, in contrast to Microsoft Access, which only works on Windows,
    SQLite works on all platforms that Python supports. On the other hand, SQLite
    doesn’t allow you to build a user interface like Microsoft Access, but Excel comes
    in handy for this part.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 是我们将要使用的数据库，类似于 Microsoft Access 的基于文件的数据库。不过，与仅在 Windows 上运行的 Microsoft
    Access 不同，SQLite 可以在 Python 支持的所有平台上运行。另一方面，SQLite 不允许您构建像 Microsoft Access 那样的用户界面，但是
    Excel 在此部分非常方便。
- en: Let’s now have a look at the structure of the Package Tracker’s database before
    finding out how we can use Python to connect to databases and make SQL queries.
    Then, to conclude this introduction about databases, we’ll have a look at SQL
    injections, a popular vulnerability of database-driven applications.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看在找出如何使用 Python 连接到数据库并进行 SQL 查询之前，Package Tracker 数据库的结构。接下来，我们将看一下数据库驱动应用程序的一个流行漏洞——SQL
    注入，来结束这篇关于数据库的介绍。
- en: The Package Tracker database
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Package Tracker 数据库
- en: 'The database of the Python Package Tracker couldn’t be any simpler as it only
    has two tables: the table `packages` stores the package name and the table `package_versions`
    stores the version strings and the date of the upload. The two tables can be joined
    on the `package_id`: rather than storing the `package_name` with every row in
    the `package_versions` table, it has been normalized into the `packages` table.
    This gets rid of redundant data—name changes, for example, only have to be done
    in a single field across the entire database. To get a better idea about how the
    database looks with the xlwings and pandas packages loaded, have a look at Tables
    [11-1](#filepos1521167) and [11-2](#filepos1522247).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Python Package Tracker 的数据库非常简单，只有两张表：`packages` 表存储包名，`package_versions` 表存储版本字符串和上传日期。这两张表可以通过
    `package_id` 进行连接：`package_versions` 表中不再重复存储 `package_name`，而是通过归一化存储在 `packages`
    表中。这样消除了冗余数据——例如，只需在整个数据库中的一个字段中执行名称更改。如果想更深入了解带有 xlwings 和 pandas 包加载的数据库结构，请参考表
    [11-1](#filepos1521167) 和 [11-2](#filepos1522247)。
- en: Table 11-1\. The packages table
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-1\. packages 表
- en: '|  package_id  |  package_name  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|  package_id  |  package_name  |'
- en: '|   `1` |   `xlwings` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|   `1` |   `xlwings` |'
- en: '|   `2` |   `pandas` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|   `2` |   `pandas` |'
- en: Table 11-2\. The package_versions table (first three rows of each package_id)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-2\. package_versions 表（每个 package_id 的前三行）
- en: '|  package_id  |  version_string  |  uploaded_at  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|  package_id  |  version_string  |  uploaded_at  |'
- en: '|   `1` |   `0.1.0` |   `2014-03-19 18:18:49.000000` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|   `1` |   `0.1.0` |   `2014-03-19 18:18:49.000000` |'
- en: '|   `1` |   `0.1.1` |   `2014-06-27 16:26:36.000000` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|   `1` |   `0.1.1` |   `2014-06-27 16:26:36.000000` |'
- en: '|   `1` |   `0.2.0` |   `2014-07-29 17:14:22.000000` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|   `1` |   `0.2.0` |   `2014-07-29 17:14:22.000000` |'
- en: '|   `...` |   `...` |   `...` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|   `...` |   `...` |   `...` |'
- en: '|   `2` |   `0.1` |   `2009-12-25 23:58:31.000000` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|   `2` |   `0.1` |   `2009-12-25 23:58:31.000000` |'
- en: '|   `2` |   `0.2beta` |   `2010-05-18 15:05:11.000000` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|   `2` |   `0.2beta` |   `2010-05-18 15:05:11.000000` |'
- en: '|   `2` |   `0.2b1` |   `2010-05-18 15:09:05.000000` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|   `2` |   `0.2b1` |   `2010-05-18 15:09:05.000000` |'
- en: '|   `...` |   `...` |   `...` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|   `...` |   `...` |   `...` |'
- en: '[Figure 11-3](#filepos1528772) is a database diagram that shows the two tables
    again schematically. You can read off the table and column names and get information
    about the primary and foreign keys:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-3](#filepos1528772) 是一个数据库图示，再次以示意方式显示了两个表。你可以查阅表和列名，并获取有关主键和外键的信息：'
- en: Primary key
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 主键
- en: Relational databases require every table to have a primary key. A primary key
    is one or more columns that uniquely identify a row (a row is also called a record).
    In the case of the `packages` table, the primary key is `package_id` and in the
    case of the `package_versions` table, the primary key is a so-called composite
    key, i.e., a combination of `package_id` and `version_string`.
  id: totrans-82
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关系数据库要求每个表都有一个主键。主键是唯一标识行（行也称为记录）的一个或多个列。在 `packages` 表中，主键是 `package_id`；在
    `package_versions` 表中，主键是所谓的复合键，即 `package_id` 和 `version_string` 的组合。
- en: Foreign key
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 外键
- en: 'The column `package_id` in the `package_versions` table is a foreign key to
    the same column in the `packages` table, symbolized by the line that connects
    the tables: a foreign key is a constraint that, in our case, ensures that every
    `package_id` in the `package_versions` table exists in the `packages` table—this
    guarantees data integrity. The branches at the right end of the connection line
    symbolize the nature of the relationship: one `package` can have many `package_versions`,
    which is called a one-to-many relationship.'
  id: totrans-84
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`package_versions` 表中的 `package_id` 列是对 `packages` 表中同一列的外键，由连接表的线条来象征：外键是一个约束条件，在我们的情况下，确保
    `package_versions` 表中的每个 `package_id` 都存在于 `packages` 表中——这保证了数据的完整性。连接线的右端分支象征着关系的性质：一个
    `package` 可以有多个 `package_versions`，这被称为一对多关系。'
- en: '![](images/00041.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00041.jpg)'
- en: Figure 11-3\. Database diagram (primary keys are bold)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-3\. 数据库图示（主键用粗体表示）
- en: To have a look at the content of the database tables and run SQL queries, you
    could install a VS Code extension called SQLite (please see the [SQLite extension
    docs](https://oreil.ly/nP4mC) for more details) or use a dedicated SQLite management
    software, of which there are plenty. We, however, will be using Python to run
    SQL queries. Before anything else, let’s see how we can connect to a database!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看数据库表的内容并运行 SQL 查询，可以安装一个名为 SQLite 的 VS Code 扩展（请参阅 [SQLite 扩展文档](https://oreil.ly/nP4mC)
    获取更多详细信息），或者使用专用的 SQLite 管理软件，种类繁多。不过，我们将使用 Python 来运行 SQL 查询。在做任何事情之前，让我们看看如何连接到数据库！
- en: Database connections
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库连接
- en: To connect to a database from Python, you need a driver, i.e., a Python package
    that knows how to communicate with the database you are using. Each database requires
    a different driver and each driver uses a different syntax, but luckily, there
    is a powerful package called [SQLAlchemy](https://sqlalchemy.org) that abstracts
    away most of the differences between the various databases and drivers. SQLAlchemy
    is mostly used as an object relational mapper (ORM) that translates your database
    records into Python objects, a concept that many developers—albeit not all—find
    more natural to work with. To keep things simple, we’re ignoring the ORM functionality
    and only using SQLAlchemy to make it easier to run raw SQL queries. SQLAlchemy
    is also used behind the scenes when you use pandas to read and write database
    tables in the form of DataFrames. Running a database query from pandas involves
    three levels of packages—pandas, SQLAlchemy, and the database driver—as shown
    in [Figure 11-4](#filepos1530880). You can run database queries from each of these
    three levels.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Python 连接到数据库，需要一个驱动程序，即一个知道如何与你使用的数据库通信的 Python 包。每个数据库都需要不同的驱动程序，每个驱动程序使用不同的语法，但幸运的是，有一个强大的包叫做
    [SQLAlchemy](https://sqlalchemy.org)，它抽象了各种数据库和驱动程序之间的大部分差异。SQLAlchemy 主要用作对象关系映射器（ORM），将你的数据库记录转换为
    Python 对象，这个概念对许多开发者来说更自然，尽管并非所有人都是这么认为的。为了简化问题，我们忽略了 ORM 功能，只使用 SQLAlchemy 来更轻松地运行原始
    SQL 查询。当你使用 pandas 以 DataFrames 的形式读取和写入数据库表时，SQLAlchemy 也是在幕后使用的。从 pandas 运行数据库查询涉及三个层次的包——
    pandas、SQLAlchemy 和数据库驱动程序——如 [图 11-4](#filepos1530880) 所示。你可以从这三个层次运行数据库查询。
- en: '![](images/00057.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00057.jpg)'
- en: Figure 11-4\. Accessing databases from Python
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-4\. 从 Python 访问数据库
- en: '[Table 11-3](#filepos1531478) shows you which driver SQLAlchemy uses by default
    (some databases can be used with more than one driver). It also gives you the
    format of the database connection string—we’ll use the connection string in a
    moment when we will run actual SQL queries.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 11-3](#filepos1531478) 展示了 SQLAlchemy 默认使用的驱动程序（某些数据库可以使用多个驱动程序）。它还为你提供了数据库连接字符串的格式——稍后我们将在实际运行
    SQL 查询时使用这个连接字符串。'
- en: Table 11-3\. SQLAlchemy default drivers and connection strings
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-3\. SQLAlchemy 默认驱动程序和连接字符串
- en: '|  Database  |  Default Driver  |  Connection String  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|  数据库  |  默认驱动程序  |  连接字符串  |'
- en: '|  SQLite  |   `sqlite3` |   `sqlite:///``filepath` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|  SQLite  |   `sqlite3` |   `sqlite:///``文件路径` |'
- en: '|  PostgreSQL  |   `psycopg2` |   `postgresql://``username``:``password``@``host``:``port``/``database`
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|  PostgreSQL  |   `psycopg2` |   `postgresql://``用户名``:``密码``@``主机``:``端口``/``数据库`
    |'
- en: '|  MySQL  |   `mysql-python` |   `mysql://``username``:``password``@``host``:``port``/``database`
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|  MySQL  |   `mysql-python` |   `mysql://``用户名``:``密码``@``主机``:``端口``/``数据库`
    |'
- en: '|  Oracle  |   `cx_oracle` |   `oracle://``username``:``password``@``host``:``port``/``database`
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|  Oracle  |   `cx_oracle` |   `oracle://``用户名``:``密码``@``主机``:``端口``/``数据库`
    |'
- en: '|  SQL Server  |   `pyodbc` |   `mssql+pyodbc://``username``:``password``@``host``:``port``/``database`
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|  SQL Server  |   `pyodbc` |   `mssql+pyodbc://``用户名``:``密码``@``主机``:``端口``/``数据库`
    |'
- en: 'Except for SQLite, you usually need a password to connect to a database. And
    since connection strings are URLs, you will have to use the URL encoded version
    of your passwords if you have any special characters in them. Here is how you
    can print the URL encoded version of your password:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 SQLite，通常需要密码才能连接到数据库。由于连接字符串是 URL，如果密码中包含特殊字符，你将需要使用 URL 编码的版本。以下是如何打印密码的
    URL 编码版本：
- en: '`In``[``9``]:``import``urllib.parse`'
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``9``]:``import``urllib.parse`'
- en: '`In``[``10``]:``urllib``.``parse``.``quote_plus``(``"pa$$word"``)`'
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``10``]:``urllib``.``parse``.``quote_plus``(``"pa$$word"``)`'
- en: '`Out[10]: ''pa%24%24word''`'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[10]: ''pa%24%24word''`'
- en: Having introduced pandas, SQLAlchemy, and the database driver as the three levels
    from which we can connect to databases, let’s see how they compare in practice
    by making a few SQL queries!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了 pandas、SQLAlchemy 和数据库驱动程序作为连接数据库的三个层级后，让我们看看它们在实践中如何比较，通过几个 SQL 查询来演示！
- en: SQL queries
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 查询
- en: 'Even if you are new to SQL, you should have no trouble understanding the few
    SQL queries that I will use in the following samples and in the Python Package
    Tracker. SQL is a declarative language, which means that you tell the database
    what you want instead of what to do. Some queries almost read like plain English:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你对 SQL 还很陌生，你也应该没有问题理解我接下来在示例和 Python Package Tracker 中使用的几个 SQL 查询。SQL 是一种声明式语言，这意味着你告诉数据库你想要什么而不是怎么做。有些查询几乎读起来像是普通的英语：
- en: '`SELECT``*``FROM``packages`'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`SELECT``*``FROM``packages`'
- en: 'This tells the database that you want to select all columns from the packages
    table. In production code, you wouldn’t want to use the wildcard `*` which means
    all columns but rather specify each column explicitly as this makes your query
    less error-prone:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉数据库你要从 packages 表中选择所有列。在生产代码中，你不应该使用通配符 `*` 来表示所有列，而是明确指定每一列，这样可以减少查询错误的可能性：
- en: '`SELECT``package_id``,``package_name``FROM``packages`'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`SELECT``package_id``,``package_name``FROM``packages`'
- en: DATABASE QUERIES VS. PANDAS DATAFRAMES
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数据库查询 vs. Pandas DataFrames
- en: 'SQL is a set-based language, which means that you operate on a set of rows
    rather than looping through individual rows. This is very similar to how you work
    with pandas DataFrames. The SQL query:'
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQL 是一种基于集合的语言，这意味着你操作的是一组行而不是逐行循环。这与你处理 pandas DataFrames 的方式非常相似。以下是 SQL 查询：
- en: '`SELECT``package_id``,``package_name``FROM``packages`'
  id: totrans-112
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`SELECT``package_id``,``package_name``FROM``packages`'
- en: 'corresponds to the following pandas expression (assuming that `packages` is
    a DataFrame):'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对应以下 pandas 表达式（假设 `packages` 是一个 DataFrame）：
- en: '`packages``.``loc``[:,``[``"package_id"``,``"package_name"``]]`'
  id: totrans-114
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`packages``.``loc``[:,``[``"package_id"``,``"package_name"``]]`'
- en: 'The following code samples use the packagetracker.db file that you will find
    in the packagetracker folder of the companion repo. The examples expect that you
    have already added xlwings and pandas to the database via the Python Package Tracker’s
    Excel frontend like we did at the beginning of this chapter—otherwise you would
    get only empty results. Following [Figure 11-4](#filepos1530880) from bottom to
    top, we will first make our SQL query from the driver directly, then use SQLAlchemy
    and finally pandas:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码示例使用的是packagetracker文件夹中的packagetracker.db文件，您可以在伴随存储库的packagetracker文件夹中找到它。示例假设您已经通过Python
    Package Tracker的Excel前端将xlwings和pandas添加到了数据库中，就像我们在本章的开头所做的那样——否则您将只得到空结果。根据[图 11-4](#filepos1530880)，从底部到顶部，我们首先直接从驱动程序执行我们的SQL查询，然后使用SQLAlchemy，最后使用pandas：
- en: '`In``[``11``]:``# Let''s start with the imports``import``sqlite3``from``sqlalchemy``import``create_engine``import``pandas``as``pd`'
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``11``]:``# 让我们从导入开始``import``sqlite3``from``sqlalchemy``import``create_engine``import``pandas``as``pd`'
- en: '`In``[``12``]:``# Our SQL query: "select all columns from the packages table"``sql``=``"SELECT
    * FROM packages"`'
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``12``]:``# 我们的SQL查询："从packages表中选择所有列"``sql``=``"SELECT * FROM packages"`'
- en: '`In``[``13``]:``# Option 1: Database driver (sqlite3 is part of the standard
    library)``# Using the connection as context manager automatically commits``# the
    transaction or rolls it back in case of an error.``with``sqlite3``.``connect``(``"packagetracker/packagetracker.db"``)``as``con``:``cursor``=``con``.``cursor``()``#
    We need a cursor to run SQL queries``result``=``cursor``.``execute``(``sql``)``.``fetchall``()``#
    Return all records``result`'
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``13``]:``# 选项 1: 数据库驱动程序（sqlite3是标准库的一部分）``# 使用连接作为上下文管理器自动提交事务或在错误的情况下回滚。``with``sqlite3``.``connect``(``"packagetracker/packagetracker.db"``)``as``con``:``cursor``=``con``.``cursor``()``#
    我们需要一个游标来运行SQL查询``result``=``cursor``.``execute``(``sql``)``.``fetchall``()``#
    返回所有记录``result`'
- en: '`Out[13]: [(1, ''xlwings''), (2, ''pandas'')]`'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[13]: [(1, ''xlwings''), (2, ''pandas'')]`'
- en: '`In``[``14``]:``# Option 2: SQLAlchemy``# "create_engine" expects the connection
    string of your database.``# Here, we can execute a query as a method of the connection
    object.``engine``=``create_engine``(``"sqlite:///packagetracker/packagetracker.db"``)``with``engine``.``connect``()``as``con``:``result``=``con``.``execute``(``sql``)``.``fetchall``()``result`'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``14``]:``# 选项 2: SQLAlchemy``# "create_engine"期望你的数据库连接字符串。``# 在这里，我们可以将查询作为连接对象的方法执行。``engine``=``create_engine``(``"sqlite:///packagetracker/packagetracker.db"``)``with``engine``.``connect``()``as``con``:``result``=``con``.``execute``(``sql``)``.``fetchall``()``result`'
- en: '`Out[14]: [(1, ''xlwings''), (2, ''pandas'')]`'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[14]: [(1, ''xlwings''), (2, ''pandas'')]`'
- en: '`In``[``15``]:``# Option 3: pandas``# Providing a table name to "read_sql"
    reads the full table.``# Pandas requires an SQLAlchemy engine that we reuse from``#
    the previous example.``df``=``pd``.``read_sql``(``"packages"``,``engine``,``index_col``=``"package_id"``)``df`'
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``15``]:``# 选项 3: pandas``# 向"read_sql"提供表名读取完整的表。``# Pandas需要一个SQLAlchemy引擎，我们从前面的示例中重用。``df``=``pd``.``read_sql``(``"packages"``,``engine``,``index_col``=``"package_id"``)``df`'
- en: '`Out[15]:            package_name          package_id          1              
    xlwings          2                pandas`'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[15]:            package_name          package_id          1              
    xlwings          2                pandas`'
- en: '`In``[``16``]:``# "read_sql" also accepts an SQL query``pd``.``read_sql``(``sql``,``engine``,``index_col``=``"package_id"``)`'
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``16``]:``# "read_sql"还接受一个SQL查询``pd``.``read_sql``(``sql``,``engine``,``index_col``=``"package_id"``)`'
- en: '`Out[16]:            package_name          package_id          1              
    xlwings          2                pandas`'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[16]:            package_name          package_id          1              
    xlwings          2                pandas`'
- en: '`In``[``17``]:``# The DataFrame method "to_sql" writes DataFrames to tables``#
    "if_exists" has to be either "fail", "append" or "replace"``# and defines what
    happens if the table already exists``df``.``to_sql``(``"packages2"``,``con``=``engine``,``if_exists``=``"append"``)`'
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``17``]:``# DataFrame方法"to_sql"将DataFrame写入表中``# "if_exists"必须是"fail"、"append"或"replace"之一``df``.``to_sql``(``"packages2"``,``con``=``engine``,``if_exists``=``"append"``)`'
- en: '`In``[``18``]:``# The previous command created a new table "packages2" and``#
    inserted the records from the DataFrame df as we can``# verify by reading it back``pd``.``read_sql``(``"packages2"``,``engine``,``index_col``=``"package_id"``)`'
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``18``]:``# 前面的命令创建了一个名为"packages2"的新表，并将DataFrame df中的记录插入其中，我们可以通过重新读取来验证``pd``.``read_sql``(``"packages2"``,``engine``,``index_col``=``"package_id"``)`'
- en: '`Out[18]:            package_name          package_id          1              
    xlwings          2                pandas`'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[18]:            package_name          package_id          1              
    xlwings          2                pandas`'
- en: '`In``[``19``]:``# Let''s get rid of the table again by running the``# "drop
    table" command via SQLAlchemy``with``engine``.``connect``()``as``con``:``con``.``execute``(``"DROP
    TABLE packages2"``)`'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``19``]:``# 让我们再次通过运行 SQLAlchemy 的“drop table”命令来摆脱这个表``with``engine``.``connect``()``as``con``:``con``.``execute``(``"DROP
    TABLE packages2"``)`'
- en: 'Whether you should use the database driver, SQLAlchemy, or pandas to run your
    queries largely depends on your preferences: I personally like the fine-grained
    control you get by using SQLAlchemy and enjoy that I can use the same syntax with
    different databases. On the other hand, pandas’ `read_sql` is convenient to get
    the result of a query in the form of a DataFrame.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 是否应该使用数据库驱动程序SQLAlchemy或pandas来运行您的查询，很大程度上取决于您的偏好：我个人喜欢使用SQLAlchemy获得的精细控制，并且享受使用相同语法在不同数据库上的便利。另一方面，pandas
    的`read_sql`便于将查询结果以DataFrame的形式获取。
- en: FOREIGN KEYS WITH SQLITE
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用SQLITE的外键
- en: Somewhat surprisingly, SQLite does not respect foreign keys by default when
    running queries. However, if you use SQLAlchemy, you can easily enforce foreign
    keys; see the [SQLAlchemy docs](https://oreil.ly/6YPvC). This will also work if
    you run the queries from pandas. You will find the respective code at the top
    of the database.py module in the packagetracker folder of the companion repository.
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有些令人惊讶的是，默认情况下，SQLite在运行查询时不会默认遵守外键约束。但是，如果您使用SQLAlchemy，可以轻松强制执行外键约束；请参阅[SQLAlchemy文档](https://oreil.ly/6YPvC)。如果您从pandas运行查询，这也适用。您将在伴随存储库的packagetracker文件夹的database.py模块顶部找到相应的代码。
- en: Now that you know how to run simple SQL queries, let’s wrap this section up
    by looking at SQL injections, which can pose a security risk to your application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何运行简单的SQL查询了，让我们通过查看SQL注入来结束本节，这可能会对您的应用程序构成安全风险。
- en: SQL injection
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入
- en: 'If you don’t protect your SQL queries properly, a malicious user can run arbitrary
    SQL code by injecting SQL statements into data input fields: for example, instead
    of selecting a package name like xlwings in the dropdown of the Python Package
    Tracker, they could send an SQL statement that changes your intended query. This
    can expose sensitive information or perform destructive actions like deleting
    a table. How can you prevent this? Let’s first have a look at the following database
    query, which the Package Tracker runs when you select xlwings and click on Show
    History:[1](#filepos1652489)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有正确保护SQL查询，恶意用户可以通过向数据输入字段注入SQL语句来运行任意的SQL代码：例如，在Python包追踪器的下拉菜单中选择包名xlwings时，他们可以发送一个改变您预期查询的SQL语句。这可能会暴露敏感信息或执行像删除表这样的破坏性操作。如何预防这种情况？让我们首先看一下下面的数据库查询，当您选择xlwings并点击“显示历史记录”时，包追踪器运行的查询：[1](#filepos1652489)
- en: '`SELECT``v``.``uploaded_at``,``v``.``version_string``FROM``packages``p``INNER``JOIN``package_versions``v``ON``p``.``package_id``=``v``.``package_id``WHERE``p``.``package_id``=``1`'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`SELECT``v``.``uploaded_at``,``v``.``version_string``FROM``packages``p``INNER``JOIN``package_versions``v``ON``p``.``package_id``=``v``.``package_id``WHERE``p``.``package_id``=``1`'
- en: 'This query joins the two tables together and only returns those rows where
    the `package_id` is `1`. To help you understand this query based on what we learned
    in [Chapter 5](index_split_015.html#filepos482650), if `packages` and `package_versions`
    were pandas DataFrames, you could write:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询将两个表连接在一起，仅返回`package_id`为`1`的行。为了帮助您基于我们在[第5章](index_split_015.html#filepos482650)中学到的内容理解此查询，如果`packages`和`package_versions`是pandas的DataFrame，您可以编写：
- en: '`df``=``packages``.``merge``(``package_versions``,``how``=``"inner"``,``on``=``"package_id"``)``df``.``loc``[``df``[``"package_id"``]``==``1``,``[``"uploaded_at"``,``"version_string"``]]`'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`df``=``packages``.``merge``(``package_versions``,``how``=``"inner"``,``on``=``"package_id"``)``df``.``loc``[``df``[``"package_id"``]``==``1``,``[``"uploaded_at"``,``"version_string"``]]`'
- en: 'It’s obvious that the `package_id` needs to be a variable where we now have
    a hardcoded `1` to return the correct rows depending on the package that is selected.
    Knowing about f-strings from [Chapter 3](index_split_010.html#filepos178328),
    you could be tempted to change the last line of the SQL query like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`package_id`需要是一个变量，而不是我们现在硬编码的`1`，以便根据所选包返回正确的行。了解到f-strings来自[第3章](index_split_010.html#filepos178328)，您可能会想要像这样更改SQL查询的最后一行：
- en: '`f``"WHERE p.package_id = {package_id}"`'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`f``"WHERE p.package_id = {package_id}"`'
- en: 'While this would technically work, you must never do this as it opens up the
    door for SQL injection: for example, somebody could send `''1 OR TRUE''` instead
    of an integer representing the `package_id`. The resulting query would return
    the rows of the whole table instead of just those where the `package_id` is `1`.
    Therefore, always use the syntax that SQLAlchemy offers you for placeholders (they
    start with a colon):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这在技术上可以工作，但绝不能这样做，因为它会为 SQL 注入打开大门：例如，有人可以发送 `'1 OR TRUE'` 而不是表示 `package_id`
    的整数。生成的查询将返回整个表的行，而不仅仅是 `package_id` 等于 `1` 的行。因此，始终使用 SQLAlchemy 为您提供的占位符语法（它们以冒号开头）：
- en: '`In``[``20``]:``# Let''s start by importing SQLAlchemy''s text function``from``sqlalchemy.sql``import``text`'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``20``]:``# 让我们从导入 SQLAlchemy 的 text 函数开始``从``sqlalchemy.sql``导入``text`'
- en: '`In``[``21``]:``# ":package_id" is the placeholder``sql``=``"""``         SELECT
    v.uploaded_at, v.version_string``         FROM packages p``         INNER JOIN
    package_versions v ON p.package_id = v.package_id``         WHERE p.package_id
    = :package_id``         ORDER BY v.uploaded_at``         """`'
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``21``]:``# “:package_id” 是占位符``sql``=``"""``         选择``v.uploaded_at,``v.version_string``        
    从``packages``p``         内连接``package_versions``v``在``p.package_id``=``v.package_id``        
    其中``p.package_id``=``:package_id``         按``v.uploaded_at``排序``"""`'
- en: '`In``[``22``]:``# Via SQLAlchemy``with``engine``.``connect``()``as``con``:``result``=``con``.``execute``(``text``(``sql``),``package_id``=``1``)``.``fetchall``()``result``[:``3``]``#
    Print the first 3 records`'
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``22``]:``# 通过 SQLAlchemy``使用``engine``.``connect``()``连接``的``方式``获取``结果``=``con``.``execute``(``text``(``sql``),``package_id``=``1``)``.``fetchall``()``结果``[:``3``]``#
    打印``前``3``条记录`'
- en: '`Out[22]: [(''2014-03-19 18:18:49.000000'', ''0.1.0''),           (''2014-06-27
    16:26:36.000000'', ''0.1.1''),           (''2014-07-29 17:14:22.000000'', ''0.2.0'')]`'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[22]: [(''2014-03-19 18:18:49.000000'', ''0.1.0''),           (''2014-06-27
    16:26:36.000000'', ''0.1.1''),           (''2014-07-29 17:14:22.000000'', ''0.2.0'')]`'
- en: '`In``[``23``]:``# Via pandas``pd``.``read_sql``(``text``(``sql``),``engine``,``parse_dates``=``[``"uploaded_at"``],``params``=``{``"package_id"``:``1``},``index_col``=``[``"uploaded_at"``])``.``head``(``3``)`'
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``23``]:``# 通过 pandas``pd``.``read_sql``(``text``(``sql``),``engine``,``parse_dates``=``[``"uploaded_at"``],``params``=``{``"package_id"``:``1``},``index_col``=``[``"uploaded_at"``])``.``head``(``3``)`'
- en: '`Out[23]:                     version_string          uploaded_at         
    2014-03-19 18:18:49          0.1.0          2014-06-27 16:26:36          0.1.1
             2014-07-29 17:14:22          0.2.0`'
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[23]:                     version_string          uploaded_at         
    2014-03-19 18:18:49          0.1.0          2014-06-27 16:26:36          0.1.1
             2014-07-29 17:14:22          0.2.0`'
- en: 'Wrapping the SQL query with SQLAlchemy’s `text` function has the advantage
    that you can use the same syntax for placeholders across different databases.
    Otherwise, you’d have to use the placeholder that the database driver uses: `sqlite3`
    uses `?` and `psycopg2` uses `%s`, for example.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SQLAlchemy 的 `text` 函数包装 SQL 查询具有一个优点，即您可以在不同的数据库中使用相同的占位符语法。否则，您将不得不使用数据库驱动程序使用的占位符：例如，`sqlite3`
    使用 `?` 而 `psycopg2` 使用 `%s`。
- en: You may argue that SQL injection isn’t much of an issue when your users have
    direct access to Python and could run arbitrary code on the database anyway. But
    if you take your xlwings prototype and transform it into a web application one
    day, it will become a huge issue, so it’s better to do it properly from the beginning.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认为当用户直接访问 Python 并可以在数据库上运行任意代码时，SQL 注入并不是什么问题。但是，如果有一天将您的 xlwings 原型转换为
    Web 应用程序，这将成为一个巨大的问题，因此最好从一开始就做好。
- en: 'Besides web APIs and databases, there is another topic that we have jumped
    over so far that is indispensable for solid application development: exception
    handling. Let’s see how it works!'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Web API 和数据库，我们到目前为止跳过的另一个不可或缺的主题是坚实应用程序开发的异常处理。让我们看看它是如何工作的！
- en: Exceptions
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 异常
- en: 'I mentioned exception handling in [Chapter 1](index_split_007.html#filepos32075)
    as an example of where VBA with its GoTo mechanism has fallen behind. In this
    section, I show you how Python uses the try/except mechanism to handle errors
    in your programs. Whenever something is outside of your control, errors can and
    will happen. For example, the email server may be down when you try to send an
    email, or a file may be missing that your program expects—in the case of the Python
    Package Tracker, this could be the database file. Dealing with user input is another
    area where you have to prepare for inputs that don’t make sense. Let’s get some
    practice—if the following function is called with a zero, you will get a `ZeroDivisionError`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第1章](index_split_007.html#filepos32075)中提到了异常处理作为VBA在其GoTo机制方面落后的一个例子。在本节中，我将向您展示Python如何使用try/except机制来处理程序中的错误。每当某些事情超出您的控制时，错误可能会发生。例如，当您尝试发送电子邮件时，可能会出现电子邮件服务器宕机的情况，或者您的程序期望的文件可能会丢失-例如Python
    Package Tracker中可能是数据库文件。处理用户输入是另一个需要准备应对不合理输入的领域。让我们练习一下-如果以下函数被零调用，您将得到`ZeroDivisionError`：
- en: '`In``[``24``]:``def``print_reciprocal``(``number``):``result``=``1``/``number``print``(``f``"The
    reciprocal is: {result}"``)`'
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``24``]:`定义`print_reciprocal``(``number``):`结果``=``1``/``number``打印``(``f``"The
    reciprocal is: {result}"``)`'
- en: '`In``[``25``]:``print_reciprocal``(``0``)``# This will raise an error`'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``25``]:`print_reciprocal``(``0``)``＃这将引发错误`'
- en: '`---------------------------------------------------------------------------
    ZeroDivisionError                         Traceback (most recent call last) <ipython-input-25-095f19ebb9e9>
    in <module> ----> 1 print_reciprocal(0)  # This will raise an error  <ipython-input-24-88fdfd8a4711>
    in print_reciprocal(number)       1 def print_reciprocal(number): ----> 2    
    result = 1 / number       3     print(f"The reciprocal is: {result}")  ZeroDivisionError:
    division by zero`'
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`---------------------------------------------------------------------------
    ZeroDivisionError                         Traceback (most recent call last) <ipython-input-25-095f19ebb9e9>
    in <module> ----> 1`print_reciprocal``(``0``) ＃这将引发错误  <ipython-input-24-88fdfd8a4711>
    in `print_reciprocal``(``number``)       1`定义`print_reciprocal``(``number``):
    ----> 2    `结果``=``1``/``number``      3      `打印``(``f``"The reciprocal is: {result}"``)  ZeroDivisionError:
    division by zero`'
- en: 'To let your program react gracefully to such errors, use the try/except statements
    (this is the equivalent of the VBA sample in [Chapter 1](index_split_007.html#filepos32075)):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要使您的程序能够优雅地对此类错误做出反应，请使用try/except语句（这相当于[第1章](index_split_007.html#filepos32075)中VBA示例的等价物）：
- en: '`In``[``26``]:``def``print_reciprocal``(``number``):``try``:``result``=``1``/``number``except``Exception``as``e``:``#
    "as e" makes the Exception object available as variable "e"``# "repr" stands for
    "printable representation" of an object``# and gives you back a string with the
    error message``print``(``f``"There was an error: {repr(e)}"``)``result``=``"N/A"``else``:``print``(``"There
    was no error!"``)``finally``:``print``(``f``"The reciprocal is: {result}"``)`'
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``26``]:`定义`print_reciprocal``(``number``):`尝试``:`结果``=``1``/``number``除``Exception``as``e``:``＃"as
    e"使异常对象可用作变量"e"``＃"repr"表示对象的可打印表示``＃并返回一个带有错误消息的字符串``打印``(``f``"There was an
    error: {repr(e)}"``)``结果``=``"N/A"``else``:``打印``(``"There was no error!"``)``最后``:``打印``(``f``"The
    reciprocal is: {result}"``)`'
- en: 'Whenever an error occurs in the `try` block, code execution moves on to the
    `except` block where you can handle the error: this allows you to give the user
    helpful feedback or write the error to a log file. The `else` clause only runs
    if there is no error raised during the `try` block and the `finally` block runs
    always, whether or not an error was raised. Often, you will get away with just
    the `try` and `except` blocks. Let’s see the output of the function given different
    inputs:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`try`块中发生错误时，代码执行将移至`except`块，您可以在那里处理错误：这使您能够为用户提供有用的反馈或将错误写入日志文件。`else`子句仅在`try`块中未引发错误并且`finally`块始终运行时运行，无论是否引发错误。通常情况下，您只需使用`try`和`except`块。让我们看看给定不同输入时函数的输出：
- en: '`In``[``27``]:``print_reciprocal``(``10``)`'
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``27``]:`print_reciprocal``(``10``)`'
- en: '`There was no error! The reciprocal is: 0.1`'
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`There was no error! The reciprocal is: 0.1`'
- en: '`In``[``28``]:``print_reciprocal``(``"a"``)`'
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``28``]:`print_reciprocal``(``"a"``)`'
- en: '`There was an error: TypeError("unsupported operand type(s) for /: ''int''
    and ''str''") The reciprocal is: N/A`'
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`There was an error: TypeError("unsupported operand type(s) for /: ''int''
    and ''str''") The reciprocal is: N/A`'
- en: '`In``[``29``]:``print_reciprocal``(``0``)`'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``29``]:`print_reciprocal``(``0``)`'
- en: '`There was an error: ZeroDivisionError(''division by zero'') The reciprocal
    is: N/A`'
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`There was an error: ZeroDivisionError(''division by zero'') The reciprocal
    is: N/A`'
- en: 'The way that I have used the except statement means that any exception that
    happens in the `try` block will cause the code execution to continue in the `except`
    block. Usually, that is not what you want. You want to check for an error as specific
    as possible and handle only those you expect. Your program may otherwise fail
    for something completely unexpected, which makes it hard to debug. To fix this,
    rewrite the function as follows, checking explicitly for the two errors that we
    expect (I am leaving away the `else` and `finally` statements):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 'The way that I have used the except statement means that any exception that
    happens in the `try` block will cause the code execution to continue in the `except`
    block. Usually, that is not what you want. You want to check for an error as specific
    as possible and handle only those you expect. Your program may otherwise fail
    for something completely unexpected, which makes it hard to debug. To fix this,
    rewrite the function as follows, checking explicitly for the two errors that we
    expect (I am leaving away the `else` and `finally` statements):'
- en: '`In``[``30``]:``def``print_reciprocal``(``number``):``try``:``result``=``1``/``number``print``(``f``"The
    reciprocal is: {result}"``)``except``(``TypeError``,``ZeroDivisionError``):``print``(``"Please
    type in any number except 0."``)`'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``30``]:``def``print_reciprocal``(``number``):``try``:``result``=``1``/``number``print``(``f``"The
    reciprocal is: {result}"``)``except``(``TypeError``,``ZeroDivisionError``):``print``(``"Please
    type in any number except 0."``)`'
- en: 'Let’s run the code again:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行代码：
- en: '`In``[``31``]:``print_reciprocal``(``"a"``)`'
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``31``]:``print_reciprocal``(``"a"``)`'
- en: '`Please type in any number except 0.`'
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请键入除0以外的任何数字。
- en: 'If you want to handle an error differently depending on the exception, handle
    them separately:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想根据异常不同处理错误，应分别处理它们：
- en: '`In``[``32``]:``def``print_reciprocal``(``number``):``try``:``result``=``1``/``number``print``(``f``"The
    reciprocal is: {result}"``)``except``TypeError``:``print``(``"Please type in a
    number."``)``except``ZeroDivisionError``:``print``(``"The reciprocal of 0 is not
    defined."``)`'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``32``]:``def``print_reciprocal``(``number``):``try``:``result``=``1``/``number``print``(``f``"The
    reciprocal is: {result}"``)``except``TypeError``:``print``(``"Please type in a
    number."``)``except``ZeroDivisionError``:``print``(``"The reciprocal of 0 is not
    defined."``)`'
- en: '`In``[``33``]:``print_reciprocal``(``"a"``)`'
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``33``]:``print_reciprocal``(``"a"``)`'
- en: '`Please type in a number.`'
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`请键入一个数字。`'
- en: '`In``[``34``]:``print_reciprocal``(``0``)`'
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``34``]:``print_reciprocal``(``0``)`'
- en: '`The reciprocal of 0 is not defined.`'
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`The reciprocal of 0 is not defined.`'
- en: Now that you know about error handling, web APIs, and databases, you are ready
    to move on to the next section, where we’ll go through each component of the Python
    Package Tracker.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了错误处理、Web API 和数据库，可以继续学习下一节内容，我们将逐个讲解 Python Package Tracker 的每个组成部分。
- en: Application Structure
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序结构
- en: In this section, we’ll look behind the scenes of the Python Package Tracker
    to understand how everything works. First, we’ll walk through the application’s
    frontend, i.e., the Excel file, before looking at its backend, i.e., the Python
    code. To wrap this section up, we’ll see how debugging an xlwings project works,
    a useful skill with projects of the size and complexity of the Package Tracker.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入了解 Python Package Tracker 的幕后工作原理。首先，我们将详细介绍应用程序的前端，即 Excel 文件，然后再看其后端，即
    Python 代码。最后，我们将了解 xlwings 项目的调试方法，这对于像 Package Tracker 这样规模和复杂性的项目非常有用。
- en: 'In the packagetracker directory in the companion repo, you’ll find four files.
    Do you remember when I talked about separation of concerns in [Chapter 1](index_split_007.html#filepos32075)?
    We are now able to map these files to the different layers as shown in [Table 11-4](#filepos1602253):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 companion repo 的 packagetracker 目录中，你会找到四个文件。还记得我在[第1章](index_split_007.html#filepos32075)中提到的关注点分离吗？现在我们可以将这些文件映射到如[表格
    11-4](#filepos1602253)所示的不同层次。
- en: Table 11-4\. Separation of concerns
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 11-4\. 关注点分离
- en: '|  Layer  |  File  |  Description  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|  层次  |  文件  |  描述  |'
- en: '|  Presentation layer  |   `packagetracker.xlsm` |  This is the frontend and
    as such the only file the end-user interacts with.  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|  展示层  |   `packagetracker.xlsm` |  这是前端，也是最终用户与之交互的唯一文件。  |'
- en: '|  Business layer  |   `packagetracker.py` |  This module handles the data
    download via web API and does the number crunching with pandas.  |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '|  业务层  |   `packagetracker.py` |  该模块通过 Web API 处理数据下载，并使用 pandas 进行数据处理。 
    |'
- en: '|  Data layer  |   `database.py` |  This module handles all database queries. 
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '|  数据层  |   `database.py` |  该模块处理所有数据库查询。  |'
- en: '|  Database  |   `packagetracker.db` |  This is an SQLite database file.  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|  数据库  |   `packagetracker.db` |  这是一个 SQLite 数据库文件。  |'
- en: In this context, it’s worth mentioning that the presentation layer, i.e., the
    Excel file, doesn’t contain a single cell formula, which makes the tool much easier
    to audit and control.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，值得一提的是，即 Excel 文件的展示层并不包含单个单元格公式，这使得工具更容易审计和控制。
- en: MODEL-VIEW-CONTROLLER (MVC)
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模型-视图-控制器（MVC）
- en: Separation of concerns has many faces and the breakdown as shown in [Table 11-4](#filepos1602253)
    is just one possibility. Another popular design pattern that you may run into
    relatively quickly is called model-view-controller (MVC). In the MVC world, the
    core of the application is the model where all the data and usually most of the
    business logic is handled. While the view corresponds to the presentation layer,
    the controller is only a thin layer that sits between the model and the view to
    make sure that they are always in sync. To keep things simple, I am not using
    the MVC pattern in this book.
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关注分离有多种形式，如 [表 11-4](#filepos1602253) 所示的分解只是一种可能性。您可能很快就会遇到的另一种流行设计模式称为模型-视图-控制器（MVC）。在
    MVC 的世界中，应用程序的核心是模型，其中处理所有数据和通常大部分业务逻辑。视图对应于表示层，控制器只是一个薄层，位于模型和视图之间，以确保它们始终保持同步。为了简化事务，本书未使用
    MVC 模式。
- en: Now that you know what each file is responsible for, let’s move on and have
    a closer look at how the Excel frontend has been set up!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道每个文件负责什么，让我们继续深入了解 Excel 前端的设置方式！
- en: Frontend
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 前端
- en: 'When you build a web application, you differentiate between the frontend, which
    is the part of the application that runs in your browser, and the backend, which
    is the code that runs on the server. We can apply the same terminology with xlwings
    tools: the frontend is the Excel file and the backend is the Python code that
    you call via `RunPython`. If you want to build the frontend from scratch, begin
    with running the following command on an Anaconda Prompt (make sure to `cd` first
    into the directory of your choice):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建 Web 应用程序时，您区分前端和后端。前端是在浏览器中运行的应用程序部分，而后端是在服务器上运行的代码，您通过`RunPython`调用它。我们可以将相同的术语应用于
    xlwings 工具：前端是 Excel 文件，后端是 Python 代码，您通过 Anaconda Prompt 运行以下命令（确保首先`cd`到您选择的目录）：
- en: '`(base)>` `xlwings quickstart packagetracker`'
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`(base)>` `xlwings quickstart packagetracker`'
- en: Navigate to the packagetracker directory and open packagetracker.xlsm in Excel.
    Start by adding the three tabs, Tracker, Database and Dropdown, as shown in [Figure 11-5](#filepos1607351).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 转到 packagetracker 目录，并在 Excel 中打开 packagetracker.xlsm。首先添加三个选项卡：Tracker、Database
    和 Dropdown，如 [图 11-5](#filepos1607351) 所示。
- en: '![](images/00024.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00024.jpg)'
- en: Figure 11-5\. Building the user interface
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-5\. 构建用户界面
- en: 'While you should be able to take over the text and formatting from [Figure 11-5](#filepos1607351),
    I need to give you a few more details about the things that aren’t visible:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您应该能够接管来自 [图 11-5](#filepos1607351) 的文本和格式，但我需要给您一些关于不可见事物的详细信息：
- en: Buttons
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮
- en: To make the tool look a bit less like Windows 3.1, I didn’t use the standard
    macro buttons that we used in the previous chapter. Instead, I went to Insert
    > Shapes and inserted a Rounded Rectangle. If you want to use the standard button,
    that’s fine, too, but at this point, don’t assign a macro just yet.
  id: totrans-198
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了使工具看起来不那么像 Windows 3.1，我没有使用我们在前一章中使用的标准宏按钮。相反，我去插入 > 形状，插入了一个圆角矩形。如果您想使用标准按钮，那也可以，但在这一点上，请不要立即分配宏。
- en: Named ranges
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 命名区域
- en: To make the tool a little easier to maintain, we will use named ranges rather
    than cell addresses in the Python code. Therefore, add the named ranges as shown
    in [Table 11-5](#filepos1608689).
  id: totrans-200
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了使工具更易于维护，我们将在 Python 代码中使用命名区域而不是单元格地址。因此，请按照 [表 11-5](#filepos1608689) 所示添加命名区域。
- en: Table 11-5\. Named ranges
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-5\. 命名区域
- en: '|  Sheet  |  Cell  |  Name  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '|  表格  |  单元格  |  名称  |'
- en: '|'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Tracker
  id: totrans-204
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 跟踪器
- en: '|'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: B5
  id: totrans-206
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: B5
- en: '|'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`package_selection`'
  id: totrans-208
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`package_selection`'
- en: '|'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Tracker
  id: totrans-211
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 跟踪器
- en: '|'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: B11
  id: totrans-213
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: B11
- en: '|'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`latest_release`'
  id: totrans-215
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`latest_release`'
- en: '|'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Database
  id: totrans-218
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数据库
- en: '|'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: B5
  id: totrans-220
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: B5
- en: '|'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`new_package`'
  id: totrans-222
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`new_package`'
- en: '|'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Database
  id: totrans-225
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数据库
- en: '|'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: B13
  id: totrans-227
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: B13
- en: '|'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`updated_at`'
  id: totrans-229
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`updated_at`'
- en: '|'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Database
  id: totrans-232
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数据库
- en: '|'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: B18
  id: totrans-234
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: B18
- en: '|'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`log`'
  id: totrans-236
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`log`'
- en: '|'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: One way to add named ranges is to select the cell, then write the name into
    the Name Box and finally confirm by hitting Enter, as in [Figure 11-6](#filepos1612557).
  id: totrans-238
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 添加命名区域的一种方法是选择单元格，然后在名称框中编写名称，最后按 Enter 确认，如 [图 11-6](#filepos1612557) 所示。
- en: '![](images/00019.jpg)'
  id: totrans-239
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00019.jpg)'
- en: Figure 11-6\. The Name Box
  id: totrans-240
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 11-6\. 名称框
- en: Tables
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 表格
- en: On the Dropdown sheet, after typing “packages” into cell A1, select A1, then
    go to Insert > Table and make sure to activate the checkbox next to “My table
    has headers.” To finalize, with the table selected, go to the ribbon tab Table
    Design (Windows) or Table (macOS) and rename the table from `Table1` to `dropdown_content`,
    as shown in [Figure 11-7](#filepos1613484).
  id: totrans-242
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 Dropdown 表上，在单元格 A1 中键入“packages”后，选择 A1，然后转到 插入 > 表格，并确保激活“我的表格具有标题”旁边的复选框。最后，选中表格后，转到功能区标签
    表格设计（Windows）或表格（macOS），并将表格从 `Table1` 重命名为 `dropdown_content`，如图 [Figure 11-7](https://example.org/filepos1613484)
    所示。
- en: '![](images/00010.jpg)'
  id: totrans-243
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00010.jpg)'
- en: Figure 11-7\. Renaming an Excel table
  id: totrans-244
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 [Figure 11-7](https://example.org/filepos1613484)。重命名 Excel 表格
- en: Data Validation
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 数据验证
- en: 'We use data validation to provide the dropdown in cell B5 on the Tracker sheet.
    To add it, select cell B5, then go to Data > Data Validation and under Allow,
    select List. Under source set the following formula:'
  id: totrans-246
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们使用数据验证在 Tracker 表的 B5 单元格中提供下拉菜单。要添加它，请选择单元格 B5，然后转到 数据 > 数据验证，允许下拉菜单，然后在源中设置以下公式：
- en: '`=INDIRECT("dropdown_content[packages]")`'
  id: totrans-247
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`=INDIRECT("dropdown_content[packages]")`'
- en: Then, confirm with OK. This is just a reference to the body of the table, but
    since Excel doesn’t accept a table reference directly, we have to wrap it in an
    `INDIRECT` formula, which resolves the table to its address. Still, by using a
    table, it will properly resize the range that is shown in the dropdown when we
    add more packages.
  id: totrans-248
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后，点击确认。这只是表的一个参考，但由于 Excel 不能直接接受表引用，我们必须用 `INDIRECT` 公式将其包装起来，这将表解析为其地址。然而，通过使用表，当我们添加更多包时，它会适当调整下拉菜单中显示的范围。
- en: Conditional Formatting
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 条件格式化
- en: 'When you add a package, there can be a few errors that we’d like to show to
    the user: the field could be empty, the package may already exist on the database,
    or it may be missing on PyPI. To show the error in red and other messages in black,
    we’ll use a simple trick based on conditional formatting: we want a red font whenever
    the message contains the word “error.” On the Database sheet, select cell C5,
    which is where we’ll write out the message. Then go to Home > Conditional Formatting
    > Highlight Cells Rules > Text that contains. Enter the value `error` and select
    Red Text in the dropdown as shown in [Figure 11-8](#filepos1615769), then click
    on OK. Apply the same conditional format to cell C5 on the Tracker sheet.'
  id: totrans-250
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当您添加一个包时，可能会出现几个错误需要向用户显示：字段可能为空，包可能已经存在于数据库中，或者可能在 PyPI 上缺失。为了在红色中显示错误信息和其他消息为黑色，我们将使用基于条件格式化的简单技巧：每当消息包含“error”时，我们希望字体变为红色。在数据库表中，选择单元格
    C5，这是我们将写出消息的地方。然后进入主页 > 条件格式化 > 突出显示单元格规则 > 包含文本。输入值 `error` 并在下拉菜单中选择红色文本，如图
    [Figure 11-8](https://example.org/filepos1615769) 所示，然后点击确定。将同样的条件格式应用到 Tracker
    表的单元格 C5 上。
- en: '![](images/00029.jpg)'
  id: totrans-251
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00029.jpg)'
- en: Figure 11-8\. Conditional Formatting on Windows (left) and macOS (right)
  id: totrans-252
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 [Figure 11-8](https://example.org/filepos1615769)。Windows 上的条件格式化（左）和 macOS
    上的条件格式化（右）
- en: Gridlines
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 网格线
- en: On the Tracker and Database sheets, the gridlines have been hidden by unchecking
    the View checkbox under Page Layout > Gridlines.
  id: totrans-254
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 Tracker 和 Database 表上，网格线已通过在页面布局 > 网格线 下取消勾选查看复选框而隐藏。
- en: 'At this point, the user interface is complete and should look like [Figure 11-5](#filepos1607351).
    We now need to add the `RunPython` calls in the VBA editor and connect them with
    the buttons. Click Alt+F11 (Windows) or Option-F11 (macOS) to open the VBA editor,
    then, under the VBAProject of packagetracker.xlsm, double-click Module1 on the
    lefthand side under Modules to open it. Delete the existing `SampleCall` code
    and replace it with the following macros:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，用户界面已完成，应如图 [Figure 11-5](https://example.org/filepos1607351) 所示。现在我们需要在
    VBA 编辑器中添加 `RunPython` 调用，并将它们与按钮连接起来。点击 Alt+F11（Windows）或 Option-F11（macOS）打开
    VBA 编辑器，然后，在 packagetracker.xlsm 的 VBAProject 下，双击左侧的 Modules 下的 Module1 打开它。删除现有的
    `SampleCall` 代码，并替换为以下宏：
- en: '`Sub``AddPackage``()``RunPython``"import packagetracker; packagetracker.add_package()"``End``Sub``Sub``ShowHistory``()``RunPython``"import
    packagetracker; packagetracker.show_history()"``End``Sub``Sub``UpdateDatabase``()``RunPython``"import
    packagetracker; packagetracker.update_database()"``End``Sub`'
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Sub``AddPackage``()``RunPython``"import packagetracker; packagetracker.add_package()"``End``Sub``Sub``ShowHistory``()``RunPython``"import
    packagetracker; packagetracker.show_history()"``End``Sub``Sub``UpdateDatabase``()``RunPython``"import
    packagetracker; packagetracker.update_database()"``End``Sub`'
- en: Next, right-click on each button, select Assign Macro and select the macro that
    corresponds to the button. [Figure 11-9](#filepos1619526) shows the Show History
    button, but it works the same for the Add Package and Update Database buttons.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，右键单击每个按钮，选择分配宏，并选择与按钮对应的宏。[图 11-9](#filepos1619526)显示了“显示历史记录”按钮，但对于“添加包”和“更新数据库”按钮，操作方式相同。
- en: '![](images/00037.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00037.jpg)'
- en: Figure 11-9\. Assign the ShowHistory macro to the Show History button
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-9\. 将“显示历史记录”宏分配给“显示历史记录”按钮
- en: The frontend is now done and we can move on with the Python backend.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 前端部分已完成，我们可以继续进行Python后端的开发。
- en: Backend
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 后端
- en: 'The code of the two Python files packagetracker.py and database.py is too long
    to be shown here, so you will need to open them from the companion repository
    in VS Code. I will, however, refer to a couple of code snippets in this section
    to explain a few key concepts. Let’s see what happens when you click the Add Package
    button on the Database sheet. The button has the following VBA macro assigned:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: packagetracker.py 和 database.py 两个Python文件的代码太长，无法在此处显示，因此您需要从配套存储库中在VS Code中打开它们。不过，在本节中我会引用一些代码片段来解释一些关键概念。让我们看看当您在Database表单上单击“添加包”按钮时会发生什么。该按钮分配了以下VBA宏：
- en: '`Sub``AddPackage``()``RunPython``"import packagetracker; packagetracker.add_package()"``End``Sub`'
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Sub``AddPackage``()``RunPython``"import packagetracker; packagetracker.add_package()"``End``Sub`'
- en: As you see, the `RunPython` function calls the `add_package` Python function
    in the `packagetracker` module as shown in [Example 11-1](#filepos1621971).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`RunPython` 函数调用了 `packagetracker` 模块中的 `add_package` Python 函数，如 [示例 11-1](#filepos1621971)
    中所示。
- en: NO PRODUCTION CODE
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无生产代码
- en: 'The application is kept as simple as possible to make it easy to follow—it
    doesn’t check for every possible thing that can go wrong. In a production environment,
    you’d want to make it more robust: for example, you would show a user-friendly
    error if it can’t find the database file.'
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了便于跟踪，应用尽可能简化—它并不检查所有可能出错的事情。在生产环境中，您希望使其更加健壮：例如，如果找不到数据库文件，您将显示用户友好的错误信息。
- en: Example 11-1\. The `add_package` function in packagetracker.py (without comments)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-1\. packagetracker.py 中的 `add_package` 函数（无注释）
- en: '`def``add_package``():``db_sheet``=``xw``.``Book``.``caller``()``.``sheets``[``"Database"``]``package_name``=``db_sheet``[``"new_package"``]``.``value``feedback_cell``=``db_sheet``[``"new_package"``]``.``offset``(``column_offset``=``1``)``feedback_cell``.``clear_contents``()``if``not``package_name``:``feedback_cell``.``value``=``"Error:
    Please provide a name!"`![](images/00031.jpg)`return``if``requests``.``get``(``f``"{BASE_URL}/{package_name}/json"``,``timeout``=``6``)``.``status_code``!=``200``:`![](images/00039.jpg)`feedback_cell``.``value``=``"Error:
    Package not found!"``return``error``=``database``.``store_package``(``package_name``)`![](images/00050.jpg)`db_sheet``[``"new_package"``]``.``clear_contents``()``if``error``:``feedback_cell``.``value``=``f``"Error:
    {error}"``else``:``feedback_cell``.``value``=``f``"Added {package_name} successfully."``update_database``()`![](images/00067.jpg)`refresh_dropdown``()`![](images/00058.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`def``add_package``():``db_sheet``=``xw``.``Book``.``caller``()``.``sheets``[``"Database"``]``package_name``=``db_sheet``[``"new_package"``]``.``value``feedback_cell``=``db_sheet``[``"new_package"``]``.``offset``(``column_offset``=``1``)``feedback_cell``.``clear_contents``()``if``not``package_name``:``feedback_cell``.``value``=``"错误：请提供名称！"`![](images/00031.jpg)`return``if``requests``.``get``(``f``"{BASE_URL}/{package_name}/json"``,``timeout``=``6``)``.``status_code``!=``200``:`![](images/00039.jpg)`feedback_cell``.``value``=``"错误：未找到包！"``return``error``=``database``.``store_package``(``package_name``)`![](images/00050.jpg)`db_sheet``[``"new_package"``]``.``clear_contents``()``if``error``:``feedback_cell``.``value``=``f``"错误：{error}"``else``:``feedback_cell``.``value``=``f``"成功添加
    {package_name}。"``update_database``()`![](images/00067.jpg)`refresh_dropdown``()`![](images/00058.jpg)'
- en: '![](images/00031.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00031.jpg)'
- en: The “error” in the feedback message will trigger the red font in Excel via conditional
    formatting.
  id: totrans-270
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过条件格式化，反馈消息中的“error”将触发Excel中的红色字体。
- en: '![](images/00039.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00039.jpg)'
- en: By default, Requests is waiting forever for a response which could lead the
    application to “hang” in cases where PyPI has an issue and is responding slowly.
    That’s why for production code, you should always include an explicit `timeout`
    parameter.
  id: totrans-272
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认情况下，Requests 会永久等待响应，这可能导致应用在PyPI出现问题且响应速度慢时“挂起”。因此，对于生产代码，您应始终包含显式的 `timeout`
    参数。
- en: '![](images/00050.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00050.jpg)'
- en: The `store_package` function returns `None` if the operation was successful
    and a string with the error message otherwise.
  id: totrans-274
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果操作成功，`store_package` 函数返回 `None`，否则返回包含错误消息的字符串。
- en: '![](images/00067.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00067.jpg)'
- en: To keep things simple, the whole database is updated. In a production environment,
    you would only add the records of the new package.
  id: totrans-276
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了简化操作，整个数据库都会被更新。在生产环境中，你只会添加新包裹的记录。
- en: '![](images/00058.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00058.jpg)'
- en: This will update the table on the Dropdown sheet with the content of the `packages`
    table. Together with the data validation that we have set up in Excel, this makes
    sure that all packages appear in the dropdown on the Tracker sheet. You would
    need to give the users a way to call this function directly if you allow the database
    to be populated from outside of your Excel file. This is the case as soon as you
    have multiple users using the same database from different Excel files.
  id: totrans-278
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这将更新Dropdown表中的表格内容到`packages`表格。结合在Excel中设置的数据验证，这确保了所有包裹出现在Tracker表单的下拉列表中。如果你允许数据库从Excel文件外部填充，你需要为用户提供直接调用该函数的方法。一旦你有多个用户从不同的Excel文件访问同一个数据库，这种情况就会发生。
- en: You should be able to follow the other functions in the packagetracker.py file
    with the help of the comments in the code. Let’s now turn our attention to the
    database.py file. The first few lines are shown in [Example 11-2](#filepos1634189).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够通过代码注释来理解packagetracker.py文件中的其他功能。现在让我们转向database.py文件。首几行如[示例 11-2](#filepos1634189)所示。
- en: Example 11-2\. database.py (excerpt with the relevant imports)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-2\. database.py（包含相关导入的摘录）
- en: '`from``pathlib``import``Path``import``sqlalchemy``import``pandas``as``pd``...``#
    We want the database file to sit next to this file.``# Here, we are turning the
    path into an absolute path.``this_dir``=``Path``(``__file__``)``.``resolve``()``.``parent`![](images/00031.jpg)`db_path``=``this_dir``/``"packagetracker.db"``#
    Database engine``engine``=``sqlalchemy``.``create_engine``(``f``"sqlite:///{db_path}"``)`'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`from``pathlib``import``Path``import``sqlalchemy``import``pandas``as``pd``...``#
    我们希望数据库文件与此文件同级。``# 这里，我们将路径转换为绝对路径。``this_dir``=``Path``(``__file__``)``.``resolve``()``.``parent`![](images/00031.jpg)`db_path``=``this_dir``/``"packagetracker.db"``#
    数据库引擎``engine``=``sqlalchemy``.``create_engine``(``f``"sqlite:///{db_path}"``)`'
- en: '![](images/00031.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00031.jpg)'
- en: If you need a refresher of what this line does, have a look at the beginning
    of [Chapter 7](index_split_019.html#filepos863345), where I explain it in the
    code of the sales report.
  id: totrans-283
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你需要对这行代码的作用进行复习，请参考[第7章](index_split_019.html#filepos863345)开头的内容，在销售报告的代码中我有解释。
- en: 'While this snippet is concerned with putting together the path of the database
    file, it also shows you how to get around a common error when you work with any
    sort of file, whether that’s a picture, a CSV file, or, like in this case, a database
    file. When you put together a quick Python script, you may just use a relative
    path as I have done in most of the Jupyter notebook samples:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个片段涉及组合数据库文件路径，但它还展示了如何解决你在处理任何文件时可能遇到的常见错误，无论是图片、CSV文件还是像这种情况下的数据库文件。当你快速编写Python脚本时，你可能只使用相对路径，就像我在大多数Jupyter笔记本示例中所做的那样：
- en: '`engine``=``sqlalchemy``.``create_engine``(``"sqlite:///packagetracker.db"``)`'
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`engine``=``sqlalchemy``.``create_engine``(``"sqlite:///packagetracker.db"``)`'
- en: This works as long as your file is in your working directory. However, when
    you run this code from Excel via `RunPython`, the working directory can be different,
    which will cause Python to look for the file in the wrong folder—you will get
    a `File not found` error. You can solve this issue by providing an absolute path
    or by creating a path the way we do in [Example 11-2](#filepos1634189). This makes
    sure that Python is looking for the file in the same directory as the source file
    even if you execute the code from Excel via `RunPython`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 只要文件在你的工作目录中，这就可以工作。但是，当你通过`RunPython`从Excel运行这段代码时，工作目录可能会不同，这会导致Python在错误的文件夹中查找文件，你将会得到一个`File
    not found`错误。你可以通过提供绝对路径或者像我们在[示例 11-2](#filepos1634189)中那样创建路径来解决这个问题。这确保了即使你通过`RunPython`从Excel执行代码，Python也会在与源文件相同的目录中查找文件。
- en: 'If you want to create the Python Package Tracker from scratch, you will need
    to create the database manually: run the database.py file as a script, for example
    by clicking the Run File button in VS Code. This will create the database file
    packagetracker.db with the two tables. The code that creates the database is found
    at the very bottom of database.py:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从头开始创建Python包跟踪器，你需要手动创建数据库：例如通过在VS Code中点击运行文件按钮来运行database.py文件。这将创建数据库文件packagetracker.db并包含两个表格。创建数据库的代码位于database.py的最底部：
- en: '`if` `__name__` `==``"__main__"``:``create_db``()`'
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`if` `__name__` `==``"__main__"``:``create_db``()`'
- en: While the last line calls the `create_db` function, the meaning of the preceding
    `if` statement is explained in the following tip.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管最后一行调用了`create_db`函数，但前面的`if`语句的含义在以下的提示中有解释。
- en: IF __NAME__ == “__MAIN__”
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: IF __NAME__ == “__MAIN__”
- en: You will see this `if` statement at the bottom of many Python files. It makes
    sure that this code only runs when you run the file as a script, for example,
    from an Anaconda Prompt by running `python database.py` or by clicking the Run
    File button in VS Code. It, however, will not be triggered when you run the file
    by importing it as a module, i.e., by doing `import database` in your code. The
    reason for this is that Python assigns the name `__main__` to the file if you
    run it directly as script, whereas it will be called by its module name (`database`)
    when you run it via the `import` statement. Since Python tracks the file name
    in a variable called `__name__`, the `if` statement will evaluate to `True` only
    when you run it as script; it will not be triggered when you import it from the
    packagetracker.py file.
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您会在许多Python文件的底部看到这个`if`语句。它确保当您以脚本的方式运行代码时才会执行，例如，通过在Anaconda Prompt中运行`python
    database.py`或在VS Code中点击运行文件按钮。但是，当您通过`import database`在您的代码中导入它时，它不会被触发。这是因为Python在直接作为脚本运行时将文件命名为`__main__`，而在通过`import`语句调用时将其称为模块名（`database`）。由于Python在一个名为`__name__`的变量中跟踪文件名，所以`if`语句只在以脚本方式运行时评估为`True`；当您通过在packagetracker.py文件中导入它时，它不会被触发。
- en: The rest of the `database` module runs SQL statements both via SQLAlchemy and
    pandas’ `to_sql` and `read_sql` methods so you get a feeling for both approaches.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`database`模块的其余部分通过SQLAlchemy和pandas的`to_sql`和`read_sql`方法运行SQL语句，这样您可以了解这两种方法的使用感觉。'
- en: MOVING TO POSTGRESQL
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 迁移到POSTGRESQL
- en: If you wanted to replace SQLite with PostgreSQL, a server-based database, there
    are only a few things you need to change. First of all, you need to run `conda
    install psycopg2` (or `pip install psycopg2-binary` if you are not using the Anaconda
    distribution) to install the PostgreSQL driver. Then, in database.py, change the
    connection string in the `create_engine` function to the PostgreSQL version as
    shown in [Table 11-3](#filepos1531478). Finally, to create the tables, you would
    need to change the `INTEGER` data type of `packages.package_id` to the PostgreSQL
    specific notation of `SERIAL`. Creating an auto-incrementing primary key is an
    example of where the SQL dialects differ.
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您想用基于服务器的数据库POSTGRESQL替换SQLite，您只需做几件事情。首先，您需要运行`conda install psycopg2`（或者如果您不使用Anaconda发行版，则运行`pip
    install psycopg2-binary`）来安装POSTGRESQL驱动程序。然后，在database.py中，根据[Table 11-3](#filepos1531478)中显示的POSTGRESQL版本更改`create_engine`函数中的连接字符串。最后，要创建表，您需要将`packages.package_id`的`INTEGER`数据类型更改为POSTGRESQL的特定表示法`SERIAL`。创建自增主键是SQL方言之间差异的一个示例。
- en: 'When you create tools of the complexity of the Python Package Tracker, you
    probably run into a few issues along the way: for example, you might have renamed
    a named range in Excel and forgot to adjust the Python code accordingly. This
    is a good moment to look into how debugging works!'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建像Python包追踪器这样复杂的工具时，您可能会遇到一些问题：例如，您可能已经在Excel中重命名了一个命名范围，但忘记相应地调整Python代码。这是了解调试工作原理的好时机！
- en: Debugging
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 调试
- en: 'To easily debug your xlwings scripts, run your functions directly from VS Code,
    instead of running them by clicking a button in Excel. The following lines at
    the very bottom of the packagetracker.py file will help you with debugging the
    `add_package` function (this is the same code that you will also find at the bottom
    of a `quickstart` project):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便调试您的xlwings脚本，请直接从VS Code运行您的函数，而不是通过在Excel中点击按钮运行它们。在packagetracker.py文件的底部添加以下几行代码，这将帮助您调试`add_package`函数（这段代码也可以在`quickstart`项目的底部找到）：
- en: '`if` `__name__` `==``"__main__"``:`![](images/00031.jpg)`xw``.``Book``(``"packagetracker.xlsm"``)``.``set_mock_caller``()`![](images/00039.jpg)`add_package``()`'
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`if` `__name__` `==``"__main__"``:`![](images/00031.jpg)`xw``.``Book``(``"packagetracker.xlsm"``)``.``set_mock_caller``()`![](images/00039.jpg)`add_package``()`'
- en: '![](images/00031.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00031.jpg)'
- en: We have just seen how this if statement works when we were looking at the database.py
    code; see the previous tip.
  id: totrans-300
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们刚刚看到了这个if语句在查看database.py代码时的工作原理；请参见前面的提示。
- en: '![](images/00039.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00039.jpg)'
- en: 'As this code is only executed when you run the file directly from Python as
    a script, the `set_mock_caller()` command is only meant for debugging purposes:
    when you run the file in VS Code or from an Anaconda Prompt, it sets the `xw.Book.caller()`
    to `xw.Book("packagetracker.xlsm")`. The only purpose of doing this is to be able
    to run your script from both sides, Python and Excel, without having to switch
    the book object within the `add_package` function back and forth between `xw.Book("packagetracker.xlsm")`
    (when you call it from VS Code) and `xw.Book.caller()` (when you call it from
    Excel).'
  id: totrans-302
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当您直接从 Python 作为脚本运行文件时，`set_mock_caller()` 命令仅用于调试目的：当您在 VS Code 中或从 Anaconda
    提示符中运行文件时，它会将 `xw.Book.caller()` 设置为 `xw.Book("packagetracker.xlsm")`。这样做的唯一目的是能够在
    Python 和 Excel 两端运行脚本，而无需在 `add_package` 函数中来回切换 `xw.Book("packagetracker.xlsm")`（从
    VS Code 调用时）和 `xw.Book.caller()`（从 Excel 调用时）的书对象。
- en: Open packagetracker.py in VS Code and set a breakpoint on any line within the
    `add_package` function by clicking to the left of the line numbers. Then hit F5
    and select “Python File” in the dialog to start the debugger and to make your
    code stop at the breakpoint. Make sure to hit F5 instead of using the Run File
    button, as the Run File button ignores breakpoints.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开 packagetracker.py，在 `add_package` 函数的任何行左侧的行号单击设置断点。然后按 F5 并在对话框中选择“Python
    文件”以启动调试器，并使您的代码停在断点处。确保使用 F5 键而不是使用“运行文件”按钮，因为“运行文件”按钮会忽略断点。
- en: DEBUGGING WITH VS CODE AND ANACONDA
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 调试 VS Code 和 Anaconda
- en: 'On Windows, when you run the VS Code debugger for the first time with code
    that uses pandas, you might be greeted by an error: “Exception has occurred: ImportError,
    Unable to import required dependencies: numpy.” This happens because the debugger
    is up and running before the Conda environment has been activated properly. As
    a workaround, stop the debugger by clicking the stop icon and hit F5 again—it
    will work the second time.'
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 Windows 上，第一次使用 VS Code 调试器运行使用 pandas 的代码时，您可能会遇到错误：“异常发生：ImportError，无法导入所需的依赖项：numpy。”这是因为调试器在
    Conda 环境正确激活之前已经启动和运行了。作为解决方法，点击停止图标停止调试器，然后再次按 F5——第二次运行时将正常工作。
- en: 'If you are not familiar with how the debugger in VS Code works, have a look
    at [Appendix B](index_split_030.html#filepos1820886) where I explain all the relevant
    functionality and buttons. We will also pick the topic up again in the respective
    section of the next chapter. If you want to debug a different function, stop the
    current debug session, then adjust the function name at the bottom of your file.
    For example, to debug the `show_history` function, change the last line in packagetracker.py
    as follows before hitting F5 again:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉 VS Code 调试器的工作原理，请参阅[附录 B](index_split_030.html#filepos1820886)，我在那里解释了所有相关功能和按钮。我们也将在下一章的相应部分再次讨论这个主题。如果您想调试不同的函数，请停止当前的调试会话，然后在文件底部调整函数名称。例如，要调试
    `show_history` 函数，请在 packagetracker.py 的最后一行修改如下，然后再次按 F5：
- en: '`if` `__name__` `==``"__main__"``:``xw``.``Book``(``"packagetracker.xlsm"``)``.``set_mock_caller``()``show_history``()`'
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`if` `__name__` `==``"__main__"``:``xw``.``Book``(``"packagetracker.xlsm"``)``.``set_mock_caller``()``show_history``()'
- en: 'On Windows, you could also activate the Show Console checkbox in the xlwings
    add-in, which will show a Command Prompt while the `RunPython` call is running.[2](#filepos1652845)
    This allows you to print additional information to help you debug the issue. For
    example, you could print the value of a variable to inspect it on the Command
    Prompt. After the code has been run, however, the Command Prompt will be closed.
    If you need to keep it open for a little longer, there is an easy trick: add `input()`
    as the last line in your function. This causes Python to wait for user input instead
    of closing the Command Prompt right away. When you’re done with inspecting the
    output, hit Enter in the Command Prompt to close it—just make sure to remove the
    `input()` line again before unchecking the Show Console option!'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，您还可以在 xlwings 插件中激活“显示控制台”复选框，这将在 `RunPython` 调用运行时显示命令提示符。这允许您打印附加信息以帮助调试问题。例如，您可以打印变量的值以在命令提示符上进行检查。然而，代码运行后，命令提示符将会关闭。如果您需要保持它稍长时间打开，有一个简单的技巧：在函数的最后一行添加
    `input()`。这会导致 Python 等待用户输入，而不是立即关闭命令提示符。当您完成检查输出时，在命令提示符中按 Enter 关闭它——只需确保在取消选中“显示控制台”选项之前再次删除
    `input()` 行！
- en: Conclusion
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 结论
- en: This chapter showed you that it’s possible to build reasonably complex applications
    with a minimum of effort. Being able to leverage powerful Python packages like
    Requests or SQLAlchemy makes all the difference to me when I compare this with
    VBA, where talking to external systems is so much harder. If you have similar
    use cases, I would highly recommend you look more closely into both Requests and
    SQLAlchemy—being able to efficiently deal with external data sources will allow
    you to make copy/paste a thing of the past.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章节向您展示了，通过最小的努力就能构建相当复杂的应用程序是可能的。能够利用强大的Python包如Requests或SQLAlchemy对我而言意义重大，特别是当我将其与VBA相比较时，在VBA中与外部系统通信要困难得多。如果您有类似的用例，我强烈建议您更仔细地了解Requests和SQLAlchemy——能够高效处理外部数据源将使您能够让复制/粘贴成为历史。
- en: Instead of clicking buttons, some users prefer to create their Excel tools by
    using cell formulas. The next chapter shows you how xlwings enables you to write
    user-defined functions in Python, allowing you to reuse most of the xlwings concepts
    we’ve learned so far.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 有些用户更喜欢通过使用单元格公式来创建他们的Excel工具，而不是点击按钮。下一章将向您展示xlwings如何使您能够在Python中编写用户定义函数，从而使您能够重复使用我们迄今学到的大部分xlwings概念。
- en: '[1  ](#filepos1563739) In reality, the tool uses `package_name` instead of
    `package_id` to simplify the code.'
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[1  ](#filepos1563739) 实际上，该工具使用`package_name`而不是`package_id`来简化代码。'
- en: '[2  ](#filepos1650741) At the time of this writing, this option is not yet
    available on macOS.'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[2  ](#filepos1650741) 在撰写本文时，此选项在macOS上尚不可用。'
