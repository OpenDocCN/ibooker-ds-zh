- en: Chapter 11\. The Python Package Tracker
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will create a typical business application that downloads
    data from the internet and stores it in a database before visualizing it in Excel.
    This will help you understand what role xlwings plays in such an application and
    allows you to see how easy it is to connect to external systems with Python. In
    an attempt to build a project that is close to a real-world application yet relatively
    simple to follow, I have come up with the Python Package Tracker, an Excel tool
    that shows the number of releases per year for a given Python package. Despite
    being a case study, you might actually find the tool useful to understand if a
    certain Python package is being actively developed or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'After getting acquainted with the application, we’ll go through a few topics
    that we need to understand to be able to follow its code: we’ll see how we can
    download data from the internet and how we can interact with databases before
    we learn about exception handling in Python, an important concept when it comes
    to application development. Once we’re done with these preliminaries, we’ll go
    through the components of the Python Package Tracker to see how everything fits
    together. To wrap this chapter up, we’ll look into how debugging xlwings code
    works. Like the last two chapters, this chapter requires you to have an installation
    of Microsoft Excel on either Windows or macOS. Let’s get started by taking the
    Python Package Tracker for a test drive!'
  prefs: []
  type: TYPE_NORMAL
- en: What We Will Build
  prefs: []
  type: TYPE_NORMAL
- en: 'Head over to the companion repository, where you will find the packagetracker
    folder. There are a couple of files in that folder, but for now just open the
    Excel file packagetracker.xlsm and head over to the Database sheet: we first need
    to get some data into the database to have something to work with. As shown in
    [Figure 11-1](#filepos1490382), type in a package name, for example “xlwings,”
    then click on Add Package. You can choose any package name that exists on the
    [Python Package Index](https://pypi.org) (PyPI).'
  prefs: []
  type: TYPE_NORMAL
- en: 'MACOS: CONFIRM ACCESS TO FOLDER'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When you add the very first package on macOS, you will have to confirm a pop-up
    so that the application can access the packagetracker folder. This is the same
    pop-up we already came across in [Chapter 9](index_split_024.html#filepos1235764).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-1\. The Python Package Tracker (Database sheet)
  prefs: []
  type: TYPE_NORMAL
- en: If everything works according to plan, you will see the message “Added xlwings
    successfully” to the right of where you typed in the package name. Also, you will
    see a Last updated timestamp under the Update Database section as well as an updated
    Log section where it says that it downloaded xlwings successfully and stored it
    to the database. Let’s do this one more time and add the pandas package so we
    have some more data to play around with. Now, switch to the Tracker sheet and
    select xlwings from the dropdown in cell B5 before clicking on Show History. Your
    screen should now look similar to [Figure 11-2](#filepos1491484), showing the
    latest release of the package as well as a chart with the number of releases over
    the years.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/00068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-2\. The Python Package Tracker (Tracker sheet)
  prefs: []
  type: TYPE_NORMAL
- en: 'You could now go back to the Database sheet and add additional packages. Whenever
    you want to update the database with the latest information from PyPI, click on
    the Update Database button: this will synchronize your database with the latest
    data from PyPI.'
  prefs: []
  type: TYPE_NORMAL
- en: After taking a look at how the Python Package Tracker works from a user’s perspective,
    let’s now introduce its core functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Core Functionality
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, I will introduce you to the core functionality of the Python
    Package Tracker: how to fetch data via web APIs and how to query databases. I’ll
    also show you how to handle exceptions, a topic that will inevitably arise when
    writing application code. Let’s get started with web APIs!'
  prefs: []
  type: TYPE_NORMAL
- en: Web APIs
  prefs: []
  type: TYPE_NORMAL
- en: 'Web APIs are one of the most popular ways for an application to fetch data
    from the internet: API stands for application programming interface and defines
    how you interact with an application programmatically. A web API, therefore, is
    an API that is accessed over a network, usually the internet. To understand how
    web APIs work, let’s take a step back and see what happens (in simplified terms)
    when you open a web page in your browser: after entering a URL into the address
    bar, your browser sends a GET request to the server, asking for the web page you
    want. A GET request is a method of the HTTP protocol that your browser uses to
    communicate with the server. When the server receives the request, it responds
    by sending back the requested HTML document, which your browser displays: voilà,
    your web page has loaded. The HTTP protocol has various other methods; the most
    common one—apart from the GET request—is the POST request, which is used to send
    data to the server (for example, when you fill in a contact form on a web page).'
  prefs: []
  type: TYPE_NORMAL
- en: 'While it makes sense for servers to send back a nicely formatted HTML page
    to interact with humans, applications don’t care about design and are only interested
    in the data. Therefore, a GET request to a web API works like requesting a web
    page, but you usually get back the data in JSON instead of HTML format. JSON stands
    for JavaScript Object Notation and is a data structure that is understood by pretty
    much every programming language, which makes it ideal to exchange data between
    different systems. Although the notation is using JavaScript syntax, it’s very
    close to how you use (nested) dictionaries and lists in Python. The differences
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: JSON only accepts double quotes for strings
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: JSON uses `null` where Python uses `None`
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: JSON uses lowercase `true` and `false` while they are capitalized in Python
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: JSON only accepts strings as keys whereas Python dictionaries accept a wide
    range of objects as keys
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `json` module from the standard library allows you to convert a Python
    dictionary to a JSON string and vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``1``]:``import``json`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``2``]:``# A Python dictionary...``user_dict``=``{``"name"``:``"Jane
    Doe"``,``"age"``:``23``,``"married"``:``False``,``"children"``:``None``,``"hobbies"``:``[``"hiking"``,``"reading"``]}`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``3``]:``# ...converted to a JSON string``# by json.dumps ("dump string").
    The "indent" parameter is``# optional and prettifies the printing.``user_json``=``json``.``dumps``(``user_dict``,``indent``=``4``)``print``(``user_json``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`{     "name": "Jane Doe",     "age": 23,     "married": false,     "children":
    null,     "hobbies": [         "hiking",         "reading"     ] }`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``4``]:``# Convert the JSON string back to a native Python data structure``json``.``loads``(``user_json``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[4]: {''name'': ''Jane Doe'',          ''age'': 23,          ''married'':
    False,          ''children'': None,          ''hobbies'': [''hiking'', ''reading'']}`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: REST API
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Instead of web API, you will often see the term REST or RESTful API. REST stands
    for representational state transfer and defines a web API that adheres to certain
    constraints. At its core, the idea of REST is that you access information in the
    form of stateless resources. Stateless means that every request to a REST API
    is completely independent of any other request and needs to always provide the
    full set of information that it requests. Note that the term REST API is often
    misused to mean any sort of web API, even if it doesn’t adhere to the REST constraints.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Consuming web APIs is usually really simple (we’ll see how this works with
    Python in a moment), and almost every service offers one. If you want to download
    your favorite Spotify playlist, you would issue the following GET request (see
    the [Spotify Web API Reference](https://oreil.ly/zcyUh)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET https://api.spotify.com/v1/playlists/``playlist_id`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Or, if you want to get information about your latest Uber trips, you would
    run the following GET request (see the [Uber REST API](https://oreil.ly/FTp-Y)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET https://api.uber.com/v1.2/history`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To use these APIs, though, you need to be authenticated, which usually means
    that you require an account and a token that you can send along with your requests.
    For the Python Package Tracker, we’ll need to fetch data from PyPI to get information
    about the releases of a specific package. Fortunately, PyPI’s web API doesn’t
    require any authentication, so we have one thing less to worry about. When you
    have a look at the [PyPI JSON API docs](https://oreil.ly/yTVjL), you will see
    that there are only two endpoints, i.e., URL fragments that are appended to the
    common base URL, [https://pypi.org/pypi](https://pypi.org/pypi):'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /``project_name``/json GET /``project_name``/``version``/json`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The second endpoint gives you the same information as the first one, but for
    a specific version only. For the Python Package Tracker, the first endpoint is
    all we need to get the details about the past releases of a package, so let’s
    see how this works. In Python, a simple way to interact with a web API is by using
    the Requests package that comes preinstalled with Anaconda. Run the following
    commands to fetch PyPI data about pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``5``]:``import``requests`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``6``]:``response``=``requests``.``get``(``"https://pypi.org/pypi/pandas/json"``)``response``.``status_code`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[6]: 200`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Every response comes with an HTTP status code: for example, `200` means OK
    and `404` means Not Found. You can look up the full list of HTTP response status
    codes in the [Mozilla web docs](https://oreil.ly/HySVq). You may be familiar with
    the status code `404` as your browser sometimes displays it when you click on
    a dead link or type in an address that doesn’t exist. Similarly, you will also
    get a `404` status code if you run a GET request with a package name that doesn’t
    exist on PyPI. To look at the content of the response, it’s easiest to call the
    `json` method of the response object, which will transform the JSON string of
    the response into a Python dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``7``]:``response``.``json``()`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The response is very long, so I am printing a short subset here to allow you
    to understand the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Out[7]: {             ''info'': {                 ''bugtrack_url'': None,
                    ''license'': ''BSD'',                 ''maintainer'': ''The PyData
    Development Team'',                 ''maintainer_email'': ''pydata@googlegroups.com'',
                    ''name'': ''pandas''             },             ''releases'':
    {                 ''0.1'': [                     {                         ''filename'':
    ''pandas-0.1.tar.gz'',                         ''size'': 238458,                        
    ''upload_time'': ''2009-12-25T23:58:31''                     },                    
    {                         ''filename'': ''pandas-0.1.win32-py2.5.exe'',                        
    ''size'': 313639,                         ''upload_time'': ''2009-12-26T17:14:35''
                        }                 ]             }         }`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To get a list with all releases and their dates, something we need for the
    Python Package Tracker, we can run the following code to loop through the `releases`
    dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``8``]:``releases``=``[]``for``version``,``files``in``response``.``json``()[``''releases''``]``.``items``():``releases``.``append``(``f``"{version}:
    {files[0][''upload_time'']}"``)``releases``[:``3``]``# show the first 3 elements
    of the list`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[8]: [''0.1: 2009-12-25T23:58:31'',          ''0.10.0: 2012-12-17T16:52:06'',
             ''0.10.1: 2013-01-22T05:22:09'']`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that we are arbitrarily picking the release timestamp from the package
    that appears first in the list. A specific release often has multiple packages
    to account for different versions of Python and operating systems. To wrap this
    topic up, you may remember from [Chapter 5](index_split_015.html#filepos482650)
    that pandas has a `read_json` method to return a DataFrame directly from a JSON
    string. This, however, wouldn’t help us here as the response from PyPI isn’t in
    a structure that can be directly transformed into a DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: This was a short introduction to web APIs to understand their use in the code
    base of the Python Package Tracker. Let’s now see how we can communicate with
    databases, the other external system that we make use of in our application!
  prefs: []
  type: TYPE_NORMAL
- en: Databases
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to use the data from PyPI even when you’re not connected to the
    internet, you need to store it after downloading. While you could store your JSON
    responses as text files on disk, a far more comfortable solution is to use a database:
    this allows you to query your data in an easy way. The Python Package Tracker
    is using [SQLite](https://sqlite.org), a relational database. Relational database
    systems get their name from relation, which refers to the database table itself
    (and not to the relation between tables, which is a common misconception): their
    highest goal is data integrity, which they achieve by splitting the data up into
    different tables (a process called normalization) and by applying constraints
    to avoid inconsistent and redundant data. Relational databases use SQL (Structured
    Query Language) to perform database queries and are among the most popular server-based
    relational database systems are [SQL Server](https://oreil.ly/XZOI9), [Oracle](https://oreil.ly/VKWE0),
    [PostgreSQL](https://oreil.ly/VAEqY), and [MySQL](https://mysql.com). As an Excel
    user, you may also be familiar with the file-based [Microsoft Access](https://oreil.ly/bRh6Q)
    database.'
  prefs: []
  type: TYPE_NORMAL
- en: NOSQL DATABASES
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'These days, relational databases have strong competition from NoSQL databases
    that store redundant data in an attempt to achieve the following advantages:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: No table joins
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Since relational databases split their data across multiple tables, you often
    need to combine the information from two or more tables by joining them, which
    sometimes can be slow. This is not required with NoSQL databases, which can result
    in better performance for certain types of queries.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: No database migrations
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With relational database systems, every time you make a change to the table
    structure, e.g., by adding a new column to a table, you must run a database migration.
    A migration is a script that brings the database into the desired new structure.
    This makes the deployment of new versions of an application more complex, potentially
    resulting in downtime, something that is easier to avoid with NoSQL databases.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Easier to scale
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: NoSQL databases are easier to distribute across multiple servers as there are
    no tables that are dependent on each other. This means that an application that
    uses a NoSQL database may scale better when your user base skyrockets.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'NoSQL databases come in many flavors: some databases are simple key-value stores,
    i.e., work similarly to a dictionary in Python (e.g., [Redis](https://redis.io));
    others allow the storage of documents, often in JSON format (e.g., [MongoDB](https://mongodb.com)).
    Some databases even combine the relational and NoSQL worlds: PostgreSQL, which
    happens to be one of the most popular databases in the Python community, is traditionally
    a relational database but also allows you to store data in JSON format—without
    losing the ability to query it via SQL.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLite, the database we’re going to use, is a file-based database like Microsoft
    Access. However, in contrast to Microsoft Access, which only works on Windows,
    SQLite works on all platforms that Python supports. On the other hand, SQLite
    doesn’t allow you to build a user interface like Microsoft Access, but Excel comes
    in handy for this part.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now have a look at the structure of the Package Tracker’s database before
    finding out how we can use Python to connect to databases and make SQL queries.
    Then, to conclude this introduction about databases, we’ll have a look at SQL
    injections, a popular vulnerability of database-driven applications.
  prefs: []
  type: TYPE_NORMAL
- en: The Package Tracker database
  prefs: []
  type: TYPE_NORMAL
- en: 'The database of the Python Package Tracker couldn’t be any simpler as it only
    has two tables: the table `packages` stores the package name and the table `package_versions`
    stores the version strings and the date of the upload. The two tables can be joined
    on the `package_id`: rather than storing the `package_name` with every row in
    the `package_versions` table, it has been normalized into the `packages` table.
    This gets rid of redundant data—name changes, for example, only have to be done
    in a single field across the entire database. To get a better idea about how the
    database looks with the xlwings and pandas packages loaded, have a look at Tables
    [11-1](#filepos1521167) and [11-2](#filepos1522247).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 11-1\. The packages table
  prefs: []
  type: TYPE_NORMAL
- en: '|  package_id  |  package_name  |'
  prefs: []
  type: TYPE_TB
- en: '|   `1` |   `xlwings` |'
  prefs: []
  type: TYPE_TB
- en: '|   `2` |   `pandas` |'
  prefs: []
  type: TYPE_TB
- en: Table 11-2\. The package_versions table (first three rows of each package_id)
  prefs: []
  type: TYPE_NORMAL
- en: '|  package_id  |  version_string  |  uploaded_at  |'
  prefs: []
  type: TYPE_TB
- en: '|   `1` |   `0.1.0` |   `2014-03-19 18:18:49.000000` |'
  prefs: []
  type: TYPE_TB
- en: '|   `1` |   `0.1.1` |   `2014-06-27 16:26:36.000000` |'
  prefs: []
  type: TYPE_TB
- en: '|   `1` |   `0.2.0` |   `2014-07-29 17:14:22.000000` |'
  prefs: []
  type: TYPE_TB
- en: '|   `...` |   `...` |   `...` |'
  prefs: []
  type: TYPE_TB
- en: '|   `2` |   `0.1` |   `2009-12-25 23:58:31.000000` |'
  prefs: []
  type: TYPE_TB
- en: '|   `2` |   `0.2beta` |   `2010-05-18 15:05:11.000000` |'
  prefs: []
  type: TYPE_TB
- en: '|   `2` |   `0.2b1` |   `2010-05-18 15:09:05.000000` |'
  prefs: []
  type: TYPE_TB
- en: '|   `...` |   `...` |   `...` |'
  prefs: []
  type: TYPE_TB
- en: '[Figure 11-3](#filepos1528772) is a database diagram that shows the two tables
    again schematically. You can read off the table and column names and get information
    about the primary and foreign keys:'
  prefs: []
  type: TYPE_NORMAL
- en: Primary key
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases require every table to have a primary key. A primary key
    is one or more columns that uniquely identify a row (a row is also called a record).
    In the case of the `packages` table, the primary key is `package_id` and in the
    case of the `package_versions` table, the primary key is a so-called composite
    key, i.e., a combination of `package_id` and `version_string`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Foreign key
  prefs: []
  type: TYPE_NORMAL
- en: 'The column `package_id` in the `package_versions` table is a foreign key to
    the same column in the `packages` table, symbolized by the line that connects
    the tables: a foreign key is a constraint that, in our case, ensures that every
    `package_id` in the `package_versions` table exists in the `packages` table—this
    guarantees data integrity. The branches at the right end of the connection line
    symbolize the nature of the relationship: one `package` can have many `package_versions`,
    which is called a one-to-many relationship.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-3\. Database diagram (primary keys are bold)
  prefs: []
  type: TYPE_NORMAL
- en: To have a look at the content of the database tables and run SQL queries, you
    could install a VS Code extension called SQLite (please see the [SQLite extension
    docs](https://oreil.ly/nP4mC) for more details) or use a dedicated SQLite management
    software, of which there are plenty. We, however, will be using Python to run
    SQL queries. Before anything else, let’s see how we can connect to a database!
  prefs: []
  type: TYPE_NORMAL
- en: Database connections
  prefs: []
  type: TYPE_NORMAL
- en: To connect to a database from Python, you need a driver, i.e., a Python package
    that knows how to communicate with the database you are using. Each database requires
    a different driver and each driver uses a different syntax, but luckily, there
    is a powerful package called [SQLAlchemy](https://sqlalchemy.org) that abstracts
    away most of the differences between the various databases and drivers. SQLAlchemy
    is mostly used as an object relational mapper (ORM) that translates your database
    records into Python objects, a concept that many developers—albeit not all—find
    more natural to work with. To keep things simple, we’re ignoring the ORM functionality
    and only using SQLAlchemy to make it easier to run raw SQL queries. SQLAlchemy
    is also used behind the scenes when you use pandas to read and write database
    tables in the form of DataFrames. Running a database query from pandas involves
    three levels of packages—pandas, SQLAlchemy, and the database driver—as shown
    in [Figure 11-4](#filepos1530880). You can run database queries from each of these
    three levels.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-4\. Accessing databases from Python
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 11-3](#filepos1531478) shows you which driver SQLAlchemy uses by default
    (some databases can be used with more than one driver). It also gives you the
    format of the database connection string—we’ll use the connection string in a
    moment when we will run actual SQL queries.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 11-3\. SQLAlchemy default drivers and connection strings
  prefs: []
  type: TYPE_NORMAL
- en: '|  Database  |  Default Driver  |  Connection String  |'
  prefs: []
  type: TYPE_TB
- en: '|  SQLite  |   `sqlite3` |   `sqlite:///``filepath` |'
  prefs: []
  type: TYPE_TB
- en: '|  PostgreSQL  |   `psycopg2` |   `postgresql://``username``:``password``@``host``:``port``/``database`
    |'
  prefs: []
  type: TYPE_TB
- en: '|  MySQL  |   `mysql-python` |   `mysql://``username``:``password``@``host``:``port``/``database`
    |'
  prefs: []
  type: TYPE_TB
- en: '|  Oracle  |   `cx_oracle` |   `oracle://``username``:``password``@``host``:``port``/``database`
    |'
  prefs: []
  type: TYPE_TB
- en: '|  SQL Server  |   `pyodbc` |   `mssql+pyodbc://``username``:``password``@``host``:``port``/``database`
    |'
  prefs: []
  type: TYPE_TB
- en: 'Except for SQLite, you usually need a password to connect to a database. And
    since connection strings are URLs, you will have to use the URL encoded version
    of your passwords if you have any special characters in them. Here is how you
    can print the URL encoded version of your password:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``9``]:``import``urllib.parse`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``10``]:``urllib``.``parse``.``quote_plus``(``"pa$$word"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[10]: ''pa%24%24word''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Having introduced pandas, SQLAlchemy, and the database driver as the three levels
    from which we can connect to databases, let’s see how they compare in practice
    by making a few SQL queries!
  prefs: []
  type: TYPE_NORMAL
- en: SQL queries
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if you are new to SQL, you should have no trouble understanding the few
    SQL queries that I will use in the following samples and in the Python Package
    Tracker. SQL is a declarative language, which means that you tell the database
    what you want instead of what to do. Some queries almost read like plain English:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT``*``FROM``packages`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This tells the database that you want to select all columns from the packages
    table. In production code, you wouldn’t want to use the wildcard `*` which means
    all columns but rather specify each column explicitly as this makes your query
    less error-prone:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT``package_id``,``package_name``FROM``packages`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: DATABASE QUERIES VS. PANDAS DATAFRAMES
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'SQL is a set-based language, which means that you operate on a set of rows
    rather than looping through individual rows. This is very similar to how you work
    with pandas DataFrames. The SQL query:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`SELECT``package_id``,``package_name``FROM``packages`'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'corresponds to the following pandas expression (assuming that `packages` is
    a DataFrame):'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`packages``.``loc``[:,``[``"package_id"``,``"package_name"``]]`'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following code samples use the packagetracker.db file that you will find
    in the packagetracker folder of the companion repo. The examples expect that you
    have already added xlwings and pandas to the database via the Python Package Tracker’s
    Excel frontend like we did at the beginning of this chapter—otherwise you would
    get only empty results. Following [Figure 11-4](#filepos1530880) from bottom to
    top, we will first make our SQL query from the driver directly, then use SQLAlchemy
    and finally pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``11``]:``# Let''s start with the imports``import``sqlite3``from``sqlalchemy``import``create_engine``import``pandas``as``pd`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``12``]:``# Our SQL query: "select all columns from the packages table"``sql``=``"SELECT
    * FROM packages"`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``13``]:``# Option 1: Database driver (sqlite3 is part of the standard
    library)``# Using the connection as context manager automatically commits``# the
    transaction or rolls it back in case of an error.``with``sqlite3``.``connect``(``"packagetracker/packagetracker.db"``)``as``con``:``cursor``=``con``.``cursor``()``#
    We need a cursor to run SQL queries``result``=``cursor``.``execute``(``sql``)``.``fetchall``()``#
    Return all records``result`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[13]: [(1, ''xlwings''), (2, ''pandas'')]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``14``]:``# Option 2: SQLAlchemy``# "create_engine" expects the connection
    string of your database.``# Here, we can execute a query as a method of the connection
    object.``engine``=``create_engine``(``"sqlite:///packagetracker/packagetracker.db"``)``with``engine``.``connect``()``as``con``:``result``=``con``.``execute``(``sql``)``.``fetchall``()``result`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[14]: [(1, ''xlwings''), (2, ''pandas'')]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``15``]:``# Option 3: pandas``# Providing a table name to "read_sql"
    reads the full table.``# Pandas requires an SQLAlchemy engine that we reuse from``#
    the previous example.``df``=``pd``.``read_sql``(``"packages"``,``engine``,``index_col``=``"package_id"``)``df`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[15]:            package_name          package_id          1              
    xlwings          2                pandas`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``16``]:``# "read_sql" also accepts an SQL query``pd``.``read_sql``(``sql``,``engine``,``index_col``=``"package_id"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[16]:            package_name          package_id          1              
    xlwings          2                pandas`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``17``]:``# The DataFrame method "to_sql" writes DataFrames to tables``#
    "if_exists" has to be either "fail", "append" or "replace"``# and defines what
    happens if the table already exists``df``.``to_sql``(``"packages2"``,``con``=``engine``,``if_exists``=``"append"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``18``]:``# The previous command created a new table "packages2" and``#
    inserted the records from the DataFrame df as we can``# verify by reading it back``pd``.``read_sql``(``"packages2"``,``engine``,``index_col``=``"package_id"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[18]:            package_name          package_id          1              
    xlwings          2                pandas`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``19``]:``# Let''s get rid of the table again by running the``# "drop
    table" command via SQLAlchemy``with``engine``.``connect``()``as``con``:``con``.``execute``(``"DROP
    TABLE packages2"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Whether you should use the database driver, SQLAlchemy, or pandas to run your
    queries largely depends on your preferences: I personally like the fine-grained
    control you get by using SQLAlchemy and enjoy that I can use the same syntax with
    different databases. On the other hand, pandas’ `read_sql` is convenient to get
    the result of a query in the form of a DataFrame.'
  prefs: []
  type: TYPE_NORMAL
- en: FOREIGN KEYS WITH SQLITE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Somewhat surprisingly, SQLite does not respect foreign keys by default when
    running queries. However, if you use SQLAlchemy, you can easily enforce foreign
    keys; see the [SQLAlchemy docs](https://oreil.ly/6YPvC). This will also work if
    you run the queries from pandas. You will find the respective code at the top
    of the database.py module in the packagetracker folder of the companion repository.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that you know how to run simple SQL queries, let’s wrap this section up
    by looking at SQL injections, which can pose a security risk to your application.
  prefs: []
  type: TYPE_NORMAL
- en: SQL injection
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t protect your SQL queries properly, a malicious user can run arbitrary
    SQL code by injecting SQL statements into data input fields: for example, instead
    of selecting a package name like xlwings in the dropdown of the Python Package
    Tracker, they could send an SQL statement that changes your intended query. This
    can expose sensitive information or perform destructive actions like deleting
    a table. How can you prevent this? Let’s first have a look at the following database
    query, which the Package Tracker runs when you select xlwings and click on Show
    History:[1](#filepos1652489)'
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT``v``.``uploaded_at``,``v``.``version_string``FROM``packages``p``INNER``JOIN``package_versions``v``ON``p``.``package_id``=``v``.``package_id``WHERE``p``.``package_id``=``1`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This query joins the two tables together and only returns those rows where
    the `package_id` is `1`. To help you understand this query based on what we learned
    in [Chapter 5](index_split_015.html#filepos482650), if `packages` and `package_versions`
    were pandas DataFrames, you could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '`df``=``packages``.``merge``(``package_versions``,``how``=``"inner"``,``on``=``"package_id"``)``df``.``loc``[``df``[``"package_id"``]``==``1``,``[``"uploaded_at"``,``"version_string"``]]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It’s obvious that the `package_id` needs to be a variable where we now have
    a hardcoded `1` to return the correct rows depending on the package that is selected.
    Knowing about f-strings from [Chapter 3](index_split_010.html#filepos178328),
    you could be tempted to change the last line of the SQL query like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`f``"WHERE p.package_id = {package_id}"`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'While this would technically work, you must never do this as it opens up the
    door for SQL injection: for example, somebody could send `''1 OR TRUE''` instead
    of an integer representing the `package_id`. The resulting query would return
    the rows of the whole table instead of just those where the `package_id` is `1`.
    Therefore, always use the syntax that SQLAlchemy offers you for placeholders (they
    start with a colon):'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``20``]:``# Let''s start by importing SQLAlchemy''s text function``from``sqlalchemy.sql``import``text`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``21``]:``# ":package_id" is the placeholder``sql``=``"""``         SELECT
    v.uploaded_at, v.version_string``         FROM packages p``         INNER JOIN
    package_versions v ON p.package_id = v.package_id``         WHERE p.package_id
    = :package_id``         ORDER BY v.uploaded_at``         """`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``22``]:``# Via SQLAlchemy``with``engine``.``connect``()``as``con``:``result``=``con``.``execute``(``text``(``sql``),``package_id``=``1``)``.``fetchall``()``result``[:``3``]``#
    Print the first 3 records`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[22]: [(''2014-03-19 18:18:49.000000'', ''0.1.0''),           (''2014-06-27
    16:26:36.000000'', ''0.1.1''),           (''2014-07-29 17:14:22.000000'', ''0.2.0'')]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``23``]:``# Via pandas``pd``.``read_sql``(``text``(``sql``),``engine``,``parse_dates``=``[``"uploaded_at"``],``params``=``{``"package_id"``:``1``},``index_col``=``[``"uploaded_at"``])``.``head``(``3``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[23]:                     version_string          uploaded_at         
    2014-03-19 18:18:49          0.1.0          2014-06-27 16:26:36          0.1.1
             2014-07-29 17:14:22          0.2.0`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Wrapping the SQL query with SQLAlchemy’s `text` function has the advantage
    that you can use the same syntax for placeholders across different databases.
    Otherwise, you’d have to use the placeholder that the database driver uses: `sqlite3`
    uses `?` and `psycopg2` uses `%s`, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: You may argue that SQL injection isn’t much of an issue when your users have
    direct access to Python and could run arbitrary code on the database anyway. But
    if you take your xlwings prototype and transform it into a web application one
    day, it will become a huge issue, so it’s better to do it properly from the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides web APIs and databases, there is another topic that we have jumped
    over so far that is indispensable for solid application development: exception
    handling. Let’s see how it works!'
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs: []
  type: TYPE_NORMAL
- en: 'I mentioned exception handling in [Chapter 1](index_split_007.html#filepos32075)
    as an example of where VBA with its GoTo mechanism has fallen behind. In this
    section, I show you how Python uses the try/except mechanism to handle errors
    in your programs. Whenever something is outside of your control, errors can and
    will happen. For example, the email server may be down when you try to send an
    email, or a file may be missing that your program expects—in the case of the Python
    Package Tracker, this could be the database file. Dealing with user input is another
    area where you have to prepare for inputs that don’t make sense. Let’s get some
    practice—if the following function is called with a zero, you will get a `ZeroDivisionError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``24``]:``def``print_reciprocal``(``number``):``result``=``1``/``number``print``(``f``"The
    reciprocal is: {result}"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``25``]:``print_reciprocal``(``0``)``# This will raise an error`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`---------------------------------------------------------------------------
    ZeroDivisionError                         Traceback (most recent call last) <ipython-input-25-095f19ebb9e9>
    in <module> ----> 1 print_reciprocal(0)  # This will raise an error  <ipython-input-24-88fdfd8a4711>
    in print_reciprocal(number)       1 def print_reciprocal(number): ----> 2    
    result = 1 / number       3     print(f"The reciprocal is: {result}")  ZeroDivisionError:
    division by zero`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To let your program react gracefully to such errors, use the try/except statements
    (this is the equivalent of the VBA sample in [Chapter 1](index_split_007.html#filepos32075)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``26``]:``def``print_reciprocal``(``number``):``try``:``result``=``1``/``number``except``Exception``as``e``:``#
    "as e" makes the Exception object available as variable "e"``# "repr" stands for
    "printable representation" of an object``# and gives you back a string with the
    error message``print``(``f``"There was an error: {repr(e)}"``)``result``=``"N/A"``else``:``print``(``"There
    was no error!"``)``finally``:``print``(``f``"The reciprocal is: {result}"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Whenever an error occurs in the `try` block, code execution moves on to the
    `except` block where you can handle the error: this allows you to give the user
    helpful feedback or write the error to a log file. The `else` clause only runs
    if there is no error raised during the `try` block and the `finally` block runs
    always, whether or not an error was raised. Often, you will get away with just
    the `try` and `except` blocks. Let’s see the output of the function given different
    inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``27``]:``print_reciprocal``(``10``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`There was no error! The reciprocal is: 0.1`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``28``]:``print_reciprocal``(``"a"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`There was an error: TypeError("unsupported operand type(s) for /: ''int''
    and ''str''") The reciprocal is: N/A`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``29``]:``print_reciprocal``(``0``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`There was an error: ZeroDivisionError(''division by zero'') The reciprocal
    is: N/A`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The way that I have used the except statement means that any exception that
    happens in the `try` block will cause the code execution to continue in the `except`
    block. Usually, that is not what you want. You want to check for an error as specific
    as possible and handle only those you expect. Your program may otherwise fail
    for something completely unexpected, which makes it hard to debug. To fix this,
    rewrite the function as follows, checking explicitly for the two errors that we
    expect (I am leaving away the `else` and `finally` statements):'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``30``]:``def``print_reciprocal``(``number``):``try``:``result``=``1``/``number``print``(``f``"The
    reciprocal is: {result}"``)``except``(``TypeError``,``ZeroDivisionError``):``print``(``"Please
    type in any number except 0."``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let’s run the code again:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``31``]:``print_reciprocal``(``"a"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Please type in any number except 0.`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you want to handle an error differently depending on the exception, handle
    them separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``32``]:``def``print_reciprocal``(``number``):``try``:``result``=``1``/``number``print``(``f``"The
    reciprocal is: {result}"``)``except``TypeError``:``print``(``"Please type in a
    number."``)``except``ZeroDivisionError``:``print``(``"The reciprocal of 0 is not
    defined."``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``33``]:``print_reciprocal``(``"a"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Please type in a number.`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``34``]:``print_reciprocal``(``0``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`The reciprocal of 0 is not defined.`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that you know about error handling, web APIs, and databases, you are ready
    to move on to the next section, where we’ll go through each component of the Python
    Package Tracker.
  prefs: []
  type: TYPE_NORMAL
- en: Application Structure
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll look behind the scenes of the Python Package Tracker
    to understand how everything works. First, we’ll walk through the application’s
    frontend, i.e., the Excel file, before looking at its backend, i.e., the Python
    code. To wrap this section up, we’ll see how debugging an xlwings project works,
    a useful skill with projects of the size and complexity of the Package Tracker.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the packagetracker directory in the companion repo, you’ll find four files.
    Do you remember when I talked about separation of concerns in [Chapter 1](index_split_007.html#filepos32075)?
    We are now able to map these files to the different layers as shown in [Table 11-4](#filepos1602253):'
  prefs: []
  type: TYPE_NORMAL
- en: Table 11-4\. Separation of concerns
  prefs: []
  type: TYPE_NORMAL
- en: '|  Layer  |  File  |  Description  |'
  prefs: []
  type: TYPE_TB
- en: '|  Presentation layer  |   `packagetracker.xlsm` |  This is the frontend and
    as such the only file the end-user interacts with.  |'
  prefs: []
  type: TYPE_TB
- en: '|  Business layer  |   `packagetracker.py` |  This module handles the data
    download via web API and does the number crunching with pandas.  |'
  prefs: []
  type: TYPE_TB
- en: '|  Data layer  |   `database.py` |  This module handles all database queries. 
    |'
  prefs: []
  type: TYPE_TB
- en: '|  Database  |   `packagetracker.db` |  This is an SQLite database file.  |'
  prefs: []
  type: TYPE_TB
- en: In this context, it’s worth mentioning that the presentation layer, i.e., the
    Excel file, doesn’t contain a single cell formula, which makes the tool much easier
    to audit and control.
  prefs: []
  type: TYPE_NORMAL
- en: MODEL-VIEW-CONTROLLER (MVC)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Separation of concerns has many faces and the breakdown as shown in [Table 11-4](#filepos1602253)
    is just one possibility. Another popular design pattern that you may run into
    relatively quickly is called model-view-controller (MVC). In the MVC world, the
    core of the application is the model where all the data and usually most of the
    business logic is handled. While the view corresponds to the presentation layer,
    the controller is only a thin layer that sits between the model and the view to
    make sure that they are always in sync. To keep things simple, I am not using
    the MVC pattern in this book.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that you know what each file is responsible for, let’s move on and have
    a closer look at how the Excel frontend has been set up!
  prefs: []
  type: TYPE_NORMAL
- en: Frontend
  prefs: []
  type: TYPE_NORMAL
- en: 'When you build a web application, you differentiate between the frontend, which
    is the part of the application that runs in your browser, and the backend, which
    is the code that runs on the server. We can apply the same terminology with xlwings
    tools: the frontend is the Excel file and the backend is the Python code that
    you call via `RunPython`. If you want to build the frontend from scratch, begin
    with running the following command on an Anaconda Prompt (make sure to `cd` first
    into the directory of your choice):'
  prefs: []
  type: TYPE_NORMAL
- en: '`(base)>` `xlwings quickstart packagetracker`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Navigate to the packagetracker directory and open packagetracker.xlsm in Excel.
    Start by adding the three tabs, Tracker, Database and Dropdown, as shown in [Figure 11-5](#filepos1607351).
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/00024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-5\. Building the user interface
  prefs: []
  type: TYPE_NORMAL
- en: 'While you should be able to take over the text and formatting from [Figure 11-5](#filepos1607351),
    I need to give you a few more details about the things that aren’t visible:'
  prefs: []
  type: TYPE_NORMAL
- en: Buttons
  prefs: []
  type: TYPE_NORMAL
- en: To make the tool look a bit less like Windows 3.1, I didn’t use the standard
    macro buttons that we used in the previous chapter. Instead, I went to Insert
    > Shapes and inserted a Rounded Rectangle. If you want to use the standard button,
    that’s fine, too, but at this point, don’t assign a macro just yet.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Named ranges
  prefs: []
  type: TYPE_NORMAL
- en: To make the tool a little easier to maintain, we will use named ranges rather
    than cell addresses in the Python code. Therefore, add the named ranges as shown
    in [Table 11-5](#filepos1608689).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Table 11-5\. Named ranges
  prefs: []
  type: TYPE_NORMAL
- en: '|  Sheet  |  Cell  |  Name  |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Tracker
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: B5
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`package_selection`'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Tracker
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: B11
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`latest_release`'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: B5
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`new_package`'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: B13
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`updated_at`'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: B18
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`log`'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: One way to add named ranges is to select the cell, then write the name into
    the Name Box and finally confirm by hitting Enter, as in [Figure 11-6](#filepos1612557).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00019.jpg)'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_IMG
- en: Figure 11-6\. The Name Box
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Tables
  prefs: []
  type: TYPE_NORMAL
- en: On the Dropdown sheet, after typing “packages” into cell A1, select A1, then
    go to Insert > Table and make sure to activate the checkbox next to “My table
    has headers.” To finalize, with the table selected, go to the ribbon tab Table
    Design (Windows) or Table (macOS) and rename the table from `Table1` to `dropdown_content`,
    as shown in [Figure 11-7](#filepos1613484).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00010.jpg)'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_IMG
- en: Figure 11-7\. Renaming an Excel table
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Data Validation
  prefs: []
  type: TYPE_NORMAL
- en: 'We use data validation to provide the dropdown in cell B5 on the Tracker sheet.
    To add it, select cell B5, then go to Data > Data Validation and under Allow,
    select List. Under source set the following formula:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`=INDIRECT("dropdown_content[packages]")`'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Then, confirm with OK. This is just a reference to the body of the table, but
    since Excel doesn’t accept a table reference directly, we have to wrap it in an
    `INDIRECT` formula, which resolves the table to its address. Still, by using a
    table, it will properly resize the range that is shown in the dropdown when we
    add more packages.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Conditional Formatting
  prefs: []
  type: TYPE_NORMAL
- en: 'When you add a package, there can be a few errors that we’d like to show to
    the user: the field could be empty, the package may already exist on the database,
    or it may be missing on PyPI. To show the error in red and other messages in black,
    we’ll use a simple trick based on conditional formatting: we want a red font whenever
    the message contains the word “error.” On the Database sheet, select cell C5,
    which is where we’ll write out the message. Then go to Home > Conditional Formatting
    > Highlight Cells Rules > Text that contains. Enter the value `error` and select
    Red Text in the dropdown as shown in [Figure 11-8](#filepos1615769), then click
    on OK. Apply the same conditional format to cell C5 on the Tracker sheet.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00029.jpg)'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_IMG
- en: Figure 11-8\. Conditional Formatting on Windows (left) and macOS (right)
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Gridlines
  prefs: []
  type: TYPE_NORMAL
- en: On the Tracker and Database sheets, the gridlines have been hidden by unchecking
    the View checkbox under Page Layout > Gridlines.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'At this point, the user interface is complete and should look like [Figure 11-5](#filepos1607351).
    We now need to add the `RunPython` calls in the VBA editor and connect them with
    the buttons. Click Alt+F11 (Windows) or Option-F11 (macOS) to open the VBA editor,
    then, under the VBAProject of packagetracker.xlsm, double-click Module1 on the
    lefthand side under Modules to open it. Delete the existing `SampleCall` code
    and replace it with the following macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Sub``AddPackage``()``RunPython``"import packagetracker; packagetracker.add_package()"``End``Sub``Sub``ShowHistory``()``RunPython``"import
    packagetracker; packagetracker.show_history()"``End``Sub``Sub``UpdateDatabase``()``RunPython``"import
    packagetracker; packagetracker.update_database()"``End``Sub`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, right-click on each button, select Assign Macro and select the macro that
    corresponds to the button. [Figure 11-9](#filepos1619526) shows the Show History
    button, but it works the same for the Add Package and Update Database buttons.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-9\. Assign the ShowHistory macro to the Show History button
  prefs: []
  type: TYPE_NORMAL
- en: The frontend is now done and we can move on with the Python backend.
  prefs: []
  type: TYPE_NORMAL
- en: Backend
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of the two Python files packagetracker.py and database.py is too long
    to be shown here, so you will need to open them from the companion repository
    in VS Code. I will, however, refer to a couple of code snippets in this section
    to explain a few key concepts. Let’s see what happens when you click the Add Package
    button on the Database sheet. The button has the following VBA macro assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Sub``AddPackage``()``RunPython``"import packagetracker; packagetracker.add_package()"``End``Sub`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As you see, the `RunPython` function calls the `add_package` Python function
    in the `packagetracker` module as shown in [Example 11-1](#filepos1621971).
  prefs: []
  type: TYPE_NORMAL
- en: NO PRODUCTION CODE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The application is kept as simple as possible to make it easy to follow—it
    doesn’t check for every possible thing that can go wrong. In a production environment,
    you’d want to make it more robust: for example, you would show a user-friendly
    error if it can’t find the database file.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Example 11-1\. The `add_package` function in packagetracker.py (without comments)
  prefs: []
  type: TYPE_NORMAL
- en: '`def``add_package``():``db_sheet``=``xw``.``Book``.``caller``()``.``sheets``[``"Database"``]``package_name``=``db_sheet``[``"new_package"``]``.``value``feedback_cell``=``db_sheet``[``"new_package"``]``.``offset``(``column_offset``=``1``)``feedback_cell``.``clear_contents``()``if``not``package_name``:``feedback_cell``.``value``=``"Error:
    Please provide a name!"`![](images/00031.jpg)`return``if``requests``.``get``(``f``"{BASE_URL}/{package_name}/json"``,``timeout``=``6``)``.``status_code``!=``200``:`![](images/00039.jpg)`feedback_cell``.``value``=``"Error:
    Package not found!"``return``error``=``database``.``store_package``(``package_name``)`![](images/00050.jpg)`db_sheet``[``"new_package"``]``.``clear_contents``()``if``error``:``feedback_cell``.``value``=``f``"Error:
    {error}"``else``:``feedback_cell``.``value``=``f``"Added {package_name} successfully."``update_database``()`![](images/00067.jpg)`refresh_dropdown``()`![](images/00058.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/00031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The “error” in the feedback message will trigger the red font in Excel via conditional
    formatting.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By default, Requests is waiting forever for a response which could lead the
    application to “hang” in cases where PyPI has an issue and is responding slowly.
    That’s why for production code, you should always include an explicit `timeout`
    parameter.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `store_package` function returns `None` if the operation was successful
    and a string with the error message otherwise.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To keep things simple, the whole database is updated. In a production environment,
    you would only add the records of the new package.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This will update the table on the Dropdown sheet with the content of the `packages`
    table. Together with the data validation that we have set up in Excel, this makes
    sure that all packages appear in the dropdown on the Tracker sheet. You would
    need to give the users a way to call this function directly if you allow the database
    to be populated from outside of your Excel file. This is the case as soon as you
    have multiple users using the same database from different Excel files.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: You should be able to follow the other functions in the packagetracker.py file
    with the help of the comments in the code. Let’s now turn our attention to the
    database.py file. The first few lines are shown in [Example 11-2](#filepos1634189).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-2\. database.py (excerpt with the relevant imports)
  prefs: []
  type: TYPE_NORMAL
- en: '`from``pathlib``import``Path``import``sqlalchemy``import``pandas``as``pd``...``#
    We want the database file to sit next to this file.``# Here, we are turning the
    path into an absolute path.``this_dir``=``Path``(``__file__``)``.``resolve``()``.``parent`![](images/00031.jpg)`db_path``=``this_dir``/``"packagetracker.db"``#
    Database engine``engine``=``sqlalchemy``.``create_engine``(``f``"sqlite:///{db_path}"``)`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/00031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you need a refresher of what this line does, have a look at the beginning
    of [Chapter 7](index_split_019.html#filepos863345), where I explain it in the
    code of the sales report.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'While this snippet is concerned with putting together the path of the database
    file, it also shows you how to get around a common error when you work with any
    sort of file, whether that’s a picture, a CSV file, or, like in this case, a database
    file. When you put together a quick Python script, you may just use a relative
    path as I have done in most of the Jupyter notebook samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`engine``=``sqlalchemy``.``create_engine``(``"sqlite:///packagetracker.db"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This works as long as your file is in your working directory. However, when
    you run this code from Excel via `RunPython`, the working directory can be different,
    which will cause Python to look for the file in the wrong folder—you will get
    a `File not found` error. You can solve this issue by providing an absolute path
    or by creating a path the way we do in [Example 11-2](#filepos1634189). This makes
    sure that Python is looking for the file in the same directory as the source file
    even if you execute the code from Excel via `RunPython`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to create the Python Package Tracker from scratch, you will need
    to create the database manually: run the database.py file as a script, for example
    by clicking the Run File button in VS Code. This will create the database file
    packagetracker.db with the two tables. The code that creates the database is found
    at the very bottom of database.py:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if` `__name__` `==``"__main__"``:``create_db``()`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: While the last line calls the `create_db` function, the meaning of the preceding
    `if` statement is explained in the following tip.
  prefs: []
  type: TYPE_NORMAL
- en: IF __NAME__ == “__MAIN__”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You will see this `if` statement at the bottom of many Python files. It makes
    sure that this code only runs when you run the file as a script, for example,
    from an Anaconda Prompt by running `python database.py` or by clicking the Run
    File button in VS Code. It, however, will not be triggered when you run the file
    by importing it as a module, i.e., by doing `import database` in your code. The
    reason for this is that Python assigns the name `__main__` to the file if you
    run it directly as script, whereas it will be called by its module name (`database`)
    when you run it via the `import` statement. Since Python tracks the file name
    in a variable called `__name__`, the `if` statement will evaluate to `True` only
    when you run it as script; it will not be triggered when you import it from the
    packagetracker.py file.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The rest of the `database` module runs SQL statements both via SQLAlchemy and
    pandas’ `to_sql` and `read_sql` methods so you get a feeling for both approaches.
  prefs: []
  type: TYPE_NORMAL
- en: MOVING TO POSTGRESQL
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you wanted to replace SQLite with PostgreSQL, a server-based database, there
    are only a few things you need to change. First of all, you need to run `conda
    install psycopg2` (or `pip install psycopg2-binary` if you are not using the Anaconda
    distribution) to install the PostgreSQL driver. Then, in database.py, change the
    connection string in the `create_engine` function to the PostgreSQL version as
    shown in [Table 11-3](#filepos1531478). Finally, to create the tables, you would
    need to change the `INTEGER` data type of `packages.package_id` to the PostgreSQL
    specific notation of `SERIAL`. Creating an auto-incrementing primary key is an
    example of where the SQL dialects differ.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'When you create tools of the complexity of the Python Package Tracker, you
    probably run into a few issues along the way: for example, you might have renamed
    a named range in Excel and forgot to adjust the Python code accordingly. This
    is a good moment to look into how debugging works!'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs: []
  type: TYPE_NORMAL
- en: 'To easily debug your xlwings scripts, run your functions directly from VS Code,
    instead of running them by clicking a button in Excel. The following lines at
    the very bottom of the packagetracker.py file will help you with debugging the
    `add_package` function (this is the same code that you will also find at the bottom
    of a `quickstart` project):'
  prefs: []
  type: TYPE_NORMAL
- en: '`if` `__name__` `==``"__main__"``:`![](images/00031.jpg)`xw``.``Book``(``"packagetracker.xlsm"``)``.``set_mock_caller``()`![](images/00039.jpg)`add_package``()`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have just seen how this if statement works when we were looking at the database.py
    code; see the previous tip.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As this code is only executed when you run the file directly from Python as
    a script, the `set_mock_caller()` command is only meant for debugging purposes:
    when you run the file in VS Code or from an Anaconda Prompt, it sets the `xw.Book.caller()`
    to `xw.Book("packagetracker.xlsm")`. The only purpose of doing this is to be able
    to run your script from both sides, Python and Excel, without having to switch
    the book object within the `add_package` function back and forth between `xw.Book("packagetracker.xlsm")`
    (when you call it from VS Code) and `xw.Book.caller()` (when you call it from
    Excel).'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Open packagetracker.py in VS Code and set a breakpoint on any line within the
    `add_package` function by clicking to the left of the line numbers. Then hit F5
    and select “Python File” in the dialog to start the debugger and to make your
    code stop at the breakpoint. Make sure to hit F5 instead of using the Run File
    button, as the Run File button ignores breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: DEBUGGING WITH VS CODE AND ANACONDA
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'On Windows, when you run the VS Code debugger for the first time with code
    that uses pandas, you might be greeted by an error: “Exception has occurred: ImportError,
    Unable to import required dependencies: numpy.” This happens because the debugger
    is up and running before the Conda environment has been activated properly. As
    a workaround, stop the debugger by clicking the stop icon and hit F5 again—it
    will work the second time.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you are not familiar with how the debugger in VS Code works, have a look
    at [Appendix B](index_split_030.html#filepos1820886) where I explain all the relevant
    functionality and buttons. We will also pick the topic up again in the respective
    section of the next chapter. If you want to debug a different function, stop the
    current debug session, then adjust the function name at the bottom of your file.
    For example, to debug the `show_history` function, change the last line in packagetracker.py
    as follows before hitting F5 again:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if` `__name__` `==``"__main__"``:``xw``.``Book``(``"packagetracker.xlsm"``)``.``set_mock_caller``()``show_history``()`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'On Windows, you could also activate the Show Console checkbox in the xlwings
    add-in, which will show a Command Prompt while the `RunPython` call is running.[2](#filepos1652845)
    This allows you to print additional information to help you debug the issue. For
    example, you could print the value of a variable to inspect it on the Command
    Prompt. After the code has been run, however, the Command Prompt will be closed.
    If you need to keep it open for a little longer, there is an easy trick: add `input()`
    as the last line in your function. This causes Python to wait for user input instead
    of closing the Command Prompt right away. When you’re done with inspecting the
    output, hit Enter in the Command Prompt to close it—just make sure to remove the
    `input()` line again before unchecking the Show Console option!'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs: []
  type: TYPE_NORMAL
- en: This chapter showed you that it’s possible to build reasonably complex applications
    with a minimum of effort. Being able to leverage powerful Python packages like
    Requests or SQLAlchemy makes all the difference to me when I compare this with
    VBA, where talking to external systems is so much harder. If you have similar
    use cases, I would highly recommend you look more closely into both Requests and
    SQLAlchemy—being able to efficiently deal with external data sources will allow
    you to make copy/paste a thing of the past.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of clicking buttons, some users prefer to create their Excel tools by
    using cell formulas. The next chapter shows you how xlwings enables you to write
    user-defined functions in Python, allowing you to reuse most of the xlwings concepts
    we’ve learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: '[1  ](#filepos1563739) In reality, the tool uses `package_name` instead of
    `package_id` to simplify the code.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[2  ](#filepos1650741) At the time of this writing, this option is not yet
    available on macOS.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
