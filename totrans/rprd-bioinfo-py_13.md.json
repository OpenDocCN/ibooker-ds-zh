["```py\n$ cd 12_mrna/\n$ cp solution1_dict.py mrna.py\n```", "```py\n$ ./mrna.py -h\nusage: mrna.py [-h] [-m int] protein\n\nInferring mRNA from Protein\n\npositional arguments:\n  protein               Input protein or file ![1](assets/1.png)\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -m int, --modulo int  Modulo value (default: 1000000) ![2](assets/2.png)\n```", "```py\n$ ./mrna.py MA\n12\n```", "```py\n$ ./mrna.py tests/inputs/1.txt\n448832\n```", "```py\n$ new.py -fp 'Infer mRNA from Protein' mrna.py\nDone, see new script \"mrna.py\".\n```", "```py\nclass Args(NamedTuple):\n    \"\"\" Command-line arguments \"\"\"\n    protein: str ![1](assets/1.png)\n    modulo: int ![2](assets/2.png)\n\ndef get_args() -> Args:\n    \"\"\" Get command-line arguments \"\"\"\n\n    parser = argparse.ArgumentParser(\n        description='Infer mRNA from Protein',\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n\n    parser.add_argument('protein', ![1](assets/1.png)\n                        metavar='protein',\n                        type=str,\n                        help='Input protein or file')\n\n    parser.add_argument('-m', ![2](assets/2.png)\n                        '--modulo',\n                        metavar='int',\n                        type=int,\n                        default=1000000,\n                        help='Modulo value')\n\n    args = parser.parse_args()\n\n    if os.path.isfile(args.protein): ![3](assets/3.png)\n        args.protein = open(args.protein).read().rstrip()\n\n    return Args(args.protein, args.modulo)\n```", "```py\ndef main() -> None:\n    args = get_args()\n    print(args.protein)\n```", "```py\n$ ./mrna.py MA\nMA\n$ ./mrna.py tests/inputs/1.txt | wc -c ![1](assets/1.png)\n  998\n```", "```py\n>>> from itertools import product\n>>> from pprint import pprint\n>>> combos = product(*codons)\n```", "```py\n>>> pprint(combos)\n<itertools.product object at 0x7fbdd822dac0>\n```", "```py\n>>> pprint(list(combos))\n[('AUG', 'GCA', 'UAA'),\n ('AUG', 'GCA', 'UAG'),\n ('AUG', 'GCA', 'UGA'),\n ('AUG', 'GCC', 'UAA'),\n ('AUG', 'GCC', 'UAG'),\n ('AUG', 'GCC', 'UGA'),\n ('AUG', 'GCG', 'UAA'),\n ('AUG', 'GCG', 'UAG'),\n ('AUG', 'GCG', 'UGA'),\n ('AUG', 'GCU', 'UAA'),\n ('AUG', 'GCU', 'UAG'),\n ('AUG', 'GCU', 'UGA')]\n```", "```py\n>>> pprint(list(combos))\n[]\n```", "```py\n>>> combos = list(product(*codons))\n```", "```py\n>>> len(combos)\n12\n```", "```py\n>>> 5 % 2\n1\n```", "```py\n$ ./mrna.py tests/inputs/1.txt\n448832\n```", "```py\n>>> import numpy as np\n>>> np.prod(range(1, 1001))\n0\n```", "```py\n>>> import math\n>>> math.prod(range(1, 1001))\n```", "```py\n>>> math.prod(range(1, 1001)) % 1000000\n0\n```", "```py\n>>> c2aa = {\n...     'AAA': 'K', 'AAC': 'N', 'AAG': 'K', 'AAU': 'N', 'ACA': 'T',\n...     'ACC': 'T', 'ACG': 'T', 'ACU': 'T', 'AGA': 'R', 'AGC': 'S',\n...     'AGG': 'R', 'AGU': 'S', 'AUA': 'I', 'AUC': 'I', 'AUG': 'M',\n...     'AUU': 'I', 'CAA': 'Q', 'CAC': 'H', 'CAG': 'Q', 'CAU': 'H',\n...     'CCA': 'P', 'CCC': 'P', 'CCG': 'P', 'CCU': 'P', 'CGA': 'R',\n...     'CGC': 'R', 'CGG': 'R', 'CGU': 'R', 'CUA': 'L', 'CUC': 'L',\n...     'CUG': 'L', 'CUU': 'L', 'GAA': 'E', 'GAC': 'D', 'GAG': 'E',\n...     'GAU': 'D', 'GCA': 'A', 'GCC': 'A', 'GCG': 'A', 'GCU': 'A',\n...     'GGA': 'G', 'GGC': 'G', 'GGG': 'G', 'GGU': 'G', 'GUA': 'V',\n...     'GUC': 'V', 'GUG': 'V', 'GUU': 'V', 'UAC': 'Y', 'UAU': 'Y',\n...     'UCA': 'S', 'UCC': 'S', 'UCG': 'S', 'UCU': 'S', 'UGC': 'C',\n...     'UGG': 'W', 'UGU': 'C', 'UUA': 'L', 'UUC': 'F', 'UUG': 'L',\n...     'UUU': 'F', 'UAA': '*', 'UAG': '*', 'UGA': '*',\n... }\n```", "```py\n>>> protein = 'MA'\n>>> for aa in protein + '*':\n...     print(aa, [c for c, res in c2aa.items() if res == aa])\n...\nM ['AUG']\nA ['GCA', 'GCC', 'GCG', 'GCU']\n* ['UAA', 'UAG', 'UGA']\n```", "```py\n>>> possible = [\n...     len([c for c, res in c2aa.items() if res == aa])\n...     for aa in protein + '*'\n... ]\n>>>\n>>> possible\n[1, 4, 3]\n```", "```py\n>>> import math\n>>> math.prod(possible)\n12\n```", "```py\n>>> sum(possible)\n8\n```", "```py\nreduce(...)\n    reduce(function, sequence[, initial]) -> value\n\n    Apply a function of two arguments cumulatively to the items of a sequence,\n    from left to right, so as to reduce the sequence to a single value.\n    For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\n    ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items\n    of the sequence in the calculation, and serves as a default when the\n    sequence is empty.\n```", "```py\n>>> from functools import reduce\n>>> reduce(lambda x, y: x + y, possible)\n8\n```", "```py\n>>> reduce(lambda x, y: x * y, possible)\n12\n```", "```py\ndef product(xs: List[int]) -> int: ![1](assets/1.png)\n    \"\"\" Return the product \"\"\"\n\n    return reduce(lambda x, y: x * y, xs, 1) ![2](assets/2.png)\n```", "```py\ndef mulmod(a: int, b: int, mod: int) -> int: ![1](assets/1.png)\n    \"\"\" Multiplication with modulo \"\"\"\n\n    def maybemod(x): ![2](assets/2.png)\n        ret = (x % mod) if mod > 1 and x > mod else x\n        return ret or x ![3](assets/3.png)\n\n    res = 0 ![4](assets/4.png)\n    a = maybemod(a) ![5](assets/5.png)\n    while b > 0: ![6](assets/6.png)\n        if b % 2 == 1: ![7](assets/7.png)\n            res = maybemod(res + a) ![8](assets/8.png)\n\n        a = maybemod(a * 2) ![9](assets/9.png)\n        b //= 2 ![10](assets/10.png)\n\n    return res\n```", "```py\ndef test_mulmod() -> None:\n    \"\"\" Text mulmod \"\"\"\n\n    assert mulmod(2, 4, 3) == 2\n    assert mulmod(9223372036854775807, 9223372036854775807, 1000000) == 501249\n```", "```py\n>>> import sys\n>>> sys.maxsize\n9223372036854775807\n```", "```py\n>>> import math\n>>> math.prod([9223372036854775807, 9223372036854775807]) % 1000000\n501249\n```", "```py\ndef modprod(xs: List[int], modulo: int) -> int:\n    \"\"\" Return the product modulo a value \"\"\"\n\n    return reduce(lambda x, y: mulmod(x, y, modulo), xs, 1)\n\ndef test_modprod() -> None:\n    \"\"\" Test modprod \"\"\"\n\n    assert modprod([], 3) == 1\n    assert modprod([1, 4, 3], 1000000) == 12\n    n = 9223372036854775807\n    assert modprod([n, n], 1000000) == 501249\n```", "```py\n>>> modprod(range(1, 1001), 1000000)\n```", "```py\ndef main() -> None:\n    args = get_args()\n    codon_to_aa = { ![1](assets/1.png)\n        'AAA': 'K', 'AAC': 'N', 'AAG': 'K', 'AAU': 'N', 'ACA': 'T',\n        'ACC': 'T', 'ACG': 'T', 'ACU': 'T', 'AGA': 'R', 'AGC': 'S',\n        'AGG': 'R', 'AGU': 'S', 'AUA': 'I', 'AUC': 'I', 'AUG': 'M',\n        'AUU': 'I', 'CAA': 'Q', 'CAC': 'H', 'CAG': 'Q', 'CAU': 'H',\n        'CCA': 'P', 'CCC': 'P', 'CCG': 'P', 'CCU': 'P', 'CGA': 'R',\n        'CGC': 'R', 'CGG': 'R', 'CGU': 'R', 'CUA': 'L', 'CUC': 'L',\n        'CUG': 'L', 'CUU': 'L', 'GAA': 'E', 'GAC': 'D', 'GAG': 'E',\n        'GAU': 'D', 'GCA': 'A', 'GCC': 'A', 'GCG': 'A', 'GCU': 'A',\n        'GGA': 'G', 'GGC': 'G', 'GGG': 'G', 'GGU': 'G', 'GUA': 'V',\n        'GUC': 'V', 'GUG': 'V', 'GUU': 'V', 'UAC': 'Y', 'UAU': 'Y',\n        'UCA': 'S', 'UCC': 'S', 'UCG': 'S', 'UCU': 'S', 'UGC': 'C',\n        'UGG': 'W', 'UGU': 'C', 'UUA': 'L', 'UUC': 'F', 'UUG': 'L',\n        'UUU': 'F', 'UAA': '*', 'UAG': '*', 'UGA': '*',\n    }\n\n    possible = [ ![2](assets/2.png)\n        len([c for c, res in codon_to_aa.items() if res == aa])\n        for aa in args.protein + '*'\n    ]\n    print(modprod(possible, args.modulo)) ![3](assets/3.png)\n```", "```py\n>>> base_to_name = dict(A='adenine', G='guanine', C='cytosine', T='thymine')\n>>> base_to_name['A']\n'adenine'\n```", "```py\n>>> list(base_to_name.items())\n[('A', 'adenine'), ('G', 'guanine'), ('C', 'cytosine'), ('T', 'thymine')]\n```", "```py\n>>> dict(map(reversed, base_to_name.items()))\n{'adenine': 'A', 'guanine': 'G', 'cytosine': 'C', 'thymine': 'T'}\n```", "```py\n>>> pprint(dict(map(reversed, c2aa.items())))\n{'*': 'UGA',\n 'A': 'GCU',\n 'C': 'UGU',\n 'D': 'GAU',\n 'E': 'GAG',\n 'F': 'UUU',\n 'G': 'GGU',\n 'H': 'CAU',\n 'I': 'AUU',\n 'K': 'AAG',\n 'L': 'UUG',\n 'M': 'AUG',\n 'N': 'AAU',\n 'P': 'CCU',\n 'Q': 'CAG',\n 'R': 'CGU',\n 'S': 'UCU',\n 'T': 'ACU',\n 'V': 'GUU',\n 'W': 'UGG',\n 'Y': 'UAU'}\n```", "```py\n>>> from collections import defaultdict\n>>> aa2codon = defaultdict(list)\n>>> for k, v in c2aa.items():\n...     aa2codon[v].append(k)\n...\n>>> pprint(aa2codon)\ndefaultdict(<class 'list'>,\n            {'*': ['UAA', 'UAG', 'UGA'],\n             'A': ['GCA', 'GCC', 'GCG', 'GCU'],\n             'C': ['UGC', 'UGU'],\n             'D': ['GAC', 'GAU'],\n             'E': ['GAA', 'GAG'],\n             'F': ['UUC', 'UUU'],\n             'G': ['GGA', 'GGC', 'GGG', 'GGU'],\n             'H': ['CAC', 'CAU'],\n             'I': ['AUA', 'AUC', 'AUU'],\n             'K': ['AAA', 'AAG'],\n             'L': ['CUA', 'CUC', 'CUG', 'CUU', 'UUA', 'UUG'],\n             'M': ['AUG'],\n             'N': ['AAC', 'AAU'],\n             'P': ['CCA', 'CCC', 'CCG', 'CCU'],\n             'Q': ['CAA', 'CAG'],\n             'R': ['AGA', 'AGG', 'CGA', 'CGC', 'CGG', 'CGU'],\n             'S': ['AGC', 'AGU', 'UCA', 'UCC', 'UCG', 'UCU'],\n             'T': ['ACA', 'ACC', 'ACG', 'ACU'],\n             'V': ['GUA', 'GUC', 'GUG', 'GUU'],\n             'W': ['UGG'],\n             'Y': ['UAC', 'UAU']})\n```", "```py\ndef main():\n    args = get_args()\n    aa_to_codon = { ![1](assets/1.png)\n        'A': ['GCA', 'GCC', 'GCG', 'GCU'],\n        'C': ['UGC', 'UGU'],\n        'D': ['GAC', 'GAU'],\n        'E': ['GAA', 'GAG'],\n        'F': ['UUC', 'UUU']\n        'G': ['GGA', 'GGC', 'GGG', 'GGU'],\n        'H': ['CAC', 'CAU'],\n        'I': ['AUA', 'AUC', 'AUU'],\n        'K': ['AAA', 'AAG'],\n        'L': ['CUA', 'CUC', 'CUG', 'CUU', 'UUA', 'UUG'],\n        'M': ['AUG'],\n        'N': ['AAC', 'AAU'],\n        'P': ['CCA', 'CCC', 'CCG', 'CCU'],\n        'Q': ['CAA', 'CAG'],\n        'R': ['AGA', 'AGG', 'CGA', 'CGC', 'CGG', 'CGU'],\n        'S': ['AGC', 'AGU', 'UCA', 'UCC', 'UCG', 'UCU'],\n        'T': ['ACA', 'ACC', 'ACG', 'ACU'],\n        'V': ['GUA', 'GUC', 'GUG', 'GUU'],\n        'W': ['UGG'],\n        'Y': ['UAC', 'UAU'],\n        '*': ['UAA', 'UAG', 'UGA'],\n    }\n\n    possible = [len(aa_to_codon[aa]) for aa in args.protein + '*'] ![2](assets/2.png)\n    print(math.prod(possible) % args.modulo) ![3](assets/3.png)\n```", "```py\n>>> codons = {\n...     'A': 4, 'C': 2, 'D': 2, 'E': 2, 'F': 2, 'G': 4, 'H': 2, 'I': 3,\n...     'K': 2, 'L': 6, 'M': 1, 'N': 2, 'P': 4, 'Q': 2, 'R': 6, 'S': 6,\n...     'T': 4, 'V': 4, 'W': 1, 'Y': 2, '*': 3,\n... }\n```", "```py\n>>> [codons.get(aa, 1) for aa in 'MA*']\n[1, 4, 3]\n```", "```py\ndef main():\n    args = get_args()\n    codons = { ![1](assets/1.png)\n        'A': 4, 'C': 2, 'D': 2, 'E': 2, 'F': 2, 'G': 4, 'H': 2, 'I': 3,\n        'K': 2, 'L': 6, 'M': 1, 'N': 2, 'P': 4, 'Q': 2, 'R': 6, 'S': 6,\n        'T': 4, 'V': 4, 'W': 1, 'Y': 2, '*': 3,\n    }\n    nums = [codons.get(aa, 1) for aa in args.protein + '*'] ![2](assets/2.png)\n    print(math.prod(nums) % args.modulo) ![3](assets/3.png)\n```", "```py\n$ ./show_patterns.py MA\n    1: AUGGCAUAA\n    2: AUGGCAUAG\n    3: AUGGCAUGA\n    4: AUGGCCUAA\n    5: AUGGCCUAG\n    6: AUGGCCUGA\n    7: AUGGCGUAA\n    8: AUGGCGUAG\n    9: AUGGCGUGA\n   10: AUGGCUUAA\n   11: AUGGCUUAG\n   12: AUGGCUUGA\n```", "```py\n  AUGGCAUAA\n+ AUGGCAUAG\n  ---------\n  AUGGCAUA[AG]\n```"]