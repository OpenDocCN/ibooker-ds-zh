- en: 'Chapter 24\. High-Performance Pandas: eval and query'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we’ve already seen in previous chapters, the power of the PyData stack is
    built upon the ability of NumPy and Pandas to push basic operations into lower-level
    compiled code via an intuitive higher-level syntax: examples are vectorized/broadcasted
    operations in NumPy, and grouping-type operations in Pandas. While these abstractions
    are efficient and effective for many common use cases, they often rely on the
    creation of temporary intermediate objects, which can cause undue overhead in
    computational time and memory use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To address this, Pandas includes some methods that allow you to directly access
    C-speed operations without costly allocation of intermediate arrays: `eval` and
    `query`, which rely on the [NumExpr package](https://oreil.ly/acvj5). In this
    chapter I will walk you through their use and give some rules of thumb about when
    you might think about using them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Motivating query and eval: Compound Expressions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve seen previously that NumPy and Pandas support fast vectorized operations;
    for example, when adding the elements of two arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As discussed in [Chapter 6](ch06.xhtml#section-0203-computation-on-arrays-ufuncs),
    this is much faster than doing the addition via a Python loop or comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'But this abstraction can become less efficient when computing compound expressions.
    For example, consider the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Because NumPy evaluates each subexpression, this is roughly equivalent to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, *every intermediate step is explicitly allocated in memory*.
    If the `x` and `y` arrays are very large, this can lead to significant memory
    and computational overhead. The NumExpr library gives you the ability to compute
    this type of compound expression element by element, without the need to allocate
    full intermediate arrays. The [NumExpr documentation](https://oreil.ly/acvj5)
    has more details, but for the time being it is sufficient to say that the library
    accepts a *string* giving the NumPy-style expression you’d like to compute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The benefit here is that NumExpr evaluates the expression in a way that avoids
    temporary arrays where possible, and thus can be much more efficient than NumPy,
    especially for long sequences of computations on large arrays. The Pandas `eval`
    and `query` tools that we will discuss here are conceptually similar, and are
    essentially Pandas-specific wrappers of NumExpr functionality.
  prefs: []
  type: TYPE_NORMAL
- en: pandas.eval for Efficient Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `eval` function in Pandas uses string expressions to efficiently compute
    operations on `DataFrame` objects. For example, consider the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To compute the sum of all four `DataFrame`s using the typical Pandas approach,
    we can just write the sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The same result can be computed via `pd.eval` by constructing the expression
    as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `eval` version of this expression is about 50% faster (and uses much less
    memory), while giving the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`pd.eval` supports a wide range of operations. To demonstrate these, we’ll
    use the following integer data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a summary of the operations `pd.eval` supports:'
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators
  prefs: []
  type: TYPE_NORMAL
- en: '`pd.eval` supports all arithmetic operators. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Comparison operators
  prefs: []
  type: TYPE_NORMAL
- en: '`pd.eval` supports all comparison operators, including chained expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Bitwise operators
  prefs: []
  type: TYPE_NORMAL
- en: '`pd.eval` supports the `&` and `|` bitwise operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, it supports the use of the literal `and` and `or` in Boolean expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Object attributes and indices
  prefs: []
  type: TYPE_NORMAL
- en: '`pd.eval` supports access to object attributes via the `obj.attr` syntax and
    indexes via the `obj[index]` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Other operations
  prefs: []
  type: TYPE_NORMAL
- en: Other operations, such as function calls, conditional statements, loops, and
    other more involved constructs are currently *not* implemented in `pd.eval`. If
    you’d like to execute these more complicated types of expressions, you can use
    the NumExpr library itself.
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame.eval for Column-Wise Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as Pandas has a top-level `pd.eval` function, `DataFrame` objects have
    an `eval` method that works in similar ways. The benefit of the `eval` method
    is that columns can be referred to by name. We’ll use this labeled array as an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `pd.eval` as in the previous section, we can compute expressions with
    the three columns like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DataFrame.eval` method allows much more succinct evaluation of expressions
    with the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice here that we treat *column names as variables* within the evaluated expression,
    and the result is what we would wish.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment in DataFrame.eval
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the options just discussed, `DataFrame.eval` also allows assignment
    to any column. Let’s use the `DataFrame` from before, which has columns `''A''`,
    `''B''`, and `''C''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `df.eval` to create a new column `''D''` and assign to it a value
    computed from the other columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, any existing column can be modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Local Variables in DataFrame.eval
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `DataFrame.eval` method supports an additional syntax that lets it work
    with local Python variables. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@` character here marks a *variable name* rather than a *column name*,
    and lets you efficiently evaluate expressions involving the two “namespaces”:
    the namespace of columns, and the namespace of Python objects. Notice that this
    `@` character is only supported by the `DataFrame.eval` *method*, not by the `pandas.eval`
    *function*, because the `pandas.eval` function only has access to the one (Python)
    namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: The DataFrame.query Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `DataFrame` has another method based on evaluated strings, called `query`.
    Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the example used in our discussion of `DataFrame.eval`, this is an
    expression involving columns of the `DataFrame`. However, it cannot be expressed
    using the `DataFrame.eval` syntax! Instead, for this type of filtering operation,
    you can use the `query` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to being a more efficient computation, compared to the masking
    expression this is much easier to read and understand. Note that the `query` method
    also accepts the `@` flag to mark local variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Performance: When to Use These Functions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When considering whether to use `eval` and `query`, there are two considerations:
    *computation time* and *memory use*. Memory use is the most predictable aspect.
    As already mentioned, every compound expression involving NumPy arrays or Pandas
    `DataFrame`s will result in implicit creation of temporary arrays. For example,
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'is roughly equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If the size of the temporary `DataFrame`s is significant compared to your available
    system memory (typically several gigabytes), then it’s a good idea to use an `eval`
    or `query` expression. You can check the approximate size of your array in bytes
    using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: On the performance side, `eval` can be faster even when you are not maxing out
    your system memory. The issue is how your temporary objects compare to the size
    of the L1 or L2 CPU cache on your system (typically a few megabytes); if they
    are much bigger, then `eval` can avoid some potentially slow movement of values
    between the different memory caches. In practice, I find that the difference in
    computation time between the traditional methods and the `eval`/`query` method
    is usually not significant—if anything, the traditional method is faster for smaller
    arrays! The benefit of `eval`/`query` is mainly in the saved memory, and the sometimes
    cleaner syntax they offer.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve covered most of the details of `eval` and `query` here; for more information
    on these, you can refer to the Pandas documentation. In particular, different
    parsers and engines can be specified for running these queries; for details on
    this, see the discussion within the [“Enhancing Performance” section](https://oreil.ly/DHNy8)
    of the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Further Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this part of the book, we’ve covered many of the basics of using Pandas
    effectively for data analysis. Still, much has been omitted from our discussion.
    To learn more about Pandas, I recommend the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Pandas online documentation](http://pandas.pydata.org)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the go-to source for complete documentation of the package. While the
    examples in the documentation tend to be based on small generated datasets, the
    description of the options is complete and generally very useful for understanding
    the use of various functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Python for Data Analysis*](https://oreil.ly/0hdsf)'
  prefs: []
  type: TYPE_NORMAL
- en: Written by Wes McKinney (the original creator of Pandas), this book contains
    much more detail on the Pandas package than we had room for in this chapter. In
    particular, McKinney takes a deep dive into tools for time series, which were
    his bread and butter as a financial consultant. The book also has many entertaining
    examples of applying Pandas to gain insight from real-world datasets.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Effective Pandas*](https://oreil.ly/cn1ls)'
  prefs: []
  type: TYPE_NORMAL
- en: This short ebook by Pandas developer Tom Augspurger provides a succinct outline
    of using the full power of the Pandas library in an effective and idiomatic way.
  prefs: []
  type: TYPE_NORMAL
- en: '[Pandas on PyVideo](https://oreil.ly/mh4wI)'
  prefs: []
  type: TYPE_NORMAL
- en: From PyCon to SciPy to PyData, many conferences have featured tutorials by Pandas
    developers and power users. The PyCon tutorials in particular tend to be given
    by very well-vetted presenters.
  prefs: []
  type: TYPE_NORMAL
- en: Using these resources, combined with the walkthrough given in these chapters,
    my hope is that you’ll be poised to use Pandas to tackle any data analysis problem
    you come across!
  prefs: []
  type: TYPE_NORMAL
