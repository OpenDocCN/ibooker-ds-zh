<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 9. Cleaning Data with pandas" data-type="chapter" epub:type="chapter"><div class="chapter" id="chapter_cleaning">
<h1><span class="label">Chapter 9. </span>Cleaning Data with pandas</h1>
<p>The previous two chapters introduced pandas and NumPy, the Numeric Python library it extends. <a data-primary="pandas" data-secondary="cleaning data with" data-type="indexterm" id="ix_pndscln"/>Armed with basic pandas know-how, we’re ready to start the cleaning stage of our toolchain, aiming to find and eliminate the dirty data in our scraped dataset (see <a data-type="xref" href="ch06.xhtml#chapter_heavy_scraping">Chapter 6</a>). This chapter will also extend your pandas knowledge, introducing new methods in a working context.</p>
<p>In <a data-type="xref" href="ch08.xhtml#chapter_intro_to_pandas">Chapter 8</a>, we covered the core components of pandas: the DataFrame, a programmatic spreadsheet capable of dealing with the many different datatypes found in the real world, and its building block, the Series, a heterogeneous extension of NumPy’s homogeneous <code>ndarray</code>. We also covered how to read from and write to different datastores, including JSON, CSV files, MongoDB, and SQL databases. Now we’ll start to put pandas through its paces, showing how it can be used to clean dirty data. I’ll introduce the key elements of data cleaning using our dirty Nobel Prize dataset as an example.</p>
<p>I’ll take it slowly, introducing key pandas concepts in a working environment. Let’s first establish why cleaning data is such an important part of a data visualizer’s work.</p>
<section data-pdf-bookmark="Coming Clean About Dirty Data" data-type="sect1"><div class="sect1" id="idm45607776710016">
<h1>Coming Clean About Dirty Data</h1>
<p>I think it’s fair to say that most people entering the field of data visualization underestimate, often by a fairly large factor, the amount of time they’re going to spend trying to make their data presentable.<a data-primary="dirty data" data-type="indexterm" id="idm45607776708048"/><a data-primary="cleaning data" data-seealso="pandas" data-type="indexterm" id="idm45607776707344"/> The fact is that getting clean datasets that are a pleasure to transform into cool visualizations could well take over half your time. Data in the wild is very rarely pristine, often bearing the sticky paw prints of mistaken manual data entry, missing whole fields due to oversight or parsing errors and/or mixed datetime formats.</p>
<p>For this book, and to pose a properly meaty challenge, our Nobel Prize dataset has been scraped from Wikipedia, a manually edited website with fairly informal guidelines. In this sense, the data is bound to be dirty—​humans make mistakes even when the environment is a good deal more forgiving. But even data from the official APIs of, for example, large social media sites, is often flawed, with missing or incomplete fields, scar tissue from countless changes to the data schemas, deliberate mis-entry, and the like.</p>
<p>So cleaning data is a fundamental part of the job of a data visualizer, stealing time from all the cool stuff you’d rather be doing—​which is an excellent reason to get really good at it and free up that drudge time for more meaningful pursuits. And a large part of getting good at cleaning data is choosing the right toolset, which is where pandas comes in. It’s a great way to slice and dice even fairly large datasets,<sup><a data-type="noteref" href="ch09.xhtml#idm45607776705472" id="idm45607776705472-marker">1</a></sup> and being comfortable with it could save you a lot of time. That is where this chapter comes in.</p>
<p>To recap, scraping the Nobel data from Wikipedia using Python’s Scrapy library (see <a data-type="xref" href="ch06.xhtml#chapter_heavy_scraping">Chapter 6</a>) produced an array of JSON objects of the form:</p>
<pre data-code-language="javascript" data-type="programlisting"><code class="p">{</code>
  <code class="s2">"category"</code><code class="o">:</code> <code class="s2">"Physics"</code><code class="p">,</code>
  <code class="s2">"name"</code><code class="o">:</code> <code class="s2">"Albert Einstein"</code><code class="p">,</code>
  <code class="s2">"gender"</code><code class="o">:</code> <code class="s2">"male"</code><code class="p">,</code>
  <code class="s2">"place_of_birth"</code><code class="o">:</code> <code class="s2">"Ulm ,  Baden-W\u00fcrttemberg ,</code>
<code class="s2">    German Empire"</code><code class="p">,</code>
  <code class="s2">"date_of_death"</code><code class="o">:</code> <code class="s2">"1955-04-18"</code><code class="p">,</code>
  <code class="p">...</code>
<code class="p">}</code></pre>
<p>The job of this chapter is to turn that array into as clean a data source as possible before we explore it with pandas in the next <span class="keep-together">chapter</span>.</p>
<p>There are many forms of dirty data, most commonly:</p>
<ul>
<li>
<p>Duplicate entries/rows</p>
</li>
<li>
<p>Missing fields</p>
</li>
<li>
<p>Misaligned rows</p>
</li>
<li>
<p>Corrupted fields</p>
</li>
<li>
<p>Mixed datatypes in a column</p>
</li>
</ul>
<p>We’ll now probe our Nobel Prize data for these kinds of anomalies.</p>
<p>First, we need to load our JSON data into a DataFrame, as shown in the previous chapter (see <a data-type="xref" href="ch08.xhtml#load_save_dataframe">“Creating and Saving DataFrames”</a>). <a data-primary="pandas" data-secondary="cleaning data with" data-tertiary="loading dirty data into a DataFrame" data-type="indexterm" id="idm45607776669568"/><a data-primary="DataFrames" data-secondary="loading JSON data into" data-type="indexterm" id="idm45607776668352"/>We can open the JSON data file directly:</p>
<pre data-code-language="python" data-type="programlisting"><code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>

<code class="n">df</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">read_json</code><code class="p">(</code><code class="nb">open</code><code class="p">(</code><code class="s1">'data/nobel_winners_dirty.json'</code><code class="p">))</code></pre>
<p>Now that we’ve got our dirty scraped data into a DataFrame, let’s get a broad overview of what we have.</p>
</div></section>
<section data-pdf-bookmark="Inspecting the Data" data-type="sect1"><div class="sect1" id="idm45607776660448">
<h1>Inspecting the Data</h1>
<p>The pandas DataFrame has a number of methods and properties that give a quick overview of the data contained within.<a data-primary="pandas" data-secondary="cleaning data with" data-tertiary="inspecting data in a DataFrame" data-type="indexterm" id="ix_pndsclninspct"/><a data-primary="DataFrames" data-secondary="inspecting data in" data-type="indexterm" id="ix_DaFrinspct"/> The most general is <code>info</code>, which gives a neat summary of the number of data entries by column:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code class="o">.</code><code class="n">info</code><code class="p">()</code>
<code class="o">&lt;</code><code class="k">class</code> <code class="err">'</code><code class="nc">pandas</code><code class="o">.</code><code class="n">core</code><code class="o">.</code><code class="n">frame</code><code class="o">.</code><code class="n">DataFrame</code><code class="s1">'&gt;</code>
<code class="n">RangeIndex</code><code class="p">:</code> <code class="mi">1052</code> <code class="n">entries</code><code class="p">,</code> <code class="mi">0</code> <code class="n">to</code> <code class="mi">1051</code>
<code class="n">Data</code> <code class="n">columns</code> <code class="p">(</code><code class="n">total</code> <code class="mi">12</code> <code class="n">columns</code><code class="p">):</code>
 <code class="c1">#   Column          Non-Null Count  Dtype</code>
<code class="o">---</code>  <code class="o">------</code>          <code class="o">--------------</code>  <code class="o">-----</code>
 <code class="mi">0</code>   <code class="n">born_in</code>         <code class="mi">1052</code> <code class="n">non</code><code class="o">-</code><code class="n">null</code>   <code class="nb">object</code>
 <code class="mi">1</code>   <code class="n">category</code>        <code class="mi">1052</code> <code class="n">non</code><code class="o">-</code><code class="n">null</code>   <code class="nb">object</code>
 <code class="mi">2</code>   <code class="n">country</code>         <code class="mi">1052</code> <code class="n">non</code><code class="o">-</code><code class="n">null</code>   <code class="nb">object</code>
 <code class="mi">3</code>   <code class="n">date_of_birth</code>   <code class="mi">1044</code> <code class="n">non</code><code class="o">-</code><code class="n">null</code>   <code class="nb">object</code>
 <code class="mi">4</code>   <code class="n">date_of_death</code>   <code class="mi">1044</code> <code class="n">non</code><code class="o">-</code><code class="n">null</code>   <code class="nb">object</code>
 <code class="mi">5</code>   <code class="n">gender</code>          <code class="mi">1040</code> <code class="n">non</code><code class="o">-</code><code class="n">null</code>   <code class="nb">object</code>
 <code class="mi">6</code>   <code class="n">link</code>            <code class="mi">1052</code> <code class="n">non</code><code class="o">-</code><code class="n">null</code>   <code class="nb">object</code>
 <code class="mi">7</code>   <code class="n">name</code>            <code class="mi">1052</code> <code class="n">non</code><code class="o">-</code><code class="n">null</code>   <code class="nb">object</code>
 <code class="mi">8</code>   <code class="n">place_of_birth</code>  <code class="mi">1044</code> <code class="n">non</code><code class="o">-</code><code class="n">null</code>   <code class="nb">object</code>
 <code class="mi">9</code>   <code class="n">place_of_death</code>  <code class="mi">1044</code> <code class="n">non</code><code class="o">-</code><code class="n">null</code>   <code class="nb">object</code>
 <code class="mi">10</code>  <code class="n">text</code>            <code class="mi">1052</code> <code class="n">non</code><code class="o">-</code><code class="n">null</code>   <code class="nb">object</code>
 <code class="mi">11</code>  <code class="n">year</code>            <code class="mi">1052</code> <code class="n">non</code><code class="o">-</code><code class="n">null</code>   <code class="n">int64</code>
<code class="n">dtypes</code><code class="p">:</code> <code class="n">int64</code><code class="p">(</code><code class="mi">1</code><code class="p">),</code> <code class="nb">object</code><code class="p">(</code><code class="mi">11</code><code class="p">)</code>
<code class="n">memory</code> <code class="n">usage</code><code class="p">:</code> <code class="mf">98.8</code><code class="o">+</code> <code class="n">KB</code></pre>
<p>You can see that some fields are missing entries. For example, although there are 1,052 rows in our DataFrame, there are only 1,040 gender attributes. Note also the handy <code>memory_usage</code>—pandas DataFrames are held in RAM, so as datasets increase in size, this number gives a nice indication of how close we are to our machine-specific memory limits.</p>
<p class="pagebreak-before">DataFrame’s <code>describe</code> method gives a <a data-primary="describe method (DataFrame)" data-type="indexterm" id="idm45607776521504"/>handy statistical summary of relevant <span class="keep-together">columns</span>:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code class="o">.</code><code class="n">describe</code><code class="p">()</code>
<code class="n">Out</code><code class="p">:</code>
              <code class="n">year</code>
<code class="n">count</code>  <code class="mf">1052.000000</code>
<code class="n">mean</code>   <code class="mf">1968.729087</code>
<code class="n">std</code>      <code class="mf">33.155829</code>
<code class="nb">min</code>    <code class="mf">1809.000000</code>
<code class="mi">25</code><code class="o">%</code>    <code class="mf">1947.000000</code>
<code class="mi">50</code><code class="o">%</code>    <code class="mf">1975.000000</code>
<code class="mi">75</code><code class="o">%</code>    <code class="mf">1996.000000</code>
<code class="nb">max</code>    <code class="mf">2014.000000</code></pre>
<p>As you can see, by default only numerical columns are described. Already we can see an error in the data, the minimum year being 1809, which is impossible when the first Nobel was awarded in 1901.</p>
<p><code>describe</code> takes an <code>include</code> parameter that allows us to specify the column datatypes (<code>dtype</code>s) to be assessed. <a data-primary="dtype object" data-secondary="specifying for columns in a dataset" data-type="indexterm" id="idm45607776339856"/>Other than year, the columns in our Nobel Prize dataset are all objects, which are pandas’s default, catchall <code>dtype</code>, capable of representing any numbers, strings, data times, and more. <a data-type="xref" href="#describe_objects">Example 9-1</a> shows how to get their stats.</p>
<div data-type="example" id="describe_objects">
<h5><span class="label">Example 9-1. </span>Describing the DataFrame</h5>
<pre data-code-language="python" data-type="programlisting"><code class="n">In</code><code> </code><code class="p">[</code><code class="mi">140</code><code class="p">]</code><code class="p">:</code><code> </code><code class="n">df</code><code class="o">.</code><code class="n">describe</code><code class="p">(</code><code class="n">include</code><code class="o">=</code><code class="p">[</code><code class="s1">'</code><code class="s1">object</code><code class="s1">'</code><code class="p">]</code><code class="p">)</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO1-1" id="co_cleaning_data_with_pandas_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code class="n">Out</code><code class="p">[</code><code class="mi">140</code><code class="p">]</code><code class="p">:</code><code>
</code><code>       </code><code class="n">born_in</code><code>  </code><code class="n">category</code><code> </code><code class="n">date_of_birth</code><code> </code><code class="n">date_of_death</code><code> </code><code class="n">gender</code><code>  </code><code>\
</code><code class="n">count</code><code>     </code><code class="mi">1052</code><code>      </code><code class="mi">1052</code><code>          </code><code class="mi">1044</code><code>          </code><code class="mi">1044</code><code>   </code><code class="mi">1040</code><code>
</code><code class="n">unique</code><code>      </code><code class="mi">40</code><code>         </code><code class="mi">7</code><code>           </code><code class="mi">853</code><code>           </code><code class="mi">563</code><code>      </code><code class="mi">2</code><code>
</code><code class="n">top</code><code>             </code><code class="n">Physio</code><code class="o">.</code><code class="o">.</code><code>    </code><code class="mi">9</code><code> </code><code class="n">May</code><code> </code><code class="mi">1947</code><code>                 </code><code class="n">male</code><code>
</code><code class="n">freq</code><code>       </code><code class="mi">910</code><code>       </code><code class="mi">250</code><code>             </code><code class="mi">4</code><code>           </code><code class="mi">362</code><code>    </code><code class="mi">983</code><code>
</code><code>
</code><code>                              </code><code class="n">link</code><code>             </code><code class="n">name</code><code>  </code><code>\
</code><code class="n">count</code><code>                         </code><code class="mi">1052</code><code>             </code><code class="mi">1052</code><code>
</code><code class="n">unique</code><code>                         </code><code class="mi">893</code><code>              </code><code class="mi">998</code><code>
</code><code class="n">top</code><code>     </code><code class="n">http</code><code class="p">:</code><code class="o">/</code><code class="o">/</code><code class="n">eg</code><code class="o">/</code><code class="n">wiki</code><code class="o">/</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>                     </code><code class="n">Daniel</code><code> </code><code class="n">Kahneman</code><code>
</code><code class="n">freq</code><code>                             </code><code class="mi">4</code><code>                </code><code class="mi">2</code><code>
</code><code>
</code><code>          </code><code class="n">country</code><code> </code><code class="n">place_of_birth</code><code> </code><code class="n">place_of_death</code><code>  </code><code>\
</code><code class="n">count</code><code>            </code><code class="mi">1052</code><code>           </code><code class="mi">1044</code><code>           </code><code class="mi">1044</code><code>
</code><code class="n">unique</code><code>             </code><code class="mi">59</code><code>            </code><code class="mi">735</code><code>            </code><code class="mi">410</code><code>
</code><code class="n">top</code><code>     </code><code class="n">United</code><code> </code><code class="n">States</code><code>
</code><code class="n">freq</code><code>              </code><code class="mi">350</code><code>             </code><code class="mi">29</code><code>            </code><code class="mi">409</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO1-1" id="callout_cleaning_data_with_pandas_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The <code>include</code> argument is a list (or single item) of columnar <code>dtype</code>s to <span class="keep-together">summarize</span>.</p></dd>
</dl></div>
<p>There’s quite a lot of useful information to be gleaned from the output of <a data-type="xref" href="#describe_objects">Example 9-1</a>, such as that there are 59 unique nationalities with the United States, at 350, being the largest group.</p>
<p>One interesting tidbit is that of 1,044 recorded dates of birth, only 853 are unique, which could mean any number of things. Possibly some auspicious days saw the birth of more than one laureate or, wearing our data-cleaning hats,  it’s more likely that there are some duplicated winners or that some dates are wrong or have only recorded the year. The duplicated winners hypothesis is confirmed by the observation that of 1,052 name counts, only 998 are unique. Now there have been a few multiple winners but not enough to account for 54 duplicates.</p>
<p>DataFrame’s <code>head</code> and <code>tail</code> methods provide another easy way to get a quick feel for the data. <a data-primary="head method (DataFrame)" data-type="indexterm" id="idm45607776167168"/><a data-primary="tail method (DataFrame)" data-type="indexterm" id="idm45607776166464"/>By default, they display the top or bottom five rows, but we can set that number by passing an integer as the first argument. <a data-type="xref" href="#dataframe_head">Example 9-2</a> shows the result of using <code>head</code> with our Nobel DataFrame.</p>
<div data-type="example" id="dataframe_head">
<h5><span class="label">Example 9-2. </span>Sampling the first five DataFrame rows</h5>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code class="o">.</code><code class="n">head</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">Out</code><code class="p">:</code><code>
</code><code>                  </code><code class="n">born_in</code><code>                </code><code class="n">category</code><code>   </code><code class="n">date_of_bi</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="mi">0</code><code>                          </code><code class="n">Physiology</code><code> </code><code class="ow">or</code><code> </code><code class="n">Medicine</code><code>  </code><code class="mi">8</code><code> </code><code class="n">October</code><code> </code><code class="mf">1.</code><code class="o">.</code><code>
</code><code class="mi">1</code><code>  </code><code class="n">Bosnia</code><code> </code><code class="ow">and</code><code> </code><code class="n">Herzegovina</code><code>              </code><code class="n">Literature</code><code>  </code><code class="mi">9</code><code> </code><code class="n">October</code><code> </code><code class="mf">1.</code><code class="o">.</code><a class="co" href="#callout_cleaning_data_with_pandas_CO2-1" id="co_cleaning_data_with_pandas_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code class="mi">2</code><code>  </code><code class="n">Bosnia</code><code> </code><code class="ow">and</code><code> </code><code class="n">Herzegovina</code><code>               </code><code class="n">Chemistry</code><code>   </code><code class="n">July</code><code> </code><code class="mi">23</code><code class="p">,</code><code> </code><code class="mf">1.</code><code class="o">.</code><code>
</code><code class="mi">3</code><code>                                           </code><code class="n">Peace</code><code>             </code><code class="o">.</code><code class="o">.</code><code>
</code><code class="mi">4</code><code>                                           </code><code class="n">Peace</code><code>    </code><code class="mi">26</code><code> </code><code class="n">July</code><code> </code><code class="mf">1.</code><code class="o">.</code><code>
</code><code>
</code><code>    </code><code class="n">date_of_death</code><code> </code><code class="n">gender</code><code>                                      </code><code class="o">.</code><code class="o">.</code><code>
</code><code class="mi">0</code><code>   </code><code class="mi">24</code><code> </code><code class="n">March</code><code> </code><code class="mi">2002</code><code>   </code><code class="n">male</code><code>   </code><code class="n">http</code><code class="p">:</code><code class="o">/</code><code class="o">/</code><code class="n">en</code><code class="o">.</code><code class="n">wikipedia</code><code class="o">.</code><code class="n">org</code><code class="o">/</code><code class="n">wiki</code><code class="o">/</code><code class="n">C</code><code class="o">%</code><code class="n">C3</code><code class="o">%</code><code class="n">A</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="mi">1</code><code>   </code><code class="mi">13</code><code> </code><code class="n">March</code><code> </code><code class="mi">1975</code><code>   </code><code class="n">male</code><code>            </code><code class="n">http</code><code class="p">:</code><code class="o">/</code><code class="o">/</code><code class="n">en</code><code class="o">.</code><code class="n">wikipedia</code><code class="o">.</code><code class="n">org</code><code class="o">/</code><code class="n">wi</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="mi">2</code><code>      </code><code class="mi">1998</code><code class="o">-</code><code class="mi">01</code><code class="o">-</code><code class="mi">07</code><code>   </code><code class="n">male</code><code>       </code><code class="n">http</code><code class="p">:</code><code class="o">/</code><code class="o">/</code><code class="n">en</code><code class="o">.</code><code class="n">wikipedia</code><code class="o">.</code><code class="n">org</code><code class="o">/</code><code class="n">wiki</code><code class="o">/</code><code class="n">Vl</code><code class="o">.</code><code class="o">.</code><a class="co" href="#callout_cleaning_data_with_pandas_CO2-2" id="co_cleaning_data_with_pandas_CO2-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code>
</code><code class="mi">3</code><code>             </code><code class="n">NaN</code><code>   </code><code class="kc">None</code><code>  </code><code class="n">http</code><code class="p">:</code><code class="o">/</code><code class="o">/</code><code class="n">en</code><code class="o">.</code><code class="n">wikipedia</code><code class="o">.</code><code class="n">org</code><code class="o">/</code><code class="n">wiki</code><code class="o">/</code><code class="n">Institu</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="mi">4</code><code>  </code><code class="mi">6</code><code> </code><code class="n">October</code><code> </code><code class="mi">1912</code><code>   </code><code class="n">male</code><code>  </code><code class="n">http</code><code class="p">:</code><code class="o">/</code><code class="o">/</code><code class="n">en</code><code class="o">.</code><code class="n">wikipedia</code><code class="o">.</code><code class="n">org</code><code class="o">/</code><code class="n">wiki</code><code class="o">/</code><code class="n">Auguste</code><code class="o">.</code><code class="o">.</code><code>
</code><code>
</code><code>                              </code><code class="n">name</code><code> </code><code class="n">country</code><code>  </code><code>\
</code><code class="mi">0</code><code>                   </code><code class="n">César</code><code> </code><code class="n">Milstein</code><code>   </code><code class="n">Argentina</code><code>
</code><code class="mi">1</code><code>                     </code><code class="n">Ivo</code><code> </code><code class="n">Andric</code><code> </code><code class="o">*</code><code>               </code><a class="co" href="#callout_cleaning_data_with_pandas_CO2-1" id="co_cleaning_data_with_pandas_CO2-3"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code class="mi">2</code><code>                </code><code class="n">Vladimir</code><code> </code><code class="n">Prelog</code><code> </code><code class="o">*</code><code>
</code><code class="mi">3</code><code>  </code><code class="n">Institut</code><code> </code><code class="n">de</code><code> </code><code class="n">Droit</code><code> </code><code class="n">International</code><code>     </code><code class="n">Belgium</code><code>
</code><code class="mi">4</code><code>                </code><code class="n">Auguste</code><code> </code><code class="n">Beernaert</code><code>     </code><code class="n">Belgium</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO2-1" id="callout_cleaning_data_with_pandas_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>These rows have an entry for the <code>born_in</code> field and an asterisk by their name.</p></dd>
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO2-2" id="callout_cleaning_data_with_pandas_CO2-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The <code>date_of_death</code> field has a different time format than the other rows.</p></dd>
</dl></div>
<p class="pagebreak-before">The first five winners in <a data-type="xref" href="#dataframe_head">Example 9-2</a> show a couple of useful things. First, we see the names in rows 1 and 2 are marked by an asterisk and have an entry in the <code>born_in</code> field <img alt="1" height="12" src="assets/1.png" width="12"/>. Second, note that row 2 has a different time format for <code>date_of_death</code> than the others, and that there are both month-day and day-month time formats in the <code>date_of_birth</code> field <img alt="2" height="12" src="assets/2.png" width="12"/>. This kind of inconsistency is a perennial problem for human-edited data, particularly dates and times. We’ll see how to fix it with pandas later.</p>
<p><a data-type="xref" href="#describe_objects">Example 9-1</a> gives an object count of 1,052 for the <code>born_in</code> field, indicating no empty fields, but <code>head</code> shows only rows 1 and 2 have content. This suggests that the missing fields are an empty string or space, both of which count as data to pandas. <a data-primary="missing fields" data-type="indexterm" id="idm45607776054400"/><a data-primary="NaN" data-secondary="replacing missing fields or empty strings in data with" data-type="indexterm" id="idm45607776053696"/>Let’s change them to a noncounted <code>NaN</code>, which will make more sense of the numbers. But first we’re going to need a little primer in pandas data selection.<a data-primary="pandas" data-secondary="cleaning data with" data-startref="ix_pndsclninspct" data-tertiary="inspecting data in a DataFrame" data-type="indexterm" id="idm45607776052144"/><a data-primary="DataFrames" data-secondary="inspecting data in" data-startref="ix_DaFrinspct" data-type="indexterm" id="idm45607776050560"/></p>
</div></section>
<section data-pdf-bookmark="Indices and pandas Data Selection" data-type="sect1"><div class="sect1" id="idm45607776628288">
<h1>Indices and pandas Data Selection</h1>
<p>Before beginning to clean our data, let’s do a quick recap of basic pandas data selection, using the Nobel Prize dataset as an example.<a data-primary="pandas" data-secondary="cleaning data with" data-tertiary="indices and pandas data selection" data-type="indexterm" id="ix_pndsclnindice"/><a data-primary="indices" data-secondary="and pandas data selection" data-secondary-sortas="pandas" data-type="indexterm" id="ix_indpnds"/></p>
<p>pandas indexes by rows and columns. <a data-primary="rows" data-secondary="pandas indexing" data-type="indexterm" id="idm45607776044384"/><a data-primary="columns" data-secondary="pandas indexing" data-type="indexterm" id="idm45607776043408"/>Usually column indices are specified by the data file, SQL table, and so on, but, as shown in the last chapter, we can set or override these when the DataFrame is created by using the <code>names</code> argument to pass a list of column names.<a data-primary="DataFrames" data-secondary="column and row indexing" data-type="indexterm" id="idm45607775860608"/> The columns index is accessible as a DataFrame property:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Our Nobel dataset's columns</code>
<code class="n">df</code><code class="o">.</code><code class="n">columns</code>
<code class="n">Out</code><code class="p">:</code> <code class="n">Index</code><code class="p">([</code><code class="s1">'born_in'</code><code class="p">,</code> <code class="s1">'category'</code><code class="p">,</code> <code class="s1">'date_of_birth'</code><code class="p">,</code>
<code class="o">...</code>
        <code class="s1">'place_of_death'</code><code class="p">,</code> <code class="s1">'text'</code><code class="p">,</code> <code class="s1">'year'</code><code class="p">],</code> <code class="n">dtype</code><code class="o">=</code><code class="s1">'object'</code><code class="p">)</code></pre>
<p>By default, pandas specifies a zero-base integer index for the rows, but we can override this by passing a list in the <code>index</code> parameter on creation of the DataFrame or afterward by setting the <code>index</code> property directly. More often we want to use one or more<sup><a data-type="noteref" href="ch09.xhtml#idm45607775813456" id="idm45607775813456-marker">2</a></sup> of the DataFrame’s columns as an index. We can do this using the <code>set_index</code> method. If you want to return to the default index, you can use the <code>reset_index</code> method, as shown in <a data-type="xref" href="#settingDFindex">Example 9-3</a>.</p>
<div class="pagebreak-before less_space" data-type="example" id="settingDFindex">
<h5><span class="label">Example 9-3. </span>Setting the DataFrame’s index</h5>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># set the name field as index</code><code>
</code><code class="n">df</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="o">.</code><code class="n">set_index</code><code class="p">(</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">)</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO3-1" id="co_cleaning_data_with_pandas_CO3-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code class="n">df</code><code class="o">.</code><code class="n">head</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code><code>
</code><code class="n">Out</code><code class="p">:</code><code>
</code><code>                               </code><code class="n">born_in</code><code>                </code><code class="n">category</code><code>  </code><code>\
</code><code class="n">name</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO3-2" id="co_cleaning_data_with_pandas_CO3-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code>
</code><code class="n">César</code><code> </code><code class="n">Milstein</code><code>                          </code><code class="n">Physiology</code><code> </code><code class="ow">or</code><code> </code><code class="n">Medicine</code><code>
</code><code class="n">Ivo</code><code> </code><code class="n">Andric</code><code> </code><code class="o">*</code><code>    </code><code class="n">Bosnia</code><code> </code><code class="ow">and</code><code> </code><code class="n">Herzegovina</code><code>              </code><code class="n">Literature</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code>
</code><code class="n">df</code><code class="o">.</code><code class="n">reset_index</code><code class="p">(</code><code class="n">inplace</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO3-3" id="co_cleaning_data_with_pandas_CO3-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code>
</code><code>
</code><code class="n">df</code><code class="o">.</code><code class="n">head</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code><code>
</code><code class="n">Out</code><code class="p">:</code><code>
</code><code>             </code><code class="n">name</code><code>                 </code><code class="n">born_in</code><code>                </code><code class="n">category</code><code>  </code><code>\
</code><code class="mi">0</code><code>  </code><code class="n">César</code><code> </code><code class="n">Milstein</code><code>                          </code><code class="n">Physiology</code><code> </code><code class="ow">or</code><code> </code><code class="n">Medicine</code><code>  </code><a class="co" href="#callout_cleaning_data_with_pandas_CO3-4" id="co_cleaning_data_with_pandas_CO3-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a><code>
</code><code class="mi">1</code><code>    </code><code class="n">Ivo</code><code> </code><code class="n">Andric</code><code> </code><code class="o">*</code><code>  </code><code class="n">Bosnia</code><code> </code><code class="ow">and</code><code> </code><code class="n">Herzegovina</code><code>              </code><code class="n">Literature</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO3-1" id="callout_cleaning_data_with_pandas_CO3-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Sets the frame’s index to its name column. Set the result back to <code>df</code>.</p></dd>
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO3-2" id="callout_cleaning_data_with_pandas_CO3-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The rows are now indexed by name.</p></dd>
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO3-3" id="callout_cleaning_data_with_pandas_CO3-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Resets the index to its integer. Note that we change it in place this time.</p></dd>
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO3-4" id="callout_cleaning_data_with_pandas_CO3-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>The index is now by integer position.</p></dd>
</dl></div>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>There are two ways to change a pandas DataFrame or Series: by altering the data in place or by assigning a copy. <a data-primary="DataFrames" data-secondary="changing, methods of" data-type="indexterm" id="idm45607775646384"/><a data-primary="Series (pandas)" data-secondary="changing, methods of" data-type="indexterm" id="idm45607775645536"/>There is no guarantee that in place is faster, plus method-chaining requires that the operation return a changed object. Generally, I use the <code>df = df.foo(...)</code> form, but most mutating methods have an <code>inplace</code> argument <code>df.foo(..., inplace=True)</code>.</p>
</div>
<p>Now that we understand the row-columnar indexing system, let’s start selecting slices of the DataFrame.</p>
<p>We can select a column of the DataFrame by dot notation (where no spaces or special characters are in the name) or square-bracket notation. Let’s take a look at that <code>born_in</code> column:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">bi_col</code> <code class="o">=</code> <code class="n">df</code><code class="o">.</code><code class="n">born_in</code> <code class="c1"># or bi = df['born_in']</code>
<code class="n">bi_col</code>
<code class="n">Out</code><code class="p">:</code>
<code class="mi">0</code>
<code class="mi">1</code>     <code class="n">Bosnia</code> <code class="ow">and</code> <code class="n">Herzegovina</code>
<code class="mi">2</code>     <code class="n">Bosnia</code> <code class="ow">and</code> <code class="n">Herzegovina</code>
<code class="mi">3</code>
<code class="o">...</code>
<code class="mi">1051</code>
<code class="n">Name</code><code class="p">:</code> <code class="n">born_in</code><code class="p">,</code> <code class="n">Length</code><code class="p">:</code> <code class="mi">1052</code><code class="p">,</code> <code class="n">dtype</code><code class="p">:</code> <code class="nb">object</code>

<code class="nb">type</code><code class="p">(</code><code class="n">bi_col</code><code class="p">)</code>
<code class="n">Out</code><code class="p">:</code> <code class="n">pandas</code><code class="o">.</code><code class="n">core</code><code class="o">.</code><code class="n">series</code><code class="o">.</code><code class="n">Series</code></pre>
<p>Note that the column selection returns a pandas Series, with the DataFrame indexing preserved.</p>
<p>DataFrames and Series share the same methods for accessing rows/members. <code>iloc</code> selects by integer position, and <code>loc</code> selects by label.<a data-primary="iloc method" data-type="indexterm" id="idm45607775563120"/><a data-primary="loc method" data-type="indexterm" id="idm45607775562512"/><a data-primary="DataFrames" data-secondary="methods accessing rows/members, iloc and loc" data-type="indexterm" id="idm45607775561840"/><a data-primary="Series (pandas)" data-secondary="methods accessing rows/members, iloc and loc" data-type="indexterm" id="idm45607775560928"/>
Let’s use <code>iloc</code> to grab the first row of our DataFrame:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># access the first row</code>
<code class="n">df</code><code class="o">.</code><code class="n">iloc</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>
<code class="n">Out</code><code class="p">:</code>
<code class="n">name</code>                                 <code class="n">César</code> <code class="n">Milstein</code>
<code class="n">born_in</code>
<code class="n">category</code>                             <code class="n">Physiology</code> <code class="ow">or</code> <code class="n">Medicine</code>
<code class="o">...</code>

<code class="c1"># set the index to 'name' and access by name-label</code>
<code class="n">df</code><code class="o">.</code><code class="n">set_index</code><code class="p">(</code><code class="s1">'name'</code><code class="p">,</code> <code class="n">inplace</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code>
<code class="n">df</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="s1">'Albert Einstein'</code><code class="p">]</code>
<code class="n">Out</code><code class="p">:</code>
                 <code class="n">born_in</code> <code class="n">category</code>      <code class="n">country</code>  <code class="o">...</code>
<code class="n">name</code>
<code class="n">Albert</code> <code class="n">Einstein</code>           <code class="n">Physics</code>  <code class="n">Switzerland</code>  <code class="o">...</code>
<code class="n">Albert</code> <code class="n">Einstein</code>           <code class="n">Physics</code>      <code class="n">Germany</code>  <code class="o">...</code>
<code class="o">...</code></pre>
<section data-pdf-bookmark="Selecting Multiple Rows" data-type="sect2"><div class="sect2" id="idm45607775532160">
<h2>Selecting Multiple Rows</h2>
<p>Standard Python array slicing can <a data-primary="rows" data-secondary="selecting multiple rows in DataFrame using array slicing" data-type="indexterm" id="idm45607775467872"/><a data-primary="DataFrames" data-secondary="selecting multiple rows using array slicing" data-type="indexterm" id="idm45607775467136"/><a data-primary="arrays" data-secondary="Python array slicing in DataFrame" data-type="indexterm" id="idm45607775466224"/>be used with a DataFrame to select multiple rows:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># select the first 10 rows</code>
<code class="n">df</code><code class="p">[</code><code class="mi">0</code><code class="p">:</code><code class="mi">10</code><code class="p">]</code>
<code class="n">Out</code><code class="p">:</code>
                  <code class="n">born_in</code>                <code class="n">category</code>   <code class="n">date_of_b</code><code class="o">..</code>
<code class="mi">0</code>                          <code class="n">Physiology</code> <code class="ow">or</code> <code class="n">Medicine</code>  <code class="mi">8</code> <code class="n">October</code> <code class="o">..</code>
<code class="mi">1</code>  <code class="n">Bosnia</code> <code class="ow">and</code> <code class="n">Herzegovina</code>              <code class="n">Literature</code>  <code class="mi">9</code> <code class="n">October</code> <code class="o">..</code>
<code class="o">...</code>
<code class="mi">9</code>                                           <code class="n">Peace</code>      <code class="mi">1910</code><code class="o">-</code><code class="mf">0.</code><code class="o">.</code>
<code class="c1"># select the last four rows</code>
<code class="n">df</code><code class="p">[</code><code class="o">-</code><code class="mi">4</code><code class="p">:]</code>
<code class="n">Out</code><code class="p">:</code>
     <code class="n">born_in</code>                <code class="n">category</code>      <code class="n">date_of_birth</code> <code class="n">date_</code><code class="o">..</code>
<code class="mi">1048</code>                           <code class="n">Peace</code>   <code class="n">November</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">1878</code>   <code class="n">May</code><code class="o">..</code>
<code class="mi">1049</code>          <code class="n">Physiology</code> <code class="ow">or</code> <code class="n">Medicine</code>         <code class="mi">1887</code><code class="o">-</code><code class="mi">04</code><code class="o">-</code><code class="mi">10</code>    <code class="mf">19.</code><code class="o">.</code>
<code class="mi">1050</code>                       <code class="n">Chemistry</code>           <code class="mi">1906</code><code class="o">-</code><code class="mi">9</code><code class="o">-</code><code class="mi">6</code>     <code class="mf">1.</code><code class="o">.</code>
<code class="mi">1051</code>                           <code class="n">Peace</code>  <code class="n">November</code> <code class="mi">26</code><code class="p">,</code> <code class="mi">1931</code>      <code class="o">..</code></pre>
<p>The standard way to select multiple rows based on a conditional expression (e.g., is the value of the column <code>value</code> greater than <code>x</code>) is to create a Boolean mask and use it in a selector. <a data-primary="Boolean expressions" data-secondary="constructing for Boolean masks" data-type="indexterm" id="idm45607775447520"/><a data-primary="Boolean masks" data-type="indexterm" id="idm45607775406544"/>Let’s find all the Nobel Prize winners after the year 2000. First, we create a mask by performing a Boolean expression on each of the rows:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">mask</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="o">.</code><code class="n">year</code><code> </code><code class="o">&gt;</code><code> </code><code class="mi">2000</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO4-1" id="co_cleaning_data_with_pandas_CO4-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code class="n">mask</code><code>
</code><code class="n">Out</code><code class="p">:</code><code>
</code><code class="mi">0</code><code>     </code><code class="kc">False</code><code>
</code><code class="mi">1</code><code>     </code><code class="kc">False</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="mi">13</code><code>     </code><code class="kc">True</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="mi">1047</code><code>     </code><code class="kc">True</code><code>
</code><code class="mi">1048</code><code>    </code><code class="kc">False</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="n">Name</code><code class="p">:</code><code> </code><code class="n">year</code><code class="p">,</code><code> </code><code class="n">Length</code><code class="p">:</code><code> </code><code class="mi">1052</code><code class="p">,</code><code> </code><code class="n">dtype</code><code class="p">:</code><code> </code><code class="nb">bool</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO4-1" id="callout_cleaning_data_with_pandas_CO4-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p><code>True</code> for all rows where the <code>year</code> field is greater than 2000.</p></dd>
</dl>
<p>The resulting Boolean mask shares our DataFrame’s index and can be used to select all <code>True</code> rows:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">mask</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="o">.</code><code class="n">year</code><code> </code><code class="o">&gt;</code><code> </code><code class="mi">2000</code><code>
</code><code class="n">winners_since_2000</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="p">[</code><code class="n">mask</code><code class="p">]</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO5-1" id="co_cleaning_data_with_pandas_CO5-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code class="n">winners_since_2000</code><code class="o">.</code><code class="n">count</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">Out</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="n">year</code><code>              </code><code class="mi">202</code><code> </code><code class="c1"># number of winners since 2000</code><code>
</code><code class="n">dtype</code><code class="p">:</code><code> </code><code class="n">int64</code><code>
</code><code>
</code><code class="n">winners_since_2000</code><code class="o">.</code><code class="n">head</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">Out</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code>                                               </code><code class="n">text</code><code>  </code><code class="n">year</code><code>
</code><code class="mi">13</code><code>                 </code><code class="n">François</code><code> </code><code class="n">Englert</code><code> </code><code class="p">,</code><code> </code><code class="n">Physics</code><code class="p">,</code><code> </code><code class="mi">2013</code><code>  </code><code class="mi">2013</code><code>
</code><code class="mi">32</code><code>      </code><code class="n">Christopher</code><code> </code><code class="n">A</code><code class="o">.</code><code> </code><code class="n">Pissarides</code><code> </code><code class="p">,</code><code> </code><code class="n">Economics</code><code class="p">,</code><code> </code><code class="mi">2010</code><code>  </code><code class="mi">2010</code><code>
</code><code class="mi">66</code><code>                         </code><code class="n">Kofi</code><code> </code><code class="n">Annan</code><code> </code><code class="p">,</code><code> </code><code class="n">Peace</code><code class="p">,</code><code> </code><code class="mi">2001</code><code>  </code><code class="mi">2001</code><code>
</code><code class="mi">87</code><code>               </code><code class="n">Riccardo</code><code> </code><code class="n">Giacconi</code><code> </code><code class="o">*</code><code class="p">,</code><code> </code><code class="n">Physics</code><code class="p">,</code><code> </code><code class="mi">2002</code><code>  </code><code class="mi">2002</code><code>
</code><code class="mi">88</code><code>   </code><code class="n">Mario</code><code> </code><code class="n">Capecchi</code><code> </code><code class="o">*</code><code class="p">,</code><code> </code><code class="n">Physiology</code><code> </code><code class="ow">or</code><code> </code><code class="n">Medicine</code><code class="p">,</code><code> </code><code class="mi">2007</code><code>  </code><code class="mi">2007</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO5-1" id="callout_cleaning_data_with_pandas_CO5-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>This will return a DataFrame containing only those rows where the Boolean <code>mask</code> array is <code>True</code>.</p></dd>
</dl>
<p>Boolean masking is a very powerful technique capable of selecting any subset of the data you need. I recommend setting a few targets to practice constructing the right Boolean expressions. Generally, we dispense with the intermediate mask creation:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">winners_since_2000</code> <code class="o">=</code> <code class="n">df</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">year</code> <code class="o">&gt;</code> <code class="mi">2000</code><code class="p">]</code></pre>
<p>Now that we can select individual and multiple rows by slicing or using a Boolean mask, in the next sections we’ll see how we can change our DataFrame, purging it of dirty data as we go.<a data-primary="indices" data-secondary="and pandas data selection" data-secondary-sortas="pandas" data-startref="ix_indpnds" data-type="indexterm" id="idm45607775080992"/><a data-primary="pandas" data-secondary="cleaning data with" data-startref="ix_pndsclnindice" data-tertiary="indices and pandas data selection" data-type="indexterm" id="idm45607775079664"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Cleaning the Data" data-type="sect1"><div class="sect1" id="idm45607776049008">
<h1>Cleaning the Data</h1>
<p>Now that we know how to access our data, let’s see how we can change it for the better, starting with what looks like empty <code>born_in</code> fields we saw in <a data-type="xref" href="#dataframe_head">Example 9-2</a>. If we look at the count of the <code>born_in</code> columns, it doesn’t show any missing rows, which it would were any fields missing or <code>NaN</code>  (not a number):</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">0</code><code class="p">]:</code> <code class="n">df</code><code class="o">.</code><code class="n">born_in</code><code class="o">.</code><code class="n">describe</code><code class="p">()</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">0</code><code class="p">]:</code>
<code class="n">count</code>     <code class="mi">1052</code>
<code class="n">unique</code>      <code class="mi">40</code>
<code class="n">top</code>
<code class="n">freq</code>       <code class="mi">910</code>
<code class="n">Name</code><code class="p">:</code> <code class="n">born_in</code><code class="p">,</code> <code class="n">dtype</code><code class="p">:</code> <code class="nb">object</code></pre>
<section data-pdf-bookmark="Finding Mixed Types" data-type="sect2"><div class="sect2" id="idm45607775035216">
<h2>Finding Mixed Types</h2>
<p>Note that pandas stores all string-like data using the <code>dtype</code> object.<a data-primary="dtype object" data-type="indexterm" id="idm45607775000288"/><a data-primary="pandas" data-secondary="cleaning data with" data-tertiary="finding mixed types" data-type="indexterm" id="idm45607774999552"/><a data-primary="datatypes, mixed, finding in columns using pandas" data-type="indexterm" id="idm45607774998336"/> A cursory inspection suggests that the column is a mixture of empty and country-name strings. <a data-primary="type function" data-type="indexterm" id="idm45607774997456"/>We can quickly check that all the column members are strings by mapping the Python <a href="https://oreil.ly/jj9hY"><code>type</code> function</a> to all members using the <code>apply</code> method and then making a set of the resulting list of column members by type:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="nb">set</code><code class="p">(</code><code class="n">df</code><code class="o">.</code><code class="n">born_in</code><code class="o">.</code><code class="n">apply</code><code class="p">(</code><code class="nb">type</code><code class="p">))</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="p">{</code><code class="nb">str</code><code class="p">}</code></pre>
<p>This shows that all of the <code>born_in</code> column members are strings of type <code>str</code>. Now let’s replace any empty strings with an empty field.</p>
</div></section>
<section data-pdf-bookmark="Replacing Strings" data-type="sect2"><div class="sect2" id="idm45607774965568">
<h2>Replacing Strings</h2>
<p>We want to replace these empty strings with a <code>NaN</code>, to prevent them being counted.<sup><a data-type="noteref" href="ch09.xhtml#idm45607774963264" id="idm45607774963264-marker">3</a></sup> <a data-primary="NaN" data-secondary="replacing empty strings with, using pandas" data-type="indexterm" id="idm45607774962160"/><a data-primary="strings" data-secondary="empty, replacing with NaN in pandas DataFrame" data-type="indexterm" id="idm45607774961216"/>The pandas <code>replace</code> method is tailor-made for this and can be applied to the whole DataFrame or individual Series:</p>
<pre data-code-language="python" data-type="programlisting"><code class="kn">import</code><code> </code><code class="nn">numpy</code><code> </code><code class="k">as</code><code> </code><code class="nn">np</code><code>
</code><code>
</code><code class="n">bi_col</code><code class="o">.</code><code class="n">replace</code><code class="p">(</code><code class="s1">'</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">np</code><code class="o">.</code><code class="n">nan</code><code class="p">,</code><code> </code><code class="n">inplace</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code><code>
</code><code class="n">bi_col</code><code>
</code><code class="n">Out</code><code class="p">:</code><code>
</code><code class="mi">0</code><code>                        </code><code class="n">NaN</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO6-1" id="co_cleaning_data_with_pandas_CO6-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code class="mi">1</code><code>     </code><code class="n">Bosnia</code><code> </code><code class="ow">and</code><code> </code><code class="n">Herzegovina</code><code>
</code><code class="mi">2</code><code>     </code><code class="n">Bosnia</code><code> </code><code class="ow">and</code><code> </code><code class="n">Herzegovina</code><code>
</code><code class="mi">3</code><code>                        </code><code class="n">NaN</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code>
</code><code class="n">bi_col</code><code class="o">.</code><code class="n">count</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">Out</code><code class="p">:</code><code> </code><code class="mi">142</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO6-2" id="co_cleaning_data_with_pandas_CO6-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO6-1" id="callout_cleaning_data_with_pandas_CO6-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Our empty <code>''</code> strings have been replaced with NumPy’s <code>NaN</code>.</p></dd>
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO6-2" id="callout_cleaning_data_with_pandas_CO6-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Unlike the empty strings, the <code>NaN</code> fields are discounted.</p></dd>
</dl>
<p>After replacing the empty strings with <code>NaN</code>s, we get a true count of 142 for the <code>born_in</code> field.</p>
<p>Let’s replace all empty strings in our DataFrame with discounted <code>NaN</code>s:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code class="o">.</code><code class="n">replace</code><code class="p">(</code><code class="s1">''</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">nan</code><code class="p">,</code> <code class="n">inplace</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code></pre>
<p>pandas allows sophisticated replacement of strings (and other objects) in columns (e.g., allowing you to craft <a href="https://oreil.ly/KK3b2">regular expressions or regexes</a>,  which are applied to whole Series, typically DataFrame columns). Let’s look at a little example, using the asterisk-marked names in our Nobel Prize DataFrame.<a data-primary="regular expressions" data-secondary="crafting for replacements in pandas DataFrames" data-type="indexterm" id="idm45607774828576"/></p>
<p><a data-type="xref" href="#dataframe_head">Example 9-2</a>  showed that some of our Nobel Prize names are marked with an asterisk, denoting that these winners are recorded by country of birth, not country at the time of winning the prize:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code class="o">.</code><code class="n">head</code><code class="p">()</code>
<code class="n">Out</code><code class="p">:</code>
<code class="o">...</code>
                              <code class="n">name</code> <code class="n">country</code>  \
<code class="mi">0</code>                   <code class="n">César</code> <code class="n">Milstein</code>   <code class="n">Argentina</code>
<code class="mi">1</code>                     <code class="n">Ivo</code> <code class="n">Andric</code> <code class="o">*</code>
<code class="mi">2</code>                <code class="n">Vladimir</code> <code class="n">Prelog</code> <code class="o">*</code>
<code class="mi">3</code>  <code class="n">Institut</code> <code class="n">de</code> <code class="n">Droit</code> <code class="n">International</code>     <code class="n">Belgium</code>
<code class="mi">4</code>                <code class="n">Auguste</code> <code class="n">Beernaert</code>     <code class="n">Belgium</code></pre>
<p>Let’s set ourselves the task of cleaning up those names by removing the asterisks and stripping any remaining whitespace.</p>
<p>pandas Series have a handy <code>str</code> member, which provides a number of useful string methods to be performed on the array. <a data-primary="Series (pandas)" data-secondary="str member and string methods" data-type="indexterm" id="idm45607774770288"/><a data-primary="strings" data-secondary="str member of Series and its string methods" data-type="indexterm" id="idm45607774769440"/>Let’s use it to check how many asterisked names we have:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">name</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">contains</code><code class="p">(</code><code class="sa">r</code><code class="s1">'</code><code class="s1">\</code><code class="s1">*</code><code class="s1">'</code><code class="p">)</code><code class="p">]</code><code class="p">[</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">]</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO7-1" id="co_cleaning_data_with_pandas_CO7-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code class="n">Out</code><code class="p">:</code><code>
</code><code class="mi">1</code><code>              </code><code class="n">Ivo</code><code> </code><code class="n">Andric</code><code> </code><code class="o">*</code><code>
</code><code class="mi">2</code><code>         </code><code class="n">Vladimir</code><code> </code><code class="n">Prelog</code><code> </code><code class="o">*</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="mi">1041</code><code>       </code><code class="n">John</code><code> </code><code class="n">Warcup</code><code> </code><code class="n">Cornforth</code><code> </code><code class="o">*</code><code>
</code><code class="mi">1046</code><code>      </code><code class="n">Elizabeth</code><code> </code><code class="n">H</code><code class="o">.</code><code> </code><code class="n">Blackburn</code><code> </code><code class="o">*</code><code>
</code><code class="n">Name</code><code class="p">:</code><code> </code><code class="n">name</code><code class="p">,</code><code> </code><code class="n">Length</code><code class="p">:</code><code> </code><code class="mi">142</code><code class="p">,</code><code> </code><code class="n">dtype</code><code class="p">:</code><code> </code><code class="nb">object</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO7-2" id="co_cleaning_data_with_pandas_CO7-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO7-1" id="callout_cleaning_data_with_pandas_CO7-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>We use <code>str</code>’s <code>contains</code> method on the <code>name</code> column. Note that we have to escape the asterisk (<code>'\*'</code>) as this is a regex string. The Boolean mask is then applied to our Nobel Prize DataFrame and the resulting names listed.</p></dd>
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO7-2" id="callout_cleaning_data_with_pandas_CO7-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>142 of our 1,052 rows have a name containing <code>*</code>.</p></dd>
</dl>
<p>To clean up the names, let’s replace the asterisks with an empty string and strip any whitespace from the resulting names:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code class="o">.</code><code class="n">name</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="o">.</code><code class="n">name</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">replace</code><code class="p">(</code><code class="s1">'</code><code class="s1">*</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">regex</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO8-1" id="co_cleaning_data_with_pandas_CO8-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code class="c1"># strip the whitespace from the names</code><code>
</code><code class="n">df</code><code class="o">.</code><code class="n">name</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="o">.</code><code class="n">name</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">strip</code><code class="p">(</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO8-1" id="callout_cleaning_data_with_pandas_CO8-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Removes all asterisks in the name fields and return the result to the DataFrame. Note that we have to explicitly set the <code>regex</code> flag to <code>True</code>.</p></dd>
</dl>
<p>A quick check shows that the names are now clean:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">name</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">contains</code><code class="p">(</code><code class="s1">'\*'</code><code class="p">)]</code>
<code class="n">Out</code><code class="p">:</code>
<code class="n">Empty</code> <code class="n">DataFrame</code></pre>
<p>pandas Series have an impressive number of string-handling functions, enabling you to search and adapt your string columns. You can find a full list of these <a href="https://oreil.ly/2mCSZ">in the API docs</a>.</p>
</div></section>
<section data-pdf-bookmark="Removing Rows" data-type="sect2"><div class="sect2" id="removing_rows">
<h2>Removing Rows</h2>
<p>To recap, the 142 winners with <code>born_in</code> fields are duplicates, having an entry in the Wikipedia biography page by both the country they were born in and their country when given the prize.<a data-primary="pandas" data-secondary="cleaning data with" data-tertiary="removing rows" data-type="indexterm" id="idm45607774533152"/><a data-primary="rows" data-secondary="removing from data using pandas" data-type="indexterm" id="idm45607774532016"/> Although the former could form the basis of an interesting visualization,<sup><a data-type="noteref" href="ch09.xhtml#idm45607774530976" id="idm45607774530976-marker">4</a></sup> for our visualization we want each individual prize represented once only and so need to remove these from our DataFrame.</p>
<p>We want to create a new DataFrame using only those rows with a <code>NaN</code> <code>born_in</code> field. You might naively assume that a conditional expression comparing the <code>born_in</code> field to <code>NaN</code> would work here, but by definition<sup><a data-type="noteref" href="ch09.xhtml#idm45607774527728" id="idm45607774527728-marker">5</a></sup> <code>NaN</code> Boolean comparisons always return <code>False</code>:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">np</code><code class="o">.</code><code class="n">nan</code> <code class="o">==</code> <code class="n">np</code><code class="o">.</code><code class="n">nan</code>
<code class="n">Out</code><code class="p">:</code> <code class="kc">False</code></pre>
<p>As a result, pandas provides the dedicated <code>isnull</code> method <a data-primary="isnull method" data-type="indexterm" id="idm45607774522256"/><a data-primary="null fields, checking for in pandas" data-type="indexterm" id="idm45607774521648"/>to check for discounted (null) fields:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">born_in</code><code class="o">.</code><code class="n">isnull</code><code class="p">(</code><code class="p">)</code><code class="p">]</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO9-1" id="co_cleaning_data_with_pandas_CO9-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code class="n">df</code><code class="o">.</code><code class="n">count</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">Out</code><code class="p">:</code><code>
</code><code class="n">born_in</code><code>             </code><code class="mi">0</code><code> </code><code class="c1"># all entries now empty</code><code>
</code><code class="n">category</code><code>          </code><code class="mi">910</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="n">dtype</code><code class="p">:</code><code> </code><code class="n">int64</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO9-1" id="callout_cleaning_data_with_pandas_CO9-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p><code>isnull</code> produces a Boolean mask with <code>True</code> for all rows with an empty <code>born_in</code> field.<a data-primary="Boolean masks" data-type="indexterm" id="idm45607774440096"/></p></dd>
</dl>
<p>The <code>born_in</code> column is no longer of use, so let’s remove it for now:<sup><a data-type="noteref" href="ch09.xhtml#idm45607774438432" id="idm45607774438432-marker">6</a></sup></p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="o">.</code><code class="n">drop</code><code class="p">(</code><code class="s1">'</code><code class="s1">born_in</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">axis</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO10-1" id="co_cleaning_data_with_pandas_CO10-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO10-1" id="callout_cleaning_data_with_pandas_CO10-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p><code>drop</code> takes a single label or index (or list of same) as a first argument and an <code>axis</code> argument to indicate row (<code>0</code> and default)  or column (<code>1</code>) index.<a data-primary="drop method (pandas DataFrame)" data-type="indexterm" id="idm45607774388320"/></p></dd>
</dl>
</div></section>
<section data-pdf-bookmark="Finding Duplicates" data-type="sect2"><div class="sect2" id="idm45607774537408">
<h2>Finding Duplicates</h2>
<p>Now, a quick internet search shows that 889 people and organizations have received the Nobel Prize up to 2015.<a data-primary="pandas" data-secondary="cleaning data with" data-tertiary="finding duplicates" data-type="indexterm" id="ix_pndsclndup"/><a data-primary="duplicate data" data-secondary="finding duplicates using pandas" data-type="indexterm" id="ix_dupfnd"/> With 910 remaining rows, we still have a few duplicates or anomalies to account for.</p>
<p>pandas has a handy <code>duplicated</code> method for finding matching rows. This matches by column name or list of column names.<a data-primary="duplicated method (pandas)" data-type="indexterm" id="idm45607774358352"/> Let’s get the list of all duplicates by name:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">dupes_by_name</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">duplicated</code><code class="p">(</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">)</code><code class="p">]</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO11-1" id="co_cleaning_data_with_pandas_CO11-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code class="n">dupes_by_name</code><code class="o">.</code><code class="n">count</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">Out</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="n">year</code><code>              </code><code class="mi">46</code><code>
</code><code class="n">dtype</code><code class="p">:</code><code> </code><code class="n">int64</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO11-1" id="callout_cleaning_data_with_pandas_CO11-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p><code>duplicated</code> returns a Boolean array with <code>True</code> for the first occurrence of any rows with the same <code>name</code> field.</p></dd>
</dl>
<p>Now, a few people have won the Nobel Prize more than once but not 46, which means 40-odd winners are duplicated. Given that the Wikipedia page we scraped listed prize winners by country, the best bet is winners being “claimed” by more than one country.</p>
<p>Let’s look at some of the ways we can find duplicates by name in our Nobel Prize DataFrame. Some of these are pretty inefficient, but it’s a nice way to demonstrate a few pandas functions.</p>
<p>By default, <code>duplicated</code> indicates (Boolean <code>True</code>) all duplicates after the first occurrence, but setting the <code>keep</code> option to <code><em>last</em></code>  sets the first occurrence of duplicated rows to <code>True</code>. By combining these two calls using a Boolean <em>or</em> (|), we can get the full list of duplicates:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">all_dupes</code> <code class="o">=</code> <code class="n">df</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">duplicated</code><code class="p">(</code><code class="s1">'name'</code><code class="p">)</code>\
               <code class="o">|</code> <code class="n">df</code><code class="o">.</code><code class="n">duplicated</code><code class="p">(</code><code class="s1">'name'</code><code class="p">,</code> <code class="n">keep</code><code class="o">=</code><code class="s1">'last'</code><code class="p">)]</code>
<code class="n">all_dupes</code><code class="o">.</code><code class="n">count</code><code class="p">()</code>
<code class="n">Out</code><code class="p">:</code>
<code class="o">...</code>
<code class="n">year</code>              <code class="mi">92</code>
<code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>We could also get all the duplicates by testing whether our DataFrame rows have a name in the list of duplicate names. <a data-primary="isin method (pandas)" data-type="indexterm" id="idm45607774269072"/>pandas has a handy <code>isin</code> method for this:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">all_dupes</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">name</code><code class="o">.</code><code class="n">isin</code><code class="p">(</code><code class="n">dupes_by_name</code><code class="o">.</code><code class="n">name</code><code class="p">)</code><code class="p">]</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO12-1" id="co_cleaning_data_with_pandas_CO12-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code class="n">all_dupes</code><code class="o">.</code><code class="n">count</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">Out</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="n">year</code><code>              </code><code class="mi">92</code><code>
</code><code class="n">dtype</code><code class="p">:</code><code> </code><code class="n">int64</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO12-1" id="callout_cleaning_data_with_pandas_CO12-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p><code>dupes_by_name.name</code> is a column Series containing all the duplicated names.</p></dd>
</dl>
<p>We can also find all duplicates by using pandas’s powerful <code>groupby</code> method, which groups our <a data-primary="groupby method (pandas)" data-type="indexterm" id="idm45607774194720"/>DataFrame’s rows by column or list of columns. It returns a list of key-value pairs with the column value(s) as key and list of rows as values:</p>
<pre data-code-language="python" data-type="programlisting"><code class="k">for</code><code> </code><code class="n">name</code><code class="p">,</code><code> </code><code class="n">rows</code><code> </code><code class="ow">in</code><code> </code><code class="n">df</code><code class="o">.</code><code class="n">groupby</code><code class="p">(</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">)</code><code class="p">:</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO13-1" id="co_cleaning_data_with_pandas_CO13-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">name: </code><code class="si">%s</code><code class="s1">, number of rows: </code><code class="si">%d</code><code class="s1">'</code><code class="o">%</code><code class="p">(</code><code class="n">name</code><code class="p">,</code><code> </code><code class="nb">len</code><code class="p">(</code><code class="n">rows</code><code class="p">)</code><code class="p">)</code><code class="p">)</code><code>
</code><code>
</code><code class="n">name</code><code class="p">:</code><code> </code><code class="n">A</code><code class="o">.</code><code> </code><code class="n">Michael</code><code> </code><code class="n">Spence</code><code class="p">,</code><code> </code><code class="n">number</code><code> </code><code class="n">of</code><code> </code><code class="n">rows</code><code class="p">:</code><code> </code><code class="mi">1</code><code>
</code><code class="n">name</code><code class="p">:</code><code> </code><code class="n">Aage</code><code> </code><code class="n">Bohr</code><code class="p">,</code><code> </code><code class="n">number</code><code> </code><code class="n">of</code><code> </code><code class="n">rows</code><code class="p">:</code><code> </code><code class="mi">1</code><code>
</code><code class="n">name</code><code class="p">:</code><code> </code><code class="n">Aaron</code><code> </code><code class="n">Ciechanover</code><code class="p">,</code><code> </code><code class="n">number</code><code> </code><code class="n">of</code><code> </code><code class="n">rows</code><code class="p">:</code><code> </code><code class="mi">1</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO13-1" id="callout_cleaning_data_with_pandas_CO13-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p><code>groupby</code> returns an iterator of (group name, group) tuples.</p></dd>
</dl>
<p>In order to get all duplicate rows, we merely need to check the length of the list of rows returned by key. Anything greater than one has name duplicates. Here we use pandas’s <code>concat</code> method, which takes a list of row lists and creates a DataFrame with all the duplicated rows.<a data-primary="concat method (pandas)" data-type="indexterm" id="idm45607774087264"/> A Python list constructor is used to filter for groups with more than one row:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">pd</code><code class="o">.</code><code class="n">concat</code><code class="p">(</code><code class="p">[</code><code class="n">g</code><code> </code><code class="k">for</code><code> </code><code class="n">_</code><code class="p">,</code><code class="n">g</code><code> </code><code class="ow">in</code><code> </code><code class="n">df</code><code class="o">.</code><code class="n">groupby</code><code class="p">(</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">)</code><code>\</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO14-1" id="co_cleaning_data_with_pandas_CO14-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code>                     </code><code class="k">if</code><code> </code><code class="nb">len</code><code class="p">(</code><code class="n">g</code><code class="p">)</code><code> </code><code class="o">&gt;</code><code> </code><code class="mi">1</code><code class="p">]</code><code class="p">)</code><code class="p">[</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">]</code><code>
</code><code>
</code><code class="n">Out</code><code class="p">:</code><code>
</code><code class="mi">121</code><code>           </code><code class="n">Aaron</code><code> </code><code class="n">Klug</code><code>
</code><code class="mi">131</code><code>           </code><code class="n">Aaron</code><code> </code><code class="n">Klug</code><code>
</code><code class="mi">615</code><code>      </code><code class="n">Albert</code><code> </code><code class="n">Einstein</code><code>
</code><code class="mi">844</code><code>      </code><code class="n">Albert</code><code> </code><code class="n">Einstein</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="mi">489</code><code>      </code><code class="n">Yoichiro</code><code> </code><code class="n">Nambu</code><code>
</code><code class="mi">773</code><code>      </code><code class="n">Yoichiro</code><code> </code><code class="n">Nambu</code><code>
</code><code class="n">Name</code><code class="p">:</code><code> </code><code class="n">name</code><code class="p">,</code><code> </code><code class="n">Length</code><code class="p">:</code><code> </code><code class="mi">92</code><code class="p">,</code><code> </code><code class="n">dtype</code><code class="p">:</code><code> </code><code class="nb">object</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO14-1" id="callout_cleaning_data_with_pandas_CO14-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Create a Python list by filtering the <code>name</code> row groups for those with more than one row (i.e., duplicated names).</p></dd>
</dl>
<div data-type="tip"><h1>Different Paths to the Same Goal</h1>
<p>With a large library like pandas, there are usually a number of ways to achieve the same thing. With small datasets like our Nobel Prize winners, any one will do, but for large datasets there could be significant performance implications. Just because pandas will do what you ask doesn’t mean it’s necessarily efficient. With a lot of complex data manipulation going on behind the scenes, it’s a good idea to be prepared to be flexible and alert to inefficient approaches.<a data-primary="pandas" data-secondary="cleaning data with" data-startref="ix_pndsclndup" data-tertiary="finding duplicates" data-type="indexterm" id="idm45607773967392"/><a data-primary="duplicate data" data-secondary="finding duplicates using pandas" data-startref="ix_dupfnd" data-type="indexterm" id="idm45607773965872"/></p>
</div>
</div></section>
<section data-pdf-bookmark="Sorting Data" data-type="sect2"><div class="sect2" id="idm45607774386896">
<h2>Sorting Data</h2>
<p>Now that we have our <code>all_dupes</code> DataFrame, with all duplicated rows by name, let’s use it to demonstrate pandas’s <code>sort</code> method.<a data-primary="sorting data" data-type="indexterm" id="idm45607773962160"/><a data-primary="pandas" data-secondary="cleaning data with" data-tertiary="sorting data" data-type="indexterm" id="idm45607773961424"/></p>
<p>pandas provides a sophisticated <code>sort</code> method for the DataFrame and Series classes, capable of sorting on multiple <a data-primary="Series (pandas)" data-secondary="sort method" data-type="indexterm" id="idm45607773921568"/><a data-primary="DataFrames" data-secondary="sort method" data-type="indexterm" id="idm45607773920720"/>column names:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df2</code><code> </code><code class="o">=</code><code> </code><code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code><code>\
</code><code>     </code><code class="p">{</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">:</code><code class="p">[</code><code class="s1">'</code><code class="s1">zak</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">alice</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">bob</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">mike</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">bob</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">bob</code><code class="s1">'</code><code class="p">]</code><code class="p">,</code><code>\
</code><code>      </code><code class="s1">'</code><code class="s1">score</code><code class="s1">'</code><code class="p">:</code><code class="p">[</code><code class="mi">4</code><code class="p">,</code><code> </code><code class="mi">3</code><code class="p">,</code><code> </code><code class="mi">5</code><code class="p">,</code><code> </code><code class="mi">2</code><code class="p">,</code><code> </code><code class="mi">3</code><code class="p">,</code><code> </code><code class="mi">7</code><code class="p">]</code><code class="p">}</code><code class="p">)</code><code>
</code><code class="n">df2</code><code class="o">.</code><code class="n">sort_values</code><code class="p">(</code><code class="p">[</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">score</code><code class="s1">'</code><code class="p">]</code><code class="p">,</code><code>\</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO15-1" id="co_cleaning_data_with_pandas_CO15-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code>        </code><code class="n">ascending</code><code class="o">=</code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">0</code><code class="p">]</code><code class="p">)</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO15-2" id="co_cleaning_data_with_pandas_CO15-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code>
</code><code>
</code><code class="n">Out</code><code class="p">:</code><code>
</code><code>    </code><code class="n">name</code><code>  </code><code class="n">score</code><code>
</code><code class="mi">1</code><code>  </code><code class="n">alice</code><code>      </code><code class="mi">3</code><code>
</code><code class="mi">5</code><code>    </code><code class="n">bob</code><code>      </code><code class="mi">7</code><code>
</code><code class="mi">2</code><code>    </code><code class="n">bob</code><code>      </code><code class="mi">5</code><code>
</code><code class="mi">4</code><code>    </code><code class="n">bob</code><code>      </code><code class="mi">3</code><code>
</code><code class="mi">3</code><code>   </code><code class="n">mike</code><code>      </code><code class="mi">2</code><code>
</code><code class="mi">0</code><code>    </code><code class="n">zak</code><code>      </code><code class="mi">4</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO15-1" id="callout_cleaning_data_with_pandas_CO15-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Sorts the DataFrame first by name, then by score within those subgroups. Older pandas versions use <code>sort</code>, now deprecated.</p></dd>
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO15-2" id="callout_cleaning_data_with_pandas_CO15-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Sorts the names in alphabetical ascending order; sorts scores from high to low.</p></dd>
</dl>
<p>Let’s sort the DataFrame of <code>all_dupes</code> by name and then look at the name, country, and year columns:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">306</code><code class="p">]:</code> <code class="n">all_dupes</code><code class="o">.</code><code class="n">sort_values</code><code class="p">(</code><code class="s1">'name'</code><code class="p">)</code>\
  <code class="p">[[</code><code class="s1">'name'</code><code class="p">,</code> <code class="s1">'country'</code><code class="p">,</code> <code class="s1">'year'</code><code class="p">]]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">306</code><code class="p">]:</code>
                          <code class="n">name</code>         <code class="n">country</code>  <code class="n">year</code>
<code class="mi">121</code>                 <code class="n">Aaron</code> <code class="n">Klug</code>    <code class="n">South</code> <code class="n">Africa</code>  <code class="mi">1982</code>
<code class="mi">131</code>                 <code class="n">Aaron</code> <code class="n">Klug</code>  <code class="n">United</code> <code class="n">Kingdom</code>  <code class="mi">1982</code>
<code class="mi">844</code>            <code class="n">Albert</code> <code class="n">Einstein</code>         <code class="n">Germany</code>  <code class="mi">1921</code>
<code class="mi">615</code>            <code class="n">Albert</code> <code class="n">Einstein</code>     <code class="n">Switzerland</code>  <code class="mi">1921</code>
<code class="o">...</code>
<code class="mi">910</code>                <code class="n">Marie</code> <code class="n">Curie</code>          <code class="n">France</code>  <code class="mi">1903</code>
<code class="mi">919</code>                <code class="n">Marie</code> <code class="n">Curie</code>          <code class="n">France</code>  <code class="mi">1911</code>
<code class="mi">706</code>     <code class="n">Marie</code> <code class="n">Skłodowska</code><code class="o">-</code><code class="n">Curie</code>          <code class="n">Poland</code>  <code class="mi">1903</code>
<code class="mi">709</code>     <code class="n">Marie</code> <code class="n">Skłodowska</code><code class="o">-</code><code class="n">Curie</code>          <code class="n">Poland</code>  <code class="mi">1911</code>
<code class="o">...</code>
<code class="mi">650</code>              <code class="n">Ragnar</code> <code class="n">Granit</code>          <code class="n">Sweden</code>  <code class="mi">1967</code>
<code class="mi">960</code>              <code class="n">Ragnar</code> <code class="n">Granit</code>         <code class="n">Finland</code>  <code class="mi">1809</code>
<code class="o">...</code>
<code class="mi">396</code>              <code class="n">Sidney</code> <code class="n">Altman</code>   <code class="n">United</code> <code class="n">States</code>  <code class="mi">1990</code>
<code class="mi">995</code>              <code class="n">Sidney</code> <code class="n">Altman</code>          <code class="n">Canada</code>  <code class="mi">1989</code>
<code class="o">...</code>
<code class="p">[</code><code class="mi">92</code> <code class="n">rows</code> <code class="n">x</code> <code class="mi">3</code> <code class="n">columns</code><code class="p">]</code></pre>
<p>This output shows that, as expected, some winners have been attributed twice for the same year with different countries. It also reveals a few other anomalies. Although Marie Curie did win a Nobel Prize twice, she’s included here with both French and Polish nationalities.<sup><a data-type="noteref" href="ch09.xhtml#idm45607773684544" id="idm45607773684544-marker">7</a></sup> The fairest thing here is to split the spoils between Poland and France while settling on the single compound surname. We have also found our anomalous year of 1809 at row 960. Sidney Altman is both duplicated and given the wrong year of 1990.</p>
</div></section>
<section data-pdf-bookmark="Removing Duplicates" data-type="sect2"><div class="sect2" id="idm45607773683408">
<h2>Removing Duplicates</h2>
<p>Let’s go about removing the duplicates we just identified and start compiling a little cleaning function.<a data-primary="pandas" data-secondary="cleaning data with" data-tertiary="removing duplicates" data-type="indexterm" id="ix_pndsclnremdup"/><a data-primary="duplicate data" data-secondary="removing duplicates using pandas" data-type="indexterm" id="ix_duprem"/></p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45607773558816">
<h5>Views Versus Copies</h5>
<p>It’s very important when working with pandas to be clear whether you are altering a view or copy of your DataFrame, Series, and so on.<a data-primary="views versus copies in pandas" data-type="indexterm" id="idm45607773557280"/><a data-primary="copies versus views in pandas" data-type="indexterm" id="idm45607773556608"/> The following seems like a natural way to change the <code>country</code> field of a row (Marie Curie’s) but gives a potentially confusing warning:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code class="p">[</code><code class="s1">'</code><code class="s1">country</code><code class="s1">'</code><code class="p">]</code><code class="p">[</code><code class="mi">709</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1">France</code><code class="s1">'</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO16-1" id="co_cleaning_data_with_pandas_CO16-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code class="o">-</code><code class="n">c</code><code class="p">:</code><code class="mi">1</code><code class="p">:</code><code> </code><code class="n">SettingWithCopyWarning</code><code class="p">:</code><code>
</code><code class="n">A</code><code> </code><code class="n">value</code><code> </code><code class="ow">is</code><code> </code><code class="n">trying</code><code> </code><code class="n">to</code><code> </code><code class="n">be</code><code> </code><code class="nb">set</code><code> </code><code class="n">on</code><code> </code><code class="n">a</code><code> </code><code class="n">copy</code><code> </code><code class="n">of</code><code> </code><code class="n">a</code><code> </code><code class="nb">slice</code><code> </code><code class="kn">from</code><code> </code><code class="nn">a</code><code>
</code><code class="n">DataFrame</code><code>
</code><code>
</code><code class="n">See</code><code> </code><code class="n">the</code><code> </code><code class="n">caveats</code><code> </code><code class="ow">in</code><code> </code><code class="n">the</code><code> </code><code class="n">documentation</code><code class="p">:</code><code>
</code><code>    </code><code class="n">http</code><code class="p">:</code><code class="o">/</code><code class="o">/</code><code class="n">pandas</code><code class="o">.</code><code class="n">pydata</code><code class="o">.</code><code class="n">org</code><code class="o">/</code><code class="n">pandas</code><code class="o">-</code><code class="n">docs</code><code class="o">/</code><code class="n">stable</code><code class="o">/</code><code class="o">.</code><code class="o">.</code><code class="o">.</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO16-1" id="callout_cleaning_data_with_pandas_CO16-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Set the country of row 709, Marie Curie, from Poland to France.</p></dd>
</dl>
<p>This is all the more confusing when you find that it has worked as expected:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code class="p">[</code><code class="s1">'country'</code><code class="p">][</code><code class="mi">709</code><code class="p">]</code>
<code class="n">Out</code><code class="p">:</code> <code class="s1">'France'</code></pre>
<p>It turns out that such <em>chained</em> operations<a data-primary="chained operations, discouraged in pandas" data-type="indexterm" id="idm45607773506736"/> are discouraged by the pandas devs because it’s easy to unintentionally alter a copy of the datatype, not the original (view).<sup><a data-type="noteref" href="ch09.xhtml#idm45607773466112" id="idm45607773466112-marker">8</a></sup></p>
<p>These warnings<sup><a data-type="noteref" href="ch09.xhtml#idm45607773464480" id="idm45607773464480-marker">9</a></sup> are there to encourage best practice, which is to use the <code>loc</code> (by label) and <code>iloc</code> (by integer position) methods:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="mi">709</code><code class="p">,</code> <code class="s1">'country'</code><code class="p">]</code> <code class="o">=</code> <code class="s1">'France'</code></pre>
</div></aside>
<div data-type="tip"><h6>Tip</h6>
<p>Changing rows by numeric index is fine if you know your dataset is stable and don’t anticipate running any of your cleaning scripts again. <a data-primary="indices" data-secondary="changing rows by numeric index in pandas" data-type="indexterm" id="idm45607773436112"/>But if, as in the case of our scraped Nobel Prize data, you may want to run the same cleaning script on an updated dataset, it’s much better to use stable indicators (i.e., grab the row with name Marie Curie and year 1911, not index 919).</p>
</div>
<p>A more robust way of changing the country of a specific row is to use stable column values to select the row rather than its index. This means if the index value changes the cleaning script should still work. So to change Marie Curie’s 1911 prize country to France, we can use a Boolean mask with the <code>loc</code> method to select a row and then set its country column to France. Note that we specify the Unicode for the Polish ł:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code class="o">.</code><code class="n">loc</code><code class="p">[(</code><code class="n">df</code><code class="o">.</code><code class="n">name</code> <code class="o">==</code> <code class="s1">'Marie Sk</code><code class="se">\u0142</code><code class="s1">odowska-Curie'</code><code class="p">)</code> <code class="o">&amp;</code>\
      <code class="p">(</code><code class="n">df</code><code class="o">.</code><code class="n">year</code> <code class="o">==</code> <code class="mi">1911</code><code class="p">),</code> <code class="s1">'country'</code><code class="p">]</code> <code class="o">=</code> <code class="s1">'France'</code></pre>
<p>As well as changing Marie Curie’s country, we want to remove or drop some rows from our DataFrame, based on column values. <a data-primary="drop method (pandas DataFrame)" data-type="indexterm" id="idm45607773378352"/>There are two ways we can do this, firstly by using the DataFrame’s <code>drop</code> method, which takes a list of index labels, or by creating a new DataFrame with a Boolean mask that filters the rows we want to drop. If we use <code>drop</code>, we can use the <code>inplace</code> argument to change the existing DataFrame.</p>
<p>In the following code, we drop our duplicate Sidney Altman row by creating a DataFrame with the single row we want (remember, index labels are preserved) and passing that index to the <code>drop</code> method and changing the DataFrame in place:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code class="o">.</code><code class="n">drop</code><code class="p">(</code><code class="n">df</code><code class="p">[(</code><code class="n">df</code><code class="o">.</code><code class="n">name</code> <code class="o">==</code> <code class="s1">'Sidney Altman'</code><code class="p">)</code> <code class="o">&amp;</code>\
 <code class="p">(</code><code class="n">df</code><code class="o">.</code><code class="n">year</code> <code class="o">==</code> <code class="mi">1990</code><code class="p">)]</code><code class="o">.</code><code class="n">index</code><code class="p">,</code>
    <code class="n">inplace</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code></pre>
<p>Another way to remove the row is to use the<a data-primary="Boolean masks" data-secondary="filtering rows in DataFrame with" data-type="indexterm" id="idm45607773346400"/> same Boolean mask with a logical <em>not</em> (~) to create a new DataFrame with all rows except the one(s) we’re selecting:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code> <code class="o">=</code> <code class="n">df</code><code class="p">[</code><code class="o">~</code><code class="p">((</code><code class="n">df</code><code class="o">.</code><code class="n">name</code> <code class="o">==</code> <code class="s1">'Sidney Altman'</code><code class="p">)</code> <code class="o">&amp;</code> <code class="p">(</code><code class="n">df</code><code class="o">.</code><code class="n">year</code> <code class="o">==</code> <code class="mi">1990</code><code class="p">))]</code></pre>
<p>Let’s add this change and all current modifications to a <code>clean_data</code> method:</p>
<pre data-code-language="python" data-type="programlisting"><code class="k">def</code> <code class="nf">clean_data</code><code class="p">(</code><code class="n">df</code><code class="p">):</code>
    <code class="n">df</code> <code class="o">=</code> <code class="n">df</code><code class="o">.</code><code class="n">replace</code><code class="p">(</code><code class="s1">''</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">nan</code><code class="p">)</code>
    <code class="n">df</code> <code class="o">=</code> <code class="n">df</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">born_in</code><code class="o">.</code><code class="n">isnull</code><code class="p">()]</code>
    <code class="n">df</code> <code class="o">=</code> <code class="n">df</code><code class="o">.</code><code class="n">drop</code><code class="p">(</code><code class="s1">'born_in'</code><code class="p">,</code> <code class="n">axis</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code>
    <code class="n">df</code><code class="o">.</code><code class="n">drop</code><code class="p">(</code><code class="n">df</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">year</code> <code class="o">==</code> <code class="mi">1809</code><code class="p">]</code><code class="o">.</code><code class="n">index</code><code class="p">,</code> <code class="n">inplace</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code>
    <code class="n">df</code> <code class="o">=</code> <code class="n">df</code><code class="p">[</code><code class="o">~</code><code class="p">(</code><code class="n">df</code><code class="o">.</code><code class="n">name</code> <code class="o">==</code> <code class="s1">'Marie Curie'</code><code class="p">)]</code>
    <code class="n">df</code><code class="o">.</code><code class="n">loc</code><code class="p">[(</code><code class="n">df</code><code class="o">.</code><code class="n">name</code> <code class="o">==</code> <code class="s1">'Marie Sk</code><code class="se">\u0142</code><code class="s1">odowska-Curie'</code><code class="p">)</code> <code class="o">&amp;</code>\
           <code class="p">(</code><code class="n">df</code><code class="o">.</code><code class="n">year</code> <code class="o">==</code> <code class="mi">1911</code><code class="p">),</code> <code class="s1">'country'</code><code class="p">]</code> <code class="o">=</code> <code class="s1">'France'</code>
    <code class="n">df</code> <code class="o">=</code> <code class="n">df</code><code class="p">[</code><code class="o">~</code><code class="p">((</code><code class="n">df</code><code class="o">.</code><code class="n">name</code> <code class="o">==</code> <code class="s1">'Sidney Altman'</code><code class="p">)</code> <code class="o">&amp;</code>\
     <code class="p">(</code><code class="n">df</code><code class="o">.</code><code class="n">year</code> <code class="o">==</code> <code class="mi">1990</code><code class="p">))]</code>
    <code class="k">return</code> <code class="n">df</code></pre>
<p>We now have a mix of valid duplicates (those few multiple Nobel Prize winners) and those with dual country.  For the purposes of our visualization, we want each prize to count only once, so we have to discard half the dual-country prizes. The easiest way is to use the <code>duplicated</code> method, but because we collected the winners alphabetically by country, this would favor those nationalities with first letters earlier in the alphabet. Short of a fair amount of research and debate, the fairest way seems to pick one out at random and discard it. <a data-primary="drop_duplicates method (pandas)" data-type="indexterm" id="idm45607773247056"/>There are various ways to do this, but the simplest is to randomize the order of the rows before using <code>drop_duplicates</code>, a pandas method that drops all duplicated rows after the first encountered or, with the <code>take_last</code> argument set to <code>True</code>, all before the last.<a data-primary="NumPy" data-secondary="random module" data-type="indexterm" id="idm45607773158896"/><a data-primary="random module (NumPy)" data-type="indexterm" id="idm45607773157888"/></p>
<p>NumPy has a number of very useful methods in its <code>random</code> module, of which <code>permutation</code> is perfect for randomizing the row index.<a data-primary="permutation method (NumPy random module)" data-type="indexterm" id="idm45607773081600"/> This method takes an array (or pandas index) of values and shuffles them. We can then use the DataFrame <code>reindex</code> method to apply the shuffled result. <a data-primary="reindex method (DataFrame)" data-type="indexterm" id="idm45607773080352"/>Note that we drop those rows sharing both name and year, which will preserve the legitimate double winners with different years for their prizes:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="o">.</code><code class="n">reindex</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">permutation</code><code class="p">(</code><code class="n">df</code><code class="o">.</code><code class="n">index</code><code class="p">)</code><code class="p">)</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO17-1" id="co_cleaning_data_with_pandas_CO17-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code class="n">df</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="o">.</code><code class="n">drop_duplicates</code><code class="p">(</code><code class="p">[</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">year</code><code class="s1">'</code><code class="p">]</code><code class="p">)</code><code>        </code><a class="co" href="#callout_cleaning_data_with_pandas_CO17-2" id="co_cleaning_data_with_pandas_CO17-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code>
</code><code class="n">df</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="o">.</code><code class="n">sort_index</code><code class="p">(</code><code class="p">)</code><code>                             </code><a class="co" href="#callout_cleaning_data_with_pandas_CO17-3" id="co_cleaning_data_with_pandas_CO17-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code>
</code><code class="n">df</code><code class="o">.</code><code class="n">count</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">Out</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="n">year</code><code>              </code><code class="mi">865</code><code>
</code><code class="n">dtype</code><code class="p">:</code><code> </code><code class="n">int64</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO17-1" id="callout_cleaning_data_with_pandas_CO17-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Create a shuffled version of <code>df</code>’s index and reindex <code>df</code> with it.</p></dd>
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO17-2" id="callout_cleaning_data_with_pandas_CO17-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Drop all duplicates sharing name and year.</p></dd>
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO17-3" id="callout_cleaning_data_with_pandas_CO17-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Return the index to sorted-by-integer position.</p></dd>
</dl>
<p>If our data wrangling has been successful, we should have only valid duplicates left, those vaunted double-prize winners. Let’s list the remaining duplicates to check:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">In</code><code> </code><code class="p">:</code><code> </code><code class="n">df</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">duplicated</code><code class="p">(</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">)</code><code> </code><code class="o">|</code><code>
</code><code>             </code><code class="n">df</code><code class="o">.</code><code class="n">duplicated</code><code class="p">(</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">keep</code><code class="o">=</code><code class="s1">'</code><code class="s1">last</code><code class="s1">'</code><code class="p">)</code><code class="p">]</code><code>\</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO18-1" id="co_cleaning_data_with_pandas_CO18-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code>             </code><code class="o">.</code><code class="n">sort_values</code><code class="p">(</code><code class="n">by</code><code class="o">=</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">)</code><code>\
</code><code>             </code><code class="p">[</code><code class="p">[</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">country</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">year</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">category</code><code class="s1">'</code><code class="p">]</code><code class="p">]</code><code>
</code><code class="n">Out</code><code class="p">:</code><code>
</code><code>                       </code><code class="n">name</code><code>     </code><code class="n">country</code><code>  </code><code class="n">year</code><code>   </code><code class="n">category</code><code>
</code><code class="mi">548</code><code>        </code><code class="n">Frederick</code><code> </code><code class="n">Sanger</code><code>  </code><code class="n">United</code><code> </code><code class="n">Kingdom</code><code>  </code><code class="mi">1958</code><code>  </code><code class="n">Chemistry</code><code>
</code><code class="mi">580</code><code>        </code><code class="n">Frederick</code><code> </code><code class="n">Sanger</code><code>  </code><code class="n">United</code><code> </code><code class="n">Kingdom</code><code>  </code><code class="mi">1980</code><code>  </code><code class="n">Chemistry</code><code>
</code><code class="mi">292</code><code>            </code><code class="n">John</code><code> </code><code class="n">Bardeen</code><code>   </code><code class="n">United</code><code> </code><code class="n">States</code><code>  </code><code class="mi">1956</code><code>    </code><code class="n">Physics</code><code>
</code><code class="mi">326</code><code>            </code><code class="n">John</code><code> </code><code class="n">Bardeen</code><code>   </code><code class="n">United</code><code> </code><code class="n">States</code><code>  </code><code class="mi">1972</code><code>    </code><code class="n">Physics</code><code>
</code><code class="mi">285</code><code>        </code><code class="n">Linus</code><code> </code><code class="n">C</code><code class="o">.</code><code> </code><code class="n">Pauling</code><code>   </code><code class="n">United</code><code> </code><code class="n">States</code><code>  </code><code class="mi">1954</code><code>  </code><code class="n">Chemistry</code><code>
</code><code class="mi">309</code><code>        </code><code class="n">Linus</code><code> </code><code class="n">C</code><code class="o">.</code><code> </code><code class="n">Pauling</code><code>   </code><code class="n">United</code><code> </code><code class="n">States</code><code>  </code><code class="mi">1962</code><code>      </code><code class="n">Peace</code><code>
</code><code class="mi">706</code><code>  </code><code class="n">Marie</code><code> </code><code class="n">Skłodowska</code><code class="o">-</code><code class="n">Curie</code><code>          </code><code class="n">Poland</code><code>  </code><code class="mi">1903</code><code>    </code><code class="n">Physics</code><code>
</code><code class="mi">709</code><code>  </code><code class="n">Marie</code><code> </code><code class="n">Skłodowska</code><code class="o">-</code><code class="n">Curie</code><code>          </code><code class="n">France</code><code>  </code><code class="mi">1911</code><code>  </code><code class="n">Chemistry</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO18-1" id="callout_cleaning_data_with_pandas_CO18-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>We combine duplicates from the first with the last to get them all. If using an older version of pandas, you may need to use the argument <code>take_last=True</code>.</p></dd>
</dl>
<p>A quick internet check shows that we have the correct four double-prize winners.</p>
<p>Assuming we’ve caught the unwanted duplicates,<sup><a data-type="noteref" href="ch09.xhtml#idm45607772960432" id="idm45607772960432-marker">10</a></sup> let’s move on to other “dirty” aspects of the data.<a data-primary="pandas" data-secondary="cleaning data with" data-startref="ix_pndsclnremdup" data-tertiary="removing duplicates" data-type="indexterm" id="idm45607772959744"/><a data-primary="duplicate data" data-secondary="removing duplicates using pandas" data-startref="ix_duprem" data-type="indexterm" id="idm45607772958256"/></p>
</div></section>
<section data-pdf-bookmark="Dealing with Missing Fields" data-type="sect2"><div class="sect2" id="idm45607772956816">
<h2>Dealing with Missing Fields</h2>
<p>Let’s see where we stand as far as <em>null</em> fields are concerned <a data-primary="pandas" data-secondary="cleaning data with" data-tertiary="missing fields" data-type="indexterm" id="ix_pndsclnmissfld"/><a data-primary="missing fields" data-secondary="dealing with using pandas" data-type="indexterm" id="ix_missfld"/>by counting our <span class="keep-together">DataFrame</span>:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code class="o">.</code><code class="n">count</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">Out</code><code class="p">:</code><code>
</code><code class="n">category</code><code>          </code><code class="mi">864</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO19-1" id="co_cleaning_data_with_pandas_CO19-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code class="n">country</code><code>           </code><code class="mi">865</code><code>
</code><code class="n">date_of_birth</code><code>     </code><code class="mi">857</code><code>
</code><code class="n">date_of_death</code><code>     </code><code class="mi">566</code><code>
</code><code class="n">gender</code><code>            </code><code class="mi">857</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO19-2" id="co_cleaning_data_with_pandas_CO19-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code>
</code><code class="n">link</code><code>              </code><code class="mi">865</code><code>
</code><code class="n">name</code><code>              </code><code class="mi">865</code><code>
</code><code class="n">place_of_birth</code><code>    </code><code class="mi">831</code><code>
</code><code class="n">place_of_death</code><code>    </code><code class="mi">524</code><code>
</code><code class="n">text</code><code>              </code><code class="mi">865</code><code>
</code><code class="n">year</code><code>              </code><code class="mi">865</code><code>
</code><code class="n">dtype</code><code class="p">:</code><code> </code><code class="n">int64</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO19-1" id="callout_cleaning_data_with_pandas_CO19-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>A missing category field</p></dd>
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO19-2" id="callout_cleaning_data_with_pandas_CO19-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Eight missing gender fields</p></dd>
</dl>
<p>We appear to be missing a <code>category</code> field, which suggests a data entry mistake. If you remember, while scraping our Nobel Prize data we checked the category against a valid list (see <a data-type="xref" href="ch06.xhtml#scrapy_process_li">Example 6-3</a>). One of them appears to have failed this check. Let’s find out which one it is by grabbing the row where the category field is null and showing its name and text columns:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">category</code><code class="o">.</code><code class="n">isnull</code><code class="p">()][[</code><code class="s1">'name'</code><code class="p">,</code> <code class="s1">'text'</code><code class="p">]]</code>
<code class="n">Out</code><code class="p">:</code>
              <code class="n">name</code>                            <code class="n">text</code>
<code class="mi">922</code>  <code class="n">Alexis</code> <code class="n">Carrel</code>  <code class="n">Alexis</code> <code class="n">Carrel</code> <code class="p">,</code> <code class="n">Medicine</code><code class="p">,</code> <code class="mi">1912</code></pre>
<p>We saved the original link text for our winners and, as you can see, Alexis Carrel was listed as winning the Nobel prize for <code>Medicine</code>, when it should have been <code>Physiology or Medicine</code>. Let’s correct that now:</p>
<pre data-code-language="python" data-type="programlisting"><code class="o">...</code>
<code class="n">df</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">name</code> <code class="o">==</code> <code class="s1">'Alexis Carrel'</code><code class="p">,</code> <code class="s1">'category'</code><code class="p">]</code> <code class="o">=</code>\
 <code class="s1">'Physiology or Medicine'</code></pre>
<p>We are also missing <code>gender</code> for eight winners. Let’s list them:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">gender</code><code class="o">.</code><code class="n">isnull</code><code class="p">()][</code><code class="s1">'name'</code><code class="p">]</code>
<code class="n">Out</code><code class="p">:</code>
<code class="mi">3</code>                         <code class="n">Institut</code> <code class="n">de</code> <code class="n">Droit</code> <code class="n">International</code>
<code class="mi">156</code>                               <code class="n">Friends</code> <code class="n">Service</code> <code class="n">Council</code>
<code class="mi">267</code>     <code class="n">American</code> <code class="n">Friends</code> <code class="n">Service</code> <code class="n">Committee</code>  <code class="p">(</code><code class="n">The</code> <code class="n">Quakers</code><code class="p">)</code>
<code class="mi">574</code>                                 <code class="n">Amnesty</code> <code class="n">International</code>
<code class="mi">650</code>                                         <code class="n">Ragnar</code> <code class="n">Granit</code>
<code class="mi">947</code>                              <code class="n">Médecins</code> <code class="n">Sans</code> <code class="n">Frontières</code>
<code class="mi">1000</code>     <code class="n">Pugwash</code> <code class="n">Conferences</code> <code class="n">on</code> <code class="n">Science</code> <code class="ow">and</code> <code class="n">World</code> <code class="n">Affairs</code>
<code class="mi">1033</code>                   <code class="n">International</code> <code class="n">Atomic</code> <code class="n">Energy</code> <code class="n">Agency</code>
<code class="n">Name</code><code class="p">:</code> <code class="n">name</code><code class="p">,</code> <code class="n">dtype</code><code class="p">:</code> <code class="nb">object</code></pre>
<p>With the exception of Ragnar Granit, all these are genderless (missing person data) institutions. The focus of our visualization is on individual winners, so we’ll remove these while establishing Ragnar Granit’s gender<sup><a data-type="noteref" href="ch09.xhtml#idm45607772538016" id="idm45607772538016-marker">11</a></sup>:</p>
<pre data-code-language="python" data-type="programlisting"><code class="o">...</code>
<code class="k">def</code> <code class="nf">clean_data</code><code class="p">(</code><code class="n">df</code><code class="p">):</code>
<code class="o">...</code>
    <code class="n">df</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">name</code> <code class="o">==</code> <code class="s1">'Ragnar Granit'</code><code class="p">,</code> <code class="s1">'gender'</code><code class="p">]</code> <code class="o">=</code> <code class="s1">'male'</code>
    <code class="n">df</code> <code class="o">=</code> <code class="n">df</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">gender</code><code class="o">.</code><code class="n">notnull</code><code class="p">()]</code> <code class="c1"># remove genderless entries</code></pre>
<p>Let’s see where those changes leave us by performing another count on our <span class="keep-together">DataFrame</span>:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code class="o">.</code><code class="n">count</code><code class="p">()</code>
<code class="n">Out</code><code class="p">:</code>
<code class="n">category</code>          <code class="mi">858</code>
<code class="n">date_of_birth</code>     <code class="mi">857</code> <code class="c1"># missing field</code>
<code class="o">...</code>
<code class="n">year</code>              <code class="mi">858</code>
<code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>Having removed all the institutions, all entries should have at least a date of birth. Let’s find the missing entry and fix it:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">date_of_birth</code><code class="o">.</code><code class="n">isnull</code><code class="p">()][</code><code class="s1">'name'</code><code class="p">]</code>
<code class="n">Out</code><code class="p">:</code>
<code class="mi">782</code>    <code class="n">Hiroshi</code> <code class="n">Amano</code>
<code class="n">Name</code><code class="p">:</code> <code class="n">name</code><code class="p">,</code> <code class="n">dtype</code><code class="p">:</code> <code class="nb">object</code></pre>
<p>Probably because Hiroshi Amano is a very recent (2014) winner, his date of birth was not available to be scraped. A quick web search establishes Amano’s date of birth, which we add to the DataFrame by hand:</p>
<pre data-code-language="python" data-type="programlisting"><code class="o">...</code>
    <code class="n">df</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">name</code> <code class="o">==</code> <code class="s1">'Hiroshi Amano'</code><code class="p">,</code> <code class="s1">'date_of_birth'</code><code class="p">]</code> <code class="o">=</code>\
    <code class="s1">'11 September 1960'</code></pre>
<p>We now have 858 individual winners. Let’s do a final count to see where we stand:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code class="o">.</code><code class="n">count</code><code class="p">()</code>
<code class="n">Out</code><code class="p">:</code>
<code class="n">category</code>          <code class="mi">858</code>
<code class="n">country</code>           <code class="mi">858</code>
<code class="n">date_of_birth</code>     <code class="mi">858</code>
<code class="n">date_of_death</code>     <code class="mi">566</code>
<code class="n">gender</code>            <code class="mi">858</code>
<code class="n">link</code>              <code class="mi">858</code>
<code class="n">name</code>              <code class="mi">858</code>
<code class="n">place_of_birth</code>    <code class="mi">831</code>
<code class="n">place_of_death</code>    <code class="mi">524</code>
<code class="n">text</code>              <code class="mi">858</code>
<code class="n">year</code>              <code class="mi">858</code>
<code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>The key fields of <code>category</code>, <code>date_of_birth</code>, <code>gender</code>, <code>country</code>, and <code>year</code> are all filled and there’s a healthy amount of data in the remaining stats. All in all, there’s enough clean data to form the basis for a rich visualization.</p>
<p>Now let’s put on the finishing touches by making our temporal fields more usable.<a data-primary="pandas" data-secondary="cleaning data with" data-startref="ix_pndsclnmissfld" data-tertiary="missing fields" data-type="indexterm" id="idm45607772238512"/><a data-primary="missing fields" data-secondary="dealing with using pandas" data-startref="ix_missfld" data-type="indexterm" id="idm45607772236992"/></p>
</div></section>
<section data-pdf-bookmark="Dealing with Times and Dates" data-type="sect2"><div class="sect2" id="idm45607772710736">
<h2>Dealing with Times and Dates</h2>
<p>Currently the <code>date_of_birth</code> and <code>date_of_death</code> fields are represented by strings. <a data-primary="pandas" data-secondary="cleaning data with" data-tertiary="dates and times" data-type="indexterm" id="ix_pndsclndttm"/><a data-primary="dates and times" data-secondary="handling with pandas" data-type="indexterm" id="ix_dttmpnds"/>As we’ve seen, Wikipedia’s informal editing guidelines have led to a number of different time formats.  Our original DataFrame shows an impressive variety of formats in the first 10 entries:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code class="p">[[</code><code class="s1">'name'</code><code class="p">,</code> <code class="s1">'date_of_birth'</code><code class="p">]]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">14</code><code class="p">]:</code>
                       <code class="n">name</code>      <code class="n">date_of_birth</code>
<code class="mi">4</code>         <code class="n">Auguste</code> <code class="n">Beernaert</code>       <code class="mi">26</code> <code class="n">July</code> <code class="mi">1829</code>
                                        <code class="o">...</code>
<code class="mi">8</code>         <code class="n">Corneille</code> <code class="n">Heymans</code>      <code class="mi">28</code> <code class="n">March</code> <code class="mi">1892</code>
<code class="o">...</code>                     <code class="o">...</code>                <code class="o">...</code>
<code class="mi">1047</code>       <code class="n">Brian</code> <code class="n">P</code><code class="o">.</code> <code class="n">Schmidt</code>  <code class="n">February</code> <code class="mi">24</code><code class="p">,</code> <code class="mi">1967</code>
<code class="mi">1048</code>  <code class="n">Carlos</code> <code class="n">Saavedra</code> <code class="n">Lamas</code>   <code class="n">November</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">1878</code>
<code class="mi">1049</code>       <code class="n">Bernardo</code> <code class="n">Houssay</code>         <code class="mi">1887</code><code class="o">-</code><code class="mi">04</code><code class="o">-</code><code class="mi">10</code>
<code class="mi">1050</code>   <code class="n">Luis</code> <code class="n">Federico</code> <code class="n">Leloir</code>           <code class="mi">1906</code><code class="o">-</code><code class="mi">9</code><code class="o">-</code><code class="mi">6</code>
<code class="mi">1051</code>  <code class="n">Adolfo</code> <code class="n">Pérez</code> <code class="n">Esquivel</code>  <code class="n">November</code> <code class="mi">26</code><code class="p">,</code> <code class="mi">1931</code>

<code class="p">[</code><code class="mi">858</code> <code class="n">rows</code> <code class="n">x</code> <code class="mi">2</code> <code class="n">columns</code><code class="p">]</code></pre>
<p>In order to compare the date fields (for example, subtracting the prize <em>year</em> from <em>date of birth</em> to give the winners’ ages), we need to get them into a format that allows such operations. Unsurprisingly, pandas is good with parsing messy dates and times, converting them by default into the NumPy <code>datetime64</code> object, which has a slew of useful methods and operators.<a data-primary="to_datetime method (pandas)" data-type="indexterm" id="idm45607772141088"/></p>
<p>Converting a time column to <code>datetime64</code>, we use pandas’s <code>to_datetime</code> method:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">pd</code><code class="o">.</code><code class="n">to_datetime</code><code class="p">(</code><code class="n">df</code><code class="o">.</code><code class="n">date_of_birth</code><code class="p">,</code><code> </code><code class="n">errors</code><code class="o">=</code><code class="s1">'</code><code class="s1">raise</code><code class="s1">'</code><code class="p">)</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO20-1" id="co_cleaning_data_with_pandas_CO20-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code class="n">Out</code><code class="p">:</code><code>
</code><code class="mi">4</code><code>      </code><code class="mi">1829</code><code class="o">-</code><code class="mi">07</code><code class="o">-</code><code class="mi">26</code><code>
</code><code class="mi">5</code><code>      </code><code class="mi">1862</code><code class="o">-</code><code class="mi">08</code><code class="o">-</code><code class="mi">29</code><code>
</code><code>         </code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="mi">1050</code><code>   </code><code class="mi">1906</code><code class="o">-</code><code class="mi">09</code><code class="o">-</code><code class="mi">06</code><code>
</code><code class="mi">1051</code><code>   </code><code class="mi">1931</code><code class="o">-</code><code class="mi">11</code><code class="o">-</code><code class="mi">26</code><code>
</code><code class="n">Name</code><code class="p">:</code><code> </code><code class="n">date_of_birth</code><code class="p">,</code><code> </code><code class="n">Length</code><code class="p">:</code><code> </code><code class="mi">858</code><code class="p">,</code><code> </code><code class="n">dtype</code><code class="p">:</code><code> </code><code class="n">datetime64</code><code class="p">[</code><code class="n">ns</code><code class="p">]</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO20-1" id="callout_cleaning_data_with_pandas_CO20-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The <code>errors</code> default is <code>ignore</code>, but we want them flagged.</p></dd>
</dl>
<p>By default <code>to_datetime</code> ignores errors, but here we want to know if pandas has been unable to parse a <code>date_of_birth</code>, giving us the opportunity to fix it manually. Thankfully, the conversion passes without error.</p>
<p>Let’s fix our DataFrame’s <code>date_of_birth</code> column before moving on:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">In</code><code class="p">:</code> <code class="n">df</code><code class="o">.</code><code class="n">date_of_birth</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">to_datetime</code><code class="p">(</code><code class="n">df</code><code class="o">.</code><code class="n">date_of_birth</code><code class="p">,</code> <code class="n">errors</code><code class="o">=</code><code class="s1">'coerce'</code><code class="p">)</code></pre>
<p>Running <code>to_datetime</code> on the <code>date_of_birth</code> field raises a <code>ValueError</code> and an unhelpful one at that, giving no <a data-primary="to_datetime method (pandas)" data-secondary="raising ValueError" data-type="indexterm" id="idm45607771952256"/><a data-primary="ValueError" data-type="indexterm" id="idm45607771951312"/>indication of the entry that triggered it:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">143</code><code class="p">]:</code> <code class="n">pd</code><code class="o">.</code><code class="n">to_datetime</code><code class="p">(</code><code class="n">df</code><code class="o">.</code><code class="n">date_of_death</code><code class="p">,</code> <code class="n">errors</code><code class="o">=</code><code class="s1">'raise'</code><code class="p">)</code>
<code class="o">--------------------------------------------------------------</code>
<code class="ne">ValueError</code>                   <code class="n">Traceback</code> <code class="p">(</code><code class="n">most</code> <code class="n">recent</code> <code class="n">call</code> <code class="n">last</code><code class="p">)</code>
<code class="o">...</code>
    <code class="mi">301</code>     <code class="k">if</code> <code class="n">arg</code> <code class="ow">is</code> <code class="kc">None</code><code class="p">:</code>

<code class="ne">ValueError</code><code class="p">:</code> <code class="n">month</code> <code class="n">must</code> <code class="n">be</code> <code class="ow">in</code> <code class="mf">1..12</code></pre>
<p>One naive way to find the bad dates would be to iterate through our rows of data, and catch and display any errors. pandas has a handy <code>iterrows</code> method that provides a row iterator.<a data-primary="try-except block (Python)" data-type="indexterm" id="idm45607771906112"/><a data-primary="iterrows method (pandas)" data-type="indexterm" id="idm45607771905504"/> Combined with a Python <code>try-except</code> block, this successfully finds our problem date fields:</p>
<pre data-code-language="python" data-type="programlisting"><code class="k">for</code><code> </code><code class="n">i</code><code class="p">,</code><code class="n">row</code><code> </code><code class="ow">in</code><code> </code><code class="n">df</code><code class="o">.</code><code class="n">iterrows</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="k">try</code><code class="p">:</code><code>
</code><code>        </code><code class="n">pd</code><code class="o">.</code><code class="n">to_datetime</code><code class="p">(</code><code class="n">row</code><code class="o">.</code><code class="n">date_of_death</code><code class="p">,</code><code> </code><code class="n">errors</code><code class="o">=</code><code class="s1">'</code><code class="s1">raise</code><code class="s1">'</code><code class="p">)</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO21-1" id="co_cleaning_data_with_pandas_CO21-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code>    </code><code class="k">except</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s2">"</code><code class="si">{</code><code class="n">row</code><code class="o">.</code><code class="n">date_of_death</code><code class="o">.</code><code class="n">ljust</code><code class="p">(</code><code class="mi">30</code><code class="p">)</code><code class="si">}</code><code class="s2">(</code><code class="si">{</code><code class="n">row</code><code class="p">[</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">]</code><code class="si">}</code><code class="s2">, </code><code class="si">{</code><code class="n">i</code><code class="si">}</code><code class="s2">)</code><code class="s2">"</code><code class="p">)</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO21-2" id="co_cleaning_data_with_pandas_CO21-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO21-1" id="callout_cleaning_data_with_pandas_CO21-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Run <code>to_datetime</code> on the individual row and catch any errors.</p></dd>
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO21-2" id="callout_cleaning_data_with_pandas_CO21-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>We left-justify the date of death in a text column of width 30 to make the output easier to read. pandas rows have a masking <code>Name</code> property, so we use string-key access with <code>['name']</code>.</p></dd>
</dl>
<p>This lists the offending rows:</p>
<pre data-type="programlisting">1968-23-07              (Henry Hallett Dale, 150)
May 30, 2011 (aged 89)  (Rosalyn Yalow, 349)
living                  (David Trimble, 581)
Diederik Korteweg       (Johannes Diderik van der Waals, 746)
living                  (Shirin Ebadi, 809)
living                  (Rigoberta Menchú, 833)
1 February 1976, age 74 (Werner Karl Heisenberg, 858)</pre>
<p>which is a good demonstration of the kind of data errors you get with collaborative editing.</p>
<p>Although the last method works, whenever you find yourself iterating through rows of a pandas DataFrame, you should pause for a second and try to find a better way, one that exploits the multirow array handling that is a fundamental aspect of pandas’s efficiency.</p>
<p>A better way to find the bad dates exploits the fact that pandas’s <code>to_datetime</code> method has a <code>coerce</code> argument, which, if <code>True</code>, converts any date exceptions to <code>NaT</code> (not a time), the temporal equivalent of <code>NaN</code>. <a data-primary="to_datetime method (pandas)" data-secondary="coerce argument" data-type="indexterm" id="idm45607771774032"/><a data-primary="NaT (not a time)" data-type="indexterm" id="idm45607771773088"/>We can then create a Boolean mask out of the resulting DataFrame based on the <code>NaT</code> date rows, producing <a data-type="xref" href="#clean_dodgy_dates">Figure 9-1</a>:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">with_death_dates</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">date_of_death</code><code class="o">.</code><code class="n">notnull</code><code class="p">(</code><code class="p">)</code><code class="p">]</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO22-1" id="co_cleaning_data_with_pandas_CO22-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code class="n">bad_dates</code><code> </code><code class="o">=</code><code> </code><code class="n">pd</code><code class="o">.</code><code class="n">isnull</code><code class="p">(</code><code class="n">pd</code><code class="o">.</code><code class="n">to_datetime</code><code class="p">(</code><code>\
</code><code>            </code><code class="n">with_death_dates</code><code class="o">.</code><code class="n">date_of_death</code><code class="p">,</code><code> </code><code class="n">errors</code><code class="o">=</code><code class="s1">'</code><code class="s1">coerce</code><code class="s1">'</code><code class="p">)</code><code class="p">)</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO22-2" id="co_cleaning_data_with_pandas_CO22-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code>
</code><code class="n">with_death_dates</code><code class="p">[</code><code class="n">bad_dates</code><code class="p">]</code><code class="p">[</code><code class="p">[</code><code class="s1">'</code><code class="s1">category</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">date_of_death</code><code class="s1">'</code><code class="p">,</code><code>\
</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">]</code><code class="p">]</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO22-1" id="callout_cleaning_data_with_pandas_CO22-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Gets all rows with non-null date fields.</p></dd>
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO22-2" id="callout_cleaning_data_with_pandas_CO22-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Creates a Boolean mask for all bad dates in <code>with_death_dates</code> by checking against null (<code>NaT</code>) after coercing failed conversions to <code>NaT</code>. For older pandas versions, you may need to use <code>coerce=True</code>.</p></dd>
</dl>
<figure><div class="figure" id="clean_dodgy_dates">
<img alt="dpj2 0901" height="249" src="assets/dpj2_0901.png" width="613"/>
<h6><span class="label">Figure 9-1. </span>The unparseable date fields</h6>
</div></figure>
<p>Depending on how fastidious you want to be, these can be corrected by hand or coerced to NumPy’s time equivalent of <code>NaN</code>, <code>NaT</code>. We’ve got more than 500 valid dates of death, which is enough to get some interesting time stats, so we’ll run <code>to_datetime</code> again and force errors to null:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code class="o">.</code><code class="n">date_of_death</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">to_datetime</code><code class="p">(</code><code class="n">df</code><code class="o">.</code><code class="n">date_of_death</code><code class="p">,</code>\
<code class="n">errors</code><code class="o">=</code><code class="s1">'coerce'</code><code class="p">)</code></pre>
<p>Now that we have our time fields in a usable format, let’s add a field for the age of the winner on receiving his/her Nobel Prize. In order to get the year value of our new dates, we need to tell pandas that it’s dealing with a date column, using the <code>DatetimeIndex</code> method. <a data-primary="DatetimeIndex" data-type="indexterm" id="idm45607771666752"/>Note that this gives a crude estimation of award age and may be off by a year. For the purposes of the next chapter’s dataviz exploration, this is more than adequate:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code><code class="p">[</code><code class="s1">'</code><code class="s1">award_age</code><code class="s1">'</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="o">.</code><code class="n">year</code><code> </code><code class="o">-</code><code> </code><code class="n">pd</code><code class="o">.</code><code class="n">DatetimeIndex</code><code class="p">(</code><code class="n">df</code><code class="o">.</code><code class="n">date_of_birth</code><code class="p">)</code><code>\
</code><code class="o">.</code><code class="n">year</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO23-1" id="co_cleaning_data_with_pandas_CO23-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO23-1" id="callout_cleaning_data_with_pandas_CO23-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Convert the column to a <code>DatetimeIndex</code>, an <code>ndarray</code> of <code>datetime64</code> data, and use the <code>year</code> property.</p></dd>
</dl>
<p>Let’s use our new <code>award_age</code> field to see the youngest recipients of the Nobel Prize:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># use +sort+ for older pandas</code><code>
</code><code class="n">df</code><code class="o">.</code><code class="n">sort_values</code><code class="p">(</code><code class="s1">'</code><code class="s1">award_age</code><code class="s1">'</code><code class="p">)</code><code class="o">.</code><code class="n">iloc</code><code class="p">[</code><code class="p">:</code><code class="mi">10</code><code class="p">]</code><code>\
</code><code>        </code><code class="p">[</code><code class="p">[</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">award_age</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">category</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">year</code><code class="s1">'</code><code class="p">]</code><code class="p">]</code><code>
</code><code class="n">Out</code><code class="p">:</code><code>
</code><code>                      </code><code class="n">name</code><code>  </code><code class="n">award_age</code><code>         </code><code class="n">category</code><code>  </code><code class="n">year</code><code>
</code><code class="mi">725</code><code>        </code><code class="n">Malala</code><code> </code><code class="n">Yousafzai</code><code>       </code><code class="mf">17.0</code><code>            </code><code class="n">Peace</code><code>  </code><code class="mi">2014</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO24-1" id="co_cleaning_data_with_pandas_CO24-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code class="mi">525</code><code>  </code><code class="n">William</code><code> </code><code class="n">Lawrence</code><code> </code><code class="n">Bragg</code><code>       </code><code class="mf">25.0</code><code>          </code><code class="n">Physics</code><code>  </code><code class="mi">1915</code><code>
</code><code class="mi">626</code><code>    </code><code class="n">Georges</code><code> </code><code class="n">J</code><code class="o">.</code><code> </code><code class="n">F</code><code class="o">.</code><code> </code><code class="n">Köhler</code><code>       </code><code class="mf">30.0</code><code>  </code><code class="n">Phys</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code class="n">Medicine</code><code>  </code><code class="mi">1976</code><code>
</code><code class="mi">294</code><code>           </code><code class="n">Tsung</code><code class="o">-</code><code class="n">Dao</code><code> </code><code class="n">Lee</code><code>       </code><code class="mf">31.0</code><code>          </code><code class="n">Physics</code><code>  </code><code class="mi">1957</code><code>
</code><code class="mi">858</code><code>  </code><code class="n">Werner</code><code> </code><code class="n">Karl</code><code> </code><code class="n">Heisenberg</code><code>       </code><code class="mf">31.0</code><code>          </code><code class="n">Physics</code><code>  </code><code class="mi">1932</code><code>
</code><code class="mi">247</code><code>           </code><code class="n">Carl</code><code> </code><code class="n">Anderson</code><code>       </code><code class="mf">31.0</code><code>          </code><code class="n">Physics</code><code>  </code><code class="mi">1936</code><code>
</code><code class="mi">146</code><code>              </code><code class="n">Paul</code><code> </code><code class="n">Dirac</code><code>       </code><code class="mf">31.0</code><code>          </code><code class="n">Physics</code><code>  </code><code class="mi">1933</code><code>
</code><code class="mi">877</code><code>        </code><code class="n">Rudolf</code><code> </code><code class="n">Mössbauer</code><code>       </code><code class="mf">32.0</code><code>          </code><code class="n">Physics</code><code>  </code><code class="mi">1961</code><code>
</code><code class="mi">226</code><code>         </code><code class="n">Tawakkol</code><code> </code><code class="n">Karman</code><code>       </code><code class="mf">32.0</code><code>            </code><code class="n">Peace</code><code>  </code><code class="mi">2011</code><code>
</code><code class="mi">804</code><code>        </code><code class="n">Mairéad</code><code> </code><code class="n">Corrigan</code><code>       </code><code class="mf">32.0</code><code>            </code><code class="n">Peace</code><code>  </code><code class="mi">1976</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO24-1" id="callout_cleaning_data_with_pandas_CO24-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>For activism for female education, I’d recommend reading more about <a href="https://oreil.ly/26szS">Malala’s inspirational story</a>.</p></dd>
</dl>
<p>Now that we have our date fields in a manipulable form, let’s have a look at the full <code>clean_data</code> function, which summarizes this chapter’s cleaning efforts.<a data-primary="pandas" data-secondary="cleaning data with" data-startref="ix_pndsclndttm" data-tertiary="dates and times" data-type="indexterm" id="idm45607771408432"/><a data-primary="dates and times" data-secondary="handling with pandas" data-startref="ix_dttmpnds" data-type="indexterm" id="idm45607771431776"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="The Full clean_data Function" data-type="sect1"><div class="sect1" id="idm45607775071024">
<h1>The Full clean_data Function</h1>
<p>For manually edited data like scraped Wikipedia datasets, it’s unlikely that you’ll catch all the errors on a first pass. <a data-primary="clean_data function, full version" data-type="indexterm" id="idm45607771429824"/><a data-primary="pandas" data-secondary="cleaning data with" data-tertiary="clean_data function" data-type="indexterm" id="idm45607771429152"/>So expect to pick up a few during the data exploration phase. Nevertheless, our Nobel Prize dataset is looking very usable. We’ll declare it clean enough and the job of this chapter done. <a data-type="xref" href="#clean_data">Example 9-4</a> shows the steps we used to achieve this cleaning feat.</p>
<div data-type="example" id="clean_data">
<h5><span class="label">Example 9-4. </span>The full Nobel Prize dataset cleaning function</h5>
<pre data-code-language="python" data-type="programlisting"><code class="k">def</code><code> </code><code class="nf">clean_data</code><code class="p">(</code><code class="n">df</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">df</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="o">.</code><code class="n">replace</code><code class="p">(</code><code class="s1">'</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">np</code><code class="o">.</code><code class="n">nan</code><code class="p">)</code><code>
</code><code>    </code><code class="n">df_born_in</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">born_in</code><code class="o">.</code><code class="n">notnull</code><code class="p">(</code><code class="p">)</code><code class="p">]</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO25-1" id="co_cleaning_data_with_pandas_CO25-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code>    </code><code class="n">df</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">born_in</code><code class="o">.</code><code class="n">isnull</code><code class="p">(</code><code class="p">)</code><code class="p">]</code><code>
</code><code>    </code><code class="n">df</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="o">.</code><code class="n">drop</code><code class="p">(</code><code class="s1">'</code><code class="s1">born_in</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">axis</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code><code>
</code><code>    </code><code class="n">df</code><code class="o">.</code><code class="n">drop</code><code class="p">(</code><code class="n">df</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">year</code><code> </code><code class="o">==</code><code> </code><code class="mi">1809</code><code class="p">]</code><code class="o">.</code><code class="n">index</code><code class="p">,</code><code> </code><code class="n">inplace</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code><code>
</code><code>    </code><code class="n">df</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="p">[</code><code class="o">~</code><code class="p">(</code><code class="n">df</code><code class="o">.</code><code class="n">name</code><code> </code><code class="o">==</code><code> </code><code class="s1">'</code><code class="s1">Marie Curie</code><code class="s1">'</code><code class="p">)</code><code class="p">]</code><code>
</code><code>    </code><code class="n">df</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="p">(</code><code class="n">df</code><code class="o">.</code><code class="n">name</code><code> </code><code class="o">==</code><code> </code><code class="s1">'</code><code class="s1">Marie Sk</code><code class="se">\u0142</code><code class="s1">odowska-Curie</code><code class="s1">'</code><code class="p">)</code><code> </code><code class="o">&amp;</code><code>\
</code><code>           </code><code class="p">(</code><code class="n">df</code><code class="o">.</code><code class="n">year</code><code> </code><code class="o">==</code><code> </code><code class="mi">1911</code><code class="p">)</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">country</code><code class="s1">'</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1">France</code><code class="s1">'</code><code>
</code><code>    </code><code class="n">df</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="p">[</code><code class="o">~</code><code class="p">(</code><code class="p">(</code><code class="n">df</code><code class="o">.</code><code class="n">name</code><code> </code><code class="o">==</code><code> </code><code class="s1">'</code><code class="s1">Sidney Altman</code><code class="s1">'</code><code class="p">)</code><code> </code><code class="o">&amp;</code><code> </code><code class="p">(</code><code class="n">df</code><code class="o">.</code><code class="n">year</code><code> </code><code class="o">==</code><code> </code><code class="mi">1990</code><code class="p">)</code><code class="p">)</code><code class="p">]</code><code>
</code><code>    </code><code class="n">df</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="o">.</code><code class="n">reindex</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">permutation</code><code class="p">(</code><code class="n">df</code><code class="o">.</code><code class="n">index</code><code class="p">)</code><code class="p">)</code><code>
</code><code>    </code><code class="n">df</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="o">.</code><code class="n">drop_duplicates</code><code class="p">(</code><code class="p">[</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">year</code><code class="s1">'</code><code class="p">]</code><code class="p">)</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO25-2" id="co_cleaning_data_with_pandas_CO25-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code>
</code><code>    </code><code class="n">df</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="o">.</code><code class="n">sort_index</code><code class="p">(</code><code class="p">)</code><code>
</code><code>    </code><code class="n">df</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">name</code><code> </code><code class="o">==</code><code> </code><code class="s1">'</code><code class="s1">Alexis Carrel</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">category</code><code class="s1">'</code><code class="p">]</code><code> </code><code class="o">=</code><code>\
</code><code>        </code><code class="s1">'</code><code class="s1">Physiology or Medicine</code><code class="s1">'</code><code>
</code><code>    </code><code class="n">df</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">name</code><code> </code><code class="o">==</code><code> </code><code class="s1">'</code><code class="s1">Ragnar Granit</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">gender</code><code class="s1">'</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1">male</code><code class="s1">'</code><code>
</code><code>    </code><code class="n">df</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">gender</code><code class="o">.</code><code class="n">notnull</code><code class="p">(</code><code class="p">)</code><code class="p">]</code><code> </code><code class="c1"># remove institutional prizes</code><code>
</code><code>    </code><code class="n">df</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="n">df</code><code class="o">.</code><code class="n">name</code><code> </code><code class="o">==</code><code> </code><code class="s1">'</code><code class="s1">Hiroshi Amano</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">date_of_birth</code><code class="s1">'</code><code class="p">]</code><code> </code><code class="o">=</code><code>\
</code><code>    </code><code class="s1">'</code><code class="s1">11 September 1960</code><code class="s1">'</code><code>
</code><code>    </code><code class="n">df</code><code class="o">.</code><code class="n">date_of_birth</code><code> </code><code class="o">=</code><code> </code><code class="n">pd</code><code class="o">.</code><code class="n">to_datetime</code><code class="p">(</code><code class="n">df</code><code class="o">.</code><code class="n">date_of_birth</code><code class="p">)</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO25-3" id="co_cleaning_data_with_pandas_CO25-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code>
</code><code>    </code><code class="n">df</code><code class="o">.</code><code class="n">date_of_death</code><code> </code><code class="o">=</code><code> </code><code class="n">pd</code><code class="o">.</code><code class="n">to_datetime</code><code class="p">(</code><code class="n">df</code><code class="o">.</code><code class="n">date_of_death</code><code class="p">,</code><code>\
</code><code>    </code><code class="n">errors</code><code class="o">=</code><code class="s1">'</code><code class="s1">coerce</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><code class="n">df</code><code class="p">[</code><code class="s1">'</code><code class="s1">award_age</code><code class="s1">'</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="n">df</code><code class="o">.</code><code class="n">year</code><code> </code><code class="o">-</code><code> </code><code class="n">pd</code><code class="o">.</code><code class="n">DatetimeIndex</code><code class="p">(</code><code class="n">df</code><code class="o">.</code><code class="n">date_of_birth</code><code class="p">)</code><code>\
</code><code>    </code><code class="o">.</code><code class="n">year</code><code>
</code><code>    </code><code class="k">return</code><code> </code><code class="n">df</code><code class="p">,</code><code> </code><code class="n">df_born_in</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO25-4" id="co_cleaning_data_with_pandas_CO25-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO25-1" id="callout_cleaning_data_with_pandas_CO25-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Makes a DataFrame containing the rows with <code>born_in</code> fields.</p></dd>
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO25-2" id="callout_cleaning_data_with_pandas_CO25-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Removes duplicates from the DataFrame after randomizing the row order.</p></dd>
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO25-3" id="callout_cleaning_data_with_pandas_CO25-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Converts the date columns to the practical <code>datetime64</code> datatype.</p></dd>
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO25-4" id="callout_cleaning_data_with_pandas_CO25-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>We return a DataFrame with the deleted <code>born_in</code> field; this data will provide an interesting visualization in the next chapter.</p></dd>
</dl></div>
</div></section>
<section data-pdf-bookmark="Adding the born_in column" data-type="sect1"><div class="sect1" id="idm45607771304384">
<h1>Adding the born_in column</h1>
<p>While cleaning the winners DataFrame we removed the <code>born_in</code> column (see <a data-type="xref" href="#removing_rows">“Removing Rows”</a>). <a data-primary="columns" data-secondary="adding born_in column to Nobel winners dataset in pandas" data-type="indexterm" id="ix_coladd"/><a data-primary="pandas" data-secondary="cleaning data with" data-tertiary="adding born_in column to Nobel winners dataset" data-type="indexterm" id="ix_pndsclnaddcol"/>As we’ll see in the next chapter, this column has some interesting data that can be correlated with the winners’ country (of prize-winning origin) to tell an interesting story or two. The <code>clean_data</code> function returns the <code>born_in</code> data as a DataFrame. Let’s see how we can add this data to our freshly cleaned DataFrame. First, we’ll read in our original, dirty dataset and apply our data cleaning function:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">read_json</code><code class="p">(</code><code class="nb">open</code><code class="p">(</code><code class="s1">'data/nobel_winners_dirty.json'</code><code class="p">))</code>
<code class="n">df_clean</code><code class="p">,</code> <code class="n">df_born_in</code> <code class="o">=</code> <code class="n">clean_data</code><code class="p">(</code><code class="n">df</code><code class="p">)</code></pre>
<p>Now we’ll clean up the name field of the <code>df_born_in</code> DataFrame by removing the asterisks, stripping any whitespace and then removing any duplicate rows by name. Finally, we’ll set the index of the DataFrame to its name column:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># clean up name column: '* Aaron Klug' -&gt; 'Aaron Klug'</code><code>
</code><code class="n">df_born_in</code><code class="o">.</code><code class="n">name</code><code> </code><code class="o">=</code><code> </code><code class="n">dfbi</code><code class="o">.</code><code class="n">name</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">replace</code><code class="p">(</code><code class="s1">'</code><code class="s1">*</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">regex</code><code class="o">=</code><code class="kc">False</code><code class="p">)</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO26-1" id="co_cleaning_data_with_pandas_CO26-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code class="n">df_born_in</code><code class="o">.</code><code class="n">name</code><code> </code><code class="o">=</code><code> </code><code class="n">dfbi</code><code class="o">.</code><code class="n">name</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">strip</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">df_born_in</code><code class="o">.</code><code class="n">drop_duplicates</code><code class="p">(</code><code class="n">subset</code><code class="o">=</code><code class="p">[</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">]</code><code class="p">,</code><code> </code><code class="n">inplace</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code><code>
</code><code class="n">df_born_in</code><code class="o">.</code><code class="n">set_index</code><code class="p">(</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">inplace</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code></pre>
<p>We now have a <code>df_born_in</code> DataFrame that we can query by name:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">In</code><code class="p">:</code> <code class="n">df_born_in</code><code class="p">[</code><code class="s1">'Eugene Wigner'</code><code class="p">]</code>
<code class="n">Out</code><code class="p">:</code>
<code class="n">born_in</code>                                                     <code class="n">Hungary</code>
<code class="n">category</code>                                                    <code class="n">Physics</code>
<code class="o">...</code>
<code class="n">year</code>                                                           <code class="mi">1963</code>
<code class="n">Name</code><code class="p">:</code> <code class="n">Eugene</code> <code class="n">Wigner</code><code class="p">,</code> <code class="n">dtype</code><code class="p">:</code> <code class="nb">object</code></pre>
<p>Now we’ll write a little Python function to return the <code>born_in</code> field by name of our <code>df_born_in</code> DataFrame if it exists, otherwise returning a NumPy <code>nan</code>:</p>
<pre data-code-language="python" data-type="programlisting"><code class="k">def</code> <code class="nf">get_born_in</code><code class="p">(</code><code class="n">name</code><code class="p">):</code>
    <code class="k">try</code><code class="p">:</code>
        <code class="n">born_in</code> <code class="o">=</code> <code class="n">df_born_in</code><code class="o">.</code><code class="n">loc</code><code class="p">[</code><code class="n">name</code><code class="p">][</code><code class="s1">'born_in'</code><code class="p">]</code>
        <code class="c1"># We'll print out these rows as a sanity-check</code>
        <code class="nb">print</code><code class="p">(</code><code class="s1">'name: </code><code class="si">%s</code><code class="s1">, born in: </code><code class="si">%s</code><code class="s1">'</code><code class="o">%</code><code class="p">(</code><code class="n">name</code><code class="p">,</code> <code class="n">born_in</code><code class="p">))</code>
    <code class="k">except</code><code class="p">:</code>
        <code class="n">born_in</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">nan</code>
    <code class="k">return</code> <code class="n">born_in</code></pre>
<p>We can now create a <code>born_in</code> column to our main DataFrame by applying this <code>get_born_in</code> function to each row, using the name field:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">In</code><code class="p">:</code> <code class="n">df_wbi</code> <code class="o">=</code> <code class="n">df_clean</code><code class="o">.</code><code class="n">copy</code><code class="p">()</code>
<code class="n">In</code><code class="p">:</code> <code class="n">df_wbi</code><code class="p">[</code><code class="s1">'born_in'</code><code class="p">]</code> <code class="o">=</code> <code class="n">df_wbi</code><code class="p">[</code><code class="s1">'name'</code><code class="p">]</code><code class="o">.</code><code class="n">apply</code><code class="p">(</code><code class="n">get_born_in</code><code class="p">)</code>
<code class="n">Out</code><code class="p">:</code>
<code class="o">...</code>
<code class="n">name</code><code class="p">:</code> <code class="n">Christian</code> <code class="n">de</code> <code class="n">Duve</code><code class="p">,</code> <code class="n">born</code> <code class="ow">in</code><code class="p">:</code> <code class="n">United</code> <code class="n">Kingdom</code>
<code class="n">name</code><code class="p">:</code> <code class="n">Ilya</code> <code class="n">Prigogine</code><code class="p">,</code> <code class="n">born</code> <code class="ow">in</code><code class="p">:</code> <code class="n">Russia</code>
<code class="o">...</code>
<code class="n">name</code><code class="p">:</code> <code class="n">Niels</code> <code class="n">Kaj</code> <code class="n">Jerne</code><code class="p">,</code> <code class="n">born</code> <code class="ow">in</code><code class="p">:</code> <code class="n">United</code> <code class="n">Kingdom</code>
<code class="n">name</code><code class="p">:</code> <code class="n">Albert</code> <code class="n">Schweitzer</code><code class="p">,</code> <code class="n">born</code> <code class="ow">in</code><code class="p">:</code> <code class="n">Germany</code>
<code class="o">...</code></pre>
<p>Finally, let’s make sure we’ve successfully added a <code>born_in</code> column to our DataFrame:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">In</code><code class="p">:</code> <code class="n">df_wbi</code><code class="o">.</code><code class="n">info</code><code class="p">()</code>
<code class="n">Out</code><code class="p">:</code>
<code class="o">&lt;</code><code class="k">class</code> <code class="err">'</code><code class="nc">pandas</code><code class="o">.</code><code class="n">core</code><code class="o">.</code><code class="n">frame</code><code class="o">.</code><code class="n">DataFrame</code><code class="s1">'&gt;</code>
<code class="n">Int64Index</code><code class="p">:</code> <code class="mi">858</code> <code class="n">entries</code><code class="p">,</code> <code class="mi">4</code> <code class="n">to</code> <code class="mi">1051</code>
<code class="n">Data</code> <code class="n">columns</code> <code class="p">(</code><code class="n">total</code> <code class="mi">13</code> <code class="n">columns</code><code class="p">):</code>
 <code class="c1">#   Column          Non-Null Count  Dtype</code>
<code class="o">---</code>  <code class="o">------</code>          <code class="o">--------------</code>  <code class="o">-----</code>
 <code class="mi">0</code>   <code class="n">category</code>        <code class="mi">858</code> <code class="n">non</code><code class="o">-</code><code class="n">null</code>    <code class="nb">object</code>
 <code class="o">...</code>
 <code class="mi">12</code>  <code class="n">born_in</code>         <code class="mi">102</code> <code class="n">non</code><code class="o">-</code><code class="n">null</code>    <code class="nb">object</code>
<code class="n">dtypes</code><code class="p">:</code> <code class="n">datetime64</code><code class="p">[</code><code class="n">ns</code><code class="p">](</code><code class="mi">2</code><code class="p">),</code> <code class="n">int64</code><code class="p">(</code><code class="mi">2</code><code class="p">),</code> <code class="nb">object</code><code class="p">(</code><code class="mi">9</code><code class="p">)</code>
<code class="n">memory</code> <code class="n">usage</code><code class="p">:</code> <code class="mf">93.8</code><code class="o">+</code> <code class="n">KB</code></pre>
<p>Note that if there were no duplicate names among our Nobel winners, we could create the <code>born_in</code> column by simply setting the index of <code>df</code> and <code>df_born_in</code> to <em>name</em> and creating the column directly:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># this won't work with duplicate names in our index</code>
<code class="n">In</code><code class="p">:</code> <code class="n">df_wbi</code><code class="p">[</code><code class="s1">'born_in'</code><code class="p">]</code> <code class="o">=</code> <code class="n">df_born_in</code><code class="o">.</code><code class="n">born_in</code>
<code class="n">Out</code><code class="p">:</code>
<code class="o">...</code>
<code class="ne">ValueError</code><code class="p">:</code> <code class="n">cannot</code> <code class="n">reindex</code> <code class="kn">from</code> <code class="nn">a</code> <code class="n">duplicate</code> <code class="n">axis</code></pre>
<p>The use of <code>apply</code> can be inefficient for large datasets, but it provides a very flexible way of creating new columns based on the existing ones.</p>
<section data-pdf-bookmark="Merging DataFrames" data-type="sect2"><div class="sect2" id="saving_datasets">
<h2>Merging DataFrames</h2>
<p>At this point, we can also create a merged database of our clean <code>winners</code> data and the image and biography dataset we scraped in <a data-type="xref" href="ch06.xhtml#scraping_bio">“Scraping Text and Images with a Pipeline”</a>. This will provide a good opportunity to demonstrate pandas’s ability to merge DataFrames. <a data-primary="DataFrames" data-secondary="merging" data-type="indexterm" id="idm45607770391232"/><a data-primary="merging DataFrames" data-type="indexterm" id="idm45607770390288"/>The following code shows how to merge <code>df_clean</code> and the bio dataset:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Read the Scrapy bio-data into a DataFrame</code><code>
</code><code class="n">df_winners_bios</code><code> </code><code class="o">=</code><code> </code><code class="n">pd</code><code class="o">.</code><code class="n">read_json</code><code class="p">(</code><code>\
</code><code class="nb">open</code><code class="p">(</code><code class="s1">'</code><code class="s1">data/scrapy_nwinners_minibio.json</code><code class="s1">'</code><code class="p">)</code><code class="p">)</code><code>
</code><code>
</code><code class="n">df_clean_bios</code><code> </code><code class="o">=</code><code> </code><code class="n">pd</code><code class="o">.</code><code class="n">merge</code><code class="p">(</code><code class="n">df_wbi</code><code class="p">,</code><code> </code><code class="n">df_winners_bios</code><code class="p">,</code><code>\
</code><code class="n">how</code><code class="o">=</code><code class="s1">'</code><code class="s1">outer</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">on</code><code class="o">=</code><code class="s1">'</code><code class="s1">link</code><code class="s1">'</code><code class="p">)</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO26-1" id="co_cleaning_data_with_pandas_CO26-2"><img alt="1" height="12" src="assets/1.png" width="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO26-1" id="callout_cleaning_data_with_pandas_CO26-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p><a href="https://oreil.ly/T3ujJ">pandas’s <code>merge</code></a> takes two DataFrames and merges them based on shared column name(s) (<code>link</code>, in this case). The <code>how</code> argument specifies how to determine which keys are to be included in the resulting table and works in the same way as SQL joins.<a data-primary="joins, FULL_OUTER_JOIN" data-type="indexterm" id="idm45607770338752"/> In this case, <code>outer</code> specifies a <code>FULL_OUTER_JOIN</code>.</p></dd>
</dl>
<p>Merging the two DataFrames results in redundancies in our merged dataset, with more than the 858 winning rows:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df_clean_bios</code><code class="o">.</code><code class="n">count</code><code class="p">()</code>
<code class="n">Out</code><code class="p">:</code>
<code class="n">award_age</code>         <code class="mi">1023</code>
<code class="n">category</code>          <code class="mi">1023</code>
<code class="o">...</code>
<code class="n">bio_image</code>          <code class="mi">978</code>
<code class="n">mini_bio</code>          <code class="mi">1086</code></pre>
<p>We can easily remove these by using <code>drop_duplicates</code> to remove<a data-primary="drop_duplicates method (pandas)" data-type="indexterm" id="idm45607770283472"/> any rows that share a <code>link</code> and <code>year</code> field after removing any rows without a <code>name</code> field:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df_clean_bios</code> <code class="o">=</code> <code class="n">df_clean_bios</code><code class="p">[</code><code class="o">~</code><code class="n">df_clean_bios</code><code class="o">.</code><code class="n">name</code><code class="o">.</code><code class="n">isnull</code><code class="p">()]</code>\
<code class="o">.</code><code class="n">drop_duplicates</code><code class="p">(</code><code class="n">subset</code><code class="o">=</code><code class="p">[</code><code class="s1">'link'</code><code class="p">,</code> <code class="s1">'year'</code><code class="p">])</code></pre>
<p>A quick count shows that we now have the right number of winners with images for 770 and a <code>mini_bio</code> for all but one:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df_clean_bios</code><code class="o">.</code><code class="n">count</code><code class="p">()</code>
<code class="n">award_age</code>         <code class="mi">858</code>
<code class="n">category</code>          <code class="mi">858</code>
<code class="o">...</code>
<code class="n">born_in</code>           <code class="mi">102</code>
<code class="n">bio_image</code>         <code class="mi">770</code>
<code class="n">mini_bio</code>          <code class="mi">857</code>
<code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>While we’re cleaning our dataset, let’s see which winner is missing a <code>mini_bio</code> field:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df_clean_bios</code><code class="p">[</code><code class="n">df_clean_bios</code><code class="o">.</code><code class="n">mini_bio</code><code class="o">.</code><code class="n">isnull</code><code class="p">()]</code>
<code class="n">Out</code><code class="p">:</code>
<code class="o">...</code>
                                            <code class="n">link</code>        <code class="n">name</code>  \
<code class="mi">229</code>  <code class="n">http</code><code class="p">:</code><code class="o">//</code><code class="n">en</code><code class="o">.</code><code class="n">wikipedia</code><code class="o">.</code><code class="n">org</code><code class="o">/</code><code class="n">wiki</code><code class="o">/</code><code class="n">L</code><code class="o">%</code><code class="n">C3</code><code class="o">%</code><code class="n">AA_</code><code class="o">%</code><code class="n">C3</code><code class="o">...</code>  <code class="n">Lê</code> <code class="n">Ðức</code> <code class="n">Thọ</code>
<code class="o">...</code></pre>
<p>It turns out to be a Unicode error in creating the Wikipedia link for Lê Ðức Thọ, the Vietnamese Peace Prize winner. This can be corrected by hand.</p>
<p>The <code>df_clean_bios</code> DataFrame includes an array of image URLs we scraped from Wikipedia. We won’t be using these, and they would have to be converted to JSON in order to save them to SQL. Let’s drop the <code>images_url</code> column to make our dataset as uncluttered as possible:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df_clean_bios</code><code class="o">.</code><code class="n">drop</code><code class="p">(</code><code class="s1">'image_urls'</code><code class="p">,</code> <code class="n">axis</code><code class="o">=</code><code class="mi">1</code><code class="p">,</code> <code class="n">inplace</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code></pre>
<p>Now our dataset is cleaned and streamlined, let’s save it in a couple of handy formats.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Saving the Cleaned Datasets" data-type="sect1"><div class="sect1" id="sect_saving_cleaned_dataset">
<h1>Saving the Cleaned Datasets</h1>
<p>Now we have the datasets required for our upcoming exploration with pandas, let’s save them in a couple of formats ubiquitous in data visualization, SQL and JSON.<a data-primary="JSON" data-secondary="saving cleaned datasets to" data-type="indexterm" id="idm45607770089584"/></p>
<p>First, we’ll save our cleaned DataFrame with <code>born_in</code> field and merged biographies as a JSON file using pandas’s handy <code>to_json</code> method:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df_clean_bios</code><code class="o">.</code><code class="n">to_json</code><code class="p">(</code><code class="s1">'</code><code class="s1">data/nobel_winners_cleaned.json</code><code class="s1">'</code><code class="p">,</code><code>\
</code><code>             </code><code class="n">orient</code><code class="o">=</code><code class="s1">'</code><code class="s1">records</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">date_format</code><code class="o">=</code><code class="s1">'</code><code class="s1">iso</code><code class="s1">'</code><code class="p">)</code><code> </code><a class="co" href="#callout_cleaning_data_with_pandas_CO27-1" id="co_cleaning_data_with_pandas_CO27-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_cleaning_data_with_pandas_CO27-1" id="callout_cleaning_data_with_pandas_CO27-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>We set the <code>orient</code> argument to <code>records</code> to store an array of row-objects and specify <code>'iso'</code> as the string encoding for our date format.</p></dd>
</dl>
<p>Let’s save a copy of our clean<a data-primary="SQLite" data-secondary="saving cleaned datasets to" data-type="indexterm" id="idm45607770042800"/> DataFrame to an SQLite <code>nobel_prize</code> database in a local <em>data</em> directory. We’ll use this to demonstrate the Flask-based REST web API in <a data-type="xref" href="ch13.xhtml#chapter_delivery_restful">Chapter 13</a>.  Three lines of Python and the DataFrame’s <code>to_sql</code> method do the job succinctly (see <a data-type="xref" href="ch08.xhtml#sect_pandas_sql">“SQL”</a> for more details):</p>
<pre data-code-language="python" data-type="programlisting"><code class="kn">import</code> <code class="nn">sqlalchemy</code>

<code class="n">engine</code> <code class="o">=</code> <code class="n">sqlalchemy</code><code class="o">.</code><code class="n">create_engine</code><code class="p">(</code>\
     <code class="s1">'sqlite:///data/nobel_winners_clean.db'</code><code class="p">)</code>
<code class="n">df_clean_bios</code><code class="o">.</code><code class="n">to_sql</code><code class="p">(</code><code class="s1">'winners'</code><code class="p">,</code> <code class="n">engine</code><code class="p">,</code> <code class="n">if_exists</code><code class="o">=</code><code class="s1">'replace'</code><code class="p">)</code></pre>
<p>Let’s make sure we’ve successfully created the database by reading the contents back into a DataFrame:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">df_read_sql</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">read_sql</code><code class="p">(</code><code class="s1">'winners'</code><code class="p">,</code> <code class="n">engine</code><code class="p">)</code>
<code class="n">df_read_sql</code><code class="o">.</code><code class="n">info</code><code class="p">()</code>
<code class="n">Out</code><code class="p">:</code>
<code class="o">&lt;</code><code class="k">class</code> <code class="err">'</code><code class="nc">pandas</code><code class="o">.</code><code class="n">core</code><code class="o">.</code><code class="n">frame</code><code class="o">.</code><code class="n">DataFrame</code><code class="s1">'&gt;</code>
<code class="n">RangeIndex</code><code class="p">:</code> <code class="mi">858</code> <code class="n">entries</code><code class="p">,</code> <code class="mi">0</code> <code class="n">to</code> <code class="mi">857</code>
<code class="n">Data</code> <code class="n">columns</code> <code class="p">(</code><code class="n">total</code> <code class="mi">16</code> <code class="n">columns</code><code class="p">):</code>
 <code class="c1">#   Column          Non-Null Count  Dtype</code>
<code class="o">---</code>  <code class="o">------</code>          <code class="o">--------------</code>  <code class="o">-----</code>
 <code class="mi">0</code>   <code class="n">index</code>           <code class="mi">858</code> <code class="n">non</code><code class="o">-</code><code class="n">null</code>    <code class="n">int64</code>
 <code class="mi">1</code>   <code class="n">category</code>        <code class="mi">858</code> <code class="n">non</code><code class="o">-</code><code class="n">null</code>    <code class="nb">object</code>
 <code class="mi">2</code>   <code class="n">country</code>         <code class="mi">858</code> <code class="n">non</code><code class="o">-</code><code class="n">null</code>    <code class="nb">object</code>
 <code class="mi">3</code>   <code class="n">date_of_birth</code>   <code class="mi">858</code> <code class="n">non</code><code class="o">-</code><code class="n">null</code>    <code class="n">datetime64</code><code class="p">[</code><code class="n">ns</code><code class="p">]</code>
 <code class="p">[</code><code class="o">...</code><code class="p">]</code>
 <code class="mi">14</code>  <code class="n">bio_image</code>       <code class="mi">770</code> <code class="n">non</code><code class="o">-</code><code class="n">null</code>    <code class="nb">object</code>
 <code class="mi">15</code>  <code class="n">mini_bio</code>        <code class="mi">857</code> <code class="n">non</code><code class="o">-</code><code class="n">null</code>    <code class="nb">object</code>
<code class="n">dtypes</code><code class="p">:</code> <code class="n">datetime64</code><code class="p">[</code><code class="n">ns</code><code class="p">](</code><code class="mi">2</code><code class="p">),</code> <code class="n">float64</code><code class="p">(</code><code class="mi">2</code><code class="p">),</code> <code class="n">int64</code><code class="p">(</code><code class="mi">1</code><code class="p">),</code> <code class="nb">object</code><code class="p">(</code><code class="mi">11</code><code class="p">)</code>
<code class="n">memory</code> <code class="n">usage</code><code class="p">:</code> <code class="mf">107.4</code><code class="o">+</code> <code class="n">KB</code></pre>
<p>With our cleaned data in the database, we’re ready to start exploring it in the next chapter.</p>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45607770090688">
<h1>Summary</h1>
<p>In this chapter, you learned how to clean a fairly messy dataset, producing data that will be much nicer to explore and generally work with. Along the way, a number of new pandas methods and techniques were introduced to extend the last chapter’s introduction to basic pandas.</p>
<p>In the next chapter, we will use our newly minted dataset to start getting a feel for the Nobel Prize recipients, their country, gender, age, and any interesting correlations (or lack thereof) we can find.<a data-primary="pandas" data-secondary="cleaning data with" data-startref="ix_pndscln" data-type="indexterm" id="idm45607769904688"/></p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45607776705472"><sup><a href="ch09.xhtml#idm45607776705472-marker">1</a></sup> <em>Large</em> is a very relative term, but pandas will take pretty much whatever will fit in your computer’s RAM memory, which is where DataFrames live.</p><p data-type="footnote" id="idm45607775813456"><sup><a href="ch09.xhtml#idm45607775813456-marker">2</a></sup> pandas supports multiple indices using the <code>MultiIndex</code> object. This provides a very powerful way of refining higher-dimensional data. Check out the details <a href="https://oreil.ly/itwDR">in the pandas documentation</a>.</p><p data-type="footnote" id="idm45607774963264"><sup><a href="ch09.xhtml#idm45607774963264-marker">3</a></sup> By default, pandas uses NumPy’s <code>NaN</code> (not a number) float to designate missing values.</p><p data-type="footnote" id="idm45607774530976"><sup><a href="ch09.xhtml#idm45607774530976-marker">4</a></sup> One interesting visualization might be charting the migration of Nobel Prize winners from their homelands.</p><p data-type="footnote" id="idm45607774527728"><sup><a href="ch09.xhtml#idm45607774527728-marker">5</a></sup> See IEEE 754 and <a href="https://oreil.ly/5H3q2">Wikipedia</a>.</p><p data-type="footnote" id="idm45607774438432"><sup><a href="ch09.xhtml#idm45607774438432-marker">6</a></sup> As you’ll see in the next chapter, the <code>born_in</code> fields contain some interesting information about the movements of Nobel Prize winners. We’ll see how to add this data to the cleaned dataset at the end of this chapter.</p><p data-type="footnote" id="idm45607773684544"><sup><a href="ch09.xhtml#idm45607773684544-marker">7</a></sup> While France was Curie’s adopted country,  she retained Polish citizenship and named her first discovered radioactive isotope <em>polonium</em> after her home country.</p><p data-type="footnote" id="idm45607773466112"><sup><a href="ch09.xhtml#idm45607773466112-marker">8</a></sup> Some users dismiss such warnings as nannying paranoia. See the discussion <a href="https://oreil.ly/b7G9r">on Stack Overflow</a>.</p><p data-type="footnote" id="idm45607773464480"><sup><a href="ch09.xhtml#idm45607773464480-marker">9</a></sup> They can be turned off with <code>pd.options.mode.chained_assignment = None  # default=<em>warn</em></code>.</p><p data-type="footnote" id="idm45607772960432"><sup><a href="ch09.xhtml#idm45607772960432-marker">10</a></sup> Depending on the dataset, the cleaning phase is unlikely to catch all transgressors.</p><p data-type="footnote" id="idm45607772538016"><sup><a href="ch09.xhtml#idm45607772538016-marker">11</a></sup> Although Granit’s gender is not specified in the person data, his <a href="https://oreil.ly/PxUns">Wikipedia biography</a> uses the male gender.</p></div></div></section></div></body></html>