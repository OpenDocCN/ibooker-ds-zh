- en: Chapter 4\. Linear Algebra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is there anything more useless or less useful than algebra?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Billy Connolly
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Linear algebra is the branch of mathematics that deals with *vector spaces*.
    Although I can’t hope to teach you linear algebra in a brief chapter, it underpins
    a large number of data science concepts and techniques, which means I owe it to
    you to at least try. What we learn in this chapter we’ll use heavily throughout
    the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abstractly, *vectors* are objects that can be added together to form new vectors
    and that can be multiplied by *scalars* (i.e., numbers), also to form new vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Concretely (for us), vectors are points in some finite-dimensional space. Although
    you might not think of your data as vectors, they are often a useful way to represent
    numeric data.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you have the heights, weights, and ages of a large number of
    people, you can treat your data as three-dimensional vectors `[height, weight,
    age]`. If you’re teaching a class with four exams, you can treat student grades
    as four-dimensional vectors `[exam1, exam2, exam3, exam4]`.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest from-scratch approach is to represent vectors as lists of numbers.
    A list of three numbers corresponds to a vector in three-dimensional space, and
    vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll accomplish this with a type alias that says a `Vector` is just a `list`
    of `float`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We’ll also want to perform *arithmetic* on vectors. Because Python `list`s aren’t
    vectors (and hence provide no facilities for vector arithmetic), we’ll need to
    build these arithmetic tools ourselves. So let’s start with that.
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we’ll frequently need to add two vectors. Vectors add *componentwise*.
    This means that if two vectors `v` and `w` are the same length, their sum is just
    the vector whose first element is `v[0] + w[0]`, whose second element is `v[1]
    + w[1]`, and so on. (If they’re not the same length, then we’re not allowed to
    add them.)
  prefs: []
  type: TYPE_NORMAL
- en: For example, adding the vectors `[1, 2]` and `[2, 1]` results in `[1 + 2, 2
    + 1]` or `[3, 3]`, as shown in [Figure 4-1](#adding_two_vectors).
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding two vectors.](assets/dsf2_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. Adding two vectors
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can easily implement this by `zip`-ing the vectors together and using a
    list comprehension to add the corresponding elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, to subtract two vectors we just subtract the corresponding elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also sometimes want to componentwise sum a list of vectors—that is, create
    a new vector whose first element is the sum of all the first elements, whose second
    element is the sum of all the second elements, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also need to be able to multiply a vector by a scalar, which we do simply
    by multiplying each element of the vector by that number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to compute the componentwise means of a list of (same-sized)
    vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A less obvious tool is the *dot product*. The dot product of two vectors is
    the sum of their componentwise products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If `w` has magnitude 1, the dot product measures how far the vector `v` extends
    in the `w` direction. For example, if `w = [1, 0]`, then `dot(v, w)` is just the
    first component of `v`. Another way of saying this is that it’s the length of
    the vector you’d get if you *projected* `v` onto `w` ([Figure 4-2](#dot_product_as_vector_projection)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Dot product as a vector projection.](assets/dsf2_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. The dot product as vector projection
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Using this, it’s easy to compute a vector’s *sum of squares*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'which we can use to compute its *magnitude* (or length):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have all the pieces we need to compute the distance between two vectors,
    defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartRoot left-parenthesis v 1 minus w 1 right-parenthesis squared
    plus ellipsis plus left-parenthesis v Subscript n Baseline minus w Subscript n
    Baseline right-parenthesis squared EndRoot" display="block"><msqrt><mrow><msup><mrow><mo>(</mo><msub><mi>v</mi>
    <mn>1</mn></msub> <mo>-</mo><msub><mi>w</mi> <mn>1</mn></msub> <mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>+</mo> <mo>...</mo> <mo>+</mo> <msup><mrow><mo>(</mo><msub><mi>v</mi>
    <mi>n</mi></msub> <mo>-</mo><msub><mi>w</mi> <mi>n</mi></msub> <mo>)</mo></mrow>
    <mn>2</mn></msup></mrow></msqrt></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'In code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is possibly clearer if we write it as (the equivalent):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: That should be plenty to get us started. We’ll be using these functions heavily
    throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using lists as vectors is great for exposition but terrible for performance.
  prefs: []
  type: TYPE_NORMAL
- en: In production code, you would want to use the NumPy library, which includes
    a high-performance array class with all sorts of arithmetic operations included.
  prefs: []
  type: TYPE_NORMAL
- en: Matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *matrix* is a two-dimensional collection of numbers. We will represent matrices
    as lists of lists, with each inner list having the same size and representing
    a *row* of the matrix. If `A` is a matrix, then `A[i][j]` is the element in the
    *i*th row and the *j*th column. Per mathematical convention, we will frequently
    use capital letters to represent matrices. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In mathematics, you would usually name the first row of the matrix “row 1” and
    the first column “column 1.” Because we’re representing matrices with Python `list`s,
    which are zero-indexed, we’ll call the first row of a matrix “row 0” and the first
    column “column 0.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this list-of-lists representation, the matrix `A` has `len(A)` rows and
    `len(A[0])` columns, which we consider its `shape`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If a matrix has *n* rows and *k* columns, we will refer to it as an *n × k
    matrix*. We can (and sometimes will) think of each row of an *n × k* matrix as
    a vector of length *k*, and each column as a vector of length *n*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also want to be able to create a matrix given its shape and a function
    for generating its elements. We can do this using a nested list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this function, you could make a 5 × 5 *identity matrix* (with 1s on the
    diagonal and 0s elsewhere) like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Matrices will be important to us for several reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can use a matrix to represent a dataset consisting of multiple vectors,
    simply by considering each vector as a row of the matrix. For example, if you
    had the heights, weights, and ages of 1,000 people, you could put them in a 1,000
    × 3 matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Second, as we’ll see later, we can use an *n × k* matrix to represent a linear
    function that maps *k*-dimensional vectors to *n*-dimensional vectors. Several
    of our techniques and concepts will involve such functions.
  prefs: []
  type: TYPE_NORMAL
- en: Third, matrices can be used to represent binary relationships. In [Chapter 1](ch01.html#introduction),
    we represented the edges of a network as a collection of pairs `(i, j)`. An alternative
    representation would be to create a matrix `A` such that `A[i][j]` is 1 if nodes
    `i` and `j` are connected and 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that before we had:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also represent this as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are very few connections, this is a much more inefficient representation,
    since you end up having to store a lot of zeros. However, with the matrix representation
    it is much quicker to check whether two nodes are connected—you just have to do
    a matrix lookup instead of (potentially) inspecting every edge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, to find a node’s connections, you only need to inspect the column
    (or the row) corresponding to that node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With a small graph you could just add a list of connections to each node object
    to speed up this process; but for a large, evolving graph that would probably
    be too expensive and difficult to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll revisit matrices throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: For Further Exploration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linear algebra is widely used by data scientists (frequently implicitly, and
    not infrequently by people who don’t understand it). It wouldn’t be a bad idea
    to read a textbook. You can find several freely available online:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Linear Algebra*](http://joshua.smcvt.edu/linearalgebra/), by Jim Hefferon
    (Saint Michael’s College)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Linear Algebra*](https://www.math.ucdavis.edu/~linear/linear-guest.pdf),
    by David Cherney, Tom Denton, Rohit Thomas, and Andrew Waldron (UC Davis)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are feeling adventurous, [*Linear Algebra Done Wrong*](https://www.math.brown.edu/~treil/papers/LADW/LADW_2017-09-04.pdf),
    by Sergei Treil (Brown University), is a more advanced introduction.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the machinery we built in this chapter you get for free if you use [NumPy](http://www.numpy.org).
    (You get a lot more too, including much better performance.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
