- en: 'Chapter 2\. Transcribing DNA into mRNA: Mutating Strings, Reading and Writing
    Files'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To express the proteins necessary to sustain life, regions of DNA must be transcribed
    into a form of RNA called *messenger RNA* (mRNA). While there are many fascinating
    biochemical differences between DNA and RNA, for our purposes the only difference
    is that all the characters *T* representing the base thymine in a sequence of
    DNA need to be changed to the letter *U*, for uracil. As described on [the Rosalind
    RNA page](https://oreil.ly/9Dddm), the program I’ll show you how to write will
    accept a string of DNA like `ACGT` and print the transcribed mRNA `ACGU`. I can
    use Python’s `str.replace()` function to accomplish this in one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You already saw in [Chapter 1](ch01.html#ch01) how to write a program to accept
    a DNA sequence from the command line or a file and print a result, so you won’t
    be learning much if you do that again. I’ll make this program more interesting
    by tackling a very common pattern found in bioinformatics. Namely, I’ll show how
    to process one or more input files and place the results in an output directory.
    For instance, it’s pretty common to get the results of a sequencing run back as
    a directory of files that need to be quality checked and filtered, with the cleaned
    sequences going into some new directory for your analysis. Here the input files
    contain DNA sequences, one per line, and I’ll write the mRNA sequences into like-named
    files in an output directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to write a program to require one or more file inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to read and write files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to modify strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It might help to try running one of the solutions first to see how your program
    should work. Start by changing into the *02_rna* directory and copying the first
    solution to the program `rna.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Request the usage for the program using the `-h` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The arguments surrounded by square brackets (`[]`) are optional. The `[FILE
    ...]` syntax means that this argument can be repeated.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The input `FILE` argument(s) will be positional.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The optional output directory has the default value of `out`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of the program is to process one or more files, each containing sequences
    of DNA. Here is the first test input file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `rna.py` program with this input file, and note the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now there should be an *out* directory containing a file called *input1.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of that file should match the input DNA sequence but with all
    the *T*s changed to *U*s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should run the program with multiple inputs and verify that you get multiple
    files in the output directory. Here I will use all the test input files with an
    output directory called *rna*. Notice how the summary text uses the correct singular/plurals
    for *sequence(s)* and *file(s)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'I can use the `wc` (word count) program with the `-l` option to count the *lines*
    in the output file and verify that five sequences were written to three files
    in the *rna* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Defining the Program’s Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you can see from the preceding usage, your program should accept the following
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: One or more positional arguments, which must be readable text files each containing
    strings of DNA to transcribe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional `-o` or `--out_dir` argument that names an output directory to write
    the sequences of RNA into. The default should be `out`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You are free to write and structure your programs however you like (so long
    as they pass the tests), but I will always start a program using **`new.py`**
    and the structure I showed in the first chapter. The `--force` flag indicates
    that the existing `rna.py` should be overwritten:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Defining an Optional Parameter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modify the `get_args()` function to accept the parameters described in the
    previous section. To start, define the `out_dir` parameter. I suggest you change
    the `-a|--arg` option generated by `new.py` to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the short flag name. Short flags start with a single dash and are followed
    by a single character.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the long flag name. Long flags start with two dashes and are followed
    by a more memorable string than the short flag. This will also be the name `argparse`
    will use to access the value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This will be incorporated into the usage statement to describe the argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `metavar` is a short description also shown in the usage.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The default type of all arguments is `str` (string), so this is technically
    superfluous but still not a bad idea to document.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The default value will be the string `out`. If you do not specify a `default`
    attribute when defining an option, the default value will be `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining One or More Required Positional Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the `FILE` value(s), I can modify the default `-f|--file` parameter to
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the `-f` short flag and the two dashes from `--file` so that this becomes
    a *positional* argument called `file`. Optional parameters start with dashes,
    and positional ones do not.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `help` string indicates the argument should be one or more files containing
    DNA sequences.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This string is printed in the short usage to indicate the argument is a file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This indicates the number of arguments. The `+` indicates that one or more values
    are required.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the actual type that `argparse` will enforce. I am requiring any value
    to be a readable text (`rt`) file.
  prefs: []
  type: TYPE_NORMAL
- en: Using nargs to Define the Number of Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I use `nargs` to describe the *number of arguments* to the program. In addition
    to using an integer value to describe exactly how many values are allowed, I can
    use the three symbols shown in [Table 2-1](#table_2.1).
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. Possible values for `nargs`
  prefs: []
  type: TYPE_NORMAL
- en: '| Symbol | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `?` | Zero or one |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Zero or more |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | One or more |'
  prefs: []
  type: TYPE_TB
- en: When you use `+` with `nargs`, `argparse` will provide the arguments as a list.
    Even if there is just one argument, you will get a list containing one element.
    You will never have an empty list because at least one argument is required.
  prefs: []
  type: TYPE_NORMAL
- en: Using argparse.FileType() to Validate File Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `argparse.FileType()` function is incredibly powerful, and using it can
    save you loads of time in validating file inputs. When you define a parameter
    with this type, `argparse` will print an error message and halt the execution
    of the program if any of the arguments is not a file. For instance, I would assume
    there is no file in your *02_dna* directory called *blargh*. Notice the result
    when I pass that value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s not obvious here, but the program never made it out of the `get_args()`
    function because `argparse` did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Detected that *blargh* is not a valid file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Printed the short usage statement
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Printed a useful error message
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exited the program with a nonzero value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is how a well-written program ought to work, detecting and rejecting bad
    arguments as soon as possible and notifying the user of the problems. All this
    happened without my writing anything more than a good description of the kind
    of argument I wanted. Again, the best code is code you never write (or as Elon
    Musk puts it, “The best part is no part, the best process is no process.”)
  prefs: []
  type: TYPE_NORMAL
- en: Because I am using the file *type*, the elements of the list will not be strings
    representing the filenames but will instead be open filehandles. A *filehandle*
    is a mechanism to read and write the contents of a file. I used a filehandle in
    the last chapter when the DNA argument was a filename.
  prefs: []
  type: TYPE_NORMAL
- en: The order in which you define these parameters in your source code does not
    matter in this instance. You can define options before or after positional parameters.
    The order only matters when you have multiple positional arguments—the first parameter
    will be for the first positional argument, the second parameter for the second
    positional argument, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Args Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, I need a way to define the `Args` class that will represent the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: I’ll need two new imports from the `typing` module, `List` to describe a list,
    and `TextIO` for an open filehandle.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `files` attribute will be a list of open filehandles.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `out_dir` attribute will be a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can use this class to create the return value from `get_args()`. The following
    syntax uses positional notation such that the `file` is the first field and the
    `out_dir` is the second. When there are one or two fields, I will tend to use
    the positional notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Explicitly using the field names is safer and arguably easier to read, and
    it will become vital when I have more fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now I have all the code to define, document, and validate the inputs. Next,
    I’ll show how the rest of the program should work.
  prefs: []
  type: TYPE_NORMAL
- en: Outlining the Program Using Pseudocode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I’ll sketch out the basics of the program’s logic in the `main()` function
    using a mix of code and pseudocode to generally describe how to handle the input
    and output files. Whenever you get stuck writing a new program, this approach
    can help you see *what* needs to be done. Then you can figure out *how* to do
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `os.path.isdir()` function will report if the output directory exists.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `os.makedirs()` function will create a directory path.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize variables for the number of files and sequences written to use in
    the feedback you provide when the program exits.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Use a `for` loop to iterate the list of filehandles in `args.files`. The iterator
    variable `fh` helps remind me of the type.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This is pseudocode describing the steps you need to do with each filehandle.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO5-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Print a summary for the user to let them know what happened.
  prefs: []
  type: TYPE_NORMAL
- en: The `os.makedirs()` function will create a directory and all the parent directories,
    while the `os.mkdir()` function will fail if the parent directories do not exist.
    I only ever use the first function in my code.
  prefs: []
  type: TYPE_NORMAL
- en: If you think you know how to finish the program, feel free to proceed. Be sure
    to run **`pytest`** (or **`make test`**) to ensure your code is correct. Stick
    with me if you need a little more guidance on how to read and write files. I’ll
    tackle the pseudocode in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating the Input Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember that `args.files` is a `List[TextIO]`, meaning that it is a list of
    filehandles. I can use a `for` loop to visit each element in any iterable in such
    a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'I’d like to stress here that I chose an iterator variable called `fh` because
    each value is a filehandle. I sometimes see people who always use an iterator
    variable name like `i` or `x` with a `for` loop, but those are not descriptive
    variable names.^([1](ch02.html#idm45963631969784)) I’ll concede that it’s very
    common to use variable names like `n` (for *number*) or `i` (for *integer*) when
    iterating numbers like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And I will sometimes use `x` and `xs` (pronounced *exes*) to stand for *one*
    and *many* of some generic value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, it’s very important to use variable names that accurately describe
    the thing they represent.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Output Filenames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Per the pseudocode, the first goal is to open an output file. For that, I need
    a filename that combines the name of the output directory with the *basename*
    of the input file. That is, if the input file is *dna/input1.txt* and the output
    directory is *rna*, then the output file path should be *rna/input1.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `os` module is used to interact with the operating system (like Windows,
    macOS, or Linux), and the `os.path` module has many handy functions I can use,
    like the `os.path.dirname()` function to get the name of the directory from a
    file path and `os.path.basename()` to get the file’s name (see [Figure 2-1](#fig_2.1)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![mpfb 0201](assets/mpfb_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. The `os.path` module contains useful functions like `dirname()`
    and `basename()` to extract parts from a file’s path
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The new sequences will be written to an output file in `args.out_dir`. I suggest
    you use the `os.path.join()` function with the basename of the input file to create
    the output filename, as shown in [Figure 2-2](#fig_2.2). This will ensure that
    the output filename works both on Unix and Windows, which use different path dividers—the
    slash (`/`) and backslash (`\`), respectively. You may also want to investigate
    the `pathlib` module for similar functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 0202](assets/mpfb_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. The `os.path.join()` will create the output path by combining the
    output directory with the basename of the input file
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can get the file’s path from the `fh.name` attribute of the filehandle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your program to verify that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: I’m taking baby steps toward what the program is supposed to do. It’s very important
    to write just one or two lines of code and then run your program to see if it’s
    correct. I often see students try to write many lines of code—whole programs,
    even—before they attempt to run them. That never works out well.
  prefs: []
  type: TYPE_NORMAL
- en: Opening the Output Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using this output filename, you need to `open()` the filehandle. I used this
    function in the first chapter to read DNA from an input file. By default, `open()`
    will only allow me to read a file, but I need to write a file. I can indicate
    that I want to open the file for writing by passing an optional second argument:
    the string `w` for *write*.'
  prefs: []
  type: TYPE_NORMAL
- en: When you open an existing file with a mode of `w`, the file will be *overwritten*,
    meaning its previous contents will be immediately and permanently lost. If needed,
    you can use the `os.path.isfile()` function to check if you’re opening an existing
    file.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Table 2-2](#table_2.2), you can also use the values `r` for *read*
    (the default) and `a` to *append*, which allows you to open for writing more content
    at the end of an existing file.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-2\. File writing modes
  prefs: []
  type: TYPE_NORMAL
- en: '| Mode | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `w` | Write |'
  prefs: []
  type: TYPE_TB
- en: '| `r` | Read |'
  prefs: []
  type: TYPE_TB
- en: '| `a` | Append |'
  prefs: []
  type: TYPE_TB
- en: '[Table 2-3](#table_2.3) shows that you can also read and write either text
    or raw bytes using the modes `t` and `b`, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-3\. File content modes
  prefs: []
  type: TYPE_NORMAL
- en: '| Mode | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `t` | Text |'
  prefs: []
  type: TYPE_TB
- en: '| `b` | Bytes |'
  prefs: []
  type: TYPE_TB
- en: 'You can combine these, for example using `rb` to *read bytes* and `wt` to *write
    text*, which is what I want here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Note that I named my variable `out_fh` to remind me this is the output filehandle.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Output Sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Looking at the pseudocode again, I have two levels of iterating—one for each
    filehandle of input, and then one for each line of DNA in the filehandles. To
    read each line from an open filehandle, I can use another `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The *input2.txt* file has two sequences, each ending with a newline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To start, I’ll show you how to print each sequence to the console, then I’ll
    demonstrate how to use `print()` to write content to a filehandle. [Chapter 1](ch01.html#ch01)
    mentions that the `print()` function will automatically append a newline (`\n`
    on Unix platforms and `\r\n` on Windows) unless I tell it not to. To avoid having
    two newlines from the following code, one from the sequence and one from `print()`,
    I can either use the `str.rstrip()` function to remove the newline from the sequence
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `dna.rstrip()` to remove the trailing newline.
  prefs: []
  type: TYPE_NORMAL
- en: 'or use the `end` option to `print()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the empty string at the end instead of a newline.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal is to transcribe each DNA sequence to RNA and write the result to
    `out_fh`. In the introduction to this chapter, I suggested you could use the `str.replace()`
    function. If you read `help(str.replace)` in the REPL, you’ll see that it will
    “Return a copy with all occurrences of substring old replaced by new”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'There are other ways to change the *T*s to *U*s that I will explore later.
    First, I’d like to point out that strings in Python are immutable, meaning they
    cannot be changed in place. That is, I could check to see if the letter *T* is
    in the DNA string and then use the `str.index()` function to find the location
    and try to overwrite it with the letter *U*, but this will raise an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, I’ll use `str.replace()` to create a new string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'I need to write this new string into the `out_fh` output filehandle. I have
    two options. First, I can use the `print()` function’s `file` option to describe
    *where* to print the string. Consult the `help(print)` documentation in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the option I need to print the string to the open filehandle.
  prefs: []
  type: TYPE_NORMAL
- en: I need to use the `out_fh` filehandle as the `file` argument. I want to point
    out that the default `file` value is `sys.stdout`. On the command line, `STDOUT`
    (pronounced *standard out*) is the standard place for program output to appear,
    which is usually the console.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to use the `out_fh.write()` method of the filehandle itself,
    but note that this function *does not* append a newline. It’s up to you to decide
    when to add newlines. In the case of reading these sequences that are terminated
    with newlines, they are not needed.
  prefs: []
  type: TYPE_NORMAL
- en: Printing the Status Report
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I almost always like to print something when my programs have finished running
    so I at least know they got to the end. It may be something as simple as “Done!”
    Here, though, I’d like to know how many sequences in how many files were processed.
    I also want to know where I can find the output, something that’s especially helpful
    if I forget the name of the default output directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests expect that you will use proper grammar^([2](ch02.html#idm45963631818520))
    to describe the numbers—for example, *1 sequence* and *1 file*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'or *3 sequences* and *2 files*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The syntax `input[12].txt` is a way to say either 1 or 2 can occur, so *input1.txt*
    and *input2.txt* will both match.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Test Suite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can run **`pytest -xv`** to run *tests/rna_test.py*. A passing test suite
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `rna.py` program exists.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The program prints a usage statement when requested.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The program exits with an error when given no arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO11-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The program prints an error message when given a bad file argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO11-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The next tests all verify that the program works properly given good inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, I first write tests that try to break a program before giving
    it good input. For instance, I want the program to fail when given no files or
    when given nonexistent files. Just as the best detectives can think like criminals,
    I try to imagine all the ways to break my programs and test that they behave predictably
    under those circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first three tests are exactly as from [Chapter 1](ch01.html#ch01). For
    the fourth test, I pass a nonexistent file and expect a nonzero exit value along
    with the usage and the error message. Note that the error specifically mentions
    the offending value, here the bad filename. You should strive to create feedback
    that lets the user know exactly what the problem is and how to fix it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This is a function I wrote to generate a string of random characters.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Run the program with this nonexistent file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the exit value is not `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO12-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Use a regular expression (*regex*) to look for the usage in the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO12-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Use another regex to look for the error message describing the bad input filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'I haven’t introduced regular expressions yet, but they will become central
    to solutions I write later. To see why they are useful, look at the output from
    the program when run with a bad file input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Using the `re.match()` function, I am looking for a pattern of text starting
    at the beginning of the `out` text. Using the `re.search()` function, I am looking
    for another pattern that occurs somewhere inside the `out` text. I’ll have much
    more to say about regexes later. For now, it’s enough to point out that they are
    very useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll show one last test that verifies the program runs correctly when provided
    good input. There are many ways to write such a test, so don’t get the impression
    this is canon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the default output directory name.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `try`/`finally` blocks help to ensure cleanup when tests fail.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-3)'
  prefs: []
  type: TYPE_NORMAL
- en: See if the output directory has been left over from a previous run.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `shutil.rmtree()` function to remove the directory and its contents.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Run the program with a known good input file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the expected output directory was created.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the expected output file was created.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the contents of the output file are correct.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Even if something fails in the `try` block, this `finally` block will be run.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](assets/10.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO13-10)'
  prefs: []
  type: TYPE_NORMAL
- en: Clean up the testing environment.
  prefs: []
  type: TYPE_NORMAL
- en: I want to stress how important it is to check every aspect of what your program
    is supposed to do. Here, the program should process some number of input files,
    create an output directory, and then place the processed data into files in the
    output directory. I’m testing every one of those requirements using known input
    to verify that the expected output is created.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of other tests I won’t cover here as they are similar to
    what I’ve already shown, but I would encourage you to read the entire *tests/rna_test.py*
    program. The first input file has one sequence. The second input file has two
    sequences, and I use that to test that two sequences are written to the output
    file. The third input file has two very long sequences. By using these inputs
    individually and together, I try to test every aspect of my program that I can
    imagine.
  prefs: []
  type: TYPE_NORMAL
- en: Although you can run the tests in *tests/rna_test.py* using `pytest`, I also
    urge you to use `pylint`, `flake8`, and `mypy` to check your program. The `make
    test` shortcut can do this for you as it will execute `pytest` with the additional
    arguments to run those tools. Your goal should be a completely clean test suite.
  prefs: []
  type: TYPE_NORMAL
- en: You may find that `pylint` will complain about variable names like `fh` being
    too short or not being *snake_case*, where lowercase words are joined with underscores.
    I have included a *pylintrc* configuration file in the top level of the GitHub
    repository. Copy this to the file *.pylintrc* in your home directory to silence
    these errors.
  prefs: []
  type: TYPE_NORMAL
- en: You should have enough information and tests now to help you finish this program.
    You’ll get the most benefit from this book if you try to write working programs
    on your own before you look at my solutions. Once you have one working version,
    try to find other ways to solve it. If you know about regular expressions, that’s
    a great solution. If you don’t, I will demonstrate a version that uses them.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following two solutions differ only in how I substitute the *T*s for *U*s.
    The first uses the `str.replace()` method, and the second introduces regular expressions
    and uses the Python `re.sub()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 1: Using str.replace()'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the entirety of one solution that uses the `str.replace()` method I
    discussed in the introduction to this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the counters for files and sequences.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate the filehandles.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Increment the counter for files.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Open the output file for this input file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate the sequences in the input file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Increment the counter for sequences.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Write the transcribed sequence to the output file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Close the output filehandle.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO14-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the status. Note that I’m relying on Python’s implicit concatenation of
    adjacent strings to create one output string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 2: Using re.sub()'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I suggested earlier that you might explore how to use regular expressions to
    solve this. Regexes are a language for describing patterns of text. They have
    been around for decades, long before Python was even invented. Though they may
    seem somewhat daunting at first, regexes are well worth the effort to learn.^([3](ch02.html#idm45963631621240))
  prefs: []
  type: TYPE_NORMAL
- en: 'To use regular expressions in Python, I must import the `re` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, I used the `re.search()` function to look for a pattern of text
    inside another string. For this program, the pattern I am looking for is the letter
    *T*, which I can write as a literal string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Search for the pattern `T` inside the string `ACGT`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO15-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Because `T` was found, the return value is a `Re.Match` object showing the location
    of the found pattern. A failed search would return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `span=(3, 4)` reports the start and stop indexes where the pattern `T`
    is found. I can use these positions to extract the substring using a slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: But instead of just finding the *T*, I want to replace the string `T` with `U`.
    As shown in [Figure 2-3](#fig_2.3), the `re.sub()` (for *substitute*) function
    will do this.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 0203](assets/mpfb_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. The `re.sub()` function will return a new string where all instances
    of a pattern have been replaced with a new string
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The result is a new string where the *T*s have all been replaced with *U*s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Replace every `T` with `U` in the string `ACGT`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO16-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The result is a new string with the substitutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this version, I can modify the inner `for` loop, as shown. Note that
    I have chosen to use the `str.strip()` method to remove the newline terminating
    the input DNA string because `print()` will add a newline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_transcribing_dna_into_mrna__mutating_strings__reading_and_writing_files_CO17-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the newline from `dna`, substitute all the `T`s with `U`s, and print
    the resulting string to the output filehandle.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might be curious to know which solution is faster. Comparing the relative
    runtimes of programs is called *benchmarking*, and I’ll show you a simple way
    to compare these two solutions using some basic `bash` commands. I’ll use the
    *./tests/inputs/input3.txt* file, as it is the largest test file. I can write
    a `for` loop in `bash` with almost the same syntax as Python. Note that I am using
    newlines in this command to make it more readable, and `bash` notes the line continuation
    with `>`. You can substitute semicolons (`;`) to write this on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'It would appear the second solution using regular expressions is faster, but
    I don’t have enough data to be sure. I need a more substantial input file. In
    the *02_rna* directory, you’ll find a program called `genseq.py` I wrote that
    will generate 1,000 sequences of 1,000,000 bases in a file called *seq.txt*. You
    can, of course, modify the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The file *seq.txt* that is generated using the defaults is about 95 MB. Here’s
    how the programs do with a more realistic input file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: It now appears that the first solution is faster. For what it’s worth, I came
    up with several other solutions, all of which fared much worse than these two.
    I thought I was creating more and more clever solutions that would ultimately
    lead to the best performance. My pride was sorely wounded when what I thought
    was my best program turned out to be orders of magnitude slower than these two.
    When you have assumptions, you should, as the saying goes, “Trust, but verify.”
  prefs: []
  type: TYPE_NORMAL
- en: Going Further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modify your program to print the lengths of the sequences to the output file
    rather than the transcribed RNA. Have the final status report the maximum, minimum,
    and average sequence lengths.
  prefs: []
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Key points from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The `argparse.FileType` option will validate file arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `nargs` option to `argparse` allows you to define the number of valid arguments
    for a parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `os.path.isdir()` function can detect if a directory exists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `os.makedirs()` function will create a directory structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `open()` function by default allows only reading files. The `w` option must
    be used to write to the filehandle, and the `a` option is for appending values
    to an existing file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File handles can be opened with the `t` option for *text* (the default) or `b`
    for *bytes*, such as when reading image files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings are immutable, and there are many methods to alter strings into new
    strings, including `str.replace()` and `re.sub()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '^([1](ch02.html#idm45963631969784-marker)) As Phil Karlton says, “There are
    only two hard things in Computer Science: cache invalidation and naming things.”'
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch02.html#idm45963631818520-marker)) Sorry, but I can’t stop being an
    English major.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch02.html#idm45963631621240-marker)) [*Mastering Regular Expressions*](https://oreil.ly/R7O1r)
    by Jeffrey Friedl (O’Reilly, 2006) is one of the best books I’ve found.
  prefs: []
  type: TYPE_NORMAL
