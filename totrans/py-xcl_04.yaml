- en: Chapter 3\. Getting Started with Python
  prefs: []
  type: TYPE_NORMAL
- en: With Anaconda installed and Jupyter notebooks up and running, you have everything
    in place to get started with Python. Although this chapter doesn’t go much further
    than the basics, it still covers a lot of ground. If you are at the beginning
    of your coding career, there may be a lot to digest. However, most concepts will
    get clearer once you use them in later chapters as part of a practical example,
    so there’s no need to worry if you don’t understand something fully the first
    time around. Whenever Python and VBA differ significantly, I will point this out
    to make sure you can transition from VBA to Python smoothly and are aware of the
    obvious traps. If you haven’t done any VBA before, feel free to ignore these parts.
  prefs: []
  type: TYPE_NORMAL
- en: I will start this chapter with Python’s basic data types, such as integers and
    strings. After that, I will introduce indexing and slicing, a core concept in
    Python that gives you access to specific elements of a sequence. Up next are data
    structures like lists and dictionaries that can hold multiple objects. I’ll continue
    with the `if` statement and the `for` and `while` loops before getting to an introduction
    of functions and modules that allow you to organize and structure your code. To
    wrap this chapter up, I will show you how to format your Python code properly.
    As you have probably guessed by now, this chapter is as technical as it can get.
    Running the examples for yourself in a Jupyter notebook is therefore a good idea
    to make everything a bit more interactive and playful. Either type the examples
    yourself or run them by using the provided notebooks in the companion repository.
  prefs: []
  type: TYPE_NORMAL
- en: Data Types
  prefs: []
  type: TYPE_NORMAL
- en: Python, like every other programming language, treats numbers, text, booleans,
    etc. differently by assigning them a different data type. The data types that
    we will use most often are integers, floats, booleans, and strings. In this section,
    I am going to introduce them one after another with a few examples. To be able
    to understand data types, though, I first need to explain what an object is.
  prefs: []
  type: TYPE_NORMAL
- en: Objects
  prefs: []
  type: TYPE_NORMAL
- en: In Python, everything is an object, including numbers, strings, functions, and
    everything else that we’ll meet in this chapter. Objects can make complex things
    easy and intuitive by giving you access to a set of variables and functions. So
    before anything else, let me say a few words about variables and functions!
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, a variable is a name that you assign to an object by using the equal
    sign. In the first line of the following example, the name `a` is assigned to
    the object `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``1``]:``a``=``3``b``=``4``a``+``b`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[1]: 7`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This works the same for all objects, which is simpler compared to VBA, where
    you use the equal sign for data types like numbers and strings and the `Set` statement
    for objects like workbooks or worksheets. In Python, you change a variable’s type
    simply by assigning it to a new object. This is referred to as dynamic typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``2``]:``a``=``3``print``(``a``)``a``=``"three"``print``(``a``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`3 three`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Unlike VBA, Python is case-sensitive, so `a` and `A` are two different variables.
    Variable names must follow certain rules:'
  prefs: []
  type: TYPE_NORMAL
- en: They must start with either a letter or an underscore
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: They must consist of letters, numbers, and underscores
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: After this short introduction to variables, let’s see how we can make function
    calls!
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs: []
  type: TYPE_NORMAL
- en: 'I will introduce functions with a lot more detail later in this chapter. For
    now, you should simply know how to call built-in functions like `print` that we
    used in the previous code sample. To call a function, you add parentheses to the
    function name and provide the arguments within the parentheses, which is pretty
    much equivalent to the mathematical notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`function_name``(``argument1``,``argument2``,``...``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s now look at how variables and functions work in the context of objects!
  prefs: []
  type: TYPE_NORMAL
- en: Attributes and methods
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of objects, variables are called attributes and functions are
    called methods: attributes give you access to the data of an object, and methods
    allow you to perform an action. To access attributes and methods, you use the
    dot notation like this: `myobject.attribute` and `myobject.method()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make this a bit more tangible: if you write a car racing game, you would
    most likely use an object that represents a car. The `car` object could have a
    `speed` attribute that allows you to get the current speed via `car.speed`, and
    you might be able to accelerate the car by calling the accelerate method `car.accelerate(10)`,
    which would increase the speed by ten miles per hour.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The type of an object and with that its behavior is defined by a class, so
    the previous example would require you to write a `Car` class. The process of
    getting a `car` object out of a `Car` class is called instantiation, and you instantiate
    an object by calling the class in the same way as you call a function: `car =
    Car()`. We won’t write our own classes in this book, but if you are interested
    in how this works, have a look at [Appendix C](index_split_031.html#filepos1832059).'
  prefs: []
  type: TYPE_NORMAL
- en: We will use a first object method in the next section to make a text string
    uppercase, and we will get back to the topic of objects and classes when we talk
    about `datetime` objects toward the end of this chapter. Now, however, let’s move
    on with those objects that have a numeric data type!
  prefs: []
  type: TYPE_NORMAL
- en: Numeric Types
  prefs: []
  type: TYPE_NORMAL
- en: 'The data types `int` and `float` represent integers and floating-point numbers,
    respectively. To find out the data type of a given object, use the built-in `type`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``3``]:``type``(``4``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[3]: int`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``4``]:``type``(``4.4``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[4]: float`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you want to force a number to be a `float` instead of an `int`, it’s good
    enough to use a trailing decimal point or the `float` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``5``]:``type``(``4.``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[5]: float`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``6``]:``float``(``4``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[6]: 4.0`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The last example can also be turned around: using the `int` constructor, you
    can turn a `float` into an `int`. If the fractional part is not zero, it will
    be truncated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``7``]:``int``(``4.9``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[7]: 4`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: EXCEL CELLS ALWAYS STORE FLOATS
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You may need to convert a `float` to an `int` when you read in a number from
    an Excel cell and provide it as an argument to a Python function that expects
    an integer. The reason is that numbers in Excel cells are always stored as floats
    behind the scenes, even if Excel shows you what looks like an integer.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Python has a few more numeric types that I won’t use or discuss in this book:
    there are the `decimal`, `fraction`, and `complex` data types. If floating-point
    inaccuracies are an issue (see sidebar), use the `decimal` type for exact results.
    These cases are very rare, though. As a rule of thumb: if Excel would be good
    enough for the calculations, use floats.'
  prefs: []
  type: TYPE_NORMAL
- en: FLOATING-POINT INACCURACIES
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'By default, Excel often shows rounded numbers: type `=1.125-1.1` into a cell,
    and you will see `0.025`. While this might be what you expect, it is not what
    Excel stores internally. Change the display format to show at least 16 decimals,
    and it will change to `0.0249999999999999`. This is the effect of floating-point
    inaccuracy: computers live in a binary world, i.e., they calculate only with zeros
    and ones. Certain decimal fractions like `0.1` can’t be stored as a finite binary
    floating-point number, which explains the result from the subtraction. In Python,
    you will see the same effect, but Python doesn’t hide the decimals from you:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``8``]:``1.125``-``1.1`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[8]: 0.02499999999999991`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Mathematical operators
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculating with numbers requires the use of mathematical operators like the
    plus or minus sign. Except for the power operator, there shouldn’t be any surprise
    if you come from Excel:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``9``]:``3``+``4``# Sum`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[9]: 7`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``10``]:``3``-``4``# Subtraction`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[10]: -1`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``11``]:``3``/``4``# Division`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[11]: 0.75`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``12``]:``3``*``4``# Multiplication`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[12]: 12`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``13``]:``3``**``4``# The power operator (Excel uses 3^4)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[13]: 81`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``14``]:``3``*``(``3``+``4``)``# Use of parentheses`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[14]: 21`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: COMMENTS
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the previous examples, I was describing the operation of the example by
    using comments (e.g., `# Sum`). Comments help other people (and yourself a few
    weeks after writing the code) to understand what’s going on in your program. It
    is good practice to only comment those things that are not already evident from
    reading the code: when in doubt, it’s better to have no comment than an outdated
    comment that contradicts the code. Anything starting with a hash sign is a comment
    in Python and is ignored when you run the code:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``15``]:``# This is a sample we''ve seen before.``# Every comment line
    has to start with a #``3``+``4`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[15]: 7`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``16``]:``3``+``4``# This is an inline comment`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[16]: 7`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Most editors have a keyboard shortcut to comment/uncomment lines. In Jupyter
    notebooks and VS Code, it is Ctrl+/ (Windows) or Command-/ (macOS). Note that
    Markdown cells in Jupyter notebooks won’t accept comments—if you start a line
    with a `#` there, Markdown will interpret this as a heading.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Having integers and floats covered, let’s move straight to the next section
    about booleans!
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  prefs: []
  type: TYPE_NORMAL
- en: 'The boolean types in Python are `True` or `False`, exactly like in VBA. The
    boolean operators `and`, `or`, and `not`, however, are all lowercase, while VBA
    shows them capitalized. Boolean expressions are similar to how they work in Excel,
    except for equality and inequality operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``17``]:``3``==``4``# Equality (Excel uses 3 = 4)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[17]: False`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``18``]:``3``!=``4``# Inequality (Excel uses 3 <> 4)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[18]: True`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``19``]:``3``<``4``# Smaller than. Use > for bigger than.`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[19]: True`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``20``]:``3``<=``4``# Smaller or equal. Use >= for bigger or equal.`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[20]: True`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``21``]:``# You can chain logical expressions``# In VBA, this would be:
    10 < 12 And 12 < 17``# In Excel formulas, this would be: =AND(10 < 12, 12 < 17)``10``<``12``<``17`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[21]: True`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``22``]:``not``True``# "not" operator`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[22]: False`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``23``]:``False``and``True``# "and" operator`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[23]: False`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``24``]:``False``or``True``# "or" operator`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[24]: True`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Every Python object evaluates to either `True` or `False`. The majority of objects
    are `True`, but there are some that evaluate to `False` including `None` (see
    sidebar), `False`, `0` or empty data types, e.g., an empty string (I’ll introduce
    strings in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: NONE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`None` is a built-in constant and represents “the absence of a value” according
    to the official docs. For example, if a function does not explicitly return anything,
    it returns `None`. It is also a good choice to represent empty cells in Excel
    as we will see in [Part III](index_split_018.html#filepos863198) and [Part IV](index_split_023.html#filepos1235617).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To double-check if an object is `True` or `False`, use the `bool` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``25``]:``bool``(``2``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[25]: True`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``26``]:``bool``(``0``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[26]: False`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``27``]:``bool``(``"some text"``)``# We''ll get to strings in a moment`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[27]: True`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``28``]:``bool``(``""``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[28]: False`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``29``]:``bool``(``None``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[29]: False`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'With booleans in our pocket, there is one more basic data type left: textual
    data, better known as strings.'
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have ever worked with strings in VBA that are longer than one line and
    contain variables and literal quotes, you probably wished it was easier. Fortunately,
    this is an area where Python is particularly strong. Strings can be expressed
    by using either double quotes (`"`) or single quotes (`''`). The only condition
    is that you have to start and end the string with the same type of quotes. You
    can use `+` to concatenate strings or `*` to repeat strings. Since I showed you
    the repeating case already when trying out the Python REPL in the previous chapter,
    here is a sample using the plus sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``30``]:``"A double quote string. "``+``''A single quote string.''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[30]: ''A double quote string. A single quote string.''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Depending on what you want to write, using single or double quotes can help
    you to easily print literal quotes without the need to escape them. If you still
    need to escape a character, you precede it with a backslash:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``31``]:``print``(``"Don''t wait! "``+``''Learn how to "speak" Python.''``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Don''t wait! Learn how to "speak" Python.`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``32``]:``print``(``"It''s easy to` `\"``escape``\"` `characters with
    a leading` `\\``."``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`It''s easy to "escape" characters with a leading \.`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'When you are mixing strings with variables, you usually work with f-strings,
    short for formatted string literal. Simply put an `f` in front of your string
    and use variables in between curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``33``]:``# Note how Python allows you to conveniently assign multiple``#
    values to multiple variables in a single line``first_adjective``,``second_adjective``=``"free"``,``"open
    source"``f``"Python is {first_adjective} and {second_adjective}."`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[33]: ''Python is free and open source.''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As I mentioned at the beginning of this section, strings are objects like everything
    else, and they offer a few methods (i.e., functions) to perform an action on that
    string. For example, this is how you transform between upper and lowercase letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``34``]:``"PYTHON"``.``lower``()`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[34]: ''python''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``35``]:``"python"``.``upper``()`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[35]: ''PYTHON''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: GETTING HELP
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'How do you know what attributes certain objects like strings offer and what
    arguments their methods accept? The answer depends a bit on the tool you use:
    with Jupyter notebooks, hit the Tab key after typing the dot that follows an object,
    for example `"python".``<Tab>`. This will make a dropdown appear with all the
    attributes and methods that this object offers. If your cursor is in a method,
    for example within the parentheses of `"python".upper()`, hit Shift+Tab to get
    the description of that function. VS Code will display this information automatically
    as a tooltip. If you run a Python REPL on the Anaconda Prompt, use `dir("python")`
    to get the available attributes and `help("python".upper)` to print the description
    of the `upper` method. Other than that, it’s always a good idea to get back to
    Python’s [online documentation](https://docs.python.org). If you are looking for
    the documentation of third-party packages like pandas, it’s helpful to search
    for them on [PyPI](https://pypi.org), Python’s package index, where you will find
    the links to the respective home pages and documentation.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'When working with strings, a regular task is to select parts of a string: for
    example, you may want to get the `USD` part out of the `EURUSD` exchange rate
    notation. The next section shows you Python’s powerful indexing and slicing mechanism
    that allows you to do exactly this.'
  prefs: []
  type: TYPE_NORMAL
- en: Indexing and Slicing
  prefs: []
  type: TYPE_NORMAL
- en: Indexing and slicing give you access to specific elements of a sequence. Since
    strings are sequences of characters, we can use them to learn how it works. In
    the next section, we will meet additional sequences like lists and tuples that
    support indexing and slicing too.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-1](#filepos228355) introduces the concept of indexing. Python is
    zero-based, which means that the first element in a sequence is referred to by
    index `0`. Negative indices from `-1` allow you to refer to elements from the
    end of the sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/00023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. Indexing from the beginning and end of a sequence
  prefs: []
  type: TYPE_NORMAL
- en: COMMON ERROR TRAPS FOR VBA DEVELOPERS
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you are coming from VBA, indexing is a common error trap. VBA uses one-based
    indexing for most collections like sheets (`Sheets(1)`) but uses zero-based indexing
    for arrays (`MyArray(0)`), although that default can be changed. Another difference
    is that VBA uses parentheses for indexing while Python uses square brackets.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The syntax for indexing is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sequence``[``index``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Accordingly, you access specific elements from a string like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``36``]:``language``=``"PYTHON"`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``37``]:``language``[``0``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[37]: ''P''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``38``]:``language``[``1``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[38]: ''Y''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``39``]:``language``[``-``1``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[39]: ''N''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``40``]:``language``[``-``2``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[40]: ''O''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You will often want to extract more than just a single character—this is where
    slicing comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Slicing
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to get more than one element from a sequence, you use the slicing
    syntax, which works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sequence``[``start``:``stop``:``step``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Python uses half-open intervals: the `start` index is included while the `stop`
    index is not. If you leave the `start` or `stop` arguments away, it will include
    everything from the beginning or to the end of the sequence, respectively. `step`
    determines the direction and the step size: for example, `2` will return every
    second element from left to right and `-3` will return every third element from
    right to left. The default step size is one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``41``]:``language``[:``3``]``# Same as language[0:3]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[41]: ''PYT''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``42``]:``language``[``1``:``3``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[42]: ''YT''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``43``]:``language``[``-``3``:]``# Same as language[-3:6]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[43]: ''HON''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``44``]:``language``[``-``3``:``-``1``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[44]: ''HO''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``45``]:``language``[::``2``]``# Every second element`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[45]: ''PTO''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``46``]:``language``[``-``1``:``-``4``:``-``1``]``# Negative step goes
    from right to left`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[46]: ''NOH''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'So far we’ve looked at just a single index or slice operation, but Python also
    allows you to chain multiple index and slice operations together. For example,
    if you want to get the second character out of the last three characters, you
    could do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``47``]:``language``[``-``3``:][``1``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[47]: ''O''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is the same as `language[-2]` so in this case, it wouldn’t make much sense
    to use chaining, but it will make more sense when we use indexing and slicing
    with lists, one of the data structures that I am going to introduce in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Data Structures
  prefs: []
  type: TYPE_NORMAL
- en: Python offers powerful data structures that make working with a collection of
    objects really easy. In this section, I am going to introduce lists, dictionaries,
    tuples, and sets. While each of these data structures has slightly different characteristics,
    they are all able to hold multiple objects. In VBA, you may have used collections
    or arrays to hold multiple values. VBA even offers a data structure called dictionary
    that works conceptually the same as Python’s dictionary. It is, however, only
    available on the Windows version of Excel out of the box. Let’s get started with
    lists, the data structure that you will probably use most.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs: []
  type: TYPE_NORMAL
- en: 'Lists are capable of holding multiple objects of different data types. They
    are so versatile that you will use them all the time. You create a list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[``element1``,``element2``,``...``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here are two lists, one with the names of Excel files and the other one with
    a few numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``48``]:``file_names``=``[``"one.xlsx"``,``"two.xlsx"``,``"three.xlsx"``]``numbers``=``[``1``,``2``,``3``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Like strings, lists can easily be concatenated with the plus sign. This also
    shows you that lists can hold different types of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``49``]:``file_names``+``numbers`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[49]: [''one.xlsx'', ''two.xlsx'', ''three.xlsx'', 1, 2, 3]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As lists are objects like everything else, lists can also have other lists
    as their elements. I will refer to them as nested lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``50``]:``nested_list``=``[[``1``,``2``,``3``],``[``4``,``5``,``6``],``[``7``,``8``,``9``]]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you rearrange this to span over multiple lines, you can easily recognize
    that this is a very nice representation of a matrix, or a range of spreadsheet
    cells. Note that the square brackets implicitly allow you to break the lines (see
    sidebar). Via indexing and slicing, you get the elements you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``51``]:``cells``=``[[``1``,``2``,``3``],``[``4``,``5``,``6``],``[``7``,``8``,``9``]]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``52``]:``cells``[``1``]``# Second row`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[52]: [4, 5, 6]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``53``]:``cells``[``1``][``1``:]``# Second row, second and third column`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[53]: [5, 6]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: LINE CONTINUATION
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Sometimes, a line of code can get so long that you will need to break it up
    into two or more lines to keep your code readable. Technically, you can either
    use parentheses or a backslash to break up the line:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``54``]:``a``=``(``1``+``2``+``3``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``55``]:``a``=``1``+``2` `\` `+``3`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Python’s style guide, however, prefers that you use implicit line breaks if
    possible: whenever you are using an expression that contains parentheses, square
    brackets, or curly braces, use them to introduce a line break without having to
    introduce an additional character. I will say more about Python’s style guide
    toward the end of this chapter.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You can change elements in lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``56``]:``users``=``[``"Linda"``,``"Brian"``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``57``]:``users``.``append``(``"Jennifer"``)``# Most commonly you add
    to the end``users`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[57]: [''Linda'', ''Brian'', ''Jennifer'']`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``58``]:``users``.``insert``(``0``,``"Kim"``)``# Insert "Kim" at index
    0``users`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[58]: [''Kim'', ''Linda'', ''Brian'', ''Jennifer'']`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To delete an element, use either `pop` or `del`. While `pop` is a method, `del`
    is implemented as a statement in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``59``]:``users``.``pop``()``# Removes and returns the last element by
    default`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[59]: ''Jennifer''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``60``]:``users`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[60]: [''Kim'', ''Linda'', ''Brian'']`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``61``]:``del``users``[``0``]``# del removes an element at the given
    index`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Some other useful things you can do with lists are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``62``]:``len``(``users``)``# Length`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[62]: 2`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``63``]:``"Linda"``in``users``# Check if users contains "Linda"`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[63]: True`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``64``]:``print``(``sorted``(``users``))``# Returns a new sorted list``print``(``users``)``#
    The original list is unchanged`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`[''Brian'', ''Linda''] [''Linda'', ''Brian'']`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``65``]:``users``.``sort``()``# Sorts the original list``users`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[65]: [''Brian'', ''Linda'']`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Note that you can use `len` and `in` with strings as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``66``]:``len``(``"Python"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[66]: 6`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``67``]:``"free"``in``"Python is free and open source."`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[67]: True`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To get access to elements in a list, you refer to them by their position or
    index—that’s not always practical. Dictionaries, the topic of the next section,
    allow you to get access to elements via a key (often a name).
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries map keys to values. You will come across key/value combinations
    all the time. The easiest way to create a dictionary is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{``key1``:``value1``,``key2``:``value2``,``...``}`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'While lists allow you to access elements by index, i.e., position, dictionaries
    allow you to access elements by key. As with indices, keys are accessed via square
    brackets. The following code samples will use a currency pair (key) that maps
    to the exchange rate (value):'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``68``]:``exchange_rates``=``{``"EURUSD"``:``1.1152``,``"GBPUSD"``:``1.2454``,``"AUDUSD"``:``0.6161``}`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``69``]:``exchange_rates``[``"EURUSD"``]``# Access the EURUSD exchange
    rate`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[69]: 1.1152`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following samples show you how to change existing values and add new key/value
    pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``70``]:``exchange_rates``[``"EURUSD"``]``=``1.2``# Change an existing
    value``exchange_rates`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[70]: {''EURUSD'': 1.2, ''GBPUSD'': 1.2454, ''AUDUSD'': 0.6161}`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``71``]:``exchange_rates``[``"CADUSD"``]``=``0.714``# Add a new key/value
    pair``exchange_rates`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[71]: {''EURUSD'': 1.2, ''GBPUSD'': 1.2454, ''AUDUSD'': 0.6161, ''CADUSD'':
    0.714}`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The easiest way to merge two or more dictionaries is by unpacking them into
    a new one. You unpack a dictionary by using two leading asterisks. If the second
    dictionary contains keys from the first one, the values from the first will be
    overridden. You can see this happening by looking at the `GBPUSD` exchange rate:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``72``]:``{``**``exchange_rates``,``**``{``"SGDUSD"``:``0.7004``,``"GBPUSD"``:``1.2222``}}`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[72]: {''EURUSD'': 1.2,           ''GBPUSD'': 1.2222,           ''AUDUSD'':
    0.6161,           ''CADUSD'': 0.714,           ''SGDUSD'': 0.7004}`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Python 3.9 introduced the pipe character as a dedicated merge operator for
    dictionaries, which allows you to simplify the previous expression to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`exchange_rates``|``{``"SGDUSD"``:``0.7004``,``"GBPUSD"``:``1.2222``}`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Many objects can serve as keys; the following is an example with integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``73``]:``currencies``=``{``1``:``"EUR"``,``2``:``"USD"``,``3``:``"AUD"``}`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``74``]:``currencies``[``1``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[74]: ''EUR''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'By using the `get` method, dictionaries allow you to use a default value in
    case the key doesn’t exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``75``]:``# currencies[100] would raise an exception. Instead of 100,``#
    you could use any other non-existing key, too.``currencies``.``get``(``100``,``"N/A"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[75]: ''N/A''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Dictionaries can often be used when you would use a `Case` statement in VBA.
    The previous example could be written like this in VBA:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Select``Case``x``Case``1``Debug``.``Print``"EUR"``Case``2``Debug``.``Print``"USD"``Case``3``Debug``.``Print``"AUD"``Case``Else``Debug``.``Print``"N/A"``End``Select`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now that you know how to work with dictionaries, let’s move on to the next
    data structure: tuples. They are similar to lists with one big difference, as
    we will see in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuples are similar to lists with the difference that they are immutable: once
    created, their elements can’t be changed. While you can often use tuples and lists
    interchangeably, tuples are the obvious choice for a collection that never changes
    throughout the program. Tuples are created by separating values with commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mytuple``=``element1``,``element2``,``...`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Using parentheses often makes it easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``76``]:``currencies``=``(``"EUR"``,``"GBP"``,``"AUD"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Tuples allow you to access elements the same way as lists, but they won’t allow
    you to change elements. Instead, concatenating tuples will create a new tuple
    behind the scenes, then bind your variable to this new tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``77``]:``currencies``[``0``]``# Accessing the first element`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[77]: ''EUR''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``78``]:``# Concatenating tuples will return a new tuple.``currencies``+``(``"SGD"``,)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[78]: (''EUR'', ''GBP'', ''AUD'', ''SGD'')`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'I explain the difference between mutable vs. immutable objects in detail in
    [Appendix C](index_split_031.html#filepos1832059), but for now, let’s have a look
    at the last data structure of this section: sets.'
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets are collections that have no duplicate elements. While you can use them
    for set theory operations, in practice they often help you to get the unique values
    of a list or a tuple. You create sets by using curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{``element1``,``element2``,``...``}`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To get the unique objects in a list or a tuple, use the `set` constructor like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``79``]:``set``([``"USD"``,``"USD"``,``"SGD"``,``"EUR"``,``"USD"``,``"EUR"``])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[79]: {''EUR'', ''SGD'', ''USD''}`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Other than that, you can apply set theory operations like intersection and
    union:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``80``]:``portfolio1``=``{``"USD"``,``"EUR"``,``"SGD"``,``"CHF"``}``portfolio2``=``{``"EUR"``,``"SGD"``,``"CAD"``}`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``81``]:``# Same as portfolio2.union(portfolio1)``portfolio1``.``union``(``portfolio2``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[81]: {''CAD'', ''CHF'', ''EUR'', ''SGD'', ''USD''}`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``82``]:``# Same as portfolio2.intersection(portfolio1)``portfolio1``.``intersection``(``portfolio2``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[82]: {''EUR'', ''SGD''}`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For a full overview of set operations, see the [official docs](https://oreil.ly/ju4ed).
    Before moving on, let’s quickly revise the four data structures we just met in
    [Table 3-1](#filepos299969). It shows a sample for each data structure in the
    notation I used in the previous paragraphs, the so-called literals. Additionally,
    I am also listing their constructors that offer an alternative to using the literals
    and are often used to convert from one data structure to another. For example,
    to convert a tuple to a list, do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``83``]:``currencies``=``"USD"``,``"EUR"``,``"CHF"``currencies`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[83]: (''USD'', ''EUR'', ''CHF'')`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``84``]:``list``(``currencies``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[84]: [''USD'', ''EUR'', ''CHF'']`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Table 3-1\. Data structures
  prefs: []
  type: TYPE_NORMAL
- en: '|  Data Structure  |  Literals  |  Constructor  |'
  prefs: []
  type: TYPE_TB
- en: '|  List  |   `[1, 2, 3]` |   `list((1, 2, 3))` |'
  prefs: []
  type: TYPE_TB
- en: '|  Dictionary  |   `{"a": 1, "b": 2}` |   `dict(a=1, b=2)` |'
  prefs: []
  type: TYPE_TB
- en: '|  Tuple  |   `(1, 2, 3)` |   `tuple([1, 2, 3])` |'
  prefs: []
  type: TYPE_TB
- en: '|  Set  |   `{1, 2, 3}` |   `set((1, 2, 3))` |'
  prefs: []
  type: TYPE_TB
- en: At this point, you know all important data types including basic ones like floats
    and strings, and data structures like lists and dictionaries. In the next section,
    we move on to control flow.
  prefs: []
  type: TYPE_NORMAL
- en: Control Flow
  prefs: []
  type: TYPE_NORMAL
- en: 'This section presents the `if` statement as well as the `for` and `while` loops.
    The `if` statement allows you to execute certain lines of code only if a condition
    is met, and the `for` and `while` loops will execute a block of code repeatedly.
    At the end of the section, I will also introduce list comprehensions, which are
    a way to construct lists that can serve as an alternative to `for` loops. I will
    start this section with the definition of code blocks, for which I also need to
    introduce one of Python’s most noteworthy particularities: significant white space.'
  prefs: []
  type: TYPE_NORMAL
- en: Code Blocks and the pass Statement
  prefs: []
  type: TYPE_NORMAL
- en: 'A code block defines a section in your source code that is used for something
    special. For example, you use a code block to define the lines over which your
    program is looping or it makes up the definition of a function. In Python, you
    define code blocks by indenting them, not by using keywords like in VBA or curly
    braces like in most other languages. This is referred to as significant white
    space. The Python community has settled on four spaces as indentation, but you
    usually type them in by hitting the Tab key: both Jupyter notebooks and VS Code
    will automatically convert your Tab key into four spaces. Let me show you how
    code blocks are formally defined by using the `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if``condition``:``pass``# Do nothing`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The line preceding the code block always terminates with a colon. Since the
    end of the code block is reached when you no longer indent the line, you need
    to use the `pass` statement if you want to create a dummy code block that does
    nothing. In VBA, this would correspond to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`If``condition``Then``'' Do nothing``End``If`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that you know how to define code blocks, let’s start using them in the next
    section, where I will properly introduce the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: The if Statement and Conditional Expressions
  prefs: []
  type: TYPE_NORMAL
- en: 'To introduce the `if` statement, let me reproduce the example from [“Readability
    and Maintainability”](index_split_007.html#filepos64265) in [Chapter 1](index_split_007.html#filepos32075),
    but this time in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``85``]:``i``=``20``if``i``<``5``:``print``(``"i is smaller than 5"``)``elif``i``<=``10``:``print``(``"i
    is between 5 and 10"``)``else``:``print``(``"i is bigger than 10"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`i is bigger than 10`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you would do the same as we did in [Chapter 1](index_split_007.html#filepos32075),
    i.e., indent the `elif` and `else` statements, you would get a `SyntaxError`.
    Python won’t let you indent your code differently from the logic. Compared to
    VBA, the keywords are lowercase and instead of `ElseIf` in VBA, Python uses `elif`.
    `if` statements are an easy way to tell if a programmer is new to Python or if
    they have already adopted a Pythonic style: in Python, a simple `if` statement
    doesn’t require any parentheses around it and to test if a value is `True`, you
    don’t need to do that explicitly. Here is what I mean by that:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``86``]:``is_important``=``True``if``is_important``:``print``(``"This
    is important."``)``else``:``print``(``"This is not important."``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`This is important.`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The same works if you want to check if a sequence like a list is empty or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``87``]:``values``=``[]``if``values``:``print``(``f``"The following values
    were provided: {values}"``)``else``:``print``(``"There were no values provided."``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`There were no values provided.`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Programmers coming from other languages would often write something like `if
    (is_important == True)` or `if len(values) > 0` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conditional expressions, also called ternary operators, allow you to use a
    more compact style for simple `if`/`else` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``88``]:``is_important``=``False``print``(``"important"``)``if``is_important``else``print``(``"not
    important"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`not important`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With `if` statements and conditional expressions in our pocket, let’s turn our
    attention to `for` and `while` loops in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The for and while Loops
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to do something repeatedly like printing the value of ten different
    variables, you are doing yourself a big favor by not copy/pasting the print statement
    ten times. Instead, use a `for` loop to do the work for you. `for` loops iterate
    over the items of a sequence like a list, a tuple, or a string (remember, strings
    are sequences of characters). As an introductory example, let’s create a `for`
    loop that takes each element of the `currencies` list, assigns it to the variable
    `currency` and prints it—one after another until there are no more elements in
    the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``89``]:``currencies``=``[``"USD"``,``"HKD"``,``"AUD"``]``for``currency``in``currencies``:``print``(``currency``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`USD HKD AUD`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As a side note, VBA’s `For Each` statement is close to how Python’s `for` loop
    works. The previous example could be written like this in VBA:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dim``currencies``As``Variant``Dim``curr``As``Variant``''currency is a reserved
    word in VBA``currencies``=``Array``(``"USD"``,``"HKD"``,``"AUD"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`For``Each``curr``In``currencies``Debug``.``Print``curr``Next`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In Python, if you need a counter variable in a `for` loop, the `range` or `enumerate`
    built-ins can help you with that. Let’s first look at `range`, which provides
    a sequence of numbers: you call it by either providing a single `stop` argument
    or by providing a `start` and `stop` argument, with an optional `step` argument.
    Like with slicing, `start` is inclusive, `stop` is exclusive, and `step` determines
    the step size, with `1` being the default:'
  prefs: []
  type: TYPE_NORMAL
- en: '`range``(``stop``)``range``(``start``,``stop``,``step``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`range` evaluates lazily, which means that without explicitly asking for it,
    you won’t see the sequence it generates:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``90``]:``range``(``5``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[90]: range(0, 5)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Converting the range to a list solves this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``91``]:``list``(``range``(``5``))``# stop argument`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[91]: [0, 1, 2, 3, 4]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``92``]:``list``(``range``(``2``,``5``,``2``))``# start, stop, step arguments`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[92]: [2, 4]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Most of the time, there’s no need to wrap `range` with a `list`, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``93``]:``for``i``in``range``(``3``):``print``(``i``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`0 1 2`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you need a counter variable while looping over a sequence, use `enumerate`.
    It returns a sequence of `(index, element)` tuples. By default, the index starts
    at zero and increments by one. You can use `enumarate` in a loop like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``94``]:``for``i``,``currency``in``enumerate``(``currencies``):``print``(``i``,``currency``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`0 USD 1 HKD 2 AUD`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Looping over tuples and sets works the same as with lists. When you loop over
    dictionaries, Python will loop over the keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``95``]:``exchange_rates``=``{``"EURUSD"``:``1.1152``,``"GBPUSD"``:``1.2454``,``"AUDUSD"``:``0.6161``}``for``currency_pair``in``exchange_rates``:``print``(``currency_pair``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`EURUSD GBPUSD AUDUSD`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'By using the `items` method, you get the key and the value at the same time
    as tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``96``]:``for``currency_pair``,``exchange_rate``in``exchange_rates``.``items``():``print``(``currency_pair``,``exchange_rate``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`EURUSD 1.1152 GBPUSD 1.2454 AUDUSD 0.6161`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To exit a loop, use the `break` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``97``]:``for``i``in``range``(``15``):``if``i``==``2``:``break``else``:``print``(``i``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`0 1`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You skip the remainder of a loop with the `continue` statement, which means
    that execution continues with a new loop and the next element:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``98``]:``for``i``in``range``(``4``):``if``i``==``2``:``continue``else``:``print``(``i``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`0 1 3`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'When comparing for loops in VBA with Python, there is a subtle difference:
    in VBA, the counter variable increases beyond your upper limit after finishing
    the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '`For``i``=``1``To``3``Debug``.``Print``i``Next``i``Debug``.``Print``i`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This prints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1 2 3 4`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In Python, it behaves like you would probably expect it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``99``]:``for``i``in``range``(``1``,``4``):``print``(``i``)``print``(``i``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`1 2 3 3`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Instead of looping over a sequence, you can also use while loops to run a loop
    while a certain condition is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``100``]:``n``=``0``while``n``<=``2``:``print``(``n``)``n``+=``1`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`0 1 2`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: AUGMENTED ASSIGNMENT
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'I have used the augmented assignment notation in the last example: `n += 1`.
    This is the same as if you would write `n = n + 1`. It also works with all the
    other mathematical operators that I’ve introduced earlier on; for example, for
    minus you could write `n -= 1`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Quite often, you will need to collect certain elements in a list for further
    processing. In this case, Python offers an alternative to writing loops: list,
    dictionary, and set comprehensions.'
  prefs: []
  type: TYPE_NORMAL
- en: List, Dictionary, and Set Comprehensions
  prefs: []
  type: TYPE_NORMAL
- en: 'List, dictionary, and set comprehensions are technically a way to create the
    respective data structure, but they often replace a `for` loop, which is why I
    am introducing them here. Assume that in the following list of USD currency pairs,
    you’d like to pick out those currencies where USD is quoted as the second currency.
    You could write the following `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``101``]:``currency_pairs``=``[``"USDJPY"``,``"USDGBP"``,``"USDCHF"``,``"USDCAD"``,``"AUDUSD"``,``"NZDUSD"``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``102``]:``usd_quote``=``[]``for``pair``in``currency_pairs``:``if``pair``[``3``:]``==``"USD"``:``usd_quote``.``append``(``pair``[:``3``])``usd_quote`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[102]: [''AUD'', ''NZD'']`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This is often easier to write with a list comprehension. A list comprehension
    is a concise way of creating a list. You can grab its syntax from this example,
    which does the same as the previous `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``103``]:``[``pair``[:``3``]``for``pair``in``currency_pairs``if``pair``[``3``:]``==``"USD"``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[103]: [''AUD'', ''NZD'']`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you don’t have any condition to satisfy, simply leave the `if` part away.
    For example, to invert all the currency pairs so that the first currency comes
    second and vice versa, you would do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``104``]:``[``pair``[``3``:]``+``pair``[:``3``]``for``pair``in``currency_pairs``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[104]: [''JPYUSD'', ''GBPUSD'', ''CHFUSD'', ''CADUSD'', ''USDAUD'', ''USDNZD'']`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'With dictionaries, there are dictionary comprehensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``105``]:``exchange_rates``=``{``"EURUSD"``:``1.1152``,``"GBPUSD"``:``1.2454``,``"AUDUSD"``:``0.6161``}``{``k``:``v``*``100``for``(``k``,``v``)``in``exchange_rates``.``items``()}`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[105]: {''EURUSD'': 111.52, ''GBPUSD'': 124.54, ''AUDUSD'': 61.61}`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'And with sets, there are set comprehensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``106``]:``{``s``+``"USD"``for``s``in``[``"EUR"``,``"GBP"``,``"EUR"``,``"HKD"``,``"HKD"``]}`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[106]: {''EURUSD'', ''GBPUSD'', ''HKDUSD''}`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At this point, you are already able to write simple scripts, as you know most
    of the basic building blocks of Python. In the next section, you will learn how
    to organize your code to keep it maintainable when your scripts start to get bigger.
  prefs: []
  type: TYPE_NORMAL
- en: Code Organization
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll look into how to bring code into a maintainable structure:
    I’ll start by introducing functions with all the details that you will commonly
    need before I’ll show you how to split your code into different Python modules.
    The knowledge about modules will allow us to finish this section by looking into
    the `datetime` module that is part of the standard library.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if you will use Python for simple scripts only, you are still going to
    write functions regularly: they are one of the most important constructs of every
    programming language and allow you to reuse the same lines of code from anywhere
    in your program. We’ll start this section by defining a function before we see
    how to call it!'
  prefs: []
  type: TYPE_NORMAL
- en: Defining functions
  prefs: []
  type: TYPE_NORMAL
- en: 'To write your own function in Python, you have to use the keyword `def`, which
    stands for function definition. Unlike VBA, Python doesn’t differentiate between
    a function and a Sub procedure. In Python, the equivalent of a Sub procedure is
    simply a function that doesn’t return anything. Functions in Python follow the
    syntax for code blocks, i.e., you end the first line with a colon and indent the
    body of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def``function_name``(``required_argument``,``optional_argument``=``default_value``,``...``):``return``value1``,``value2``,``...`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Required arguments
  prefs: []
  type: TYPE_NORMAL
- en: Required arguments do not have a default value. Multiple arguments are separated
    by commas.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Optional arguments
  prefs: []
  type: TYPE_NORMAL
- en: You make an argument optional by supplying a default value. `None` is often
    used to make an argument optional if there is no meaningful default.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Return value
  prefs: []
  type: TYPE_NORMAL
- en: The `return` statement defines the value that the function returns. If you leave
    it away, the function automatically returns `None`. Python conveniently allows
    you to return multiple values separated by commas.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To be able to play around with a function, let’s define one that is able to
    convert the temperature from Fahrenheit or Kelvin to degrees Celsius:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``107``]:``def``convert_to_celsius``(``degrees``,``source``=``"fahrenheit"``):``if``source``.``lower``()``==``"fahrenheit"``:``return``(``degrees``-``32``)``*``(``5``/``9``)``elif``source``.``lower``()``==``"kelvin"``:``return``degrees``-``273.15``else``:``return``f``"Don''t
    know how to convert from {source}"`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I am using the string method `lower`, which transforms the provided strings
    to lowercase. This allows us to accept the `source` string with any capitalization
    while the comparison will still work. With the `convert_to_celsius` function defined,
    let’s see how we can call it!
  prefs: []
  type: TYPE_NORMAL
- en: Calling functions
  prefs: []
  type: TYPE_NORMAL
- en: 'As briefly mentioned at the beginning of this chapter, you call a function
    by adding parentheses to the function name, enclosing the function arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`value1``,``value2``,``...``=``function_name``(``positional_arg``,``arg_name``=``value``,``...``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Positional arguments
  prefs: []
  type: TYPE_NORMAL
- en: If you provide a value as a positional argument (`positional_arg`), the values
    are matched to the arguments according to their position in the function definition.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Keyword arguments
  prefs: []
  type: TYPE_NORMAL
- en: 'By providing the argument in the form `arg_name=value`, you’re providing a
    keyword argument. This has the advantage that you can provide the arguments in
    any order. It is also more explicit to the reader and can make it easier to understand.
    For example, if the function is defined as `f(a, b)`, you could call the function
    like this: `f(b=1, a=2)`. This concept also exists in VBA, where you could use
    keyword arguments by calling a function like this: `f(b:=1, a:=1)`.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let’s play around with the `convert_to_celsius` function to see how this all
    works in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``108``]:``convert_to_celsius``(``100``,``"fahrenheit"``)``# Positional
    arguments`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[108]: 37.77777777777778`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``109``]:``convert_to_celsius``(``50``)``# Will use the default source
    (fahrenheit)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[109]: 10.0`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``110``]:``convert_to_celsius``(``source``=``"kelvin"``,``degrees``=``0``)``#
    Keyword arguments`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[110]: -273.15`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that you know how to define and call functions, let’s see how to organize
    them with the help of modules.
  prefs: []
  type: TYPE_NORMAL
- en: Modules and the import Statement
  prefs: []
  type: TYPE_NORMAL
- en: When you write code for bigger projects, you will have to split it into different
    files at some point to be able to bring it into a maintainable structure. As we
    have already seen in the previous chapter, Python files have the extension .py
    and you usually refer to your main file as a script. If you now want your main
    script to access functionality from other files, you need to import that functionality
    first. In this context, Python source files are called modules. To get a better
    feeling for how this works and what the different import options are, have a look
    at the file temperature.py in the companion repository by opening it with VS Code
    ([Example 3-1](#filepos377335)). If you need a refresher on how to open files
    in VS Code, have another look at [Chapter 2](index_split_008.html#filepos96824).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-1\. temperature.py
  prefs: []
  type: TYPE_NORMAL
- en: '`TEMPERATURE_SCALES``=``(``"fahrenheit"``,``"kelvin"``,``"celsius"``)``def``convert_to_celsius``(``degrees``,``source``=``"fahrenheit"``):``if``source``.``lower``()``==``"fahrenheit"``:``return``(``degrees``-``32``)``*``(``5``/``9``)``elif``source``.``lower``()``==``"kelvin"``:``return``degrees``-``273.15``else``:``return``f``"Don''t
    know how to convert from {source}"``print``(``"This is the temperature module."``)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to import the `temperature` module from your Jupyter notebook, you
    will need the Jupyter notebook and the `temperature` module to be in the same
    directory—as it is in the case of the companion repository. To import, you only
    use the name of the module, without the .py ending. After running the `import`
    statement, you will have access to all the objects in that Python module via the
    dot notation. For example, use `temperature.convert_to_celsius()` to perform your
    conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``111``]:``import``temperature`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`This is the temperature module.`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``112``]:``temperature``.``TEMPERATURE_SCALES`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[112]: (''fahrenheit'', ''kelvin'', ''celsius'')`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``113``]:``temperature``.``convert_to_celsius``(``120``,``"fahrenheit"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[113]: 48.88888888888889`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that I used uppercase letters for `TEMPERATURE_SCALES` to express that
    it is a constant—I will say more about that toward the end of this chapter. When
    you execute the cell with `import temperature`, Python will run the temperature.py
    file from top to bottom. You can easily see this happening since importing the
    module will fire the print function at the bottom of temperature.py.
  prefs: []
  type: TYPE_NORMAL
- en: MODULES ARE ONLY IMPORTED ONCE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you run the `import temperature` cell again, you will notice that it does
    not print anything anymore. This is because Python modules are only imported once
    per session. If you change code in a module that you import, you need to restart
    your Python interpreter to pick up all the changes, i.e., in a Jupyter notebook,
    you’d have to click on Kernel > Restart.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In reality, you usually don’t print anything in modules. This was only to show
    you the effect of importing a module more than once. Most commonly, you put functions
    and classes in your modules (for more on classes, see [Appendix C](index_split_031.html#filepos1832059)).
    If you don’t want to type `temperature` every time you use an object from the
    temperature module, change the `import` statement like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``114``]:``import``temperature``as``tp`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``115``]:``tp``.``TEMPERATURE_SCALES`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[115]: (''fahrenheit'', ''kelvin'', ''celsius'')`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Assigning a short alias `tp` to your module can make it easier to use while
    it’s still always clear where an object comes from. Many third-party packages
    suggest a specific convention when using an alias. For example, pandas is using
    `import pandas as pd`. There is one more option to import objects from another
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``116``]:``from``temperature``import``TEMPERATURE_SCALES``,``convert_to_celsius`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``117``]:``TEMPERATURE_SCALES`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[117]: (''fahrenheit'', ''kelvin'', ''celsius'')`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: THE __PYCACHE__ FOLDER
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When you import the `temperature` module, you will see that Python creates a
    folder called __pycache__ with files that have the .pyc extension. These are bytecode-compiled
    files that the Python interpreter creates when you import a module. For our purposes,
    we can simply ignore this folder, as it is a technical detail of how Python runs
    your code.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'When using the `from x import y` syntax, you import specific objects only.
    By doing this, you are importing them directly into the namespace of your main
    script: that is, without looking at the `import` statements, you won’t be able
    to tell whether the imported objects were defined in your current Python script
    or Jupyter notebook or if they come from another module. This could cause conflicts:
    if your main script has a function called `convert_to_celsius`, it would override
    the one that you are importing from the `temperature` module. If, however, you
    use one of the two previous methods, your local function and the one from the
    imported module could live next to each other as `convert_to_celsius` and `temperature.convert_to_celsius`.'
  prefs: []
  type: TYPE_NORMAL
- en: DON’T NAME YOUR SCRIPTS LIKE EXISTING PACKAGES
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A common source for errors is to name your Python file the same as an existing
    Python package or module. If you create a file to test out some pandas functionality,
    don’t call that file pandas.py, as this can cause conflicts.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that you know how the import mechanism works, let’s use it right away to
    import the `datetime` module! This will also allow you to learn a few more things
    about objects and classes.
  prefs: []
  type: TYPE_NORMAL
- en: The datetime Class
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with date and time is a common operation in Excel, but it comes with
    limitations: for example, Excel’s cell format for time doesn’t support smaller
    units than milliseconds and time zones are not supported at all. In Excel, date
    and time are stored as a simple float called the date serial number. The Excel
    cell is then formatted to display it as date and/or time. For example, January
    1, 1900 has the date serial number of 1, which means that this is also the earliest
    date that you can work with in Excel. Time gets translated into the decimal part
    of the float, e.g., `01/01/1900 10:10:00` is represented by `1.4236111111`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, to work with date and time, you import the `datetime` module, which
    is part of the standard library. The `datetime` module contains a class with the
    same name that allows us to create `datetime` objects. Since having the same name
    for the module and the class can be confusing, I will use the following import
    convention throughout this book: `import datetime as dt`. This makes it easy to
    differentiate between the module (`dt`) and the class (`datetime`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Up to this point, we were most of the time using literals to create objects
    like lists or dictionaries. Literals refer to the syntax that Python recognizes
    as a specific object type—in the case of a list, this would be something like
    `[1, 2, 3]`. However, most of the objects have to be created by calling their
    class: this process is called instantiation, and objects are therefore also called
    class instances. Calling a class works the same way as calling a function, i.e.,
    you add parentheses to the class name and provide the arguments in the same way
    we did with functions. To instantiate a `datetime` object, you need to call the
    class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import``datetime``as``dt``dt``.``datetime``(``year``,``month``,``day``,``hour``,``minute``,``second``,``microsecond``,``timezone``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let’s go through a couple of examples to see how you work with `datetime` objects
    in Python. For the purpose of this introduction, let’s ignore time zones and work
    with time-zone-naive `datetime` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``118``]:``# Import the datetime module as "dt"``import``datetime``as``dt`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``119``]:``# Instantiate a datetime object called "timestamp"``timestamp``=``dt``.``datetime``(``2020``,``1``,``31``,``14``,``30``)``timestamp`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[119]: datetime.datetime(2020, 1, 31, 14, 30)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``120``]:``# Datetime objects offer various attributes, e.g., to get
    the day``timestamp``.``day`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[120]: 31`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``121``]:``# The difference of two datetime objects returns a timedelta
    object``timestamp``-``dt``.``datetime``(``2020``,``1``,``14``,``12``,``0``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[121]: datetime.timedelta(days=17, seconds=9000)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``122``]:``# Accordingly, you can also work with timedelta objects``timestamp``+``dt``.``timedelta``(``days``=``1``,``hours``=``4``,``minutes``=``11``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[122]: datetime.datetime(2020, 2, 1, 18, 41)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To format `datetime` objects into strings, use the `strftime` method, and to
    parse a string and convert it into a `datetime` object, use the `strptime` function
    (you can find an overview of the accepted format codes in the [datetime docs](https://oreil.ly/gXOts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``123``]:``# Format a datetime object in a specific way``# You could
    also use an f-string: f"{timestamp:%d/%m/%Y %H:%M}"``timestamp``.``strftime``(``"``%d``/``%m``/``%Y``%H``:``%M``"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[123]: ''31/01/2020 14:30''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``124``]:``# Parse a string into a datetime object``dt``.``datetime``.``strptime``(``"12.1.2020"``,``"``%d``.``%m``.``%Y``"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[124]: datetime.datetime(2020, 1, 12, 0, 0)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After this short introduction to the `datetime` module, let’s move on to the
    last topic of this chapter, which is about formatting your code properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'PEP 8: Style Guide for Python Code'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have been wondering why I was sometimes using variable names with underscores
    or in all caps. This section will explain my formatting choices by introducing
    you to Python’s official style guide. Python uses so-called Python Enhancement
    Proposals (PEP) to discuss the introduction of new language features. One of these,
    the Style Guide for Python Code, is usually referred to by its number: PEP 8\.
    PEP 8 is a set of style recommendations for the Python community; if everybody
    who works on the same code adheres to the same style guide, the code becomes much
    more readable. This is especially important in the world of open source where
    many programmers work on the same project, often without knowing each other personally.
    [Example 3-2](#filepos410016) shows a short Python file that introduces the most
    important conventions.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-2\. pep8_sample.py
  prefs: []
  type: TYPE_NORMAL
- en: '`"""This script shows a few PEP 8 rules.` ![](images/00031.jpg) `"""``import``datetime``as``dt`![](images/00039.jpg)`TEMPERATURE_SCALES``=``(``"fahrenheit"``,``"kelvin"``,``"celsius"``)`![](images/00050.jpg)![](images/00067.jpg)`class``TemperatureConverter``:`![](images/00058.jpg)`pass``#
    Doesn''t do anything at the moment` ![](images/00082.jpg)`def``convert_to_celsius``(``degrees``,``source``=``"fahrenheit"``):`![](images/00076.jpg)`"""This
    function converts degrees Fahrenheit or Kelvin     into degrees Celsius.` ![](images/00007.jpg)
    `"""``if``source``.``lower``()``==``"fahrenheit"``:`![](images/00015.jpg)`return``(``degrees``-``32``)``*``(``5``/``9``)`![](images/00020.jpg)`elif``source``.``lower``()``==``"kelvin"``:``return``degrees``-``273.15``else``:``return``f``"Don''t
    know how to convert from {source}"``celsius``=``convert_to_celsius``(``44``,``source``=``"fahrenheit"``)`![](images/00025.jpg)`non_celsius_scales``=``TEMPERATURE_SCALES``[:``-``1``]`![](images/00034.jpg)`print``(``"Current
    time: "``+``dt``.``datetime``.``now``()``.``isoformat``())``print``(``f``"The
    temperature in Celsius is: {celsius}"``)`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/00031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Explain what the script/module does with a docstring at the top. A docstring
    is a special type of string, enclosed with triple quotes. Apart from serving as
    a string for documenting your code, a docstring also makes it easy to write strings
    over multiple lines and is useful if your text contains a lot of double-quotes
    or single-quotes, as you won’t need to escape them. They are also useful to write
    multiline SQL queries, as we will see in [Chapter 11](index_split_027.html#filepos1487255).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All imports are at the top of the file, one per line. List the imports of the
    standard library first, then those of third-party packages, and finally those
    from your own modules. This sample only makes use of the standard library.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Use capital letters with underscores for constants. Use a maximum line length
    of 79 characters. If possible, take advantage of parentheses, square brackets,
    or curly braces for implicit line breaks.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Separate classes and functions with two empty lines from the rest of the code.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Despite the fact that many classes like `datetime` are all lowercase, your own
    classes should use `CapitalizedWords` as names. For more on classes, see [Appendix C](index_split_031.html#filepos1832059).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Inline comments should be separated by at least two spaces from the code. Code
    blocks should be indented by four spaces.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00076.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Functions and function arguments should use lowercase names with underscores
    if they improve readability. Don’t use spaces between the argument name and its
    default value.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A function’s docstring should also list and explain the function arguments.
    I haven’t done this here to keep the sample short, but you will find complete
    docstrings in the excel.py file that is included in the companion repository and
    that we will meet in [Chapter 8](index_split_020.html#filepos959867).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Don’t use spaces around the colon.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Use spaces around mathematical operators. If operators with different priorities
    are used, you may consider adding spaces around those with the lowest priority
    only. Since the multiplication in this example has the lowest priority, I have
    added spaces around it.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Use lowercase names for variables. Make use of underscores if they improve readability.
    When assigning a variable name, use spaces around the equal sign. However, when
    calling a function, don’t use spaces around the equal sign used with keyword arguments.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With indexing and slicing, don’t use spaces around the square brackets.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is a simplified summary of PEP 8, so it’s a good idea to have a look at
    the original [PEP 8](https://oreil.ly/3fTTZ) once you start to get more serious
    with Python. PEP 8 clearly states that it is a recommendation and that your own
    style guides will take precedence. After all, consistency is the most important
    factor. If you are interested in other publicly available guidelines, you may
    want to have a look at [Google’s style guide for Python](https://oreil.ly/6sYSa),
    which is reasonably close to PEP 8\. In practice, most Python programmers loosely
    adhere to PEP 8, and ignoring the maximum line length of 79 characters is probably
    the most common sin.
  prefs: []
  type: TYPE_NORMAL
- en: Since it might be difficult to format your code properly while writing it, you
    can have your style checked automatically. The next section shows you how this
    works with VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: PEP 8 and VS Code
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with VS Code, there is an easy way to make sure your code sticks
    to PEP 8: use a linter. A linter checks your source code for syntax and style
    errors. Fire up the command palette (Ctrl+Shift+P on Windows or Command-Shift-P
    on macOS) and search for Python: Select Linter. A popular option is flake8, a
    package that comes preinstalled with Anaconda. If enabled, VS Code will underline
    issues with squiggly lines every time you save your file. Hovering over such a
    squiggly line will give you an explanation in a tooltip. You switch a linter off
    again by searching for “Python: Enable Linting” in the command palette and choosing
    “Disable Linting.” If you prefer, you can also run `flake8` on an Anaconda Prompt
    to have a report printed (the command only prints something if there is a violation
    of PEP 8, so running this on pep8_sample.py won’t print anything unless you introduce
    a violation):'
  prefs: []
  type: TYPE_NORMAL
- en: '`(base)>` `cd C:\Users\``username``\python-for-excel` `(base)>` `flake8 pep8_sample.py`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Python has recently taken static code analysis a step further by adding support
    for type hints. The next section explains how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Type Hints
  prefs: []
  type: TYPE_NORMAL
- en: 'In VBA, you often see code that prefixes each variable with an abbreviation
    for the data type, like `strEmployeeName` or `wbWorkbookName`. While nobody will
    stop you from doing this in Python, it isn’t commonly done. You also won’t find
    an equivalent to VBA’s `Option Explicit` or `Dim` statement to declare the type
    of a variable. Instead, Python 3.5 introduced a feature called type hints. Type
    hints are also referred to as type annotations and allow you to declare the data
    type of a variable. They are completely optional and have no effect on how the
    code is run by the Python interpreter (there are, however, third-party packages
    like [pydantic](https://oreil.ly/J9W8h) that can enforce type hints at runtime).
    The main purpose of type hints is to allow text editors like VS Code to catch
    more errors before running the code, but they can also improve code autocompletion
    of VS Code and other editors. The most popular type checker for type annotated
    code is mypy, which VS Code offers as a linter. To get a feeling of how type annotations
    work in Python, here is a short sample without type hints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x``=``1``def``hello``(``name``):``return``f``"Hello {name}!"`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'And again with type hints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x``:``int``=``1``def``hello``(``name``:``str``)``->``str``:``return``f``"Hello
    {name}!"`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As type hints generally make more sense in bigger codebases, I am not going
    to use them in the remainder of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter was a packed introduction to Python. We met the most important
    building blocks of the language, including data structures, functions, and modules.
    We also touched on some of Python’s particularities like meaningful white space
    and code formatting guidelines, better known as PEP 8\. To continue with this
    book, you won’t need to know all the details: as a beginner, just knowing about
    lists and dictionaries, indexing and slicing, as well as how to work with functions,
    modules, `for` loops, and `if` statements will get you far already.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to VBA, I find Python more consistent and powerful but at the same
    time easier to learn. If you are a VBA die-hard fan and this chapter didn’t convince
    you just yet, I am pretty sure the next part will: there, I will give you an introduction
    to array-based calculations before starting our data analysis journey with the
    pandas library. Let’s get started with [Part II](index_split_013.html#filepos433190)
    by learning a few basics about NumPy!'
  prefs: []
  type: TYPE_NORMAL
