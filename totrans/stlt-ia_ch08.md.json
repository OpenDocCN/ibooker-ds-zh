["```py\n>>> from openai import OpenAI\n```", "```py\n>>> client = OpenAI(api_key='sk-proj-...')\n```", "```py\n>>> messages = [\n...     {'role': 'system', 'content': 'You are a helpful programming assistant'},\n...     {'role': 'user', 'content': 'Explain what Streamlit is in 10 words or fewer'}\n... ]\n\n```", "```py\ncompletion = client.chat.completions.create(model='gpt-4o-mini', messages=messages)\n```", "```py\n>>> completion.choices[0].message.content\n'Streamlit is a framework for building interactive web applications easily.'\n```", "```py\nfrom openai import OpenAI\n\nclass Llm:\n  def __init__(self, api_key):\n    self.client = OpenAI(api_key=api_key)\n\n  @staticmethod\n  def construct_messages(user_msg, sys_msg=None):\n    messages = []\n    if sys_msg:\n      messages.append({\"role\": \"system\", \"content\": sys_msg})\n    messages.append({\"role\": \"user\", \"content\": user_msg})\n    return messages\n\n  def ask(self, user_msg, sys_msg=None):\n    messages = self.construct_messages(user_msg, sys_msg)\n    completion = self.client.chat.completions.create(\n      model=\"gpt-4o-mini\",\n      messages=messages\n    )\n    return completion.choices[0].message.content\n```", "```py\nfrom llm import Llm\n\nclass Game:\n  def __init__(self, llm_api_key):\n    self.llm = Llm(llm_api_key)\n\n  def ask_llm_for_question(self):\n    return self.llm.ask(\n      'Ask a trivia question. Do not provide choices or the answer.',\n      'You are a quizmaster.'\n    )\n```", "```py\nllm_api_key = \"sk-proj-...\"    #A\n```", "```py\nimport streamlit as st\nfrom game import Game\n\ngame = Game(st.secrets['llm_api_key'])\n\nquestion = game.ask_llm_for_question()\nst.container(border=True).write(question)\n```", "```py\nst.container(border=True).write(question)\n```", "```py\nfrom pydantic import BaseModel\n\nclass AnswerEvaluation(BaseModel):\n  is_correct: bool\n  correct_answer: str\n```", "```py\nfrom openai import OpenAI\n\nclass Llm:\n  ...\n  def ask(self, user_message, sys_message=None, schema=None):\n    messages = self.construct_messages(user_message, sys_message)\n\n    if schema:\n completion = self.client.beta.chat.completions.parse(\n model=\"gpt-4o-mini\",\n messages=messages,\n response_format=schema\n )\n return completion.choices[0].message.parsed\n    else:\n      completion = self.client.chat.completions.create(\n        model=\"gpt-4o-mini\",\n        messages=messages\n      )\n      return completion.choices[0].message.content\n```", "```py\nQUESTION_PROMPT = {\n  'system': 'You are a quizmaster.',\n  'user': 'Ask a trivia question. Do not provide choices or the answer.'\n}\n\nANSWER_PROMPT = {\n  'system': 'You are an expert quizmaster.',\n  'user': '''\n    You have asked the following question: {question}\n    The player answered the following: {answer}\n\n    Evaluate if the answer provided by the player is close enough\n    to be correct.\n\n    Also, provide the correct answer.\n  '''\n}\n```", "```py\nYou have asked the following question: {question}\nThe player answered the following: {answer}\n```", "```py\nfrom llm import Llm\nfrom prompts import QUESTION_PROMPT, ANSWER_PROMPT\nfrom answer_evaluation import AnswerEvaluation\n\nclass Game:\n  def __init__(self, llm_api_key):\n    self.llm = Llm(llm_api_key)\n\n def ask_llm_for_question(self):\n usr_msg, sys_msg = QUESTION_PROMPT['user'], QUESTION_PROMPT['system']\n return self.llm.ask(usr_msg, sys_msg)\n\n  def ask_llm_to_evaluate_answer(self, question, answer):\n sys_msg = ANSWER_PROMPT['system']\n user_msg = (\n ANSWER_PROMPT['user']\n .replace('{question}', question)\n .replace('{answer}', answer)\n )\n return self.llm.ask(user_msg, sys_msg, AnswerEvaluation)\n```", "```py\nimport streamlit as st\nfrom game import Game\n\ngame = Game(st.secrets['llm_api_key'])\n\nquestion = game.ask_llm_for_question()\nst.container(border=True).write(question)\n\nanswer = st.text_input(\"Enter your answer\")\nif st.button(\"Submit\"):\n evaluation = game.ask_llm_to_evaluate_answer(question, answer)\n if evaluation.is_correct:\n st.success(\"That's correct!\")\n else:\n st.error(\"Sorry, that's incorrect.\")\n st.info(f\"The correct answer was: {evaluation.correct_answer}\")\n```", "```py\nfrom llm import Llm\nfrom prompts import QUESTION_PROMPT, ANSWER_PROMPT\nfrom answer_evaluation import AnswerEvaluation\n\nclass Game:\n  def __init__(self, llm_api_key):\n    self.llm = Llm(llm_api_key)\n    self.status = 'GET_QUESTION'\n\n self.curr_question = None\n self.curr_answer = None\n self.curr_eval = None\n\n  def ask_llm_for_question(self):\n    usr_msg, sys_msg = QUESTION_PROMPT['user'], QUESTION_PROMPT['system']\n    return self.llm.ask(usr_msg, sys_msg)\n\n  def ask_llm_to_evaluate_answer(self):\n    sys_msg = ANSWER_PROMPT['system']\n    user_msg = (\n      ANSWER_PROMPT['user']\n      .replace('{question}', self.curr_question)\n      .replace('{answer}', self.curr_answer)\n    )\n    reply = self.llm.ask(user_msg, sys_msg, AnswerEvaluation)\n    return reply\n\n  def obtain_question(self):\n self.curr_question = self.ask_llm_for_question()\n self.status = 'ASK_QUESTION'\n return self.curr_question\n\n def accept_answer(self, answer):\n self.curr_answer = answer\n self.status = 'EVALUATE_ANSWER'\n\n def evaluate_answer(self):\n self.curr_eval = self.ask_llm_to_evaluate_answer()\n self.status = 'STATE_RESULT'\n```", "```py\nimport streamlit as st\nfrom game import Game\n\nif 'game' not in st.session_state:\n st.session_state.game = Game(st.secrets['llm_api_key'])\ngame = st.session_state.game\n\nif game.status == 'GET_QUESTION':\n with st.spinner('Obtaining question...') as status:\n question = game.obtain_question()\n st.rerun()\n\nelif game.status == 'ASK_QUESTION':\n  st.container(border=True).write(game.curr_question)\n  answer = st.text_input(\"Enter your answer\")\n  if st.button(\"Submit\", type='primary'):\n    game.accept_answer(answer)\n st.rerun()\n\nelif game.status == 'EVALUATE_ANSWER':\n with st.spinner('Evaluating answer...') as status:\n game.evaluate_answer()\n st.rerun()\n\nelif game.status == 'STATE_RESULT':\n  if game.curr_eval.is_correct:\n    st.success(\"That's correct!\")\n  else:\n    st.error(\"Sorry, that's incorrect.\")\n    st.info(f\"The correct answer was: {game.curr_eval.correct_answer}\")\n```", "```py\nif 'game' not in st.session_state:\n  st.session_state.game = Game(st.secrets['llm_api_key'])\ngame = st.session_state.game\n```", "```py\nif game.status == 'GET_QUESTION':\n  with st.spinner('Obtaining question...') as status:\n    question = game.obtain_question()\n    st.rerun()\n```", "```py\n...\nclass Game:\n  def __init__(self, llm_api_key):\n    self.llm = Llm(llm_api_key)\n    ...\n\n    self.score = 0\n\n  ...\n  def evaluate_answer(self):\n    self.curr_eval = self.ask_llm_to_evaluate_answer()\n    if self.curr_eval.is_correct:\n self.score += 1\n    self.status = 'STATE_RESULT'\n```", "```py\n...\nclass Game:\n  def __init__(self, llm_api_key):\n    ...\n    self.score = 0\n    self.num_questions_completed = 0\n self.max_questions = 1\n\n...\n  def evaluate_answer(self):\n    self.curr_eval = self.ask_llm_to_evaluate_answer()\n    self.num_questions_completed += 1\n    if self.curr_eval.is_correct:\n      self.score += 1\n    self.status = 'STATE_RESULT'\n\n  def is_over(self):\n return self.num_questions_completed >= self.max_questions\n```", "```py\nimport streamlit as st\nfrom game import Game\n\ndef start_new_game():\n st.session_state.game = Game(st.secrets['llm_api_key'])\n st.rerun()\n\ndef new_game_button(game):\n if game and not game.is_over():\n button_text, button_type = \"Restart game\", \"secondary\"\n else:\n button_text, button_type = \"Start new game\", \"primary\"\n if st.button(button_text, use_container_width=True, type=button_type):\n start_new_game()\n\ngame = st.session_state.game if 'game' in st.session_state else None\nside_col, main_col = st.columns([2, 3])\nwith side_col:\n st.header(\"⚡ Fact Frenzy\", divider='gray')\n new_game_button(game)\n\nwith main_col:\n if game:\n st.header(\"Question\", divider='gray')\n    if game.status == 'GET_QUESTION':\n      ...\n\n    ...\n    elif game.status == 'STATE_RESULT':\n      if game.curr_eval.is_correct:\n        st.success(\"That's correct!\")\n      else:\n        st.error(\"Sorry, that's incorrect.\")\n        st.info(f\"The correct answer was: {game.curr_eval.correct_answer}\")\n\n      if game.is_over():\n with st.container(border=True):\n st.markdown(f\"Game over! Your final score is: **{game.score}**\")\n```", "```py\ngame = st.session_state.game if 'game' in st.session_state else None\n```", "```py\nside_col, main_col = st.columns([2, 3])\n```", "```py\nwith side_col:\n  st.header(\"⚡ Fact Frenzy\", divider='gray')\n  new_game_button(game)\n```", "```py\ndef new_game_button(game):\n  if game and not game.is_over():\n    button_text, button_type = \"Restart game\", \"secondary\"\n  else:\n    button_text, button_type = \"Start new game\", \"primary\"\n  if st.button(button_text, use_container_width=True, type=button_type):\n    start_new_game()\n```", "```py\ndef start_new_game():\n  st.session_state.game = Game(st.secrets['llm_api_key'])\n  st.rerun()\n```", "```py\nwith main_col:\n  if game:\n    st.header(\"Question\", divider='gray')\n    if game.status == 'GET_QUESTION':\n      ...\n```", "```py\nelif game.status == 'STATE_RESULT':\n      ...\n      if game.is_over():\n        with st.container(border=True):\n          st.markdown(f\"Game over! Your final score is: **{game.score}**\")\n```", "```py\nfrom openai import OpenAI\n\nclass Llm:\n  ...\n\n  def ask(self, user_message, sys_message=None, schema=None,\n          temperature=None, top_p=None):\n    messages = self.construct_messages(user_message, sys_message)\n\n    llm_args = {'model': 'gpt-4o-mini', 'messages': messages}\n if temperature:\n llm_args['temperature'] = temperature\n if top_p:\n llm_args['top_p'] = top_p\n\n if schema:\n completion = self.client.beta.chat.completions.parse(\n response_format=schema,\n **llm_args\n )\n      return completion.choices[0].message.parsed\n    else:\n      completion = self.client.chat.completions.create(**llm_args)\n      return completion.choices[0].message.content\n```", "```py\ncompletion = self.client.beta.chat.completions.parse(\n  response_format=schema,\n  **llm_args\n)\n```", "```py\nQUESTION_PROMPT = {\n  'system': 'You are a quizmaster who never asks the same question twice.',\n  'user': '''\n First think of a unique category for a trivia question.\n Then think of a topic within that category.\n\n Finally, ask a unique trivia question, generated using the random seed\n {seed}, without revealing the category or topic.\n\n Do not provide choices, or reveal the answer.\n\n The following questions have already been asked:\n {already_asked}\n '''\n}\n\nANSWER_PROMPT = {\n  ...\n```", "```py\nimport time\n\nfrom llm import Llm\n...\n\nclass Game:\n  def __init__(self, llm_api_key):\n    ...\n    self.max_questions = 5\n    self.questions = []\n\n  def ask_llm_for_question(self):\n    seed = int(time.time())\n    sys_msg = QUESTION_PROMPT['system']\n usr_msg = (\n QUESTION_PROMPT['user']\n .replace('{already_asked}', '\\n'.join(self.questions))\n .replace('{seed}', str(seed))\n )\n    return self.llm.ask(usr_msg, sys_msg, temperature=0.7, top_p=0.9)\n\n  ...\n  def obtain_question(self):\n    self.curr_question = self.ask_llm_for_question()\n    self.questions.append(self.curr_question)\n    self.status = 'ASK_QUESTION'\n    return self.curr_question\n\n  ...\n  def proceed_to_next_question(self):\n self.status = 'GET_QUESTION'\n\n...\n```", "```py\nself.questions.append(self.curr_question)\n```", "```py\nseed = int(time.time())\n```", "```py\nimport streamlit as st\nfrom game import Game\n\n...\nwith main_col:\n  if game:\n    st.header(\n f\"Question {len(game.questions)} / {game.max_questions}\",\n divider='gray'\n )\n    st.subheader(f\"Score: {game.score}\")\n\n    if game.status == 'GET_QUESTION':\n      ...\n\n    ...\n    elif game.status == 'STATE_RESULT':\n      ...\n      if game.is_over():\n        with st.container(border=True):\n          st.markdown(f\"Game over! Your final score is: **{game.score}**\")\n      else:\n st.button(\n \"Next question\",\n type='primary',\n on_click=lambda: game.proceed_to_next_question()\n )\n```", "```py\nst.header(\n  f\"Question {len(game.questions)} / {game.max_questions}\",\n  divider='gray'\n)\n```", "```py\nst.subheader(f\"Score: {game.score}\")\n```", "```py\nst.button(\n  \"Next question\",\n  type='primary',\n  on_click=lambda: game.proceed_to_next_question()\n)\n```", "```py\nif st.button(\"Next question\", type='primary'):\n  game.proceed_to_next_question()\n  st.rerun()\n```", "```py\n+----------------+------------+\n|   Quizmaster   | Difficulty |\n+----------------+------------+\n| Alex Trebek    | Medium     |\n+----------------+------------+\n```", "```py\nsettings = st.data_editor(default_settings, num_rows='fixed', key='settings_editor')\n```", "```py\nst.data_editor(\n  default_settings,\n  column_config={\n 'Quizmaster': st.column_config.SelectboxColumn(\n options=['Alex Trebek', 'Eminem', 'Gollum'],\n required=True\n ),\n 'Difficulty': st.column_config.SelectboxColumn(\n options=['Easy', 'Medium', 'Difficult'],\n required=True\n )\n },\n  num_rows='fixed',\n  key='settings_editor'\n)\n```", "```py\nimport streamlit as st\n\nQM_OPTIONS = [\"Alex Trebek\", \"Eminem\", \"Gollum\", \"Gruk the Caveman\"]\nDIFFICULTY_OPTIONS = [\"Easy\", \"Medium\", \"Hard\"]\n\ndefault_settings = {\n  \"Quizmaster\": [QM_OPTIONS[0]],\n  \"Difficulty\": [DIFFICULTY_OPTIONS[1]]\n}\n\ndef settings_editor():\n  with st.popover(\"Settings\", use_container_width=True):\n    return st.data_editor(\n      default_settings,\n      key='settings_editor',\n      column_config={\n        'Quizmaster': st.column_config.SelectboxColumn(\n          options=QM_OPTIONS, required=True),\n        'Difficulty': st.column_config.SelectboxColumn(\n          options=DIFFICULTY_OPTIONS, required=True)\n      },\n      num_rows='fixed',\n      use_container_width=True,\n    )\n```", "```py\ndefault_settings = {\n  \"Quizmaster\": [QM_OPTIONS[0]],\n  \"Difficulty\": [DIFFICULTY_OPTIONS[1]]\n}\n```", "```py\nwith st.popover(\"Settings\", use_container_width=True):\n  ...\n```", "```py\nreturn st.data_editor(\n  default_settings,\n  key='settings_editor',\n  column_config={\n    'Quizmaster': st.column_config.SelectboxColumn(\n      options=QM_OPTIONS, required=True),\n    'Difficulty': st.column_config.SelectboxColumn(\n      options=DIFFICULTY_OPTIONS, required=True)\n  },\n  num_rows='fixed',\n  use_container_width=True,\n)\n```", "```py\nQUESTION_PROMPT = {\n  'system': '''\n    You are a quizmaster who mimics the speaking style of {quizmaster} and\n    never asks the same question twice.\n  ''',\n  'user': '''\n    First think of a unique category for a trivia question.\n    Then think of a topic within that category.\n\n    Finally, ask a unique trivia question that has a difficulty rating of\n {difficulty} and is generated using the random seed {seed}, without\n    revealing the category or topic.\n\n    Do not provide choices, or reveal the answer.\n\n    The following questions have already been asked:\n    {already_asked}\n  '''\n}\n...\n```", "```py\n...\nclass Game:\n  def __init__(self, llm_api_key, settings):\n    self.llm = Llm(llm_api_key)\n    self.settings = settings\n    self.status = 'GET_QUESTION'\n    ...\n\n  def get_setting(self, setting_name):\n return self.settings[setting_name][0]\n\n def modify_settings(self, new_settings):\n self.settings = new_settings\n\n  def ask_llm_for_question(self):\n    seed = int(time.time())\n    sys_msg = (\n QUESTION_PROMPT['system']\n .replace('{quizmaster}', self.get_setting('Quizmaster'))\n )\n    usr_msg = (\n      QUESTION_PROMPT['user']\n      .replace('{already_asked}', '\\n'.join(self.questions))\n      .replace('{seed}', str(seed))\n      .replace('{difficulty}', self.get_setting('Difficulty'))\n    )\n    return self.llm.ask(usr_msg, sys_msg)\n\n  def ask_llm_to_evaluate_answer(self):\n    ...\n  ...\n```", "```py\nimport streamlit as st\nfrom game import Game\nfrom settings import default_settings, settings_editor\n\ndef start_new_game():\n  st.session_state.game = Game(st.secrets['llm_api_key'], default_settings)\n  st.rerun()\n\n...\nwith side_col:\n  st.header(\"⚡ Fact Frenzy\", divider='gray')\n  settings = settings_editor()\n  new_game_button(game)\n\nwith main_col:\n  if game:\n    game.modify_settings(settings)\n    st.header(\n      ...\n    ...\n```"]