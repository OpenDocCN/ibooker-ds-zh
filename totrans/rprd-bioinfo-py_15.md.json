["```py\n$ cd 14_orf/\n$ cp solution1_iterate_set.py orf.py\n```", "```py\n$ ./orf.py -h\nusage: orf.py [-h] FILE\n\nOpen Reading Frames\n\npositional arguments:\n  FILE        Input FASTA file\n\noptional arguments:\n  -h, --help  show this help message and exit\n```", "```py\n$ cat tests/inputs/1.fa\n>Rosalind_99\nAGCCATGTAGCTAACTCAGGTTACATGGGGATGACCCCGCGACTTGGATTAGAGTCTCTTTTGGAATAAG\\\nCCTGAATGATCCGAGTAGCATCTCAG\n```", "```py\n$ ./orf.py tests/inputs/1.fa\nM\nMGMTPRLGLESLLE\nMLLGSFRLIPKETLIQVAGSSPCNLS\nMTPRLGLESLLE\n```", "```py\n$ new.py -fp 'Open Reading Frames' orf.py\nDone, see new script \"orf.py\".\n```", "```py\nclass Args(NamedTuple):\n    \"\"\" Command-line arguments \"\"\"\n    file: TextIO\n\ndef get_args() -> Args:\n    \"\"\" Get command-line arguments \"\"\"\n\n    parser = argparse.ArgumentParser(\n        description='Open Reading Frames',\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n\n    parser.add_argument('file', ![1](assets/1.png)\n                        help='Input FASTA file',\n                        metavar='FILE',\n                        type=argparse.FileType('rt'))\n\n    args = parser.parse_args()\n\n    return Args(args.file)\n```", "```py\ndef main() -> None:\n    args = get_args()\n    print(args.file.name)\n```", "```py\n$ ./orf.py tests/inputs/1.fa\ntests/inputs/1.fa\n```", "```py\ndef main() -> None:\n    args = get_args()\n\n    # Iterate through each DNA sequence in the file:\n        # Transcribe the sequence from DNA to mRNA\n        # Iterate using the forward and reverse complement of the mRNA:\n            # Iterate through 0, 1, 2 for frames in this sequence:\n                # Translate the mRNA frame into a protein sequence\n                # Try to find the ORFs in this protein sequence\n```", "```py\ndef main() -> None:\n    args = get_args()\n\n    for rec in SeqIO.parse(args.file, 'fasta'):\n        print(str(rec.seq))\n```", "```py\n$ ./orf.py tests/inputs/1.fa\nAGCCATGTAGCTAACTCAGGTTACATGGGGATGACCCCGCGACTTGGATTAGAGTCTCTTTTGGA\\\nATAAGCCTGAATGATCCGAGTAGCATCTCAG\n```", "```py\n$ ./orf.py tests/inputs/1.fa\nAGCCAUGUAGCUAACUCAGGUUACAUGGGGAUGACCCCGCGACUUGGAUUAGAGUCUCUUUUGGA\\\nAUAAGCCUGAAUGAUCCGAGUAGCAUCUCAG\n```", "```py\n$ ./orf.py tests/inputs/1.fa\nAGCCAUGUAGCUAACUCAGGUUACAUGGGGAUGACCCCGCGACUUGGAUUAGAGUCUCUUUUGGA\\\nAUAAGCCUGAAUGAUCCGAGUAGCAUCUCAG\nCUGAGAUGCUACUCGGAUCAUUCAGGCUUAUUCCAAAAGAGACUCUAAUCCAAGUCGCGGGGUCA\\\nUCCCCAUGUAACCUGAGUUAGCUACAUGGCU\n```", "```py\n$ ./orf.py tests/inputs/1.fa\nSHVANSGYMGMTPRLGLESLLE*A*MIRVASQ\nLRCYSDHSGLFQKRL*SKSRGHPHVT*VSYMA\n```", "```py\ndef truncate(seq: str, k: int) -> str:\n    \"\"\" Truncate a sequence to even division by k \"\"\"\n\n    return ''\n```", "```py\ndef test_truncate() -> None:\n    \"\"\" Test truncate \"\"\"\n\n    seq = '0123456789'\n    assert truncate(seq, 3) == '012345678'\n    assert truncate(seq[1:], 3) == '123456789'\n    assert truncate(seq[2:], 3) == '234567'\n```", "```py\n$ ./orf.py tests/inputs/1.fa\nSHVANSGYMGMTPRLGLESLLE*A*MIRVASQ\nAM*LTQVTWG*PRDLD*SLFWNKPE*SE*HL\nPCS*LRLHGDDPATWIRVSFGISLNDPSSIS\nLRCYSDHSGLFQKRL*SKSRGHPHVT*VSYMA\n*DATRIIQAYSKRDSNPSRGVIPM*PELATW\nEMLLGSFRLIPKETLIQVAGSSPCNLS*LHG\n```", "```py\ndef find_orfs(aa: str) -> List[str]: ![1](assets/1.png)\n    \"\"\" Find ORFs in AA sequence \"\"\"\n\n    return [] ![2](assets/2.png)\n```", "```py\ndef test_find_orfs() -> None:\n    \"\"\" Test find_orfs \"\"\"\n\n    assert find_orfs('') == [] ![1](assets/1.png)\n    assert find_orfs('M') == [] ![2](assets/2.png)\n    assert find_orfs('*') == [] ![3](assets/3.png)\n    assert find_orfs('M*') == ['M'] ![4](assets/4.png)\n    assert find_orfs('MAMAPR*') == ['MAMAPR', 'MAPR'] ![5](assets/5.png)\n    assert find_orfs('MAMAPR*M') == ['MAMAPR', 'MAPR'] ![6](assets/6.png)\n    assert find_orfs('MAMAPR*MP*') == ['MAMAPR', 'MAPR', 'MP'] ![7](assets/7.png)\n```", "```py\ndef truncate(seq: str, k: int) -> str:\n    \"\"\" Truncate a sequence to even division by k \"\"\"\n\n    length = len(seq) ![1](assets/1.png)\n    end = length - (length % k) ![2](assets/2.png)\n    return seq[:end] ![3](assets/3.png)\n```", "```py\ndef find_orfs(aa: str) -> List[str]:\n    orfs = [] ![1](assets/1.png)\n    while 'M' in aa: ![2](assets/2.png)\n        start = aa.index('M') ![3](assets/3.png)\n        if '*' in aa[start + 1:]: ![4](assets/4.png)\n            stop = aa.index('*', start + 1) ![5](assets/5.png)\n            orfs.append(''.join(aa[start:stop])) ![6](assets/6.png)\n            aa = aa[start + 1:] ![7](assets/7.png)\n        else:\n            break ![8](assets/8.png)\n\n    return orfs\n```", "```py\ndef main() -> None:\n    args = get_args()\n    for rec in SeqIO.parse(args.file, 'fasta'): ![1](assets/1.png)\n        rna = str(rec.seq).replace('T', 'U') ![2](assets/2.png)\n        orfs = set() ![3](assets/3.png)\n\n        for seq in [rna, Seq.reverse_complement(rna)]: ![4](assets/4.png)\n            for i in range(3): ![5](assets/5.png)\n                if prot := Seq.translate(truncate(seq[i:], 3), to_stop=False): ![6](assets/6.png)\n                    for orf in find_orfs(prot): ![7](assets/7.png)\n                        orfs.add(orf) ![8](assets/8.png)\n\n        print('\\n'.join(sorted(orfs))) ![9](assets/9.png)\n```", "```py\n>>> 'MAMAPR*MP*'.partition('*')\n('MAMAPR', '*', 'MP*')\n```", "```py\n>>> 'M'.partition('*')\n('M', '', '')\n```", "```py\ndef find_orfs(aa: str) -> List[str]:\n    \"\"\" Find ORFs in AA sequence \"\"\"\n\n    orfs = [] ![1](assets/1.png)\n    while True: ![2](assets/2.png)\n        first, middle, rest = aa.partition('*') ![3](assets/3.png)\n        if middle == '': ![4](assets/4.png)\n            break\n\n        last = 0 ![5](assets/5.png)\n        while True: ![6](assets/6.png)\n            start = first.find('M', last) ![7](assets/7.png)\n            if start == -1: ![8](assets/8.png)\n                break\n            orfs.append(first[start:]) ![9](assets/9.png)\n            last = start + 1 ![10](assets/10.png)\n        aa = rest ![11](assets/11.png)\n\n    return orfs ![12](assets/12.png)\n```", "```py\n>>> import re\n>>> re.findall('M', 'MAMAPR*MP*M')\n['M', 'M', 'M', 'M']\n```", "```py\n>>> re.findall('M[^*]*', 'MAMAPR*MP*M')\n['MAMAPR', 'MP', 'M']\n```", "```py\n>>> re.findall('M[^*]*\\*', 'MAMAPR*MP*M')\n['MAMAPR*', 'MP*']\n```", "```py\n>>> re.findall('M[^*]*[*]', 'MAMAPR*MP*M')\n['MAMAPR*', 'MP*']\n```", "```py\n>>> re.findall('(?=(M[^*]*)[*])', 'MAMAPR*MP*M')\n['MAMAPR', 'MAPR', 'MP']\n```", "```py\ndef find_orfs(aa: str) -> List[str]:\n    \"\"\" Find ORFs in AA sequence \"\"\"\n\n    return re.findall('(?=(M[^*]*)[*])', aa)\n```", "```py\ndef find_orfs(aa: str) -> List[str]:\n    \"\"\" Find ORFs in AA sequence \"\"\"\n\n    pattern = ( ![1](assets/1.png)\n        '(?='    # start positive look-ahead to handle overlaps\n        '('      # start a capture group\n        'M'      # a literal M\n        '[^*]*'  # zero or more of anything not the asterisk\n        ')'      # end the capture group\n        '[*]'    # a literal asterisk\n        ')')     # end the look-ahead group\n\n    return re.findall(pattern, aa) ![2](assets/2.png)\n```"]