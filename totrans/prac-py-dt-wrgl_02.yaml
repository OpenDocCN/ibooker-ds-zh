- en: Chapter 2\. Introduction to Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Can you read this? If so, I have good news for you: you won’t have any trouble
    learning to program. Why? Because computer programming languages in general—and
    Python in particular—are much less complex than natural human languages. Programming
    languages are designed by humans to be read, for the most part, by computers,
    so they have simpler grammar and far fewer “parts of speech” than natural languages.
    So if you feel reasonably comfortable reading English—a language notorious for
    its large vocabulary and irregular spellings and pronunciation—rest assured that
    learning the fundamentals of Python is well within your reach.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you’ll have all the Python skills you need to begin
    doing basic data wrangling with the common data formats that we’ll cover in [Chapter 4](ch04.html#chapter4).
    To get to that point, we’ll start by doing some basic coding exercises that cover
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Essential Python “parts of speech” and its basic grammar/syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the computer reads and interprets your Python code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use code “recipes” that are built by others (and yourself!) to quickly
    expand what your own code can do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Throughout this chapter, you’ll find code snippets that illustrate each concept,
    which are also collected in the accompanying Jupyter notebooks and standalone
    Python files on GitHub; these can be pulled into Google Colab or downloaded and
    run on a computer. While these files will let you see this chapter’s code in action,
    however, I *strongly* suggest that you create a new Colab/Jupyter notebook or
    standalone Python file and practice writing, running, and commenting this code
    for yourself (for a refresher on how to do this, see [“Hello World!”](ch01.html#hello_world)).
    While you might think this is silly, there is actually nothing more useful for
    building your data wrangling skills and confidence than setting up a Python file
    “from scratch” and then seeing code you wrote yourself make the computer do what
    you want—even if you are “just” retyping it from another file. Yes, you will encounter
    more hiccups this way, but that’s sort of the point: doing good data wrangling
    is not really about learning to do anything “right,” *it’s about learning how
    to recover when things go wrong*. Giving yourself room to make little mistakes
    early on (and learning how to recognize and fix them) is how you’ll truly make
    progress as both a data wrangler and programmer. You’ll never get that experience
    if all you do is run already-working code.'
  prefs: []
  type: TYPE_NORMAL
- en: Because these little mistakes are so important, I’ve included some “Fast Forward”
    sections in this chapter, which will offer you ways to take the code examples
    I’ve provided one step further—which often involves intentionally “breaking” the
    code. By the end of this chapter, you’ll be ready to combine the basics we’ve
    covered into a full-fledged data wrangling program that relies on real-world data.
    For each example, I’ll also include some explicit reminders about the kinds of
    things you’ll want to include in your data diary, when you’ll want to back up
    your code to GitHub, and so on so that you can begin to get really comfortable
    with those processes and also start to develop a feel for when you’ll want to
    take those steps during your own data wrangling projects.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know where we’re headed—let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: The Programming “Parts of Speech”
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Different human languages use different vocabularies and syntax structures,
    but there are many fundamental concepts that they typically share. For example,
    let’s take a look at the following two sentences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these sentences express essentially the same thing: they state what
    my name is. And though each language uses different words and slightly different
    grammatical structures, they both include parts of speech like subjects, objects,
    verbs, and modifiers. They also both follow similar grammar and *syntax* rules,
    in that they organize words and ideas into structures like sentences, paragraphs,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many programming languages also share key structural and organizational elements
    that roughly parallel those found in natural languages. To get a better idea of
    how this works, let’s start in the same way that we might when learning a new
    human language: by exploring programming languages’ “parts of speech.”'
  prefs: []
  type: TYPE_NORMAL
- en: Nouns ≈ Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the English language, nouns are often described as any word that refers
    to a “person, place, or thing.” Though this isn’t a super-precise definition,
    it is a handy way of illustrating the different types of entities that nouns can
    be. In programming languages, it is *variables* that are used to hold and refer
    to the different data *types* that we use to write our programs. Instead of “people,
    places, and things,” however, variables in the Python programming language can
    be one of five main data types:'
  prefs: []
  type: TYPE_NORMAL
- en: Number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionary (dict)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As with human languages, there is a lot of overlap in types of variables that
    different programming languages support: what in Python we call *lists* are known
    as *arrays* in JavaScript or C, for example; JavaScript *objects*, on the other
    hand, are officially known as *maps* (or *dict*ionaries) in Python.^([1](ch02.html#idm45143423781840))'
  prefs: []
  type: TYPE_NORMAL
- en: Having read the data types list, you can probably already guess what at least
    some of these data types will look like. The good news is that, unlike nouns in
    the real world, every data type in Python can be reliably identified by its formatting
    and punctuation—so there’s no need to worry that you’ll mix up your *dicts* and
    your *lists*, as long as you take the time to look closely at the symbols that
    surround your data.
  prefs: []
  type: TYPE_NORMAL
- en: To get a sense of the unique punctuation structure of each data type, take a
    look at [Example 2-1](#parts_of_speech). In particular, make sure you open or
    make a copy of this code in your code editor or notebook, so you can see the *syntax
    highlighting* in action. Numbers should be a different color than strings, for
    example, and the brackets, braces, and comments (on the lines that begin with
    a `#`) should all be another color as well.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-1\. parts_of_speech.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this list is far from exhaustive; just as human languages support
    “complex nouns” (like “haircut” and “bedroom”), it is possible to build more complex
    data types in programming languages as well. As you’ll soon see, however, there’s
    quite a lot that we can get done even with just this handful of basic types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the real world we also often give names to the many unique instances of
    “people, places, and things” in our lives, to reference and communicate about
    them more easily. We do this in programming, too, and for exactly the same reason:
    naming our variables lets us reference and modify specific pieces of data in a
    way the computer can understand. To see how this works, let’s try translating
    a simple English sentence into Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After reading this sentence, you will associate the name “Susan E. McGregor”
    with the label “author.” If someone asks you who wrote this book, you will (hopefully)
    remember this and say “Susan E. McGregor.” The equivalent “sentence” in Python
    code is shown in [Example 2-2](#naming_variable).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-2\. Naming a Python variable
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code tells the computer to set aside a box in memory, label it `author`,
    and then put the string `"Susan E. McGregor"` into that box. Later on in our program,
    if we asked the computer about the `author` variable, it would tell us that it
    contains the string `"Susan E. McGregor"`, as shown in [Example 2-3](#printing_variable).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-3\. Printing the contents of a Python variable
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What’s in a name?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Example 2-3](#printing_variable), I chose to name my variable `author`,
    but there is nothing magical about that choice. In principle, you can name variables
    almost anything you want—the only “hard-and-fast” rules are that variable names
    cannot:'
  prefs: []
  type: TYPE_NORMAL
- en: Begin with a digit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contain punctuation marks other than underscores (`_`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be “reserved” words or “keywords” (like Number or Boolean, for example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, I could just as easily have called the variable in [Example 2-3](#printing_variable)
    `nyc_resident` or even `fuzzy_pink_bunny`. What matters most is that you, as the
    programmer, follow the few restrictions listed previously, *and* that you use
    *exactly* the same variable name when trying to access its contents later (capitalization
    counts!). For example, create a new Python file containing the code in [Example 2-4](#variable_names),
    and then run it to see what results you get.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-4\. noun_examples.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Best practices for naming variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While all of the examples used in [Example 2-4](#variable_names) are *legitimate*
    variable names, not all of them are especially *good* variable names. As we’ll
    see throughout this book, writing good code—like any other kind of writing—is
    about more than just writing code that “works”; it’s also about how useful and
    intelligible that code is to both computers *and* people. Because of this, I consider
    naming variables well an essential part of good programming. In practice, *good*
    variable names are:'
  prefs: []
  type: TYPE_NORMAL
- en: Descriptive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unique (within a given file or program)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because achieving the first two properties often requires using more than one
    word, programmers typically use one of two stylistic conventions to help ensure
    that their variable names also remain *readable*, both of which are shown in [Example 2-4](#variable_names).
    One approach is to add underscores (`_`) between words (e.g., `nyc_residents`)
    or use “camel case,” in which the first letter of every word (except the first)
    is capitalized (e.g., `fuzzyPinkBunny`). In general, you should use one style
    and stick to it, though your code will work fine (and mostly meet the readability
    criteria) even if you mix them together. In this book, we’ll mostly use underscores,
    which also happen to be considered more “Pythonic.”
  prefs: []
  type: TYPE_NORMAL
- en: Verbs ≈ Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the English language, verbs are often described as “actions” or “states
    of being.” We’ve already seen a programming language equivalent of the latter:
    the equals sign (`=`) and the `print()` function used in the preceding examples.
    In English, we use forms of the verb “to be” to describe what something *is*;
    in Python (and many other programming languages), the value of a variable *is*
    whatever appears on the righthand side of the equals sign. This is why the equals
    sign is also sometimes described as the *assignment operator*.'
  prefs: []
  type: TYPE_NORMAL
- en: In programming, the equivalent of “action verbs” are *functions*. In Python
    and many other programming languages, there are *built-in functions*, which represent
    tasks—like printing output via the `print()` function—that the language “just
    knows” how to do. While similar, *methods* are special functions that are designed
    to work with a particular data type and need to be “called on” a variable of that
    data type in order to work. The methods available for a given data type tend to
    reflect common tasks you might want to perform with it. So just as most humans
    can walk, talk, eat, drink, and grasp objects, most programming languages have
    *string methods* that can do tasks like stick two strings together (known as *concatenation*),
    split two strings apart, and so on. But since it doesn’t make sense to “split”
    the number 5, the Number data type *doesn’t* have a `split()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is the difference between a built-in function and a method in practice?
    Not much, except for the way we include these “verbs” in our Python “sentences”
    or *statements*. With a built-in function, we can simply write the function name
    and pass along any “ingredients” it needs, by placing them between the round parentheses.
    For example, if you recall our [Example 1-1](ch01.html#hello_world_code), all
    we had to do was pass the string `Hello World!` to the `print()` function, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the case of the `split()` method, however, *we have to attach the method
    to a specific string*. That string can either be a *literal* (that is, a series
    of characters surrounded by quotation marks), or it can be a variable whose value
    is a string. Try the code in [Example 2-5](#split_string) in a standalone file
    or notebook, and see what kind of output you get!
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-5\. method_madness.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if you try to run the `split()` method by itself or on a data type
    where it doesn’t make sense, you’ll get an error. Try each of these out in succession
    (or in two different cells if you’re using a notebook) and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like data types, methods and functions are recognizable thanks to their
    typography and punctuation. A built-in function (like `print()`) will turn a specific
    color in your code editor or notebook. In Atom’s default One Dark theme, for example,
    variable names are light gray, operators like `=` are purple, and built-in functions
    like `print()` are aqua. You can also recognize functions by their associated
    punctuation: anywhere you see text *immediately* followed by round parentheses
    (e.g., `print()`), you are looking at a function. The same is true of methods,
    except that these are always preceded by an appropriate data type or variable
    name, and separated from it by a period (`.`).'
  prefs: []
  type: TYPE_NORMAL
- en: In a programming language like Python, you can actually get a fair bit done
    with just operators, methods, and built-in functions—especially if you are mostly
    doing tasks like basic math. When it comes to data wrangling, however, we need
    a little bit more sophistication. In exactly the same way we can think about complex
    tasks like playing a piano or kicking a ball as “just” a careful combination of
    many simpler actions—like moving our fingers or feet, for example—very sophisticated
    programming functions can be built by thoughtfully composing relatively simple
    operators, methods, and built-in functions. These *user-defined functions* are
    where we can start to really amplify the power of our code by making what are
    essentially code “recipes” that can be used again and again.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s say we wanted to print out the same greeting to two different
    people. We could simply use the `print()` function as we have been, as shown in
    [Example 2-6](#two_prints).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-6\. basic_greeting.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of things to notice about the code in [Example 2-6](#two_prints).
    First, using the `print()` function works just fine; this code totally gets the
    job done. And that’s great! The first time we write code for something (including
    a given data wrangling task), that’s pretty much our main goal: get it to work
    correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve accomplished that, though, we can start to think about some simple
    ways to make our code “cleaner” and more useful. In the previous example, the
    two print statements are identical, except for the variable being used. Any time
    we see this type of repetition in our code, it’s a clue that we may want to make
    our own user-defined function instead, as in [Example 2-7](#greet_me).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-7\. greet_me.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Pretty nifty, right? In some ways, we didn’t change much at all—but there’s
    actually quite a lot going in [Example 2-7](#greet_me). We’ll take a few moments
    now to highlight some of the new concepts being used here, but don’t worry if
    it doesn’t all make sense right away—we’ll continue to revisit these ideas throughout
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: The main thing we’ve done in [Example 2-7](#greet_me) is write our first custom
    function, `greet_me()`. We did this by using a few different syntax structures
    and typographic indicators to let the computer know that we want it to create
    and remember this function for future use. Some of these conventions match what
    we’ve already seen for creating our own custom variables (for example, using the
    descriptive name `greet_me()`), as well as the conventions of built-in functions
    and methods, like following the name of our function immediately with round parentheses
    (`()`).
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 2-1](#function_structure_diagram), I’ve diagrammed the code for our
    `greet_me()` function in order to highlight what’s happening on each line.
  prefs: []
  type: TYPE_NORMAL
- en: '![Components of a custom function](assets/ppdw_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Components of a custom function
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As you can see from [Figure 2-1](#function_structure_diagram), creating a custom
    function means including multiple signposts to the computer:'
  prefs: []
  type: TYPE_NORMAL
- en: The `def` keyword (short for *def*ine) tells the computer that what comes next
    is a function name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The round parentheses immediately following the function name reinforce that
    this is a function and are used to enclose the function’s *parameters* (if there
    are any).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The colon (`:`) indicates that the indented lines of code that follow are part
    of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we want to access the variable that was passed into our function as an *argument*,
    we use the “local” *parameter* name that appears between the round parentheses
    in the function definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use any type of functions (both built-in and custom) or methods *inside*
    our custom function. This is key strategy for building efficient, flexible code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it comes to using or “calling” our function, we can simply write the name
    of the function (`greet_me()`), making sure that we put the same number of “ingredients”
    between the parentheses that appear in the function definition. Since we have
    defined `greet_me()` to take exactly *one* argument “ingredient” (in this case,
    the `a_name` parameter), we have to provide *exactly* one argument when we want
    to use it—otherwise, we’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: Cooking with Custom Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may have noticed, I like to think of user-defined or “custom” functions
    as programming “recipes.” Like food recipes, they provide the computer with reusable
    instructions for transforming one or more raw data “ingredients” into some other
    useful resource. Sometimes there is only one parameter or “ingredient,” as in
    our `greet_me()` recipe; sometimes there are many parameters of many different
    data types. There’s no strictly “right” or “wrong” way to write a custom function—much
    as there’s no right or wrong way to write a cooking recipe; everyone will have
    their own style. At the same time, when it comes to strategies for deciding what
    should go into a given function, it can help to think about how we tend to use
    (or maybe even write!) recipes for cooking food.
  prefs: []
  type: TYPE_NORMAL
- en: For example, it’s obviously *possible* to write a single cooking recipe called
    “Thanksgiving” that describes how to make an entire holiday meal from start to
    finish. Depending on your holiday style, it might take anywhere from 2 to 72 hours
    to “run,” and it would be very useful once a year—and almost never otherwise.
    If you *did* want to make just part of that massive recipe—perhaps you want to
    serve your Thanksgiving mashed potatoes at New Year’s—you’d first have to dig
    through the Thanksgiving instructions to identify and piece together *just* the
    ingredients and steps for making mashed potatoes. That would mean investing a
    lot of work before you ever even got cooking!
  prefs: []
  type: TYPE_NORMAL
- en: So while we want our custom functions to do things that are *somewhat* more
    complex than what the computer can do already, we generally don’t want them to
    be truly *complicated*. Like a “Thanksgiving” recipe, making giant functions (or
    even programs) limits how effectively they can be reused. Creating simple, focused
    functions actually makes our code more useful and flexible in the long run—a process
    we’ll explore in more detail in [Chapter 8](ch08.html#chapter8).
  prefs: []
  type: TYPE_NORMAL
- en: 'Libraries: Borrowing Custom Functions from Other Coders'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If custom functions are programming recipes, then *libraries* are programming
    cookbooks: large collections of *other people’s* custom functions that *we* can
    use to transform our raw data ingredients without having to figure out and write
    our own recipe “from scratch.” As I mentioned in [Chapter 1](ch01.html#chapter1),
    the large community of coders who have written useful Python libraries is one
    of the reasons we’re using Python in the first place—and as you’ll see in [“Hitting
    the Road with Citi Bike Data”](#hitting_the_road_intro) at the end of this chapter,
    using them is both useful and powerful.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can really take advantage of libraries, however, we need to cover
    two more essential grammatical structures of Python: *loops* and *conditionals*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking Control: Loops and Conditionals'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have discussed, writing Python code is similar to writing in English
    in many ways. In addition to relying on some basic “parts of speech,” Python code
    is written from left to right and read essentially from top to bottom. But the
    path that the computer takes through a data wrangling program is much more like
    a [“Choose Your Own Adventure” book](https://en.wikipedia.org/wiki/Choose_Your_Own_Adventure)
    than a traditional essay or article: depending on the commands that you, as the
    programmer, provide, some bits of code may be skipped or repeated based on your
    data or other factors.'
  prefs: []
  type: TYPE_NORMAL
- en: In the Loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we’re data wrangling with Python, one of our most common goals will be
    to do *something* to every record in a dataset. For example, let’s say we wanted
    to add together a list of numbers to find their sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you needed to total a group of numbers like this without programming, you
    would have several options: you could use the calculator program on a computer,
    a physical calculator, or even (gasp!) a pencil and paper. If you know how to
    use a spreadsheet program, you could enter each data item there and use a `SUM()`
    function, too. For short lists, any of these solutions would probably be fine,
    but they don’t *scale* well: sure, adding up 10 numbers by hand (or by calculator)
    might not take too long, but adding up 100 numbers would. The spreadsheet solution
    is somewhat better in terms of time, but it still requires a number of external
    steps—like copying and pasting the data into a spreadsheet and more or less manually
    selecting which rows or columns should be summed. With a programmatic solution,
    we can avoid almost all of those drawbacks—and whether we need to add 10 rows
    or 10 million, it will take no more work on our part, and only slightly longer
    for the computer to actually calculate.'
  prefs: []
  type: TYPE_NORMAL
- en: Because programming is still writing, of course, there are multiple ways we
    can express the instructions we give to the computer. One way is to have the computer
    look at each number in the list and keep a running total, as shown in [Example 2-8](#pagecount_loop).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-8\. page_count_loop.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we look at some other ways we could tell the computer to do this task,
    let’s break down [Example 2-8](#pagecount_loop). Obviously, we start with the
    list of numbers. Next, we create a variable to keep track of `total_pages`, to
    which we have to explicitly assign a value of `0` to start out (most calculator
    programs do this more or less implicitly). Finally, we begin going through our
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To me, the easiest way to understand this line of code is to say it out loud
    like an English sentence: “For every `a_number` in the list, `page_counts` do
    the following.” And in fact, that’s exactly what happens. For every item in the
    `page_counts` list, the computer follows the instructions in the code indented
    under the `for...in...:` statement. In this case, that means adding together the
    current value of `total_pages` and the value of `a_number` and storing that back
    in `total_pages` again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In some ways, this is straightforward: we’ve already told the computer, very
    explicitly, the values of both `page_counts` (that’s our list of numbers) and
    `total_pages`. But what about `a_number`? Where did that come from, and how does
    the computer know where to find it?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the `print()` statement or the `def...function_name():` construction,
    the `for...in...:` configuration is built into the Python language, which is why
    we don’t have to give it quite as many instructions as we usually will when coding.
    In this case, what we have to provide the `for...in...:` statement to work are
    two things: a list-like variable (in this case, `page_counts`) and a name that
    the computer can use to refer to the current item in the list (in this case, `a_number`),
    as shown in [Figure 2-2](#for_loop_diagram).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Structure of a `for` loop.](assets/ppdw_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Structure of a `for` loop
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As with all variable names, there is nothing “magic” about the variable name
    `a_number`—I thought that was a good option because it’s descriptive and readable.
    What matters is that when I want the computer to do something with each list item,
    the variable name I use in my indented code has to match what I’ve written in
    that top `for...in...:` statement.
  prefs: []
  type: TYPE_NORMAL
- en: In programming lingo, this `for...in...:` construction is known as a *for loop*—and
    every commonly used programming language has one. The reason why it’s known as
    a “loop” is because for every item in the list provided, the computer runs every
    relevant line of code—in the case of Python, every indented line below the `for...in...:`
    statement—and then moves to the next item and “loops” back to the first indented
    line of code again. This is a little hard to see when our “loop” only has one
    line of code, so let’s add a few more lines to better illustrate what’s going
    on, as shown in [Example 2-9](#page_loop).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-9\. page_count_printout.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'By now you might be thinking, “This seems like a lot of work just to sum a
    list of numbers.” And there is, of course, a more efficient way to complete this
    *specific* task: Python has a built-in `sum()` function that will take our list
    of numbers as an argument ([Example 2-10](#pagecounts_sum)).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-10\. Using the `sum()` function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introduction_to_python_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Try adding this to your existing program on your own!
  prefs: []
  type: TYPE_NORMAL
- en: Even though we could have used the `sum()` function from the start, I took this
    opportunity to introduce `for` loops, for a couple of reasons. First, because
    it’s a good reminder that even when it comes to simple programming tasks, there’s
    always more than one approach. Second, because `for` loops are an essential part
    of data wrangling (and, really, all programming), `for...in...:` loops are one
    of the key tools we’ll use to filter, evaluate, and reformat data.
  prefs: []
  type: TYPE_NORMAL
- en: One Condition…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `for` loop gives us a straightforward way to look at every item in a dataset,
    but data wrangling requires making *decisions* about our data as well. Usually,
    that means evaluating some aspect of the data and doing one thing if the data
    has a certain value and otherwise something (or nothing!) else. For example, what
    if we wanted to know how many chapters in this book have more than 30 pages and
    how many have fewer than 30 pages? We’d need a way to:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether a particular number in our `page_counts` list is more than 30.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add 1 to an `over_30` counter if it’s more than 30.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, add 1 to our `under_30` counter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fortunately, Python has a built-in grammatical structure for doing exactly
    this kind of evaluation and decision-making: the `if...else` statement. Let’s
    see how it works by modifying the `for` loop in [Example 2-9](#page_loop) to also
    track the number of chapters that are more and less than 30 pages.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-11\. page_count_conditional.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `for` loops, I think the easiest way to understand what’s happening
    in an `if...else` conditional is to say it out loud as a sentence (and, just as
    importantly, write that sentence in the comments of your code): “`if` the current
    number of pages is more than 30, add one to the `over_30` counter. Otherwise (`else`),
    add one to the `under_30` counter.”'
  prefs: []
  type: TYPE_NORMAL
- en: While hopefully this makes some sense intuitively, I want to slow down again
    and go through what’s happening in a bit more detail, since `if...else` statements
    are another programming structure that we’ll come back to over and over.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s look at the indenting structure of the preceding example: everything
    that’s part of the `for` loop is indented one tab from the left margin; that’s
    how the computer knows that code is “inside” that loop. Similarly, the code that
    belongs to each part of the `if...else` statement is indented one tab *more*.
    In Python, this process of progressive indentation is actually *required* for
    the code to work properly—if the indenting isn’t correct, Python will complain.^([2](ch02.html#idm45143426063952))
    This mechanism is often referred to as *nesting*. A more visual way to think about
    what’s happening is shown in [Figure 2-3](#loop_nesting_diagram).'
  prefs: []
  type: TYPE_NORMAL
- en: '![A Venn-style diagram of code nesting.](assets/ppdw_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. Code “nesting”
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are a number of implications of nesting that we’ll address later in this
    book, but the main takeaway for now is that in order to make a line of code “belong”
    to a function, loop, or conditional, *it must be indented one tab to the right
    of the structure you want it to be part of*. To see this in action, let’s bring
    together everything we’ve done up to this point to create a Python program that
    uses a loop, a conditional, and a custom-defined function, as shown in [Example 2-12](#page_counts_complete).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-12\. page_count_custom_function.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introduction_to_python_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We can “wrap” our existing code into a new function (here called `count_​pages()`)
    by indenting one tab and adding the function definition line.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introduction_to_python_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We have to match the name of the list variable the `for` loop references to
    the parameter name provided between the round parentheses in the function definition
    in ![1](assets/1.png).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_introduction_to_python_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: A function does not *do* anything until it is actually *called* or *executed*.
    At this point, we need to provide it with the specific argument/ingredient we
    want it to work on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you compare [Example 2-12](#page_counts_complete) to [Example 2-11](#page_counts),
    you’ll see that I actually just copied the code from [Example 2-11](#page_counts)
    and did three things:'
  prefs: []
  type: TYPE_NORMAL
- en: I added the function defining statement `def count_pages(page_count_list):`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I indented all the existing code one additional tab so that the computer views
    it as “belonging” to our new `count_pages()` function. In Atom, you can do this
    all at once by highlighting all the lines of code you want to move and hitting
    the Tab key. I also updated the variable referenced at the top of the `for` loop
    to match the parameter name provided between the round parentheses on the `def`
    line of the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I made sure to “call” the function at the end, giving it the `page_counts` variable
    as an “ingredient” or *argument*. Notice that the `count_pages(page_counts)` statement
    isn’t indented at all.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hopefully, you’re starting to get a little bit of a handle on how all this fits
    together. Before we start using these tools to do some real-world data wrangling,
    though, we need to spend some time talking about what happens when code goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we’ve mentioned in [Chapter 1](ch01.html#chapter1), computers are *very*
    good at doing repetitive tasks quickly (and usually accurately). This lets us
    write programs that *scale* well: the same code that can sum or sort a list that’s
    10 items long (like our `page_counts` example) can also be used pretty effectively
    on a list that’s 10,000 items long.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the same time, however, computers are truly, importantly, and irretrievably
    stupid. Computers can’t really infer or innovate—they can only choose paths through
    their code based on the instructions and data that humans provide to them. As
    a result, there are many ways in which writing code is like giving instructions
    to a toddler: you have to be extremely literal and very explicit, and if something
    unexpected happens, you should expect a tantrum.^([3](ch02.html#idm45143428265504))'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when humans encounter a spelling or grammatical error in a written
    sentence, we often don’t even notice it: based on the context of the surrounding
    sentence or paragraph, much of the time we’ll infer the appropriate meaning without
    even really trying. In fact, even if almost *all* of the letters in *all* of the
    words in a sentence are rearranged, we can uusally siltl raed it wihtuot too mcuh
    erfoft.^([4](ch02.html#idm45143428263280)) Computers, by contrast, will just complain
    loudly and stop reading altogether if your code has even a comma out of place.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this, errors in programming aren’t just inevitable, they’re *expected*.
    No matter how much you program, any chunk of code you write that’s longer than
    a few lines will have errors in it of one kind or another. Rather than worrying
    about how to *avoid* errors, it is much more useful to learn how to *interpret*
    and *correct* errors. Throughout this book, I will at times intentionally generate
    errors (or encourage you to do so, as in [“Fast Forward”](#greet_me_ff) and [“Fast
    Forward”](#loop_errors)) so that you can get familiar with them and begin to develop
    your own process for working through them. As a starting point, we’ll discuss
    the three main *types* of errors that occur in programming: syntax errors, runtime
    errors, and logic errors.'
  prefs: []
  type: TYPE_NORMAL
- en: Syntax Snafus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Grammatical or *syntax* errors in programming may simultaneously be the simplest
    and most frustrating type of error you’ll encounter—in part because they happen
    very frequently and because the computer complains loudly about them. The example
    I gave earlier about a comma being out of place is an example of a syntax error:
    in one way or another, your code has violated the grammatical rules of the programming
    language.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason I describe these errors as “simple” is that they almost always are.
    In my experience, most syntax errors—and, by extension, programming errors—are
    basically typos: a comma or quotation mark gets forgotten, or a line of code gets
    indented too much or not enough. Unfortunately, many newer programmers I’ve worked
    with seem to find these errors especially frustrating precisely because they are
    simple—and because they feel silly for making them.'
  prefs: []
  type: TYPE_NORMAL
- en: In truth, experienced programmers experience syntax errors all the time. If
    you’re just starting out, the main thing you can learn from syntax errors is how
    *not* to let them derail you. In fact, one of the reasons why I’ve included the
    preceding “Fast Forward” sections on how to “break” your code intentionally is
    to help illustrate how easily errors can happen—and be fixed. In some ways one
    of the greatest skills you’ll learn when programming is how to be wrong a *lot*
    and not let it discourage you.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run a piece of code that has a syntax error, you’ll know because the
    last line of the (usually multiline) error message will say `SyntaxError`. But
    more useful than this when actually *fixing* the error will be the part of the
    error message that tells you *which file* the error is in and *which line* the
    error is on. Over time, just going to that line of code and looking for problems
    (typically missing punctuation: commas, brackets, colons, and quotation marks)
    will be enough for you to spot what’s wrong. While the error message will also
    include the (presumably) offending line of code with a caret (`^`) below the spot
    where Python believes the missing character might belong, this isn’t foolproof.
    For instance, [Example 2-13](#object_error) shows a Python `dict` that is missing
    a comma on one line.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-13\. Introducing an error
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the error output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, even though the code in [Example 2-13](#object_error) is missing
    a comma after the value `"book"` on line 4, the computer reports the error as
    being on line 5 (because that’s the point at which the computer has realized there
    is a problem). In general, though, you can usually find a syntax error on the
    line (or the line before) wherever the computer has reported it.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime Runaround
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *runtime* error in programming is used to describe any type of problem that
    crops up in the process of “running” or *executing* your code. Like syntax errors,
    a large portion of runtime errors are *also* essentially typos, such as incorrectly
    copied variable names. For example, anytime you see an error that includes the
    phrase *`some_variable`* `is not defined`, you’ve almost certainly got mismatched
    variable names somewhere in your code (remember: capitalization counts!). Since
    reading the entire “traceback” error can get a little convoluted (they tend to
    reference the inner workings of the Python programming language more than I, personally,
    find strictly useful), I recommend copying the variable name directly from the
    error and then doing a case-*insensitive* search for it in your code (this is
    the default behavior in Atom). This approach will highlight similar (but not *quite*
    identical) spellings of a variable name, speeding up your search for the mismatch.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, in [Example 2-14](#param_mismatch) the parameter name provided
    in the function definition for `greet_me(a_name)` doesn’t *precisely* match what’s
    used within the body of the function definition on the next line.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-14\. Slightly mismatched variable names will generate runtime errors
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the parameter name that appears inside the round parentheses of the
    function definition always takes precedence, running the code in [Example 2-14](#param_mismatch)
    generates the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that, as usual, the last few lines of the error message are giving us the
    most helpful information. The last line lets us know that we’re trying to use
    the variable name `A_name` without having defined it first, and the line above
    contains the actual code where it appears. With these two pieces of information
    (plus our search strategy), it probably won’t take too long before we see where
    we went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Another very common type of runtime error occurs when you try to do something
    with a particular data type that it wasn’t designed for. In the [“Fast Forward”](#greet_me_ff),
    you may have tried running the code `greet_me(14)`. In this case, the last line
    of the error output will include the word `TypeError`, which means that some part
    of our code received a different data type than it was expecting. In that example,
    the problem is that the function expects a string (which can be “added” or *concatenated*
    to another string using the `+` sign), but we provided it with a number, in this
    case, `14`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The challenge with fixing this kind of error is that identifying exactly where
    the problem lies can be a bit tricky, because it involves a mismatch between where
    a variable’s value was *assigned* and where that variable (and therefore its value)
    was actually *used*. Especially as your programs grow more sophisticated, these
    two processes may be nowhere near each other in your code. Looking at the error
    output from [Example 2-14](#param_mismatch), for example, you can see that it
    reports two locations. The first is a line where the variable was passed into
    the function, and so where the available value was *assigned*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The second is the line where the value passed to it was *used*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As I have mentioned already, starting your debugging work with where a problematic
    variable or value was *used* and then working backward through your code to see
    where the value was assigned is helpful; just know that the line of code where
    the value was assigned may or may *not* actually appear in the error output. This
    is part of what makes these kinds of runtime errors more difficult to track down
    than your average syntax error.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that runtime errors are some of the harder ones to diagnose is a key
    reason why I recommend both saving and testing your code frequently. The source
    of a new runtime error is much easier to identify if you’ve only written a few
    new lines of code since you last tested it, because the problem *must* be in that
    little bit of new code. With this sort of `write, run, repeat` approach, you’ll
    have much less ground to cover when it comes to looking for the source of any
    new errors, and you’ll probably be able to fix them relatively quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Logic Loss
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By far the trickiest type of programming problem is the *logic* error, which
    is broadly used to describe what happens when your program *works*, just *not
    how you intended*. These errors are especially insidious because—from the computer’s
    perspective—everything is fine: your code is not trying to do anything it finds
    confusing or “wrong.” But computers are stupid, remember, so they will happily
    let your program do things that produce meaningless, nonsensical, or even misleading
    results. In precisely the same way that one can do correct math on bad data (as
    we’ll discuss in [Chapter 3](ch03.html#chapter3)), it’s very possible to write
    functioning code that does something inappropriate or incorrect. In fact, we already
    have!'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look back at [Example 2-12](#page_counts_complete), you’ll notice that
    there’s actually a slight disconnect between what our comments *say* we wanted
    to accomplish and what our code actually *does*. The output of that example looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'But our data looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: See the problem? While it’s true that we have 5 chapters whose page count is
    more than 30, we actually have only 3 chapters whose page count is *under* 30—there’s
    one chapter with exactly 30 pages.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, this may not seem like a particularly significant error—after all,
    how important is it if one 30-page chapter gets lumped in with chapters that are
    fewer than 30 pages? But imagine that instead of counting chapter pages, this
    code was being used to determine voting eligibility? If that code was counting
    only people who were “over 18,” hundreds of thousands of people would be disenfranchised.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixing this error is not difficult or complicated in terms of the code we need
    to adjust. All we have to do is change this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The challenge this type of error presents is that it relies entirely on our
    diligence as programmers to make sure that as we *design* our programs, we don’t
    overlook some possible data value or discrepancy that can result in incorrect
    measurements or results. Because the computer cannot warn us about logic errors,
    the only reliable way to avoid them is to plan our programs carefully in the first
    place, and to carefully “sanity check” the results. In [“Hitting the Road with
    Citi Bike Data”](#hitting_the_road_intro), we’ll see what this process looks like
    when we write a program to deal with a real-world dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Phew! Now that we’ve covered all the fundamentals of Python programming (really!),
    we’re ready to move on from our “toy” examples using data that is (sort of) about
    this book. To get our feet wet with a data wrangling task using a real dataset,
    we’ll turn to information from the New York City bike-sharing system, Citi Bike.
  prefs: []
  type: TYPE_NORMAL
- en: Hitting the Road with Citi Bike Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every month, millions of people use bike-sharing systems to navigate cities
    and towns around the world. New York City’s Citi Bike program launched in 2013
    with 6,000 bikes, and in 2020, the system saw its [100 millionth ride](https://citibikenyc.com/about).
  prefs: []
  type: TYPE_NORMAL
- en: 'Citi Bike provides freely accessible data about its system operations that
    is both real-time and historical. To see what it takes to do data wrangling with
    a real-world dataset, we’re going to use Citi Bike data to answer a simple question:
    how many rides each day are taken by different types of Citi Bike riders?'
  prefs: []
  type: TYPE_NORMAL
- en: We need our Python skills to answer this question because Citi Bike riders take
    hundreds of thousands of rides per day—meaning that just one day of this data
    has too many rows for either Microsoft Excel or Google Sheets to handle. But even
    on a Chromebook, Python will have no problem working with this amount of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To think about how to approach this, let’s revisit the steps of data wrangling
    outlined in [“What Is “Data Wrangling”?”](ch01.html#describing_data_wrangling):'
  prefs: []
  type: TYPE_NORMAL
- en: Locating or collecting data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assessing the data’s quality
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: “Cleaning,” standardizing, and/or transforming the data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Analyzing the data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visualizing the data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Communicating the data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this exercise, we’re going to focus on steps 1–4, though as you’ll see,
    I’ve done some preparation that will cut down on how long we spend with certain
    steps. For example, I’ve already located [the Citi Bike system data](https://citibikenyc.com/system-data)
    and downloaded [the September 2020 trip history data](https://s3.amazonaws.com/tripdata/index.html),
    confirmed that the only values that appear in the `User Type` column are `Customer`
    and `Subscriber`, and cut down the whole September dataset to *just* the rides
    that began on September 1, 2020\. While we’ll delve into how to do all of these
    processes in subsequent chapters, for now I want to focus on how to apply the
    lessons from this chapter to data that we didn’t make up for ourselves.^([7](ch02.html#idm45143427916368))
  prefs: []
  type: TYPE_NORMAL
- en: Starting with Pseudocode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the best ways to get started with a data wrangling project of any size
    is to plan out your approach in advance and include that program outline in you
    Python file through a process known as *pseudocoding*. Pseudocoding basically
    means writing, in regular English (though you could certainly pseudocode in another
    natural language if you prefer!), what your program will do, step by step. In
    addition to giving you space to think through what your program needs to accomplish
    without worrying about how to code it, pseudocoding will give you a valuable reference
    for what to work on next when you need to take a break from your project and come
    back to it later. Although you’ll no doubt meet many professional programmers
    who *don’t* do this part of the process regularly, I can guarantee that it will
    help you finish your wrangling projects more quickly—and that it’s the kind of
    habit that is welcome in any professional programming or data science setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'I prefer to put my program outline and pseudocode right at the top of my Python
    file, in a large block of comments. To start out, I’m going to do three things:'
  prefs: []
  type: TYPE_NORMAL
- en: State my question.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe how I will “answer” my question.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Outline in plain language the steps my program will take.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This means that the first thing I’m going to do is write a *lot* of comments
    in my file, as you can see in [Example 2-15](#citibike_comment_block).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-15\. hitting_the_road_with_citibike.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the program outline is all squared away, it’s time to get started
    with the first part of our program: reading in our data.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Anytime you start a new file like this, remember that even if it’s saved inside
    a local Git repo folder, you’ll need to run `git add` to have Git back up any
    changes you make (you can’t `commit` a file until you `add` it, remember). These
    steps are outlined in [“Don’t Forget Git!”](#dont_forget_git), in case you’d like
    a refresher. While how often you `commit` is up to you, for this exercise I recommend
    that you `commit` your code (with a descriptive commit message, of course!) after
    each code block in this section. As you get more comfortable with the coding and
    Git `commit` process, of course, you’ll find a frequency and rhythm for backing
    up your code that works best for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading different data formats, as we’ll see in-depth in [Chapter 4](ch04.html#chapter4),
    can actually be one of the trickier aspects of data wrangling. Fortunately, there
    are many Python libraries available to help, and we’re going to make use of one
    right now! I mentioned libraries briefly in [“Libraries: Borrowing Custom Functions
    from Other Coders”](#library_love); they are essentially cookbooks of code. For
    this project, we’re going to use the code “recipes” from the *csv* library, which
    is mostly designed to deal with—you guessed it!—*.csv* files. The file extension
    *.csv* stands for *c*omma-*s*eparated *v*alue, and if you haven’t seen it before,
    don’t worry. We’ll go into (significant) detail about file types in [Chapter 4](ch04.html#chapter4).
    Right now, having the *csv* library on hand means that we don’t actually *need*
    to know too much about this file type in order to work with it, because the library’s
    code recipes are going to do a lot of the work for us!'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re following along in your own file, you’ll want to add the code in [Example 2-16](#hitting_the_road_1)
    to the program outline.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-16\. hitting_the_road_with_citibike.py (continued)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introduction_to_python_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The *csv* library includes a range of handy code recipes for dealing with our
    data files.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introduction_to_python_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`open()` is a built-in function that takes a file name and a “mode” as parameters.
    In this example, the target file (*202009CitibikeTripdataExample.csv*) should
    be in the same folder as our Python script or notebook. Values for the “mode”
    can be `"r"` for “read” or `"w"` for “write.”'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_introduction_to_python_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: By printing out the `citibike_reader.fieldnames` values, we can see that the
    exact label for the “User Type” column is `usertype`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we could actually run this script, and we should see output
    that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve also now succeeded in completing the first step of our outline: we’ve
    read in our data. But we’ve also used the *csv* library to transform that data
    and even generate some *metadata* about it. Importantly, we now know that the
    *precise* name of the column containing our “User Type” information is actually
    `usertype`. This will help us when it comes time to write our `if...else` statements.
    To confirm that things are working as you expect, be sure to save and run your
    code. If it works as expected (that is, it prints out a list of column headers),
    now is a good time to do a `git commit` cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Remember that if you are working on Google Colab, you can commit your code directly
    to GitHub by choosing File → “Save a copy in GitHub” and entering your commit
    message in the overlay window that appears.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve completed step one successfully, let’s go on to step two, as
    shown in [Example 2-17](#hitting_the_road_2).^([8](ch02.html#idm45143427725168))
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-17\. hitting_the_road_with_citibike.py (continued again)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Pretty simple, right? On to step three! Since we need to check each row of data
    in the file, we’ll need to write a `for...in` loop, which will need to have an
    `if...else` inside of it to test for specific values in the `usertype` column.
    To help keep track of what each line of code is doing, I’m going to write a *lot*
    of comments explaining the code in English, as shown in [Example 2-18](#hitting_the_road_3).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-18\. hitting_the_road_with_citibike.py (still rolling)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introduction_to_python_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We want to make sure our `for` loop is working with the data that’s already
    been transformed by our DictReader recipe, so we want to make sure we’re referencing
    our `citibike_reader` variable here.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introduction_to_python_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: In order for my `if` statements to be “inside” my loop, they have to be indented
    one more `tab` to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_introduction_to_python_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Because we need to use “else” here—but also need another “if” statement—we’re
    using the compound keyword `elif`, which is short for “else if.”
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_introduction_to_python_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This final `else` will “catch” any rows of data where the value of `usertype`
    was not one of the values we checked for explicitly (in this case, “Subscriber”
    or “Customer”). This serves as a (very) basic data quality check: if this data
    column contains any unexpected values, `other_user_count` will be greater than
    zero (`0`), and we need to look at our original data more closely.'
  prefs: []
  type: TYPE_NORMAL
- en: OK, there is a *lot* going on in [Example 2-18](#hitting_the_road_3)—or at least
    it looks like there is! Really, all we did was check whether the value in each
    row’s `usertype` column was `"Subscriber"` or `"Customer"` and added one to (or
    *incremented*) the corresponding `count` variable if it was. If the `usertype`
    value was *neither* of those, we added one to the `other_user_count` variable.
  prefs: []
  type: TYPE_NORMAL
- en: While it may seem strange that we’ve added so many more lines of comments than
    code, this is actually pretty normal—even good! After all, while the computer
    never “forgets” how to read Python code, *you* will *absolutely* forget what this
    code is doing and why if you don’t explain it in the comments. And that’s not
    a bad thing! After all, memorizing all of your code would make programming pretty
    inefficient. By writing detailed comments, you ensure that you can easily understand
    your code in the future, without having to do the work of translating Python to
    English all over again!
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, make sure to run your code. Since “no news is good news”
    for our most common types of errors, if you don’t get any errors, go ahead and
    do a `git commit` cycle. Otherwise, now is a good time to pause and troubleshoot
    any issues you’ve encountered. Once those are resolved, you’ll see there’s only
    one very simple step left: printing! Let’s just go the most straightforward route
    and use built-in `print` statements, as shown in [Example 2-19](#hitting_the_road_4).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-19\. hitting_the_road_with_citibike.py (we’ve arrived!)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introduction_to_python_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Note that these `print()` statements are left justified, because we only want
    to print values once the `for` loop has finished going through the entire dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’ve added the code in [Example 2-19](#hitting_the_road_4) to your file,
    save and run it. Your output should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If that’s what you see—congratulations! You’ve successfully written your first
    real-world data wrangling program. Make sure to do a `git commit` cycle to back
    up your great work!
  prefs: []
  type: TYPE_NORMAL
- en: Seeking Scale
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In writing this script, we’ve accomplished a number of things:'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve successfully and precisely counted the number of “Subscribers” and “Customers”
    who used Citi Bikes on a single day in September 2020.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve confirmed that there are no other values in the `usertype` column (because
    the value in our `other_user_count` variable was 0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you’ve done data wrangling before using spreadsheet or database programs,
    for example, but this was your first time working in Python, chances are this
    process took longer than your previous method, all things considered. But as I’ve
    mentioned a few times already, a key advantage that coding offers over many other
    methods is the ability to *scale* almost seamlessly. That scale works in two ways.
    First, it does the same work on a larger dataset almost as fast as a smaller one.
    For example, on my Chromebook, the *hitting_the_road_with_citibike.py* script
    completes in about half a second. If I run the same script on the data from *the
    entire month of September*, it takes about 12 seconds. Most software programs
    that could even handle the entire month’s data would probably need that long just
    to *open* the file, much less do any work to it. So, using Python helps us scale
    because we can handle larger datasets much more quickly and effectively. You can
    test this out for yourself by changing the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re working in a standalone Python file, you can even measure how long
    it takes to run your script on the new file by adding the `time` keyword before
    your `python` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This illustrates the second type of scale we achieve with Python, which has
    to do with the *marginal effort* required to have the computer do the same task
    on a different dataset (with the same structure) once we have written our program,
    and this is where Python (and programming in general) really shines. In order
    to run my script on data from the whole month of September 2020, *all I had to
    do was load a different data file*. By changing the target filename that I opened
    with my `source_file =` statement, I was able to process *all* of the September
    data instead of just the data from one day. In other words, the additional (or
    “marginal”) effort to process hundreds of thousands of additional rows of data
    was exactly as long as it took me to copy and paste the filename. Building on
    that example, I could process an entire year of data in a few minutes (or less,
    as we’ll see in [Chapter 8](ch08.html#chapter8)). That is something that is nearly
    impossible to achieve with any noncoding data wrangling method.
  prefs: []
  type: TYPE_NORMAL
- en: The complete script we’ve built in this section is an example of how, even using
    just the basic structures we’ve covered in this chapter, you can do some really
    useful and efficient data wrangling with Python. Though there are many new data
    formats and challenges to explore in the remaining chapters, I hope this has given
    you a sense of how much you can achieve with even these “basic” Python tools and
    just a little effort and attention to detail. Imagine what else you can accomplish
    if you keep going!
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Believe it or not, in this chapter we’ve covered *all* the essential Python
    tools you’ll need to do data wrangling—as well as almost any other kind of Python
    programming! To recap what we’ve covered, we learned about:'
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the “nouns” of programming: numbers, strings, lists, dicts, and Booleans.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the “verbs” of programming: operators, built-in functions, and user-defined
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Using `for...in...` loops
  prefs: []
  type: TYPE_NORMAL
- en: These let us run a particular chunk of code on every item in a list.
  prefs: []
  type: TYPE_NORMAL
- en: Using `if...else` conditionals
  prefs: []
  type: TYPE_NORMAL
- en: These let us to make “decisions” about what code should be run, based (usually)
    on the attributes of our data.
  prefs: []
  type: TYPE_NORMAL
- en: Errors
  prefs: []
  type: TYPE_NORMAL
- en: We explored the different types of errors that we’re likely to encounter when
    programming and how to best address and prevent them.
  prefs: []
  type: TYPE_NORMAL
- en: We also practiced combining and composing these concepts to create a basic program
    to work with some sample data from the New York Citi Bike system. While we’ll
    expand on this example and explore others in future chapters, our next task is
    to understand more about how to evaluate data itself as part of our data wrangling
    work.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch02.html#idm45143423781840-marker)) There are also many language-specific
    data types (such as Python’s *tuple* data type) that are not as relevant to our
    data wrangling efforts, so we won’t address these in detail.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch02.html#idm45143426063952-marker)) In many other programming languages,
    curly braces are used to indicate which pieces of code belong inside a loop or
    a conditional statement. As we mentioned in [“Readability”](ch01.html#readability),
    however, Python is *whitespace dependent*.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch02.html#idm45143428265504-marker)) Unlike computers, of course, toddlers
    are capable of genuine originality and learning.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch02.html#idm45143428263280-marker)) For more, see Scott Rosenberg’s Wordyard
    [blog post about the topic](http://wordyard.com/2003/09/15/if-u-cn-rd-ths-msg-u-r-jst-lke-vryne-lse).
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch02.html#idm45143428086384-marker)) This is actually a good thing, as
    we’ll see in [Chapter 3](ch03.html#chapter3).
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch02.html#idm45143428081024-marker)) For information on code coverage
    best practices, see “Code Coverage Best Practices” on the [Google Testing Blog](https://testing.googleblog.com/2020/08/code-coverage-best-practices.html).
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch02.html#idm45143427916368-marker)) All of the code for this exercise
    can be found in the *hitting_the_road_with_citibike.py* and *hitting_the_road_with_citibike.ipynb*
    files. However, I strongly encourage you to create new files of your own and enter
    the provided code yourself.
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch02.html#idm45143427725168-marker)) Once again—and from here on out—add
    this code to your file below the last line of the previous block.
  prefs: []
  type: TYPE_NORMAL
