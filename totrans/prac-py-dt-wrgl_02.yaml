- en: Chapter 2\. Introduction to Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。Python简介
- en: 'Can you read this? If so, I have good news for you: you won’t have any trouble
    learning to program. Why? Because computer programming languages in general—and
    Python in particular—are much less complex than natural human languages. Programming
    languages are designed by humans to be read, for the most part, by computers,
    so they have simpler grammar and far fewer “parts of speech” than natural languages.
    So if you feel reasonably comfortable reading English—a language notorious for
    its large vocabulary and irregular spellings and pronunciation—rest assured that
    learning the fundamentals of Python is well within your reach.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您能读懂这段话吗？如果可以，我有个好消息告诉您：学习编程不会有任何困难。为什么这么说？因为总体而言，计算机编程语言—特别是Python语言—比起自然人类语言要简单得多。编程语言是由人类设计的，主要是为了让计算机阅读，因此它们的语法更简单，所涉及的“语法成分”要比自然语言少得多。所以，如果您对阅读英语感到相对舒适—这是以其庞大词汇量、不规则拼写和发音而闻名的语言—那么学习Python基础是完全可以做到的。
- en: 'By the end of this chapter, you’ll have all the Python skills you need to begin
    doing basic data wrangling with the common data formats that we’ll cover in [Chapter 4](ch04.html#chapter4).
    To get to that point, we’ll start by doing some basic coding exercises that cover
    the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章末尾时，您将掌握所有必要的Python技能，可以开始使用我们将在[第4章](ch04.html#chapter4)中介绍的常见数据格式进行基本数据处理。为了达到这一目标，我们将从一些基本的编码练习开始，涵盖以下内容：
- en: Essential Python “parts of speech” and its basic grammar/syntax
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python基础语法及其基本语法/句法要点
- en: How the computer reads and interprets your Python code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机如何读取和解释您的Python代码
- en: How to use code “recipes” that are built by others (and yourself!) to quickly
    expand what your own code can do
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用他人（以及您自己！）编写的代码“配方”快速扩展您自己代码的功能
- en: 'Throughout this chapter, you’ll find code snippets that illustrate each concept,
    which are also collected in the accompanying Jupyter notebooks and standalone
    Python files on GitHub; these can be pulled into Google Colab or downloaded and
    run on a computer. While these files will let you see this chapter’s code in action,
    however, I *strongly* suggest that you create a new Colab/Jupyter notebook or
    standalone Python file and practice writing, running, and commenting this code
    for yourself (for a refresher on how to do this, see [“Hello World!”](ch01.html#hello_world)).
    While you might think this is silly, there is actually nothing more useful for
    building your data wrangling skills and confidence than setting up a Python file
    “from scratch” and then seeing code you wrote yourself make the computer do what
    you want—even if you are “just” retyping it from another file. Yes, you will encounter
    more hiccups this way, but that’s sort of the point: doing good data wrangling
    is not really about learning to do anything “right,” *it’s about learning how
    to recover when things go wrong*. Giving yourself room to make little mistakes
    early on (and learning how to recognize and fix them) is how you’ll truly make
    progress as both a data wrangler and programmer. You’ll never get that experience
    if all you do is run already-working code.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节中，您会找到演示每个概念的代码片段，这些代码片段也在附带的Jupyter笔记本和独立的Python文件中收集在GitHub上；这些可以被导入Google
    Colab中，或者下载到计算机上运行。虽然这些文件能让您看到本章的代码实际运行，但是我*强烈建议*您创建一个新的Colab/Jupyter笔记本或者独立的Python文件，自己动手练习编写、运行和评论这些代码（如果需要回顾如何操作，请参见[“Hello
    World！”](ch01.html#hello_world)）。虽然您可能觉得这有些愚蠢，但实际上对于提升数据处理技能和自信心来说，没有比从零开始设置Python文件，然后看到自己编写的代码让计算机按您的意愿执行更有用的了，即使只是“简单地”从另一个文件中重新输入。是的，这样做可能会遇到更多问题，但这正是关键所在：良好的数据处理不仅仅是学会如何“正确”地做事情，*更是学会在事情出错时如何恢复*。在早期给自己留些小错误的空间（以及学会如何识别和修正它们），这才是您作为数据处理员和程序员真正进步的方式。如果您只是运行已经运行的代码，您将永远无法获得那种经验。
- en: Because these little mistakes are so important, I’ve included some “Fast Forward”
    sections in this chapter, which will offer you ways to take the code examples
    I’ve provided one step further—which often involves intentionally “breaking” the
    code. By the end of this chapter, you’ll be ready to combine the basics we’ve
    covered into a full-fledged data wrangling program that relies on real-world data.
    For each example, I’ll also include some explicit reminders about the kinds of
    things you’ll want to include in your data diary, when you’ll want to back up
    your code to GitHub, and so on so that you can begin to get really comfortable
    with those processes and also start to develop a feel for when you’ll want to
    take those steps during your own data wrangling projects.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些小错误如此重要，我在本章中包含了一些“快速前进”部分，这些部分将为您提供将我提供的代码示例推向更高级的方法，这通常涉及有意“破坏”代码。通过本章结束时，您将准备好将我们涵盖的基础知识结合到依赖于真实世界数据的完整数据整理程序中。对于每个示例，我还将包括一些明确的提醒，让您了解您希望在数据日记中包含的内容，何时需要将您的代码备份到GitHub等等，这样您就可以开始真正熟悉这些过程，并开始发展一种感觉，了解何时需要在自己的数据整理项目中采取这些步骤。
- en: Now that you know where we’re headed—let’s get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道我们的目标在哪里了——让我们开始吧！
- en: The Programming “Parts of Speech”
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程语言的“词类”
- en: 'Different human languages use different vocabularies and syntax structures,
    but there are many fundamental concepts that they typically share. For example,
    let’s take a look at the following two sentences:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的人类语言使用不同的词汇和语法结构，但它们通常共享许多基本概念。例如，让我们看看以下两个句子：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Both of these sentences express essentially the same thing: they state what
    my name is. And though each language uses different words and slightly different
    grammatical structures, they both include parts of speech like subjects, objects,
    verbs, and modifiers. They also both follow similar grammar and *syntax* rules,
    in that they organize words and ideas into structures like sentences, paragraphs,
    and so on.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个句子基本表达了同样的意思：它们陈述了我的名字是什么。尽管每种语言使用不同的词汇和略有不同的语法结构，但它们都包括像主语、宾语、动词和修饰语等词类。它们还都遵循类似的语法和*语法*规则，以组织单词和思想为句子、段落等结构。
- en: 'Many programming languages also share key structural and organizational elements
    that roughly parallel those found in natural languages. To get a better idea of
    how this works, let’s start in the same way that we might when learning a new
    human language: by exploring programming languages’ “parts of speech.”'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言也分享与自然语言类似的关键结构和组织元素。为了更好地理解这一点，让我们从学习新的人类语言时常用的方式开始：探索编程语言的“词类”。
- en: Nouns ≈ Variables
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名词 ≈ 变量
- en: 'In the English language, nouns are often described as any word that refers
    to a “person, place, or thing.” Though this isn’t a super-precise definition,
    it is a handy way of illustrating the different types of entities that nouns can
    be. In programming languages, it is *variables* that are used to hold and refer
    to the different data *types* that we use to write our programs. Instead of “people,
    places, and things,” however, variables in the Python programming language can
    be one of five main data types:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，名词通常被描述为任何指代“人、地方或事物”的词。尽管这不是一个非常精确的定义，但这是一个便于说明名词可以是不同类型实体的一种方便方法。在编程语言中，*变量*用于保存和引用我们编写程序时使用的不同*数据类型*。然而，与“人、地方和事物”不同的是，在Python编程语言中，变量可以是五种主要的数据类型之一：
- en: Number
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: String
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: List
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: Dictionary (dict)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典（dict）
- en: Boolean
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔
- en: 'As with human languages, there is a lot of overlap in types of variables that
    different programming languages support: what in Python we call *lists* are known
    as *arrays* in JavaScript or C, for example; JavaScript *objects*, on the other
    hand, are officially known as *maps* (or *dict*ionaries) in Python.^([1](ch02.html#idm45143423781840))'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与人类语言类似，不同编程语言支持的变量类型存在许多重叠：例如，在Python中我们称之为*列表*的东西在JavaScript或C中称为*数组*；另一方面，JavaScript中的*对象*在Python中正式称为*映射*（或*字典*）^([1](ch02.html#idm45143423781840))
- en: Having read the data types list, you can probably already guess what at least
    some of these data types will look like. The good news is that, unlike nouns in
    the real world, every data type in Python can be reliably identified by its formatting
    and punctuation—so there’s no need to worry that you’ll mix up your *dicts* and
    your *lists*, as long as you take the time to look closely at the symbols that
    surround your data.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读数据类型列表后，你可能已经能猜到其中至少一些数据类型的样子。好消息是，与现实世界中的名词不同，Python 中的每种数据类型都可以通过其格式和标点符号可靠地识别——因此，只要你仔细看待围绕数据的符号，就不用担心会将*dicts*和*lists*搞混。
- en: To get a sense of the unique punctuation structure of each data type, take a
    look at [Example 2-1](#parts_of_speech). In particular, make sure you open or
    make a copy of this code in your code editor or notebook, so you can see the *syntax
    highlighting* in action. Numbers should be a different color than strings, for
    example, and the brackets, braces, and comments (on the lines that begin with
    a `#`) should all be another color as well.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要感受每种数据类型独特的标点结构，请看一下[示例 2-1](#parts_of_speech)。特别是，请确保在你的代码编辑器或笔记本中打开或复制此代码，这样你就可以看到*语法高亮*的效果。例如，数字应该是一个颜色，而字符串，方括号、花括号以及注释（以`#`开头的行）应该是另一种颜色。
- en: Example 2-1\. parts_of_speech.py
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-1\. parts_of_speech.py
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Of course, this list is far from exhaustive; just as human languages support
    “complex nouns” (like “haircut” and “bedroom”), it is possible to build more complex
    data types in programming languages as well. As you’ll soon see, however, there’s
    quite a lot that we can get done even with just this handful of basic types.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个列表远非详尽无遗；就像人类语言支持“复杂名词”（比如“理发”和“卧室”）一样，编程语言也能构建更复杂的数据类型。然而，正如你很快会看到的那样，即使只有这几种基本类型，我们也能做很多事情。
- en: 'In the real world we also often give names to the many unique instances of
    “people, places, and things” in our lives, to reference and communicate about
    them more easily. We do this in programming, too, and for exactly the same reason:
    naming our variables lets us reference and modify specific pieces of data in a
    way the computer can understand. To see how this works, let’s try translating
    a simple English sentence into Python code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，我们通常也会给我们生活中许多独特的“人、地、物”取名，以便更容易地引用和交流。在编程中，我们也是如此，原因正是一样的：给变量命名让我们能以计算机能理解的方式引用和修改特定的数据。为了看看这是如何运作的，让我们尝试将一个简单的英文句子翻译成
    Python 代码：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After reading this sentence, you will associate the name “Susan E. McGregor”
    with the label “author.” If someone asks you who wrote this book, you will (hopefully)
    remember this and say “Susan E. McGregor.” The equivalent “sentence” in Python
    code is shown in [Example 2-2](#naming_variable).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读这句话后，你将会将“Susan E. McGregor”与标签“作者”关联起来。如果有人问你谁写了这本书，你（希望的话）会记住这个并说“Susan
    E. McGregor”。在 Python 代码中，相应的“句子”如[示例 2-2](#naming_variable)所示。
- en: Example 2-2\. Naming a Python variable
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-2\. 命名 Python 变量
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code tells the computer to set aside a box in memory, label it `author`,
    and then put the string `"Susan E. McGregor"` into that box. Later on in our program,
    if we asked the computer about the `author` variable, it would tell us that it
    contains the string `"Susan E. McGregor"`, as shown in [Example 2-3](#printing_variable).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码告诉计算机在内存中留出一个盒子，标记为`author`，然后将字符串`"Susan E. McGregor"`放入该盒子。在程序的后续部分，如果我们询问计算机关于`author`变量，它会告诉我们它包含字符串`"Susan
    E. McGregor"`，如[示例 2-3](#printing_variable)所示。
- en: Example 2-3\. Printing the contents of a Python variable
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-3\. 打印 Python 变量的内容
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What’s in a name?
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名字中有什么含义？
- en: 'In [Example 2-3](#printing_variable), I chose to name my variable `author`,
    but there is nothing magical about that choice. In principle, you can name variables
    almost anything you want—the only “hard-and-fast” rules are that variable names
    cannot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 2-3](#printing_variable)中，我选择将我的变量命名为`author`，但这个选择并没有什么神奇之处。原则上，你几乎可以按照任何你想要的方式命名变量——唯一的“硬性规则”是变量名不能：
- en: Begin with a digit
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以数字开头
- en: Contain punctuation marks other than underscores (`_`)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含除了下划线（`_`）之外的标点符号
- en: Be “reserved” words or “keywords” (like Number or Boolean, for example)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是“保留”字或“关键字”（比如 Number 或 Boolean，例如）
- en: For example, I could just as easily have called the variable in [Example 2-3](#printing_variable)
    `nyc_resident` or even `fuzzy_pink_bunny`. What matters most is that you, as the
    programmer, follow the few restrictions listed previously, *and* that you use
    *exactly* the same variable name when trying to access its contents later (capitalization
    counts!). For example, create a new Python file containing the code in [Example 2-4](#variable_names),
    and then run it to see what results you get.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 [示例 2-3](#printing_variable) 中，我也可以称变量为 `nyc_resident` 或者甚至 `fuzzy_pink_bunny`。最重要的是，作为程序员的你，遵循前面列出的一些限制，*并且*在稍后访问其内容时使用*完全相同*的变量名（大小写敏感！）。例如，创建一个包含
    [示例 2-4](#variable_names) 代码的新Python文件，然后运行它查看结果。
- en: Example 2-4\. noun_examples.py
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-4\. noun_examples.py
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Best practices for naming variables
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量命名的最佳实践
- en: 'While all of the examples used in [Example 2-4](#variable_names) are *legitimate*
    variable names, not all of them are especially *good* variable names. As we’ll
    see throughout this book, writing good code—like any other kind of writing—is
    about more than just writing code that “works”; it’s also about how useful and
    intelligible that code is to both computers *and* people. Because of this, I consider
    naming variables well an essential part of good programming. In practice, *good*
    variable names are:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 [示例 2-4](#variable_names) 中使用的所有示例都是*合法*的变量名，但并非所有都是特别*好*的变量名。正如我们在本书中将看到的那样，写好代码——就像任何其他写作一样——不仅仅是编写“可运行”的代码；它还关乎代码对计算机和人类的有用性和可理解性。因此，我认为良好命名变量是良好编程的重要组成部分。实际上，*好*的变量名包括：
- en: Descriptive
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述性的
- en: Unique (within a given file or program)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在给定文件或程序中唯一的
- en: Readable
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可读性强的
- en: Because achieving the first two properties often requires using more than one
    word, programmers typically use one of two stylistic conventions to help ensure
    that their variable names also remain *readable*, both of which are shown in [Example 2-4](#variable_names).
    One approach is to add underscores (`_`) between words (e.g., `nyc_residents`)
    or use “camel case,” in which the first letter of every word (except the first)
    is capitalized (e.g., `fuzzyPinkBunny`). In general, you should use one style
    and stick to it, though your code will work fine (and mostly meet the readability
    criteria) even if you mix them together. In this book, we’ll mostly use underscores,
    which also happen to be considered more “Pythonic.”
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因为实现前两个属性通常需要使用多个单词，程序员通常使用两种风格约定来确保其变量名也保持*可读性*，这两种风格都显示在 [示例 2-4](#variable_names)
    中。一种方法是在单词之间添加下划线 (`_`)（例如，`nyc_residents`），或者使用“驼峰命名法”，其中每个单词的首字母（除了第一个）大写（例如，`fuzzyPinkBunny`）。通常情况下，你应该选择一种风格并坚持使用它，尽管即使混合使用它们，你的代码也将正常工作（并且大多数情况下会满足可读性标准）。在本书中，我们将主要使用下划线，这也被认为更符合“Python风格”。
- en: Verbs ≈ Functions
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动词 ≈ 函数
- en: 'In the English language, verbs are often described as “actions” or “states
    of being.” We’ve already seen a programming language equivalent of the latter:
    the equals sign (`=`) and the `print()` function used in the preceding examples.
    In English, we use forms of the verb “to be” to describe what something *is*;
    in Python (and many other programming languages), the value of a variable *is*
    whatever appears on the righthand side of the equals sign. This is why the equals
    sign is also sometimes described as the *assignment operator*.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，动词通常被描述为“动作”或“存在状态”。我们已经看到了后者的编程语言等价物：等号 (`=`) 和在前面示例中使用的 `print()` 函数。在英语中，我们使用“to
    be”动词的形式来描述某物*是*什么；在Python（以及许多其他编程语言中），变量的值*是*等号右侧出现的内容。这也是为什么等号有时被描述为*赋值操作符*的原因。
- en: In programming, the equivalent of “action verbs” are *functions*. In Python
    and many other programming languages, there are *built-in functions*, which represent
    tasks—like printing output via the `print()` function—that the language “just
    knows” how to do. While similar, *methods* are special functions that are designed
    to work with a particular data type and need to be “called on” a variable of that
    data type in order to work. The methods available for a given data type tend to
    reflect common tasks you might want to perform with it. So just as most humans
    can walk, talk, eat, drink, and grasp objects, most programming languages have
    *string methods* that can do tasks like stick two strings together (known as *concatenation*),
    split two strings apart, and so on. But since it doesn’t make sense to “split”
    the number 5, the Number data type *doesn’t* have a `split()` method.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，“动作动词”的等价物是*函数*。在 Python 和许多其他编程语言中，有*内置函数*，它们表示语言“知道如何执行”的任务，例如通过`print()`函数输出结果。虽然类似，*方法*是专门设计用于特定数据类型并且需要在该数据类型的变量上“调用”的特殊函数以便工作。给定数据类型的可用方法往往反映了您可能希望执行的常见任务。因此，正如大多数人能够行走、说话、吃东西、喝水和抓取物体一样，大多数编程语言都有*字符串方法*，可以执行像将两个字符串粘合在一起（称为*连接*）或将两个字符串分开等任务。但由于在数字
    5 上“拆分”没有意义，数字数据类型*没有*`split()`方法。
- en: 'What is the difference between a built-in function and a method in practice?
    Not much, except for the way we include these “verbs” in our Python “sentences”
    or *statements*. With a built-in function, we can simply write the function name
    and pass along any “ingredients” it needs, by placing them between the round parentheses.
    For example, if you recall our [Example 1-1](ch01.html#hello_world_code), all
    we had to do was pass the string `Hello World!` to the `print()` function, like
    this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，内置函数和方法之间有什么区别？实际上并没有太大区别，除了我们在 Python “句子”或*语句*中包含这些“动词”的方式不同。对于内置函数，我们可以简单地写出函数名，并通过将它们放置在圆括号之间传递它所需的任何“参数”。例如，如果你回想一下我们的[示例 1-1](ch01.html#hello_world_code)，我们只需将字符串`Hello
    World!`传递给`print()`函数，就像这样：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the case of the `split()` method, however, *we have to attach the method
    to a specific string*. That string can either be a *literal* (that is, a series
    of characters surrounded by quotation marks), or it can be a variable whose value
    is a string. Try the code in [Example 2-5](#split_string) in a standalone file
    or notebook, and see what kind of output you get!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`split()`方法的情况下，*我们必须将方法附加到特定的字符串*上。该字符串可以是一个*文字*（即一系列被引号包围的字符），或者它可以是一个其值为字符串的变量。尝试在[示例 2-5](#split_string)中的代码文件或笔记本中执行，并查看您会得到什么样的输出！
- en: Example 2-5\. method_madness.py
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-5\. method_madness.py
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that if you try to run the `split()` method by itself or on a data type
    where it doesn’t make sense, you’ll get an error. Try each of these out in succession
    (or in two different cells if you’re using a notebook) and see what happens:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您尝试在不合适的数据类型或者没有意义的数据类型上运行`split()`方法，您将会收到一个错误。连续尝试这些操作（或者如果您使用笔记本，则在两个不同的单元格中），看看会发生什么：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Just like data types, methods and functions are recognizable thanks to their
    typography and punctuation. A built-in function (like `print()`) will turn a specific
    color in your code editor or notebook. In Atom’s default One Dark theme, for example,
    variable names are light gray, operators like `=` are purple, and built-in functions
    like `print()` are aqua. You can also recognize functions by their associated
    punctuation: anywhere you see text *immediately* followed by round parentheses
    (e.g., `print()`), you are looking at a function. The same is true of methods,
    except that these are always preceded by an appropriate data type or variable
    name, and separated from it by a period (`.`).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据类型一样，方法和函数因其排版和标点而容易识别。内置函数（如`print()`）在代码编辑器或笔记本中会显示特定的颜色。例如，在 Atom 的默认
    One Dark 主题中，变量名为浅灰色，操作符如`=`为紫色，内置函数如`print()`则为青色。您还可以通过它们的相关标点来识别函数：任何您看到的文本*紧接*在圆括号后面（例如`print()`），您都在看一个函数。方法也是如此，只是它们总是在适当的数据类型或变量名称之前，并通过一个句点(`.`)与之分隔。
- en: In a programming language like Python, you can actually get a fair bit done
    with just operators, methods, and built-in functions—especially if you are mostly
    doing tasks like basic math. When it comes to data wrangling, however, we need
    a little bit more sophistication. In exactly the same way we can think about complex
    tasks like playing a piano or kicking a ball as “just” a careful combination of
    many simpler actions—like moving our fingers or feet, for example—very sophisticated
    programming functions can be built by thoughtfully composing relatively simple
    operators, methods, and built-in functions. These *user-defined functions* are
    where we can start to really amplify the power of our code by making what are
    essentially code “recipes” that can be used again and again.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s say we wanted to print out the same greeting to two different
    people. We could simply use the `print()` function as we have been, as shown in
    [Example 2-6](#two_prints).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-6\. basic_greeting.py
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are a couple of things to notice about the code in [Example 2-6](#two_prints).
    First, using the `print()` function works just fine; this code totally gets the
    job done. And that’s great! The first time we write code for something (including
    a given data wrangling task), that’s pretty much our main goal: get it to work
    correctly.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve accomplished that, though, we can start to think about some simple
    ways to make our code “cleaner” and more useful. In the previous example, the
    two print statements are identical, except for the variable being used. Any time
    we see this type of repetition in our code, it’s a clue that we may want to make
    our own user-defined function instead, as in [Example 2-7](#greet_me).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-7\. greet_me.py
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Pretty nifty, right? In some ways, we didn’t change much at all—but there’s
    actually quite a lot going in [Example 2-7](#greet_me). We’ll take a few moments
    now to highlight some of the new concepts being used here, but don’t worry if
    it doesn’t all make sense right away—we’ll continue to revisit these ideas throughout
    the book.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The main thing we’ve done in [Example 2-7](#greet_me) is write our first custom
    function, `greet_me()`. We did this by using a few different syntax structures
    and typographic indicators to let the computer know that we want it to create
    and remember this function for future use. Some of these conventions match what
    we’ve already seen for creating our own custom variables (for example, using the
    descriptive name `greet_me()`), as well as the conventions of built-in functions
    and methods, like following the name of our function immediately with round parentheses
    (`()`).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 2-1](#function_structure_diagram), I’ve diagrammed the code for our
    `greet_me()` function in order to highlight what’s happening on each line.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![Components of a custom function](assets/ppdw_0201.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Components of a custom function
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As you can see from [Figure 2-1](#function_structure_diagram), creating a custom
    function means including multiple signposts to the computer:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，从[图 2-1](#function_structure_diagram)可以看出，创建自定义函数意味着向计算机包括多个指标：
- en: The `def` keyword (short for *def*ine) tells the computer that what comes next
    is a function name.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def`关键字（缩写*def*ine）告诉计算机接下来是一个函数名。'
- en: The round parentheses immediately following the function name reinforce that
    this is a function and are used to enclose the function’s *parameters* (if there
    are any).
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即跟在函数名后面的圆括号强调这是一个函数，并用于包围函数的*参数*（如果有的话）。
- en: The colon (`:`) indicates that the indented lines of code that follow are part
    of the function.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒号（`:`）表示接下来缩进的代码行是函数的一部分。
- en: If we want to access the variable that was passed into our function as an *argument*,
    we use the “local” *parameter* name that appears between the round parentheses
    in the function definition.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想访问作为*参数*传递给我们函数的变量，我们使用函数定义中圆括号之间出现的“局部”*参数*名称。
- en: We can use any type of functions (both built-in and custom) or methods *inside*
    our custom function. This is key strategy for building efficient, flexible code.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在我们的自定义函数中使用任何类型的函数（包括内置和自定义）或方法*内部*。这是构建高效、灵活代码的关键策略。
- en: When it comes to using or “calling” our function, we can simply write the name
    of the function (`greet_me()`), making sure that we put the same number of “ingredients”
    between the parentheses that appear in the function definition. Since we have
    defined `greet_me()` to take exactly *one* argument “ingredient” (in this case,
    the `a_name` parameter), we have to provide *exactly* one argument when we want
    to use it—otherwise, we’ll get an error.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到使用或“调用”我们的函数时，我们只需写函数名（`greet_me()`），确保在括号中放入与函数定义中出现的“配料”数量相同即可。由于我们定义了`greet_me()`函数仅接受*一个*参数“配料”（在这种情况下是`a_name`参数），当我们想要使用它时，必须提供*恰好*一个参数，否则将会出错。
- en: Cooking with Custom Functions
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义函数进行烹饪
- en: As you may have noticed, I like to think of user-defined or “custom” functions
    as programming “recipes.” Like food recipes, they provide the computer with reusable
    instructions for transforming one or more raw data “ingredients” into some other
    useful resource. Sometimes there is only one parameter or “ingredient,” as in
    our `greet_me()` recipe; sometimes there are many parameters of many different
    data types. There’s no strictly “right” or “wrong” way to write a custom function—much
    as there’s no right or wrong way to write a cooking recipe; everyone will have
    their own style. At the same time, when it comes to strategies for deciding what
    should go into a given function, it can help to think about how we tend to use
    (or maybe even write!) recipes for cooking food.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，我喜欢将用户定义的或“自定义”函数看作编程的“食谱”。像食谱一样，它们为计算机提供了将一个或多个原始数据“配料”转换为其他有用资源的可重复使用指令。有时只有一个参数或“配料”，就像我们的`greet_me()`食谱中一样；有时有多个参数，类型各异。写自定义函数没有严格的“对”或“错”—就像写烹饪食谱一样；每个人都有自己的风格。同时，当决定应该将什么放入给定函数时的策略，可以考虑我们通常如何使用（甚至可能编写！）烹饪食谱。
- en: For example, it’s obviously *possible* to write a single cooking recipe called
    “Thanksgiving” that describes how to make an entire holiday meal from start to
    finish. Depending on your holiday style, it might take anywhere from 2 to 72 hours
    to “run,” and it would be very useful once a year—and almost never otherwise.
    If you *did* want to make just part of that massive recipe—perhaps you want to
    serve your Thanksgiving mashed potatoes at New Year’s—you’d first have to dig
    through the Thanksgiving instructions to identify and piece together *just* the
    ingredients and steps for making mashed potatoes. That would mean investing a
    lot of work before you ever even got cooking!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，显然可以*可能*编写一个称为“感恩节”的单一烹饪食谱，描述如何从头到尾制作整个假日大餐。根据你的假日风格，可能需要2到72小时“运行”，每年一次非常有用—其他时候几乎从不使用。如果你*确实*只想制作那个庞大食谱的一部分—也许你想在新年时享用感恩节的土豆泥—你首先必须查找感恩节的说明，识别并组合*只有*制作土豆泥的配料和步骤。这意味着在你开始烹饪之前要投入大量工作！
- en: So while we want our custom functions to do things that are *somewhat* more
    complex than what the computer can do already, we generally don’t want them to
    be truly *complicated*. Like a “Thanksgiving” recipe, making giant functions (or
    even programs) limits how effectively they can be reused. Creating simple, focused
    functions actually makes our code more useful and flexible in the long run—a process
    we’ll explore in more detail in [Chapter 8](ch08.html#chapter8).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然我们希望我们的自定义函数比计算机已经能够做的*稍微*复杂一些，但我们通常不希望它们真正*复杂*。就像“感恩节”食谱一样，制作巨大的函数（甚至程序）会限制它们在多大程度上可以被重复使用。实际上，创建简单而专注的函数会使我们的代码在长远来看更加有用和灵活——这是我们将在[第8章](ch08.html#chapter8)中详细探讨的一个过程。
- en: 'Libraries: Borrowing Custom Functions from Other Coders'
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库：从其他编程者那里借用自定义函数
- en: 'If custom functions are programming recipes, then *libraries* are programming
    cookbooks: large collections of *other people’s* custom functions that *we* can
    use to transform our raw data ingredients without having to figure out and write
    our own recipe “from scratch.” As I mentioned in [Chapter 1](ch01.html#chapter1),
    the large community of coders who have written useful Python libraries is one
    of the reasons we’re using Python in the first place—and as you’ll see in [“Hitting
    the Road with Citi Bike Data”](#hitting_the_road_intro) at the end of this chapter,
    using them is both useful and powerful.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自定义函数是编程配方，那么*库*就是编程食谱书：大量*其他人*编写的自定义函数的集合，*我们*可以用来转换我们的原始数据成分，而不必从零开始想出并编写我们自己的配方。正如我在[第1章](ch01.html#chapter1)中提到的那样，编写有用的Python库的大社区是我们首先选择使用Python的原因之一——正如你将在本章末尾的[“使用Citi
    Bike数据踏上旅途”](#hitting_the_road_intro)中看到的那样，使用它们既有用又强大。
- en: 'Before we can really take advantage of libraries, however, we need to cover
    two more essential grammatical structures of Python: *loops* and *conditionals*.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们真正利用库之前，我们需要掌握Python的另外两个基本语法结构：*循环*和*条件语句*。
- en: 'Taking Control: Loops and Conditionals'
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌控：循环和条件语句
- en: 'As we have discussed, writing Python code is similar to writing in English
    in many ways. In addition to relying on some basic “parts of speech,” Python code
    is written from left to right and read essentially from top to bottom. But the
    path that the computer takes through a data wrangling program is much more like
    a [“Choose Your Own Adventure” book](https://en.wikipedia.org/wiki/Choose_Your_Own_Adventure)
    than a traditional essay or article: depending on the commands that you, as the
    programmer, provide, some bits of code may be skipped or repeated based on your
    data or other factors.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，编写Python代码在许多方面与用英语写作相似。除了依赖一些基本的“词类”之外，Python代码是从左到右编写并且基本上是从上到下阅读的。但计算机在数据整理程序中的路径更像是[“选择你自己的冒险”书](https://zh.wikipedia.org/wiki/选择你自己的冒险)而不是传统的论文或文章：根据程序员——也就是你提供的命令，一些代码片段可能会根据数据或其他因素被跳过或重复执行。
- en: In the Loop
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在循环中
- en: 'When we’re data wrangling with Python, one of our most common goals will be
    to do *something* to every record in a dataset. For example, let’s say we wanted
    to add together a list of numbers to find their sum:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用Python进行数据整理时，我们最常见的目标之一是对数据集中的每条记录做*某些*处理。例如，假设我们想要对一组数字进行求和以找到它们的总和：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you needed to total a group of numbers like this without programming, you
    would have several options: you could use the calculator program on a computer,
    a physical calculator, or even (gasp!) a pencil and paper. If you know how to
    use a spreadsheet program, you could enter each data item there and use a `SUM()`
    function, too. For short lists, any of these solutions would probably be fine,
    but they don’t *scale* well: sure, adding up 10 numbers by hand (or by calculator)
    might not take too long, but adding up 100 numbers would. The spreadsheet solution
    is somewhat better in terms of time, but it still requires a number of external
    steps—like copying and pasting the data into a spreadsheet and more or less manually
    selecting which rows or columns should be summed. With a programmatic solution,
    we can avoid almost all of those drawbacks—and whether we need to add 10 rows
    or 10 million, it will take no more work on our part, and only slightly longer
    for the computer to actually calculate.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在没有编程的情况下对一组数字进行求和，你有几个选择：你可以使用计算机上的计算器程序，实体计算器，或者甚至（哇！）一支铅笔和纸。如果你知道如何使用电子表格程序，你可以在那里输入每个数据项并使用`SUM()`函数。对于较短的列表，这些解决方案可能都还好，但它们不适合*扩展*：当然，手工（或计算器）加起来10个数字可能不会花费太长时间，但加起来100个数字就不同了。在时间上电子表格解决方案要好一些，但它仍然需要许多外部步骤——比如将数据复制粘贴到电子表格中，并基本手动选择应该加总的行或列。通过编程解决方案，我们几乎可以避免所有这些缺点——无论我们需要加总10行还是10百万行，我们的工作量几乎没有增加，计算机实际计算的时间也只会略微延长。
- en: Because programming is still writing, of course, there are multiple ways we
    can express the instructions we give to the computer. One way is to have the computer
    look at each number in the list and keep a running total, as shown in [Example 2-8](#pagecount_loop).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，因为编程仍然是在编写，我们可以表达给计算机的指令有多种方式。一种方式是让计算机查看列表中的每个数字并保持运行总数，就像在[示例 2-8](#pagecount_loop)中所示的那样。
- en: Example 2-8\. page_count_loop.py
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-8\. page_count_loop.py
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Before we look at some other ways we could tell the computer to do this task,
    let’s break down [Example 2-8](#pagecount_loop). Obviously, we start with the
    list of numbers. Next, we create a variable to keep track of `total_pages`, to
    which we have to explicitly assign a value of `0` to start out (most calculator
    programs do this more or less implicitly). Finally, we begin going through our
    list:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨其他可能告诉计算机执行此任务的方式之前，让我们先分解[示例 2-8](#pagecount_loop)。显然，我们从数字列表开始。接下来，我们创建一个变量来跟踪`total_pages`，我们必须显式地为其分配一个起始值`0`（大多数计算器程序会更或多少隐式地执行此操作）。最后，我们开始遍历我们的列表：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To me, the easiest way to understand this line of code is to say it out loud
    like an English sentence: “For every `a_number` in the list, `page_counts` do
    the following.” And in fact, that’s exactly what happens. For every item in the
    `page_counts` list, the computer follows the instructions in the code indented
    under the `for...in...:` statement. In this case, that means adding together the
    current value of `total_pages` and the value of `a_number` and storing that back
    in `total_pages` again.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这行代码最简单的方法是像读英文句子一样大声说出来：“对于列表中的每个`a_number`，`page_counts`执行以下操作。”实际上，事情就是这样的。对于`page_counts`列表中的每个项目，计算机都会按照缩进在`for...in...:`语句下的代码指令执行。在这种情况下，这意味着将`total_pages`的当前值与`a_number`的值相加，并将结果再次存储回`total_pages`中。
- en: 'In some ways, this is straightforward: we’ve already told the computer, very
    explicitly, the values of both `page_counts` (that’s our list of numbers) and
    `total_pages`. But what about `a_number`? Where did that come from, and how does
    the computer know where to find it?'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，这是很直接的：我们已经非常明确地告诉计算机了`page_counts`（这是我们的数字列表）和`total_pages`的值。但`a_number`呢？它从哪里来的，计算机如何知道在哪里找到它？
- en: 'Like the `print()` statement or the `def...function_name():` construction,
    the `for...in...:` configuration is built into the Python language, which is why
    we don’t have to give it quite as many instructions as we usually will when coding.
    In this case, what we have to provide the `for...in...:` statement to work are
    two things: a list-like variable (in this case, `page_counts`) and a name that
    the computer can use to refer to the current item in the list (in this case, `a_number`),
    as shown in [Figure 2-2](#for_loop_diagram).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 像`print()`语句或`def...function_name():`结构一样，`for...in...:`配置内置于Python语言中，这就是为什么在编码时我们不必给它那么多指示。在这种情况下，`for...in...:`语句要提供的两个东西是：一个类似列表的变量（在本例中是`page_counts`）和计算机用来引用列表中当前项目的名称（在本例中是`a_number`），如[图
    2-2](#for_loop_diagram)所示。
- en: '![Structure of a `for` loop.](assets/ppdw_0202.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![`for`循环的结构。](assets/ppdw_0202.png)'
- en: Figure 2-2\. Structure of a `for` loop
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. `for`循环的结构
- en: As with all variable names, there is nothing “magic” about the variable name
    `a_number`—I thought that was a good option because it’s descriptive and readable.
    What matters is that when I want the computer to do something with each list item,
    the variable name I use in my indented code has to match what I’ve written in
    that top `for...in...:` statement.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有变量名称一样，变量名称`a_number`没有任何“魔力”——我认为这是一个很好的选择，因为它具有描述性和可读性。重要的是，当我希望计算机对每个列表项执行某些操作时，我在缩进代码中使用的变量名称必须与我在顶部`for...in...:`语句中编写的名称相匹配。
- en: In programming lingo, this `for...in...:` construction is known as a *for loop*—and
    every commonly used programming language has one. The reason why it’s known as
    a “loop” is because for every item in the list provided, the computer runs every
    relevant line of code—in the case of Python, every indented line below the `for...in...:`
    statement—and then moves to the next item and “loops” back to the first indented
    line of code again. This is a little hard to see when our “loop” only has one
    line of code, so let’s add a few more lines to better illustrate what’s going
    on, as shown in [Example 2-9](#page_loop).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程术语中，这种`for...in...:`结构被称为*for循环*，并且每种常用的编程语言都有它。之所以称为“循环”，是因为对于提供的列表中的每个项目，计算机都会运行每一行相关的代码——在Python中的情况下，是`for...in...:`语句下的每一行缩进的代码——然后移动到下一个项目并再次“循环”回第一行缩进的代码。当我们的“循环”只有一行代码时，这有点难以看到，因此让我们添加几行代码来更好地说明正在发生的情况，如[示例
    2-9](#page_loop)所示。
- en: Example 2-9\. page_count_printout.py
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-9\. page_count_printout.py
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'By now you might be thinking, “This seems like a lot of work just to sum a
    list of numbers.” And there is, of course, a more efficient way to complete this
    *specific* task: Python has a built-in `sum()` function that will take our list
    of numbers as an argument ([Example 2-10](#pagecounts_sum)).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能会想：“这似乎是为了对一组数字求和而做很多工作。”当然，有一种更有效的方法来完成这个*特定*任务：Python有一个内置的`sum()`函数，它将接受我们的数字列表作为参数（见[示例
    2-10](#pagecounts_sum)）。
- en: Example 2-10\. Using the `sum()` function
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-10\. 使用`sum()`函数
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](assets/1.png)](#co_introduction_to_python_CO1-1)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_to_python_CO1-1)'
- en: Try adding this to your existing program on your own!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己将其添加到现有程序中！
- en: Even though we could have used the `sum()` function from the start, I took this
    opportunity to introduce `for` loops, for a couple of reasons. First, because
    it’s a good reminder that even when it comes to simple programming tasks, there’s
    always more than one approach. Second, because `for` loops are an essential part
    of data wrangling (and, really, all programming), `for...in...:` loops are one
    of the key tools we’ll use to filter, evaluate, and reformat data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们从一开始就可以使用`sum()`函数，我也利用这个机会介绍了`for`循环，有几个原因。首先，因为这是一个很好的提醒，即使是对于简单的编程任务，也总会有不止一种方法。其次，因为`for`循环是数据整理（实际上是所有编程）的重要部分，`for...in...:`循环是我们将用于过滤、评估和重新格式化数据的关键工具之一。
- en: One Condition…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个条件…
- en: 'The `for` loop gives us a straightforward way to look at every item in a dataset,
    but data wrangling requires making *decisions* about our data as well. Usually,
    that means evaluating some aspect of the data and doing one thing if the data
    has a certain value and otherwise something (or nothing!) else. For example, what
    if we wanted to know how many chapters in this book have more than 30 pages and
    how many have fewer than 30 pages? We’d need a way to:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环为我们提供了查看数据集中每个项目的简单方法，但数据整理还需要对数据做出*决策*。通常情况下，这意味着评估数据的某些方面，并根据数据的特定值执行某些操作（或什么也不做）。例如，如果我们想知道这本书有多少章节超过30页，有多少少于30页，我们需要一种方法来：'
- en: Check whether a particular number in our `page_counts` list is more than 30.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查我们`page_counts`列表中特定数字是否超过30。
- en: Add 1 to an `over_30` counter if it’s more than 30.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果超过30，则将`over_30`计数器加1。
- en: Otherwise, add 1 to our `under_30` counter.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，将1添加到我们的`under_30`计数器中。
- en: 'Fortunately, Python has a built-in grammatical structure for doing exactly
    this kind of evaluation and decision-making: the `if...else` statement. Let’s
    see how it works by modifying the `for` loop in [Example 2-9](#page_loop) to also
    track the number of chapters that are more and less than 30 pages.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python具有一种内置的语法结构，可以做到这种类型的评估和决策：`if...else`语句。让我们通过修改[示例 2-9](#page_loop)中的`for`循环来看看它是如何工作的，以跟踪超过和少于30页的章节数量。
- en: Example 2-11\. page_count_conditional.py
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-11\. page_count_conditional.py
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As with `for` loops, I think the easiest way to understand what’s happening
    in an `if...else` conditional is to say it out loud as a sentence (and, just as
    importantly, write that sentence in the comments of your code): “`if` the current
    number of pages is more than 30, add one to the `over_30` counter. Otherwise (`else`),
    add one to the `under_30` counter.”'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与`for`循环一样，理解`if...else`条件语句中正在发生的事情最简单的方法是大声说出来（并且同样重要的是，在代码的注释中写下这个句子）：“`if`当前页数大于30，则将`over_30`计数器加一。否则（`else`），将`under_30`计数器加一。”
- en: While hopefully this makes some sense intuitively, I want to slow down again
    and go through what’s happening in a bit more detail, since `if...else` statements
    are another programming structure that we’ll come back to over and over.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个直觉上是有点意义的，但我想再次放慢脚步，更详细地讲解一下正在发生的事情，因为`if...else`语句是我们将反复使用的另一种编程结构。
- en: 'First, let’s look at the indenting structure of the preceding example: everything
    that’s part of the `for` loop is indented one tab from the left margin; that’s
    how the computer knows that code is “inside” that loop. Similarly, the code that
    belongs to each part of the `if...else` statement is indented one tab *more*.
    In Python, this process of progressive indentation is actually *required* for
    the code to work properly—if the indenting isn’t correct, Python will complain.^([2](ch02.html#idm45143426063952))
    This mechanism is often referred to as *nesting*. A more visual way to think about
    what’s happening is shown in [Figure 2-3](#loop_nesting_diagram).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下前面示例的缩进结构：所有属于`for`循环的代码从左边缘缩进一个制表符；这是计算机知道该代码“在”该循环内部的方式。类似地，属于`if...else`语句的每个部分的代码再次缩进一个制表符。在Python中，这种逐步缩进的过程实际上是*必需的*，否则代码将无法正常工作—如果缩进不正确，Python会抱怨。^([2](ch02.html#idm45143426063952))
    这种机制通常称为*嵌套*。更直观地理解正在发生的事情的一种方法显示在[图 2-3](#loop_nesting_diagram)中。
- en: '![A Venn-style diagram of code nesting.](assets/ppdw_0203.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![代码嵌套的文氏图](assets/ppdw_0203.png)'
- en: Figure 2-3\. Code “nesting”
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-3\. 代码“嵌套”
- en: There are a number of implications of nesting that we’ll address later in this
    book, but the main takeaway for now is that in order to make a line of code “belong”
    to a function, loop, or conditional, *it must be indented one tab to the right
    of the structure you want it to be part of*. To see this in action, let’s bring
    together everything we’ve done up to this point to create a Python program that
    uses a loop, a conditional, and a custom-defined function, as shown in [Example 2-12](#page_counts_complete).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的几个含义我们将在本书的后面进行探讨，但现在的主要要点是为了使一行代码“属于”一个函数、循环或条件语句，*它必须缩进到比您想要它属于的结构右边缩进一个制表符的位置*。为了看到这一点的实际效果，让我们把到目前为止我们所做的一切集成起来，创建一个使用循环、条件语句和自定义定义的函数的Python程序，如[示例 2-12](#page_counts_complete)所示。
- en: Example 2-12\. page_count_custom_function.py
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-12\. page_count_custom_function.py
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_introduction_to_python_CO2-1)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_to_python_CO2-1)'
- en: We can “wrap” our existing code into a new function (here called `count_​pages()`)
    by indenting one tab and adding the function definition line.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过缩进一个制表符并添加函数定义行将我们现有的代码“包装”到一个新函数中（这里称为`count_pages()`）。
- en: '[![2](assets/2.png)](#co_introduction_to_python_CO2-2)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_introduction_to_python_CO2-2)'
- en: We have to match the name of the list variable the `for` loop references to
    the parameter name provided between the round parentheses in the function definition
    in ![1](assets/1.png).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将`for`循环引用的列表变量名称与函数定义中圆括号之间提供的参数名称匹配，这一点在![1](assets/1.png)中已经提到。
- en: '[![3](assets/3.png)](#co_introduction_to_python_CO2-3)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_introduction_to_python_CO2-3)'
- en: A function does not *do* anything until it is actually *called* or *executed*.
    At this point, we need to provide it with the specific argument/ingredient we
    want it to work on.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在实际*调用*或*执行*之前并不执行任何操作。在这一点上，我们需要为其提供我们希望其处理的具体参数/参数。
- en: 'If you compare [Example 2-12](#page_counts_complete) to [Example 2-11](#page_counts),
    you’ll see that I actually just copied the code from [Example 2-11](#page_counts)
    and did three things:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将[示例 2-12](#page_counts_complete)与[示例 2-11](#page_counts)进行比较，你会发现我实际上只是从[示例 2-11](#page_counts)复制了代码，并做了三件事：
- en: I added the function defining statement `def count_pages(page_count_list):`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我添加了函数定义语句`def count_pages(page_count_list):`。
- en: I indented all the existing code one additional tab so that the computer views
    it as “belonging” to our new `count_pages()` function. In Atom, you can do this
    all at once by highlighting all the lines of code you want to move and hitting
    the Tab key. I also updated the variable referenced at the top of the `for` loop
    to match the parameter name provided between the round parentheses on the `def`
    line of the function.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我将所有现有代码都缩进了一个额外的制表符，以便计算机将其视为“属于”我们新的`count_pages()`函数。在Atom中，你可以通过高亮显示要移动的所有代码行并按Tab键来一次性完成这个操作。我还更新了`for`循环顶部引用的变量，使其与函数`def`行中圆括号内提供的参数名匹配。
- en: I made sure to “call” the function at the end, giving it the `page_counts` variable
    as an “ingredient” or *argument*. Notice that the `count_pages(page_counts)` statement
    isn’t indented at all.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我确保在最后“调用”了函数，将`page_counts`变量作为“成分”或*参数*传递给它。请注意，`count_pages(page_counts)`语句根本没有缩进。
- en: Hopefully, you’re starting to get a little bit of a handle on how all this fits
    together. Before we start using these tools to do some real-world data wrangling,
    though, we need to spend some time talking about what happens when code goes wrong.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你开始逐渐理解所有这些是如何结合在一起的。不过，在我们开始使用这些工具进行一些真实世界的数据处理之前，我们需要花些时间讨论当代码出现问题时会发生什么。
- en: Understanding Errors
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解错误
- en: 'As we’ve mentioned in [Chapter 1](ch01.html#chapter1), computers are *very*
    good at doing repetitive tasks quickly (and usually accurately). This lets us
    write programs that *scale* well: the same code that can sum or sort a list that’s
    10 items long (like our `page_counts` example) can also be used pretty effectively
    on a list that’s 10,000 items long.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](ch01.html#chapter1)中提到的，计算机非常擅长快速执行重复的任务（通常也很准确）。这使得我们能够编写可以很好*扩展*的程序：能够对包含10项的列表（如我们的`page_counts`示例）进行求和或排序的相同代码也可以相当有效地用于包含10,000项的列表。
- en: 'At the same time, however, computers are truly, importantly, and irretrievably
    stupid. Computers can’t really infer or innovate—they can only choose paths through
    their code based on the instructions and data that humans provide to them. As
    a result, there are many ways in which writing code is like giving instructions
    to a toddler: you have to be extremely literal and very explicit, and if something
    unexpected happens, you should expect a tantrum.^([3](ch02.html#idm45143428265504))'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与此同时，计算机确实、重要且不可挽回地愚蠢。计算机无法真正推断或创新——它们只能根据人类提供给它们的指令和数据选择其代码路径。因此，写代码与给幼儿下指令非常相似：你必须非常字面和非常明确，如果发生意外，你应该期待一场发脾气。^([3](ch02.html#idm45143428265504))
- en: 'For example, when humans encounter a spelling or grammatical error in a written
    sentence, we often don’t even notice it: based on the context of the surrounding
    sentence or paragraph, much of the time we’ll infer the appropriate meaning without
    even really trying. In fact, even if almost *all* of the letters in *all* of the
    words in a sentence are rearranged, we can uusally siltl raed it wihtuot too mcuh
    erfoft.^([4](ch02.html#idm45143428263280)) Computers, by contrast, will just complain
    loudly and stop reading altogether if your code has even a comma out of place.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当人类在书面句子中遇到拼写或语法错误时，我们通常甚至不会注意到它：根据周围句子或段落的上下文，大部分时间我们会在不费力气的情况下推断出适当的意思。事实上，即使一个句子中几乎*所有*单词中的*所有*字母都被重新排列，我们通常也能够毫不费力地阅读出来。^([4](ch02.html#idm45143428263280))
    相比之下，计算机只会大声抱怨并停止读取，如果你的代码中有一个逗号错位的话。
- en: 'Because of this, errors in programming aren’t just inevitable, they’re *expected*.
    No matter how much you program, any chunk of code you write that’s longer than
    a few lines will have errors in it of one kind or another. Rather than worrying
    about how to *avoid* errors, it is much more useful to learn how to *interpret*
    and *correct* errors. Throughout this book, I will at times intentionally generate
    errors (or encourage you to do so, as in [“Fast Forward”](#greet_me_ff) and [“Fast
    Forward”](#loop_errors)) so that you can get familiar with them and begin to develop
    your own process for working through them. As a starting point, we’ll discuss
    the three main *types* of errors that occur in programming: syntax errors, runtime
    errors, and logic errors.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，编程中的错误不仅是不可避免的，而且是*预期的*。无论你编程多少，你写的任何代码块，只要超过几行，都会有各种类型的错误。与其担心如何*避免*错误，学习如何*解释*和*纠正*错误会更有用。在本书中，我有时会故意制造错误（或者鼓励你这样做，如在[“快进”](#greet_me_ff)和[“快进”](#loop_errors)中），这样你就可以熟悉它们，并开始制定自己的处理过程。作为起点，我们将讨论编程中发生的三种主要*类型*错误：语法错误、运行时错误和逻辑错误。
- en: Syntax Snafus
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法问题
- en: 'Grammatical or *syntax* errors in programming may simultaneously be the simplest
    and most frustrating type of error you’ll encounter—in part because they happen
    very frequently and because the computer complains loudly about them. The example
    I gave earlier about a comma being out of place is an example of a syntax error:
    in one way or another, your code has violated the grammatical rules of the programming
    language.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中的语法错误或*语法*错误可能同时是你遇到的最简单和最令人沮丧的错误类型之一——部分原因是它们非常频繁发生，而计算机对此却表现得非常吵闹。我之前提到的逗号错位的例子就是语法错误的一个例子：在某种程度上，你的代码违反了编程语言的语法规则。
- en: 'The reason I describe these errors as “simple” is that they almost always are.
    In my experience, most syntax errors—and, by extension, programming errors—are
    basically typos: a comma or quotation mark gets forgotten, or a line of code gets
    indented too much or not enough. Unfortunately, many newer programmers I’ve worked
    with seem to find these errors especially frustrating precisely because they are
    simple—and because they feel silly for making them.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这些错误描述为“简单”的原因是它们几乎总是如此。在我的经验中，大多数语法错误——甚至可以推广到编程错误——基本上都是笔误：逗号或引号被遗忘，或者一行代码的缩进过多或不足。不幸的是，许多我合作过的新手程序员似乎特别对这些错误感到沮丧，正是因为它们简单——因为他们觉得自己犯了这些错误很愚蠢。
- en: In truth, experienced programmers experience syntax errors all the time. If
    you’re just starting out, the main thing you can learn from syntax errors is how
    *not* to let them derail you. In fact, one of the reasons why I’ve included the
    preceding “Fast Forward” sections on how to “break” your code intentionally is
    to help illustrate how easily errors can happen—and be fixed. In some ways one
    of the greatest skills you’ll learn when programming is how to be wrong a *lot*
    and not let it discourage you.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，经验丰富的程序员一直在经历语法错误。如果你刚开始学习，你可以从语法错误中学到的主要一点是如何*不*让它们让你步步后退。事实上，我在前面的“快进”部分中故意介绍如何故意“破坏”代码的原因之一，就是帮助说明错误是如何容易发生和被修复的。在编程时，你将学到的最重要的技能之一就是如何频繁地犯错，但不要因此而灰心。
- en: 'If you run a piece of code that has a syntax error, you’ll know because the
    last line of the (usually multiline) error message will say `SyntaxError`. But
    more useful than this when actually *fixing* the error will be the part of the
    error message that tells you *which file* the error is in and *which line* the
    error is on. Over time, just going to that line of code and looking for problems
    (typically missing punctuation: commas, brackets, colons, and quotation marks)
    will be enough for you to spot what’s wrong. While the error message will also
    include the (presumably) offending line of code with a caret (`^`) below the spot
    where Python believes the missing character might belong, this isn’t foolproof.
    For instance, [Example 2-13](#object_error) shows a Python `dict` that is missing
    a comma on one line.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行的代码出现语法错误，你会知道，因为（通常是多行）错误消息的最后一行会显示`SyntaxError`。但比起这个，更实用的是错误消息中告诉你错误出现在*哪个文件*和*哪一行*的部分，在实际*修复*错误时更为重要。随着时间的推移，只需转到那行代码并查找问题（通常是缺少标点：逗号、括号、冒号和引号）就足以发现问题所在。尽管错误消息还会包括（可能）有问题的代码行，并在Python认为缺少字符的地方下方标注一个插入符（`^`），但这并非万无一失。例如，[示例 2-13](#object_error)
    展示了一个Python `dict` 缺少一行上的逗号的情况。
- en: Example 2-13\. Introducing an error
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-13\. 引入错误
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And here is the error output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是错误输出：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, even though the code in [Example 2-13](#object_error) is missing
    a comma after the value `"book"` on line 4, the computer reports the error as
    being on line 5 (because that’s the point at which the computer has realized there
    is a problem). In general, though, you can usually find a syntax error on the
    line (or the line before) wherever the computer has reported it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，尽管[示例 2-13](#object_error) 中的代码在第4行值`"book"`后缺少逗号，计算机却报告错误发生在第5行（因为计算机在那时意识到有问题）。总的来说，通常可以在计算机报告错误的行（或前一行）找到语法错误。
- en: Runtime Runaround
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时困扰
- en: 'A *runtime* error in programming is used to describe any type of problem that
    crops up in the process of “running” or *executing* your code. Like syntax errors,
    a large portion of runtime errors are *also* essentially typos, such as incorrectly
    copied variable names. For example, anytime you see an error that includes the
    phrase *`some_variable`* `is not defined`, you’ve almost certainly got mismatched
    variable names somewhere in your code (remember: capitalization counts!). Since
    reading the entire “traceback” error can get a little convoluted (they tend to
    reference the inner workings of the Python programming language more than I, personally,
    find strictly useful), I recommend copying the variable name directly from the
    error and then doing a case-*insensitive* search for it in your code (this is
    the default behavior in Atom). This approach will highlight similar (but not *quite*
    identical) spellings of a variable name, speeding up your search for the mismatch.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中的*运行时*错误用于描述在“运行”或*执行*代码过程中出现的任何问题。与语法错误一样，运行时错误的很大一部分实质上也是拼写错误，例如错误复制的变量名称。例如，每当你看到一个包含短语*`some_variable`*
    `is not defined`的错误时，几乎可以肯定你的代码中有不匹配的变量名称（记住：大小写敏感！）。由于阅读整个“回溯”错误可能会有点复杂（它们倾向于引用Python编程语言的内部工作方式，而我个人认为这并不十分有用），建议直接从错误中复制变量名，然后在代码中进行大小写*不敏感*搜索（这是Atom的默认行为）。这种方法将突出显示变量名的类似（但*不完全*相同）拼写，加快查找不匹配的速度。
- en: For example, in [Example 2-14](#param_mismatch) the parameter name provided
    in the function definition for `greet_me(a_name)` doesn’t *precisely* match what’s
    used within the body of the function definition on the next line.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[示例 2-14](#param_mismatch) 中，函数定义中提供给`greet_me(a_name)`的参数名称与后续代码体中使用的名称*并不完全*匹配。
- en: Example 2-14\. Slightly mismatched variable names will generate runtime errors
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-14\. 稍微不匹配的变量名称会生成运行时错误
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Because the parameter name that appears inside the round parentheses of the
    function definition always takes precedence, running the code in [Example 2-14](#param_mismatch)
    generates the following error:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因为函数定义圆括号内部出现的参数名称始终优先，运行[示例 2-14](#param_mismatch) 中的代码会生成以下错误：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that, as usual, the last few lines of the error message are giving us the
    most helpful information. The last line lets us know that we’re trying to use
    the variable name `A_name` without having defined it first, and the line above
    contains the actual code where it appears. With these two pieces of information
    (plus our search strategy), it probably won’t take too long before we see where
    we went wrong.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通常情况下，错误消息的最后几行提供了最有用的信息。最后一行告诉我们，我们尝试使用变量名`A_name`，但在此之前并未先定义它，而上一行包含了它出现的实际代码。有了这两条信息（再加上我们的搜索策略），在我们找到错误源之前可能不会花费太长时间。
- en: Another very common type of runtime error occurs when you try to do something
    with a particular data type that it wasn’t designed for. In the [“Fast Forward”](#greet_me_ff),
    you may have tried running the code `greet_me(14)`. In this case, the last line
    of the error output will include the word `TypeError`, which means that some part
    of our code received a different data type than it was expecting. In that example,
    the problem is that the function expects a string (which can be “added” or *concatenated*
    to another string using the `+` sign), but we provided it with a number, in this
    case, `14`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种非常常见的运行时错误类型是在尝试对特定数据类型进行不适当操作时发生。在[“快进”](#greet_me_ff)中，你可能尝试运行代码`greet_me(14)`。在这种情况下，错误输出的最后一行将包含`TypeError`，这意味着我们的某部分代码接收到了与预期不同的数据类型。在这个例子中，问题在于该函数期望一个字符串（可以使用`+`号“添加”或*连接*到另一个字符串），但我们提供了一个数字，即`14`。
- en: 'The challenge with fixing this kind of error is that identifying exactly where
    the problem lies can be a bit tricky, because it involves a mismatch between where
    a variable’s value was *assigned* and where that variable (and therefore its value)
    was actually *used*. Especially as your programs grow more sophisticated, these
    two processes may be nowhere near each other in your code. Looking at the error
    output from [Example 2-14](#param_mismatch), for example, you can see that it
    reports two locations. The first is a line where the variable was passed into
    the function, and so where the available value was *assigned*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 修复此类错误的挑战在于准确定位问题所在有些许棘手，因为涉及到变量值的*赋值*和实际*使用*位置之间的不匹配。特别是当你的程序变得更加复杂时，这两个过程可能在代码中完全不相关。例如，查看来自[示例 2-14](#param_mismatch)的错误输出，你可以看到它报告了两个位置。第一个是将变量传递到函数的行，因此可用值被*赋予*的位置：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The second is the line where the value passed to it was *used*:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是传递给它的值被*使用*的行：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As I have mentioned already, starting your debugging work with where a problematic
    variable or value was *used* and then working backward through your code to see
    where the value was assigned is helpful; just know that the line of code where
    the value was assigned may or may *not* actually appear in the error output. This
    is part of what makes these kinds of runtime errors more difficult to track down
    than your average syntax error.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我已经提到的，从一个问题变量或值的*使用*位置开始进行调试工作，然后逆向查找到分配值的代码行通常是有帮助的；只是要知道，分配值的代码行可能实际上并没有出现在错误输出中。这是使这类运行时错误比普通语法错误更难跟踪的部分原因之一。
- en: The fact that runtime errors are some of the harder ones to diagnose is a key
    reason why I recommend both saving and testing your code frequently. The source
    of a new runtime error is much easier to identify if you’ve only written a few
    new lines of code since you last tested it, because the problem *must* be in that
    little bit of new code. With this sort of `write, run, repeat` approach, you’ll
    have much less ground to cover when it comes to looking for the source of any
    new errors, and you’ll probably be able to fix them relatively quickly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时错误之所以难以诊断是我推荐频繁保存和测试你的代码的一个关键原因。如果自上次测试以来你只写了几行新代码，那么识别新运行时错误的来源将更加容易，因为问题*必然*出现在这段新代码中。采用这种`编写、运行、重复`的方法，当你需要查找任何新错误的来源时，需要覆盖的范围将会少得多，并且你可能能够相对快速地修复它们。
- en: Logic Loss
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑损失
- en: 'By far the trickiest type of programming problem is the *logic* error, which
    is broadly used to describe what happens when your program *works*, just *not
    how you intended*. These errors are especially insidious because—from the computer’s
    perspective—everything is fine: your code is not trying to do anything it finds
    confusing or “wrong.” But computers are stupid, remember, so they will happily
    let your program do things that produce meaningless, nonsensical, or even misleading
    results. In precisely the same way that one can do correct math on bad data (as
    we’ll discuss in [Chapter 3](ch03.html#chapter3)), it’s very possible to write
    functioning code that does something inappropriate or incorrect. In fact, we already
    have!'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，最棘手的编程问题绝对是*逻辑*错误，这个术语广泛用来描述当你的程序*运行*时，只是*不是你打算的方式*发生的情况。这些错误特别阴险，因为从计算机的角度来看，一切都很正常：你的代码没有试图执行任何它认为混乱或“错误”的操作。但是请记住，计算机很笨，所以它们会很高兴地让你的程序执行产生毫无意义、混乱甚至误导性的结果。事实上，我们已经遇到了这种情况！
- en: 'If you look back at [Example 2-12](#page_counts_complete), you’ll notice that
    there’s actually a slight disconnect between what our comments *say* we wanted
    to accomplish and what our code actually *does*. The output of that example looks
    like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回顾一下[示例 2-12](#page_counts_complete)，您会注意到我们的注释表达的意图与我们的实际代码所做的事情之间存在轻微的不一致。该示例的输出如下：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'But our data looks like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们的数据看起来是这样的：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: See the problem? While it’s true that we have 5 chapters whose page count is
    more than 30, we actually have only 3 chapters whose page count is *under* 30—there’s
    one chapter with exactly 30 pages.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 看出问题了吗？虽然我们确实有5章的页数超过30页，但实际上只有3章的页数*不到*30页——有一章正好是30页。
- en: Right now, this may not seem like a particularly significant error—after all,
    how important is it if one 30-page chapter gets lumped in with chapters that are
    fewer than 30 pages? But imagine that instead of counting chapter pages, this
    code was being used to determine voting eligibility? If that code was counting
    only people who were “over 18,” hundreds of thousands of people would be disenfranchised.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这可能看起来并不是一个特别重要的错误——毕竟，如果一个30页的章节被归类到少于30页的章节中，这有多重要呢？但是想象一下，如果这段代码不是用来计算章节页数，而是用来确定投票资格呢？如果这段代码只计算“超过18岁”的人数，将会有成千上万的人失去选举权。
- en: 'Fixing this error is not difficult or complicated in terms of the code we need
    to adjust. All we have to do is change this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复这个错误，在代码调整方面并不困难或复杂。我们只需要改变这一点：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 改为：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The challenge this type of error presents is that it relies entirely on our
    diligence as programmers to make sure that as we *design* our programs, we don’t
    overlook some possible data value or discrepancy that can result in incorrect
    measurements or results. Because the computer cannot warn us about logic errors,
    the only reliable way to avoid them is to plan our programs carefully in the first
    place, and to carefully “sanity check” the results. In [“Hitting the Road with
    Citi Bike Data”](#hitting_the_road_intro), we’ll see what this process looks like
    when we write a program to deal with a real-world dataset.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型错误的挑战在于，它完全依赖于我们作为程序员的勤奋，以确保在我们*设计*程序时，我们不会忽视可能导致不正确测量或结果的某些数据值或差异。因为计算机无法警告我们逻辑错误，避免它们的唯一可靠方法是一开始就仔细计划我们的程序，并仔细“审查”结果。在[“使用Citi
    Bike数据上路”](#hitting_the_road_intro)中，我们将看到当我们编写处理真实数据集的程序时，这个过程是什么样子的。
- en: Phew! Now that we’ve covered all the fundamentals of Python programming (really!),
    we’re ready to move on from our “toy” examples using data that is (sort of) about
    this book. To get our feet wet with a data wrangling task using a real dataset,
    we’ll turn to information from the New York City bike-sharing system, Citi Bike.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！现在我们已经涵盖了Python编程的所有基础知识（真的！），我们准备从我们关于本书的“玩具”示例中继续，使用（某种程度上）关于这本书的数据。为了让我们的脚步湿润，使用一个真实数据集进行数据整理任务，我们将转向来自纽约市自行车共享系统Citi
    Bike的信息。
- en: Hitting the Road with Citi Bike Data
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Citi Bike数据上路
- en: Every month, millions of people use bike-sharing systems to navigate cities
    and towns around the world. New York City’s Citi Bike program launched in 2013
    with 6,000 bikes, and in 2020, the system saw its [100 millionth ride](https://citibikenyc.com/about).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 每个月，数百万人使用自行车共享系统在世界各地的城市和城镇中行驶。纽约市的Citi Bike计划于2013年推出了6000辆自行车，在2020年，该系统见证了其[第1亿次骑行](https://citibikenyc.com/about)。
- en: 'Citi Bike provides freely accessible data about its system operations that
    is both real-time and historical. To see what it takes to do data wrangling with
    a real-world dataset, we’re going to use Citi Bike data to answer a simple question:
    how many rides each day are taken by different types of Citi Bike riders?'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Citi Bike提供了关于其系统运营的免费可访问数据，这些数据既是实时的又是历史的。为了查看使用Citi Bike数据回答一个简单问题所需的步骤，我们将使用Citi
    Bike数据来回答一个简单问题：Citi Bike不同类型的骑行者每天骑行多少次？
- en: We need our Python skills to answer this question because Citi Bike riders take
    hundreds of thousands of rides per day—meaning that just one day of this data
    has too many rows for either Microsoft Excel or Google Sheets to handle. But even
    on a Chromebook, Python will have no problem working with this amount of data.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要我们的Python技能来回答这个问题，因为Citi Bike骑行者每天骑行数以十万计——这意味着这些数据的一天对于Microsoft Excel或Google
    Sheets来说有太多的行了。但即使在Chromebook上，Python也不会在处理这些数据量时遇到问题。
- en: 'To think about how to approach this, let’s revisit the steps of data wrangling
    outlined in [“What Is “Data Wrangling”?”](ch01.html#describing_data_wrangling):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要思考如何处理这个问题，让我们重新审视数据整理的步骤，详见[“什么是“数据整理”？”](ch01.html#describing_data_wrangling)：
- en: Locating or collecting data
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位或收集数据
- en: Assessing the data’s quality
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估数据的质量
- en: “Cleaning,” standardizing, and/or transforming the data
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “清洁”、标准化和/或转换数据
- en: Analyzing the data
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析数据
- en: Visualizing the data
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化数据
- en: Communicating the data
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传达数据
- en: For this exercise, we’re going to focus on steps 1–4, though as you’ll see,
    I’ve done some preparation that will cut down on how long we spend with certain
    steps. For example, I’ve already located [the Citi Bike system data](https://citibikenyc.com/system-data)
    and downloaded [the September 2020 trip history data](https://s3.amazonaws.com/tripdata/index.html),
    confirmed that the only values that appear in the `User Type` column are `Customer`
    and `Subscriber`, and cut down the whole September dataset to *just* the rides
    that began on September 1, 2020\. While we’ll delve into how to do all of these
    processes in subsequent chapters, for now I want to focus on how to apply the
    lessons from this chapter to data that we didn’t make up for ourselves.^([7](ch02.html#idm45143427916368))
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，我们将专注于步骤1至4，尽管你会看到，我已经做了一些准备工作，这将减少我们花在某些步骤上的时间。例如，我已经找到了[Citi Bike系统的数据](https://citibikenyc.com/system-data)，并下载了[2020年9月的出行历史数据](https://s3.amazonaws.com/tripdata/index.html)，确认了`User
    Type`列中出现的唯一值是`Customer`和`Subscriber`，并将整个九月的数据集削减为*仅仅*在2020年9月1日开始的骑行。虽然我们将在后续章节中详细介绍如何执行所有这些过程，但现在我想专注于如何将本章的教训应用于我们没有为自己准备的数据。^([7](ch02.html#idm45143427916368))
- en: Starting with Pseudocode
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从伪代码开始
- en: One of the best ways to get started with a data wrangling project of any size
    is to plan out your approach in advance and include that program outline in you
    Python file through a process known as *pseudocoding*. Pseudocoding basically
    means writing, in regular English (though you could certainly pseudocode in another
    natural language if you prefer!), what your program will do, step by step. In
    addition to giving you space to think through what your program needs to accomplish
    without worrying about how to code it, pseudocoding will give you a valuable reference
    for what to work on next when you need to take a break from your project and come
    back to it later. Although you’ll no doubt meet many professional programmers
    who *don’t* do this part of the process regularly, I can guarantee that it will
    help you finish your wrangling projects more quickly—and that it’s the kind of
    habit that is welcome in any professional programming or data science setting.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 无论项目的数据整理大小如何，最好的方法之一是事先计划您的方法，并通过伪代码将该程序大纲包含在您的Python文件中。伪代码基本上意味着逐步编写您的程序将要做的事情，用普通英语（尽管您当然可以用其他自然语言进行伪代码，如果您更喜欢！）。除了为您提供思考程序需要完成的任务的空间而无需担心如何编写代码外，伪代码还将为您提供一个宝贵的参考，以便在需要休息一下项目并稍后回来时，确定下一步工作。尽管您无疑会遇到许多不经常完成此过程部分的专业程序员，但我可以保证这将帮助您更快地完成整理项目，并且这种习惯在任何专业的编程或数据科学环境中都受欢迎。
- en: 'I prefer to put my program outline and pseudocode right at the top of my Python
    file, in a large block of comments. To start out, I’m going to do three things:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢将程序大纲和伪代码放在我的Python文件顶部，作为一大块注释。起初，我将做三件事：
- en: State my question.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 陈述我的问题。
- en: Describe how I will “answer” my question.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述如何“回答”我的问题。
- en: Outline in plain language the steps my program will take.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用简单的语言概述我程序将采取的步骤。
- en: This means that the first thing I’m going to do is write a *lot* of comments
    in my file, as you can see in [Example 2-15](#citibike_comment_block).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我要做的第一件事就是在我的文件中写很多注释，正如你在 [示例 2-15](#citibike_comment_block) 中看到的那样。
- en: Example 2-15\. hitting_the_road_with_citibike.py
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-15\. hitting_the_road_with_citibike.py
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now that the program outline is all squared away, it’s time to get started
    with the first part of our program: reading in our data.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序大纲已经搞定，是时候开始我们程序的第一部分了：读取我们的数据。
- en: Tip
  id: totrans-208
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Anytime you start a new file like this, remember that even if it’s saved inside
    a local Git repo folder, you’ll need to run `git add` to have Git back up any
    changes you make (you can’t `commit` a file until you `add` it, remember). These
    steps are outlined in [“Don’t Forget Git!”](#dont_forget_git), in case you’d like
    a refresher. While how often you `commit` is up to you, for this exercise I recommend
    that you `commit` your code (with a descriptive commit message, of course!) after
    each code block in this section. As you get more comfortable with the coding and
    Git `commit` process, of course, you’ll find a frequency and rhythm for backing
    up your code that works best for you.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 每次像这样开始一个新文件时，请记住，即使它保存在本地 Git 存储库文件夹内，你也需要运行 `git add` 来备份你所做的任何更改（记住，你不能在
    `add` 文件之前 `commit` 文件）。这些步骤在 [“别忘了 Git！”](#dont_forget_git) 中有详细说明，以防你需要恢复。虽然你可以自行决定多久
    `commit` 一次，但对于这个练习，我建议在每个代码块之后 `commit` 你的代码（当然，附带描述性的提交消息！）。当你对编码和 Git `commit`
    过程更加熟悉时，你会找到适合你的最佳代码备份频率和节奏。
- en: 'Loading different data formats, as we’ll see in-depth in [Chapter 4](ch04.html#chapter4),
    can actually be one of the trickier aspects of data wrangling. Fortunately, there
    are many Python libraries available to help, and we’re going to make use of one
    right now! I mentioned libraries briefly in [“Libraries: Borrowing Custom Functions
    from Other Coders”](#library_love); they are essentially cookbooks of code. For
    this project, we’re going to use the code “recipes” from the *csv* library, which
    is mostly designed to deal with—you guessed it!—*.csv* files. The file extension
    *.csv* stands for *c*omma-*s*eparated *v*alue, and if you haven’t seen it before,
    don’t worry. We’ll go into (significant) detail about file types in [Chapter 4](ch04.html#chapter4).
    Right now, having the *csv* library on hand means that we don’t actually *need*
    to know too much about this file type in order to work with it, because the library’s
    code recipes are going to do a lot of the work for us!'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 加载不同的数据格式，正如我们在 [第四章](ch04.html#chapter4) 中将深入了解的那样，实际上可能是数据处理中更棘手的方面之一。幸运的是，有许多
    Python 库可用来帮助，我们现在将使用其中之一！我在 [“库：从其他编程者那里借用自定义函数”](#library_love) 中简要提到了库；它们本质上是代码的食谱。对于这个项目，我们将使用
    *csv* 库的“食谱”，它主要设计用于处理——你猜对了！——*.csv* 文件。文件扩展名 *.csv* 代表 *c*omma-*s*eparated *v*alue，如果你以前没有见过它，不要担心。我们将在
    [第四章](ch04.html#chapter4) 中详细讨论文件类型（详细）。现在，有了 *csv* 库就意味着我们实际上不需要太多关于这种文件类型的知识来处理它，因为库的代码食谱将为我们完成大部分工作！
- en: If you’re following along in your own file, you’ll want to add the code in [Example 2-16](#hitting_the_road_1)
    to the program outline.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在自己的文件中跟着做，你会想要将 [示例 2-16](#hitting_the_road_1) 中的代码添加到程序大纲中。
- en: Example 2-16\. hitting_the_road_with_citibike.py (continued)
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-16\. hitting_the_road_with_citibike.py（续）
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](assets/1.png)](#co_introduction_to_python_CO3-1)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_to_python_CO3-1)'
- en: The *csv* library includes a range of handy code recipes for dealing with our
    data files.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*csv* 库包含一系列方便的代码食谱，用于处理我们的数据文件。'
- en: '[![2](assets/2.png)](#co_introduction_to_python_CO3-2)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_introduction_to_python_CO3-2)'
- en: '`open()` is a built-in function that takes a file name and a “mode” as parameters.
    In this example, the target file (*202009CitibikeTripdataExample.csv*) should
    be in the same folder as our Python script or notebook. Values for the “mode”
    can be `"r"` for “read” or `"w"` for “write.”'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`open()` 是一个内置函数，它以文件名和“模式”作为参数。在这个例子中，目标文件（*202009CitibikeTripdataExample.csv*）应该与我们的
    Python 脚本或笔记本在同一个文件夹中。对于“模式”，可以使用 `"r"` 表示“读取”或 `"w"` 表示“写入”。'
- en: '[![3](assets/3.png)](#co_introduction_to_python_CO3-3)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_introduction_to_python_CO3-3)'
- en: By printing out the `citibike_reader.fieldnames` values, we can see that the
    exact label for the “User Type” column is `usertype`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打印出 `citibike_reader.fieldnames` 的值，我们可以看到“User Type”列的确切标签是 `usertype`。
- en: 'At this point, we could actually run this script, and we should see output
    that looks something like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们实际上可以运行此脚本，我们应该看到类似以下的输出：
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We’ve also now succeeded in completing the first step of our outline: we’ve
    read in our data. But we’ve also used the *csv* library to transform that data
    and even generate some *metadata* about it. Importantly, we now know that the
    *precise* name of the column containing our “User Type” information is actually
    `usertype`. This will help us when it comes time to write our `if...else` statements.
    To confirm that things are working as you expect, be sure to save and run your
    code. If it works as expected (that is, it prints out a list of column headers),
    now is a good time to do a `git commit` cycle:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功完成了大纲的第一步：我们已经读入了我们的数据。但我们还使用了 *csv* 库来转换数据，甚至生成了一些关于它的 *元数据*。重要的是，我们现在知道包含我们
    “User Type” 信息的列的确切名称实际上是 `usertype`。这将有助于我们在编写 `if...else` 语句时的操作。为了确认一切按您的预期工作，请确保保存并运行您的代码。如果按预期工作（即，它打印出列标题的列表），现在是执行
    `git commit` 循环的好时机：
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Remember that if you are working on Google Colab, you can commit your code directly
    to GitHub by choosing File → “Save a copy in GitHub” and entering your commit
    message in the overlay window that appears.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果您正在使用 Google Colab，您可以通过选择文件 → “在 GitHub 中保存副本” 并在出现的覆盖窗口中输入提交消息，直接将您的代码提交到
    GitHub。
- en: Now that we’ve completed step one successfully, let’s go on to step two, as
    shown in [Example 2-17](#hitting_the_road_2).^([8](ch02.html#idm45143427725168))
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已成功完成第一步，让我们继续进行第二步，如 [Example 2-17](#hitting_the_road_2) 所示。^([8](ch02.html#idm45143427725168))
- en: Example 2-17\. hitting_the_road_with_citibike.py (continued again)
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-17\. hitting_the_road_with_citibike.py（继续）
- en: '[PRE34]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Pretty simple, right? On to step three! Since we need to check each row of data
    in the file, we’ll need to write a `for...in` loop, which will need to have an
    `if...else` inside of it to test for specific values in the `usertype` column.
    To help keep track of what each line of code is doing, I’m going to write a *lot*
    of comments explaining the code in English, as shown in [Example 2-18](#hitting_the_road_3).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 相当简单，对吧？继续进行第三步！因为我们需要检查文件中的每一行数据，所以我们需要编写一个 `for...in` 循环，其中将需要在 `usertype`
    列中测试特定值的 `if...else`。为了帮助跟踪代码的每一行正在做什么，我将写很多以英文解释代码的注释，如 [Example 2-18](#hitting_the_road_3)
    所示。
- en: Example 2-18\. hitting_the_road_with_citibike.py (still rolling)
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-18\. hitting_the_road_with_citibike.py（继续进行）
- en: '[PRE35]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[![1](assets/1.png)](#co_introduction_to_python_CO4-1)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_to_python_CO4-1)'
- en: We want to make sure our `for` loop is working with the data that’s already
    been transformed by our DictReader recipe, so we want to make sure we’re referencing
    our `citibike_reader` variable here.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要确保我们的 `for` 循环正在处理已由我们的 DictReader 转换的数据，所以我们要确保在这里引用我们的 `citibike_reader`
    变量。
- en: '[![2](assets/2.png)](#co_introduction_to_python_CO4-2)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_introduction_to_python_CO4-2)'
- en: In order for my `if` statements to be “inside” my loop, they have to be indented
    one more `tab` to the right.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我的 `if` 语句“内嵌”到我的循环中，它们必须向右缩进一个 `tab`。
- en: '[![3](assets/3.png)](#co_introduction_to_python_CO4-3)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_introduction_to_python_CO4-3)'
- en: Because we need to use “else” here—but also need another “if” statement—we’re
    using the compound keyword `elif`, which is short for “else if.”
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们需要在这里使用 “else” —— 但也需要另一个 “if” 语句 —— 所以我们使用了复合关键字 `elif`，它是 “else if” 的简写。
- en: '[![4](assets/4.png)](#co_introduction_to_python_CO4-4)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_introduction_to_python_CO4-4)'
- en: 'This final `else` will “catch” any rows of data where the value of `usertype`
    was not one of the values we checked for explicitly (in this case, “Subscriber”
    or “Customer”). This serves as a (very) basic data quality check: if this data
    column contains any unexpected values, `other_user_count` will be greater than
    zero (`0`), and we need to look at our original data more closely.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最终的 `else` 将“捕获”任何数据行，其中 `usertype` 的值不是我们明确检查过的值之一（在本例中是“Subscriber”或“Customer”）。这充当了一个（非常）基本的数据质量检查：如果此数据列包含任何意外的值，`other_user_count`
    将大于零 (`0`)，我们需要仔细查看原始数据。
- en: OK, there is a *lot* going on in [Example 2-18](#hitting_the_road_3)—or at least
    it looks like there is! Really, all we did was check whether the value in each
    row’s `usertype` column was `"Subscriber"` or `"Customer"` and added one to (or
    *incremented*) the corresponding `count` variable if it was. If the `usertype`
    value was *neither* of those, we added one to the `other_user_count` variable.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，在[示例 2-18](#hitting_the_road_3)中有*很多*内容—或者看起来像是有很多！实际上，我们只是检查了每行的`usertype`列的值是否为`"Subscriber"`或`"Customer"`，如果是的话，我们将对应的`count`变量加一（或者*增加*）。如果`usertype`的值既不是这两者之一，我们将`other_user_count`变量加一。
- en: While it may seem strange that we’ve added so many more lines of comments than
    code, this is actually pretty normal—even good! After all, while the computer
    never “forgets” how to read Python code, *you* will *absolutely* forget what this
    code is doing and why if you don’t explain it in the comments. And that’s not
    a bad thing! After all, memorizing all of your code would make programming pretty
    inefficient. By writing detailed comments, you ensure that you can easily understand
    your code in the future, without having to do the work of translating Python to
    English all over again!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们添加了比代码更多的行注释可能看起来有些奇怪，但实际上这是非常正常的—甚至是好的！毕竟，虽然计算机永远不会“忘记”如何读取Python代码，*你*如果不在注释中解释这段代码在做什么和为什么要这样做，*绝对*会忘记。而这并不是一件坏事！毕竟，如果要记住所有的代码，编程效率会大大降低。通过编写详细的注释，你确保将来能轻松理解你的代码，而不必再次将Python翻译成英语！
- en: 'Before we move on, make sure to run your code. Since “no news is good news”
    for our most common types of errors, if you don’t get any errors, go ahead and
    do a `git commit` cycle. Otherwise, now is a good time to pause and troubleshoot
    any issues you’ve encountered. Once those are resolved, you’ll see there’s only
    one very simple step left: printing! Let’s just go the most straightforward route
    and use built-in `print` statements, as shown in [Example 2-19](#hitting_the_road_4).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，请确保运行你的代码。对于我们最常见的错误类型，“无消息就是好消息”，如果你没有收到任何错误，那就进行一次`git commit`循环。否则，现在是暂停并排除你遇到的任何问题的好时机。一旦解决了这些问题，你会发现只剩下一个非常简单的步骤：打印！让我们采用最直接的方式并使用内置的`print`语句，就像[示例 2-19](#hitting_the_road_4)中显示的那样。
- en: Example 2-19\. hitting_the_road_with_citibike.py (we’ve arrived!)
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-19\. 使用 citibike.py 出发（我们到达了！）
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[![1](assets/1.png)](#co_introduction_to_python_CO5-1)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_to_python_CO5-1)'
- en: Note that these `print()` statements are left justified, because we only want
    to print values once the `for` loop has finished going through the entire dataset.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些`print()`语句是左对齐的，因为我们只想在`for`循环完成整个数据集的遍历后打印值。
- en: 'When you’ve added the code in [Example 2-19](#hitting_the_road_4) to your file,
    save and run it. Your output should look something like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当你把代码添加到[示例 2-19](#hitting_the_road_4)中后，保存并运行它。你的输出应该类似于这样：
- en: '[PRE37]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If that’s what you see—congratulations! You’ve successfully written your first
    real-world data wrangling program. Make sure to do a `git commit` cycle to back
    up your great work!
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到这些内容—恭喜！你成功地编写了你的第一个真实世界数据整理程序。确保进行一次`git commit`来备份你的优秀工作！
- en: Seeking Scale
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻求规模
- en: 'In writing this script, we’ve accomplished a number of things:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写这个脚本时，我们完成了许多事情：
- en: We’ve successfully and precisely counted the number of “Subscribers” and “Customers”
    who used Citi Bikes on a single day in September 2020.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们成功并精确地统计了2020年9月某一天使用Citi Bikes的“订阅者”和“顾客”的数量。
- en: We’ve confirmed that there are no other values in the `usertype` column (because
    the value in our `other_user_count` variable was 0).
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们确认`usertype`列中没有其他值（因为我们的`other_user_count`变量的值为0）。
- en: 'If you’ve done data wrangling before using spreadsheet or database programs,
    for example, but this was your first time working in Python, chances are this
    process took longer than your previous method, all things considered. But as I’ve
    mentioned a few times already, a key advantage that coding offers over many other
    methods is the ability to *scale* almost seamlessly. That scale works in two ways.
    First, it does the same work on a larger dataset almost as fast as a smaller one.
    For example, on my Chromebook, the *hitting_the_road_with_citibike.py* script
    completes in about half a second. If I run the same script on the data from *the
    entire month of September*, it takes about 12 seconds. Most software programs
    that could even handle the entire month’s data would probably need that long just
    to *open* the file, much less do any work to it. So, using Python helps us scale
    because we can handle larger datasets much more quickly and effectively. You can
    test this out for yourself by changing the line:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前使用电子表格或数据库程序进行数据整理，但这是您第一次在Python中工作，综合考虑所有事情，这个过程可能比您以前的方法花费更长时间。但正如我已经多次提到的，编码相比许多其他方法的一个关键优势是能够*无缝扩展*。这种扩展有两种方式。首先，它几乎可以在较大的数据集上以几乎与较小数据集相同的速度完成相同的工作。例如，在我的Chromebook上，*hitting_the_road_with_citibike.py*脚本大约在半秒内完成。如果我在*整个九月份*的数据上运行相同的脚本，大约需要12秒钟。大多数软件程序即使能够处理整个月份的数据，可能只需打开文件就需要这么长时间，更不用说对其进行任何工作了。因此，使用Python帮助我们扩展，因为我们可以更快速和有效地处理更大的数据集。您可以通过更改以下行来自行测试：
- en: '[PRE38]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'to:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 至：
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you’re working in a standalone Python file, you can even measure how long
    it takes to run your script on the new file by adding the `time` keyword before
    your `python` command:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在独立的Python文件中工作，甚至可以通过在您的`python`命令之前添加`time`关键字来测量运行新文件上的脚本所需的时间：
- en: '[PRE40]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This illustrates the second type of scale we achieve with Python, which has
    to do with the *marginal effort* required to have the computer do the same task
    on a different dataset (with the same structure) once we have written our program,
    and this is where Python (and programming in general) really shines. In order
    to run my script on data from the whole month of September 2020, *all I had to
    do was load a different data file*. By changing the target filename that I opened
    with my `source_file =` statement, I was able to process *all* of the September
    data instead of just the data from one day. In other words, the additional (or
    “marginal”) effort to process hundreds of thousands of additional rows of data
    was exactly as long as it took me to copy and paste the filename. Building on
    that example, I could process an entire year of data in a few minutes (or less,
    as we’ll see in [Chapter 8](ch08.html#chapter8)). That is something that is nearly
    impossible to achieve with any noncoding data wrangling method.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了我们通过Python实现的第二种类型的扩展，这与在不同数据集上（具有相同结构）计算机执行相同任务所需的*边际努力*有关。一旦我们编写了我们的程序，Python（以及一般的编程）真正闪耀的地方就在于此。为了在2020年9月的整个月份数据上运行我的脚本，*我所需要做的只是加载一个不同的数据文件*。通过更改我用`source_file
    =`语句打开的目标文件名，我能够处理整个九月份的数据，而不仅仅是一天的数据。换句话说，处理成千上万个额外数据行的额外（或“边际”）努力正好等于我复制和粘贴文件名所花费的时间。基于这个例子，我可以在几分钟内（或更短时间，正如我们将在[第8章](ch08.html#chapter8)中看到的那样）处理一整年的数据。这几乎是任何非编码数据整理方法都难以实现的事情。
- en: The complete script we’ve built in this section is an example of how, even using
    just the basic structures we’ve covered in this chapter, you can do some really
    useful and efficient data wrangling with Python. Though there are many new data
    formats and challenges to explore in the remaining chapters, I hope this has given
    you a sense of how much you can achieve with even these “basic” Python tools and
    just a little effort and attention to detail. Imagine what else you can accomplish
    if you keep going!
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中构建的完整脚本是一个示例，展示了即使仅使用我们在本章中介绍的基本结构，您也可以使用Python进行一些非常有用和高效的数据整理。尽管在剩余的章节中有许多新的数据格式和挑战需要探索，但我希望这能让您感受到即使使用这些“基本”的Python工具和稍加努力和注意细节，您也能取得多大的成就。想象一下，如果您继续努力，还能实现什么！
- en: Conclusion
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'Believe it or not, in this chapter we’ve covered *all* the essential Python
    tools you’ll need to do data wrangling—as well as almost any other kind of Python
    programming! To recap what we’ve covered, we learned about:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，在本章中，我们涵盖了*所有*您进行数据整理所需的基本Python工具，以及几乎任何其他类型的Python编程！为了总结我们所学到的内容，我们学到了：
- en: Data types
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'These are the “nouns” of programming: numbers, strings, lists, dicts, and Booleans.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是编程的“名词”：数字、字符串、列表、字典和布尔值。
- en: Functions
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 函数
- en: 'These are the “verbs” of programming: operators, built-in functions, and user-defined
    functions.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是编程的“动词”：运算符、内置函数和用户定义函数。
- en: Using `for...in...` loops
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for...in...`循环
- en: These let us run a particular chunk of code on every item in a list.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这些让我们在列表中的每个项目上运行特定的代码块。
- en: Using `if...else` conditionals
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`if...else`条件语句
- en: These let us to make “decisions” about what code should be run, based (usually)
    on the attributes of our data.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这些让我们根据数据的属性“决定”应该运行什么代码。
- en: Errors
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 错误
- en: We explored the different types of errors that we’re likely to encounter when
    programming and how to best address and prevent them.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了编程时可能遇到的不同类型的错误，以及如何最好地处理和预防它们。
- en: We also practiced combining and composing these concepts to create a basic program
    to work with some sample data from the New York Citi Bike system. While we’ll
    expand on this example and explore others in future chapters, our next task is
    to understand more about how to evaluate data itself as part of our data wrangling
    work.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还练习了将这些概念结合和组合，以创建一个基本程序来处理来自纽约市自行车系统的一些样本数据。虽然我们将在未来的章节中扩展这个示例并探索其他示例，但我们下一个任务是更深入地了解如何作为数据整理工作的一部分评估数据本身。
- en: ^([1](ch02.html#idm45143423781840-marker)) There are also many language-specific
    data types (such as Python’s *tuple* data type) that are not as relevant to our
    data wrangling efforts, so we won’t address these in detail.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#idm45143423781840-marker)) 还有许多特定于语言的数据类型（如Python的*元组*数据类型），这些对我们的数据整理工作不是很相关，因此我们不会详细讨论这些。
- en: ^([2](ch02.html#idm45143426063952-marker)) In many other programming languages,
    curly braces are used to indicate which pieces of code belong inside a loop or
    a conditional statement. As we mentioned in [“Readability”](ch01.html#readability),
    however, Python is *whitespace dependent*.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.html#idm45143426063952-marker)) 在许多其他编程语言中，花括号用于指示代码的哪些部分属于循环或条件语句。然而，正如我们在[“可读性”](ch01.html#readability)中提到的，Python是*依赖于空白*的。
- en: ^([3](ch02.html#idm45143428265504-marker)) Unlike computers, of course, toddlers
    are capable of genuine originality and learning.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.html#idm45143428265504-marker)) 当然，与计算机不同，幼儿具有真正的独创性和学习能力。
- en: ^([4](ch02.html#idm45143428263280-marker)) For more, see Scott Rosenberg’s Wordyard
    [blog post about the topic](http://wordyard.com/2003/09/15/if-u-cn-rd-ths-msg-u-r-jst-lke-vryne-lse).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.html#idm45143428263280-marker)) 欲了解更多信息，请参阅Scott Rosenberg的Wordyard
    [博客文章](http://wordyard.com/2003/09/15/if-u-cn-rd-ths-msg-u-r-jst-lke-vryne-lse)。
- en: ^([5](ch02.html#idm45143428086384-marker)) This is actually a good thing, as
    we’ll see in [Chapter 3](ch03.html#chapter3).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch02.html#idm45143428086384-marker)) 这实际上是一件好事，正如我们将在[第3章](ch03.html#chapter3)中看到的那样。
- en: ^([6](ch02.html#idm45143428081024-marker)) For information on code coverage
    best practices, see “Code Coverage Best Practices” on the [Google Testing Blog](https://testing.googleblog.com/2020/08/code-coverage-best-practices.html).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch02.html#idm45143428081024-marker)) 关于代码覆盖率最佳实践的信息，请参阅[Google测试博客](https://testing.googleblog.com/2020/08/code-coverage-best-practices.html)上的“代码覆盖率最佳实践”。
- en: ^([7](ch02.html#idm45143427916368-marker)) All of the code for this exercise
    can be found in the *hitting_the_road_with_citibike.py* and *hitting_the_road_with_citibike.ipynb*
    files. However, I strongly encourage you to create new files of your own and enter
    the provided code yourself.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch02.html#idm45143427916368-marker)) 此练习的所有代码都可以在*hitting_the_road_with_citibike.py*和*hitting_the_road_with_citibike.ipynb*文件中找到。然而，我强烈建议您创建自己的新文件，并手动输入提供的代码。
- en: ^([8](ch02.html#idm45143427725168-marker)) Once again—and from here on out—add
    this code to your file below the last line of the previous block.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch02.html#idm45143427725168-marker)) 再次强调——从现在开始——将此代码添加到您的文件中，放在上一个代码块的最后一行下面。
