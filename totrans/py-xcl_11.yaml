- en: Chapter 8\. Excel File Manipulation with Reader and Writer Packages
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter introduces you to OpenPyXL, XlsxWriter, pyxlsb, xlrd, and xlwt:
    these are the packages that can read and write Excel files and are used by pandas
    under the hood when you call the `read_excel` or `to_excel` functions. Using the
    reader and writer packages directly allows you to create more complex Excel reports
    as well as fine-tune the reading process. Also, should you ever work on a project
    where you only need to read and write Excel files without the need for the rest
    of the pandas functionality, installing the full NumPy/pandas stack would probably
    be overkill. We’ll start this chapter by learning when to use which package and
    how their syntax works before looking at a few advanced topics, including how
    to work with big Excel files and how to combine pandas with the reader and writer
    packages to improve the styling of DataFrames. To conclude, we will pick up the
    case study from the beginning of the last chapter again and enhance the Excel
    report by formatting the table and adding a chart. Like the last chapter, this
    chapter does not require an installation of Excel, which means that all code samples
    run on Windows, macOS, and Linux.'
  prefs: []
  type: TYPE_NORMAL
- en: The Reader and Writer Packages
  prefs: []
  type: TYPE_NORMAL
- en: 'The reader and writer landscape can be a bit overwhelming: we are going to
    look at no less than six packages in this section as almost every Excel file type
    requires a different package. The fact that each package uses a different syntax
    that often deviates substantially from the original Excel object model doesn’t
    make it easier—I’ll say more about the Excel object model in the next chapter.
    This means that you will likely have to look up a lot of commands, even if you
    are a seasoned VBA developer. This section starts with an overview of when you
    need which package before it introduces a helper module that makes working with
    these packages a little easier. After that, it presents each of the packages in
    a cookbook style, where you can look up how the most commonly used commands work.'
  prefs: []
  type: TYPE_NORMAL
- en: When to Use Which Package
  prefs: []
  type: TYPE_NORMAL
- en: 'This section introduces the following six packages to read, write, and edit
    Excel files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[OpenPyXL](https://oreil.ly/3jHQM)'
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[XlsxWriter](https://oreil.ly/7jI3T)'
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[pyxlsb](https://oreil.ly/sEHXS)'
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[xlrd](https://oreil.ly/tSam7)'
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[xlwt](https://oreil.ly/wPSLe)'
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[xlutils](https://oreil.ly/MTFOL)'
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To understand which package can do what, have a look at [Table 8-1](#filepos964418).
    For example, to read the xlsx file format, you will have to use the OpenPyXL package:'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-1\. When to use which package
  prefs: []
  type: TYPE_NORMAL
- en: '|  Excel File Format  |  Read  |  Write  |  Edit  |'
  prefs: []
  type: TYPE_TB
- en: '|   `xlsx` |  OpenPyXL  |  OpenPyXL, XlsxWriter  |  OpenPyXL  |'
  prefs: []
  type: TYPE_TB
- en: '|   `xlsm` |  OpenPyXL  |  OpenPyXL, XlsxWriter  |  OpenPyXL  |'
  prefs: []
  type: TYPE_TB
- en: '|   `xltx`, `xltm` |  OpenPyXL  |  OpenPyXL  |  OpenPyXL  |'
  prefs: []
  type: TYPE_TB
- en: '|   `xlsb` |  pyxlsb  |  -  |  -  |'
  prefs: []
  type: TYPE_TB
- en: '|   `xls`, `xlt` |  xlrd  |  xlwt  |  xlutils  |'
  prefs: []
  type: TYPE_TB
- en: 'If you want to write xlsx or xlsm files, you need to decide between OpenPyXL
    and XlsxWriter. Both packages cover similar functionality, but each package may
    have a few unique features that the other one doesn’t have. As both libraries
    are actively being developed, this is changing over time. Here is a high-level
    overview of where they differ:'
  prefs: []
  type: TYPE_NORMAL
- en: OpenPyXL can read, write, and edit while XlsxWriter can only write.
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: OpenPyXL makes it easier to produce Excel files with VBA macros.
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: XlsxWriter is better documented.
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: XlsxWriter tends to be faster than OpenPyXL, but depending on the size of the
    workbook you’re writing, the differences may not be significant.
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: WHERE IS XLWINGS?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you are wondering where xlwings is in table [Table 8-1](index_split_020.html#filepos964418),
    then the answer is nowhere or everywhere, depending on your use case: unlike any
    of the packages in this chapter, xlwings depends on the Excel application, which
    often isn’t available, for example, if you need to run your scripts on Linux.
    If, on the other hand, you are OK with running your scripts on Windows or macOS
    where you have access to an installation of Excel, xlwings can indeed be used
    as an alternative to all packages in this chapter. Since Excel dependency is such
    a fundamental difference between xlwings and all the other Excel packages, I am
    introducing xlwings in the next chapter, which starts [Part IV](index_split_023.html#filepos1235617)
    of this book.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'pandas uses the writer package it can find and if you have both OpenPyXL and
    XlsxWriter installed, XlsxWriter is the default. If you want to choose which package
    pandas should use, specify the `engine` parameter in the `read_excel` or `to_excel`
    functions or the `ExcelFile` and `ExcelWriter` classes, respectively. The engine
    is the package name in lower case, so to write a file with OpenPyXL instead of
    XlsxWriter, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`df``.``to_excel``(``"filename.xlsx"``,``engine``=``"openpyxl"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Once you know which package you need, there is a second challenge waiting for
    you: most of these packages require you to write quite a bit of code to read or
    write a range of cells, and each package uses a different syntax. To make your
    life easier, I created a helper module that I’ll introduce next.'
  prefs: []
  type: TYPE_NORMAL
- en: The excel.py Module
  prefs: []
  type: TYPE_NORMAL
- en: 'I have created the `excel.py` module to make your life easier when using the
    reader and writer packages, as it takes care of the following issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Package switching
  prefs: []
  type: TYPE_NORMAL
- en: Having to switch the reader or writer package is a relatively common scenario.
    For example, Excel files tend to grow in size over time, which many users fight
    by switching the file format from xlsx to xlsb as this can substantially reduce
    the file size. In that case, you will have to switch away from OpenPyXL to pyxlsb.
    This forces you to rewrite your OpenPyXL code to reflect pyxlsb’s syntax.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Data type conversion
  prefs: []
  type: TYPE_NORMAL
- en: 'This is connected to the previous point: when switching packages, you don’t
    just have to adjust the syntax of your code, but you also need to watch out for
    different data types that these packages return for the same cell content. For
    example, OpenPyXL returns `None` for empty cells, while xlrd returns an empty
    string.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Cell looping
  prefs: []
  type: TYPE_NORMAL
- en: 'The reader and writer packages are low-level packages: this means that they
    lack convenience functions that would allow you to tackle common tasks easily.
    For example, most of the packages require you to loop through every single cell
    that you are going to read or write.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You will find the `excel.py` module in the companion repository and we will
    use it in the upcoming sections, but as a preview, here is the syntax to read
    and write values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import``excel``values``=``excel``.``read``(``sheet_object``,``first_cell``=``"A1"``,``last_cell``=``None``)``excel``.``write``(``sheet_object``,``values``,``first_cell``=``"A1"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `read` function accepts a `sheet` object from one of the following packages:
    xlrd, OpenPyXL, or pyxlsb. It also accepts the optional arguments `first_cell`
    and `last_cell`. They can be provided in either the `A1` notation or as row-column-tuple
    with Excel’s one-based indices: `(1, 1)`. The default value for the `first_cell`
    is `A1` whereas the default value for `last_cell` is the bottom right corner of
    the used range. Hence, if you only provide the `sheet` object, it will read the
    whole sheet. The `write` function works similarly: it expects a `sheet` object
    from xlwt, OpenPyXL, or XlsxWriter along with the values as nested list and an
    optional `first_cell`, which marks the upper left corner of where the nested list
    will be written to. The `excel.py` module also harmonizes the data type conversion
    as shown in [Table 8-2](#filepos977881).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-2\. Data type conversion
  prefs: []
  type: TYPE_NORMAL
- en: '|  Excel representation  |  Python data type  |'
  prefs: []
  type: TYPE_TB
- en: '|  Empty cell  |   `None` |'
  prefs: []
  type: TYPE_TB
- en: '|  Cell with a date format  |   `datetime.datetime` (except for pyxlsb) |'
  prefs: []
  type: TYPE_TB
- en: '|  Cell with a boolean  |   `bool` |'
  prefs: []
  type: TYPE_TB
- en: '|  Cell with an error  |   `str` (the error message) |'
  prefs: []
  type: TYPE_TB
- en: '|  String  |   `str` |'
  prefs: []
  type: TYPE_TB
- en: '|  Float  |   `float` or `int` |'
  prefs: []
  type: TYPE_TB
- en: 'Equipped with the `excel.py` module, we’re now ready to dive into the packages:
    the next four sections are about OpenPyXL, XlsxWriter, pyxlsb, and xlrd/xlwt/xlutils.
    They follow a cookbook style that allows you to get started quickly with each
    package. Instead of reading through it sequentially, I would recommend you to
    pick the package you need based on [Table 8-1](index_split_020.html#filepos964418),
    then jump directly to the corresponding section.'
  prefs: []
  type: TYPE_NORMAL
- en: THE WITH STATEMENT
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We’ll be using the `with` statement on various occasions in this chapter. If
    you need a refresher, have a look at the sidebar [“Context Managers and the with
    Statement”](index_split_019.html#filepos910476) in [Chapter 7](index_split_019.html#filepos863345).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: OpenPyXL
  prefs: []
  type: TYPE_NORMAL
- en: OpenPyXL is the only package in this section that can both read and write Excel
    files. You can even use it to edit Excel files—albeit only simple ones. Let’s
    start by looking at how reading works!
  prefs: []
  type: TYPE_NORMAL
- en: Reading with OpenPyXL
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sample code shows you how to perform common tasks when you use
    OpenPyXL for reading Excel files. To get the cell values, you need to open the
    workbook with `data_only=True`. The default is on `False`, which would return
    the formulas of the cells instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``1``]:``import``pandas``as``pd``import``openpyxl``import``excel``import``datetime``as``dt`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``2``]:``# Open the workbook to read cell values.``# The file is automatically
    closed again after loading the data.``book``=``openpyxl``.``load_workbook``(``"xl/stores.xlsx"``,``data_only``=``True``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``3``]:``# Get a worksheet object by name or index (0-based)``sheet``=``book``[``"2019"``]``sheet``=``book``.``worksheets``[``0``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``4``]:``# Get a list with all sheet names``book``.``sheetnames`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[4]: [''2019'', ''2020'', ''2019-2020'']`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``5``]:``# Loop through the sheet objects.``# Instead of "name", openpyxl
    uses "title".``for``i``in``book``.``worksheets``:``print``(``i``.``title``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`2019 2020 2019-2020`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``6``]:``# Getting the dimensions,``# i.e., the used range of the sheet``sheet``.``max_row``,``sheet``.``max_column`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[6]: (8, 6)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``7``]:``# Read the value of a single cell``# using "A1" notation and
    using cell indices (1-based)``sheet``[``"B6"``]``.``value``sheet``.``cell``(``row``=``6``,``column``=``2``)``.``value`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[7]: ''Boston''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``8``]:``# Read in a range of cell values by using our excel module``data``=``excel``.``read``(``book``[``"2019"``],``(``2``,``2``),``(``8``,``6``))``data``[:``2``]``#
    Print the first two rows`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[8]: [[''Store'', ''Employees'', ''Manager'', ''Since'', ''Flagship''],
             [''New York'', 10, ''Sarah'', datetime.datetime(2018, 7, 20, 0, 0), False]]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Writing with OpenPyXL
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenPyXL builds the Excel file in memory and writes out the file once you call
    the `save` method. The following code produces the file as shown in [Figure 8-1](#filepos1032954):'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``9``]:``import``openpyxl``from``openpyxl.drawing.image``import``Image``from``openpyxl.chart``import``BarChart``,``Reference``from``openpyxl.styles``import``Font``,``colors``from``openpyxl.styles.borders``import``Border``,``Side``from``openpyxl.styles.alignment``import``Alignment``from``openpyxl.styles.fills``import``PatternFill``import``excel`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``10``]:``# Instantiate a workbook``book``=``openpyxl``.``Workbook``()``#
    Get the first sheet and give it a name``sheet``=``book``.``active``sheet``.``title``=``"Sheet1"``#
    Writing individual cells using A1 notation``# and cell indices (1-based)``sheet``[``"A1"``]``.``value``=``"Hello
    1"``sheet``.``cell``(``row``=``2``,``column``=``1``,``value``=``"Hello 2"``)``#
    Formatting: fill color, alignment, border and font``font_format``=``Font``(``color``=``"FF0000"``,``bold``=``True``)``thin``=``Side``(``border_style``=``"thin"``,``color``=``"FF0000"``)``sheet``[``"A3"``]``.``value``=``"Hello
    3"``sheet``[``"A3"``]``.``font``=``font_format``sheet``[``"A3"``]``.``border``=``Border``(``top``=``thin``,``left``=``thin``,``right``=``thin``,``bottom``=``thin``)``sheet``[``"A3"``]``.``alignment``=``Alignment``(``horizontal``=``"center"``)``sheet``[``"A3"``]``.``fill``=``PatternFill``(``fgColor``=``"FFFF00"``,``fill_type``=``"solid"``)``#
    Number formatting (using Excel''s formatting strings)``sheet``[``"A4"``]``.``value``=``3.3333``sheet``[``"A4"``]``.``number_format``=``"0.00"``#
    Date formatting (using Excel''s formatting strings)``sheet``[``"A5"``]``.``value``=``dt``.``date``(``2016``,``10``,``13``)``sheet``[``"A5"``]``.``number_format``=``"mm/dd/yy"``# Formula:
    you must use the English name of the formula``# with commas as delimiters``sheet``[``"A6"``]``.``value``=``"=SUM(A4,
    2)"``# Image``sheet``.``add_image``(``Image``(``"images/python.png"``),``"C1"``)``#
    Two-dimensional list (we''re using our excel module)``data``=``[[``None``,``"North"``,``"South"``],``[``"Last
    Year"``,``2``,``5``],``[``"This Year"``,``3``,``6``]]``excel``.``write``(``sheet``,``data``,``"A10"``)``#
    Chart``chart``=``BarChart``()``chart``.``type``=``"col"``chart``.``title``=``"Sales
    Per Region"``chart``.``x_axis``.``title``=``"Regions"``chart``.``y_axis``.``title``=``"Sales"``chart_data``=``Reference``(``sheet``,``min_row``=``11``,``min_col``=``1``,``max_row``=``12``,``max_col``=``3``)``chart_categories``=``Reference``(``sheet``,``min_row``=``10``,``min_col``=``2``,``max_row``=``10``,``max_col``=``3``)``#
    from_rows interprets the data in the same way``# as if you would add a chart manually
    in Excel``chart``.``add_data``(``chart_data``,``titles_from_data``=``True``,``from_rows``=``True``)``chart``.``set_categories``(``chart_categories``)``sheet``.``add_chart``(``chart``,``"A15"``)``#
    Saving the workbook creates the file on disk``book``.``save``(``"openpyxl.xlsx"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you want to write an Excel template file, you’ll need to set the `template`
    attribute to `True` before saving it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``11``]:``book``=``openpyxl``.``Workbook``()``sheet``=``book``.``active``sheet``[``"A1"``]``.``value``=``"This
    is a template"``book``.``template``=``True``book``.``save``(``"template.xltx"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As you can see in the code, OpenPyXL is setting colors by providing a string
    like `FF0000`. This value is made up of three hex values (`FF`, `00`, and `00`)
    that correspond to the red/green/blue values of the desired color. Hex stands
    for hexadecimal and represents numbers using a base of sixteen instead of a base
    of ten that is used by our standard decimal system.
  prefs: []
  type: TYPE_NORMAL
- en: FINDING THE HEX VALUE OF A COLOR
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To find the desired hex value of a color in Excel, click on the paint dropdown
    that you would use to change the fill color of a cell, then select More Colors.
    Now select your color and read off its hex value from the menu.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. The file written by OpenPyXL (openpyxl.xlsx)
  prefs: []
  type: TYPE_NORMAL
- en: Editing with OpenPyXL
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no reader/writer package that can truly edit Excel files: in reality,
    OpenPyXL reads the file with everything it understands, then writes the file again
    from scratch—including any changes you make in between. This can be very powerful
    for simple Excel files that contain mainly formatted cells with data and formulas,
    but it’s limited when you have charts and other more advanced content in your
    spreadsheet as OpenPyXL will either change them or drop them altogether. For example,
    as of v3.0.5, OpenPyXL will rename charts and drop their title. Here is a simple
    editing example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``12``]:``# Read the stores.xlsx file, change a cell``# and store it
    under a new location/name.``book``=``openpyxl``.``load_workbook``(``"xl/stores.xlsx"``)``book``[``"2019"``][``"A1"``]``.``value``=``"modified"``book``.``save``(``"stores_edited.xlsx"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you want to write an xlsm file, OpenPyXL has to work off an existing file
    that you need to load with the `keep_vba` parameter set to `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``13``]:``book``=``openpyxl``.``load_workbook``(``"xl/macro.xlsm"``,``keep_vba``=``True``)``book``[``"Sheet1"``][``"A1"``]``.``value``=``"Click
    the button!"``book``.``save``(``"macro_openpyxl.xlsm"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The button in the example file is calling a macro that shows a message box.
    OpenPyXL covers a lot more functionality than I am able to cover in this section;
    it is therefore a good idea to have a look at the [official docs](https://oreil.ly/7qfYL).
    We will also see more functionality at the end of this chapter when we pick up
    the case study from the previous chapter again.
  prefs: []
  type: TYPE_NORMAL
- en: XlsxWriter
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name suggests, XlsxWriter can only write Excel files. The following
    code produces the same workbook as we previously produced with OpenPyXL, which
    is shown in [Figure 8-1](#filepos1032954). Note that XlsxWriter uses zero-based
    cell indices, while OpenPyXL uses one-based cell indices—make sure to take this
    into account if you switch between packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``14``]:``import``datetime``as``dt``import``xlsxwriter``import``excel`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``15``]:``# Instantiate a workbook``book``=``xlsxwriter``.``Workbook``(``"xlxswriter.xlsx"``)``#
    Add a sheet and give it a name``sheet``=``book``.``add_worksheet``(``"Sheet1"``)``#
    Writing individual cells using A1 notation``# and cell indices (0-based)``sheet``.``write``(``"A1"``,``"Hello
    1"``)``sheet``.``write``(``1``,``0``,``"Hello 2"``)``# Formatting: fill color,
    alignment, border and font``formatting``=``book``.``add_format``({``"font_color"``:``"#FF0000"``,``"bg_color"``:``"#FFFF00"``,``"bold"``:``True``,``"align"``:``"center"``,``"border"``:``1``,``"border_color"``:``"#FF0000"``})``sheet``.``write``(``"A3"``,``"Hello
    3"``,``formatting``)``# Number formatting (using Excel''s formatting strings)``number_format``=``book``.``add_format``({``"num_format"``:``"0.00"``})``sheet``.``write``(``"A4"``,``3.3333``,``number_format``)``#
    Date formatting (using Excel''s formatting strings)``date_format``=``book``.``add_format``({``"num_format"``:``"mm/dd/yy"``})``sheet``.``write``(``"A5"``,``dt``.``date``(``2016``,``10``,``13``),``date_format``)``# Formula:
    you must use the English name of the formula``# with commas as delimiters``sheet``.``write``(``"A6"``,``"=SUM(A4,
    2)"``)``# Image``sheet``.``insert_image``(``0``,``2``,``"images/python.png"``)``#
    Two-dimensional list (we''re using our excel module)``data``=``[[``None``,``"North"``,``"South"``],``[``"Last
    Year"``,``2``,``5``],``[``"This Year"``,``3``,``6``]]``excel``.``write``(``sheet``,``data``,``"A10"``)``# Chart:
    see the file "sales_report_xlsxwriter.py" in the``# companion repo to see how
    you can work with indices``# instead of cell addresses``chart``=``book``.``add_chart``({``"type"``:``"column"``})``chart``.``set_title``({``"name"``:``"Sales
    per Region"``})``chart``.``add_series``({``"name"``:``"=Sheet1!A11"``,``"categories"``:``"=Sheet1!B10:C10"``,``"values"``:``"=Sheet1!B11:C11"``})``chart``.``add_series``({``"name"``:``"=Sheet1!A12"``,``"categories"``:``"=Sheet1!B10:C10"``,``"values"``:``"=Sheet1!B12:C12"``})``chart``.``set_x_axis``({``"name"``:``"Regions"``})``chart``.``set_y_axis``({``"name"``:``"Sales"``})``sheet``.``insert_chart``(``"A15"``,``chart``)``#
    Closing the workbook creates the file on disk``book``.``close``()`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In comparison to OpenPyXL, XlsxWriter has to take a more complicated approach
    to write xlsm files as it is a pure writer package. First, you need to extract
    the macro code from an existing Excel file on the Anaconda Prompt (the example
    uses the macro.xlsm file, which you’ll find in the xl folder of the companion
    repo):'
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by changing into the xl directory, then find the path to vba_extract.py,
    a script that comes with XlsxWriter:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`(base)>` `cd C:\Users\``username``\python-for-excel\xl` `(base)>` `where vba_extract.py`
    `C:\Users\``username``\Anaconda3\Scripts\vba_extract.py`'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Then use this path in the following command:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`(base)>` `python C:\...\Anaconda3\Scripts\vba_extract.py macro.xlsm`'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: macOS
  prefs: []
  type: TYPE_NORMAL
- en: 'On macOS, the command is available as executable script and can be run like
    this:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`(base)>` `cd /Users/``username``/python-for-excel/xl` `(base)>` `vba_extract.py
    macro.xlsm`'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This will save the file vbaProject.bin in the directory where you are running
    the command. I have also included the extracted file in the xl folder of the companion
    repo. We will use it in the following sample to write a workbook with a macro
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``16``]:``book``=``xlsxwriter``.``Workbook``(``"macro_xlxswriter.xlsm"``)``sheet``=``book``.``add_worksheet``(``"Sheet1"``)``sheet``.``write``(``"A1"``,``"Click
    the button!"``)``book``.``add_vba_project``(``"xl/vbaProject.bin"``)``sheet``.``insert_button``(``"A3"``,``{``"macro"``:``"Hello"``,``"caption"``:``"Button
    1"``,``"width"``:``130``,``"height"``:``35``})``book``.``close``()`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: pyxlsb
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to the other reader libraries, pyxlsb offers less functionality but
    it’s your only option when it comes to reading Excel files in the binary xlsb
    format. pyxlsb is not part of Anaconda, so you will need to install it if you
    haven’t already done this. It is currently not available via Conda either, so
    use pip to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(base)>` `pip install pyxlsb`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You read sheets and cell values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``17``]:``import``pyxlsb``import``excel`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``18``]:``# Loop through sheets. With pyxlsb, the workbook``# and sheet
    objects can be used as context managers.``# book.sheets returns a list of sheet
    names, not objects!``# To get a sheet object, use get_sheet() instead.``with``pyxlsb``.``open_workbook``(``"xl/stores.xlsb"``)``as``book``:``for``sheet_name``in``book``.``sheets``:``with``book``.``get_sheet``(``sheet_name``)``as``sheet``:``dim``=``sheet``.``dimension``print``(``f``"Sheet
    ''{sheet_name}'' has "``f``"{dim.h} rows and {dim.w} cols"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Sheet ''2019'' has 7 rows and 5 cols Sheet ''2020'' has 7 rows and 5 cols
    Sheet ''2019-2020'' has 20 rows and 5 cols`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``19``]:``# Read in the values of a range of cells by using our excel
    module.``# Instead of "2019", you could also use its index (1-based).``with``pyxlsb``.``open_workbook``(``"xl/stores.xlsb"``)``as``book``:``with``book``.``get_sheet``(``"2019"``)``as``sheet``:``data``=``excel``.``read``(``sheet``,``"B2"``)``data``[:``2``]``#
    Print the first two rows`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[19]: [[''Store'', ''Employees'', ''Manager'', ''Since'', ''Flagship''],
              [''New York'', 10.0, ''Sarah'', 43301.0, False]]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'pyxlsb currently offers no way of recognizing cells with dates, so you will
    have to manually convert values from date-formatted cells into `datetime` objects
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``20``]:``from``pyxlsb``import``convert_date``convert_date``(``data``[``1``][``3``])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[20]: datetime.datetime(2018, 7, 20, 0, 0)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Remember, when you read the xlsb file format with a pandas version below 1.3,
    you need to specify the engine explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``21``]:``df``=``pd``.``read_excel``(``"xl/stores.xlsb"``,``engine``=``"pyxlsb"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: xlrd, xlwt, and xlutils
  prefs: []
  type: TYPE_NORMAL
- en: 'The combination of xlrd, xlwt, and xlutils offers roughly the same functionality
    for the legacy xls format that OpenPyXL offers for the xlsx format: xlrd reads,
    xlwt writes, and xlutils edits xls files. These packages aren’t actively developed
    anymore, but they are likely going to be relevant as long as there are still xls
    files around. xlutils is not part of Anaconda, so install it if you haven’t already:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(base)>` `conda install xlutils`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s get started with the reading part!
  prefs: []
  type: TYPE_NORMAL
- en: Reading with xlrd
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sample code shows you how to read the values from an Excel workbook
    with xlrd:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``22``]:``import``xlrd``import``xlwt``from``xlwt.Utils``import``cell_to_rowcol2``import``xlutils``import``excel`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``23``]:``# Open the workbook to read cell values. The file is``# automatically
    closed again after loading the data.``book``=``xlrd``.``open_workbook``(``"xl/stores.xls"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``24``]:``# Get a list with all sheet names``book``.``sheet_names``()`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[24]: [''2019'', ''2020'', ''2019-2020'']`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``25``]:``# Loop through the sheet objects``for``sheet``in``book``.``sheets``():``print``(``sheet``.``name``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`2019 2020 2019-2020`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``26``]:``# Get a sheet object by name or index (0-based)``sheet``=``book``.``sheet_by_index``(``0``)``sheet``=``book``.``sheet_by_name``(``"2019"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``27``]:``# Dimensions``sheet``.``nrows``,``sheet``.``ncols`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[27]: (8, 6)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``28``]:``# Read the value of a single cell``# using "A1" notation and
    using cell indices (0-based).``# The "*" unpacks the tuple that cell_to_rowcol2
    returns``# into individual arguments.``sheet``.``cell``(``*``cell_to_rowcol2``(``"B3"``))``.``value``sheet``.``cell``(``2``,``1``)``.``value`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[28]: ''New York''`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``29``]:``# Read in a range of cell values by using our excel module``data``=``excel``.``read``(``sheet``,``"B2"``)``data``[:``2``]``#
    Print the first two rows`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[29]: [[''Store'', ''Employees'', ''Manager'', ''Since'', ''Flagship''],
             [''New York'', 10.0, ''Sarah'', datetime.datetime(2018, 7, 20, 0, 0),
              False]]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: USED RANGE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unlike OpenPyXL and pyxlsb, xlrd returns the dimensions of cells with a value,
    instead of the used range of a sheet when using `sheet.nrows` and `sheet.ncols`.
    What Excel returns as used range often contains empty rows and columns at the
    bottom and at the right border of the range. This can, for example, happen when
    you delete the content of rows (by hitting the Delete key), rather than deleting
    the rows themselves (by right-clicking and selecting Delete).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Writing with xlwt
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code reproduces what we have done previously with OpenPyXL and
    XlsxWriter as shown in [Figure 8-1](index_split_021.html#filepos1032954). xlwt,
    however, cannot produce charts and only supports the `bmp` format for pictures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``30``]:``import``xlwt``from``xlwt.Utils``import``cell_to_rowcol2``import``datetime``as``dt``import``excel`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``31``]:``# Instantiate a workbook``book``=``xlwt``.``Workbook``()``#
    Add a sheet and give it a name``sheet``=``book``.``add_sheet``(``"Sheet1"``)``#
    Writing individual cells using A1 notation``# and cell indices (0-based)``sheet``.``write``(``*``cell_to_rowcol2``(``"A1"``),``"Hello
    1"``)``sheet``.``write``(``r``=``1``,``c``=``0``,``label``=``"Hello 2"``)``# Formatting:
    fill color, alignment, border and font``formatting``=``xlwt``.``easyxf``(``"font:
    bold on, color red;"``"align: horiz center;"``"borders: top_color red, bottom_color
    red,"``"right_color red, left_color red,"``"left thin, right thin,"``"top thin,
    bottom thin;"``"pattern: pattern solid, fore_color yellow;"``)``sheet``.``write``(``r``=``2``,``c``=``0``,``label``=``"Hello
    3"``,``style``=``formatting``)``# Number formatting (using Excel''s formatting
    strings)``number_format``=``xlwt``.``easyxf``(``num_format_str``=``"0.00"``)``sheet``.``write``(``3``,``0``,``3.3333``,``number_format``)``#
    Date formatting (using Excel''s formatting strings)``date_format``=``xlwt``.``easyxf``(``num_format_str``=``"mm/dd/yyyy"``)``sheet``.``write``(``4``,``0``,``dt``.``datetime``(``2012``,``2``,``3``),``date_format``)``# Formula:
    you must use the English name of the formula``# with commas as delimiters``sheet``.``write``(``5``,``0``,``xlwt``.``Formula``(``"SUM(A4,
    2)"``))``# Two-dimensional list (we''re using our excel module)``data``=``[[``None``,``"North"``,``"South"``],``[``"Last
    Year"``,``2``,``5``],``[``"This Year"``,``3``,``6``]]``excel``.``write``(``sheet``,``data``,``"A10"``)``#
    Picture (only allows to add bmp format)``sheet``.``insert_bitmap``(``"images/python.bmp"``,``0``,``2``)``#
    This writes the file to disk``book``.``save``(``"xlwt.xls"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Editing with xlutils
  prefs: []
  type: TYPE_NORMAL
- en: 'xlutils acts as a bridge between xlrd and xlwt. This makes it explicit that
    this is not a true editing operation: the spreadsheet is read including the formatting
    via xlrd (by setting `formatting_info=True`) and then written out again by xlwt,
    including the changes that were made in between:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``32``]:``import``xlutils.copy`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``33``]:``book``=``xlrd``.``open_workbook``(``"xl/stores.xls"``,``formatting_info``=``True``)``book``=``xlutils``.``copy``.``copy``(``book``)``book``.``get_sheet``(``0``)``.``write``(``0``,``0``,``"changed!"``)``book``.``save``(``"stores_edited.xls"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At this point, you know how to read and write an Excel workbook in a specific
    format. The next section moves on with a few advanced topics that include working
    with big Excel files and using pandas and the reader and writer packages together.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Reader and Writer Topics
  prefs: []
  type: TYPE_NORMAL
- en: 'If your files are bigger and more complex than the simple Excel files we used
    in the examples so far, relying on the default options may not be good enough
    anymore. Therefore, we start this section by looking at how to work with bigger
    files. Then, we’ll learn how to use pandas together with the reader and writer
    packages: this will open up the ability to style your pandas DataFrames the way
    you want. To conclude this section, we will use everything we learned in this
    chapter to make the Excel report from last chapter’s case study look much more
    professional.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Big Excel Files
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with big files can cause two issues: the reading and writing process
    may be slow or your computer may run out of memory. Usually, the memory issue
    is of bigger concern as it will cause your program to crash. When exactly a file
    is considered big always depends on the available resources on your system and
    your definition of slow. This section shows optimization techniques offered by
    the individual packages, allowing you to work with Excel files that push the limits.
    I’ll start by looking at the options for the writer libraries, followed by the
    options for the reader libraries. At the end of this section, I’ll show you how
    to read the sheets of a workbook in parallel to reduce processing time.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing with OpenPyXL
  prefs: []
  type: TYPE_NORMAL
- en: 'When writing large files with OpenPyXL, make sure to have the lxml package
    installed, as this makes the writing process faster. It is included in Anaconda,
    so there’s nothing you need to do about that. The critical option, though, is
    the `write_only=True` flag, which makes sure that the memory consumption remains
    low. It, however, forces you to write row by row by using the `append` method
    and won’t allow you to write single cells anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``34``]:``book``=``openpyxl``.``Workbook``(``write_only``=``True``)``#
    With write_only=True, book.active doesn''t work``sheet``=``book``.``create_sheet``()``#
    This will produce a sheet with 1000 x 200 cells``for``row``in``range``(``1000``):``sheet``.``append``(``list``(``range``(``200``)))``book``.``save``(``"openpyxl_optimized.xlsx"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Writing with XlsxWriter
  prefs: []
  type: TYPE_NORMAL
- en: 'XlsxWriter has a similar option like OpenPyXL called `constant_memory`. It
    forces you to write sequential rows, too. You enable the option by providing an
    `options` dictionary like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``35``]:``book``=``xlsxwriter``.``Workbook``(``"xlsxwriter_optimized.xlsx"``,``options``=``{``"constant_memory"``:``True``})``sheet``=``book``.``add_worksheet``()``#
    This will produce a sheet with 1000 x 200 cells``for``row``in``range``(``1000``):``sheet``.``write_row``(``row``,``0``,``list``(``range``(``200``)))``book``.``close``()`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Reading with xlrd
  prefs: []
  type: TYPE_NORMAL
- en: 'When reading big files in the legacy xls format, xlrd allows you to load sheets
    on demand, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``36``]:``with``xlrd``.``open_workbook``(``"xl/stores.xls"``,``on_demand``=``True``)``as``book``:``sheet``=``book``.``sheet_by_index``(``0``)``#
    Only loads the first sheet`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you wouldn’t use the workbook as a context manager as we do here, you would
    need to call `book.release_resources()` manually to properly close the workbook
    again. To use xlrd in this mode with pandas, use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``37``]:``with``xlrd``.``open_workbook``(``"xl/stores.xls"``,``on_demand``=``True``)``as``book``:``with``pd``.``ExcelFile``(``book``,``engine``=``"xlrd"``)``as``f``:``df``=``pd``.``read_excel``(``f``,``sheet_name``=``0``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Reading with OpenPyXL
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep memory under control when reading big Excel files with OpenPyXL, you
    should load the workbook with `read_only=True`. Since OpenPyXL doesn’t support
    the `with` statement, you will need to make sure to close the file again when
    you’re done. If your file contains links to external workbooks, you may additionally
    want to use `keep_links=False` to make it faster. `keep_links` makes sure that
    the references to external workbooks are kept, which may unnecessarily slow down
    the process if you are only interested in reading the values of a workbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``38``]:``book``=``openpyxl``.``load_workbook``(``"xl/big.xlsx"``,``data_only``=``True``,``read_only``=``True``,``keep_links``=``False``)``#
    Perform the desired read operations here``book``.``close``()``# Required with
    read_only=True`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Reading sheets in parallel
  prefs: []
  type: TYPE_NORMAL
- en: When you use pandas’ `read_excel` function to read in multiple sheets of a big
    workbook, you will find that this takes a long time (we’ll get to a concrete example
    in a moment). The reason is that pandas reads sheets sequentially, i.e., one after
    another. To speed things up, you could read the sheets in parallel. While there
    is no easy way to parallelize the writing of workbooks due to how the files are
    structured internally, reading multiple sheets in parallel is simple enough. However,
    since parallelization is an advanced topic, I left it out of the Python introduction
    and won’t go into details here either.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, if you want to take advantage of the multiple CPU cores that every
    modern computer has, you use the multiprocessing package that is part of the standard
    library. This will spawn multiple Python interpreters (usually one per CPU core),
    which work on a task in parallel. Instead of processing one sheet after another,
    you have one Python interpreter process the first sheet, while at the same time
    a second Python interpreter is processing the second sheet, etc. However, every
    additional Python interpreter takes some time to start up and uses additional
    memory, so if you have small files, they will most likely run slower when you
    parallelize the reading process instead of faster. In the case of a big file with
    multiple big sheets, multiprocessing can speed up the process substantially, though—always
    assuming that your system has the required memory to handle the workload. If you
    run the Jupyter notebook on Binder as shown in [Chapter 2](index_split_008.html#filepos96824),
    you won’t have enough memory and hence, the parallelized version will run slower.
    In the companion repo, you will find parallel_pandas.py, which is a simple implementation
    for reading the sheets in parallel, using OpenPyXL as the engine. It’s simple
    to use, so you won’t need to know anything about multiprocessing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import``parallel_pandas``parallel_pandas``.``read_excel``(``filename``,``sheet_name``=``None``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'By default, it will read in all sheets but you can provide a list of sheet
    names that you want to process. Like pandas, the function returns a dictionary
    in the following form: `{"sheetname": df}`, i.e., keys are the sheet names and
    the values are the DataFrames.'
  prefs: []
  type: TYPE_NORMAL
- en: THE %%TIME MAGIC COMMAND
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the following samples, I am going to make use of the `%%time` cell magic.
    I introduced magic commands in [Chapter 5](index_split_015.html#filepos482650)
    in connection with Matplotlib. `%%time` is a cell magic that can be very useful
    for simple performance tuning as it makes it easy to compare the execution time
    of two cells with different code snippets. Wall time is the elapsed time from
    the start to the end of the program, i.e., the cell. If you are on macOS or Linux,
    you will not just get the wall time but an additional line for CPU times along
    these lines:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`CPU times: user 49.4 s, sys: 108 ms, total: 49.5 s`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: CPU times measures the time spent on the CPU, which can be lower than the wall
    time (if the program has to wait for the CPU to become available) or higher (if
    the program is running on multiple CPU cores in parallel). To measure the time
    more accurately, use `%%timeit` instead of `%%time`, which runs the cell multiple
    times and takes the average of all runs. `%%time` and `%%timeit` are cell magics,
    i.e., they need to be on the first line of the cell and will measure the execution
    time of the whole cell. If, instead, you want to measure just a single line, start
    that line with `%time` or `%timeit`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let’s see how much faster the parallelized version reads the big.xlsx file
    that you will find in the companion repo’s xl folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``39``]:``%%``time``data``=``pd``.``read_excel``(``"xl/big.xlsx"``,``sheet_name``=``None``,``engine``=``"openpyxl"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Wall time: 49.5 s`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``40``]:``%%``time``import``parallel_pandas``data``=``parallel_pandas``.``read_excel``(``"xl/big.xlsx"``,``sheet_name``=``None``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Wall time: 12.1 s`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To get the DataFrame that represents Sheet1, you would write `data["Sheet1"]`
    in both cases. Looking at the wall time of both samples, you’ll see that the parallelized
    version was multiple times faster than `pd.read_excel` with this particular workbook
    and on my laptop with 6 CPU cores. If you want it even faster, parallelize OpenPyXL
    directly: you will also find an implementation for that in the companion repository
    (parallel_openpyxl.py), together with an implementation for xlrd to read the legacy
    xls format in parallel (parallel_xlrd.py). Going through the underlying packages
    instead of pandas will allow you to skip the transformation into a DataFrame or
    only apply the cleaning steps that you need, which will most likely help you make
    things faster—if that is your biggest concern.'
  prefs: []
  type: TYPE_NORMAL
- en: READING A SHEET IN PARALLEL WITH MODIN
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you are only reading in one huge sheet, it is worth looking at [Modin](https://oreil.ly/wQszH),
    a project that acts as a drop-in replacement for pandas. It parallelizes the reading
    process of a single sheet and provides impressive speed improvements. Since Modin
    requires a specific version of pandas, it could downgrade the version that comes
    with Anaconda when you install it. If you want to test it, I would recommend that
    you create a separate Conda environment for this to ensure you are not messing
    up your base environment. See [Appendix A](index_split_029.html#filepos1810552)
    for more detailed instructions on how to create a Conda environment:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`(base)>` `conda create --name modin python=3.8 -y` `(base)>` `conda activate
    modin` `(modin)>` `conda install -c conda-forge modin -y`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'On my machine and using the big.xlsx file, running the following code took
    roughly five seconds while it took pandas about twelve seconds:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`import``modin.pandas``data``=``modin``.``pandas``.``read_excel``(``"xl/big.xlsx"``,``sheet_name``=``0``,``engine``=``"openpyxl"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that you know how to deal with big files, let’s move on and see how we can
    use pandas and the low-level packages together to improve the default formatting
    when writing DataFrames to Excel files!
  prefs: []
  type: TYPE_NORMAL
- en: Formatting DataFrames in Excel
  prefs: []
  type: TYPE_NORMAL
- en: 'To format DataFrames in Excel the way we want, we can write code that uses
    pandas together with OpenPyXL or XlsxWriter. We’ll first use this combination
    to add a title to the exported DataFrame. We’ll then format a DataFrame’s header
    and index before wrapping this section up by formatting the data part of a DataFrame.
    Combining pandas with OpenPyXL for reading can also be occasionally useful, so
    let’s start with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``41``]:``with``pd``.``ExcelFile``(``"xl/stores.xlsx"``,``engine``=``"openpyxl"``)``as``xlfile``:``#
    Read a DataFrame``df``=``pd``.``read_excel``(``xlfile``,``sheet_name``=``"2020"``)``#
    Get the OpenPyXL workbook object``book``=``xlfile``.``book``# From here on, it''s
    OpenPyXL code``sheet``=``book``[``"2019"``]``value``=``sheet``[``"B3"``]``.``value``#
    Read a single value`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'When writing workbooks, it works analogously, allowing us to easily add a title
    to our DataFrame report:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``42``]:``with``pd``.``ExcelWriter``(``"pandas_and_openpyxl.xlsx"``,``engine``=``"openpyxl"``)``as``writer``:``df``=``pd``.``DataFrame``({``"col1"``:``[``1``,``2``,``3``,``4``],``"col2"``:``[``5``,``6``,``7``,``8``]})``#
    Write a DataFrame``df``.``to_excel``(``writer``,``"Sheet1"``,``startrow``=``4``,``startcol``=``2``)``#
    Get the OpenPyXL workbook and sheet objects``book``=``writer``.``book``sheet``=``writer``.``sheets``[``"Sheet1"``]``#
    From here on, it''s OpenPyXL code``sheet``[``"A1"``]``.``value``=``"This is a
    Title"``# Write a single cell value`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: These samples use OpenPyXL, but it works conceptually the same with the other
    packages. Let’s now continue with finding out how we can format the index and
    header of a DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting a DataFrame’s index and headers
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to get complete control over the formatting of the index and
    column headers is to simply write them yourself. The following sample shows you
    how to do this with OpenPyXL and XlsxWriter, respectively. You can see the output
    in [Figure 8-2](#filepos1205246). Let’s start by creating a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``43``]:``df``=``pd``.``DataFrame``({``"col1"``:``[``1``,``-``2``],``"col2"``:``[``-``3``,``4``]},``index``=``[``"row1"``,``"row2"``])``df``.``index``.``name``=``"ix"``df`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[43]:       col1  col2          ix          row1     1    -3          row2   
    -2     4`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To format the index and headers with OpenPyXL, do as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``44``]:``from``openpyxl.styles``import``PatternFill`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``45``]:``with``pd``.``ExcelWriter``(``"formatting_openpyxl.xlsx"``,``engine``=``"openpyxl"``)``as``writer``:``#
    Write out the df with the default formatting to A1``df``.``to_excel``(``writer``,``startrow``=``0``,``startcol``=``0``)``#
    Write out the df with custom index/header formatting to A6``startrow``,``startcol``=``0``,``5``#
    1\. Write out the data part of the DataFrame``df``.``to_excel``(``writer``,``header``=``False``,``index``=``False``,``startrow``=``startrow``+``1``,``startcol``=``startcol``+``1``)``#
    Get the sheet object and create a style object``sheet``=``writer``.``sheets``[``"Sheet1"``]``style``=``PatternFill``(``fgColor``=``"D9D9D9"``,``fill_type``=``"solid"``)``#
    2\. Write out the styled column headers``for``i``,``col``in``enumerate``(``df``.``columns``):``sheet``.``cell``(``row``=``startrow``+``1``,``column``=``i``+``startcol``+``2``,``value``=``col``)``.``fill``=``style``#
    3\. Write out the styled index``index``=``[``df``.``index``.``name``if``df``.``index``.``name``else``None``]``+``list``(``df``.``index``)``for``i``,``row``in``enumerate``(``index``):``sheet``.``cell``(``row``=``i``+``startrow``+``1``,``column``=``startcol``+``1``,``value``=``row``)``.``fill``=``style`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To format the index and headers with XlsxWriter instead, you’ll need to adjust
    the code slightly:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``46``]:``# Formatting index/headers with XlsxWriter``with``pd``.``ExcelWriter``(``"formatting_xlsxwriter.xlsx"``,``engine``=``"xlsxwriter"``)``as``writer``:``#
    Write out the df with the default formatting to A1``df``.``to_excel``(``writer``,``startrow``=``0``,``startcol``=``0``)``#
    Write out the df with custom index/header formatting to A6``startrow``,``startcol``=``0``,``5``#
    1\. Write out the data part of the DataFrame``df``.``to_excel``(``writer``,``header``=``False``,``index``=``False``,``startrow``=``startrow``+``1``,``startcol``=``startcol``+``1``)``#
    Get the book and sheet object and create a style object``book``=``writer``.``book``sheet``=``writer``.``sheets``[``"Sheet1"``]``style``=``book``.``add_format``({``"bg_color"``:``"#D9D9D9"``})``#
    2\. Write out the styled column headers``for``i``,``col``in``enumerate``(``df``.``columns``):``sheet``.``write``(``startrow``,``startcol``+``i``+``1``,``col``,``style``)``#
    3\. Write out the styled index``index``=``[``df``.``index``.``name``if``df``.``index``.``name``else``None``]``+``list``(``df``.``index``)``for``i``,``row``in``enumerate``(``index``):``sheet``.``write``(``startrow``+``i``,``startcol``,``row``,``style``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With the index and header formatted, let’s see how we can style the data part!
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2\. A DataFrame with the default format (left) and with a custom format
    (right)
  prefs: []
  type: TYPE_NORMAL
- en: Formatting a DataFrame’s data part
  prefs: []
  type: TYPE_NORMAL
- en: 'The possibilities you have to format the data part of a DataFrame depend on
    the package you’re using: if you use pandas’ `to_excel` method, OpenPyXL can apply
    a format to each cell, while XlsxWriter can only apply formats on a row or column
    basis. For example, to set the number format of the cells to three decimals and
    center-align the content as shown in [Figure 8-3](#filepos1221576), do the following
    with OpenPyXL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``47``]:``from``openpyxl.styles``import``Alignment`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``48``]:``with``pd``.``ExcelWriter``(``"data_format_openpyxl.xlsx"``,``engine``=``"openpyxl"``)``as``writer``:``#
    Write out the DataFrame``df``.``to_excel``(``writer``)``# Get the book and sheet
    objects``book``=``writer``.``book``sheet``=``writer``.``sheets``[``"Sheet1"``]``#
    Formatting individual cells``nrows``,``ncols``=``df``.``shape``for``row``in``range``(``nrows``):``for``col``in``range``(``ncols``):``#
    +1 to account for the header/index``# +1 since OpenPyXL is 1-based``cell``=``sheet``.``cell``(``row``=``row``+``2``,``column``=``col``+``2``)``cell``.``number_format``=``"0.000"``cell``.``alignment``=``Alignment``(``horizontal``=``"center"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For XlsxWriter, adjust the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``49``]:``with``pd``.``ExcelWriter``(``"data_format_xlsxwriter.xlsx"``,``engine``=``"xlsxwriter"``)``as``writer``:``#
    Write out the DataFrame``df``.``to_excel``(``writer``)``# Get the book and sheet
    objects``book``=``writer``.``book``sheet``=``writer``.``sheets``[``"Sheet1"``]``#
    Formatting the columns (individual cells can''t be formatted)``number_format``=``book``.``add_format``({``"num_format"``:``"0.000"``,``"align"``:``"center"``})``sheet``.``set_column``(``first_col``=``1``,``last_col``=``2``,``cell_format``=``number_format``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3\. A DataFrame with a formatted data part
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alternative, pandas offers experimental support for the `style` property
    of DataFrames. Experimental means that the syntax can change at any point in time.
    Since styles were introduced to format the DataFrames in HTML format, they use
    CSS syntax. CSS stands for cascading style sheets and is used to define the style
    of HTML elements. To apply the same format as in the previous example (three decimals
    and center align), you’ll need to apply a function to every element of a `Styler`
    object via `applymap`. You get a `Styler` object via the `df.style` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``50``]:``df``.``style``.``applymap``(``lambda``x``:``"number-format:
    0.000;"``"text-align: center"``)``\` `.``to_excel``(``"styled.xlsx"``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The outcome of this code is the same as shown in [Figure 8-3](#filepos1221576).
    For more details on the DataFrame style approach, please refer directly to the
    [styling docs](https://oreil.ly/_JzfP).
  prefs: []
  type: TYPE_NORMAL
- en: 'Without having to rely on the style attribute, pandas offers support to format
    the date and datetime objects as shown in [Figure 8-4](#filepos1229706):'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``51``]:``df``=``pd``.``DataFrame``({``"Date"``:``[``dt``.``date``(``2020``,``1``,``1``)],``"Datetime"``:``[``dt``.``datetime``(``2020``,``1``,``1``,``10``)]})``with``pd``.``ExcelWriter``(``"date.xlsx"``,``date_format``=``"yyyy-mm-dd"``,``datetime_format``=``"yyyy-mm-dd
    hh:mm:ss"``)``as``writer``:``df``.``to_excel``(``writer``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](images/00013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-4\. A DataFrame with formatted dates
  prefs: []
  type: TYPE_NORMAL
- en: OTHER READER AND WRITER PACKAGES
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Apart from the packages that we have looked at in this chapter, there are a
    few others that may be interesting for specific use cases:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: pyexcel
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[pyexcel](http://pyexcel.org) offers a harmonized syntax across different Excel
    packages and other file formats including CSV files and OpenOffice files.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: PyExcelerate
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The goal of [PyExcelerate](https://oreil.ly/yJax7) is to write Excel files in
    the fastest possible way.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: pylightxl
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[pylightxl](https://oreil.ly/efjt4) can read xlsx and xlsm files and write
    xlsx files.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: styleframe
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[styleframe](https://oreil.ly/nQUg9) wraps pandas and OpenPyXL to produce Excel
    files with nicely formatted DataFrames.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: oletools
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[oletools](https://oreil.ly/SG-Jy) is not a classic reader or writer package
    but can be used to analyze Microsoft Office documents, e.g., for malware analysis.
    It offers a convenient way to extract VBA code from Excel workbooks.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that you know how to format DataFrames in Excel, it’s time to take another
    stab at the case study from the previous chapter and see if we can improve the
    Excel report with the knowledge of this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: 'Case Study (Revisited): Excel Reporting'
  prefs: []
  type: TYPE_NORMAL
- en: Having made it to the end of this chapter, you know enough to be able to go
    back to the Excel report from last chapter’s case study and make it visually more
    appealing. If you like, go back to sales_report_pandas.py in the companion repository
    and try to turn it into the report as shown in [Figure 8-5](#filepos1233720).
  prefs: []
  type: TYPE_NORMAL
- en: 'The red numbers are sales figures that are below 20,000\. I haven’t touched
    every aspect of formatting in this chapter (like how to apply conditional formatting),
    so you will have to use the documentation of the package you choose to work with.
    To compare your solution, I have included two versions of the script that produce
    this report in the companion repo. The first version is based on OpenPyXL (sales_report_openpyxl.py)
    and the other one is based on XlsxWriter (sales_report_xlsxwriter.py). Seeing
    the scripts side-by-side may also allow you to make a more educated decision about
    which package you want to pick for your next writer task. We will get back to
    this case study one more time in the next chapter: there, we’ll rely on an installation
    of Microsoft Excel to work with report templates.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-5\. The revisited sales report as created by sales_report_openpyxl.py
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I introduced you to the reader and writer packages that pandas
    uses under the hood. Using them directly allows us to read and write Excel workbooks
    without needing to have pandas installed. However, using them in combination with
    pandas enables us to enhance the Excel DataFrame reports by adding titles, charts,
    and formatting. While the current reader and writer packages are incredibly powerful,
    I still hope that we’ll see a “NumPy moment” one day that unites the efforts of
    all the developers into a single project. It would be great to know which package
    to use without having to look at a table first and without having to use a different
    syntax for each type of Excel file. In that sense, it makes sense to start with
    pandas and only fall back to the reader and writer packages when you need additional
    functionality that pandas doesn’t cover.
  prefs: []
  type: TYPE_NORMAL
- en: 'Excel, however, is so much more than just a data file or a report: the Excel
    application is one of the most intuitive user interfaces where users can type
    in a few numbers and get it to display the information they are looking for. Automating
    the Excel application instead of reading and writing Excel files opens up a whole
    new range of functionality that we are going to explore in [Part IV](index_split_023.html#filepos1235617).
    The next chapter starts this journey by showing you how to control Excel from
    Python remotely.'
  prefs: []
  type: TYPE_NORMAL
- en: Part IV. Programming the Excel Application with xlwings
  prefs: []
  type: TYPE_NORMAL
