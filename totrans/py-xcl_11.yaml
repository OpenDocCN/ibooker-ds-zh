- en: Chapter 8\. Excel File Manipulation with Reader and Writer Packages
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 第 8 章\. 使用读取器和写入器包进行 Excel 文件操作
- en: 'This chapter introduces you to OpenPyXL, XlsxWriter, pyxlsb, xlrd, and xlwt:
    these are the packages that can read and write Excel files and are used by pandas
    under the hood when you call the `read_excel` or `to_excel` functions. Using the
    reader and writer packages directly allows you to create more complex Excel reports
    as well as fine-tune the reading process. Also, should you ever work on a project
    where you only need to read and write Excel files without the need for the rest
    of the pandas functionality, installing the full NumPy/pandas stack would probably
    be overkill. We’ll start this chapter by learning when to use which package and
    how their syntax works before looking at a few advanced topics, including how
    to work with big Excel files and how to combine pandas with the reader and writer
    packages to improve the styling of DataFrames. To conclude, we will pick up the
    case study from the beginning of the last chapter again and enhance the Excel
    report by formatting the table and adding a chart. Like the last chapter, this
    chapter does not require an installation of Excel, which means that all code samples
    run on Windows, macOS, and Linux.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 OpenPyXL、XlsxWriter、pyxlsb、xlrd 和 xlwt：这些是可以读写 Excel 文件的包，并且在调用 `read_excel`
    或 `to_excel` 函数时被 pandas 底层使用。直接使用读取器和写入器包可以让您创建更复杂的 Excel 报告，并且可以微调读取过程。此外，如果您曾经需要在一个只需要读写
    Excel 文件而不需要其他 pandas 功能的项目中工作，安装完整的 NumPy/pandas 堆栈可能会有些过火。我们将从学习何时使用哪个包以及它们的语法工作开始本章，然后再讨论一些高级主题，包括如何处理大型
    Excel 文件以及如何将 pandas 与读取器和写入器包结合起来以改进 DataFrame 的样式。最后，我们将再次回顾上一章开头的案例研究，并通过格式化表格和添加图表来增强
    Excel 报告。与上一章类似，本章不需要安装 Excel，这意味着所有的代码示例都可以在 Windows、macOS 和 Linux 上运行。
- en: The Reader and Writer Packages
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 读取器和写入器包
- en: 'The reader and writer landscape can be a bit overwhelming: we are going to
    look at no less than six packages in this section as almost every Excel file type
    requires a different package. The fact that each package uses a different syntax
    that often deviates substantially from the original Excel object model doesn’t
    make it easier—I’ll say more about the Excel object model in the next chapter.
    This means that you will likely have to look up a lot of commands, even if you
    are a seasoned VBA developer. This section starts with an overview of when you
    need which package before it introduces a helper module that makes working with
    these packages a little easier. After that, it presents each of the packages in
    a cookbook style, where you can look up how the most commonly used commands work.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 读取器和写入器的使用场景可能有些令人不知所措：本节将介绍不少于六个包，因为几乎每种 Excel 文件类型都需要不同的包。每个包使用不同的语法，通常与原始的
    Excel 对象模型有很大不同，这并不让人更容易——我将在下一章中更多地讨论 Excel 对象模型。这意味着即使您是经验丰富的 VBA 开发人员，您也可能需要查找很多命令。本节从概述何时需要使用哪个包开始，然后介绍一个辅助模块，使使用这些包变得稍微容易一些。之后，它以食谱的形式呈现每个包，您可以查阅最常用命令的工作方式。
- en: When to Use Which Package
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 何时使用哪个包
- en: 'This section introduces the following six packages to read, write, and edit
    Excel files:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了以下六个用于读取、写入和编辑 Excel 文件的包：
- en: '[OpenPyXL](https://oreil.ly/3jHQM)'
  id: totrans-6
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[OpenPyXL](https://oreil.ly/3jHQM)'
- en: '[XlsxWriter](https://oreil.ly/7jI3T)'
  id: totrans-7
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[XlsxWriter](https://oreil.ly/7jI3T)'
- en: '[pyxlsb](https://oreil.ly/sEHXS)'
  id: totrans-8
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[pyxlsb](https://oreil.ly/sEHXS)'
- en: '[xlrd](https://oreil.ly/tSam7)'
  id: totrans-9
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[xlrd](https://oreil.ly/tSam7)'
- en: '[xlwt](https://oreil.ly/wPSLe)'
  id: totrans-10
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[xlwt](https://oreil.ly/wPSLe)'
- en: '[xlutils](https://oreil.ly/MTFOL)'
  id: totrans-11
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[xlutils](https://oreil.ly/MTFOL)'
- en: 'To understand which package can do what, have a look at [Table 8-1](#filepos964418).
    For example, to read the xlsx file format, you will have to use the OpenPyXL package:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解哪个包可以做什么，请查看[表 8-1](#filepos964418)。例如，要读取 xlsx 文件格式，您将需要使用 OpenPyXL 包：
- en: Table 8-1\. When to use which package
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-1\. 何时使用哪个包
- en: '|  Excel File Format  |  Read  |  Write  |  Edit  |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|  Excel 文件格式  |  读取  |  写入  |  编辑  |'
- en: '|   `xlsx` |  OpenPyXL  |  OpenPyXL, XlsxWriter  |  OpenPyXL  |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|   `xlsx` |  OpenPyXL  |  OpenPyXL, XlsxWriter  |  OpenPyXL  |'
- en: '|   `xlsm` |  OpenPyXL  |  OpenPyXL, XlsxWriter  |  OpenPyXL  |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|   `xlsm` |  OpenPyXL  |  OpenPyXL, XlsxWriter  |  OpenPyXL  |'
- en: '|   `xltx`, `xltm` |  OpenPyXL  |  OpenPyXL  |  OpenPyXL  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|   `xltx`, `xltm` |  OpenPyXL  |  OpenPyXL  |  OpenPyXL  |'
- en: '|   `xlsb` |  pyxlsb  |  -  |  -  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|   `xlsb` |  pyxlsb  |  -  |  -  |'
- en: '|   `xls`, `xlt` |  xlrd  |  xlwt  |  xlutils  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|   `xls`, `xlt` |  xlrd  |  xlwt  |  xlutils  |'
- en: 'If you want to write xlsx or xlsm files, you need to decide between OpenPyXL
    and XlsxWriter. Both packages cover similar functionality, but each package may
    have a few unique features that the other one doesn’t have. As both libraries
    are actively being developed, this is changing over time. Here is a high-level
    overview of where they differ:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想写入 xlsx 或 xlsm 文件，你需要在 OpenPyXL 和 XlsxWriter 之间做出选择。这两个包都涵盖了类似的功能，但每个包可能有一些其他包没有的独特功能。由于这两个库都在积极开发中，这种情况随着时间的推移而变化。以下是它们的区别的高级概述：
- en: OpenPyXL can read, write, and edit while XlsxWriter can only write.
  id: totrans-21
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: OpenPyXL 可以读取、写入和编辑，而 XlsxWriter 只能写入。
- en: OpenPyXL makes it easier to produce Excel files with VBA macros.
  id: totrans-22
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: OpenPyXL 更容易生成带有 VBA 宏的 Excel 文件。
- en: XlsxWriter is better documented.
  id: totrans-23
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: XlsxWriter 的文档更好。
- en: XlsxWriter tends to be faster than OpenPyXL, but depending on the size of the
    workbook you’re writing, the differences may not be significant.
  id: totrans-24
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: XlsxWriter 的速度比 OpenPyXL 快，但根据你写入的工作簿的大小，差异可能不显著。
- en: WHERE IS XLWINGS?
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: XLWINGS 在哪里？
- en: 'If you are wondering where xlwings is in table [Table 8-1](index_split_020.html#filepos964418),
    then the answer is nowhere or everywhere, depending on your use case: unlike any
    of the packages in this chapter, xlwings depends on the Excel application, which
    often isn’t available, for example, if you need to run your scripts on Linux.
    If, on the other hand, you are OK with running your scripts on Windows or macOS
    where you have access to an installation of Excel, xlwings can indeed be used
    as an alternative to all packages in this chapter. Since Excel dependency is such
    a fundamental difference between xlwings and all the other Excel packages, I am
    introducing xlwings in the next chapter, which starts [Part IV](index_split_023.html#filepos1235617)
    of this book.'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你想知道表 [表 8-1](index_split_020.html#filepos964418) 中的 xlwings 在哪里，答案是无处不在或无处不在，这取决于你的用例：与本章中的任何包不同，xlwings
    依赖于 Excel 应用程序，这通常是不可用的，例如，如果你需要在 Linux 上运行你的脚本。另一方面，如果你愿意在 Windows 或 macOS 上运行你的脚本，那么你就可以访问安装的
    Excel，xlwings 确实可以作为本章中所有包的替代品使用。由于 Excel 依赖性是 xlwings 与所有其他 Excel 包之间的基本差异，我会在下一章中介绍
    xlwings，这一章开始了本书的 [第四部分](index_split_023.html#filepos1235617)。
- en: 'pandas uses the writer package it can find and if you have both OpenPyXL and
    XlsxWriter installed, XlsxWriter is the default. If you want to choose which package
    pandas should use, specify the `engine` parameter in the `read_excel` or `to_excel`
    functions or the `ExcelFile` and `ExcelWriter` classes, respectively. The engine
    is the package name in lower case, so to write a file with OpenPyXL instead of
    XlsxWriter, run the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 使用它能找到的 writer 包，如果你同时安装了 OpenPyXL 和 XlsxWriter，XlsxWriter 就是默认的。如果你想选择
    pandas 应该使用哪个包，请在 `read_excel` 或 `to_excel` 函数的 `engine` 参数中指定，或者在 `ExcelFile`
    和 `ExcelWriter` 类中分别指定。引擎是包名的小写形式，因此要使用 OpenPyXL 而不是 XlsxWriter 写文件，运行以下命令：
- en: '`df``.``to_excel``(``"filename.xlsx"``,``engine``=``"openpyxl"``)`'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`df``.``to_excel``(``"filename.xlsx"``,``engine``=``"openpyxl"``)`'
- en: 'Once you know which package you need, there is a second challenge waiting for
    you: most of these packages require you to write quite a bit of code to read or
    write a range of cells, and each package uses a different syntax. To make your
    life easier, I created a helper module that I’ll introduce next.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道你需要哪个包，就会有第二个挑战在等着你：大多数这些包需要你写相当多的代码来读取或写入一系列单元格，而且每个包都使用不同的语法。为了让你的生活更轻松，我创建了一个辅助模块，我将在下面介绍。
- en: The excel.py Module
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: excel.py 模块
- en: 'I have created the `excel.py` module to make your life easier when using the
    reader and writer packages, as it takes care of the following issues:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了 `excel.py` 模块，以便在使用读取器和写入器包时让你的生活更轻松，因为它解决了以下问题：
- en: Package switching
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 包交换
- en: Having to switch the reader or writer package is a relatively common scenario.
    For example, Excel files tend to grow in size over time, which many users fight
    by switching the file format from xlsx to xlsb as this can substantially reduce
    the file size. In that case, you will have to switch away from OpenPyXL to pyxlsb.
    This forces you to rewrite your OpenPyXL code to reflect pyxlsb’s syntax.
  id: totrans-33
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不得不切换读取器或写入器包是一个相对常见的情况。例如，Excel 文件往往会随着时间的推移而增大，许多用户通过将文件格式从 xlsx 切换到 xlsb
    来对抗这一点，因为这可以大幅减小文件大小。在这种情况下，你将不得不从 OpenPyXL 切换到 pyxlsb。这会迫使你重写 OpenPyXL 代码以反映
    pyxlsb 的语法。
- en: Data type conversion
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型转换
- en: 'This is connected to the previous point: when switching packages, you don’t
    just have to adjust the syntax of your code, but you also need to watch out for
    different data types that these packages return for the same cell content. For
    example, OpenPyXL returns `None` for empty cells, while xlrd returns an empty
    string.'
  id: totrans-35
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这与前面的观点有关：在切换包时，不仅需要调整代码的语法，还需要注意这些包针对相同单元格内容返回的不同数据类型。例如，OpenPyXL 对空单元格返回 `None`，而
    xlrd 返回空字符串。
- en: Cell looping
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 单元格循环
- en: 'The reader and writer packages are low-level packages: this means that they
    lack convenience functions that would allow you to tackle common tasks easily.
    For example, most of the packages require you to loop through every single cell
    that you are going to read or write.'
  id: totrans-37
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 读取器和写入器包是低级别包：这意味着它们缺乏能让你轻松处理常见任务的便利函数。例如，大多数包要求你循环遍历每个要读取或写入的单元格。
- en: 'You will find the `excel.py` module in the companion repository and we will
    use it in the upcoming sections, but as a preview, here is the syntax to read
    and write values:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在配套的仓库中找到 `excel.py` 模块，并且我们将在即将展示的章节中使用它。作为预览，这里是读取和写入值的语法：
- en: '`import``excel``values``=``excel``.``read``(``sheet_object``,``first_cell``=``"A1"``,``last_cell``=``None``)``excel``.``write``(``sheet_object``,``values``,``first_cell``=``"A1"``)`'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`import``excel``values``=``excel``.``read``(``sheet_object``,``first_cell``=``"A1"``,``last_cell``=``None``)``excel``.``write``(``sheet_object``,``values``,``first_cell``=``"A1"``)`'
- en: 'The `read` function accepts a `sheet` object from one of the following packages:
    xlrd, OpenPyXL, or pyxlsb. It also accepts the optional arguments `first_cell`
    and `last_cell`. They can be provided in either the `A1` notation or as row-column-tuple
    with Excel’s one-based indices: `(1, 1)`. The default value for the `first_cell`
    is `A1` whereas the default value for `last_cell` is the bottom right corner of
    the used range. Hence, if you only provide the `sheet` object, it will read the
    whole sheet. The `write` function works similarly: it expects a `sheet` object
    from xlwt, OpenPyXL, or XlsxWriter along with the values as nested list and an
    optional `first_cell`, which marks the upper left corner of where the nested list
    will be written to. The `excel.py` module also harmonizes the data type conversion
    as shown in [Table 8-2](#filepos977881).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`read` 函数接受来自以下包之一的 `sheet` 对象：xlrd、OpenPyXL 或 pyxlsb。它还接受可选参数 `first_cell`
    和 `last_cell`。它们可以以 `A1` 表示法或带有 Excel 基于一的索引的行列元组 `(1, 1)` 提供。`first_cell` 的默认值是
    `A1`，而 `last_cell` 的默认值是已使用范围的右下角。因此，如果只提供 `sheet` 对象，它将读取整个工作表。`write` 函数工作方式类似：它期望来自
    xlwt、OpenPyXL 或 XlsxWriter 的 `sheet` 对象以及作为嵌套列表的值，以及一个可选的 `first_cell`，它标记了嵌套列表将写入的左上角位置。`excel.py`
    模块还展示了如 [表 8-2](#filepos977881) 所示的数据类型转换的协调工作。'
- en: Table 8-2\. Data type conversion
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-2\. 数据类型转换
- en: '|  Excel representation  |  Python data type  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|  Excel 表示  |  Python 数据类型  |'
- en: '|  Empty cell  |   `None` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '|  空单元格  |   `None` |'
- en: '|  Cell with a date format  |   `datetime.datetime` (except for pyxlsb) |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|  带有日期格式的单元格  |   `datetime.datetime`（除了 pyxlsb） |'
- en: '|  Cell with a boolean  |   `bool` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|  布尔值单元格  |   `bool` |'
- en: '|  Cell with an error  |   `str` (the error message) |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|  带有错误的单元格  |   `str`（错误消息） |'
- en: '|  String  |   `str` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|  字符串  |   `str` |'
- en: '|  Float  |   `float` or `int` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|  浮点数  |   `float` 或 `int` |'
- en: 'Equipped with the `excel.py` module, we’re now ready to dive into the packages:
    the next four sections are about OpenPyXL, XlsxWriter, pyxlsb, and xlrd/xlwt/xlutils.
    They follow a cookbook style that allows you to get started quickly with each
    package. Instead of reading through it sequentially, I would recommend you to
    pick the package you need based on [Table 8-1](index_split_020.html#filepos964418),
    then jump directly to the corresponding section.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们装备好使用 `excel.py` 模块，准备深入探讨以下几个包：OpenPyXL、XlsxWriter、pyxlsb 和 xlrd/xlwt/xlutils。这些部分都采用了食谱式的样式，让你可以快速入门每个包。建议你根据
    [表 8-1](index_split_020.html#filepos964418) 选择你需要的包，然后直接跳转到相应的章节，而不是顺序阅读。
- en: THE WITH STATEMENT
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: WITH 语句
- en: We’ll be using the `with` statement on various occasions in this chapter. If
    you need a refresher, have a look at the sidebar [“Context Managers and the with
    Statement”](index_split_019.html#filepos910476) in [Chapter 7](index_split_019.html#filepos863345).
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章中我们会在多个场合使用 `with` 语句。如果需要温习，请参阅第7章侧边栏 [“上下文管理器和 with 语句”](index_split_019.html#filepos910476)。
- en: OpenPyXL
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: OpenPyXL
- en: OpenPyXL is the only package in this section that can both read and write Excel
    files. You can even use it to edit Excel files—albeit only simple ones. Let’s
    start by looking at how reading works!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: OpenPyXL 是本节唯一一个既能读取又能写入 Excel 文件的包。你甚至可以用它来编辑 Excel 文件——尽管只能是简单的文件。让我们先来看看如何进行读取操作！
- en: Reading with OpenPyXL
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenPyXL 进行读取
- en: 'The following sample code shows you how to perform common tasks when you use
    OpenPyXL for reading Excel files. To get the cell values, you need to open the
    workbook with `data_only=True`. The default is on `False`, which would return
    the formulas of the cells instead:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例代码展示了在使用 OpenPyXL 读取 Excel 文件时执行常见任务的方法。要获取单元格的值，需要使用 `data_only=True`
    打开工作簿。默认为 `False`，这会返回单元格的公式而不是值：
- en: '`In``[``1``]:``import``pandas``as``pd``import``openpyxl``import``excel``import``datetime``as``dt`'
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``1``]:``import``pandas``as``pd``import``openpyxl``import``excel``import``datetime``as``dt`'
- en: '`In``[``2``]:``# Open the workbook to read cell values.``# The file is automatically
    closed again after loading the data.``book``=``openpyxl``.``load_workbook``(``"xl/stores.xlsx"``,``data_only``=``True``)`'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``2``]:``# 打开工作簿以读取单元格值。``# 加载数据后文件会自动关闭。``book``=``openpyxl``.``load_workbook``(``"xl/stores.xlsx"``,``data_only``=``True``)`'
- en: '`In``[``3``]:``# Get a worksheet object by name or index (0-based)``sheet``=``book``[``"2019"``]``sheet``=``book``.``worksheets``[``0``]`'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``3``]:``# 根据名称或索引（从0开始）获取工作表对象``sheet``=``book``[``"2019"``]``sheet``=``book``.``worksheets``[``0``]`'
- en: '`In``[``4``]:``# Get a list with all sheet names``book``.``sheetnames`'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``4``]:``# 获取包含所有工作表名称的列表``book``.``sheetnames`'
- en: '`Out[4]: [''2019'', ''2020'', ''2019-2020'']`'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[4]: [''2019'', ''2020'', ''2019-2020'']`'
- en: '`In``[``5``]:``# Loop through the sheet objects.``# Instead of "name", openpyxl
    uses "title".``for``i``in``book``.``worksheets``:``print``(``i``.``title``)`'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``5``]:``# 遍历工作表对象。``# openpyxl 使用 "title" 而不是 "name"。``for``i``in``book``.``worksheets``:``print``(``i``.``title``)`'
- en: '`2019 2020 2019-2020`'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`2019 2020 2019-2020`'
- en: '`In``[``6``]:``# Getting the dimensions,``# i.e., the used range of the sheet``sheet``.``max_row``,``sheet``.``max_column`'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``6``]:``# 获取工作表的维度，即工作表的使用范围``sheet``.``max_row``,``sheet``.``max_column`'
- en: '`Out[6]: (8, 6)`'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[6]: (8, 6)`'
- en: '`In``[``7``]:``# Read the value of a single cell``# using "A1" notation and
    using cell indices (1-based)``sheet``[``"B6"``]``.``value``sheet``.``cell``(``row``=``6``,``column``=``2``)``.``value`'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``7``]:``# 读取单个单元格的值``# 使用 "A1" 表示法和单元格索引（基于1的索引）``sheet``[``"B6"``]``.``value``sheet``.``cell``(``row``=``6``,``column``=``2``)``.``value`'
- en: '`Out[7]: ''Boston''`'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[7]: ''Boston''`'
- en: '`In``[``8``]:``# Read in a range of cell values by using our excel module``data``=``excel``.``read``(``book``[``"2019"``],``(``2``,``2``),``(``8``,``6``))``data``[:``2``]``#
    Print the first two rows`'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``8``]:``# 使用我们的 excel 模块读取单元格值的范围``data``=``excel``.``read``(``book``[``"2019"``],``(``2``,``2``),``(``8``,``6``))``data``[:``2``]``#
    打印前两行的数据`'
- en: '`Out[8]: [[''Store'', ''Employees'', ''Manager'', ''Since'', ''Flagship''],
             [''New York'', 10, ''Sarah'', datetime.datetime(2018, 7, 20, 0, 0), False]]`'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[8]: [[''Store'', ''Employees'', ''Manager'', ''Since'', ''Flagship''],
             [''New York'', 10, ''Sarah'', datetime.datetime(2018, 7, 20, 0, 0), False]]`'
- en: Writing with OpenPyXL
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenPyXL 进行写入
- en: 'OpenPyXL builds the Excel file in memory and writes out the file once you call
    the `save` method. The following code produces the file as shown in [Figure 8-1](#filepos1032954):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: OpenPyXL 在内存中构建 Excel 文件，并在调用 `save` 方法时写出文件。以下代码生成了 [图 8-1](#filepos1032954)
    中显示的文件：
- en: '`In``[``9``]:``import``openpyxl``from``openpyxl.drawing.image``import``Image``from``openpyxl.chart``import``BarChart``,``Reference``from``openpyxl.styles``import``Font``,``colors``from``openpyxl.styles.borders``import``Border``,``Side``from``openpyxl.styles.alignment``import``Alignment``from``openpyxl.styles.fills``import``PatternFill``import``excel`'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``9``]:``import``openpyxl``from``openpyxl.drawing.image``import``Image``from``openpyxl.chart``import``BarChart``,``Reference``from``openpyxl.styles``import``Font``,``colors``from``openpyxl.styles.borders``import``Border``,``Side``from``openpyxl.styles.alignment``import``Alignment``from``openpyxl.styles.fills``import``PatternFill``import``excel`'
- en: '`In``[``10``]:``# Instantiate a workbook``book``=``openpyxl``.``Workbook``()``#
    Get the first sheet and give it a name``sheet``=``book``.``active``sheet``.``title``=``"Sheet1"``#
    Writing individual cells using A1 notation``# and cell indices (1-based)``sheet``[``"A1"``]``.``value``=``"Hello
    1"``sheet``.``cell``(``row``=``2``,``column``=``1``,``value``=``"Hello 2"``)``#
    Formatting: fill color, alignment, border and font``font_format``=``Font``(``color``=``"FF0000"``,``bold``=``True``)``thin``=``Side``(``border_style``=``"thin"``,``color``=``"FF0000"``)``sheet``[``"A3"``]``.``value``=``"Hello
    3"``sheet``[``"A3"``]``.``font``=``font_format``sheet``[``"A3"``]``.``border``=``Border``(``top``=``thin``,``left``=``thin``,``right``=``thin``,``bottom``=``thin``)``sheet``[``"A3"``]``.``alignment``=``Alignment``(``horizontal``=``"center"``)``sheet``[``"A3"``]``.``fill``=``PatternFill``(``fgColor``=``"FFFF00"``,``fill_type``=``"solid"``)``#
    Number formatting (using Excel''s formatting strings)``sheet``[``"A4"``]``.``value``=``3.3333``sheet``[``"A4"``]``.``number_format``=``"0.00"``#
    Date formatting (using Excel''s formatting strings)``sheet``[``"A5"``]``.``value``=``dt``.``date``(``2016``,``10``,``13``)``sheet``[``"A5"``]``.``number_format``=``"mm/dd/yy"``# Formula:
    you must use the English name of the formula``# with commas as delimiters``sheet``[``"A6"``]``.``value``=``"=SUM(A4,
    2)"``# Image``sheet``.``add_image``(``Image``(``"images/python.png"``),``"C1"``)``#
    Two-dimensional list (we''re using our excel module)``data``=``[[``None``,``"North"``,``"South"``],``[``"Last
    Year"``,``2``,``5``],``[``"This Year"``,``3``,``6``]]``excel``.``write``(``sheet``,``data``,``"A10"``)``#
    Chart``chart``=``BarChart``()``chart``.``type``=``"col"``chart``.``title``=``"Sales
    Per Region"``chart``.``x_axis``.``title``=``"Regions"``chart``.``y_axis``.``title``=``"Sales"``chart_data``=``Reference``(``sheet``,``min_row``=``11``,``min_col``=``1``,``max_row``=``12``,``max_col``=``3``)``chart_categories``=``Reference``(``sheet``,``min_row``=``10``,``min_col``=``2``,``max_row``=``10``,``max_col``=``3``)``#
    from_rows interprets the data in the same way``# as if you would add a chart manually
    in Excel``chart``.``add_data``(``chart_data``,``titles_from_data``=``True``,``from_rows``=``True``)``chart``.``set_categories``(``chart_categories``)``sheet``.``add_chart``(``chart``,``"A15"``)``#
    Saving the workbook creates the file on disk``book``.``save``(``"openpyxl.xlsx"``)`'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``10``]:``# 实例化一个工作簿``book``=``openpyxl``.``Workbook``()``# 获取第一个工作表并命名``sheet``=``book``.``active``sheet``.``title``=``"Sheet1"``#
    使用A1表示法和单元格索引（从1开始）写入单个单元格``sheet``[``"A1"``]``.``value``=``"Hello 1"``sheet``.``cell``(``row``=``2``,``column``=``1``,``value``=``"Hello
    2"``)``# 格式化：填充颜色，对齐，边框和字体``font_format``=``Font``(``color``=``"FF0000"``,``bold``=``True``)``thin``=``Side``(``border_style``=``"thin"``,``color``=``"FF0000"``)``sheet``[``"A3"``]``.``value``=``"Hello
    3"``sheet``[``"A3"``]``.``font``=``font_format``sheet``[``"A3"``]``.``border``=``Border``(``top``=``thin``,``left``=``thin``,``right``=``thin``,``bottom``=``thin``)``sheet``[``"A3"``]``.``alignment``=``Alignment``(``horizontal``=``"center"``)``sheet``[``"A3"``]``.``fill``=``PatternFill``(``fgColor``=``"FFFF00"``,``fill_type``=``"solid"``)``#
    数字格式化（使用Excel的格式字符串）``sheet``[``"A4"``]``.``value``=``3.3333``sheet``[``"A4"``]``.``number_format``=``"0.00"``#
    日期格式化（使用Excel的格式字符串）``sheet``[``"A5"``]``.``value``=``dt``.``date``(``2016``,``10``,``13``)``sheet``[``"A5"``]``.``number_format``=``"mm/dd/yy"``# 公式：必须使用公式的英文名称``#
    并使用逗号作为分隔符``sheet``[``"A6"``]``.``value``=``"=SUM(A4, 2)"``# 图像``sheet``.``add_image``(``Image``(``"images/python.png"``),``"C1"``)``#
    二维列表（我们正在使用我们的excel模块）``data``=``[[``None``,``"North"``,``"South"``],``[``"Last
    Year"``,``2``,``5``],``[``"This Year"``,``3``,``6``]]``excel``.``write``(``sheet``,``data``,``"A10"``)``#
    图表``chart``=``BarChart``()``chart``.``type``=``"col"``chart``.``title``=``"按地区销售"``chart``.``x_axis``.``title``=``"地区"``chart``.``y_axis``.``title``=``"销售额"``chart_data``=``Reference``(``sheet``,``min_row``=``11``,``min_col``=``1``,``max_row``=``12``,``max_col``=``3``)``chart_categories``=``Reference``(``sheet``,``min_row``=``10``,``min_col``=``2``,``max_row``=``10``,``max_col``=``3``)``#
    from_rows解释了数据，与在Excel中手动添加图表的方式相同``chart``.``add_data``(``chart_data``,``titles_from_data``=``True``,``from_rows``=``True``)``chart``.``set_categories``(``chart_categories``)``sheet``.``add_chart``(``chart``,``"A15"``)``#
    保存工作簿将文件保存到磁盘``book``.``save``(``"openpyxl.xlsx"``)'
- en: 'If you want to write an Excel template file, you’ll need to set the `template`
    attribute to `True` before saving it:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要编写一个Excel模板文件，在保存之前，你需要将`template`属性设置为`True`：
- en: '`In``[``11``]:``book``=``openpyxl``.``Workbook``()``sheet``=``book``.``active``sheet``[``"A1"``]``.``value``=``"This
    is a template"``book``.``template``=``True``book``.``save``(``"template.xltx"``)`'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``11``]:``book``=``openpyxl``.``Workbook``()``sheet``=``book``.``active``sheet``[``"A1"``]``.``value``=``"这是一个模板"``book``.``template``=``True``book``.``save``(``"template.xltx"``)`'
- en: As you can see in the code, OpenPyXL is setting colors by providing a string
    like `FF0000`. This value is made up of three hex values (`FF`, `00`, and `00`)
    that correspond to the red/green/blue values of the desired color. Hex stands
    for hexadecimal and represents numbers using a base of sixteen instead of a base
    of ten that is used by our standard decimal system.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在代码中所见，OpenPyXL通过提供类似`FF0000`的字符串来设置颜色。该值由三个十六进制值（`FF`、`00`和`00`）组成，分别对应所需颜色的红/绿/蓝值。十六进制表示十六进制数，使用十六进制基数而不是我们标准十进制系统使用的十进制基数。
- en: FINDING THE HEX VALUE OF A COLOR
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查找颜色的十六进制值
- en: To find the desired hex value of a color in Excel, click on the paint dropdown
    that you would use to change the fill color of a cell, then select More Colors.
    Now select your color and read off its hex value from the menu.
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要在Excel中找到所需颜色的十六进制值，请单击用于更改单元格填充颜色的油漆下拉菜单，然后选择更多颜色。现在选择您的颜色，并从菜单中读取其十六进制值。
- en: '![](images/00026.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00026.jpg)'
- en: Figure 8-1\. The file written by OpenPyXL (openpyxl.xlsx)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-1\. 由OpenPyXL编写的文件（openpyxl.xlsx）
- en: Editing with OpenPyXL
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenPyXL进行编辑
- en: 'There is no reader/writer package that can truly edit Excel files: in reality,
    OpenPyXL reads the file with everything it understands, then writes the file again
    from scratch—including any changes you make in between. This can be very powerful
    for simple Excel files that contain mainly formatted cells with data and formulas,
    but it’s limited when you have charts and other more advanced content in your
    spreadsheet as OpenPyXL will either change them or drop them altogether. For example,
    as of v3.0.5, OpenPyXL will rename charts and drop their title. Here is a simple
    editing example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 没有读取/写入包可以真正编辑Excel文件：实际上，OpenPyXL读取文件时理解其中的一切，然后再次从头开始编写文件——包括您在其中进行的任何更改。这对于主要包含格式化单元格及数据和公式的简单Excel文件非常有用，但对于包含图表和其他更高级内容的电子表格而言，其功能有限，因为OpenPyXL要么会更改它们，要么完全删除它们。例如，截至v3.0.5，OpenPyXL会重命名图表并删除它们的标题。这里是一个简单的编辑示例：
- en: '`In``[``12``]:``# Read the stores.xlsx file, change a cell``# and store it
    under a new location/name.``book``=``openpyxl``.``load_workbook``(``"xl/stores.xlsx"``)``book``[``"2019"``][``"A1"``]``.``value``=``"modified"``book``.``save``(``"stores_edited.xlsx"``)`'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``12``]:``# 读取stores.xlsx文件，更改单元格# 并将其存储在新位置/名称下。``book``=``openpyxl``.``load_workbook``(``"xl/stores.xlsx"``)``book``[``"2019"``][``"A1"``]``.``value``=``"modified"``book``.``save``(``"stores_edited.xlsx"``)`'
- en: 'If you want to write an xlsm file, OpenPyXL has to work off an existing file
    that you need to load with the `keep_vba` parameter set to `True`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要编写一个xlsm文件，OpenPyXL必须基于一个现有文件进行操作，您需要使用`keep_vba`参数设置为`True`加载该文件：
- en: '`In``[``13``]:``book``=``openpyxl``.``load_workbook``(``"xl/macro.xlsm"``,``keep_vba``=``True``)``book``[``"Sheet1"``][``"A1"``]``.``value``=``"Click
    the button!"``book``.``save``(``"macro_openpyxl.xlsm"``)`'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``13``]:``book``=``openpyxl``.``load_workbook``(``"xl/macro.xlsm"``,``keep_vba``=``True``)``book``[``"Sheet1"``][``"A1"``]``.``value``=``"Click
    the button!"``book``.``save``(``"macro_openpyxl.xlsm"``)`'
- en: The button in the example file is calling a macro that shows a message box.
    OpenPyXL covers a lot more functionality than I am able to cover in this section;
    it is therefore a good idea to have a look at the [official docs](https://oreil.ly/7qfYL).
    We will also see more functionality at the end of this chapter when we pick up
    the case study from the previous chapter again.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 示例文件中的按钮调用了一个显示消息框的宏。 OpenPyXL涵盖的功能远比我在本节中能够覆盖的要多；因此，建议查看[官方文档](https://oreil.ly/7qfYL)。在本章末尾，当我们再次接手上一章的案例研究时，我们还将看到更多功能。
- en: XlsxWriter
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: XlsxWriter
- en: 'As the name suggests, XlsxWriter can only write Excel files. The following
    code produces the same workbook as we previously produced with OpenPyXL, which
    is shown in [Figure 8-1](#filepos1032954). Note that XlsxWriter uses zero-based
    cell indices, while OpenPyXL uses one-based cell indices—make sure to take this
    into account if you switch between packages:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，XlsxWriter只能编写Excel文件。以下代码生成了与我们先前用OpenPyXL生成的相同工作簿，如[图8-1](#filepos1032954)所示。请注意，XlsxWriter使用从零开始的单元格索引，而OpenPyXL使用从一开始的单元格索引——如果您在这两种包之间切换，请务必注意这一点：
- en: '`In``[``14``]:``import``datetime``as``dt``import``xlsxwriter``import``excel`'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``14``]:``import``datetime``as``dt``import``xlsxwriter``import``excel`'
- en: '`In``[``15``]:``# Instantiate a workbook``book``=``xlsxwriter``.``Workbook``(``"xlxswriter.xlsx"``)``#
    Add a sheet and give it a name``sheet``=``book``.``add_worksheet``(``"Sheet1"``)``#
    Writing individual cells using A1 notation``# and cell indices (0-based)``sheet``.``write``(``"A1"``,``"Hello
    1"``)``sheet``.``write``(``1``,``0``,``"Hello 2"``)``# Formatting: fill color,
    alignment, border and font``formatting``=``book``.``add_format``({``"font_color"``:``"#FF0000"``,``"bg_color"``:``"#FFFF00"``,``"bold"``:``True``,``"align"``:``"center"``,``"border"``:``1``,``"border_color"``:``"#FF0000"``})``sheet``.``write``(``"A3"``,``"Hello
    3"``,``formatting``)``# Number formatting (using Excel''s formatting strings)``number_format``=``book``.``add_format``({``"num_format"``:``"0.00"``})``sheet``.``write``(``"A4"``,``3.3333``,``number_format``)``#
    Date formatting (using Excel''s formatting strings)``date_format``=``book``.``add_format``({``"num_format"``:``"mm/dd/yy"``})``sheet``.``write``(``"A5"``,``dt``.``date``(``2016``,``10``,``13``),``date_format``)``# Formula:
    you must use the English name of the formula``# with commas as delimiters``sheet``.``write``(``"A6"``,``"=SUM(A4,
    2)"``)``# Image``sheet``.``insert_image``(``0``,``2``,``"images/python.png"``)``#
    Two-dimensional list (we''re using our excel module)``data``=``[[``None``,``"North"``,``"South"``],``[``"Last
    Year"``,``2``,``5``],``[``"This Year"``,``3``,``6``]]``excel``.``write``(``sheet``,``data``,``"A10"``)``# Chart:
    see the file "sales_report_xlsxwriter.py" in the``# companion repo to see how
    you can work with indices``# instead of cell addresses``chart``=``book``.``add_chart``({``"type"``:``"column"``})``chart``.``set_title``({``"name"``:``"Sales
    per Region"``})``chart``.``add_series``({``"name"``:``"=Sheet1!A11"``,``"categories"``:``"=Sheet1!B10:C10"``,``"values"``:``"=Sheet1!B11:C11"``})``chart``.``add_series``({``"name"``:``"=Sheet1!A12"``,``"categories"``:``"=Sheet1!B10:C10"``,``"values"``:``"=Sheet1!B12:C12"``})``chart``.``set_x_axis``({``"name"``:``"Regions"``})``chart``.``set_y_axis``({``"name"``:``"Sales"``})``sheet``.``insert_chart``(``"A15"``,``chart``)``#
    Closing the workbook creates the file on disk``book``.``close``()`'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``15``]:``# 实例化一个工作簿``book``=``xlsxwriter``.``Workbook``(``"xlxswriter.xlsx"``)``#
    添加一个工作表并命名``sheet``=``book``.``add_worksheet``(``"Sheet1"``)``# 使用 A1 表示法和单元格索引（从
    0 开始）写入单个单元格``sheet``.``write``(``"A1"``,``"Hello 1"``)``sheet``.``write``(``1``,``0``,``"Hello
    2"``)``# 格式化：填充颜色、对齐、边框和字体``formatting``=``book``.``add_format``({``"font_color"``:``"#FF0000"``,``"bg_color"``:``"#FFFF00"``,``"bold"``:``True``,``"align"``:``"center"``,``"border"``:``1``,``"border_color"``:``"#FF0000"``})``sheet``.``write``(``"A3"``,``"Hello
    3"``,``formatting``)``# 数字格式化（使用 Excel 的格式化字符串）``number_format``=``book``.``add_format``({``"num_format"``:``"0.00"``})``sheet``.``write``(``"A4"``,``3.3333``,``number_format``)``#
    日期格式化（使用 Excel 的格式化字符串）``date_format``=``book``.``add_format``({``"num_format"``:``"mm/dd/yy"``})``sheet``.``write``(``"A5"``,``dt``.``date``(``2016``,``10``,``13``),``date_format``)``#
    公式：您必须使用公式的英文名称，并以逗号作为分隔符``sheet``.``write``(``"A6"``,``"=SUM(A4, 2)"``)``# 图像``sheet``.``insert_image``(``0``,``2``,``"images/python.png"``)``#
    二维列表（我们使用我们的 excel 模块）``data``=``[[``None``,``"North"``,``"South"``],``[``"Last
    Year"``,``2``,``5``],``[``"This Year"``,``3``,``6``]]``excel``.``write``(``sheet``,``data``,``"A10"``)``#
    图表：请参阅伴随存储库中的 "sales_report_xlsxwriter.py" 文件，了解如何使用索引而不是单元格地址``chart``=``book``.``add_chart``({``"type"``:``"column"``})``chart``.``set_title``({``"name"``:``"Sales
    per Region"``})``chart``.``add_series``({``"name"``:``"=Sheet1!A11"``,``"categories"``:``"=Sheet1!B10:C10"``,``"values"``:``"=Sheet1!B11:C11"``})``chart``.``add_series``({``"name"``:``"=Sheet1!A12"``,``"categories"``:``"=Sheet1!B10:C10"``,``"values"``:``"=Sheet1!B12:C12"``})``chart``.``set_x_axis``({``"name"``:``"Regions"``})``chart``.``set_y_axis``({``"name"``:``"Sales"``})``sheet``.``insert_chart``(``"A15"``,``chart``)``#
    关闭工作簿会在磁盘上创建文件``book``.``close``()`'
- en: 'In comparison to OpenPyXL, XlsxWriter has to take a more complicated approach
    to write xlsm files as it is a pure writer package. First, you need to extract
    the macro code from an existing Excel file on the Anaconda Prompt (the example
    uses the macro.xlsm file, which you’ll find in the xl folder of the companion
    repo):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与 OpenPyXL 相比，XlsxWriter 在编写 xlsm 文件时需要采取更复杂的方法，因为它是一个纯写入包。首先，您需要在 Anaconda
    Prompt 中从现有的 Excel 文件中提取宏代码（示例使用的是 macro.xlsm 文件，在伴随存储库的 xl 文件夹中）：
- en: Windows
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Windows
- en: 'Start by changing into the xl directory, then find the path to vba_extract.py,
    a script that comes with XlsxWriter:'
  id: totrans-92
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 首先进入 xl 目录，然后找到 vba_extract.py 的路径，这是一个附带 XlsxWriter 的脚本：
- en: '`(base)>` `cd C:\Users\``username``\python-for-excel\xl` `(base)>` `where vba_extract.py`
    `C:\Users\``username``\Anaconda3\Scripts\vba_extract.py`'
  id: totrans-93
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`(base)>` `cd C:\Users\``username``\python-for-excel\xl` `(base)>` `where vba_extract.py`
    `C:\Users\``username``\Anaconda3\Scripts\vba_extract.py`'
- en: 'Then use this path in the following command:'
  id: totrans-94
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后在以下命令中使用此路径：
- en: '`(base)>` `python C:\...\Anaconda3\Scripts\vba_extract.py macro.xlsm`'
  id: totrans-95
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`(base)>` `python C:\...\Anaconda3\Scripts\vba_extract.py macro.xlsm`'
- en: macOS
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: macOS
- en: 'On macOS, the command is available as executable script and can be run like
    this:'
  id: totrans-97
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在macOS上，该命令可作为可执行脚本使用，并可以像这样运行：
- en: '`(base)>` `cd /Users/``username``/python-for-excel/xl` `(base)>` `vba_extract.py
    macro.xlsm`'
  id: totrans-98
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`(base)>` `cd /Users/``username``/python-for-excel/xl` `(base)>` `vba_extract.py
    macro.xlsm`'
- en: 'This will save the file vbaProject.bin in the directory where you are running
    the command. I have also included the extracted file in the xl folder of the companion
    repo. We will use it in the following sample to write a workbook with a macro
    button:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在运行命令的目录中保存文件vbaProject.bin。我还在伴随的存储库的xl文件夹中包含了提取的文件。我们将在下面的示例中使用它来编写一个带有宏按钮的工作簿：
- en: '`In``[``16``]:``book``=``xlsxwriter``.``Workbook``(``"macro_xlxswriter.xlsm"``)``sheet``=``book``.``add_worksheet``(``"Sheet1"``)``sheet``.``write``(``"A1"``,``"Click
    the button!"``)``book``.``add_vba_project``(``"xl/vbaProject.bin"``)``sheet``.``insert_button``(``"A3"``,``{``"macro"``:``"Hello"``,``"caption"``:``"Button
    1"``,``"width"``:``130``,``"height"``:``35``})``book``.``close``()`'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``16``]:``book``=``xlsxwriter``.``Workbook``(``"macro_xlxswriter.xlsm"``)``sheet``=``book``.``add_worksheet``(``"Sheet1"``)``sheet``.``write``(``"A1"``,``"点击按钮！"``)``book``.``add_vba_project``(``"xl/vbaProject.bin"``)``sheet``.``insert_button``(``"A3"``,``{``"macro"``:``"Hello"``,``"caption"``:``"Button
    1"``,``"width"``:``130``,``"height"``:``35``})``book``.``close``()`  '
- en: pyxlsb
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: pyxlsb
- en: 'Compared to the other reader libraries, pyxlsb offers less functionality but
    it’s your only option when it comes to reading Excel files in the binary xlsb
    format. pyxlsb is not part of Anaconda, so you will need to install it if you
    haven’t already done this. It is currently not available via Conda either, so
    use pip to install it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他读取库相比，pyxlsb提供的功能较少，但它是读取二进制xlsb格式Excel文件的唯一选择。pyxlsb不是Anaconda的一部分，因此如果尚未安装，您需要安装它。目前，它也不支持通过Conda安装，因此请使用pip安装：
- en: '`(base)>` `pip install pyxlsb`'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`(base)>` `pip install pyxlsb`'
- en: 'You read sheets and cell values as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按以下方式读取工作表和单元格值：
- en: '`In``[``17``]:``import``pyxlsb``import``excel`'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``17``]:``import``pyxlsb``import``excel`'
- en: '`In``[``18``]:``# Loop through sheets. With pyxlsb, the workbook``# and sheet
    objects can be used as context managers.``# book.sheets returns a list of sheet
    names, not objects!``# To get a sheet object, use get_sheet() instead.``with``pyxlsb``.``open_workbook``(``"xl/stores.xlsb"``)``as``book``:``for``sheet_name``in``book``.``sheets``:``with``book``.``get_sheet``(``sheet_name``)``as``sheet``:``dim``=``sheet``.``dimension``print``(``f``"Sheet
    ''{sheet_name}'' has "``f``"{dim.h} rows and {dim.w} cols"``)`'
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``18``]:``# 循环遍历工作表。使用pyxlsb，工作簿和工作表对象可以用作上下文管理器。book.sheets返回的是工作表名称列表，而不是对象！要获取工作表对象，请使用get_sheet()。``with``pyxlsb``.``open_workbook``(``"xl/stores.xlsb"``)``as``book``:``for``sheet_name``in``book``.``sheets``:``with``book``.``get_sheet``(``sheet_name``)``as``sheet``:``dim``=``sheet``.``dimension````print``(``f``"工作表
    ''{sheet_name}'' 有 "``f``"{dim.h} 行 {dim.w} 列"``)`'
- en: '`Sheet ''2019'' has 7 rows and 5 cols Sheet ''2020'' has 7 rows and 5 cols
    Sheet ''2019-2020'' has 20 rows and 5 cols`'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`工作表 ''2019'' 有 7 行 5 列 工作表 ''2020'' 有 7 行 5 列 工作表 ''2019-2020'' 有 20 行 5 列`'
- en: '`In``[``19``]:``# Read in the values of a range of cells by using our excel
    module.``# Instead of "2019", you could also use its index (1-based).``with``pyxlsb``.``open_workbook``(``"xl/stores.xlsb"``)``as``book``:``with``book``.``get_sheet``(``"2019"``)``as``sheet``:``data``=``excel``.``read``(``sheet``,``"B2"``)``data``[:``2``]``#
    Print the first two rows`'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``19``]:``# 通过我们的excel模块读取一段单元格范围的值。与其使用"2019"，您也可以使用它的索引（从1开始）。``with``pyxlsb``.``open_workbook``(``"xl/stores.xlsb"``)``as``book``:``with``book``.``get_sheet``(``"2019"``)``as``sheet``:``data``=``excel``.``read``(``sheet``,``"B2"``)``data``[:``2``]``#
    打印前两行`'
- en: '`Out[19]: [[''Store'', ''Employees'', ''Manager'', ''Since'', ''Flagship''],
              [''New York'', 10.0, ''Sarah'', 43301.0, False]]`'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[19]: [[''Store'', ''Employees'', ''Manager'', ''Since'', ''Flagship''],
              [''纽约'', 10.0, ''莎拉'', 43301.0, False]]`'
- en: 'pyxlsb currently offers no way of recognizing cells with dates, so you will
    have to manually convert values from date-formatted cells into `datetime` objects
    like so:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: pyxlsb目前没有识别日期单元格的方法，因此您必须手动将日期格式的单元格值转换为`datetime`对象，如下所示：
- en: '`In``[``20``]:``from``pyxlsb``import``convert_date``convert_date``(``data``[``1``][``3``])`'
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``20``]:``from``pyxlsb``import``convert_date``convert_date``(``data``[``1``][``3``])`'
- en: '`Out[20]: datetime.datetime(2018, 7, 20, 0, 0)`'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[20]: datetime.datetime(2018, 7, 20, 0, 0)`'
- en: 'Remember, when you read the xlsb file format with a pandas version below 1.3,
    you need to specify the engine explicitly:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果您使用的是低于1.3版本的pandas，需要显式指定引擎来读取xlsb文件格式：
- en: '`In``[``21``]:``df``=``pd``.``read_excel``(``"xl/stores.xlsb"``,``engine``=``"pyxlsb"``)`'
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``21``]:``df``=``pd``.``read_excel``(``"xl/stores.xlsb"``,``engine``=``"pyxlsb"``)`'
- en: xlrd, xlwt, and xlutils
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: xlrd、xlwt和xlutils
- en: 'The combination of xlrd, xlwt, and xlutils offers roughly the same functionality
    for the legacy xls format that OpenPyXL offers for the xlsx format: xlrd reads,
    xlwt writes, and xlutils edits xls files. These packages aren’t actively developed
    anymore, but they are likely going to be relevant as long as there are still xls
    files around. xlutils is not part of Anaconda, so install it if you haven’t already:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: xlrd、xlwt 和 xlutils 的组合为旧版 xls 格式提供了与 OpenPyXL 对 xlsx 格式提供的大致相同的功能：xlrd 读取、xlwt
    写入、xlutils 编辑 xls 文件。这些包已经不再积极开发，但只要仍然有 xls 文件存在，它们可能还会有用。xlutils 不是 Anaconda
    的一部分，所以如果还没有安装它，请安装：
- en: '`(base)>` `conda install xlutils`'
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`(base)>` `conda install xlutils`'
- en: Let’s get started with the reading part!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始阅读部分！
- en: Reading with xlrd
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 xlrd 进行读取
- en: 'The following sample code shows you how to read the values from an Excel workbook
    with xlrd:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例代码向您展示如何使用 xlrd 从 Excel 工作簿中读取数值：
- en: '`In``[``22``]:``import``xlrd``import``xlwt``from``xlwt.Utils``import``cell_to_rowcol2``import``xlutils``import``excel`'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``22``]:``import``xlrd``import``xlwt``from``xlwt.Utils``import``cell_to_rowcol2``import``xlutils``import``excel`'
- en: '`In``[``23``]:``# Open the workbook to read cell values. The file is``# automatically
    closed again after loading the data.``book``=``xlrd``.``open_workbook``(``"xl/stores.xls"``)`'
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``23``]:``# 打开工作簿以读取单元格数值。在加载数据后文件会自动关闭。``book``=``xlrd``.``open_workbook``(``"xl/stores.xls"``)`'
- en: '`In``[``24``]:``# Get a list with all sheet names``book``.``sheet_names``()`'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``24``]:``# 获取所有工作表的名称列表``book``.``sheet_names``()`'
- en: '`Out[24]: [''2019'', ''2020'', ''2019-2020'']`'
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[24]: [''2019'', ''2020'', ''2019-2020'']`'
- en: '`In``[``25``]:``# Loop through the sheet objects``for``sheet``in``book``.``sheets``():``print``(``sheet``.``name``)`'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``25``]:``# 遍历工作表对象``for``sheet``in``book``.``sheets``():``print``(``sheet``.``name``)`'
- en: '`2019 2020 2019-2020`'
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`2019 2020 2019-2020`'
- en: '`In``[``26``]:``# Get a sheet object by name or index (0-based)``sheet``=``book``.``sheet_by_index``(``0``)``sheet``=``book``.``sheet_by_name``(``"2019"``)`'
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``26``]:``# 按名称或索引（从 0 开始）获取工作表对象``sheet``=``book``.``sheet_by_index``(``0``)``sheet``=``book``.``sheet_by_name``(``"2019"``)`'
- en: '`In``[``27``]:``# Dimensions``sheet``.``nrows``,``sheet``.``ncols`'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``27``]:``# 维度``sheet``.``nrows``,``sheet``.``ncols`'
- en: '`Out[27]: (8, 6)`'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[27]: (8, 6)`'
- en: '`In``[``28``]:``# Read the value of a single cell``# using "A1" notation and
    using cell indices (0-based).``# The "*" unpacks the tuple that cell_to_rowcol2
    returns``# into individual arguments.``sheet``.``cell``(``*``cell_to_rowcol2``(``"B3"``))``.``value``sheet``.``cell``(``2``,``1``)``.``value`'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``28``]:``# 使用 "A1" 表示法或使用单元格索引（从 0 开始）读取单元格的值。``# "*" 将 cell_to_rowcol2
    返回的元组展开为单独的参数。``sheet``.``cell``(``*``cell_to_rowcol2``(``"B3"``))``.``value``sheet``.``cell``(``2``,``1``)``.``value`'
- en: '`Out[28]: ''New York''`'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[28]: ''New York''`'
- en: '`In``[``29``]:``# Read in a range of cell values by using our excel module``data``=``excel``.``read``(``sheet``,``"B2"``)``data``[:``2``]``#
    Print the first two rows`'
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``29``]:``# 使用我们的 excel 模块读取单元格数值的范围``data``=``excel``.``read``(``sheet``,``"B2"``)``data``[:``2``]``#
    打印前两行`'
- en: '`Out[29]: [[''Store'', ''Employees'', ''Manager'', ''Since'', ''Flagship''],
             [''New York'', 10.0, ''Sarah'', datetime.datetime(2018, 7, 20, 0, 0),
              False]]`'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[29]: [[''Store'', ''Employees'', ''Manager'', ''Since'', ''Flagship''],
             [''New York'', 10.0, ''Sarah'', datetime.datetime(2018, 7, 20, 0, 0),
              False]]`'
- en: USED RANGE
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用范围
- en: Unlike OpenPyXL and pyxlsb, xlrd returns the dimensions of cells with a value,
    instead of the used range of a sheet when using `sheet.nrows` and `sheet.ncols`.
    What Excel returns as used range often contains empty rows and columns at the
    bottom and at the right border of the range. This can, for example, happen when
    you delete the content of rows (by hitting the Delete key), rather than deleting
    the rows themselves (by right-clicking and selecting Delete).
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与 OpenPyXL 和 pyxlsb 不同，xlrd 在使用 `sheet.nrows` 和 `sheet.ncols` 时返回带有值的单元格的维度，而不是工作表的使用范围。Excel
    返回的使用范围通常包含底部和右侧的空白行和列。例如，当您删除行内容（通过按删除键）而不是删除行本身（通过右键单击并选择删除）时，就会发生这种情况。
- en: Writing with xlwt
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 xlwt 进行写入
- en: 'The following code reproduces what we have done previously with OpenPyXL and
    XlsxWriter as shown in [Figure 8-1](index_split_021.html#filepos1032954). xlwt,
    however, cannot produce charts and only supports the `bmp` format for pictures:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码复现了我们之前用 OpenPyXL 和 XlsxWriter 完成的工作，如 [图 8-1](index_split_021.html#filepos1032954)
    所示。但是，xlwt 无法生成图表，只支持 `bmp` 格式的图片：
- en: '`In``[``30``]:``import``xlwt``from``xlwt.Utils``import``cell_to_rowcol2``import``datetime``as``dt``import``excel`'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``30``]:``import``xlwt``from``xlwt.Utils``import``cell_to_rowcol2``import``datetime``as``dt``import``excel`'
- en: '`In``[``31``]:``# Instantiate a workbook``book``=``xlwt``.``Workbook``()``#
    Add a sheet and give it a name``sheet``=``book``.``add_sheet``(``"Sheet1"``)``#
    Writing individual cells using A1 notation``# and cell indices (0-based)``sheet``.``write``(``*``cell_to_rowcol2``(``"A1"``),``"Hello
    1"``)``sheet``.``write``(``r``=``1``,``c``=``0``,``label``=``"Hello 2"``)``# Formatting:
    fill color, alignment, border and font``formatting``=``xlwt``.``easyxf``(``"font:
    bold on, color red;"``"align: horiz center;"``"borders: top_color red, bottom_color
    red,"``"right_color red, left_color red,"``"left thin, right thin,"``"top thin,
    bottom thin;"``"pattern: pattern solid, fore_color yellow;"``)``sheet``.``write``(``r``=``2``,``c``=``0``,``label``=``"Hello
    3"``,``style``=``formatting``)``# Number formatting (using Excel''s formatting
    strings)``number_format``=``xlwt``.``easyxf``(``num_format_str``=``"0.00"``)``sheet``.``write``(``3``,``0``,``3.3333``,``number_format``)``#
    Date formatting (using Excel''s formatting strings)``date_format``=``xlwt``.``easyxf``(``num_format_str``=``"mm/dd/yyyy"``)``sheet``.``write``(``4``,``0``,``dt``.``datetime``(``2012``,``2``,``3``),``date_format``)``# Formula:
    you must use the English name of the formula``# with commas as delimiters``sheet``.``write``(``5``,``0``,``xlwt``.``Formula``(``"SUM(A4,
    2)"``))``# Two-dimensional list (we''re using our excel module)``data``=``[[``None``,``"North"``,``"South"``],``[``"Last
    Year"``,``2``,``5``],``[``"This Year"``,``3``,``6``]]``excel``.``write``(``sheet``,``data``,``"A10"``)``#
    Picture (only allows to add bmp format)``sheet``.``insert_bitmap``(``"images/python.bmp"``,``0``,``2``)``#
    This writes the file to disk``book``.``save``(``"xlwt.xls"``)`'
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``31``]:``# 实例化工作簿``book``=``xlwt``.``Workbook``()``# 添加一个工作表并给它命名``sheet``=``book``.``add_sheet``(``"Sheet1"``)``#
    使用 A1 表示法和单元格索引（从 0 开始）写入单个单元格``sheet``.``write``(``*``cell_to_rowcol2``(``"A1"``),``"Hello
    1"``)``sheet``.``write``(``r``=``1``,``c``=``0``,``label``=``"Hello 2"``)``# 格式化：填充颜色、对齐、边框和字体``formatting``=``xlwt``.``easyxf``(``"font:
    bold on, color red;"``"align: horiz center;"``"borders: top_color red, bottom_color
    red,"``"right_color red, left_color red,"``"left thin, right thin,"``"top thin,
    bottom thin;"``"pattern: pattern solid, fore_color yellow;"``)``sheet``.``write``(``r``=``2``,``c``=``0``,``label``=``"Hello
    3"``,``style``=``formatting``)``# 数字格式化（使用 Excel 的格式字符串）``number_format``=``xlwt``.``easyxf``(``num_format_str``=``"0.00"``)``sheet``.``write``(``3``,``0``,``3.3333``,``number_format``)``#
    日期格式化（使用 Excel 的格式字符串）``date_format``=``xlwt``.``easyxf``(``num_format_str``=``"mm/dd/yyyy"``)``sheet``.``write``(``4``,``0``,``dt``.``datetime``(``2012``,``2``,``3``),``date_format``)``# 公式：您必须使用逗号作为分隔符的公式的英文名称``sheet``.``write``(``5``,``0``,``xlwt``.``Formula``(``"SUM(A4,
    2)"``))``# 二维列表（我们使用我们的 excel 模块）``data``=``[[``None``,``"North"``,``"South"``],``[``"Last
    Year"``,``2``,``5``],``[``"This Year"``,``3``,``6``]]``excel``.``write``(``sheet``,``data``,``"A10"``)``#
    图片（仅允许添加 bmp 格式）``sheet``.``insert_bitmap``(``"images/python.bmp"``,``0``,``2"``)``#
    将文件写入磁盘``book``.``save``(``"xlwt.xls"``)`'
- en: Editing with xlutils
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 xlutils 进行编辑
- en: 'xlutils acts as a bridge between xlrd and xlwt. This makes it explicit that
    this is not a true editing operation: the spreadsheet is read including the formatting
    via xlrd (by setting `formatting_info=True`) and then written out again by xlwt,
    including the changes that were made in between:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: xlutils 充当了 xlrd 和 xlwt 之间的桥梁。这明确说明这不是一个真正的编辑操作：通过 xlrd（通过设置 `formatting_info=True`）读取包括格式的电子表格，然后由
    xlwt 再次写出，包括在其中进行的更改：
- en: '`In``[``32``]:``import``xlutils.copy`'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``32``]:``import``xlutils.copy`'
- en: '`In``[``33``]:``book``=``xlrd``.``open_workbook``(``"xl/stores.xls"``,``formatting_info``=``True``)``book``=``xlutils``.``copy``.``copy``(``book``)``book``.``get_sheet``(``0``)``.``write``(``0``,``0``,``"changed!"``)``book``.``save``(``"stores_edited.xls"``)`'
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``33``]:``book``=``xlrd``.``open_workbook``(``"xl/stores.xls"``,``formatting_info``=``True``)``book``=``xlutils``.``copy``.``copy``(``book``)``book``.``get_sheet``(``0``)``.``write``(``0``,``0``,``"changed!"``)``book``.``save``(``"stores_edited.xls"``)`'
- en: At this point, you know how to read and write an Excel workbook in a specific
    format. The next section moves on with a few advanced topics that include working
    with big Excel files and using pandas and the reader and writer packages together.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您知道如何以特定格式读取和编写 Excel 工作簿了。下一节将介绍一些高级主题，包括处理大型 Excel 文件以及将 pandas 和读取器和写入器包一起使用。
- en: Advanced Reader and Writer Topics
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 高级读取器和写入器主题
- en: 'If your files are bigger and more complex than the simple Excel files we used
    in the examples so far, relying on the default options may not be good enough
    anymore. Therefore, we start this section by looking at how to work with bigger
    files. Then, we’ll learn how to use pandas together with the reader and writer
    packages: this will open up the ability to style your pandas DataFrames the way
    you want. To conclude this section, we will use everything we learned in this
    chapter to make the Excel report from last chapter’s case study look much more
    professional.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的文件比我们迄今为止在示例中使用的简单 Excel 文件更大更复杂，仅依赖默认选项可能不再足够。因此，我们从讨论如何处理更大的文件开始这一部分。然后，我们将学习如何将
    pandas 与 reader 和 writer 包一起使用：这将使你能够以想要的方式设计 pandas 数据帧的样式。最后，我们将运用本章学到的所有知识，使上一章案例研究中的
    Excel 报告看起来更加专业。
- en: Working with Big Excel Files
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 处理大型 Excel 文件
- en: 'Working with big files can cause two issues: the reading and writing process
    may be slow or your computer may run out of memory. Usually, the memory issue
    is of bigger concern as it will cause your program to crash. When exactly a file
    is considered big always depends on the available resources on your system and
    your definition of slow. This section shows optimization techniques offered by
    the individual packages, allowing you to work with Excel files that push the limits.
    I’ll start by looking at the options for the writer libraries, followed by the
    options for the reader libraries. At the end of this section, I’ll show you how
    to read the sheets of a workbook in parallel to reduce processing time.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 处理大文件可能会导致两个问题：读写过程可能会很慢，或者您的计算机可能会因内存不足而崩溃。通常，内存问题更加令人担忧，因为它会导致程序崩溃。文件何时被认为是大文件始终取决于系统上的可用资源以及您对慢的定义。本节展示了各个包提供的优化技术，使你能够处理极限的
    Excel 文件。我将首先讨论写入库的选项，然后是读取库的选项。在本节末尾，我将向你展示如何并行读取工作簿的工作表以减少处理时间。
- en: Writing with OpenPyXL
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenPyXL 进行写入
- en: 'When writing large files with OpenPyXL, make sure to have the lxml package
    installed, as this makes the writing process faster. It is included in Anaconda,
    so there’s nothing you need to do about that. The critical option, though, is
    the `write_only=True` flag, which makes sure that the memory consumption remains
    low. It, however, forces you to write row by row by using the `append` method
    and won’t allow you to write single cells anymore:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 OpenPyXL 写入大文件时，请确保已安装 lxml 包，因为这会加快写入过程。它已包含在 Anaconda 中，因此你无需做任何操作。然而，关键的选项是`write_only=True`标志，它确保内存消耗保持较低水平。但是，它强制你通过使用`append`方法逐行写入，并且不再允许你单元格单独写入：
- en: '`In``[``34``]:``book``=``openpyxl``.``Workbook``(``write_only``=``True``)``#
    With write_only=True, book.active doesn''t work``sheet``=``book``.``create_sheet``()``#
    This will produce a sheet with 1000 x 200 cells``for``row``in``range``(``1000``):``sheet``.``append``(``list``(``range``(``200``)))``book``.``save``(``"openpyxl_optimized.xlsx"``)`'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``34``]:``book``=``openpyxl``.``Workbook``(``write_only``=``True``)``#
    使用 write_only=True，book.active 不起作用``sheet``=``book``.``create_sheet``()``# 这将生成一个包含
    1000 x 200 个单元格的工作表``for``row``in``range``(``1000``):``sheet``.``append``(``list``(``range``(``200``)))``book``.``save``(``"openpyxl_optimized.xlsx"``)`'
- en: Writing with XlsxWriter
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 XlsxWriter 写入
- en: 'XlsxWriter has a similar option like OpenPyXL called `constant_memory`. It
    forces you to write sequential rows, too. You enable the option by providing an
    `options` dictionary like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: XlsxWriter 有一个类似于 OpenPyXL 的选项叫做`constant_memory`。它也强制你按顺序写入行。你可以通过提供一个像这样的`options`字典来启用该选项：
- en: '`In``[``35``]:``book``=``xlsxwriter``.``Workbook``(``"xlsxwriter_optimized.xlsx"``,``options``=``{``"constant_memory"``:``True``})``sheet``=``book``.``add_worksheet``()``#
    This will produce a sheet with 1000 x 200 cells``for``row``in``range``(``1000``):``sheet``.``write_row``(``row``,``0``,``list``(``range``(``200``)))``book``.``close``()`'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``35``]:``book``=``xlsxwriter``.``Workbook``(``"xlsxwriter_optimized.xlsx"``,``options``=``{``"constant_memory"``:``True``})``sheet``=``book``.``add_worksheet``()``#
    这将生成一个包含 1000 x 200 个单元格的工作表``for``row``in``range``(``1000``):``sheet``.``write_row``(``row``,``0``,``list``(``range``(``200``)))``book``.``close``()`'
- en: Reading with xlrd
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 xlrd 读取
- en: 'When reading big files in the legacy xls format, xlrd allows you to load sheets
    on demand, like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取旧版 xls 格式的大文件时，xlrd 允许你按需加载工作表，就像这样：
- en: '`In``[``36``]:``with``xlrd``.``open_workbook``(``"xl/stores.xls"``,``on_demand``=``True``)``as``book``:``sheet``=``book``.``sheet_by_index``(``0``)``#
    Only loads the first sheet`'
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``36``]:``with``xlrd``.``open_workbook``(``"xl/stores.xls"``,``on_demand``=``True``)``as``book``:``sheet``=``book``.``sheet_by_index``(``0``)``#
    只加载第一个工作表`'
- en: 'If you wouldn’t use the workbook as a context manager as we do here, you would
    need to call `book.release_resources()` manually to properly close the workbook
    again. To use xlrd in this mode with pandas, use it like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不像我们这样使用工作簿作为上下文管理器，你将需要手动调用 `book.release_resources()` 来正确地再次关闭工作簿。要以这种模式使用
    xlrd 和 pandas，像这样使用：
- en: '`In``[``37``]:``with``xlrd``.``open_workbook``(``"xl/stores.xls"``,``on_demand``=``True``)``as``book``:``with``pd``.``ExcelFile``(``book``,``engine``=``"xlrd"``)``as``f``:``df``=``pd``.``read_excel``(``f``,``sheet_name``=``0``)`'
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``37``]:``with``xlrd``.``open_workbook``(``"xl/stores.xls"``,``on_demand``=``True``)``as``book``:``with``pd``.``ExcelFile``(``book``,``engine``=``"xlrd"``)``as``f``:``df``=``pd``.``read_excel``(``f``,``sheet_name``=``0``)`'
- en: Reading with OpenPyXL
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenPyXL 读取
- en: 'To keep memory under control when reading big Excel files with OpenPyXL, you
    should load the workbook with `read_only=True`. Since OpenPyXL doesn’t support
    the `with` statement, you will need to make sure to close the file again when
    you’re done. If your file contains links to external workbooks, you may additionally
    want to use `keep_links=False` to make it faster. `keep_links` makes sure that
    the references to external workbooks are kept, which may unnecessarily slow down
    the process if you are only interested in reading the values of a workbook:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenPyXL 读取大型 Excel 文件时，为了控制内存使用，你应该以 `read_only=True` 加载工作簿。由于 OpenPyXL
    不支持 `with` 语句，所以在完成后你需要确保关闭文件。如果你的文件包含对外部工作簿的链接，你可能还想使用 `keep_links=False` 来加快速度。`keep_links`
    确保保留对外部工作簿的引用，这可能会在你只想读取工作簿的值时不必要地减慢过程：
- en: '`In``[``38``]:``book``=``openpyxl``.``load_workbook``(``"xl/big.xlsx"``,``data_only``=``True``,``read_only``=``True``,``keep_links``=``False``)``#
    Perform the desired read operations here``book``.``close``()``# Required with
    read_only=True`'
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``38``]:``book``=``openpyxl``.``load_workbook``(``"xl/big.xlsx"``,``data_only``=``True``,``read_only``=``True``,``keep_links``=``False``)``#
    在此执行所需的读取操作``book``.``close``()``# 使用 read_only=True 时需要关闭`'
- en: Reading sheets in parallel
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 并行读取工作表
- en: When you use pandas’ `read_excel` function to read in multiple sheets of a big
    workbook, you will find that this takes a long time (we’ll get to a concrete example
    in a moment). The reason is that pandas reads sheets sequentially, i.e., one after
    another. To speed things up, you could read the sheets in parallel. While there
    is no easy way to parallelize the writing of workbooks due to how the files are
    structured internally, reading multiple sheets in parallel is simple enough. However,
    since parallelization is an advanced topic, I left it out of the Python introduction
    and won’t go into details here either.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 pandas 的 `read_excel` 函数读取大型工作簿的多个工作表时，你会发现这需要很长时间（我们稍后会举一个具体的例子）。原因在于
    pandas 会顺序地读取工作表，即一个接一个地。为了加快速度，你可以并行读取工作表。虽然由于文件内部结构的原因，写入工作簿的并行化没有简单的方法，但读取多个工作表并行却很简单。然而，由于并行化是一个高级话题，我没有在
    Python 介绍中涉及，并且在这里也不会详细讨论。
- en: 'In Python, if you want to take advantage of the multiple CPU cores that every
    modern computer has, you use the multiprocessing package that is part of the standard
    library. This will spawn multiple Python interpreters (usually one per CPU core),
    which work on a task in parallel. Instead of processing one sheet after another,
    you have one Python interpreter process the first sheet, while at the same time
    a second Python interpreter is processing the second sheet, etc. However, every
    additional Python interpreter takes some time to start up and uses additional
    memory, so if you have small files, they will most likely run slower when you
    parallelize the reading process instead of faster. In the case of a big file with
    multiple big sheets, multiprocessing can speed up the process substantially, though—always
    assuming that your system has the required memory to handle the workload. If you
    run the Jupyter notebook on Binder as shown in [Chapter 2](index_split_008.html#filepos96824),
    you won’t have enough memory and hence, the parallelized version will run slower.
    In the companion repo, you will find parallel_pandas.py, which is a simple implementation
    for reading the sheets in parallel, using OpenPyXL as the engine. It’s simple
    to use, so you won’t need to know anything about multiprocessing:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，如果你想利用每台现代计算机都具备的多个CPU核心，你可以使用标准库中的`multiprocessing`包。这将会生成多个Python解释器（通常每个CPU核心一个），并行处理任务。与逐个处理表格不同，你可以让一个Python解释器处理第一个表格，同时第二个Python解释器处理第二个表格，以此类推。然而，每个额外的Python解释器启动需要一些时间，并且使用额外的内存，所以如果你有小文件，当你并行化读取过程时，它们可能比串行化处理更慢。但对于包含多个大表格的大文件，`multiprocessing`可以显著加快处理速度——前提是你的系统具备足够的内存来处理工作负载。如果像[第2章](index_split_008.html#filepos96824)展示的那样在Binder上运行Jupyter笔记本，你可能没有足够的内存，因此并行化版本的运行速度会较慢。在伴随的存储库中，你会找到`parallel_pandas.py`，它是使用OpenPyXL作为引擎的简单实现，用于并行读取表格。使用起来非常简单，因此你不需要了解`multiprocessing`的任何内容。
- en: '`import``parallel_pandas``parallel_pandas``.``read_excel``(``filename``,``sheet_name``=``None``)`'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`import``parallel_pandas``parallel_pandas``.``read_excel``(``filename``,``sheet_name``=``None``)`'
- en: 'By default, it will read in all sheets but you can provide a list of sheet
    names that you want to process. Like pandas, the function returns a dictionary
    in the following form: `{"sheetname": df}`, i.e., keys are the sheet names and
    the values are the DataFrames.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，它会读取所有表格，但你可以提供一个要处理的表格名称列表。像pandas一样，该函数返回一个字典，形式如`{"表格名称": df}`，即键是表格名称，值是DataFrame。'
- en: THE %%TIME MAGIC COMMAND
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**%%TIME魔术命令**'
- en: 'In the following samples, I am going to make use of the `%%time` cell magic.
    I introduced magic commands in [Chapter 5](index_split_015.html#filepos482650)
    in connection with Matplotlib. `%%time` is a cell magic that can be very useful
    for simple performance tuning as it makes it easy to compare the execution time
    of two cells with different code snippets. Wall time is the elapsed time from
    the start to the end of the program, i.e., the cell. If you are on macOS or Linux,
    you will not just get the wall time but an additional line for CPU times along
    these lines:'
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我将使用`%%time`单元格魔术命令。我在[第5章](index_split_015.html#filepos482650)中与Matplotlib一起介绍了魔术命令。`%%time`是一个非常有用的单元格魔术命令，可以用于简单的性能调优，因为它可以轻松比较包含不同代码片段的两个单元格的执行时间。墙时间是从程序（即单元格）开始到结束的经过时间。如果你在macOS或Linux上，你不仅会得到墙时间，还会得到类似以下这样的CPU时间额外行：
- en: '`CPU times: user 49.4 s, sys: 108 ms, total: 49.5 s`'
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`CPU times: user 49.4 s, sys: 108 ms, total: 49.5 s`'
- en: CPU times measures the time spent on the CPU, which can be lower than the wall
    time (if the program has to wait for the CPU to become available) or higher (if
    the program is running on multiple CPU cores in parallel). To measure the time
    more accurately, use `%%timeit` instead of `%%time`, which runs the cell multiple
    times and takes the average of all runs. `%%time` and `%%timeit` are cell magics,
    i.e., they need to be on the first line of the cell and will measure the execution
    time of the whole cell. If, instead, you want to measure just a single line, start
    that line with `%time` or `%timeit`.
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: CPU时间测量CPU上花费的时间，这可能低于墙时间（如果程序必须等待CPU可用）或高于墙时间（如果程序在多个CPU核心上并行运行）。为了更准确地测量时间，请使用`%%timeit`代替`%%time`，它会多次运行单元格并取所有运行的平均值。`%%time`和`%%timeit`是单元格魔术命令，即它们需要在单元格的第一行，并测量整个单元格的执行时间。如果你想测量单独一行代码的时间，可以使用`%time`或`%timeit`。
- en: 'Let’s see how much faster the parallelized version reads the big.xlsx file
    that you will find in the companion repo’s xl folder:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看并行化版本在读取 companion repo 的 xl 文件夹中的 big.xlsx 文件时快多少：
- en: '`In``[``39``]:``%%``time``data``=``pd``.``read_excel``(``"xl/big.xlsx"``,``sheet_name``=``None``,``engine``=``"openpyxl"``)`'
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``39``]:``%%``time``data``=``pd``.``read_excel``(``"xl/big.xlsx"``,``sheet_name``=``None``,``engine``=``"openpyxl"``)`'
- en: '`Wall time: 49.5 s`'
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Wall time: 49.5 s`'
- en: '`In``[``40``]:``%%``time``import``parallel_pandas``data``=``parallel_pandas``.``read_excel``(``"xl/big.xlsx"``,``sheet_name``=``None``)`'
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``40``]:``%%``time``import``parallel_pandas``data``=``parallel_pandas``.``read_excel``(``"xl/big.xlsx"``,``sheet_name``=``None``)`'
- en: '`Wall time: 12.1 s`'
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Wall time: 12.1 s`'
- en: 'To get the DataFrame that represents Sheet1, you would write `data["Sheet1"]`
    in both cases. Looking at the wall time of both samples, you’ll see that the parallelized
    version was multiple times faster than `pd.read_excel` with this particular workbook
    and on my laptop with 6 CPU cores. If you want it even faster, parallelize OpenPyXL
    directly: you will also find an implementation for that in the companion repository
    (parallel_openpyxl.py), together with an implementation for xlrd to read the legacy
    xls format in parallel (parallel_xlrd.py). Going through the underlying packages
    instead of pandas will allow you to skip the transformation into a DataFrame or
    only apply the cleaning steps that you need, which will most likely help you make
    things faster—if that is your biggest concern.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取代表 Sheet1 的 DataFrame，你可以在两种情况下写 `data["Sheet1"]`。通过比较两个样本的墙上时间，你会发现，并行化版本在我的笔记本上，对于这个特定的工作簿和
    6 个 CPU 内核，比 `pd.read_excel` 快了数倍。如果你想要更快的速度，直接并行化 OpenPyXL：在 companion repository（parallel_openpyxl.py）中也有一个实现，还有一个用于以并行方式读取传统
    xls 格式的 xlrd 实现（parallel_xlrd.py）。通过直接使用底层包而不是 pandas，你可以跳过转换成 DataFrame 或者只应用你需要的清理步骤，这很可能会帮助你加快速度，如果这是你最关心的问题的话。
- en: READING A SHEET IN PARALLEL WITH MODIN
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 MODIN 并行读取表格
- en: 'If you are only reading in one huge sheet, it is worth looking at [Modin](https://oreil.ly/wQszH),
    a project that acts as a drop-in replacement for pandas. It parallelizes the reading
    process of a single sheet and provides impressive speed improvements. Since Modin
    requires a specific version of pandas, it could downgrade the version that comes
    with Anaconda when you install it. If you want to test it, I would recommend that
    you create a separate Conda environment for this to ensure you are not messing
    up your base environment. See [Appendix A](index_split_029.html#filepos1810552)
    for more detailed instructions on how to create a Conda environment:'
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你只读取一个巨大的表格，那么看看 [Modin](https://oreil.ly/wQszH) 值得一试，这是一个可以替代 pandas 的项目。它并行化了单表的读取过程，并提供了令人印象深刻的速度改进。由于
    Modin 需要特定版本的 pandas，在安装时可能会降级 Anaconda 自带的版本。如果你想测试它，我建议你为此创建一个单独的 Conda 环境，以确保不会影响到基础环境。有关如何创建
    Conda 环境的更详细说明，请参阅 [附录 A](index_split_029.html#filepos1810552)：
- en: '`(base)>` `conda create --name modin python=3.8 -y` `(base)>` `conda activate
    modin` `(modin)>` `conda install -c conda-forge modin -y`'
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`(base)>` `conda create --name modin python=3.8 -y` `(base)>` `conda activate
    modin` `(modin)>` `conda install -c conda-forge modin -y`'
- en: 'On my machine and using the big.xlsx file, running the following code took
    roughly five seconds while it took pandas about twelve seconds:'
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在我的机器上，使用 big.xlsx 文件运行以下代码大约需要五秒钟，而 pandas 则需要大约十二秒钟：
- en: '`import``modin.pandas``data``=``modin``.``pandas``.``read_excel``(``"xl/big.xlsx"``,``sheet_name``=``0``,``engine``=``"openpyxl"``)`'
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`import``modin.pandas``data``=``modin``.``pandas``.``read_excel``(``"xl/big.xlsx"``,``sheet_name``=``0``,``engine``=``"openpyxl"``)`'
- en: Now that you know how to deal with big files, let’s move on and see how we can
    use pandas and the low-level packages together to improve the default formatting
    when writing DataFrames to Excel files!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何处理大文件了，让我们继续看看如何将 pandas 和低级包一起使用，以改进写入 DataFrame 到 Excel 文件时的默认格式！
- en: Formatting DataFrames in Excel
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化 Excel 中的 DataFrame
- en: 'To format DataFrames in Excel the way we want, we can write code that uses
    pandas together with OpenPyXL or XlsxWriter. We’ll first use this combination
    to add a title to the exported DataFrame. We’ll then format a DataFrame’s header
    and index before wrapping this section up by formatting the data part of a DataFrame.
    Combining pandas with OpenPyXL for reading can also be occasionally useful, so
    let’s start with this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要按我们想要的方式格式化 Excel 中的 DataFrame，我们可以编写代码，使用 pandas 与 OpenPyXL 或 XlsxWriter 结合使用。我们首先使用这种组合为导出的
    DataFrame 添加一个标题。然后在包装这一部分之前，格式化 DataFrame 的标题和索引。将 pandas 与 OpenPyXL 结合用于读取有时也可能很有用，所以让我们从这里开始：
- en: '`In``[``41``]:``with``pd``.``ExcelFile``(``"xl/stores.xlsx"``,``engine``=``"openpyxl"``)``as``xlfile``:``#
    Read a DataFrame``df``=``pd``.``read_excel``(``xlfile``,``sheet_name``=``"2020"``)``#
    Get the OpenPyXL workbook object``book``=``xlfile``.``book``# From here on, it''s
    OpenPyXL code``sheet``=``book``[``"2019"``]``value``=``sheet``[``"B3"``]``.``value``#
    Read a single value`'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``41``]:``with``pd``.``ExcelFile``(``"xl/stores.xlsx"``,``engine``=``"openpyxl"``)``as``xlfile``:``#
    读取DataFrame``df``=``pd``.``read_excel``(``xlfile``,``sheet_name``=``"2020"``)``#
    获取OpenPyXL的工作簿对象``book``=``xlfile``.``book``# 从这里开始是OpenPyXL代码``sheet``=``book``[``"2019"``]``value``=``sheet``[``"B3"``]``.``value``#
    读取单个值`'
- en: 'When writing workbooks, it works analogously, allowing us to easily add a title
    to our DataFrame report:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在写入工作簿时，它的功能类似，允许我们轻松地向我们的DataFrame报告添加一个标题：
- en: '`In``[``42``]:``with``pd``.``ExcelWriter``(``"pandas_and_openpyxl.xlsx"``,``engine``=``"openpyxl"``)``as``writer``:``df``=``pd``.``DataFrame``({``"col1"``:``[``1``,``2``,``3``,``4``],``"col2"``:``[``5``,``6``,``7``,``8``]})``#
    Write a DataFrame``df``.``to_excel``(``writer``,``"Sheet1"``,``startrow``=``4``,``startcol``=``2``)``#
    Get the OpenPyXL workbook and sheet objects``book``=``writer``.``book``sheet``=``writer``.``sheets``[``"Sheet1"``]``#
    From here on, it''s OpenPyXL code``sheet``[``"A1"``]``.``value``=``"This is a
    Title"``# Write a single cell value`'
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``42``]:``with``pd``.``ExcelWriter``(``"pandas_and_openpyxl.xlsx"``,``engine``=``"openpyxl"``)``as``writer``:``df``=``pd``.``DataFrame``({``"col1"``:``[``1``,``2``,``3``,``4``],``"col2"``:``[``5``,``6``,``7``,``8``]})``#
    写入DataFrame``df``.``to_excel``(``writer``,``"Sheet1"``,``startrow``=``4``,``startcol``=``2``)``#
    获取OpenPyXL的工作簿和表对象``book``=``writer``.``book``sheet``=``writer``.``sheets``[``"Sheet1"``]``#
    从这里开始是OpenPyXL代码``sheet``[``"A1"``]``.``value``=``"这是一个标题"``# 写入单元格值`'
- en: These samples use OpenPyXL, but it works conceptually the same with the other
    packages. Let’s now continue with finding out how we can format the index and
    header of a DataFrame.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例使用了OpenPyXL，但概念上与其他包相同。接下来我们继续了解如何格式化DataFrame的索引和标头。
- en: Formatting a DataFrame’s index and headers
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化DataFrame的索引和标头
- en: 'The easiest way to get complete control over the formatting of the index and
    column headers is to simply write them yourself. The following sample shows you
    how to do this with OpenPyXL and XlsxWriter, respectively. You can see the output
    in [Figure 8-2](#filepos1205246). Let’s start by creating a DataFrame:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全控制索引和列标题的格式化，最简单的方法是直接编写它们。以下示例分别演示了如何使用OpenPyXL和XlsxWriter做到这一点。您可以在[图 8-2](#filepos1205246)中查看输出。让我们从创建一个DataFrame开始：
- en: '`In``[``43``]:``df``=``pd``.``DataFrame``({``"col1"``:``[``1``,``-``2``],``"col2"``:``[``-``3``,``4``]},``index``=``[``"row1"``,``"row2"``])``df``.``index``.``name``=``"ix"``df`'
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``43``]:``df``=``pd``.``DataFrame``({``"col1"``:``[``1``,``-``2``],``"col2"``:``[``-``3``,``4``]},``index``=``[``"row1"``,``"row2"``])``df``.``index``.``name``=``"ix"``df`'
- en: '`Out[43]:       col1  col2          ix          row1     1    -3          row2   
    -2     4`'
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Out[43]:       col1  col2          ix          row1     1    -3          row2   
    -2     4`'
- en: 'To format the index and headers with OpenPyXL, do as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用OpenPyXL格式化索引和标头，请按以下步骤操作：
- en: '`In``[``44``]:``from``openpyxl.styles``import``PatternFill`'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``44``]:``from``openpyxl.styles``import``PatternFill`'
- en: '`In``[``45``]:``with``pd``.``ExcelWriter``(``"formatting_openpyxl.xlsx"``,``engine``=``"openpyxl"``)``as``writer``:``#
    Write out the df with the default formatting to A1``df``.``to_excel``(``writer``,``startrow``=``0``,``startcol``=``0``)``#
    Write out the df with custom index/header formatting to A6``startrow``,``startcol``=``0``,``5``#
    1\. Write out the data part of the DataFrame``df``.``to_excel``(``writer``,``header``=``False``,``index``=``False``,``startrow``=``startrow``+``1``,``startcol``=``startcol``+``1``)``#
    Get the sheet object and create a style object``sheet``=``writer``.``sheets``[``"Sheet1"``]``style``=``PatternFill``(``fgColor``=``"D9D9D9"``,``fill_type``=``"solid"``)``#
    2\. Write out the styled column headers``for``i``,``col``in``enumerate``(``df``.``columns``):``sheet``.``cell``(``row``=``startrow``+``1``,``column``=``i``+``startcol``+``2``,``value``=``col``)``.``fill``=``style``#
    3\. Write out the styled index``index``=``[``df``.``index``.``name``if``df``.``index``.``name``else``None``]``+``list``(``df``.``index``)``for``i``,``row``in``enumerate``(``index``):``sheet``.``cell``(``row``=``i``+``startrow``+``1``,``column``=``startcol``+``1``,``value``=``row``)``.``fill``=``style`'
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 Openpyxl 格式化索引/标题的示例 `In[45]`：
- en: 'To format the index and headers with XlsxWriter instead, you’ll need to adjust
    the code slightly:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用 XlsxWriter 格式化索引和标题，请稍微调整代码：
- en: '`In``[``46``]:``# Formatting index/headers with XlsxWriter``with``pd``.``ExcelWriter``(``"formatting_xlsxwriter.xlsx"``,``engine``=``"xlsxwriter"``)``as``writer``:``#
    Write out the df with the default formatting to A1``df``.``to_excel``(``writer``,``startrow``=``0``,``startcol``=``0``)``#
    Write out the df with custom index/header formatting to A6``startrow``,``startcol``=``0``,``5``#
    1\. Write out the data part of the DataFrame``df``.``to_excel``(``writer``,``header``=``False``,``index``=``False``,``startrow``=``startrow``+``1``,``startcol``=``startcol``+``1``)``#
    Get the book and sheet object and create a style object``book``=``writer``.``book``sheet``=``writer``.``sheets``[``"Sheet1"``]``style``=``book``.``add_format``({``"bg_color"``:``"#D9D9D9"``})``#
    2\. Write out the styled column headers``for``i``,``col``in``enumerate``(``df``.``columns``):``sheet``.``write``(``startrow``,``startcol``+``i``+``1``,``col``,``style``)``#
    3\. Write out the styled index``index``=``[``df``.``index``.``name``if``df``.``index``.``name``else``None``]``+``list``(``df``.``index``)``for``i``,``row``in``enumerate``(``index``):``sheet``.``write``(``startrow``+``i``,``startcol``,``row``,``style``)`'
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 XlsxWriter 格式化索引/标题的示例 `In[46]`：
- en: With the index and header formatted, let’s see how we can style the data part!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在索引和标题都已格式化好了，让我们看看如何对数据部分进行样式设置！
- en: '![](images/00054.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00054.jpg)'
- en: Figure 8-2\. A DataFrame with the default format (left) and with a custom format
    (right)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-2\. 默认格式的 DataFrame（左）和自定义格式（右）
- en: Formatting a DataFrame’s data part
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化 DataFrame 数据部分
- en: 'The possibilities you have to format the data part of a DataFrame depend on
    the package you’re using: if you use pandas’ `to_excel` method, OpenPyXL can apply
    a format to each cell, while XlsxWriter can only apply formats on a row or column
    basis. For example, to set the number format of the cells to three decimals and
    center-align the content as shown in [Figure 8-3](#filepos1221576), do the following
    with OpenPyXL:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化DataFrame数据部分的可能性取决于您使用的包：如果使用pandas的`to_excel`方法，OpenPyXL可以对每个单元格应用格式，而XlsxWriter只能按行或列的方式应用格式。例如，要设置单元格的数字格式为三位小数并居中显示内容，如[图 8-3](#filepos1221576)中所示，使用OpenPyXL可以按以下步骤进行：
- en: '`In``[``47``]:``from``openpyxl.styles``import``Alignment`'
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``47``]:``from``openpyxl.styles``import``Alignment`'
- en: '`In``[``48``]:``with``pd``.``ExcelWriter``(``"data_format_openpyxl.xlsx"``,``engine``=``"openpyxl"``)``as``writer``:``#
    Write out the DataFrame``df``.``to_excel``(``writer``)``# Get the book and sheet
    objects``book``=``writer``.``book``sheet``=``writer``.``sheets``[``"Sheet1"``]``#
    Formatting individual cells``nrows``,``ncols``=``df``.``shape``for``row``in``range``(``nrows``):``for``col``in``range``(``ncols``):``#
    +1 to account for the header/index``# +1 since OpenPyXL is 1-based``cell``=``sheet``.``cell``(``row``=``row``+``2``,``column``=``col``+``2``)``cell``.``number_format``=``"0.000"``cell``.``alignment``=``Alignment``(``horizontal``=``"center"``)`'
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``48``]:``with``pd``.``ExcelWriter``(``"data_format_openpyxl.xlsx"``,``engine``=``"openpyxl"``)``as``writer``:``#
    写出DataFrame``df``.``to_excel``(``writer``)``# 获取工作簿和工作表对象``book``=``writer``.``book``sheet``=``writer``.``sheets``[``"Sheet1"``]``#
    格式化单个单元格``nrows``,``ncols``=``df``.``shape``for``row``in``range``(``nrows``):``for``col``in``range``(``ncols``):``#
    +1 考虑到标题/索引``# +1 因为OpenPyXL基于1``base````cell``=``sheet``.``cell``(``row``=``row``+``2``,``column``=``col``+``2``)``cell``.``number_format``=``"0.000"``cell``.``alignment``=``Alignment``(``horizontal``=``"center"``)`'
- en: 'For XlsxWriter, adjust the code as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于XlsxWriter，调整代码如下：
- en: '`In``[``49``]:``with``pd``.``ExcelWriter``(``"data_format_xlsxwriter.xlsx"``,``engine``=``"xlsxwriter"``)``as``writer``:``#
    Write out the DataFrame``df``.``to_excel``(``writer``)``# Get the book and sheet
    objects``book``=``writer``.``book``sheet``=``writer``.``sheets``[``"Sheet1"``]``#
    Formatting the columns (individual cells can''t be formatted)``number_format``=``book``.``add_format``({``"num_format"``:``"0.000"``,``"align"``:``"center"``})``sheet``.``set_column``(``first_col``=``1``,``last_col``=``2``,``cell_format``=``number_format``)`'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``49``]:``with``pd``.``ExcelWriter``(``"data_format_xlsxwriter.xlsx"``,``engine``=``"xlsxwriter"``)``as``writer``:``#
    写出DataFrame``df``.``to_excel``(``writer``)``# 获取工作簿和工作表对象``book``=``writer``.``book``sheet``=``writer``.``sheets``[``"Sheet1"``]``#
    格式化列（无法格式化单个单元格）``number_format``=``book``.``add_format``({``"num_format"``:``"0.000"``,``"align"``:``"center"``})``sheet``.``set_column``(``first_col``=``1``,``last_col``=``2``,``cell_format``=``number_format``)`'
- en: '![](images/00046.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00046.jpg)'
- en: Figure 8-3\. A DataFrame with a formatted data part
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-3\. 数据部分格式化的DataFrame
- en: 'As an alternative, pandas offers experimental support for the `style` property
    of DataFrames. Experimental means that the syntax can change at any point in time.
    Since styles were introduced to format the DataFrames in HTML format, they use
    CSS syntax. CSS stands for cascading style sheets and is used to define the style
    of HTML elements. To apply the same format as in the previous example (three decimals
    and center align), you’ll need to apply a function to every element of a `Styler`
    object via `applymap`. You get a `Styler` object via the `df.style` attribute:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，pandas为DataFrame的`style`属性提供了实验性支持。实验性意味着语法随时可能更改。由于样式用于在HTML格式中格式化DataFrame，因此它们使用CSS语法。CSS代表层叠样式表，用于定义HTML元素的样式。要应用与前面示例相同的格式（三位小数和居中对齐），您需要通过`applymap`函数将函数应用于`Styler`对象的每个元素。您可以通过`df.style`属性获得`Styler`对象：
- en: '`In``[``50``]:``df``.``style``.``applymap``(``lambda``x``:``"number-format:
    0.000;"``"text-align: center"``)``\` `.``to_excel``(``"styled.xlsx"``)`'
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``50``]:``df``.``style``.``applymap``(``lambda``x``:``"number-format:
    0.000;"``"text-align: center"``)``\` `.``to_excel``(``"styled.xlsx"``)`'
- en: The outcome of this code is the same as shown in [Figure 8-3](#filepos1221576).
    For more details on the DataFrame style approach, please refer directly to the
    [styling docs](https://oreil.ly/_JzfP).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出结果与[图 8-3](#filepos1221576)中显示的一样。有关DataFrame样式方法的更多详细信息，请直接参阅[样式文档](https://oreil.ly/_JzfP)。
- en: 'Without having to rely on the style attribute, pandas offers support to format
    the date and datetime objects as shown in [Figure 8-4](#filepos1229706):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 无需依赖样式属性，pandas提供了对日期和日期时间对象进行格式化的支持，如[图 8-4](#filepos1229706)所示：
- en: '`In``[``51``]:``df``=``pd``.``DataFrame``({``"Date"``:``[``dt``.``date``(``2020``,``1``,``1``)],``"Datetime"``:``[``dt``.``datetime``(``2020``,``1``,``1``,``10``)]})``with``pd``.``ExcelWriter``(``"date.xlsx"``,``date_format``=``"yyyy-mm-dd"``,``datetime_format``=``"yyyy-mm-dd
    hh:mm:ss"``)``as``writer``:``df``.``to_excel``(``writer``)`'
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`In``[``51``]:``df``=``pd``.``DataFrame``({``"Date"``:``[``dt``.``date``(``2020``,``1``,``1``)],``"Datetime"``:``[``dt``.``datetime``(``2020``,``1``,``1``,``10``)]})``with``pd``.``ExcelWriter``(``"date.xlsx"``,``date_format``=``"yyyy-mm-dd"``,``datetime_format``=``"yyyy-mm-dd
    hh:mm:ss"``)``as``writer``:``df``.``to_excel``(``writer``)`'
- en: '![](images/00013.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00013.jpg)'
- en: Figure 8-4\. A DataFrame with formatted dates
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-4。带有格式化日期的数据框
- en: OTHER READER AND WRITER PACKAGES
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 其他读取器和写入器包
- en: 'Apart from the packages that we have looked at in this chapter, there are a
    few others that may be interesting for specific use cases:'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了本章中我们已经查看过的软件包之外，还有一些其他的软件包可能对特定的用例有所帮助：
- en: pyexcel
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: pyexcel
- en: '[pyexcel](http://pyexcel.org) offers a harmonized syntax across different Excel
    packages and other file formats including CSV files and OpenOffice files.'
  id: totrans-220
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[pyexcel](http://pyexcel.org)提供了一种在不同的Excel包和其他文件格式（包括CSV文件和OpenOffice文件）之间统一的语法。'
- en: PyExcelerate
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: PyExcelerate
- en: The goal of [PyExcelerate](https://oreil.ly/yJax7) is to write Excel files in
    the fastest possible way.
  id: totrans-222
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[PyExcelerate](https://oreil.ly/yJax7)的目标是以最快的速度编写Excel文件。'
- en: pylightxl
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: pylightxl
- en: '[pylightxl](https://oreil.ly/efjt4) can read xlsx and xlsm files and write
    xlsx files.'
  id: totrans-224
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[pylightxl](https://oreil.ly/efjt4)可以读取xlsx和xlsm文件，并写入xlsx文件。'
- en: styleframe
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: styleframe
- en: '[styleframe](https://oreil.ly/nQUg9) wraps pandas and OpenPyXL to produce Excel
    files with nicely formatted DataFrames.'
  id: totrans-226
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[styleframe](https://oreil.ly/nQUg9)封装了pandas和OpenPyXL，以产生带有精美格式的数据框的Excel文件。'
- en: oletools
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: oletools
- en: '[oletools](https://oreil.ly/SG-Jy) is not a classic reader or writer package
    but can be used to analyze Microsoft Office documents, e.g., for malware analysis.
    It offers a convenient way to extract VBA code from Excel workbooks.'
  id: totrans-228
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[oletools](https://oreil.ly/SG-Jy)并不是一个传统的读取器或写入器包，但可以用于分析Microsoft Office文档，例如，用于恶意软件分析。它提供了一种方便的方法来从Excel工作簿中提取VBA代码。'
- en: Now that you know how to format DataFrames in Excel, it’s time to take another
    stab at the case study from the previous chapter and see if we can improve the
    Excel report with the knowledge of this chapter!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何在Excel中格式化数据框了，是时候重新审视上一章的案例研究，看看我们是否能够运用本章的知识来改进Excel报告了！
- en: 'Case Study (Revisited): Excel Reporting'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 案例研究（再访）：Excel报告
- en: Having made it to the end of this chapter, you know enough to be able to go
    back to the Excel report from last chapter’s case study and make it visually more
    appealing. If you like, go back to sales_report_pandas.py in the companion repository
    and try to turn it into the report as shown in [Figure 8-5](#filepos1233720).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译到了本章的最后，您已经了解足够的知识，可以回到上一章的Excel报告，并使其在视觉上更具吸引力。如果您愿意，可以回到附带存储库中的sales_report_pandas.py，并尝试将其转换为[Figue
    8-5](#filepos1233720)中显示的报告。
- en: 'The red numbers are sales figures that are below 20,000\. I haven’t touched
    every aspect of formatting in this chapter (like how to apply conditional formatting),
    so you will have to use the documentation of the package you choose to work with.
    To compare your solution, I have included two versions of the script that produce
    this report in the companion repo. The first version is based on OpenPyXL (sales_report_openpyxl.py)
    and the other one is based on XlsxWriter (sales_report_xlsxwriter.py). Seeing
    the scripts side-by-side may also allow you to make a more educated decision about
    which package you want to pick for your next writer task. We will get back to
    this case study one more time in the next chapter: there, we’ll rely on an installation
    of Microsoft Excel to work with report templates.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 红色数字是低于20,000的销售数字。本章未涉及所有格式设置的每个方面（比如如何应用条件格式设置），因此您需要使用您选择的软件包的文档。为了比较您的解决方案，我在附带的存储库中包含了生成此报告的两个脚本版本。第一个版本基于OpenPyXL（sales_report_openpyxl.py），另一个版本基于XlsxWriter（sales_report_xlsxwriter.py）。并排查看脚本可能还能让您更明智地决定下一次要选择哪个软件包来完成您的写入任务。我们将在下一章再次回到这个案例研究：在那里，我们将依赖于Microsoft
    Excel的安装来处理报告模板。
- en: '![](images/00081.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00081.jpg)'
- en: Figure 8-5\. The revisited sales report as created by sales_report_openpyxl.py
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-5。由sales_report_openpyxl.py创建的重新审视的销售报告
- en: Conclusion
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, I introduced you to the reader and writer packages that pandas
    uses under the hood. Using them directly allows us to read and write Excel workbooks
    without needing to have pandas installed. However, using them in combination with
    pandas enables us to enhance the Excel DataFrame reports by adding titles, charts,
    and formatting. While the current reader and writer packages are incredibly powerful,
    I still hope that we’ll see a “NumPy moment” one day that unites the efforts of
    all the developers into a single project. It would be great to know which package
    to use without having to look at a table first and without having to use a different
    syntax for each type of Excel file. In that sense, it makes sense to start with
    pandas and only fall back to the reader and writer packages when you need additional
    functionality that pandas doesn’t cover.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我向您介绍了 pandas 在底层使用的读取器和写入器包。直接使用它们允许我们读取和写入 Excel 工作簿，而无需安装 pandas。然而，与
    pandas 结合使用使我们能够通过添加标题、图表和格式来增强 Excel DataFrame 报告。虽然当前的读取器和写入器包非常强大，但我仍然希望有一天能看到一个像
    "NumPy 时刻" 那样将所有开发者的努力统一到一个项目中。能够在不必首先查看表格的情况下知道使用哪个包，并且在不必为每种类型的 Excel 文件使用不同的语法的情况下使用它，这将是很棒的。从这个意义上说，从
    pandas 开始，只有在需要 pandas 未涵盖的附加功能时才退而使用读取器和写入器包，这是有道理的。
- en: 'Excel, however, is so much more than just a data file or a report: the Excel
    application is one of the most intuitive user interfaces where users can type
    in a few numbers and get it to display the information they are looking for. Automating
    the Excel application instead of reading and writing Excel files opens up a whole
    new range of functionality that we are going to explore in [Part IV](index_split_023.html#filepos1235617).
    The next chapter starts this journey by showing you how to control Excel from
    Python remotely.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Excel 不仅仅是一个数据文件或报告：Excel 应用程序是最直观的用户界面之一，用户可以输入几个数字，并让它显示他们正在寻找的信息。自动化 Excel
    应用程序而不是读写 Excel 文件，开启了我们将在[第四部分](index_split_023.html#filepos1235617)探索的全新功能范围。下一章将通过向您展示如何从
    Python 远程控制 Excel 来开始这段旅程。
- en: Part IV. Programming the Excel Application with xlwings
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 第四部分：使用 xlwings 编程 Excel 应用程序
