- en: Chapter 24\. Databases and SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory is man’s greatest friend and worst enemy.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Gilbert Parker
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The data you need will often live in *databases*, systems designed for efficiently
    storing and querying data. The bulk of these are *relational* databases, such
    as PostgreSQL, MySQL, and SQL Server, which store data in *tables* and are typically
    queried using Structured Query Language (SQL), a declarative language for manipulating
    data.
  prefs: []
  type: TYPE_NORMAL
- en: SQL is a pretty essential part of the data scientist’s toolkit. In this chapter,
    we’ll create NotQuiteABase, a Python implementation of something that’s not quite
    a database. We’ll also cover the basics of SQL while showing how they work in
    our not-quite database, which is the most “from scratch” way I could think of
    to help you understand what they’re doing. My hope is that solving problems in
    NotQuiteABase will give you a good sense of how you might solve the same problems
    using SQL.
  prefs: []
  type: TYPE_NORMAL
- en: CREATE TABLE and INSERT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A relational database is a collection of tables, and of relationships among
    them. A table is simply a collection of rows, not unlike some of the matrices
    we’ve been working with. However, a table also has associated with it a fixed
    *schema* consisting of column names and column types.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine a `users` dataset containing for each user her `user_id`,
    `name`, and `num_friends`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In SQL, we might create this table with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we specified that the `user_id` and `num_friends` must be integers
    (and that `user_id` isn’t allowed to be `NULL`, which indicates a missing value
    and is sort of like our `None`) and that the name should be a string of length
    200 or less. We’ll use Python types in a similar way.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: SQL is almost completely case and indentation insensitive. The capitalization
    and indentation style here is my preferred style. If you start learning SQL, you
    will surely encounter other examples styled differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can insert the rows with `INSERT` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice also that SQL statements need to end with semicolons, and that SQL requires
    single quotes for its strings.
  prefs: []
  type: TYPE_NORMAL
- en: In NotQuiteABase, you’ll create a `Table` by specifying a similar schema. Then
    to insert a row, you’ll use the table’s `insert` method, which takes a `list`
    of row values that need to be in the same order as the table’s column names.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, we’ll store each row as a `dict` from column names to values.
    A real database would never use such a space-wasting representation, but doing
    so will make NotQuiteABase much easier to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll implement the NotQuiteABase `Table` as a giant class, which we’ll implement
    one method at a time. Let’s start by getting out of the way some imports and type
    aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s start with the constructor. To create a NotQuiteABase table, we’ll need
    to pass in a list of column names, and a list of column types, just as you would
    if you were creating a table in a SQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll add a helper method to get the type of a column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And we’ll add an `insert` method that checks that the values you’re inserting
    are valid. In particular, you have to provide the correct number of values, and
    each has to be the correct type (or `None`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In an actual SQL database you’d explicitly specify whether any given column
    was allowed to contain null (`None`) values; to make our lives simpler we’ll just
    say that any column can.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll also introduce a few dunder methods that allow us to treat a table like
    a `List[Row]`, which we’ll mostly use for testing our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And we’ll add a method to pretty-print our table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create our `Users` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now `print(users)`, you’ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The list-like API makes it easy to write tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We’ve got a lot more functionality to add.
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you need to update the data that’s already in the database. For instance,
    if Dunn acquires another friend, you might need to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The key features are:'
  prefs: []
  type: TYPE_NORMAL
- en: What table to update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which rows to update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which fields to update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What their new values should be
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll add a similar `update` method to NotQuiteABase. Its first argument will
    be a `dict` whose keys are the columns to update and whose values are the new
    values for those fields. Its second (optional) argument should be a `predicate`
    that returns `True` for rows that should be updated, and `False` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'after which we can simply do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: DELETE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways to delete rows from a table in SQL. The dangerous way deletes
    every row from a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The less dangerous way adds a `WHERE` clause and deletes only rows that match
    a certain condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s easy to add this functionality to our `Table`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you supply a `predicate` function (i.e., a `WHERE` clause), this deletes
    only the rows that satisfy it. If you don’t supply one, the default `predicate`
    always returns `True`, and you will delete every row.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: SELECT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typically you don’t inspect SQL tables directly. Instead you query them with
    a `SELECT` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `SELECT` statements to calculate fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll give our `Table` class a `select` method that returns a new `Table`.
    The method accepts two optional arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`keep_columns` specifies the names of the columns you want to keep in the result.
    If you don’t supply it, the result contains all the columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`additional_columns` is a dictionary whose keys are new column names and whose
    values are functions specifying how to compute the values of the new columns.
    We’ll peek at the type annotations of those functions to figure out the types
    of the new columns, so the functions will need to have annotated return types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you were to supply neither of them, you’d simply get back a copy of the
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember way back in [Chapter 2](ch02.html#python) when we said that type annotations
    don’t actually do anything? Well, here’s the counterexample. But look at the convoluted
    procedure we have to go through to get at them.
  prefs: []
  type: TYPE_NORMAL
- en: Our `select` returns a new `Table`, while the typical SQL `SELECT` just produces
    some sort of transient result set (unless you explicitly insert the results into
    a table).
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll also need `where` and `limit` methods. Both are pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'after which we can easily construct NotQuiteABase equivalents to the preceding
    SQL statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice that for the multiline “fluent” queries we have to wrap the whole query
    in parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: GROUP BY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common SQL operation is `GROUP BY`, which groups together rows with
    identical values in specified columns and produces aggregate values like `MIN`
    and `MAX` and `COUNT` and `SUM`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you might want to find the number of users and the smallest `user_id`
    for each possible name length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Every field we `SELECT` needs to be either in the `GROUP BY` clause (which `name_length`
    is) or an aggregate computation (which `min_user_id` and `num_users` are).
  prefs: []
  type: TYPE_NORMAL
- en: SQL also supports a `HAVING` clause that behaves similarly to a `WHERE` clause,
    except that its filter is applied to the aggregates (whereas a `WHERE` would filter
    out rows before aggregation even took place).
  prefs: []
  type: TYPE_NORMAL
- en: You might want to know the average number of friends for users whose names start
    with specific letters but see only the results for letters whose corresponding
    average is greater than 1\. (Yes, some of these examples are contrived.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Functions for working with strings vary across SQL implementations; some databases
    might instead use `SUBSTRING` or something else.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also compute overall aggregates. In that case, you leave off the `GROUP
    BY`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To add this functionality to NotQuiteABase `Table`s, we’ll add a `group_by`
    method. It takes the names of the columns you want to group by, a dictionary of
    the aggregation functions you want to run over each group, and an optional predicate
    called `having` that operates on multiple rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then it does the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a `defaultdict` to map `tuple`s (of the group-by values) to rows (containing
    the group-by values). Recall that you can’t use lists as `dict` keys; you have
    to use tuples.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterates over the rows of the table, populating the `defaultdict`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates a new table with the correct output columns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterates over the `defaultdict` and populates the output table, applying the
    `having` filter, if any.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An actual database would almost certainly do this in a more efficient manner.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, let’s see how we would do the equivalent of the preceding SQL statements.
    The `name_length` metrics are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `first_letter` metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'and the `user_id_sum` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: ORDER BY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Frequently, you’ll want to sort your results. For example, you might want to
    know the (alphabetically) first two names of your users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is easy to implement by giving our `Table` an `order_by` method that takes
    an `order` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'which we can then use as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The SQL `ORDER BY` lets you specify `ASC` (ascending) or `DESC` (descending)
    for each sort field; here we’d have to bake that into our `order` function.
  prefs: []
  type: TYPE_NORMAL
- en: JOIN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Relational database tables are often *normalized*, which means that they’re
    organized to minimize redundancy. For example, when we work with our users’ interests
    in Python, we can just give each user a `list` containing his interests.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL tables can’t typically contain lists, so the typical solution is to create
    a second table called `user_interests` containing the one-to-many relationship
    between `user_id`s and `interest`s. In SQL you might do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'whereas in NotQuiteABase you’d create the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There’s still plenty of redundancy—the interest “SQL” is stored in two different
    places. In a real database you might store `user_id` and `interest_id` in the
    `user_interests` table and then create a third table, `interests`, mapping `interest_id`
    to `interest` so you could store the interest names only once each. Here that
    would just make our examples more complicated than they need to be.
  prefs: []
  type: TYPE_NORMAL
- en: When our data lives across different tables, how do we analyze it? By `JOIN`ing
    the tables together. A `JOIN` combines rows in the left table with corresponding
    rows in the right table, where the meaning of “corresponding” is based on how
    we specify the join.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to find the users interested in SQL you’d query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `JOIN` says that, for each row in `users`, we should look at the `user_id`
    and associate that row with every row in `user_interests` containing the same
    `user_id`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice we had to specify which tables to `JOIN` and also which columns to join
    `ON`. This is an `INNER JOIN`, which returns the combinations of rows (and only
    the combinations of rows) that match according to the specified join criteria.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a `LEFT JOIN`, which—in addition to the combinations of matching
    rows—returns a row for each left-table row with no matching rows (in which case,
    the fields that would have come from the right table are all `NULL`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a `LEFT JOIN`, it’s easy to count the number of interests each user has:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `LEFT JOIN` ensures that users with no interests will still have rows in
    the joined dataset (with `NULL` values for the fields coming from `user_interests`),
    and `COUNT` counts only values that are non-`NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The NotQuiteABase `join` implementation will be more restrictive—it simply
    joins two tables on whatever columns they have in common. Even so, it’s not trivial
    to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we could find users interested in SQL with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And we could get the interest counts with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In SQL, there is also a `RIGHT JOIN`, which keeps rows from the right table
    that have no matches, and a `FULL OUTER JOIN`, which keeps rows from both tables
    that have no matches. We won’t implement either of those.
  prefs: []
  type: TYPE_NORMAL
- en: Subqueries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In SQL, you can `SELECT` from (and `JOIN`) the results of queries as if they
    were tables. So, if you wanted to find the smallest `user_id` of anyone interested
    in SQL, you could use a subquery. (Of course, you could do the same calculation
    using a `JOIN`, but that wouldn’t illustrate subqueries.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Given the way we’ve designed NotQuiteABase, we get this for free. (Our query
    results are actual tables.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To find rows containing a specific value (say, where `name` is “Hero”), NotQuiteABase
    has to inspect every row in the table. If the table has a lot of rows, this can
    take a very long time.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, our `join` algorithm is extremely inefficient. For each row in the
    left table, it inspects every row in the right table to see if it’s a match. With
    two large tables this could take approximately forever.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you’d often like to apply constraints to some of your columns. For example,
    in your `users` table you probably don’t want to allow two different users to
    have the same `user_id`.
  prefs: []
  type: TYPE_NORMAL
- en: Indexes solve all these problems. If the `user_interests` table had an index
    on `user_id`, a smart `join` algorithm could find matches directly rather than
    scanning the whole table. If the `users` table had a “unique” index on `user_id`,
    you’d get an error if you tried to insert a duplicate.
  prefs: []
  type: TYPE_NORMAL
- en: Each table in a database can have one or more indexes, which allow you to quickly
    look up rows by key columns, efficiently join tables together, and enforce unique
    constraints on columns or combinations of columns.
  prefs: []
  type: TYPE_NORMAL
- en: Designing and using indexes well is something of a black art (which varies somewhat
    depending on the specific database), but if you end up doing a lot of database
    work it’s worth learning about.
  prefs: []
  type: TYPE_NORMAL
- en: Query Optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recall the query to find all users who are interested in SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In NotQuiteABase there are (at least) two different ways to write this query.
    You could filter the `user_interests` table before performing the join:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you could filter the results of the join:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You’ll end up with the same results either way, but filter-before-join is almost
    certainly more efficient, since in that case `join` has many fewer rows to operate
    on.
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, you generally wouldn’t worry about this. You “declare” the results you
    want and leave it up to the query engine to execute them (and use indexes efficiently).
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A recent trend in databases is toward nonrelational “NoSQL” databases, which
    don’t represent data in tables. For instance, MongoDB is a popular schemaless
    database whose elements are arbitrarily complex JSON documents rather than rows.
  prefs: []
  type: TYPE_NORMAL
- en: There are column databases that store data in columns instead of rows (good
    when data has many columns but queries need few of them), key/value stores that
    are optimized for retrieving single (complex) values by their keys, databases
    for storing and traversing graphs, databases that are optimized to run across
    multiple datacenters, databases that are designed to run in memory, databases
    for storing time-series data, and hundreds more.
  prefs: []
  type: TYPE_NORMAL
- en: Tomorrow’s flavor of the day might not even exist now, so I can’t do much more
    than let you know that NoSQL is a thing. So now you know. It’s a thing.
  prefs: []
  type: TYPE_NORMAL
- en: For Further Exploration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’d like to download a relational database to play with, [SQLite](http://www.sqlite.org)
    is fast and tiny, while [MySQL](http://www.mysql.com) and [PostgreSQL](http://www.postgresql.org)
    are larger and featureful. All are free and have lots of documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to explore NoSQL, [MongoDB](http://www.mongodb.org) is very simple
    to get started with, which can be both a blessing and somewhat of a curse. It
    also has pretty good documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Wikipedia article on NoSQL](http://en.wikipedia.org/wiki/NoSQL) almost
    certainly now contains links to databases that didn’t even exist when this book
    was written.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
