- en: 'Chapter 10\. Finding the Longest Shared Subsequence: Finding K-mers, Writing
    Functions, and Using Binary Search'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described in [the Rosalind LCSM challenge](https://oreil.ly/SONgC), the goal
    of this exercise is to find the longest substring that is shared by all sequences
    in a given FASTA file. In [Chapter 8](ch08.html#ch08), I was searching for a given
    motif in some sequences. In this challenge, I don’t know *a priori* that any shared
    motif is present—much less the size or composition of it—so I’ll just look for
    any length of sequence that is present in every sequence. This is a challenging
    exercise that brings together many ideas I’ve shown in earlier chapters. I’ll
    use the solutions to explore algorithm design, functions, tests, and code organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use k-mers to find shared subsequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use `itertools.chain()` to concatenate lists of lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How and why to use a binary search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One way to maximize a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `key` option with `min()` and `max()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the code and tests for this challenge are in the *10_lcsm* directory. Start
    by copying the first solution to the `lcsm.py` program and asking for help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The only required argument is a single positional file of FASTA-formatted DNA
    sequences. As with other programs that accept files, the program will reject invalid
    or unreadable input. The following is the first input I’ll use. The longest common
    subsequences in these sequences are *CA*, *TA*, and *AC*, with the last shown
    in bold in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Any of these answers are acceptable. Run the program with the first test input
    and see that it randomly selects one of the acceptable 2-mers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The second test input is much larger, and you’ll notice that the program takes
    significantly longer to find the answer. On my laptop, it takes almost 40 seconds.
    In the solutions, I’ll show you a way to significantly decrease the runtime using
    a binary search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Although not a requirement of the challenge, I’ve included one input file that
    contains no shared subsequences for which the program should create a suitable
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the `lcsm.py` program from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the arguments like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The only input to this program is a FASTA-formatted file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Define a single `file` argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Return the `Args` object containing the open filehandle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then update the `main()` function to print the incoming filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that you see the correct usage and that the program correctly prints
    the filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: At this point, your program should pass the first three tests. If you think
    you know how to complete the program, have at it. If you want a prod in the right
    direction, read on.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Shortest Sequence in a FASTA File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reading a FASTA file should be familiar by now. I’ll use `Bio.SeqIO.parse()`
    as before. My first idea on this problem was to find shared k-mers while maximizing
    for `k`. The longest subsequence can be no longer than the shortest sequence in
    the file, so I decided to start with `k` equal to that. Finding the shortest sequence
    requires that I first scan through *all* the records. To review how to do this,
    the `Bio.SeqIO.parse()` function returns an iterator that gives me access to each
    FASTA record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'I can use the `next()` function I first showed in [Chapter 4](ch04.html#ch04)
    to force the iterator to produce the next value, the type of which is `SeqRecord`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the sequence itself, the FASTA record contains metadata such
    as the sequence ID, name, and such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The read information is wrapped in a `Seq` object, which has many interesting
    and useful methods you can explore in the REPL using **`help(rec.seq)`**. I’m
    only interested in the raw sequence, so I can use the `str()` function to coerce
    it to a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'I need all the sequences in a list so that I can find the length of the shortest
    one. I can use a list comprehension to read the entire file into a list since
    I’ll be using these many times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Reopen the filehandle or the existing filehandle will continue from the second
    read.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a list, coercing each record’s sequence to a string.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence files may hold millions of reads, and storing them in a list could
    easily exceed the available memory and crash your machine. (Ask me how I know.)
    The problem is that I need all the sequences in the next step to find the subsequence
    that is common to all of them. I have several *Makefile* targets that will use
    the `genseq.py` program in the *10_lcsm* directory to generate large FASTA inputs
    with a common motif for you to test. This program works adequately for the datasets
    provided by Rosalind.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same idea can be expressed using the `map()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the length of the shortest sequence, I need to find the lengths of
    all the sequences, which I can do using a list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'I prefer the shorter way to write this using a `map()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Python has built-in `min()` and `max()` functions that will return the minimum
    or maximum value from a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'So the shortest sequence is equal to the minimum of the lengths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Extracting K-mers from a Sequence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The longest shared subsequence can be no longer than the shortest sequence
    and must be shared by all the reads. Therefore, my next step is to find all the
    k-mers in all the sequences, starting with `k` equal to the length of the shortest
    sequence (`5`). In [Chapter 9](ch09.html#ch09) I wrote a `find_kmers()` function
    and test, so I’ll copy that code into this program. Remember to import `typing.List`
    for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'One logical approach is to start with the maximum possible value of `k` and
    count down, stopping when I find a k-mer shared by all the sequences. So far I’ve
    only used the `range()` function to count up. Can I reverse the start and stop
    values to count down? Apparently not. If the start value is greater than the stop
    value, then `range()` will produce an empty list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When reading codons in [Chapter 7](ch07.html#ch07), I mentioned that the `range()`
    function accepts up to three arguments, the last of which is the *step*, which
    I used there to jump three bases at a time. Here I need to use a step of `-1`
    to count down. Remember that the stop value is not included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to count backward is to count up and reverse the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Either way, I want to iterate over decreasing values of `k` until I find a
    k-mer that is shared by all the sequences. A sequence might contain multiple copies
    of the same k-mer, so it’s important to make the result unique by using the `set()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Can you see a way to use this idea to count all the k-mers for each value of
    `k`? Look for k-mers that have a frequency matching the number of sequences. If
    you find more than one, print any one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The two variations for this program use the same basic logic to find the longest
    shared subsequence. The first version proves to scale poorly as the input size
    increases because it uses a stepwise, linear approach to iterating over every
    possible `k`-length of sequence. The second version introduces a binary search
    to find a good starting value for `k` and then initiates a hill-climbing search
    to discover a maximum value for `k`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 1: Counting Frequencies of K-mers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, I got as far as finding all the k-mers in the sequences
    for values of `k`, starting with the shortest sequence and moving down to `1`.
    Here I’ll start with `k` equal to `5`, which was the length of the shortest sequence
    in the first FASTA file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'I need a way to count how many times each k-mer appears across all the sequences.
    One approach is to use `collections.Counter()`, which I first showed in [Chapter 1](ch01.html#ch01):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'I can iterate over each set of k-mers from the sequences and use the `Counter.update()`
    method to add them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Or I could concatenate the many lists of k-mers together into a single list
    using `itertools.chain()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this as the input for the `Counter()` produces the same collection, showing
    that each 5-mer is unique, occurring once each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Counter()` is a regular dictionary underneath, which means I have access
    to all the dictionary methods. I want to iterate through the keys and values as
    pairs using the `dict.items()` method to find where the count of the k-mers is
    equal to the number of sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When `k` is `5`, there are no candidate sequences, so I need to try with a
    smaller value. Since I know the right answer is `2`, I’ll rerun this code with
    `k=2` to produce this dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, I find three candidate 2-mers have a frequency of 3, which equals
    the number of sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It doesn’t matter which of the candidates I choose, so I’ll use the `random.choice()`
    function which returns one value from a list of choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'I like where this is going, so I’d like to put it into a function so I can
    test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Find the number of sequences.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Return the k-mers having a frequency equal to the number of sequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes for a pretty readable `main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Read all the sequences into a list.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Find the length of the shortest sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Count down from the shortest sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Find all the common k-mers using this value of `k`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: If any k-mers are found, print a random selection.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Exit the program using an exit value of `0` (no errors).
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-7)'
  prefs: []
  type: TYPE_NORMAL
- en: If I make it to this point, inform the user there is no shared sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, I’m again using the walrus operator (`:=`) I introduced
    in [Chapter 5](ch05.html#ch05) to first assign the result of calling `common_kmers()`
    to the variable `kmers` and then evaluate `kmers` for truthiness. Python will
    only enter the next block if `kmers` is truthy, meaning there were common k-mers
    found for this value of `k`. Before the addition of this language feature, I would
    have had to write the assignment and evaluation on two lines, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Solution 2: Speeding Things Up with a Binary Search'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As noted in the opening section of this chapter, this solution grows much slower
    as the size of the inputs increases. One way to track the progress of the program
    is to put a `print(k)` statement at the beginning of the `for` loop. Run this
    with the second input file, and you’ll see that it starts counting down from 1,000
    and doesn’t reach the correct value for `k` until it hits 78.
  prefs: []
  type: TYPE_NORMAL
- en: Counting backward by 1 is taking too long. If your friend asked you to guess
    a number between 1 and 1,000, you wouldn’t start at 1,000 and keep guessing 1
    less each time your friend said, “Too high.” It’s much faster (and better for
    your friendship) to guess 500. If your friend chose 453, they’d say “Too high,”
    so you’d be wise to choose 250. They’d reply, “Too low,” and you’d keep splitting
    the differences between your last high and low guesses until you found the right
    answer. This is a *binary search*, and it’s a great way to quickly find the location
    of a wanted value from a sorted list of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this better, I’ve included a program in the *10_lcsm* directory
    called `binsearch.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the relevant portion of the program. You can read the source
    code for the argument definitions if you like. The `binary_search()` function
    is recursive, like one solution to the Fibonacci sequence problem from [Chapter 4](ch04.html#ch04).
    Note that the search values must be sorted for binary searches to work, which
    the `range()` function provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The base case to exit the recursion is when this is false.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The midpoint is halfway between `high` and `low`, using floor division.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Return the midpoint if the element is in the middle.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: See if the value at the midpoint is greater than the desired value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Search the lower values.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Search the higher values.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The value was not found.
  prefs: []
  type: TYPE_NORMAL
- en: The names `x` and `xs` in the `binary_search()` function are meant to be singular
    and plural. In my head, I pronounce them *ex* and *exes*. This kind of notation
    is common in purely functional programming because I’m not trying to describe
    what kind of value `x` is. It could be a string or a number or anything. The important
    point is that `xs` is some collection of comparable values all of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'I included some `print()` statements so that, running with the previous numbers,
    you can see how `low` and `high` finally converge on the target number in 10 steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It takes just eight iterations to determine the number is not present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The binary search can tell me if a value occurs in a list of values, but this
    is not quite my problem. While I’m reasonably sure there will be at least a 2-
    or 1-mer in common in most datasets, I have included one file that has none:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is an acceptable value for `k`, then I need to find the *maximum*
    value. I decided to use the binary search to find a starting point for a hill-climbing
    search to find the maximum value. First I’ll show `main()`, and then I’ll break
    down the other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Get a list of the sequences as strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Find the length of the shortest sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Partially apply the `common_kmers()` function with the `seqs` input.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the binary search to find a starting point for the given function, using
    `1` for the lowest value of `k` and the shortest sequence length for the maximum.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Check that the binary search found something useful.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a list of the candidate values.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Start the hill climbing with the binary search result.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Check if there are common k-mers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-9)'
  prefs: []
  type: TYPE_NORMAL
- en: If so, randomly add one to the list of candidates.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](assets/10.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-10)'
  prefs: []
  type: TYPE_NORMAL
- en: If there are no common k-mers, break out of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[![11](assets/11.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-11)'
  prefs: []
  type: TYPE_NORMAL
- en: Choose the candidate sequence having the longest length.
  prefs: []
  type: TYPE_NORMAL
- en: '[![12](assets/12.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-12)'
  prefs: []
  type: TYPE_NORMAL
- en: Let the user know that there is no answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are many things to explain in the preceding code, I want to highlight
    the call to `max()`. I showed earlier that this function will return the maximum
    value from a list. Normally you might think to use this on a list of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, I want to find the longest string in a list. I can `map()`
    the `len()` function to find their lengths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that the third sequence, *GGGG*, is the longest. The `max()` function
    accepts an optional `key` argument, which is a function to apply to each element
    before comparing. If I use the `len()` function, then `max()` correctly identifies
    the longest sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a look at how I modified the `binary_search()` function to suit
    my needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The function takes another function `f()` along with `low` and `high` values
    as arguments. In this instance, the function `f()` will return the common k-mers,
    but the function can perform any calculation you like.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Call the function `f()` with the highest and lowest values for `k`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Find the midpoint value of `k`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: If the function `f()` found common k-mers for both the high and low `k` values,
    return the highest k.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-5)'
  prefs: []
  type: TYPE_NORMAL
- en: If the high `k` found no k-mers but the low value did, recursively call the
    function searching in the lower values of `k`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-6)'
  prefs: []
  type: TYPE_NORMAL
- en: If the low `k` found no k-mers but the high value did, recursively call the
    function searching in the higher values of `k`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Return `-1` to indicate no k-mers were found using the `high` and `low` arguments
    to `f()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the test I wrote for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: These are the sequences I’ve been using that have three shared 2-mers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Define a function to find the k-mers in the first set of sequences.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The search finds a `k` of `2` which is the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The same sequences as before but now with a shared 3-mer.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The search finds a `k` of `3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the previous binary search, my version won’t (necessarily) return the
    *exact* answer, just a decent starting point. If there are no shared sequences
    for any size `k`, then I let the user know:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is a shared subsequence, this version runs significantly faster—perhaps
    as much as 28 times faster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When I was searching from the maximum `k` value and iterating down, I was performing
    a *linear* search through all the possible values. This means the time to search
    grows in proportion (linearly) to the number *n* of values. A binary search, by
    contrast, grows at a rate of log *n*. It’s common to talk about the runtime growth
    of algorithms using *Big O* notation, so you might see binary search described
    as O(log *n*), whereas linear searching is O(*n*)—which is much worse.
  prefs: []
  type: TYPE_NORMAL
- en: Going Further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with the suggestion in [Chapter 9](ch09.html#ch09), add a Hamming distance
    option that will allow for the indicated number of differences when deciding on
    a shared k-mer.
  prefs: []
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Key points from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: K-mers can be used to find conserved regions of sequences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists of lists can be combined into a single list using `itertools.chain()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A binary search can be used on sorted values to find a value more quickly than
    searching through the list linearly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hill climbing is one way to maximize the input to a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `key` option for `min()` and `max()` is a function that is applied to the
    values before comparing them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
