- en: Chapter 23\. Working with Time Series
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第23章。 与时间序列一起工作
- en: 'Pandas was originally developed in the context of financial modeling, so as
    you might expect, it contains an extensive set of tools for working with dates,
    times, and time-indexed data. Date and time data comes in a few flavors, which
    we will discuss here:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas最初是在财务建模的背景下开发的，因此您可能期望它包含大量用于处理日期、时间和时间索引数据的工具。 日期和时间数据有几种不同的形式，我们将在这里进行讨论：
- en: '*Timestamps*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*时间戳*'
- en: Particular moments in time (e.g., July 4, 2021 at 7:00 a.m.).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 特定的时间点（例如，2021年7月4日上午7:00）。
- en: '*Time intervals* and *periods*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*时间间隔*和*周期*'
- en: A length of time between a particular beginning and end point; for example,
    the month of June 2021. Periods usually reference a special case of time intervals
    in which each interval is of uniform length and does not overlap (e.g., 24-hour-long
    periods comprising days).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 特定开始和结束点之间的一段时间；例如，2021年6月份。 周期通常指每个间隔具有统一长度且不重叠的特殊时间间隔的情况（例如，由一天组成的24小时周期）。
- en: '*Time deltas* or *durations*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*时间差*或*持续时间*'
- en: An exact length of time (e.g., a duration of 22.56 seconds).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 精确的时间长度（例如，22.56秒的持续时间）。
- en: This chapter will introduce how to work with each of these types of date/time
    data in Pandas. This is by no means a complete guide to the time series tools
    available in Python or Pandas, but instead is intended as a broad overview of
    how you as a user should approach working with time series. We will start with
    a brief discussion of tools for dealing with dates and times in Python, before
    moving more specifically to a discussion of the tools provided by Pandas. Finally,
    we will review some short examples of working with time series data in Pandas.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍如何在Pandas中处理这些类型的日期/时间数据。 这并不是Python或Pandas中可用的时间序列工具的完整指南，而是旨在作为用户如何处理时间序列的广泛概述。
    我们将首先简要讨论Python中处理日期和时间的工具，然后更详细地讨论Pandas提供的工具。 最后，我们将回顾一些在Pandas中处理时间序列数据的简短示例。
- en: Dates and Times in Python
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的日期和时间
- en: The Python world has a number of available representations of dates, times,
    deltas, and time spans. While the time series tools provided by Pandas tend to
    be the most useful for data science applications, it is helpful to see their relationship
    to other tools used in Python.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python世界中有许多可用于表示日期、时间、时间差和时间跨度的表示方法。 虽然Pandas提供的时间序列工具对数据科学应用最有用，但了解它们与Python中其他工具的关系是有帮助的。
- en: 'Native Python Dates and Times: datetime and dateutil'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本机Python日期和时间：datetime和dateutil
- en: 'Python’s basic objects for working with dates and times reside in the built-in
    `datetime` module. Along with the third-party `dateutil` module, you can use this
    to quickly perform a host of useful functionalities on dates and times. For example,
    you can manually build a date using the `datetime` type:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python用于处理日期和时间的基本对象位于内置的`datetime`模块中。 除了第三方的`dateutil`模块之外，您还可以使用此功能快速执行许多有用的日期和时间功能。
    例如，您可以使用`datetime`类型手动构建日期：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or, using the `dateutil` module, you can parse dates from a variety of string
    formats:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用`dateutil`模块，您可以从各种字符串格式中解析日期：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once you have a `datetime` object, you can do things like printing the day
    of the week:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了`datetime`对象，您可以执行一些操作，比如打印星期几：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here we’ve used one of the standard string format codes for printing dates
    (`''%A''`), which you can read about in the [`strftime` section](https://oreil.ly/bjdsf)
    of Python’s [`datetime` documentation](https://oreil.ly/AGVR9). Documentation
    of other useful date utilities can be found in [`dateutil`’s online documentation](https://oreil.ly/Y5Rwd).
    A related package to be aware of is [`pytz`](https://oreil.ly/DU9Jr), which contains
    tools for working with the most migraine-inducing element of time series data:
    time zones.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用了用于打印日期的标准字符串格式代码之一（`'%A'`），您可以在Python的`datetime`文档的[`strftime`部分](https://oreil.ly/bjdsf)中了解相关信息。
    有关其他有用日期工具的文档，请查看[`dateutil`的在线文档](https://oreil.ly/Y5Rwd)。 还有一个相关的软件包需要注意，那就是[`pytz`](https://oreil.ly/DU9Jr)，它包含了处理时间序列数据中最令人头疼的元素：时区。
- en: 'The power of `datetime` and `dateutil` lies in their flexibility and easy syntax:
    you can use these objects and their built-in methods to easily perform nearly
    any operation you might be interested in. Where they break down is when you wish
    to work with large arrays of dates and times: just as lists of Python numerical
    variables are suboptimal compared to NumPy-style typed numerical arrays, lists
    of Python `datetime` objects are suboptimal compared to typed arrays of encoded
    dates.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`datetime`和`dateutil`的威力在于它们的灵活性和简单的语法：你可以使用这些对象及其内置方法轻松地执行几乎任何你感兴趣的操作。它们的局限性在于当你希望处理大量的日期和时间时：正如
    Python 数值变量的列表与 NumPy 风格的类型化数值数组相比是次优的一样，Python `datetime`对象的列表与编码日期的类型化数组相比也是次优的。'
- en: 'Typed Arrays of Times: NumPy’s datetime64'
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间数组：NumPy的datetime64
- en: 'NumPy’s `datetime64` dtype encodes dates as 64-bit integers, and thus allows
    arrays of dates to be represented compactly and operated on in an efficient manner.
    The `datetime64` requires a specific input format:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy的`datetime64`数据类型将日期编码为64位整数，因此允许以紧凑的方式表示日期数组并以有效的方式对其进行操作。`datetime64`需要特定的输入格式：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once we have dates in this form, we can quickly do vectorized operations on
    it:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将日期转换为这种形式，就可以快速对其进行向量化操作：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Because of the uniform type in NumPy `datetime64` arrays, this kind of operation
    can be accomplished much more quickly than if we were working directly with Python’s
    `datetime` objects, especially as arrays get large (we introduced this type of
    vectorization in [Chapter 6](ch06.xhtml#section-0203-computation-on-arrays-ufuncs)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于NumPy `datetime64`数组中的统一类型，这种操作比直接使用Python的`datetime`对象要快得多，特别是在数组变大时（我们在[第6章](ch06.xhtml#section-0203-computation-on-arrays-ufuncs)中介绍了这种向量化类型）。
- en: One detail of the `datetime64` and related `timedelta64` objects is that they
    are built on a *fundamental time unit*. Because the `datetime64` object is limited
    to 64-bit precision, the range of encodable times is <math alttext="2 Superscript
    64"><msup><mn>2</mn> <mn>64</mn></msup></math> times this fundamental unit. In
    other words, `datetime64` imposes a trade-off between *time resolution* and *maximum
    time span*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`datetime64`和相关的`timedelta64`对象的一个细节是它们是建立在*基本时间单位*上的。因为`datetime64`对象的精度限制为64位，所以可编码时间的范围是基本单位的<math
    alttext="2 Superscript 64"><msup><mn>2</mn> <mn>64</mn></msup></math>倍。换句话说，`datetime64`在*时间分辨率*和*最大时间跨度*之间存在权衡。'
- en: 'For example, if you want a time resolution of 1 nanosecond, you only have enough
    information to encode a range of <math alttext="2 Superscript 64"><msup><mn>2</mn>
    <mn>64</mn></msup></math> nanoseconds, or just under 600 years. NumPy will infer
    the desired unit from the input; for example, here is a day-based `datetime`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想要1纳秒的时间分辨率，您只有足够的信息来编码<math alttext="2 Superscript 64"><msup><mn>2</mn>
    <mn>64</mn></msup></math>纳秒范围内的时间，或者不到600年。NumPy将从输入中推断出所需的单位；例如，这里是一个基于天的`datetime`：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is a minute-based datetime:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基于分钟的datetime：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can force any desired fundamental unit using one of many format codes;
    for example, here we’ll force a nanosecond-based time:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用许多格式代码强制使用任何所需的基本单位；例如，这里我们将强制使用基于纳秒的时间：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Table 23-1](#table-23-1), drawn from the NumPy `datetime64` documentation,
    lists the available format codes along with the relative and absolute time spans
    that they can encode.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[表23-1](#table-23-1)，摘自 NumPy `datetime64` 文档，列出了可用的格式代码及其可以编码的相对和绝对时间跨度。'
- en: Table 23-1\. Description of date and time codes
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 表23-1\. 日期和时间代码描述
- en: '| Code | Meaning | Time span (relative) | Time span (absolute) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 意义 | 时间跨度（相对） | 时间跨度（绝对） |'
- en: '| --- | --- | --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `Y` | Year | ± 9.2e18 years | [9.2e18 BC, 9.2e18 AD] |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `Y` | 年 | ± 9.2e18 年 | [9.2e18 BC, 9.2e18 AD] |'
- en: '| `M` | Month | ± 7.6e17 years | [7.6e17 BC, 7.6e17 AD] |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `M` | 月 | ± 7.6e17 年 | [7.6e17 BC, 7.6e17 AD] |'
- en: '| `W` | Week | ± 1.7e17 years | [1.7e17 BC, 1.7e17 AD] |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `W` | 周 | ± 1.7e17 年 | [1.7e17 BC, 1.7e17 AD] |'
- en: '| `D` | Day | ± 2.5e16 years | [2.5e16 BC, 2.5e16 AD] |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `D` | 日 | ± 2.5e16 年 | [2.5e16 BC, 2.5e16 AD] |'
- en: '| `h` | Hour | ± 1.0e15 years | [1.0e15 BC, 1.0e15 AD] |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `h` | 小时 | ± 1.0e15 年 | [1.0e15 BC, 1.0e15 AD] |'
- en: '| `m` | Minute | ± 1.7e13 years | [1.7e13 BC, 1.7e13 AD] |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `m` | 分钟 | ± 1.7e13 年 | [1.7e13 BC, 1.7e13 AD] |'
- en: '| `s` | Second | ± 2.9e12 years | [ 2.9e9 BC, 2.9e9 AD] |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `s` | 秒 | ± 2.9e12 年 | [2.9e9 BC, 2.9e9 AD] |'
- en: '| `ms` | Millisecond | ± 2.9e9 years | [ 2.9e6 BC, 2.9e6 AD] |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `ms` | 毫秒 | ± 2.9e9 年 | [2.9e6 BC, 2.9e6 AD] |'
- en: '| `us` | Microsecond | ± 2.9e6 years | [290301 BC, 294241 AD] |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `us` | 微秒 | ± 2.9e6 年 | [290301 BC, 294241 AD] |'
- en: '| `ns` | Nanosecond | ± 292 years | [ 1678 AD, 2262 AD] |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `ns` | 纳秒 | ± 292 年 | [1678 AD, 2262 AD] |'
- en: '| `ps` | Picosecond | ± 106 days | [ 1969 AD, 1970 AD] |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `ps` | 皮秒 | ± 106 天 | [ 1969 年, 1970 年] |'
- en: '| `fs` | Femtosecond | ± 2.6 hours | [ 1969 AD, 1970 AD] |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `fs` | 飞秒 | ± 2.6 小时 | [ 1969 年, 1970 年] |'
- en: '| `as` | Attosecond | ± 9.2 seconds | [ 1969 AD, 1970 AD] |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `as` | 阿秒 | ± 9.2 秒 | [ 1969 年, 1970 年] |'
- en: For the types of data we see in the real world, a useful default is `datetime64[ns]`,
    as it can encode a useful range of modern dates with a suitably fine precision.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在现实世界中看到的数据类型，一个有用的默认值是`datetime64[ns]`，因为它可以用适当的精度编码一系列现代日期。
- en: Finally, note that while the `datetime64` data type addresses some of the deficiencies
    of the built-in Python `datetime` type, it lacks many of the convenient methods
    and functions provided by `datetime` and especially `dateutil`. More information
    can be found in [NumPy’s `datetime64` documentation](https://oreil.ly/XDbck).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，虽然`datetime64`数据类型解决了内置 Python `datetime` 类型的一些不足之处，但它缺少许多`datetime`和尤其是`dateutil`提供的便利方法和函数。更多信息可以在[NumPy的`datetime64`文档](https://oreil.ly/XDbck)中找到。
- en: 'Dates and Times in Pandas: The Best of Both Worlds'
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pandas 中的日期和时间：两者兼得
- en: Pandas builds upon all the tools just discussed to provide a `Timestamp` object,
    which combines the ease of use of `datetime` and `dateutil` with the efficient
    storage and vectorized interface of `numpy.datetime64`. From a group of these
    `Timestamp` objects, Pandas can construct a `DatetimeIndex` that can be used to
    index data in a `Series` or `DataFrame`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 在刚讨论的所有工具基础上构建了一个`Timestamp`对象，它结合了`datetime`和`dateutil`的易用性以及`numpy.datetime64`的高效存储和向量化接口。从这些`Timestamp`对象中，Pandas
    可以构建一个`DatetimeIndex`，用于索引`Series`或`DataFrame`中的数据。
- en: 'For example, we can use Pandas tools to repeat the demonstration from earlier.
    We can parse a flexibly formatted string date and use format codes to output the
    day of the week, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用 Pandas 工具重复之前的演示。我们可以解析一个灵活格式的字符串日期，并使用格式代码输出星期几，如下所示：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Additionally, we can do NumPy-style vectorized operations directly on this
    same object:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以直接在同一个对象上进行 NumPy 风格的向量化操作：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the next section, we will take a closer look at manipulating time series
    data with the tools provided by Pandas.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更仔细地学习使用 Pandas 提供的工具操作时间序列数据。
- en: 'Pandas Time Series: Indexing by Time'
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pandas 时间序列：按时间索引
- en: 'The Pandas time series tools really become useful when you begin to index data
    by timestamps. For example, we can construct a `Series` object that has time-indexed
    data:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始按时间戳索引数据时，Pandas 的时间序列工具就会变得非常有用。例如，我们可以构建一个具有时间索引数据的`Series`对象：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And now that we have this data in a `Series`, we can make use of any of the
    `Series` indexing patterns we discussed in previous chapters, passing values that
    can be coerced into dates:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将这些数据放入了一个`Series`中，我们可以利用我们在之前章节中讨论过的任何`Series`索引模式，传递可以强制转换为日期的值：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are additional special date-only indexing operations, such as passing
    a year to obtain a slice of all data from that year:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他特殊的仅限日期索引操作，比如传递一个年份以获得该年份所有数据的切片：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Later, we will see additional examples of the convenience of dates-as-indices.
    But first, let’s take a closer look at the available time series data structures.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 后面，我们将看到更多关于日期作为索引的便利性的例子。但首先，让我们更仔细地看一下可用的时间序列数据结构。
- en: Pandas Time Series Data Structures
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pandas 时间序列数据结构
- en: 'This section will introduce the fundamental Pandas data structures for working
    with time series data:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍处理时间序列数据的基本 Pandas 数据结构：
- en: For *timestamps*, Pandas provides the `Timestamp` type. As mentioned before,
    this is essentially a replacement for Python’s native `datetime`, but it’s based
    on the more efficient `numpy.datetime64` data type. The associated `Index` structure
    is `DatetimeIndex`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于*时间戳*，Pandas 提供了`Timestamp`类型。如前所述，这实际上是 Python 原生`datetime`的替代品，但它基于更高效的`numpy.datetime64`数据类型。相关的索引结构是`DatetimeIndex`。
- en: For *time periods*, Pandas provides the `Period` type. This encodes a fixed-frequency
    interval based on `numpy.datetime64`. The associated index structure is `PeriodIndex`.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于*时间段*，Pandas 提供了`Period`类型。这个类型基于`numpy.datetime64`，用于编码固定频率间隔。相关的索引结构是`PeriodIndex`。
- en: For *time deltas* or *durations*, Pandas provides the `Timedelta` type. `Timedelta`
    is a more efficient replacement for Python’s native `datetime.timedelta` type,
    and is based on `numpy.timedelta64`. The associated index structure is `TimedeltaIndex`.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于*时间差*或*持续时间*，Pandas 提供了`Timedelta`类型。`Timedelta`是 Python 原生的`datetime.timedelta`类型的更高效替代品，基于`numpy.timedelta64`。相关的索引结构是`TimedeltaIndex`。
- en: 'The most fundamental of these date/time objects are the `Timestamp` and `Datetime​In⁠dex`
    objects. While these class objects can be invoked directly, it is more common
    to use the `pd.to_datetime` function, which can parse a wide variety of formats.
    Passing a single date to `pd.to_datetime` yields a `Timestamp`; passing a series
    of dates by default yields a `DatetimeIndex`, as you can see here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些日期/时间对象中最基础的是`Timestamp`和`Datetime​In⁠dex`对象。虽然可以直接调用这些类对象，但更常见的是使用`pd.to_datetime`函数，该函数可以解析各种格式。将单个日期传递给`pd.to_datetime`将产生一个`Timestamp`；默认情况下传递一系列日期将产生一个`DatetimeIndex`，正如你在这里看到的：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Any `DatetimeIndex` can be converted to a `PeriodIndex` with the `to_period`
    function, with the addition of a frequency code; here we’ll use `''D''` to indicate
    daily frequency:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 任何`DatetimeIndex`都可以通过`to_period`函数转换为`PeriodIndex`，并增加一个频率代码；这里我们将使用`'D'`表示每日频率：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A `TimedeltaIndex` is created, for example, when a date is subtracted from
    another:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当从一个日期中减去另一个日期时，会创建一个`TimedeltaIndex`：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Regular Sequences: pd.date_range'
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常规序列：pd.date_range
- en: 'To make creation of regular date sequences more convenient, Pandas offers a
    few functions for this purpose: `pd.date_range` for timestamps, `pd.period_range`
    for periods, and `pd.timedelta_range` for time deltas. We’ve seen that Python’s
    `range` and NumPy’s `np.arange` take a start point, end point, and optional step
    size and return a sequence. Similarly, `pd.date_range` accepts a start date, an
    end date, and an optional frequency code to create a regular sequence of dates:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更方便地创建常规日期序列，Pandas提供了几个专用函数：`pd.date_range`用于时间戳，`pd.period_range`用于周期，`pd.timedelta_range`用于时间差。我们已经看到Python的`range`和NumPy的`np.arange`接受起始点、结束点和可选步长，并返回一个序列。类似地，`pd.date_range`接受起始日期、结束日期和可选频率代码，以创建一系列常规日期：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Alternatively, the date range can be specified not with a start and end point,
    but with a start point and a number of periods:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，日期范围可以不是起点和终点，而是起点和一定数量的周期：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The spacing can be modified by altering the `freq` argument, which defaults
    to `D`. For example, here we construct a range of hourly timestamps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过修改`freq`参数来调整间隔，默认为`D`。例如，这里我们构建一个小时时间戳的范围：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To create regular sequences of `Period` or `Timedelta` values, the similar
    `pd.period_range` and `pd.timedelta_range` functions are useful. Here are some
    monthly periods:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`Period`或`Timedelta`值的常规序列，可以使用类似的`pd.period_range`和`pd.timedelta_range`函数。这里是一些月度周期：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And a sequence of durations increasing by an hour:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一系列按小时增加的持续时间：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All of these require an understanding of Pandas frequency codes, which are summarized
    in the next section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都需要理解Pandas的频率代码，这些在下一节中总结。
- en: Frequencies and Offsets
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 频率和偏移量
- en: Fundamental to these Pandas time series tools is the concept of a *frequency*
    or *date offset*. The following table summarizes the main codes available; as
    with the `D` (day) and `H` (hour) codes demonstrated in the previous sections,
    we can use these to specify any desired frequency spacing. [Table 23-2](#table-23-2)
    summarizes the main codes available.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas时间序列工具的基础是*频率*或*日期偏移*的概念。下表总结了主要的可用代码；与前面章节展示的`D`（天）和`H`（小时）代码一样，我们可以使用这些代码来指定任何所需的频率间隔。[表 23-2](#table-23-2)总结了主要可用的代码。
- en: Table 23-2\. Listing of Pandas frequency codes
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表 23-2\. Pandas频率代码列表
- en: '| Code | Description | Code | Description |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 描述 | 代码 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `D` | Calendar day | `B` | Business day |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `D` | 日历日 | `B` | 工作日 |'
- en: '| `W` | Weekly |  |  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `W` | 周 |  |  |'
- en: '| `M` | Month end | `BM` | Business month end |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `M` | 月末 | `BM` | 工作月末 |'
- en: '| `Q` | Quarter end | `BQ` | Business quarter end |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `Q` | 季度末 | `BQ` | 商业季度末 |'
- en: '| `A` | Year end | `BA` | Business year end |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `A` | 年末 | `BA` | 商业年末 |'
- en: '| `H` | Hours | `BH` | Business hours |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `H` | 小时 | `BH` | 工作小时 |'
- en: '| `T` | Minutes |  |  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `T` | 分钟 |  |  |'
- en: '| `S` | Seconds |  |  |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `S` | 秒 |  |  |'
- en: '| `L` | Milliseconds |  |  |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `L` | 毫秒 |  |  |'
- en: '| `U` | Microseconds |  |  |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `U` | 微秒 |  |  |'
- en: '| `N` | Nanoseconds |  |  |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `N` | 纳秒 |  |  |'
- en: The monthly, quarterly, and annual frequencies are all marked at the end of
    the specified period. Adding an `S` suffix to any of these causes them to instead
    be marked at the beginning (see [Table 23-3](#table-23-3)).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 月度、季度和年度频率均标记在指定期间的末尾。在任何这些频率代码后面添加`S`后缀会使它们标记在开始而不是末尾（参见[表 23-3](#table-23-3)）。
- en: Table 23-3\. Listing of start-indexed frequency codes
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 表 23-3\. 开始索引频率代码列表
- en: '| Code | Description | Code | Description |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 描述 | 代码 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `MS` | Month start | `BMS` | Business month start |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `MS` | 月开始 | `BMS` | 工作日月开始 |'
- en: '| `QS` | Quarter start | `BQS` | Business quarter start |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `QS` | 季度开始 | `BQS` | 工作日季度开始 |'
- en: '| `AS` | Year start | `BAS` | Business year start |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `AS` | 年度开始 | `BAS` | 工作日年度开始 |'
- en: 'Additionally, you can change the month used to mark any quarterly or annual
    code by adding a three-letter month code as a suffix:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以通过添加三个字母的月份代码作为后缀来更改用于标记任何季度或年度代码的月份：
- en: '`Q-JAN`, `BQ-FEB`, `QS-MAR`, `BQS-APR`, etc.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q-JAN`, `BQ-FEB`, `QS-MAR`, `BQS-APR`等。'
- en: '`A-JAN`, `BA-FEB`, `AS-MAR`, `BAS-APR`, etc.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A-JAN`, `BA-FEB`, `AS-MAR`, `BAS-APR`等。'
- en: 'In the same way, the split point of the weekly frequency can be modified by
    adding a three-letter weekday code: `W-SUN`, `W-MON`, `W-TUE`, `W-WED`, etc.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，周频率的分割点可以通过添加三个字母的工作日代码进行修改：`W-SUN`, `W-MON`, `W-TUE`, `W-WED`等。
- en: 'On top of this, codes can be combined with numbers to specify other frequencies.
    For example, for a frequency of 2 hours and 30 minutes, we can combine the hour
    (`H`) and minute (`T`) codes as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，代码可以与数字结合以指定其他频率。例如，对于2小时30分钟的频率，我们可以将小时(`H`)和分钟(`T`)代码组合如下：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'All of these short codes refer to specific instances of Pandas time series
    offsets, which can be found in the `pd.tseries.offsets` module. For example, we
    can create a business day offset directly as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些短代码都指向Pandas时间序列偏移的特定实例，这些可以在`pd.tseries.offsets`模块中找到。例如，我们可以直接创建工作日偏移量如下：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For more discussion of the use of frequencies and offsets, see the [`DateOffset`
    section](https://oreil.ly/J6JHA) of the Pandas documentation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多频率和偏移使用的讨论，请参阅Pandas文档的[`DateOffset`部分](https://oreil.ly/J6JHA)。
- en: Resampling, Shifting, and Windowing
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新采样、移位和窗口操作
- en: The ability to use dates and times as indices to intuitively organize and access
    data is an important aspect of the Pandas time series tools. The benefits of indexed
    data in general (automatic alignment during operations, intuitive data slicing
    and access, etc.) still apply, and Pandas provides several additional time series–specific
    operations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日期和时间作为索引以直观地组织和访问数据的能力是Pandas时间序列工具的重要组成部分。总体上索引数据的好处（在操作期间自动对齐，直观的数据切片和访问等）仍然适用，并且Pandas提供了几个额外的时间序列特定操作。
- en: 'We will take a look at a few of those here, using some stock price data as
    an example. Because Pandas was developed largely in a finance context, it includes
    some very specific tools for financial data. For example, the accompanying `pandas-datareader`
    package (installable via `pip install pandas-datareader`) knows how to import
    data from various online sources. Here we will load part of the S&P 500 price
    history:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一些股价数据为例，来看一些具体的内容。由于Pandas主要在金融环境中开发，因此它包含了一些非常具体的金融数据工具。例如，配套的`pandas-datareader`包（可通过`pip
    install pandas-datareader`安装）知道如何从各种在线源导入数据。这里我们将加载部分标准普尔500指数的价格历史：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For simplicity, we’ll use just the closing price:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 简单起见，我们将仅使用收盘价：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can visualize this using the `plot` method, after the normal Matplotlib setup
    boilerplate (see [Part IV](part04.xhtml#section-0400-introduction-to-matplotlib));
    the result is shown in [Figure 23-1](#fig_0311-working-with-time-series_files_in_output_68_0).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`plot`方法来可视化这一点，在正常的Matplotlib设置样板之后（参见[第四部分](part04.xhtml#section-0400-introduction-to-matplotlib)）；结果显示在[图 23-1](#fig_0311-working-with-time-series_files_in_output_68_0)中。
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![output 68 0](assets/output_68_0.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![output 68 0](assets/output_68_0.png)'
- en: Figure 23-1\. S&P500 closing price over time
  id: totrans-132
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 23-1\. 标准普尔500指数随时间变化的收盘价
- en: Resampling and Converting Frequencies
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新采样和转换频率
- en: One common need when dealing with time series data is resampling at a higher
    or lower frequency. This can be done using the `resample` method, or the much
    simpler `asfreq` method. The primary difference between the two is that `resample`
    is fundamentally a *data aggregation*, while `asfreq` is fundamentally a *data
    selection*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理时间序列数据时，一个常见的需求是在更高或更低的频率上重新采样。这可以使用`resample`方法完成，或者更简单的`asfreq`方法。两者之间的主要区别在于`resample`基本上是*数据聚合*，而`asfreq`基本上是*数据选择*。
- en: Let’s compare what the two return when we downsample the S&P 500 closing price
    data. Here we will resample the data at the end of business year; [Figure 23-2](#fig_0311-working-with-time-series_files_in_output_70_0)
    shows the result.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较当我们对标准普尔500指数的收盘价数据进行降采样时，这两者返回的结果。这里我们将数据重新采样到商业年度末；结果显示在[图 23-2](#fig_0311-working-with-time-series_files_in_output_70_0)中。
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![output 70 0](assets/output_70_0.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![output 70 0](assets/output_70_0.png)'
- en: Figure 23-2\. Resampling of S&P500 closing price
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 23-2\. 标准普尔500指数收盘价的重新采样
- en: 'Notice the difference: at each point, `resample` reports the *average of the
    previous year*, while `asfreq` reports the *value at the end of the year*.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意区别：在每个点上，`resample`报告的是*前一年的平均值*，而`asfreq`报告的是*年末的值*。
- en: For upsampling, `resample` and `asfreq` are largely equivalent, though `resample`
    has many more options available. In this case, the default for both methods is
    to leave the upsampled points empty; that is, filled with NA values. Like the
    `pd.fillna` function discussed in [Chapter 16](ch16.xhtml#section-0304-missing-values),
    `asfreq` accepts a `method` argument to specify how values are imputed. Here,
    we will resample the business day data at a daily frequency (i.e., including weekends);
    [Figure 23-3](#fig_0311-working-with-time-series_files_in_output_73_0) shows the
    result.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上采样，`resample`和`asfreq`基本上是等效的，尽管`resample`提供了更多的选项。在这种情况下，这两种方法的默认行为都是保留上采样点为空；即，填充为NA值。就像[第16章](ch16.xhtml#section-0304-missing-values)中讨论的`pd.fillna`函数一样，`asfreq`接受一个`method`参数来指定如何填补值。在这里，我们将业务日数据重新采样为每日频率（即包括周末）；[图 23-3](#fig_0311-working-with-time-series_files_in_output_73_0)显示了结果。
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![output 73 0](assets/output_73_0.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![output 73 0](assets/output_73_0.png)'
- en: Figure 23-3\. Comparison between forward-fill and back-fill interpolation
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 23-3\. 前向填充和后向填充插值的比较
- en: 'Because the S&P 500 data only exists for business days, the top panel has gaps
    representing NA values. The bottom panel shows the differences between two strategies
    for filling the gaps: forward filling and backward filling.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因为S&P 500数据仅存在于工作日，顶部面板中的空白表示NA值。底部面板显示了填补空白的两种策略之间的差异：前向填充和后向填充。
- en: Time Shifts
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间偏移
- en: Another common time series–specific operation is shifting of data in time. For
    this, Pandas provides the `shift` method, which can be used to shift data by a
    given number of entries. With time series data sampled at a regular frequency,
    this can give us a way to explore trends over time.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的时间序列特定操作是数据的时间偏移。为此，Pandas 提供了`shift`方法，可以将数据按给定的条目数进行偏移。对于以固定频率采样的时间序列数据，这可以为我们提供探索时间趋势的方法。
- en: For example, here we resample the data to daily values, and shift by 364 to
    compute the 1-year return on investment for the S&P 500 over time (see [Figure 23-4](#fig_0311-working-with-time-series_files_in_output_76_0)).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这里我们将数据重新采样为每日值，并将其向前偏移364天，以计算S&P 500的一年投资回报率（参见[图 23-4](#fig_0311-working-with-time-series_files_in_output_76_0)）。
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![output 76 0](assets/output_76_0.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![output 76 0](assets/output_76_0.png)'
- en: Figure 23-4\. Return on investment after one year
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 23-4\. 一年后的投资回报率
- en: The worst one-year return was around March 2019, with the coronavirus-related
    market crash exactly a year later. As you might expect, the best one-year return
    was to be found in March 2020, for those with enough foresight or luck to buy
    low.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最糟糕的一年回报率约为2019年3月，随后的一年发生了与冠状病毒相关的市场崩盘。正如你所预料的，最佳的一年回报率出现在2020年3月，对于那些有足够远见或运气购买低位的人来说。
- en: Rolling Windows
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滚动窗口
- en: Calculating rolling statistics is a third type of time series–specific operation
    implemented by Pandas. This can be accomplished via the `rolling` attribute of
    `Series` and `DataFrame` objects, which returns a view similar to what we saw
    with the `groupby` operation (see [Chapter 20](ch20.xhtml#section-0308-aggregation-and-grouping)).
    This rolling view makes available a number of aggregation operations by default.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 计算滚动统计数据是Pandas实现的第三种时间序列特定操作。这可以通过`Series`和`DataFrame`对象的`rolling`属性实现，它返回一个类似于`groupby`操作所见的视图（参见[第20章](ch20.xhtml#section-0308-aggregation-and-grouping)）。
- en: For example, we can look at the one-year centered rolling mean and standard
    deviation of the stock prices (see [Figure 23-5](#fig_0311-working-with-time-series_files_in_output_80_0)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以查看股票价格的一年居中滚动均值和标准差（参见[图 23-5](#fig_0311-working-with-time-series_files_in_output_80_0)）。
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![output 80 0](assets/output_80_0.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![output 80 0](assets/output_80_0.png)'
- en: Figure 23-5\. Rolling statistics on S&P500 index
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 23-5\. S&P500指数的滚动统计数据
- en: As with `groupby` operations, the `aggregate` and `apply` methods can be used
    for custom rolling computations.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与`groupby`操作一样，`aggregate`和`apply`方法可以用于自定义滚动计算。
- en: 'Example: Visualizing Seattle Bicycle Counts'
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例：可视化西雅图自行车计数
- en: As a more involved example of working with time series data, let’s take a look
    at bicycle counts on Seattle’s [Fremont Bridge](https://oreil.ly/6qVBt). This
    data comes from an automated bicycle counter installed in late 2012, which has
    inductive sensors on the east and west sidewalks of the bridge. The hourly bicycle
    counts can be downloaded from [*http://data.seattle.gov*](http://data.seattle.gov);
    the Fremont Bridge Bicycle Counter dataset is available under the Transportation
    category.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 作为处理时间序列数据的更深入的例子，让我们来看看西雅图[Fremont Bridge](https://oreil.ly/6qVBt)的自行车计数。这些数据来自于2012年底安装的自动自行车计数器，该计数器在桥的东西侧人行道上有感应传感器。小时自行车计数可从[*http://data.seattle.gov*](http://data.seattle.gov)下载；Fremont
    Bridge自行车计数数据集在交通类别下可用。
- en: 'The CSV used for this book can be downloaded as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 用于本书的CSV可以按以下方式下载：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once this dataset is downloaded, we can use Pandas to read the CSV output into
    a `DataFrame`. We will specify that we want the `Date` column as an index, and
    we want these dates to be automatically parsed:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 下载了这个数据集之后，我们可以使用Pandas将CSV输出读入`DataFrame`。我们将指定`Date`列作为索引，并希望这些日期能够自动解析：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For convenience, we’ll shorten the column names:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们将缩短列名：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now let’s take a look at the summary statistics for this data:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看这些数据的摘要统计信息：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Visualizing the Data
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据可视化
- en: We can gain some insight into the dataset by visualizing it. Let’s start by
    plotting the raw data (see [Figure 23-6](#fig_0311-working-with-time-series_files_in_output_92_0)).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过可视化数据集来获得一些见解。让我们首先绘制原始数据（见[图 23-6](#fig_0311-working-with-time-series_files_in_output_92_0)）。
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![output 92 0](assets/output_92_0.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![output 92 0](assets/output_92_0.png)'
- en: Figure 23-6\. Hourly bicycle counts on Seattle’s Fremont Bridge
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 23-6\. 西雅图Fremont Bridge的小时自行车计数
- en: The ~150,000 hourly samples are far too dense for us to make much sense of.
    We can gain more insight by resampling the data to a coarser grid. Let’s resample
    by week (see [Figure 23-7](#fig_0311-working-with-time-series_files_in_output_94_0)).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ~150,000小时样本过于密集，我们无法理解太多内容。我们可以通过将数据重新采样到更粗的网格来获得更多见解。让我们按周重新采样（见[图 23-7](#fig_0311-working-with-time-series_files_in_output_94_0)）。
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This reveals some trends: as you might expect, people bicycle more in the summer
    than in the winter, and even within a particular season the bicycle use varies
    from week to week (likely dependent on weather; see [Chapter 42](ch42.xhtml#section-0506-linear-regression),
    where we explore this further). Further, the effect of the COVID-19 pandemic on
    commuting patterns is quite clear, starting in early 2020.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这揭示了一些趋势：正如你所预料的，夏季人们骑自行车的次数比冬季多，即使在特定季节内，自行车使用量也会随着周而变化（可能取决于天气；参见[第42章](ch42.xhtml#section-0506-linear-regression)，我们将进一步探讨这一点）。此外，COVID-19大流行对通勤模式的影响非常明显，始于2020年初。
- en: '![output 94 0](assets/output_94_0.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![output 94 0](assets/output_94_0.png)'
- en: Figure 23-7\. Weekly bicycle crossings of Seattle’s Fremont Bridge
  id: totrans-178
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 23-7\. 西雅图Fremont Bridge每周自行车过桥次数
- en: Another option that comes in handy for aggregating the data is to use a rolling
    mean, utilizing the `pd.rolling_mean` function. Here we’ll examine the 30-day
    rolling mean of our data, making sure to center the window (see [Figure 23-8](#fig_0311-working-with-time-series_files_in_output_96_0)).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个处理数据聚合的便捷选项是使用滚动均值，利用`pd.rolling_mean`函数。在这里，我们将研究数据的30天滚动均值，确保窗口居中（见[图 23-8](#fig_0311-working-with-time-series_files_in_output_96_0)）。
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![output 96 0](assets/output_96_0.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![output 96 0](assets/output_96_0.png)'
- en: Figure 23-8\. Rolling mean of weekly bicycle counts
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 23-8\. 每周自行车计数的滚动均值
- en: 'The jaggedness of the result is due to the hard cutoff of the window. We can
    get a smoother version of a rolling mean using a window function—for example,
    a Gaussian window, as shown in [Figure 23-9](#fig_0311-working-with-time-series_files_in_output_98_0).
    The following code specifies both the width of the window (here, 50 days) and
    the width of the Gaussian window (here, 10 days):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的不平滑是由于窗口的硬截断造成的。我们可以使用窗口函数来获得更平滑的滚动均值，例如，使用高斯窗口，如[图 23-9](#fig_0311-working-with-time-series_files_in_output_98_0)所示。以下代码指定了窗口的宽度（这里是50天）和高斯窗口的宽度（这里是10天）：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![output 98 0](assets/output_98_0.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![output 98 0](assets/output_98_0.png)'
- en: Figure 23-9\. Gaussian smoothed weekly bicycle counts
  id: totrans-186
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 23-9\. 高斯平滑后的每周自行车计数
- en: Digging into the Data
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入数据
- en: While these smoothed data views are useful to get an idea of the general trend
    in the data, they hide much of the structure. For example, we might want to look
    at the average traffic as a function of the time of day. We can do this using
    the `groupby` functionality discussed in [Chapter 20](ch20.xhtml#section-0308-aggregation-and-grouping)
    (see [Figure 23-10](#fig_0311-working-with-time-series_files_in_output_100_0)).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些平滑的数据视图有助于了解数据的一般趋势，但它们隐藏了很多结构。例如，我们可能想要查看平均交通量随时间变化的情况。我们可以使用[第 20 章](ch20.xhtml#section-0308-aggregation-and-grouping)中讨论的`groupby`功能来实现这一点（见[图 23-10](#fig_0311-working-with-time-series_files_in_output_100_0)）。
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![output 100 0](assets/output_100_0.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![output 100 0](assets/output_100_0.png)'
- en: Figure 23-10\. Average hourly bicycle counts
  id: totrans-191
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 23-10\. 平均每小时自行车计数
- en: 'The hourly traffic is a strongly bimodal sequence, with peaks around 8:00 a.m.
    and 5:00 p.m. This is likely evidence of a strong component of commuter traffic
    crossing the bridge. There is a directional component as well: according to the
    data, the east sidewalk is used more during the a.m. commute, and the west sidewalk
    is used more during the p.m. commute.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每小时的交通量呈现出明显的双峰分布，大约在上午 8 点和下午 5 点左右。这很可能是通勤交通的强烈组成部分的证据。还有一个方向性的组成部分：根据数据显示，东侧人行道在上午通勤时段更多被使用，而西侧人行道在下午通勤时段更多被使用。
- en: We also might be curious about how things change based on the day of the week.
    Again, we can do this with a simple `groupby` (see [Figure 23-11](#fig_0311-working-with-time-series_files_in_output_102_0)).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也许会对一周中不同日期的情况有所好奇。同样，我们可以通过简单的`groupby`（见[图 23-11](#fig_0311-working-with-time-series_files_in_output_102_0)）来做到这一点。
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![output 102 0](assets/output_102_0.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![output 102 0](assets/output_102_0.png)'
- en: Figure 23-11\. Average daily bicycle counts
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 23-11\. 平均每日自行车计数
- en: This shows a strong distinction between weekday and weekend totals, with around
    twice as many average riders crossing the bridge on Monday through Friday than
    on Saturday and Sunday.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了工作日和周末之间的明显区别，工作日每天穿过桥的平均骑行者大约是周六和周日的两倍。
- en: 'With this in mind, let’s do a compound `groupby` and look at the hourly trends
    on weekdays versus weekends. We’ll start by grouping by flags marking the weekend
    and the time of day:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴此，让我们进行复合`groupby`，并查看工作日与周末的小时趋势。我们将首先按周末标志和时间段进行分组：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now we’ll use some of the Matplotlib tools that will be described in [Chapter 31](ch31.xhtml#section-0408-multiple-subplots)
    to plot two panels side by side, as shown in [Figure 23-12](#fig_0311-working-with-time-series_files_in_output_106_0).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用一些Matplotlib工具，这些工具将在[第 31 章](ch31.xhtml#section-0408-multiple-subplots)中进行描述，以便将两个面板并排绘制，如[图 23-12](#fig_0311-working-with-time-series_files_in_output_106_0)所示。
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![output 106 0](assets/output_106_0.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![output 106 0](assets/output_106_0.png)'
- en: Figure 23-12\. Average hourly bicycle counts by weekday and weekend
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 23-12\. 每小时平均自行车计数（按工作日和周末划分）
- en: The result shows a bimodal commuting pattern during the work week, and a unimodal
    recreational pattern during the weekends. It might be interesting to dig through
    this data in more detail and examine the effects of weather, temperature, time
    of year, and other factors on people’s commuting patterns; for further discussion,
    see my blog post [“Is Seattle Really Seeing an Uptick in Cycling?”](https://oreil.ly/j5oEI),
    which uses a subset of this data. We will also revisit this dataset in the context
    of modeling in [Chapter 42](ch42.xhtml#section-0506-linear-regression).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示了工作日的双峰通勤模式和周末的单峰休闲模式。深入挖掘这些数据并详细分析天气、温度、年份和其他因素对人们通勤模式的影响可能会很有趣；有关详细讨论，请参阅我的博客文章[《西雅图真的看到了自行车使用率的上升吗？》](https://oreil.ly/j5oEI)，该文章使用了这些数据的子集。我们还将在[第 42
    章](ch42.xhtml#section-0506-linear-regression)中探讨这些数据集的建模背景。
