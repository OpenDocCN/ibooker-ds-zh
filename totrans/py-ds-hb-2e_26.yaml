- en: Chapter 23\. Working with Time Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pandas was originally developed in the context of financial modeling, so as
    you might expect, it contains an extensive set of tools for working with dates,
    times, and time-indexed data. Date and time data comes in a few flavors, which
    we will discuss here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Timestamps*'
  prefs: []
  type: TYPE_NORMAL
- en: Particular moments in time (e.g., July 4, 2021 at 7:00 a.m.).
  prefs: []
  type: TYPE_NORMAL
- en: '*Time intervals* and *periods*'
  prefs: []
  type: TYPE_NORMAL
- en: A length of time between a particular beginning and end point; for example,
    the month of June 2021. Periods usually reference a special case of time intervals
    in which each interval is of uniform length and does not overlap (e.g., 24-hour-long
    periods comprising days).
  prefs: []
  type: TYPE_NORMAL
- en: '*Time deltas* or *durations*'
  prefs: []
  type: TYPE_NORMAL
- en: An exact length of time (e.g., a duration of 22.56 seconds).
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will introduce how to work with each of these types of date/time
    data in Pandas. This is by no means a complete guide to the time series tools
    available in Python or Pandas, but instead is intended as a broad overview of
    how you as a user should approach working with time series. We will start with
    a brief discussion of tools for dealing with dates and times in Python, before
    moving more specifically to a discussion of the tools provided by Pandas. Finally,
    we will review some short examples of working with time series data in Pandas.
  prefs: []
  type: TYPE_NORMAL
- en: Dates and Times in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python world has a number of available representations of dates, times,
    deltas, and time spans. While the time series tools provided by Pandas tend to
    be the most useful for data science applications, it is helpful to see their relationship
    to other tools used in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Native Python Dates and Times: datetime and dateutil'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python’s basic objects for working with dates and times reside in the built-in
    `datetime` module. Along with the third-party `dateutil` module, you can use this
    to quickly perform a host of useful functionalities on dates and times. For example,
    you can manually build a date using the `datetime` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, using the `dateutil` module, you can parse dates from a variety of string
    formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have a `datetime` object, you can do things like printing the day
    of the week:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we’ve used one of the standard string format codes for printing dates
    (`''%A''`), which you can read about in the [`strftime` section](https://oreil.ly/bjdsf)
    of Python’s [`datetime` documentation](https://oreil.ly/AGVR9). Documentation
    of other useful date utilities can be found in [`dateutil`’s online documentation](https://oreil.ly/Y5Rwd).
    A related package to be aware of is [`pytz`](https://oreil.ly/DU9Jr), which contains
    tools for working with the most migraine-inducing element of time series data:
    time zones.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The power of `datetime` and `dateutil` lies in their flexibility and easy syntax:
    you can use these objects and their built-in methods to easily perform nearly
    any operation you might be interested in. Where they break down is when you wish
    to work with large arrays of dates and times: just as lists of Python numerical
    variables are suboptimal compared to NumPy-style typed numerical arrays, lists
    of Python `datetime` objects are suboptimal compared to typed arrays of encoded
    dates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typed Arrays of Times: NumPy’s datetime64'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NumPy’s `datetime64` dtype encodes dates as 64-bit integers, and thus allows
    arrays of dates to be represented compactly and operated on in an efficient manner.
    The `datetime64` requires a specific input format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have dates in this form, we can quickly do vectorized operations on
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Because of the uniform type in NumPy `datetime64` arrays, this kind of operation
    can be accomplished much more quickly than if we were working directly with Python’s
    `datetime` objects, especially as arrays get large (we introduced this type of
    vectorization in [Chapter 6](ch06.xhtml#section-0203-computation-on-arrays-ufuncs)).
  prefs: []
  type: TYPE_NORMAL
- en: One detail of the `datetime64` and related `timedelta64` objects is that they
    are built on a *fundamental time unit*. Because the `datetime64` object is limited
    to 64-bit precision, the range of encodable times is <math alttext="2 Superscript
    64"><msup><mn>2</mn> <mn>64</mn></msup></math> times this fundamental unit. In
    other words, `datetime64` imposes a trade-off between *time resolution* and *maximum
    time span*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want a time resolution of 1 nanosecond, you only have enough
    information to encode a range of <math alttext="2 Superscript 64"><msup><mn>2</mn>
    <mn>64</mn></msup></math> nanoseconds, or just under 600 years. NumPy will infer
    the desired unit from the input; for example, here is a day-based `datetime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a minute-based datetime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can force any desired fundamental unit using one of many format codes;
    for example, here we’ll force a nanosecond-based time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 23-1](#table-23-1), drawn from the NumPy `datetime64` documentation,
    lists the available format codes along with the relative and absolute time spans
    that they can encode.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 23-1\. Description of date and time codes
  prefs: []
  type: TYPE_NORMAL
- en: '| Code | Meaning | Time span (relative) | Time span (absolute) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Y` | Year | ± 9.2e18 years | [9.2e18 BC, 9.2e18 AD] |'
  prefs: []
  type: TYPE_TB
- en: '| `M` | Month | ± 7.6e17 years | [7.6e17 BC, 7.6e17 AD] |'
  prefs: []
  type: TYPE_TB
- en: '| `W` | Week | ± 1.7e17 years | [1.7e17 BC, 1.7e17 AD] |'
  prefs: []
  type: TYPE_TB
- en: '| `D` | Day | ± 2.5e16 years | [2.5e16 BC, 2.5e16 AD] |'
  prefs: []
  type: TYPE_TB
- en: '| `h` | Hour | ± 1.0e15 years | [1.0e15 BC, 1.0e15 AD] |'
  prefs: []
  type: TYPE_TB
- en: '| `m` | Minute | ± 1.7e13 years | [1.7e13 BC, 1.7e13 AD] |'
  prefs: []
  type: TYPE_TB
- en: '| `s` | Second | ± 2.9e12 years | [ 2.9e9 BC, 2.9e9 AD] |'
  prefs: []
  type: TYPE_TB
- en: '| `ms` | Millisecond | ± 2.9e9 years | [ 2.9e6 BC, 2.9e6 AD] |'
  prefs: []
  type: TYPE_TB
- en: '| `us` | Microsecond | ± 2.9e6 years | [290301 BC, 294241 AD] |'
  prefs: []
  type: TYPE_TB
- en: '| `ns` | Nanosecond | ± 292 years | [ 1678 AD, 2262 AD] |'
  prefs: []
  type: TYPE_TB
- en: '| `ps` | Picosecond | ± 106 days | [ 1969 AD, 1970 AD] |'
  prefs: []
  type: TYPE_TB
- en: '| `fs` | Femtosecond | ± 2.6 hours | [ 1969 AD, 1970 AD] |'
  prefs: []
  type: TYPE_TB
- en: '| `as` | Attosecond | ± 9.2 seconds | [ 1969 AD, 1970 AD] |'
  prefs: []
  type: TYPE_TB
- en: For the types of data we see in the real world, a useful default is `datetime64[ns]`,
    as it can encode a useful range of modern dates with a suitably fine precision.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, note that while the `datetime64` data type addresses some of the deficiencies
    of the built-in Python `datetime` type, it lacks many of the convenient methods
    and functions provided by `datetime` and especially `dateutil`. More information
    can be found in [NumPy’s `datetime64` documentation](https://oreil.ly/XDbck).
  prefs: []
  type: TYPE_NORMAL
- en: 'Dates and Times in Pandas: The Best of Both Worlds'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pandas builds upon all the tools just discussed to provide a `Timestamp` object,
    which combines the ease of use of `datetime` and `dateutil` with the efficient
    storage and vectorized interface of `numpy.datetime64`. From a group of these
    `Timestamp` objects, Pandas can construct a `DatetimeIndex` that can be used to
    index data in a `Series` or `DataFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can use Pandas tools to repeat the demonstration from earlier.
    We can parse a flexibly formatted string date and use format codes to output the
    day of the week, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we can do NumPy-style vectorized operations directly on this
    same object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will take a closer look at manipulating time series
    data with the tools provided by Pandas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pandas Time Series: Indexing by Time'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Pandas time series tools really become useful when you begin to index data
    by timestamps. For example, we can construct a `Series` object that has time-indexed
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And now that we have this data in a `Series`, we can make use of any of the
    `Series` indexing patterns we discussed in previous chapters, passing values that
    can be coerced into dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There are additional special date-only indexing operations, such as passing
    a year to obtain a slice of all data from that year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Later, we will see additional examples of the convenience of dates-as-indices.
    But first, let’s take a closer look at the available time series data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Pandas Time Series Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section will introduce the fundamental Pandas data structures for working
    with time series data:'
  prefs: []
  type: TYPE_NORMAL
- en: For *timestamps*, Pandas provides the `Timestamp` type. As mentioned before,
    this is essentially a replacement for Python’s native `datetime`, but it’s based
    on the more efficient `numpy.datetime64` data type. The associated `Index` structure
    is `DatetimeIndex`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For *time periods*, Pandas provides the `Period` type. This encodes a fixed-frequency
    interval based on `numpy.datetime64`. The associated index structure is `PeriodIndex`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For *time deltas* or *durations*, Pandas provides the `Timedelta` type. `Timedelta`
    is a more efficient replacement for Python’s native `datetime.timedelta` type,
    and is based on `numpy.timedelta64`. The associated index structure is `TimedeltaIndex`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most fundamental of these date/time objects are the `Timestamp` and `Datetime​In⁠dex`
    objects. While these class objects can be invoked directly, it is more common
    to use the `pd.to_datetime` function, which can parse a wide variety of formats.
    Passing a single date to `pd.to_datetime` yields a `Timestamp`; passing a series
    of dates by default yields a `DatetimeIndex`, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Any `DatetimeIndex` can be converted to a `PeriodIndex` with the `to_period`
    function, with the addition of a frequency code; here we’ll use `''D''` to indicate
    daily frequency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A `TimedeltaIndex` is created, for example, when a date is subtracted from
    another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Regular Sequences: pd.date_range'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make creation of regular date sequences more convenient, Pandas offers a
    few functions for this purpose: `pd.date_range` for timestamps, `pd.period_range`
    for periods, and `pd.timedelta_range` for time deltas. We’ve seen that Python’s
    `range` and NumPy’s `np.arange` take a start point, end point, and optional step
    size and return a sequence. Similarly, `pd.date_range` accepts a start date, an
    end date, and an optional frequency code to create a regular sequence of dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, the date range can be specified not with a start and end point,
    but with a start point and a number of periods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The spacing can be modified by altering the `freq` argument, which defaults
    to `D`. For example, here we construct a range of hourly timestamps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To create regular sequences of `Period` or `Timedelta` values, the similar
    `pd.period_range` and `pd.timedelta_range` functions are useful. Here are some
    monthly periods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And a sequence of durations increasing by an hour:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: All of these require an understanding of Pandas frequency codes, which are summarized
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Frequencies and Offsets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fundamental to these Pandas time series tools is the concept of a *frequency*
    or *date offset*. The following table summarizes the main codes available; as
    with the `D` (day) and `H` (hour) codes demonstrated in the previous sections,
    we can use these to specify any desired frequency spacing. [Table 23-2](#table-23-2)
    summarizes the main codes available.
  prefs: []
  type: TYPE_NORMAL
- en: Table 23-2\. Listing of Pandas frequency codes
  prefs: []
  type: TYPE_NORMAL
- en: '| Code | Description | Code | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `D` | Calendar day | `B` | Business day |'
  prefs: []
  type: TYPE_TB
- en: '| `W` | Weekly |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `M` | Month end | `BM` | Business month end |'
  prefs: []
  type: TYPE_TB
- en: '| `Q` | Quarter end | `BQ` | Business quarter end |'
  prefs: []
  type: TYPE_TB
- en: '| `A` | Year end | `BA` | Business year end |'
  prefs: []
  type: TYPE_TB
- en: '| `H` | Hours | `BH` | Business hours |'
  prefs: []
  type: TYPE_TB
- en: '| `T` | Minutes |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `S` | Seconds |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `L` | Milliseconds |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `U` | Microseconds |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `N` | Nanoseconds |  |  |'
  prefs: []
  type: TYPE_TB
- en: The monthly, quarterly, and annual frequencies are all marked at the end of
    the specified period. Adding an `S` suffix to any of these causes them to instead
    be marked at the beginning (see [Table 23-3](#table-23-3)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 23-3\. Listing of start-indexed frequency codes
  prefs: []
  type: TYPE_NORMAL
- en: '| Code | Description | Code | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `MS` | Month start | `BMS` | Business month start |'
  prefs: []
  type: TYPE_TB
- en: '| `QS` | Quarter start | `BQS` | Business quarter start |'
  prefs: []
  type: TYPE_TB
- en: '| `AS` | Year start | `BAS` | Business year start |'
  prefs: []
  type: TYPE_TB
- en: 'Additionally, you can change the month used to mark any quarterly or annual
    code by adding a three-letter month code as a suffix:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Q-JAN`, `BQ-FEB`, `QS-MAR`, `BQS-APR`, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A-JAN`, `BA-FEB`, `AS-MAR`, `BAS-APR`, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the same way, the split point of the weekly frequency can be modified by
    adding a three-letter weekday code: `W-SUN`, `W-MON`, `W-TUE`, `W-WED`, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of this, codes can be combined with numbers to specify other frequencies.
    For example, for a frequency of 2 hours and 30 minutes, we can combine the hour
    (`H`) and minute (`T`) codes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'All of these short codes refer to specific instances of Pandas time series
    offsets, which can be found in the `pd.tseries.offsets` module. For example, we
    can create a business day offset directly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: For more discussion of the use of frequencies and offsets, see the [`DateOffset`
    section](https://oreil.ly/J6JHA) of the Pandas documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Resampling, Shifting, and Windowing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to use dates and times as indices to intuitively organize and access
    data is an important aspect of the Pandas time series tools. The benefits of indexed
    data in general (automatic alignment during operations, intuitive data slicing
    and access, etc.) still apply, and Pandas provides several additional time series–specific
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will take a look at a few of those here, using some stock price data as
    an example. Because Pandas was developed largely in a finance context, it includes
    some very specific tools for financial data. For example, the accompanying `pandas-datareader`
    package (installable via `pip install pandas-datareader`) knows how to import
    data from various online sources. Here we will load part of the S&P 500 price
    history:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'For simplicity, we’ll use just the closing price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can visualize this using the `plot` method, after the normal Matplotlib setup
    boilerplate (see [Part IV](part04.xhtml#section-0400-introduction-to-matplotlib));
    the result is shown in [Figure 23-1](#fig_0311-working-with-time-series_files_in_output_68_0).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![output 68 0](assets/output_68_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-1\. S&P500 closing price over time
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Resampling and Converting Frequencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One common need when dealing with time series data is resampling at a higher
    or lower frequency. This can be done using the `resample` method, or the much
    simpler `asfreq` method. The primary difference between the two is that `resample`
    is fundamentally a *data aggregation*, while `asfreq` is fundamentally a *data
    selection*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s compare what the two return when we downsample the S&P 500 closing price
    data. Here we will resample the data at the end of business year; [Figure 23-2](#fig_0311-working-with-time-series_files_in_output_70_0)
    shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![output 70 0](assets/output_70_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-2\. Resampling of S&P500 closing price
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Notice the difference: at each point, `resample` reports the *average of the
    previous year*, while `asfreq` reports the *value at the end of the year*.'
  prefs: []
  type: TYPE_NORMAL
- en: For upsampling, `resample` and `asfreq` are largely equivalent, though `resample`
    has many more options available. In this case, the default for both methods is
    to leave the upsampled points empty; that is, filled with NA values. Like the
    `pd.fillna` function discussed in [Chapter 16](ch16.xhtml#section-0304-missing-values),
    `asfreq` accepts a `method` argument to specify how values are imputed. Here,
    we will resample the business day data at a daily frequency (i.e., including weekends);
    [Figure 23-3](#fig_0311-working-with-time-series_files_in_output_73_0) shows the
    result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![output 73 0](assets/output_73_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-3\. Comparison between forward-fill and back-fill interpolation
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Because the S&P 500 data only exists for business days, the top panel has gaps
    representing NA values. The bottom panel shows the differences between two strategies
    for filling the gaps: forward filling and backward filling.'
  prefs: []
  type: TYPE_NORMAL
- en: Time Shifts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another common time series–specific operation is shifting of data in time. For
    this, Pandas provides the `shift` method, which can be used to shift data by a
    given number of entries. With time series data sampled at a regular frequency,
    this can give us a way to explore trends over time.
  prefs: []
  type: TYPE_NORMAL
- en: For example, here we resample the data to daily values, and shift by 364 to
    compute the 1-year return on investment for the S&P 500 over time (see [Figure 23-4](#fig_0311-working-with-time-series_files_in_output_76_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![output 76 0](assets/output_76_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-4\. Return on investment after one year
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The worst one-year return was around March 2019, with the coronavirus-related
    market crash exactly a year later. As you might expect, the best one-year return
    was to be found in March 2020, for those with enough foresight or luck to buy
    low.
  prefs: []
  type: TYPE_NORMAL
- en: Rolling Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Calculating rolling statistics is a third type of time series–specific operation
    implemented by Pandas. This can be accomplished via the `rolling` attribute of
    `Series` and `DataFrame` objects, which returns a view similar to what we saw
    with the `groupby` operation (see [Chapter 20](ch20.xhtml#section-0308-aggregation-and-grouping)).
    This rolling view makes available a number of aggregation operations by default.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can look at the one-year centered rolling mean and standard
    deviation of the stock prices (see [Figure 23-5](#fig_0311-working-with-time-series_files_in_output_80_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![output 80 0](assets/output_80_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-5\. Rolling statistics on S&P500 index
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As with `groupby` operations, the `aggregate` and `apply` methods can be used
    for custom rolling computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Visualizing Seattle Bicycle Counts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a more involved example of working with time series data, let’s take a look
    at bicycle counts on Seattle’s [Fremont Bridge](https://oreil.ly/6qVBt). This
    data comes from an automated bicycle counter installed in late 2012, which has
    inductive sensors on the east and west sidewalks of the bridge. The hourly bicycle
    counts can be downloaded from [*http://data.seattle.gov*](http://data.seattle.gov);
    the Fremont Bridge Bicycle Counter dataset is available under the Transportation
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CSV used for this book can be downloaded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this dataset is downloaded, we can use Pandas to read the CSV output into
    a `DataFrame`. We will specify that we want the `Date` column as an index, and
    we want these dates to be automatically parsed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience, we’ll shorten the column names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s take a look at the summary statistics for this data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Visualizing the Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can gain some insight into the dataset by visualizing it. Let’s start by
    plotting the raw data (see [Figure 23-6](#fig_0311-working-with-time-series_files_in_output_92_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![output 92 0](assets/output_92_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-6\. Hourly bicycle counts on Seattle’s Fremont Bridge
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The ~150,000 hourly samples are far too dense for us to make much sense of.
    We can gain more insight by resampling the data to a coarser grid. Let’s resample
    by week (see [Figure 23-7](#fig_0311-working-with-time-series_files_in_output_94_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This reveals some trends: as you might expect, people bicycle more in the summer
    than in the winter, and even within a particular season the bicycle use varies
    from week to week (likely dependent on weather; see [Chapter 42](ch42.xhtml#section-0506-linear-regression),
    where we explore this further). Further, the effect of the COVID-19 pandemic on
    commuting patterns is quite clear, starting in early 2020.'
  prefs: []
  type: TYPE_NORMAL
- en: '![output 94 0](assets/output_94_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-7\. Weekly bicycle crossings of Seattle’s Fremont Bridge
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Another option that comes in handy for aggregating the data is to use a rolling
    mean, utilizing the `pd.rolling_mean` function. Here we’ll examine the 30-day
    rolling mean of our data, making sure to center the window (see [Figure 23-8](#fig_0311-working-with-time-series_files_in_output_96_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![output 96 0](assets/output_96_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-8\. Rolling mean of weekly bicycle counts
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The jaggedness of the result is due to the hard cutoff of the window. We can
    get a smoother version of a rolling mean using a window function—for example,
    a Gaussian window, as shown in [Figure 23-9](#fig_0311-working-with-time-series_files_in_output_98_0).
    The following code specifies both the width of the window (here, 50 days) and
    the width of the Gaussian window (here, 10 days):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '![output 98 0](assets/output_98_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-9\. Gaussian smoothed weekly bicycle counts
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Digging into the Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While these smoothed data views are useful to get an idea of the general trend
    in the data, they hide much of the structure. For example, we might want to look
    at the average traffic as a function of the time of day. We can do this using
    the `groupby` functionality discussed in [Chapter 20](ch20.xhtml#section-0308-aggregation-and-grouping)
    (see [Figure 23-10](#fig_0311-working-with-time-series_files_in_output_100_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '![output 100 0](assets/output_100_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-10\. Average hourly bicycle counts
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The hourly traffic is a strongly bimodal sequence, with peaks around 8:00 a.m.
    and 5:00 p.m. This is likely evidence of a strong component of commuter traffic
    crossing the bridge. There is a directional component as well: according to the
    data, the east sidewalk is used more during the a.m. commute, and the west sidewalk
    is used more during the p.m. commute.'
  prefs: []
  type: TYPE_NORMAL
- en: We also might be curious about how things change based on the day of the week.
    Again, we can do this with a simple `groupby` (see [Figure 23-11](#fig_0311-working-with-time-series_files_in_output_102_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![output 102 0](assets/output_102_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-11\. Average daily bicycle counts
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This shows a strong distinction between weekday and weekend totals, with around
    twice as many average riders crossing the bridge on Monday through Friday than
    on Saturday and Sunday.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, let’s do a compound `groupby` and look at the hourly trends
    on weekdays versus weekends. We’ll start by grouping by flags marking the weekend
    and the time of day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now we’ll use some of the Matplotlib tools that will be described in [Chapter 31](ch31.xhtml#section-0408-multiple-subplots)
    to plot two panels side by side, as shown in [Figure 23-12](#fig_0311-working-with-time-series_files_in_output_106_0).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![output 106 0](assets/output_106_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-12\. Average hourly bicycle counts by weekday and weekend
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The result shows a bimodal commuting pattern during the work week, and a unimodal
    recreational pattern during the weekends. It might be interesting to dig through
    this data in more detail and examine the effects of weather, temperature, time
    of year, and other factors on people’s commuting patterns; for further discussion,
    see my blog post [“Is Seattle Really Seeing an Uptick in Cycling?”](https://oreil.ly/j5oEI),
    which uses a subset of this data. We will also revisit this dataset in the context
    of modeling in [Chapter 42](ch42.xhtml#section-0506-linear-regression).
  prefs: []
  type: TYPE_NORMAL
