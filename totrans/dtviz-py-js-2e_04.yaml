- en: Chapter 2\. A Language-Learning Bridge Between Python and JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Probably the most ambitious aspect of this book is that it deals with two programming
    languages. Moreover, it only requires that you are competent in one of these languages.
    This is only possible because Python and JavaScript (JS) are fairly simple languages
    with much in common. The aim of this chapter is to draw out those commonalities
    and use them to make a learning bridge between the two languages such that core
    skills acquired in one can easily be applied to the other.
  prefs: []
  type: TYPE_NORMAL
- en: After showing the key similarities and differences between the two languages,
    I’ll show how to set up a learning environment for Python and JS. The bulk of
    the chapter will then deal with core syntactical and conceptual differences, followed
    by a selection of patterns and idioms that I use often while doing data visualization
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Similarities and Differences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Syntax differences aside, Python and JavaScript actually have a lot in common.
    After a short while, switching between them can be almost seamless.^([1](ch02.xhtml#idm45607814867312))
    Let’s compare the two from a data visualizer’s perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the chief similarities:'
  prefs: []
  type: TYPE_NORMAL
- en: They both work without needing a compilation step (i.e., they are interpreted).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use both with an interactive interpreter, which means you can type in
    lines of code and see the results right away.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both have [garbage collection](https://oreil.ly/3QDQA), which means they manage
    program memory automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neither language has header files, package boilerplate, and so on, as compared
    to languages like C++, Java, etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both can happily be developed with a text editor or lightweight IDE.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both, functions are first-class citizens, which can be passed as arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the key differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Possibly the biggest difference is that JavaScript is [single-threaded and non-blocking](https://oreil.ly/Ja0FW),
    using asynchronous I/O. This means that simple things like file access involve
    the use of a [callback function](https://oreil.ly/L9DA5), passed to another function
    and called on completion of some code, usually asynchronously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JS is used essentially in web development and until relatively recently was
    browser-bound,^([2](ch02.xhtml#idm45607814847776)) but Python is used almost everywhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JS is the only first-class language in web browsers, Python being excluded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python has a comprehensive standard library, whereas JS has a limited set of
    utility objects (e.g., JSON, Math).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python has fairly classical object-oriented classes, whereas JS uses prototype
    objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JS lacks heavyweight general-purpose data-processing libs.^([3](ch02.xhtml#idm45607814841712))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The differences here emphasize the need for this book to be bilingual. The JavaScript
    monopoly on browser dataviz needs the complement of a conventional data-processing
    stack. And Python has the best there is.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the great advantages of Python and JavaScript is that because they are
    interpreted on the fly, you can interact with them. Python’s interpreter can be
    run from the command line, whereas JavaScript’s is generally accessed from the
    web browser through a console, usually available from the built-in development
    tools. In this section, we’ll see how to fire up a session with the interpreter
    and start trying out your code.
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By far, the best command-line Python interpreter is [IPython](https://ipython.org),
    which comes in three shades: the basic terminal version, an enhanced graphical
    version, and a browser-based notebook. Since IPython version 4.0, the latter two
    have been spun out into project [Jupyter](https://jupyter.org). The Jupyter notebook
    is a rather brilliant and fairly recent innovation, providing a browser-based
    interactive computational environment. The great boon of the notebook is session
    persistence and the possibility of web access.^([4](ch02.xhtml#idm45607814829968))
    The ease with which one can share programming sessions, complete with embedded
    data visualizations, makes the notebook a fantastic teaching tool as well as a
    great way to recover programming context. That’s why the Python chapters of this
    book have accompanying Jupyter notebooks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start a Jupyter notebook just run `jupyter` at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then open a browser tab at the URL specified (*http://localhost:8888* in this
    case) and start reading or writing Python notebooks.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are lots of options for trying out JavaScript code without starting a
    server, though the latter isn’t that difficult. Because the JavaScript interpreter
    comes embedded in all modern web browsers, there are a number of sites that let
    you try out bits of JavaScript along with HTML and CSS and see the results. [CodePen](https://oreil.ly/ZtROX)
    is a good option. These sites are great for sharing code and trying out snippets,
    and usually allow you to add libraries such as *D3.js* with a few mouse-clicks.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to try out code one-liners or quiz the state of live code, browser-based
    consoles are your best bet. With Chrome, you can access the console with the key
    combo Ctrl-Shift-J (Command + Option + J on a Mac). As well as trying little JS
    snippets, the console allows you to drill down into any objects in scope, revealing
    their methods and properties. This is a great way to quiz the state of a live
    object and search for bugs.
  prefs: []
  type: TYPE_NORMAL
- en: One disadvantage of using online JavaScript editors is losing the power of your
    favorite editing environment, with linting, familiar keyboard shortcuts, and the
    like (see [Chapter 4](ch04.xhtml#chapter_webdev101)). Online editors tend to be
    rudimentary, to say the least. If you anticipate an extensive JavaScript session
    and want to use your favorite editor, the best bet is to run a local server.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a project directory—called *sandpit*, for example—and add a minimal
    HTML file that includes a JS script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The *index.xhtml* file need only be a few lines long, with an optional `div`
    placeholder on which to start building your visualization or just trying out a
    little DOM manipulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then add a little JavaScript to your *script.js* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Start your development server in the project directory using Python’s `http`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Then open your browser at *http://localhost:8000*, press Ctrl-Shift-J (Cmd-Opt-J
    on OS X) to access the console and you should see [Figure 2-1](#langbridge_sum33),
    showing the logged output of the script (see [Chapter 4](ch04.xhtml#chapter_webdev101)
    for further details).
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 0201](assets/dpj2_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Outputting to the Chrome console
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that we’ve established how to run the demo code, let’s start building a
    bridge between Python and JavaScript. First, we’ll cover the basic differences
    in syntax. As you’ll see, they’re fairly minor and easily absorbed.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Bridge Work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I’ll contrast the basic nuts and bolts of programming in the
    two languages.
  prefs: []
  type: TYPE_NORMAL
- en: Style Guidelines, PEP 8, and use strict
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Where JavaScript style guidelines are a bit of a free-for-all (with people often
    defaulting to those used by a big library like React), Python has a Python Enhancement
    Proposal (PEP) dedicated to it. I’d recommend getting acquainted with PEP-8 but
    not submitting totally to its leadership. It’s right about most things, but there’s
    room for some personal choice here. There’s a handy online checker called [PEP8
    Online](http://pep8online.com), which will pick up any infractions of PEP-8\.
    Many Pythonistas are turning to [the Black Python code formatter](https://oreil.ly/C9xWO),
    which takes over formatting duties in accordance with PEP-8.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, you should use four spaces to indent a code block. JavaScript is
    less strict, but two spaces is the most common indent.
  prefs: []
  type: TYPE_NORMAL
- en: 'One recent addition to JavaScript (ECMAScript 5) is the `''use strict''` directive,
    which imposes strict mode. This mode enforces some good JavaScript practice, which
    includes catching accidental global declarations, and I thoroughly recommend its
    use. To use it, just place the string at the top of your function or module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: CamelCase Versus Underscore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JS conventionally uses CamelCase (e.g., `processStudentData`) for its variables,
    whereas Python, in accordance with PEP-8, uses underscores (e.g., `process_student_data`)
    in its variable names (see Section B in Examples [2-3](#ex1_py) and [2-4](#ex1_js)).
    By convention (and convention is more important in the Python ecosystem than it
    is in JS), Python uses capitalized CamelCase for class declarations (see the following
    example), uppercase for constants, and underscores for everything else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Importing Modules, Including Scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using other libraries in your code, either your own or third-party, is fundamental
    to modern programming, which makes it all the more surprising that until relatively
    recently JavaScript didn’t have a dedicated way of doing it.^([5](ch02.xhtml#idm45607817504464))
    Python has a simple import system that, on the whole, works pretty well.
  prefs: []
  type: TYPE_NORMAL
- en: The good news on the JavaScript front is that since ECMAScript 6, JavaScript
    has addressed this issue, with the addition of `import` and `export` statements
    for encapsulated modules. We now have JavaScript modules (typically with the `.mjs`
    suffix) that can import and export encapsulated functions and objects, a huge
    step forward. In [Part V](part05.xhtml#part_viz), we’ll see how easy these are
    to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'While getting comfortable with JS you’ll probably want to import third-party
    libraries using the `script` tag, which will typically see them added to the global
    namespace as an object. For example, in order to use D3 you add the following
    `script` tag to your HTML entry file (typically *index.xhtml*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now use the D3 library like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Python comes with “batteries included,” a comprehensive set of libraries covering
    everything from extended data containers (collections) to working with the family
    of CSV files (csv). If you want to use one of these, just import it using the
    `import` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t want to import the whole library or want to use an alias, you
    can use the `as` and `from` keywords instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This imports all the variables from the module into the current namespace and
    is almost always a bad idea. One of the variables could mask an existing one,
    and it goes against the Python best practice of explicit being better than implicit.
    One exception to this rule is if you are using the Python interpreter interactively.
    In this limited context, it may make sense to import all functions from a library
    to cut down on key presses; for example, importing all the math functions (`from
    math import *`) if doing some Python math hacking.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you import a nonstandard library, Python uses `sys.path` to try to find
    it. `sys.path` consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: The directory containing the importing module (current directory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PYTHONPATH` variable, containing a list of directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The installation-dependent default, where libraries installed using `pip` or
    `easy_install` will usually be placed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Big libraries are often packaged, divided into submodules. These submodules
    are accessed by dot notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Packages are constructed from the filesystem via *__init__.py* files, usually
    empty, as shown in [Example 2-1](#pyjs_import). The presence of an init file makes
    the directory visible to Python’s import system.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-1\. Building a Python package
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: You would import this module using `from mypackage.io.tests import test_excel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access packages on `sys.path` from the root directory (that’s `mypackage`
    in [Example 2-1](#pyjs_import)) using dot notation. A special case of `import`
    is intrapackage references. The `test_excel.py` submodule in [Example 2-1](#pyjs_import)
    can import submodules from the `mypackage` package both absolutely and relatively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Imports the `test_data.py` module absolutely, from the package’s head directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: An explicit (`. import`) and implicit relative import.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: A relative import from a sibling package of `tests`.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript now has modules with import and export of encapsulated variables.
    JS cherry-picked its import syntax, using a lot of stuff that will be familiar
    to Pythonistas but, in my opinion, improving on it. Here’s a brief run-down:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we have a JS entry-point module `index.js`, which wants to use some
    functions or objects from a library module `libFoo.js` in a `lib` directory. The
    file structure looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In `libFoo.mjs` we export a dummy function and can use `export default` to
    export a single object for the module, typically an API with, for example, utility
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of object creation with shorthand property name, equivalent to `{findOdds:
    findOdds}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'To import the exported functions and objects from our index module we use the
    `import` statement, which allows us to import the default API or select exported
    variables by name using curly brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'JS imports also support aliasing, which can be a great code sanitizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, JavaScript imports and exports are very similar to Python’s,
    though a little more user-friendly in my experience. You can see more details
    in Mozilla’s documentation for [exports](https://oreil.ly/J0aDV) and [imports](https://oreil.ly/slsT5).
  prefs: []
  type: TYPE_NORMAL
- en: Keeping Your Namespaces Clean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The variables defined in Python modules are encapsulated, which means that
    unless you import them explicitly (e.g., `from foo import baa`), you will be accessing
    them from the imported module’s namespace using dot notation (e.g., `foo.baa`).
    This modularization of the global namespace is quite rightly seen as a very good
    thing and plays to one of Python’s key tenets: the importance of explicit statements
    over implicit. When analyzing someone’s Python code you should be able to see
    exactly where a class, function, or variable has come from. Just as importantly,
    preserving the namespace limits the chance of conflicting or masking variables—a
    big potential problem as codebases get larger.'
  prefs: []
  type: TYPE_NORMAL
- en: In the past one of the main criticisms of JavaScript, and a fair one, was that
    it played fast and loose with namespace conventions. The most egregious example
    of this is that variables declared outside of functions or missing the `var` keyword^([6](ch02.xhtml#idm45607819371024))
    are global rather than confined to the script in which they are declared. With
    modern, modular JavaScript you get Python-like encapsulation with imported and
    exported variables.
  prefs: []
  type: TYPE_NORMAL
- en: JS modules are a relatively recent game changer—a common pattern used in the
    past and one that you may well run into is the creation of a self-calling function
    in order to isolate local variables from the global namespace. This makes all
    variables declared via `var` local to the script/function, preventing them from
    polluting the global namespace. The JavaScript [`let`](https://oreil.ly/cTxOy)
    keyword, which is block-scoped, is pretty much always preferable to `var`. Any
    objects, functions, and variables you want to make available to other scripts
    can be attached to an object that is part of the global namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 2-2](#pyjs_module) demonstrates a module pattern. The boilerplate
    head and tail (labeled ![1](assets/1.png) and ![3](assets/3.png)) effectively
    create an encapsulated module. This pattern is far from a perfect solution to
    modular JavaScript but was the best compromise I knew of until ECMAScript 6’s
    dedicated import system was adopted by all major browsers.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-2\. A module pattern for JavaScript
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Receives the global `nbviz` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Attaches the `updateTimeChart` method to the global `nbviz` object, effectively
    *exporting* it.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: If an `nbviz` object exists in the global (window) namespace, pass it into the
    module function; otherwise, add it to the global namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Outputting “Hello World!”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By far the most popular initial demonstration of any programming language is
    getting it to print or communicate “Hello World!” in some form, so let’s start
    with getting output from Python and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python’s output couldn’t be much simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript has no print function, but you can log output to the browser console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Simple Data Processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A good way to get an overview of the language differences is to see the same
    function written in both. Examples [2-3](#ex1_py) and [2-4](#ex1_js) show a small,
    contrived example of data munging in Python and JavaScript, respectively. We’ll
    use these to compare Python and JS syntax and label them with capital letters
    (A, B…​) to allow comparison of the code blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-3\. Simple data transformation with Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Example 2-4\. Simple data munging with JavaScript
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Note the deliberate and valid inconsistency in the object keys with some quoted
    and some unquoted.
  prefs: []
  type: TYPE_NORMAL
- en: String Construction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The D sections in Examples [2-3](#ex1_py) and [2-4](#ex1_js) show the standard
    way to print output to the console or terminal. JavaScript has no `print` statement
    but will log to the browser’s console through the `console` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that the integer variable `id` is coerced to a string, allowing concatenation.
    Python doesn’t perform this implicit coercion, so attempting to add a string to
    an integer in this way gives an error. Instead, explicit conversion to string
    form is achieved through one of the `str` or `repr` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In section A of [Example 2-3](#ex1_py), the output string is constructed with
    C type formatting. String (`%s`) and integer (`%d`) placeholders are provided
    by a final tuple (`%(…​)`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: These days, I rarely use Python’s `print` statement, opting for the much more
    powerful and flexible `logging` module, which is demonstrated in the following
    code block. It takes a little more effort to use, but it is worth it. Logging
    gives you the flexibility to direct output to a file and/or the screen, adjusting
    the logging level to prioritize certain information, and a whole load of other
    useful things. Check out the details in the [Python documentation](https://oreil.ly/aJzyx).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a logger with the name of this module.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the logging level to “debug” provides the most detailed information
    available (see the [Python documentation](https://oreil.ly/xAiP1) for further
    details).
  prefs: []
  type: TYPE_NORMAL
- en: Significant Whitespace Versus Curly Brackets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The syntactic feature most associated with Python is significant whitespace.
    Whereas languages like C and JavaScript use whitespace for readability and could
    easily be condensed into one line,^([7](ch02.xhtml#idm45607813738384)) in Python
    leading spaces are used to indicate code blocks and removing them changes the
    meaning of the code. The extra effort required to maintain correct code alignment
    is more than compensated for by increased readability—you spend far longer reading
    than writing code, and the easy reading of Python is probably the main reason
    why the Python library ecosystem is so healthy. Four spaces is pretty much mandatory
    (see PEP-8) and my personal preference is for what are known as *soft tabs*, where
    your editor inserts (and deletes) multiple spaces instead of a tab character.^([8](ch02.xhtml#idm45607813736320))
  prefs: []
  type: TYPE_NORMAL
- en: In the following code, the indentation of the `return` statement must be four
    spaces by convention:^([9](ch02.xhtml#idm45607813735088))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript doesn’t care about the number of spaces between statements and variables,
    using curly brackets to demark code blocks; the two doubler functions in this
    code are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Much is made of Python’s whitespace, but most good coders I know set up their
    editors to enforce indented code blocks and a consistent look and feel. Python
    merely enforces this good practice. And, to reiterate, I believe the extreme readability
    of Python code contributes as much to Python’s supremely healthy ecosystem as
    its simple syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Comments and Doc-Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add comments to code, Python uses hashes, *#*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'By contrast, JavaScript uses the C language convention of double backslashes
    (*//*) or */* …​ */* for multiline comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to comments, and in keeping with its philosophy of readability
    and transparency, Python has documentation strings (doc-strings) by convention.
    The `process_student_data` function in [Example 2-3](#ex1_py) has a triple-quoted
    line of text at its top that will automatically be assigned to the function’s
    `__doc__` attribute. You can also use multiline doc-strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Doc-strings are a great habit to get into, particularly if you are working collaboratively.
    They are understood by most decent Python editing toolsets and are also used by
    such automated documentation libraries as [Sphinx](http://sphinx-doc.org). The
    string-literal doc-string is accessible as the `doc` property of a function or
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Variables Using let or var
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript uses `let` or `var` to declare variables. Generally speaking, `let`
    is almost always the right choice.
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, JS statements should be terminated with a semicolon as opposed
    to Python’s newline. You will see examples where the semicolon is dispensed with,
    and modern browsers will usually do the right thing here. There are a few edge
    cases that could necessitate the use of a semicolon (e.g., it can trip up code
    minifiers and compressors that remove whitespace), but generally I find that the
    loss of clutter and improvement in readability are a worthwhile compromise to
    coding without the semicolons.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: JavaScript has *variable hoisting*, which means variables declared with `var`
    are processed before any other code. This means declaring them anywhere in the
    function is equivalent to declaring them at the top. This can result in weird
    errors and confusion. Explicitly placing `var`s at the top avoids this, but it’s
    better to use the modern `let` and have scoped declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Strings and Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *name* strings used in the student data (see Section A of Examples [2-3](#ex1_py)
    and [2-4](#ex1_js)) will be interpreted as UCS-2 (the parent of unicode UTF-16)
    in JavaScript,^([10](ch02.xhtml#idm45607813787904)) and Unicode (UTF-8 by default)
    in Python 3.^([11](ch02.xhtml#idm45607813786288))
  prefs: []
  type: TYPE_NORMAL
- en: 'Both languages allow single and double quotes for strings. If you want to include
    a single or double quote in the string, then enclose with the alternative, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `scores` in Section A of [Example 2-4](#ex1_js) are stored as JavaScript’s
    one numeric type, double-precision 64-bit (IEEE 754) floating-point numbers. Although
    JavaScript has a `parseInt` conversion function, when used with floats,^([12](ch02.xhtml#idm45607813779728))
    it is really just a rounding operator, similar to `floor`. The type of the parsed
    `number` is still `number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Python has two numeric types: the 32-bit `int`, to which the student scores
    are cast, and a `float` equivalent (IEE 754) to JS’s `number`. This means that
    Python can represent any integer, whereas JavaScript is more limited.^([13](ch02.xhtml#idm45607815619968))
    Python’s casting changes type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The nice thing about Python and JavaScript numbers is that they are easy to
    work with and usually do what you want. If you need something more efficient,
    Python has the NumPy library, which allows fine-grained control of your numeric
    types (you’ll learn more about NumPy in [Chapter 7](ch07.xhtml#chapter_numpy)).
    In JavaScript, aside from some cutting-edge projects, you’re pretty much stuck
    with 64-bit floats.
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python differs from the JavaScript and the C class languages in using named
    Boolean operators. Other than that, they work pretty much as expected. This table
    gives a comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python** | `bool` | `True` | `False` | `not` | `and` | `or` |'
  prefs: []
  type: TYPE_TB
- en: '| **JavaScript** | `boolean` | `true` | `false` | `!` | `&&` | &#124;&#124;
    |'
  prefs: []
  type: TYPE_TB
- en: Python’s capitalized `True` and `False` is an obvious trip-up for any JavaScripter
    and vice versa, but any decent syntax highlighting should catch that, as should
    your code linter.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than always returning Boolean true or false, both Python and JavaScript
    `and`/`or` expressions return the result of one of the arguments, which may of
    course be a Boolean value. [Table 2-1](#table0201) shows how this works, using
    Python to demonstrate.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. Python’s Boolean operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| x or y | if x is false, then y, else x |'
  prefs: []
  type: TYPE_TB
- en: '| x and y | if x is false, then x, else y |'
  prefs: []
  type: TYPE_TB
- en: '| not x | if x is false, then `True`, else `False` |'
  prefs: []
  type: TYPE_TB
- en: 'This fact allows for some occasionally useful variable assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Data Containers: dicts, objects, lists, Arrays'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Roughly speaking, JavaScript `objects` can be used like Python `dict`s, and
    Python `list`s like JavaScript arrays. Python also has a tuple container, which
    functions like an immutable list. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As shown in Section A of Examples [2-3](#ex1_py) and [2-4](#ex1_js), while Python’s
    `dict` keys must be quote-marked strings (or hashable types), JavaScript allows
    you to omit the quotes if the property is a valid identifier (i.e., not containing
    special characters such as spaces and dashes). So in our `studentData` objects,
    JS implicitly converts the property `'name'` to string form.
  prefs: []
  type: TYPE_NORMAL
- en: The student data declarations look pretty much the same and, in practice, are
    used pretty much the same too. The key difference to note is that while the curly-bracketed
    containers in the JS `studentData` look like Python `dict`s, they are actually
    a shorthand declaration of JS [objects](https://oreil.ly/QTlNc), a somewhat different
    data container.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JS data visualization, we tend to use arrays of objects as the chief data
    container and here, JS objects function much as a Pythonista would expect. In
    fact, as demonstrated in the following code, we get the advantage of both dot
    notation and key-string access, the former being preferred where applicable (keys
    with spaces or dashes needing quoted strings):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: It’s good to be aware that although they can be used like Python dictionaries,
    JavaScript objects are much more than just containers (aside from primitives like
    strings and numbers, pretty much everything in JavaScript is an object).^([14](ch02.xhtml#idm45607815328112))
    But in most dataviz examples you see, they are used very much like Python `dict`s.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 2-2](#table0202) converts basic list operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-2\. Lists and arrays
  prefs: []
  type: TYPE_NORMAL
- en: '| JavaScript array (a) | Python list (l) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `a.length` | `len(l)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a.push(item)` | `l.append(item)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a.pop()` | `l.pop()` |'
  prefs: []
  type: TYPE_TB
- en: '| `a.shift()` | `l.pop(0)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a.unshift(item)` | `l.insert(0, item)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a.slice(start, end)` | `l[start:end]` |'
  prefs: []
  type: TYPE_TB
- en: '| `a.splice(start, howMany, i1, …​)` | `l[start:end] = [i1, …​]` |'
  prefs: []
  type: TYPE_TB
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The B sections of Examples [2-3](#ex1_py) and [2-4](#ex1_js) show a function
    declaration. Python uses `def` to indicate a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'whereas JavaScript uses `function`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Both have a list of parameters. With JS, the function code block is indicated
    by the curly brackets { …​ }; with Python, the code block is defined by a colon
    and indentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'JS has an alternative way of defining a function called the *function expression*,
    which you may see in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'There is now a shortened form, which is becoming more popular:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The differences are subtle enough not to worry about for now.^([15](ch02.xhtml#idm45607815158832))
  prefs: []
  type: TYPE_NORMAL
- en: Function parameters is an area where Python’s handling is more sophisticated
    than JavaScript’s. As you can see in `process_student_data` (Section B in [Example 2-3](#ex1_py)),
    Python allows default arguments for the parameters. In JavaScript, all parameters
    not used in the function call are declared as *undefined*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterating: for Loops and Functional Alternatives'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C sections in Examples [2-3](#ex1_py) and [2-4](#ex1_js) shows our first
    key difference between Python and JavaScript—their handling of `for` loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python’s `for` loops are simple, intuitive, and effective on any iterator,
    such as arrays and `dict`s. One gotcha with `dict`s is that standard iteration
    is by key, not items. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To iterate over the key-value pairs, use the `dict`’s `items` method like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can assign the key-values in the `for` statement for convenience. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Because Python’s `for` loop works on anything with the correct iterator plumbing,
    you can do cool things like loop over file lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Coming from Python, JS’s `for` loop is a pretty horrible, unintuitive thing.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: JS’s `for .. in` returns the index of the array’s items, not the items themselves.
    To compound matters, for the Pythonista, the order of iteration is not guaranteed,
    so the indices could be returned in nonconsecutive order.
  prefs: []
  type: TYPE_NORMAL
- en: Shifting between Python and JS `for` loops is hardly seamless, demanding you
    keep on the ball. The good news is that you hardly need to use JS `for` loops
    these days. In fact, I almost never find the need. That’s because JS has recently
    acquired some very powerful first-class functional abilities, which have more
    expressive power and less scope for confusion with Python and, once you get used
    to them, quickly become indispensable.^([16](ch02.xhtml#idm45607802789056))
  prefs: []
  type: TYPE_NORMAL
- en: Section C in [Example 2-4](#ex1_js) demonstrates `forEach()`, one of the *functional*
    methods available to modern JavaScript arrays.^([17](ch02.xhtml#idm45607802786192))
    `forEach()` iterates over the array’s items, sending them in turn to an anonymous
    callback function defined in the first argument, where they can be processed.
    The true expressive power of these functional methods comes from chaining them
    (maps, filters, etc.), but already we have a cleaner, more elegant iteration with
    none of the awkward bookkeeping of old.
  prefs: []
  type: TYPE_NORMAL
- en: 'The callback function receives the index and the original array as an optional
    second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Until recently even iterating over an `object`’s key-value pairs was fairly
    tricky. Unlike Python’s `dict`s, `object`s could have inherited properties from
    the prototyping chain, so you had to use a `hasOwnProperty` guard to filter these
    out. You may well come across code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas JS arrays have a set of native functional iterator methods (`map`,
    `reduce`, `filter`, `every`, `sum`, `reduceRight`), `object`s—in their guise as
    pseudodictionaries—don’t. The good news is that the `object` class has recently
    acquired some useful additional methods that fill this gap. So you can iterate
    through the key-value pairs using the `entries` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Note the string template form `${foo}` for printing variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conditionals: if, else, elif, switch'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Section C in Examples [2-3](#ex1_py) and [2-4](#ex1_js) shows Python and JavaScript
    conditionals in action. Aside from JavaScript’s use of brackets, the statements
    are very similar; the only real difference being Python’s extra `elif` keyword,
    a convenient conjunction of `else if`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though much requested, Python does not have the `switch` statement found in
    most high-level languages. JS does, allowing you to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The good news for Pythonistas is that with 3.10 Python gets a very powerful
    pattern-matching conditional that can function as a `switch` statement but do
    a [whole lot more](https://oreil.ly/5x76a). So we can do this to switch between
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: File Input and Output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Browser-based JavaScript has no real equivalent of file input and output (I/O),
    but Python’s is as simple as could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'One much recommended best practice is to use Python’s `with`, `as` context
    manager when opening files. This ensures they are closed automatically when leaving
    the block, essentially providing [syntactic sugar](https://oreil.ly/DPxaM) for
    a `try`, `except`, `finally` block. Here’s how to open a file using `with`, `as`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript does, however, have the roughly analogous `fetch` method for fetching
    a resource from the network, based on its URL. So to fetch a dataset from the
    website’s server, in the *static/data* directory you do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The [Fetch API](https://oreil.ly/OFjns) is thoroughly documented at Mozilla.
  prefs: []
  type: TYPE_NORMAL
- en: Classes and Prototypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Possibly the cause of more confusion that any other topic is JavaScript’s choice
    of prototypes rather than classical classes as its chief object-oriented programming
    (OOP) element. This does require some adaption for a Pythonista, where classes
    are ubiquitous, but in practice this learning curve is, in my experience, short
    and fairly shallow.
  prefs: []
  type: TYPE_NORMAL
- en: I remember, when I first started my forays into more advanced languages like
    C++, falling for the promise of OOP, particularly class-based inheritance. Polymorphism
    was all the rage and shape classes were being subclassed to rectangles and ellipses,
    which were in turn subclassed to more specialized squares and circles.
  prefs: []
  type: TYPE_NORMAL
- en: It didn’t take long to realize that the clean class divisions found in the textbooks
    were rarely found in real programming and that trying to balance generic and specific
    APIs quickly became fraught. In this sense, I find composition and mix-ins much
    more useful as programming concepts than attempts at extended subclassing, and
    often avoid all these by using functional programming techniques, particularly
    in JavaScript. Nevertheless, the class/prototype distinction is an obvious difference
    between the two languages, and the more you understand its nuances, the better
    you’ll code.^([18](ch02.xhtml#idm45607802261472))
  prefs: []
  type: TYPE_NORMAL
- en: 'Python’s classes are fairly simple affairs and, as with most of the language,
    easy to use. I tend to think of them these days as a handy way to encapsulate
    data with a convenient API, and rarely extend subclassing beyond one generation.
    Here’s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Python classes have a number of double-underscored special methods, `__init__`
    being the most common, called when the class instance is created. All instance
    methods have a first, explicit `self` argument (you could name it something else,
    but it’s a very bad idea), which refers to the instance. In this case, we use
    it to set name and country properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: You can override the class’s string method, which is used when the `print` function
    is called on an instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a new `Citizen` instance, initialized with name and country.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python follows a fairly classical pattern of class inheritance. It’s easy to
    do, which is probably why Pythonistas make a lot of use of it. Let’s customize
    the `Citizen` class to create a (Nobel Prize) `Winner` class with a couple of
    extra properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We want to reuse the superclass `Citizen’s` `__init__` method, using this `Winner`
    instance as `self`. The `super` method scales the inheritance tree one branch
    from its first argument, supplying the second as instance to the class-instance
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'I think the best article I have read on the key difference between JavaScript’s
    prototypes and classical classes is Reginald Braithwaite’s [“OOP, JavaScript,
    and so-called Classes”](https://oreil.ly/92Kxk). This quote sums up the difference
    between classes and prototypes as nicely as any I’ve found:'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between a prototype and a class is similar to the difference
    between a model home and a blueprint for a home.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When you instantiate a C++ or Python class, a blueprint is followed, creating
    an object and calling its various constructors in the inheritance tree. In other
    words, you start from scratch and build a nice, pristine new class instance.
  prefs: []
  type: TYPE_NORMAL
- en: With JavaScript prototypes, you start with a model home (object) that has rooms
    (methods). If you want a new living room, you can just replace the old one with
    something in better colors. If you want a new conservatory, then just make an
    extension. But rather than building from scratch with a blueprint, you’re adapting
    and extending an existing object.
  prefs: []
  type: TYPE_NORMAL
- en: With that necessary theory out of the way and the reminder that object inheritance
    is useful to know but hardly ubiquitous in dataviz, let’s see a simple JavaScript
    prototype object in [Example 2-5](#bridge_citizen_js).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-5\. A simple JavaScript object
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This function is essentially an initializer, invoked by the `new` operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`this` is an implicit reference to the *calling context* of the function. For
    now, it behaves as you would expect and even though it looks a little like Python’s
    `self`, the two are quite different, as we’ll see.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The methods specified here will both override any prototypical methods up the
    inheritance chain and be inherited by any objects derived from `Citizen`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO11-4)'
  prefs: []
  type: TYPE_NORMAL
- en: '`new` is used to create a new object, set its prototype to that of the `Citizen`
    constructor function, and then call the `Citizen` constructor function on the
    new object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript has recently acquired some [syntactic sugar](https://oreil.ly/43NXG)
    allowing classes to be declared. This essentially wraps the object-based form
    (see [Example 2-5](#bridge_citizen_js)) in something more familiar to programmers
    coming from `class`-based languages like Java and C#. I think it’s fair to say
    that classes haven’t really taken off in frontend, browser-based JavaScript, having
    been usurped somewhat by new frameworks with an emphasis on reusable components
    (e.g., React, Vue, Svelte). Here’s how we would implement the `Citizen` `Object`
    shown in [Example 2-5](#bridge_citizen_js):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: I included [Example 2-5](#bridge_citizen_js), which shows `new` in JavaScript
    object instantiation, because you will run into its use a fair deal. But the syntax
    is already a little awkward and gets quite a bit worse when you try to do inheritance.
    ECMAScript 5 introduced the `Object.create` method, a better way to create objects
    and to implement inheritance. I’d recommend using it in your own code, but `new`
    will probably crop up in some third-party libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use `Object.create` to create a `Citizen` and its `Winner` inheritor.
    To emphasize, JavaScript has many ways to do this, but [Example 2-6](#bridge_prototype_inheritance)
    shows the cleanest I have found and my personal pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-6\. Prototypical inheritance with `Object.create`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Citizen` is now an object rather than a constructor function. Think of this
    as the base house for any new buildings such as `Winner`.'
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate, prototypical inheritance is not seen that often in JavaScript
    dataviz, particularly the 800-pound gorilla D3 with its emphasis on declarative
    and functional patterns, with *raw* unencapsulated data being used to stamp its
    impression on the web page.
  prefs: []
  type: TYPE_NORMAL
- en: The tricky class/prototype comparison concludes this section on basic syntactic
    differences. Now let’s look at some common patterns seen in dataviz work with
    Python and JS.
  prefs: []
  type: TYPE_NORMAL
- en: Differences in Practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The syntactic differences between JS and Python are important to know and are
    thankfully outweighed by their syntactic similarities. The meat and potatoes of
    imperative programming, loops, conditionals, data declaration, and manipulation
    is much the same. This is all the more so in the specialized domain of data processing
    and data visualization where the languages’ first-class functions allow common
    idioms.
  prefs: []
  type: TYPE_NORMAL
- en: What follows is a less-than-comprehensive list of some important patterns and
    idioms seen in Python and JavaScript, from the perspective of a data visualizer.
    Where possible, a translation between the two languages is given.
  prefs: []
  type: TYPE_NORMAL
- en: Method Chaining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common JavaScript idiom is *method chaining*, popularized by its most-used
    library, jQuery, and much used in D3\. Method chaining involves returning an object
    from its own method in order to call another method on the result, using dot notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `attr` method returns the D3 selection that called it, which is then used
    to call another `attr` method.
  prefs: []
  type: TYPE_NORMAL
- en: Method chaining is not much seen in Python, which generally advocates one statement
    per line in keeping with simplicity and readability.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating a List
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often it’s useful to iterate through a list while keeping track of the item’s
    index. Python has the very handy built-in `enumerate` function for just this reason:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript’s list methods, such as `forEach` and the functional `map`, `reduce`,
    and `filter`, supply the iterated item and its index to the callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Tuple Unpacking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the first cool tricks Python initiates uses tuple unpacking to switch
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the brackets are optional. This can be put to more practical purpose
    as a way of reducing the temporary variables, such as in a [Fibonacci function](https://oreil.ly/OAT8Q):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to ignore one of the unpacked variables, use an underscore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python 3 has an [* operator](https://oreil.ly/MFjiR) that means, in this case,
    we could unpack our variables with this: `name, *_, nationality = winner`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The JavaScript language is adapting rapidly and has recently acquired some
    very powerful [destructuring abilities](https://oreil.ly/97rbT). With the addition
    of the *spread operator* (`...`), this enables some very succinct data manipulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike in Python, you still need to declare any variables you are going to use.
  prefs: []
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most useful Python “batteries” is the `collections` module. This
    provides some specialized container datatypes to augment Python’s standard set.
    It has a `deque`, which provides a list-like container with fast appends and pops
    at either end; an `OrderedDict`, which remembers the order entries were added;
    a `defaultdict`, which provides a factory function to set the dictionary’s default;
    and a `Counter` container for counting hashable objects, among others. I find
    myself using the last three a lot. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the dictionary default to an integer, with value 0 by default.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO16-2)'
  prefs: []
  type: TYPE_NORMAL
- en: If the item-key doesn’t exist, its value is set to the default of 0 and 1 added
    to that.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO16-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Gets the list of items in the dictionary `d` as key-value tuple pairs, sorts
    using the integer value, and then creates an `OrderedDict` with the sorted list.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO16-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `OrderedDict` remembers the (sorted) order of the items as they were added
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: You can get more details on the `collections` module in the [Python documentation](https://oreil.ly/IOK7c).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to replicate some of Python’s `collections` function using more
    conventional JavaScript libraries, Underscore (or its functionally identical replacement
    Lodash^([20](ch02.xhtml#idm45607800747696))) is a good place to start. These libraries
    offer some enhanced functional programming utilities. Let’s take a quick look
    at this very handy tool.
  prefs: []
  type: TYPE_NORMAL
- en: Underscore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Underscore is probably the most popular JavaScript library after the ubiquitous
    jQuery and offers a bevy of functional programming utilities for the JavaScript
    dataviz programmer. The easiest way to use Underscore is to use a content delivery
    network (CDN) to load it remotely (these loads will be cached by your browser,
    making things very efficient for common libraries), like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Underscore has loads of useful functions. There is, for example, a `countBy`
    method, which serves the same purpose as the Python’s `collections` counter just
    discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO17-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Now you see why the library is called Underscore.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ll now see, the inclusion in modern JavaScript of native functional methods
    (`map`, `reduce`, `filter`) and a `forEach` iterator for arrays has made Underscore
    slightly less indispensable, but it still has some great utilities to augment
    vanilla JS. With a little chaining, you can produce extremely terse but very powerful
    code. Underscore was my introduction to functional programming in JavaScript,
    and the idioms are just as appealing today. Check out Underscore’s repertoire
    of utilities on [their website](https://underscorejs.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at Underscore in action, tackling a more involved task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO18-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Our array of morning times arrays (`[[44, 34, 56, 31], [33...]]`) needs to be
    *flattened* into a single array of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Array Methods and List Comprehensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I find myself using Underscore a lot less since the addition, with ECMAScript
    5, of functional methods to JavaScript arrays. I don’t think I’ve used a conventional
    `for` loop since then, which, given the ugliness of JS `for` loops, is a very
    good thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you get used to processing arrays functionally, it’s hard to consider
    going back. Combined with JS’s anonymous functions, it makes for very fluid, expressive
    programming. It’s also an area where method chaining seems very natural. Let’s
    look at a highly contrived example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO19-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Filters the list for odd numbers (i.e., returning `1` for the `modulus (%) 2`
    operation).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO19-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`map` produces a new list by applying a function to each member (i.e., `[1,
    3, 5...]` → `[1, 9, 25...]`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO19-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`reduce` processes the resultant mapped list in sequence, providing the current
    (in this case, summed) value (`total`) and the item value (`current`). By default,
    the initial value of the first argument (`total`) is `0` but we provide it explicitly
    here, as the second argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python’s powerful list comprehensions can emulate the previous example easily
    enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO20-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Python has a handy built-in `range` function, which can also take a start, end,
    and step (e.g., range(2, 8, 2) → (2, 4, 6)).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO20-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `if` condition tests for oddness of `x`, and any numbers passing this filter
    are squared and inserted into the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO20-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Python also has a built-in and often used `sum` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Python’s list comprehensions can use recursive control structures, such as applying
    a second `for`/`if` expression to the iterated items. Although this can create
    terse and powerful lines of code, it goes against the grain of Python’s readability
    and I discourage its use. Even simple list comprehensions are less than intuitive
    and, as much as it appeals to the leet hacker in all of us, you risk creating
    incomprehensible code.
  prefs: []
  type: TYPE_NORMAL
- en: Python’s list comprehensions work well for basic filtering and mapping. They
    do lack the convenience of JavaScript’s anonymous functions (which are fully fledged,
    with their own scope, control blocks, exception handling, etc.), but there are
    arguments against the use of anonymous functions. For example, they are not reusable
    and, being unnamed, they make it hard to follow exceptions and debug. See [Ultimate
    Courses](https://oreil.ly/7u1j6) for some persuasive arguments. Having said that,
    for libraries like D3, replacing the small, throwaway anonymous functions used
    to set [DOM attributes](https://oreil.ly/hYN27) and properties with named ones
    would be far too onerous and would just add to the boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python does have functional lambda expressions, which we’ll look at in the
    next section, but for full functional processing in Python by necessity and JavaScript
    for best practice, we can use named functions to increase our control scope. For
    our simple odd-squares example, named functions are a contrivance—but note that
    they increase the first-glance readability of the list comprehension, which becomes
    much more important as your functions get more complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: With JavaScript, a similar contrivance can also increase readability and facilitate
    DRY code:^([21](ch02.xhtml#idm45607799695392))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Map, Reduce, and Filter with Python’s Lambdas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although Python lacks anonymous functions, it does have *lambdas*, which are
    nameless expressions that take arguments. Though lacking the bells and whistles
    of JavaScript’s anonymous functions, these are a powerful addition to Python’s
    functional programming repertoire, especially when combined with its functional
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Python’s functional built-ins (`map`, `reduce`, `filter` methods, and lambda
    expressions) have a checkered past. It’s no secret that the creator of Python
    wanted to remove them from the language. The clamor of disapproval led to their
    reluctant preservation. With the recent trend toward functional programming, this
    looks like a very good thing. They’re not perfect but are far better than nothing.
    And given JavaScript’s strong functional emphasis, they’re a good way to leverage
    skills acquired in that language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python’s lambdas take a number of parameters and return an operation on them,
    using a colon separator to define the function block, in much the same way that
    standard Python functions, only pared to the bare essentials and with an implicit
    return. The following example shows a few lambdas employed in functional programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO21-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the `reduce` method provides two arguments to the lambda, which uses them
    to return the expression after the colon.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Closures and the Module Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the key concepts in JavaScript is that of the *closure*, which is essentially
    a nested function declaration that uses variables declared in an outer (but not
    global) scope that are *kept alive* after the function is returned. Closures allow
    for a number of very useful programming patterns and are a common feature of the
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at possibly the most common usage of closures and one we’ve already
    seen exploited in our module pattern ([Example 2-2](#pyjs_module)): exposing a
    limited API while having access to essentially private member variables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example of a closure is this little counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO22-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `add` function gets access to the essentially private, outer-scope `count`
    and `inc` variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO22-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This returns an `add` function with the closure variables, `count` (`0`) and
    `inc` (`2`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO22-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Calling `inc2` calls `add`, updating the *closed* `count` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extend the `Counter` to add a little API. This technique is the basis
    of JavaScript modules and many simple libraries, particularly when using script-based
    JavaScript.^([22](ch02.xhtml#idm45607799372592)) In essence, it selectively exposes
    public methods while hiding private methods and variables, which is generally
    seen as good practice in the programming world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Closures have all sorts of uses in JavaScript and I’d recommend getting your
    head around them—you’ll see them a lot as you start investigating other people’s
    code. These are three particularly good web articles that provide a lot of good
    use cases for closures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Mozilla’s introduction](https://oreil.ly/T6itS)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“JavaScript Module Pattern: In-Depth”](https://oreil.ly/0P2EI) by Ben Cherry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Use Cases for JavaScript Closures”](https://oreil.ly/xz4G5) by Juriy Zaytsev'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python has closures, but they are not used nearly as much as JavaScript’s, perhaps
    because of a few quirks that, though surmountable, make for some slightly awkward
    code. To demonstrate, [Example 2-7](#pyjs_pyclosure_1) tries to replicate the
    previous JavaScript counter.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-7\. A first-pass attempt at a Python counter closure
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'If you create a counter with `get_counter` ([Example 2-7](#pyjs_pyclosure_1))
    and try to run it, you’ll get an `UnboundLocalError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, although we can read the value of `count` within the `add` function
    (comment out the `count += inc` line to try it), attempts to change it throw an
    error. This is because attempts to assign a value to something in Python assume
    it is local in scope. There is no `count` local to the `add` function and so an
    error is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python 3, we can get around the error in [Example 2-7](#pyjs_pyclosure_1)
    by using the `nonlocal` keyword to tell Python that `count` is in a nonlocal scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are obliged to use Python 2+ (please try and upgrade), we can use a
    little dictionary hack to allow mutation of our closed variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This hack works because we are not assigning a new value to `vars` but are instead
    mutating an existing container, which is perfectly valid even if it is out of
    local scope.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, with a bit of effort, JavaScripters can transfer their closure
    skills to Python. The use cases are similar, but Python, being a richer language
    with lots of useful batteries included, has more options to apply to the same
    problem. Probably the most common use of closures is in Python’s decorators.
  prefs: []
  type: TYPE_NORMAL
- en: '*Decorators* are essentially function wrappers that extend the function’s utility
    without having to alter the function itself. They’re a relatively advanced concept,
    but you can find a user-friendly introduction [on The Code Ship website](https://oreil.ly/Skz8b).'
  prefs: []
  type: TYPE_NORMAL
- en: This concludes my cherry-picked selection of patterns and hacks that I find
    myself using a lot in dataviz work. You’ll doubtless acquire your own, but I hope
    these give you a leg up.
  prefs: []
  type: TYPE_NORMAL
- en: A Cheat Sheet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a handy reference guide, Figures [2-2](#build_cheat_basic) to [2-7](#build_cheat_classes)
    include a set of cheat sheets to translate basic operations between Python and
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 0202](assets/dpj2_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Some basic syntax
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![dpj2 0203](assets/dpj2_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. Booleans
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![dpj2 0204](assets/dpj2_0204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-4\. Loops and iterations
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![dpj2 0205](assets/dpj2_0205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-5\. Conditionals
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![dpj2 0206](assets/dpj2_0206.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-6\. Containers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![dpj2 0207](assets/dpj2_0207.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-7\. Classes and prototypes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope this chapter has shown that JavaScript and Python have a lot of common
    syntax and that most common idioms and patterns from one of the languages can
    be expressed in the other without too much fuss. The meat and potatoes of programming—iteration,
    conditionals, and basic data manipulation—is simple in both languages, and the
    translation of functions is straightforward. If you can program in one to any
    degree of competency, the threshold to entry for the other is low. That’s the
    huge appeal of these simple scripting languages, which have a lot of common heritage.
  prefs: []
  type: TYPE_NORMAL
- en: I provided a list of patterns, hacks, and idioms I find myself using frequently
    in dataviz work. I’m sure this list has its idiosyncrasies, but I’ve tried to
    tick the obvious boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Treat this as part tutorial, part reference for the chapters to come. Anything
    not covered here will be dealt with when introduced.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch02.xhtml#idm45607814867312-marker)) One particularly annoying little
    gotcha is that while Python uses `pop` to remove a list item, it uses `append`—not
    `push`—to add an item. JavaScript uses `push` to add an item, whereas `append`
    is used to concatenate arrays.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch02.xhtml#idm45607814847776-marker)) The ascent of [node.js](https://nodejs.org/en)
    has extended JavaScript to the server.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch02.xhtml#idm45607814841712-marker)) This is changing with libraries
    like [TensorFlow.js](https://oreil.ly/kDw6M) and [Danfo.js](https://oreil.ly/dJnOl)
    (a JavaScript pandas-alike based on TensorFlow), but JS is still well behind Python,
    R, and others.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch02.xhtml#idm45607814829968-marker)) At the cost of running a Python
    interpreter on the server.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch02.xhtml#idm45607817504464-marker)) The constraint of having to deliver
    JS scripts over the web via HTTP is largely responsible for this.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch02.xhtml#idm45607819371024-marker)) You can eliminate the possibility
    of a missing `var` by using the ECMAScript 5 `'use strict'` directive.
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch02.xhtml#idm45607813738384-marker)) This is actually done by JavaScript
    compressors to reduce the file size of downloaded web pages.
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch02.xhtml#idm45607813736320-marker)) The soft versus hard tab debate
    generates controversy, with much heat and little light. PEP-8 stipulates spaces,
    which is good enough for me.
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch02.xhtml#idm45607813735088-marker)) It could be two or even three spaces,
    but this number must be consistent throughout the module.
  prefs: []
  type: TYPE_NORMAL
- en: ^([10](ch02.xhtml#idm45607813787904-marker)) The quite fair assumption that
    JavaScript uses UTF-16 has been the cause of much bug-driven misery. See [this
    blog post by Mathias Bynens](https://oreil.ly/9otVB) for an interesting analysis.
  prefs: []
  type: TYPE_NORMAL
- en: ^([11](ch02.xhtml#idm45607813786288-marker)) The change to Unicode strings in
    Python 3 is a big one. Given the confusion that often attends Unicode de/encoding,
    it’s worth reading [a little bit about it](https://oreil.ly/5FNwi). Python 2 used
    strings of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: ^([12](ch02.xhtml#idm45607813779728-marker)) `parseInt` can do quite a bit more
    than round. For example, `parseInt(*12.5px*)` gives 12, first removing the *`px`*
    and then casting the string to a number. It also has a second `radix` argument
    to specify the base of the cast. See [the Mozilla documentation](https://oreil.ly/ZtA4n)
    for the specifics.
  prefs: []
  type: TYPE_NORMAL
- en: ^([13](ch02.xhtml#idm45607815619968-marker)) Because all numbers in JavaScript
    are floating point, it can only support 53-bit integers. Using larger integers
    (such as the commonly used 64-bit) can result in discontinuous integers. See this
    [2ality blog post](https://oreil.ly/hBxvS) for further information.
  prefs: []
  type: TYPE_NORMAL
- en: ^([14](ch02.xhtml#idm45607815328112-marker)) This makes iterating over their
    properties a little trickier than it might be. See [this Stack Overflow thread](https://oreil.ly/3kJW3)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: ^([15](ch02.xhtml#idm45607815158832-marker)) For the curious, there’s a nice
    summation in a [blog post by Angus Croll](https://oreil.ly/YyUyx).
  prefs: []
  type: TYPE_NORMAL
- en: ^([16](ch02.xhtml#idm45607802789056-marker)) This is one area where JS beats
    Python hands-down and which finds many of us wishing for similar functionality
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: ^([17](ch02.xhtml#idm45607802786192-marker)) Added with ECMAScript 5 and available
    on all modern browsers.
  prefs: []
  type: TYPE_NORMAL
- en: ^([18](ch02.xhtml#idm45607802261472-marker)) I mentioned to a talented programmer
    friend that I was faced with the challenge of explaining prototypes to Python
    programmers, and he pointed out that most JavaScripters could probably do with
    some pointers too. There’s a lot of truth in this and many JSers do manage to
    be productive by using prototypes in a *classy* way, hacking their way around
    the edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: ^([19](ch02.xhtml#idm45607801599376-marker)) This is another reason to use ECMAScript
    5’s `'use strict;'` injunction, which calls attention to such mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: ^([20](ch02.xhtml#idm45607800747696-marker)) My personal choice for performance
    reasons.
  prefs: []
  type: TYPE_NORMAL
- en: ^([21](ch02.xhtml#idm45607799695392-marker)) Don’t Repeat Yourself (DRY) is
    a solid coding convention.
  prefs: []
  type: TYPE_NORMAL
- en: ^([22](ch02.xhtml#idm45607799372592-marker)) Modern JavaScript has proper modules
    that can import and export encapsulated variables. There is an overhead to using
    these as they currently require a build phase to make ready for the browser.
  prefs: []
  type: TYPE_NORMAL
