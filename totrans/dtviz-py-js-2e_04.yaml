- en: Chapter 2\. A Language-Learning Bridge Between Python and JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章. Python 和 JavaScript 之间的语言学习桥梁
- en: Probably the most ambitious aspect of this book is that it deals with two programming
    languages. Moreover, it only requires that you are competent in one of these languages.
    This is only possible because Python and JavaScript (JS) are fairly simple languages
    with much in common. The aim of this chapter is to draw out those commonalities
    and use them to make a learning bridge between the two languages such that core
    skills acquired in one can easily be applied to the other.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书最雄心勃勃的方面可能是它涉及两种编程语言。此外，它只需要你精通其中一种语言。这仅仅是因为 Python 和 JavaScript（JS）是相当简单的语言，并且有很多共同之处。本章的目的是挖掘这些共同之处，并利用它们来构建两种语言之间的学习桥梁，以便在一种语言中获得的核心技能可以轻松地应用到另一种语言中。
- en: After showing the key similarities and differences between the two languages,
    I’ll show how to set up a learning environment for Python and JS. The bulk of
    the chapter will then deal with core syntactical and conceptual differences, followed
    by a selection of patterns and idioms that I use often while doing data visualization
    work.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示了这两种语言之间的关键相似之处和差异之后，我将展示如何为 Python 和 JS 设置学习环境。然后，本章的大部分内容将涉及核心的句法和概念差异，然后是我在进行数据可视化工作时经常使用的一些模式和习惯用法的选择。
- en: Similarities and Differences
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相似之处和不同之处
- en: 'Syntax differences aside, Python and JavaScript actually have a lot in common.
    After a short while, switching between them can be almost seamless.^([1](ch02.xhtml#idm45607814867312))
    Let’s compare the two from a data visualizer’s perspective:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 除了语法差异之外，Python 和 JavaScript 实际上有很多共同之处。在短时间内，它们之间的切换几乎可以无缝进行。让我们从数据可视化者的角度来比较这两种语言：
- en: 'These are the chief similarities:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是主要的相似之处：
- en: They both work without needing a compilation step (i.e., they are interpreted).
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们都可以在不需要编译步骤的情况下工作（即，它们是解释型的）。
- en: You can use both with an interactive interpreter, which means you can type in
    lines of code and see the results right away.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用交互式解释器来使用它们，这意味着你可以输入代码并立即看到结果。
- en: Both have [garbage collection](https://oreil.ly/3QDQA), which means they manage
    program memory automatically.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两者都有垃圾收集，这意味着它们会自动管理程序内存。
- en: Neither language has header files, package boilerplate, and so on, as compared
    to languages like C++, Java, etc.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 C++、Java 等语言相比，两种语言都没有头文件、包装样板等。
- en: Both can happily be developed with a text editor or lightweight IDE.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两者都可以在文本编辑器或轻量级 IDE 中愉快地开发。
- en: In both, functions are first-class citizens, which can be passed as arguments.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两者中，函数都是一等公民，可以作为参数传递。
- en: 'These are the key differences:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是关键的区别：
- en: Possibly the biggest difference is that JavaScript is [single-threaded and non-blocking](https://oreil.ly/Ja0FW),
    using asynchronous I/O. This means that simple things like file access involve
    the use of a [callback function](https://oreil.ly/L9DA5), passed to another function
    and called on completion of some code, usually asynchronously.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能最大的区别是 JavaScript 是单线程和非阻塞的，使用异步 I/O。这意味着简单的事情，比如文件访问，涉及到使用一个回调函数，传递给另一个函数，并在某些代码完成后调用，通常是异步的。
- en: JS is used essentially in web development and until relatively recently was
    browser-bound,^([2](ch02.xhtml#idm45607814847776)) but Python is used almost everywhere.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JS 基本上是用于 Web 开发，并且直到相对最近才与浏览器捆绑在一起，但 Python 几乎随处可见。
- en: JS is the only first-class language in web browsers, Python being excluded.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JS 是 Web 浏览器中唯一的一流语言，而 Python 被排除在外。
- en: Python has a comprehensive standard library, whereas JS has a limited set of
    utility objects (e.g., JSON, Math).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 有一个全面的标准库，而 JS 只有一套有限的实用对象（例如，JSON、Math）。
- en: Python has fairly classical object-oriented classes, whereas JS uses prototype
    objects.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 有着相当经典的面向对象类，而 JS 使用原型对象。
- en: JS lacks heavyweight general-purpose data-processing libs.^([3](ch02.xhtml#idm45607814841712))
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JS 缺乏重量级的通用数据处理库。
- en: The differences here emphasize the need for this book to be bilingual. The JavaScript
    monopoly on browser dataviz needs the complement of a conventional data-processing
    stack. And Python has the best there is.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些差异突显了这本书需要是双语的必要性。JavaScript 在浏览器数据可视化方面的垄断需要一个传统的数据处理堆栈的补充。而 Python 则是最好的选择。
- en: Interacting with the Code
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与代码交互
- en: One of the great advantages of Python and JavaScript is that because they are
    interpreted on the fly, you can interact with them. Python’s interpreter can be
    run from the command line, whereas JavaScript’s is generally accessed from the
    web browser through a console, usually available from the built-in development
    tools. In this section, we’ll see how to fire up a session with the interpreter
    and start trying out your code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Python 和 JavaScript 的一大优势是它们可以即时解释，因此可以与其交互。Python 的解释器可以从命令行运行，而 JavaScript
    的通常通过浏览器的控制台访问，通常可从内置的开发工具中获取。在本节中，我们将看到如何启动解释器会话并开始尝试您的代码。
- en: Python
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python
- en: 'By far, the best command-line Python interpreter is [IPython](https://ipython.org),
    which comes in three shades: the basic terminal version, an enhanced graphical
    version, and a browser-based notebook. Since IPython version 4.0, the latter two
    have been spun out into project [Jupyter](https://jupyter.org). The Jupyter notebook
    is a rather brilliant and fairly recent innovation, providing a browser-based
    interactive computational environment. The great boon of the notebook is session
    persistence and the possibility of web access.^([4](ch02.xhtml#idm45607814829968))
    The ease with which one can share programming sessions, complete with embedded
    data visualizations, makes the notebook a fantastic teaching tool as well as a
    great way to recover programming context. That’s why the Python chapters of this
    book have accompanying Jupyter notebooks.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，最好的命令行 Python 解释器是 [IPython](https://ipython.org)，它有三种形式：基本的终端版本、增强的图形版本和基于浏览器的笔记本。自
    IPython 版本 4.0 以来，后两种已经分拆成 [Jupyter](https://jupyter.org) 项目。Jupyter 笔记本是一个非常出色且相当新颖的创新，提供基于浏览器的交互式计算环境。笔记本的重要优势在于会话持久性和
    web 访问的可能性。在其中分享编程会话及嵌入的数据可视化非常简便，使笔记本成为绝佳的教学工具以及恢复编程上下文的好方式。这也是为什么本书的 Python
    章节配有 Jupyter 笔记本的原因。
- en: 'To start a Jupyter notebook just run `jupyter` at the command line:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动 Jupyter 笔记本，请在命令行运行 `jupyter`：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then open a browser tab at the URL specified (*http://localhost:8888* in this
    case) and start reading or writing Python notebooks.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 打开指定的 URL（在这种情况下是 *http://localhost:8888*），然后开始阅读或编写 Python 笔记本。
- en: JavaScript
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript
- en: There are lots of options for trying out JavaScript code without starting a
    server, though the latter isn’t that difficult. Because the JavaScript interpreter
    comes embedded in all modern web browsers, there are a number of sites that let
    you try out bits of JavaScript along with HTML and CSS and see the results. [CodePen](https://oreil.ly/ZtROX)
    is a good option. These sites are great for sharing code and trying out snippets,
    and usually allow you to add libraries such as *D3.js* with a few mouse-clicks.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多选项可以尝试 JavaScript 代码而不启动服务器，尽管后者并不难。因为 JavaScript 解释器嵌入在所有现代 web 浏览器中，所以有许多网站可以让您尝试
    JavaScript 片段以及 HTML 和 CSS，并查看结果。[CodePen](https://oreil.ly/ZtROX) 是一个不错的选择。这些网站非常适合分享代码和尝试片段，通常还允许您通过几次鼠标点击添加库，如
    *D3.js*。
- en: If you want to try out code one-liners or quiz the state of live code, browser-based
    consoles are your best bet. With Chrome, you can access the console with the key
    combo Ctrl-Shift-J (Command + Option + J on a Mac). As well as trying little JS
    snippets, the console allows you to drill down into any objects in scope, revealing
    their methods and properties. This is a great way to quiz the state of a live
    object and search for bugs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想尝试代码一行或者查看活动代码的状态，基于浏览器的控制台是最佳选择。在 Chrome 中，您可以使用 Ctrl-Shift-J（Mac 上为 Command
    + Option + J）访问控制台。除了尝试一些小的 JavaScript 片段外，控制台还允许您深入到任何范围内的对象，显示它们的方法和属性。这是查看活动对象状态和搜索错误的好方法。
- en: One disadvantage of using online JavaScript editors is losing the power of your
    favorite editing environment, with linting, familiar keyboard shortcuts, and the
    like (see [Chapter 4](ch04.xhtml#chapter_webdev101)). Online editors tend to be
    rudimentary, to say the least. If you anticipate an extensive JavaScript session
    and want to use your favorite editor, the best bet is to run a local server.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在线 JavaScript 编辑器的一个缺点是失去了您喜欢的编辑环境的优势，如 linting、熟悉的键盘快捷键等（参见 [第四章](ch04.xhtml#chapter_webdev101)）。在线编辑器往往基本功能简陋。如果您预计会进行广泛的
    JavaScript 会话并想使用您喜欢的编辑器，最好的选择是运行本地服务器。
- en: 'First, create a project directory—called *sandpit*, for example—and add a minimal
    HTML file that includes a JS script:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个项目目录——例如称为 *sandpit*——并添加一个包含 JS 脚本的最小 HTML 文件：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The *index.xhtml* file need only be a few lines long, with an optional `div`
    placeholder on which to start building your visualization or just trying out a
    little DOM manipulation:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*index.xhtml* 文件只需几行代码，可以选择在其中使用 `div` 占位符来开始构建你的可视化或尝试一些 DOM 操作：'
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can then add a little JavaScript to your *script.js* file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以向你的 *script.js* 文件中添加一些 JavaScript 代码：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Start your development server in the project directory using Python’s `http`
    module:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 的 `http` 模块在项目目录中启动开发服务器：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then open your browser at *http://localhost:8000*, press Ctrl-Shift-J (Cmd-Opt-J
    on OS X) to access the console and you should see [Figure 2-1](#langbridge_sum33),
    showing the logged output of the script (see [Chapter 4](ch04.xhtml#chapter_webdev101)
    for further details).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在浏览器中打开 *http://localhost:8000*，按 Ctrl-Shift-J（OS X 上的 Cmd-Opt-J）访问控制台，你应该可以看到
    [图 2-1](#langbridge_sum33)，显示脚本的日志输出（详见 [第 4 章](ch04.xhtml#chapter_webdev101)）。
- en: '![dpj2 0201](assets/dpj2_0201.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![dpj2 0201](assets/dpj2_0201.png)'
- en: Figure 2-1\. Outputting to the Chrome console
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. 输出到 Chrome 控制台
- en: Now that we’ve established how to run the demo code, let’s start building a
    bridge between Python and JavaScript. First, we’ll cover the basic differences
    in syntax. As you’ll see, they’re fairly minor and easily absorbed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何运行演示代码，让我们开始在 Python 和 JavaScript 之间建立桥梁。首先，我们将介绍语法上的基本差异。正如你将看到的那样，它们相差甚微，容易吸收。
- en: Basic Bridge Work
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础桥梁工作
- en: In this section, I’ll contrast the basic nuts and bolts of programming in the
    two languages.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将对比这两种语言中编程的基本要素。
- en: Style Guidelines, PEP 8, and use strict
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 风格指南、PEP 8 和使用严格模式
- en: Where JavaScript style guidelines are a bit of a free-for-all (with people often
    defaulting to those used by a big library like React), Python has a Python Enhancement
    Proposal (PEP) dedicated to it. I’d recommend getting acquainted with PEP-8 but
    not submitting totally to its leadership. It’s right about most things, but there’s
    room for some personal choice here. There’s a handy online checker called [PEP8
    Online](http://pep8online.com), which will pick up any infractions of PEP-8\.
    Many Pythonistas are turning to [the Black Python code formatter](https://oreil.ly/C9xWO),
    which takes over formatting duties in accordance with PEP-8.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的风格指南有些松散（人们通常默认使用像 React 这样的大型库所使用的风格），而 Python 则有一项专门的 Python Enhancement
    Proposal（PEP）。我建议熟悉 PEP-8，但不完全服从其领导地位。它在大多数事情上都是正确的，但在这里也有一些个人选择的余地。有一个方便的在线检查工具叫做
    [PEP8 Online](http://pep8online.com)，可以找出任何违反 PEP-8 的情况。许多 Python 爱好者正在转向 [Black
    Python 代码格式化工具](https://oreil.ly/C9xWO)，它按照 PEP-8 规范接管了格式化任务。
- en: In Python, you should use four spaces to indent a code block. JavaScript is
    less strict, but two spaces is the most common indent.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，应使用四个空格缩进代码块。JavaScript 则不那么严格，但两个空格是最常见的缩进方式。
- en: 'One recent addition to JavaScript (ECMAScript 5) is the `''use strict''` directive,
    which imposes strict mode. This mode enforces some good JavaScript practice, which
    includes catching accidental global declarations, and I thoroughly recommend its
    use. To use it, just place the string at the top of your function or module:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的最新增强（ECMAScript 5）之一是 `'use strict'` 指令，它强制启用严格模式。这种模式强制执行一些良好的
    JavaScript 实践，包括捕获意外的全局声明，我强烈推荐使用它。要使用它，只需将字符串放在函数或模块的顶部：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: CamelCase Versus Underscore
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 骆驼命名法对比下划线
- en: 'JS conventionally uses CamelCase (e.g., `processStudentData`) for its variables,
    whereas Python, in accordance with PEP-8, uses underscores (e.g., `process_student_data`)
    in its variable names (see Section B in Examples [2-3](#ex1_py) and [2-4](#ex1_js)).
    By convention (and convention is more important in the Python ecosystem than it
    is in JS), Python uses capitalized CamelCase for class declarations (see the following
    example), uppercase for constants, and underscores for everything else:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 通常使用骆驼命名法（例如 `processStudentData`）来命名变量，而 Python 根据 PEP-8 使用下划线（例如
    `process_student_data`）来命名变量（参见示例 [2-3](#ex1_py) 和 [2-4](#ex1_js)）。按照惯例（Python
    生态系统中的惯例比 JavaScript 更重要），Python 使用大写的骆驼命名法来声明类（见下面的示例），使用大写字母来定义常量，使用下划线来区分其他内容：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Importing Modules, Including Scripts
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入模块，包括脚本
- en: Using other libraries in your code, either your own or third-party, is fundamental
    to modern programming, which makes it all the more surprising that until relatively
    recently JavaScript didn’t have a dedicated way of doing it.^([5](ch02.xhtml#idm45607817504464))
    Python has a simple import system that, on the whole, works pretty well.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中使用其他库，无论是你自己的还是第三方的，对现代编程至关重要，这使得直到相对较近的时间内JavaScript没有专门的方法来做这件事显得更加令人惊讶。Python有一个简单的导入系统，总体上运行得相当好。
- en: The good news on the JavaScript front is that since ECMAScript 6, JavaScript
    has addressed this issue, with the addition of `import` and `export` statements
    for encapsulated modules. We now have JavaScript modules (typically with the `.mjs`
    suffix) that can import and export encapsulated functions and objects, a huge
    step forward. In [Part V](part05.xhtml#part_viz), we’ll see how easy these are
    to work with.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript前端的好消息是，自ECMAScript 6以来，JavaScript已经解决了这个问题，通过增加了`import`和`export`语句来封装模块。我们现在有JavaScript模块（通常使用`.mjs`后缀），可以导入和导出封装的函数和对象，这是一个巨大的进步。在[第 V
    部分](part05.xhtml#part_viz)，我们将看到这些如何易于使用。
- en: 'While getting comfortable with JS you’ll probably want to import third-party
    libraries using the `script` tag, which will typically see them added to the global
    namespace as an object. For example, in order to use D3 you add the following
    `script` tag to your HTML entry file (typically *index.xhtml*):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你熟悉JS时，你可能想使用`script`标签导入第三方库，这通常会将它们作为对象添加到全局命名空间中。例如，为了使用D3，你可以在你的HTML入口文件（通常是*index.xhtml*）中添加以下`script`标签：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can now use the D3 library like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以像这样使用D3库：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Python comes with “batteries included,” a comprehensive set of libraries covering
    everything from extended data containers (collections) to working with the family
    of CSV files (csv). If you want to use one of these, just import it using the
    `import` keyword:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带“电池”，一个涵盖从扩展数据容器（collections）到处理CSV文件家族的全面库集合。如果你想使用其中之一，只需使用`import`关键字导入它：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you don’t want to import the whole library or want to use an alias, you
    can use the `as` and `from` keywords instead:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想导入整个库或想使用别名，你可以使用`as`和`from`关键字代替：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO1-1)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO1-1)'
- en: This imports all the variables from the module into the current namespace and
    is almost always a bad idea. One of the variables could mask an existing one,
    and it goes against the Python best practice of explicit being better than implicit.
    One exception to this rule is if you are using the Python interpreter interactively.
    In this limited context, it may make sense to import all functions from a library
    to cut down on key presses; for example, importing all the math functions (`from
    math import *`) if doing some Python math hacking.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将模块中的所有变量导入到当前命名空间，几乎总是一个坏主意。其中一个变量可能掩盖一个现有的变量，并且违反了Python显示优于隐式的最佳实践。唯一的例外是，如果你在交互式Python解释器中使用。在这种有限的情况下，从库中导入所有函数可能有意义，以减少按键次数；例如，如果进行一些Python数学操作，导入所有数学函数(`from
    math import *`)。
- en: 'If you import a nonstandard library, Python uses `sys.path` to try to find
    it. `sys.path` consists of:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果导入非标准库，Python会使用`sys.path`来尝试找到它。`sys.path`包括：
- en: The directory containing the importing module (current directory)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入模块的目录（当前目录）
- en: The `PYTHONPATH` variable, containing a list of directories
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PYTHONPATH`变量，包含一个目录列表'
- en: The installation-dependent default, where libraries installed using `pip` or
    `easy_install` will usually be placed
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装依赖的默认位置，使用`pip`或`easy_install`安装的库通常会放在这里
- en: 'Big libraries are often packaged, divided into submodules. These submodules
    are accessed by dot notation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 大型库通常被打包分成子模块。这些子模块通过点符号访问：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Packages are constructed from the filesystem via *__init__.py* files, usually
    empty, as shown in [Example 2-1](#pyjs_import). The presence of an init file makes
    the directory visible to Python’s import system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过文件系统构建包，通常是空的`__init__.py`文件，如[示例 2-1](#pyjs_import)所示。有init文件使得目录对Python的导入系统可见。
- en: Example 2-1\. Building a Python package
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-1\. 构建一个Python包
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO2-1)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO2-1)'
- en: You would import this module using `from mypackage.io.tests import test_excel`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`from mypackage.io.tests import test_excel`来导入这个模块。
- en: 'You can access packages on `sys.path` from the root directory (that’s `mypackage`
    in [Example 2-1](#pyjs_import)) using dot notation. A special case of `import`
    is intrapackage references. The `test_excel.py` submodule in [Example 2-1](#pyjs_import)
    can import submodules from the `mypackage` package both absolutely and relatively:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用点符号从根目录（即 [示例 2-1](#pyjs_import) 中的 `mypackage`）访问 `sys.path` 上的包。 `import`
    的一个特例是包内引用。`test_excel.py` 子模块在 [示例 2-1](#pyjs_import) 中可以绝对和相对地从 `mypackage`
    包导入子模块：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO3-1)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO3-1)'
- en: Imports the `test_data.py` module absolutely, from the package’s head directory.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对导入 `test_data.py` 模块，从包的主目录。
- en: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO3-2)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO3-2)'
- en: An explicit (`. import`) and implicit relative import.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 显式（`. import`）和隐式相对导入。
- en: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO3-4)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO3-4)'
- en: A relative import from a sibling package of `tests`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 `tests` 兄弟包的相对导入。
- en: JavaScript Modules
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript模块
- en: 'JavaScript now has modules with import and export of encapsulated variables.
    JS cherry-picked its import syntax, using a lot of stuff that will be familiar
    to Pythonistas but, in my opinion, improving on it. Here’s a brief run-down:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 现在具有模块，可以导入和导出封装的变量。JS挑选了它的导入语法，使用了许多对Python开发者来说很熟悉但在我看来改进了的东西。以下是简要介绍：
- en: 'Let’s say we have a JS entry-point module `index.js`, which wants to use some
    functions or objects from a library module `libFoo.js` in a `lib` directory. The
    file structure looks like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个JS入口模块 `index.js`，它想要使用位于 `lib` 目录中的库模块 `libFoo.js` 中的一些函数或对象。文件结构如下所示：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In `libFoo.mjs` we export a dummy function and can use `export default` to
    export a single object for the module, typically an API with, for example, utility
    methods:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `libFoo.mjs` 中，我们导出一个虚拟函数，并可以使用 `export default` 导出模块的单个对象，通常是一个带有实用方法的API：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO4-1)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO4-1)'
- en: 'An example of object creation with shorthand property name, equivalent to `{findOdds:
    findOdds}`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '使用简写属性名创建对象的示例，相当于 `{findOdds: findOdds}`'
- en: 'To import the exported functions and objects from our index module we use the
    `import` statement, which allows us to import the default API or select exported
    variables by name using curly brackets:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们的索引模块导入导出的函数和对象，我们使用 `import` 语句，它允许我们导入默认的API或通过花括号选择按名称导出的变量：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'JS imports also support aliasing, which can be a great code sanitizer:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: JS导入还支持别名，这可以成为优秀的代码消毒器：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, JavaScript imports and exports are very similar to Python’s,
    though a little more user-friendly in my experience. You can see more details
    in Mozilla’s documentation for [exports](https://oreil.ly/J0aDV) and [imports](https://oreil.ly/slsT5).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，JavaScript的导入和导出与Python非常相似，尽管在我的经验中稍微更加用户友好。你可以在Mozilla的 [exports](https://oreil.ly/J0aDV)
    和 [imports](https://oreil.ly/slsT5) 文档中查看更多细节。
- en: Keeping Your Namespaces Clean
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持您的命名空间干净
- en: 'The variables defined in Python modules are encapsulated, which means that
    unless you import them explicitly (e.g., `from foo import baa`), you will be accessing
    them from the imported module’s namespace using dot notation (e.g., `foo.baa`).
    This modularization of the global namespace is quite rightly seen as a very good
    thing and plays to one of Python’s key tenets: the importance of explicit statements
    over implicit. When analyzing someone’s Python code you should be able to see
    exactly where a class, function, or variable has come from. Just as importantly,
    preserving the namespace limits the chance of conflicting or masking variables—a
    big potential problem as codebases get larger.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Python模块中定义的变量是封装的，这意味着除非你显式地导入它们（例如，`from foo import baa`），否则你将使用点符号从导入的模块命名空间访问它们（例如，`foo.baa`）。全局命名空间的模块化被视为非常好的事情，符合Python的关键原则之一：显式声明的重要性胜过隐式声明。分析某人的Python代码时，你应该能够准确地看到类、函数或变量来自哪里。同样重要的是，保留命名空间限制了变量冲突或遮蔽的可能性——这在代码库变大时是一个很大的潜在问题。
- en: In the past one of the main criticisms of JavaScript, and a fair one, was that
    it played fast and loose with namespace conventions. The most egregious example
    of this is that variables declared outside of functions or missing the `var` keyword^([6](ch02.xhtml#idm45607819371024))
    are global rather than confined to the script in which they are declared. With
    modern, modular JavaScript you get Python-like encapsulation with imported and
    exported variables.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 过去JavaScript的主要批评之一（也是公正的），是其对命名空间约定的快速且不拘一格。其中最突出的例子是，在函数外声明的变量或者缺少`var`关键字^([6](ch02.xhtml#idm45607819371024))，是全局的，而不是限定在其声明所在的脚本内。使用现代化、模块化的JavaScript，你可以像Python一样进行封装，通过导入和导出变量来实现。
- en: JS modules are a relatively recent game changer—a common pattern used in the
    past and one that you may well run into is the creation of a self-calling function
    in order to isolate local variables from the global namespace. This makes all
    variables declared via `var` local to the script/function, preventing them from
    polluting the global namespace. The JavaScript [`let`](https://oreil.ly/cTxOy)
    keyword, which is block-scoped, is pretty much always preferable to `var`. Any
    objects, functions, and variables you want to make available to other scripts
    can be attached to an object that is part of the global namespace.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: JS模块是一个相对较新的游戏变革者——过去常用的一种模式是创建自调用函数，以便将局部变量与全局命名空间隔离开来。这样一来，通过`var`声明的所有变量都将局部化到脚本/函数中，防止它们污染全局命名空间。JavaScript中的[`let`](https://oreil.ly/cTxOy)关键字具有块级作用域，几乎总是优于`var`。你希望在其他脚本中使用的任何对象、函数和变量，都可以附加到全局命名空间的一个对象上。
- en: '[Example 2-2](#pyjs_module) demonstrates a module pattern. The boilerplate
    head and tail (labeled ![1](assets/1.png) and ![3](assets/3.png)) effectively
    create an encapsulated module. This pattern is far from a perfect solution to
    modular JavaScript but was the best compromise I knew of until ECMAScript 6’s
    dedicated import system was adopted by all major browsers.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-2](#pyjs_module)展示了一个模块模式。模板的头部和尾部（标记为 ![1](assets/1.png) 和 ![3](assets/3.png)）有效地创建了一个封装模块。这种模式远非是JavaScript模块化的完美解决方案，但在ECMAScript
    6采用了主流浏览器的专用导入系统之前，它是我所知道的最佳折中方案。'
- en: Example 2-2\. A module pattern for JavaScript
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-2\. JavaScript的模块模式
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO5-1)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO5-1)'
- en: Receives the global `nbviz` object.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接收全局的`nbviz`对象。
- en: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO5-2)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO5-2)'
- en: Attaches the `updateTimeChart` method to the global `nbviz` object, effectively
    *exporting* it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将`updateTimeChart`方法附加到全局的`nbviz`对象上，有效地*导出*它。
- en: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO5-3)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO5-3)'
- en: If an `nbviz` object exists in the global (window) namespace, pass it into the
    module function; otherwise, add it to the global namespace.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果全局（窗口）命名空间中存在`nbviz`对象，则将其传递给模块函数；否则，将其添加到全局命名空间中。
- en: Outputting “Hello World!”
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出“Hello World!”
- en: By far the most popular initial demonstration of any programming language is
    getting it to print or communicate “Hello World!” in some form, so let’s start
    with getting output from Python and JavaScript.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，任何编程语言最受欢迎的初始演示，是在某种形式上打印或传递“Hello World!”，因此让我们从Python和JavaScript的输出开始。
- en: 'Python’s output couldn’t be much simpler:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Python的输出简直不能再简单：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'JavaScript has no print function, but you can log output to the browser console:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript没有打印函数，但你可以将输出记录到浏览器控制台：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Simple Data Processing
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的数据处理
- en: A good way to get an overview of the language differences is to see the same
    function written in both. Examples [2-3](#ex1_py) and [2-4](#ex1_js) show a small,
    contrived example of data munging in Python and JavaScript, respectively. We’ll
    use these to compare Python and JS syntax and label them with capital letters
    (A, B…​) to allow comparison of the code blocks.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解语言差异的一个好方法是查看两种语言中相同功能的编写方式。示例[2-3](#ex1_py)和[2-4](#ex1_js)展示了Python和JavaScript中数据处理的小型构造示例，我们将使用它们来比较Python和JS的语法，并标记为大写字母（A、B...），以便进行代码块比较。
- en: Example 2-3\. Simple data transformation with Python
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-3\. Python的简单数据转换
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Example 2-4\. Simple data munging with JavaScript
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-4\. JavaScript的简单数据处理
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO6-1)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO6-1)'
- en: Note the deliberate and valid inconsistency in the object keys with some quoted
    and some unquoted.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意对象键中有些带引号有些不带引号的故意和有效的不一致性。
- en: String Construction
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串构造
- en: 'The D sections in Examples [2-3](#ex1_py) and [2-4](#ex1_js) show the standard
    way to print output to the console or terminal. JavaScript has no `print` statement
    but will log to the browser’s console through the `console` object:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 [2-3](#ex1_py) 和 [2-4](#ex1_js) 中的 D 部分显示了将输出打印到控制台或终端的标准方法。JavaScript 没有
    `print` 语句，但可以通过 `console` 对象记录到浏览器的控制台：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that the integer variable `id` is coerced to a string, allowing concatenation.
    Python doesn’t perform this implicit coercion, so attempting to add a string to
    an integer in this way gives an error. Instead, explicit conversion to string
    form is achieved through one of the `str` or `repr` functions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，整数变量 `id` 被强制转换为字符串，允许串联。Python 不执行这种隐式强制转换，因此尝试以这种方式将字符串添加到整数会导致错误。而是通过
    `str` 或 `repr` 函数显式转换为字符串形式。
- en: 'In section A of [Example 2-3](#ex1_py), the output string is constructed with
    C type formatting. String (`%s`) and integer (`%d`) placeholders are provided
    by a final tuple (`%(…​)`):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 2-3](#ex1_py) 的 A 部分中，输出字符串是用 C 类型格式化构造的。通过最终的元组 (`%(…​)`) 提供字符串 (`%s`)
    和整数 (`%d`) 占位符：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: These days, I rarely use Python’s `print` statement, opting for the much more
    powerful and flexible `logging` module, which is demonstrated in the following
    code block. It takes a little more effort to use, but it is worth it. Logging
    gives you the flexibility to direct output to a file and/or the screen, adjusting
    the logging level to prioritize certain information, and a whole load of other
    useful things. Check out the details in the [Python documentation](https://oreil.ly/aJzyx).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，我很少使用 Python 的 `print` 语句，而是选择更强大和灵活的 `logging` 模块，在以下代码块中展示。使用它需要更多的努力，但是非常值得。日志记录使您可以灵活地将输出定向到文件和/或屏幕，调整日志级别以优先处理某些信息，以及其他许多有用的功能。在
    [Python 文档](https://oreil.ly/aJzyx) 中查看详细信息。
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO7-1)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO7-1)'
- en: Creates a logger with the name of this module.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个以该模块名称命名的记录器。
- en: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO7-2)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO7-2)'
- en: Setting the logging level to “debug” provides the most detailed information
    available (see the [Python documentation](https://oreil.ly/xAiP1) for further
    details).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将日志级别设置为“debug”提供了可用的最详细信息（参见 [Python 文档](https://oreil.ly/xAiP1) 了解更多详情）。
- en: Significant Whitespace Versus Curly Brackets
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显著的空白与大括号
- en: The syntactic feature most associated with Python is significant whitespace.
    Whereas languages like C and JavaScript use whitespace for readability and could
    easily be condensed into one line,^([7](ch02.xhtml#idm45607813738384)) in Python
    leading spaces are used to indicate code blocks and removing them changes the
    meaning of the code. The extra effort required to maintain correct code alignment
    is more than compensated for by increased readability—you spend far longer reading
    than writing code, and the easy reading of Python is probably the main reason
    why the Python library ecosystem is so healthy. Four spaces is pretty much mandatory
    (see PEP-8) and my personal preference is for what are known as *soft tabs*, where
    your editor inserts (and deletes) multiple spaces instead of a tab character.^([8](ch02.xhtml#idm45607813736320))
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Python 最显著的语法特点是显著的空白。与像 C 和 JavaScript 这样的语言使用空白来增强可读性并可以轻易地压缩成一行不同，^([7](ch02.xhtml#idm45607813738384))
    在 Python 中，前导空格用于指示代码块，移除它们会改变代码的含义。维护正确的代码对齐所需的额外工作远远超过了增加的可读性 —— 你阅读代码的时间远远超过写代码的时间，而
    Python 的易读性可能是 Python 库生态系统如此健康的主要原因。四个空格几乎是强制性的（参见 PEP-8），而我个人偏好所谓的*软制表符*，即你的编辑器插入（和删除）多个空格而不是制表符字符。^([8](ch02.xhtml#idm45607813736320))
- en: In the following code, the indentation of the `return` statement must be four
    spaces by convention:^([9](ch02.xhtml#idm45607813735088))
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`return` 语句的缩进按照惯例必须是四个空格：^([9](ch02.xhtml#idm45607813735088))
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'JavaScript doesn’t care about the number of spaces between statements and variables,
    using curly brackets to demark code blocks; the two doubler functions in this
    code are equivalent:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 不关心语句和变量之间的空格数量，使用大括号来标记代码块；此代码中的两个 doubler 函数是等效的：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Much is made of Python’s whitespace, but most good coders I know set up their
    editors to enforce indented code blocks and a consistent look and feel. Python
    merely enforces this good practice. And, to reiterate, I believe the extreme readability
    of Python code contributes as much to Python’s supremely healthy ecosystem as
    its simple syntax.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的缩进被过分强调，但我认识的大多数优秀编码者都设置了编辑器以强制执行缩进代码块和一致的外观。Python 只是强制执行这种良好的实践。再次强调，我认为
    Python 代码的极高可读性对 Python 极其健康的生态系统贡献了同样多，这与其简单的语法一样重要。
- en: Comments and Doc-Strings
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释和文档字符串
- en: 'To add comments to code, Python uses hashes, *#*:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要向代码添加注释，Python 使用井号（`#`）：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'By contrast, JavaScript uses the C language convention of double backslashes
    (*//*) or */* …​ */* for multiline comments:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，JavaScript 使用 C 语言约定的双反斜杠（`//`）或 `/* ... */` 来进行多行注释：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In addition to comments, and in keeping with its philosophy of readability
    and transparency, Python has documentation strings (doc-strings) by convention.
    The `process_student_data` function in [Example 2-3](#ex1_py) has a triple-quoted
    line of text at its top that will automatically be assigned to the function’s
    `__doc__` attribute. You can also use multiline doc-strings:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 除了注释外，Python 还有文档字符串（doc-strings）的约定，符合其可读性和透明性的哲学。在 [示例 2-3](#ex1_py) 中的 `process_student_data`
    函数顶部有一行三引号的文本，将自动分配给函数的 `__doc__` 属性。你也可以使用多行文档字符串：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Doc-strings are a great habit to get into, particularly if you are working collaboratively.
    They are understood by most decent Python editing toolsets and are also used by
    such automated documentation libraries as [Sphinx](http://sphinx-doc.org). The
    string-literal doc-string is accessible as the `doc` property of a function or
    class.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串是一个很好养成的习惯，特别是在协作工作中。它们被大多数优秀的 Python 编辑工具集所理解，并且也被自动化文档库（如 [Sphinx](http://sphinx-doc.org)）使用。字符串字面量的文档字符串可以作为函数或类的
    `doc` 属性访问。
- en: Declaring Variables Using let or var
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`let`或`var`声明变量
- en: JavaScript uses `let` or `var` to declare variables. Generally speaking, `let`
    is almost always the right choice.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 使用 `let` 或 `var` 来声明变量。一般来说，`let` 几乎总是正确的选择。
- en: Strictly speaking, JS statements should be terminated with a semicolon as opposed
    to Python’s newline. You will see examples where the semicolon is dispensed with,
    and modern browsers will usually do the right thing here. There are a few edge
    cases that could necessitate the use of a semicolon (e.g., it can trip up code
    minifiers and compressors that remove whitespace), but generally I find that the
    loss of clutter and improvement in readability are a worthwhile compromise to
    coding without the semicolons.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，JS 语句应该以分号结尾，而不是 Python 的换行符。你会看到有些例子省略了分号，在现代浏览器中通常不会有问题。有一些边缘情况可能需要使用分号（例如，可能会影响去除空格的代码缩小器和压缩器），但通常来说，减少混乱和提高可读性是一种值得的编码方式，不使用分号。
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: JavaScript has *variable hoisting*, which means variables declared with `var`
    are processed before any other code. This means declaring them anywhere in the
    function is equivalent to declaring them at the top. This can result in weird
    errors and confusion. Explicitly placing `var`s at the top avoids this, but it’s
    better to use the modern `let` and have scoped declarations.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 具有变量提升机制，这意味着使用 `var` 声明的变量会在任何其他代码之前进行处理。这意味着在函数中的任何位置声明它们都等效于在顶部声明它们。这可能导致奇怪的错误和混乱。明确将
    `var` 放在顶部可以避免这种情况，但更好的做法是使用现代的 `let` 并具有作用域声明。
- en: Strings and Numbers
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串和数字
- en: The *name* strings used in the student data (see Section A of Examples [2-3](#ex1_py)
    and [2-4](#ex1_js)) will be interpreted as UCS-2 (the parent of unicode UTF-16)
    in JavaScript,^([10](ch02.xhtml#idm45607813787904)) and Unicode (UTF-8 by default)
    in Python 3.^([11](ch02.xhtml#idm45607813786288))
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，学生数据中使用的 *name* 字符串（参见示例 [2-3](#ex1_py) 和 [2-4](#ex1_js) 的第 A
    部分）将被解释为 UCS-2（unicode UTF-16 的父类）^([10](ch02.xhtml#idm45607813787904))，而在 Python
    3 中将被解释为 Unicode（默认为 UTF-8）^([11](ch02.xhtml#idm45607813786288))。
- en: 'Both languages allow single and double quotes for strings. If you want to include
    a single or double quote in the string, then enclose with the alternative, like
    so:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 两种语言都允许在字符串中使用单引号和双引号。如果要在字符串中包含单引号或双引号，可以使用另一种引号进行封闭，如下所示：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `scores` in Section A of [Example 2-4](#ex1_js) are stored as JavaScript’s
    one numeric type, double-precision 64-bit (IEEE 754) floating-point numbers. Although
    JavaScript has a `parseInt` conversion function, when used with floats,^([12](ch02.xhtml#idm45607813779728))
    it is really just a rounding operator, similar to `floor`. The type of the parsed
    `number` is still `number`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-4](#ex1_js) 中A节中的`scores`以JavaScript的一种数值类型，双精度64位（IEEE 754）浮点数存储。尽管JavaScript有一个`parseInt`转换函数，当与浮点数一起使用时，^([12](ch02.xhtml#idm45607813779728))
    它实际上只是一个舍入操作符，类似于`floor`。解析的`number`的类型仍然是`number`：'
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Python has two numeric types: the 32-bit `int`, to which the student scores
    are cast, and a `float` equivalent (IEE 754) to JS’s `number`. This means that
    Python can represent any integer, whereas JavaScript is more limited.^([13](ch02.xhtml#idm45607815619968))
    Python’s casting changes type:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Python有两种数值类型：32位的`int`，学生分数将被转换为这种类型，以及与JS的`number`相当的`float`（IEE 754）。这意味着Python可以表示任何整数，而JavaScript更为有限。^([13](ch02.xhtml#idm45607815619968))
    Python的强制类型转换会改变类型：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The nice thing about Python and JavaScript numbers is that they are easy to
    work with and usually do what you want. If you need something more efficient,
    Python has the NumPy library, which allows fine-grained control of your numeric
    types (you’ll learn more about NumPy in [Chapter 7](ch07.xhtml#chapter_numpy)).
    In JavaScript, aside from some cutting-edge projects, you’re pretty much stuck
    with 64-bit floats.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Python和JavaScript的数字的好处在于它们易于使用并且通常能够做到你想要的。如果需要更高效的东西，Python有NumPy库，允许精细控制你的数值类型（你将在[第7章](ch07.xhtml#chapter_numpy)学到更多关于NumPy的知识）。在JavaScript中，除了一些前沿项目，你基本上只能使用64位浮点数。
- en: Booleans
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'Python differs from the JavaScript and the C class languages in using named
    Boolean operators. Other than that, they work pretty much as expected. This table
    gives a comparison:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Python在使用命名布尔运算符上与JavaScript和C类语言不同。除此之外，它们的工作方式几乎符合预期。这张表格给出了一个比较：
- en: '| **Python** | `bool` | `True` | `False` | `not` | `and` | `or` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **Python** | `bool` | `True` | `False` | `not` | `and` | `or` |'
- en: '| **JavaScript** | `boolean` | `true` | `false` | `!` | `&&` | &#124;&#124;
    |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| **JavaScript** | `boolean` | `true` | `false` | `!` | `&&` | &#124;&#124;
    |'
- en: Python’s capitalized `True` and `False` is an obvious trip-up for any JavaScripter
    and vice versa, but any decent syntax highlighting should catch that, as should
    your code linter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Python的大写`True`和`False`对任何JavaScript开发者来说都是一个明显的障碍，反之亦然，但是任何良好的语法高亮工具和你的代码检查工具都应该能够捕捉到这一点。
- en: Rather than always returning Boolean true or false, both Python and JavaScript
    `and`/`or` expressions return the result of one of the arguments, which may of
    course be a Boolean value. [Table 2-1](#table0201) shows how this works, using
    Python to demonstrate.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与总是返回布尔值true或false不同，Python和JavaScript的`and`/`or`表达式返回其中一个参数的结果，当然，这个参数可以是布尔值。[表 2-1](#table0201)
    展示了这是如何工作的，使用Python来演示。
- en: Table 2-1\. Python’s Boolean operators
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1\. Python的布尔运算符
- en: '| Operation | Result |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 结果 |'
- en: '| --- | --- |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| x or y | if x is false, then y, else x |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| x or y | 如果x为假，则为y，否则为x |'
- en: '| x and y | if x is false, then x, else y |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| x and y | 如果x为假，则为x，否则为y |'
- en: '| not x | if x is false, then `True`, else `False` |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| not x | 如果x为假，则为`True`，否则为`False` |'
- en: 'This fact allows for some occasionally useful variable assignments:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事实允许偶尔有用的变量赋值：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Data Containers: dicts, objects, lists, Arrays'
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据容器：dicts, objects, lists, Arrays
- en: 'Roughly speaking, JavaScript `objects` can be used like Python `dict`s, and
    Python `list`s like JavaScript arrays. Python also has a tuple container, which
    functions like an immutable list. Here are some examples:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 粗略地说，JavaScript中的`objects`可以像Python中的`dict`s一样使用，而Python中的`list`s则像JavaScript中的数组。Python还有一个元组容器，类似于不可变的列表。以下是一些例子：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As shown in Section A of Examples [2-3](#ex1_py) and [2-4](#ex1_js), while Python’s
    `dict` keys must be quote-marked strings (or hashable types), JavaScript allows
    you to omit the quotes if the property is a valid identifier (i.e., not containing
    special characters such as spaces and dashes). So in our `studentData` objects,
    JS implicitly converts the property `'name'` to string form.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例 [2-3](#ex1_py) 和 [2-4](#ex1_js) 中A节所示，Python的`dict`键必须是用引号括起来的字符串（或可散列类型），而JavaScript允许你在属性是有效标识符（即不包含特殊字符如空格和破折号）时省略引号。所以在我们的`studentData`对象中，JS隐式地将属性`'name'`转换为字符串形式。
- en: The student data declarations look pretty much the same and, in practice, are
    used pretty much the same too. The key difference to note is that while the curly-bracketed
    containers in the JS `studentData` look like Python `dict`s, they are actually
    a shorthand declaration of JS [objects](https://oreil.ly/QTlNc), a somewhat different
    data container.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 学生数据声明看起来非常相似，实际上也基本相同。需要注意的主要区别是，虽然 JS 中 `studentData` 中用花括号括起来的容器看起来像 Python
    的 `dict`，但它们实际上是 JS 对象的一种简写声明，这是一种略有不同的数据容器。
- en: 'In JS data visualization, we tend to use arrays of objects as the chief data
    container and here, JS objects function much as a Pythonista would expect. In
    fact, as demonstrated in the following code, we get the advantage of both dot
    notation and key-string access, the former being preferred where applicable (keys
    with spaces or dashes needing quoted strings):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JS 数据可视化中，我们倾向于使用对象数组作为主要数据容器，在这里，JS 对象的功能与 Python 程序员所期望的功能非常相似。事实上，正如下面的代码所示，我们既获得了点表示法又获得了键字符串访问的优势，前者在适用时更受青睐（需要用引号括起来的键名，如含有空格或破折号的情况）：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It’s good to be aware that although they can be used like Python dictionaries,
    JavaScript objects are much more than just containers (aside from primitives like
    strings and numbers, pretty much everything in JavaScript is an object).^([14](ch02.xhtml#idm45607815328112))
    But in most dataviz examples you see, they are used very much like Python `dict`s.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，虽然 JavaScript 的对象可以像 Python 字典那样使用，但它们实际上远不止于简单的容器（除了像字符串和数字这样的基本类型外，JavaScript
    的几乎所有东西都是对象）。^([14](ch02.xhtml#idm45607815328112)) 但在大多数数据可视化示例中，它们与 Python 的
    `dict` 非常类似。
- en: '[Table 2-2](#table0202) converts basic list operations.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-2](#table0202) 转换基本列表操作。'
- en: Table 2-2\. Lists and arrays
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-2\. 列表和数组
- en: '| JavaScript array (a) | Python list (l) |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| JavaScript 数组（a） | Python 列表（l） |'
- en: '| --- | --- |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `a.length` | `len(l)` |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `a.length` | `len(l)` |'
- en: '| `a.push(item)` | `l.append(item)` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `a.push(item)` | `l.append(item)` |'
- en: '| `a.pop()` | `l.pop()` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `a.pop()` | `l.pop()` |'
- en: '| `a.shift()` | `l.pop(0)` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `a.shift()` | `l.pop(0)` |'
- en: '| `a.unshift(item)` | `l.insert(0, item)` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `a.unshift(item)` | `l.insert(0, item)` |'
- en: '| `a.slice(start, end)` | `l[start:end]` |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `a.slice(start, end)` | `l[start:end]` |'
- en: '| `a.splice(start, howMany, i1, …​)` | `l[start:end] = [i1, …​]` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `a.splice(start, howMany, i1, …​)` | `l[start:end] = [i1, …​]` |'
- en: Functions
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: 'The B sections of Examples [2-3](#ex1_py) and [2-4](#ex1_js) show a function
    declaration. Python uses `def` to indicate a function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 例子 [2-3](#ex1_py) 和 [2-4](#ex1_js) 的 B 部分展示了函数声明。Python 使用 `def` 表示函数：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'whereas JavaScript uses `function`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 而 JavaScript 使用 `function`：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Both have a list of parameters. With JS, the function code block is indicated
    by the curly brackets { …​ }; with Python, the code block is defined by a colon
    and indentation.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都有参数列表。在 JS 中，函数的代码块用花括号 { …​ } 表示；在 Python 中，代码块由冒号和缩进定义。
- en: 'JS has an alternative way of defining a function called the *function expression*,
    which you may see in this example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: JS 还有一种称为 *函数表达式* 的定义函数的替代方式，你可以在这个例子中看到：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'There is now a shortened form, which is becoming more popular:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一种更受欢迎的简化形式：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The differences are subtle enough not to worry about for now.^([15](ch02.xhtml#idm45607815158832))
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些差异现在可以不用担心。
- en: Function parameters is an area where Python’s handling is more sophisticated
    than JavaScript’s. As you can see in `process_student_data` (Section B in [Example 2-3](#ex1_py)),
    Python allows default arguments for the parameters. In JavaScript, all parameters
    not used in the function call are declared as *undefined*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数是一个领域，Python 处理比 JavaScript 更为复杂。正如你在 `process_student_data`（例子 2-3 中的 B
    部分）中看到的那样，Python 允许参数有默认值。在 JavaScript 中，所有未在函数调用中使用的参数都声明为 *undefined*。
- en: 'Iterating: for Loops and Functional Alternatives'
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历：for 循环和函数式替代方法
- en: The C sections in Examples [2-3](#ex1_py) and [2-4](#ex1_js) shows our first
    key difference between Python and JavaScript—their handling of `for` loops.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 例子 [2-3](#ex1_py) 和 [2-4](#ex1_js) 的 C 部分展示了 Python 和 JavaScript 之间第一个关键差异 ——
    它们对 `for` 循环的处理方式。
- en: 'Python’s `for` loops are simple, intuitive, and effective on any iterator,
    such as arrays and `dict`s. One gotcha with `dict`s is that standard iteration
    is by key, not items. For example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `for` 循环对任何迭代器（如数组和 `dict`）都是简单直观且高效的。`dict` 的一个需要注意的地方是，标准迭代是按键而非项进行的。例如：
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To iterate over the key-value pairs, use the `dict`’s `items` method like so:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 若要遍历键值对，使用 `dict` 的 `items` 方法，如下所示：
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can assign the key-values in the `for` statement for convenience. For example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `for` 语句中方便地分配键值对。例如：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Because Python’s `for` loop works on anything with the correct iterator plumbing,
    you can do cool things like loop over file lines:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Python的`for`循环适用于具有正确迭代器管道的任何内容，所以您可以做一些很酷的事情，比如循环遍历文件行：
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Coming from Python, JS’s `for` loop is a pretty horrible, unintuitive thing.
    Here’s an example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从Python过来的人来说，JS的`for`循环是一件相当可怕和不直观的事情。以下是一个例子：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: JS’s `for .. in` returns the index of the array’s items, not the items themselves.
    To compound matters, for the Pythonista, the order of iteration is not guaranteed,
    so the indices could be returned in nonconsecutive order.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: JS的`for .. in`返回数组项的索引，而不是数组项本身。更糟糕的是，对于Pythonista来说，迭代的顺序不能保证，因此索引可能以非连续的顺序返回。
- en: Shifting between Python and JS `for` loops is hardly seamless, demanding you
    keep on the ball. The good news is that you hardly need to use JS `for` loops
    these days. In fact, I almost never find the need. That’s because JS has recently
    acquired some very powerful first-class functional abilities, which have more
    expressive power and less scope for confusion with Python and, once you get used
    to them, quickly become indispensable.^([16](ch02.xhtml#idm45607802789056))
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python和JS的`for`循环之间进行切换几乎没有无缝衔接，要求您保持警觉。好消息是，这些日子几乎不需要使用JS的`for`循环。事实上，我几乎从不需要。这是因为JS最近获得了一些非常强大的一流函数能力，这些能力具有更高的表达能力，且与Python的混淆机会更少，一旦您习惯了它们，很快就变得不可或缺。^([16](ch02.xhtml#idm45607802789056))
- en: Section C in [Example 2-4](#ex1_js) demonstrates `forEach()`, one of the *functional*
    methods available to modern JavaScript arrays.^([17](ch02.xhtml#idm45607802786192))
    `forEach()` iterates over the array’s items, sending them in turn to an anonymous
    callback function defined in the first argument, where they can be processed.
    The true expressive power of these functional methods comes from chaining them
    (maps, filters, etc.), but already we have a cleaner, more elegant iteration with
    none of the awkward bookkeeping of old.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-4](#ex1_js)中的第C部分展示了现代JavaScript数组可用的*功能*方法之一，即`forEach()`。`forEach()`迭代数组项，依次将它们发送到第一个参数中定义的匿名回调函数中，其中可以处理它们。这些功能方法的真正表现力来自它们的链式调用（映射、过滤等），但是现在我们已经有了更清洁、更优雅的迭代，没有旧方法的笨重记录。'
- en: 'The callback function receives the index and the original array as an optional
    second argument:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数可以选择性地接收索引和原始数组作为第二个参数：
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Until recently even iterating over an `object`’s key-value pairs was fairly
    tricky. Unlike Python’s `dict`s, `object`s could have inherited properties from
    the prototyping chain, so you had to use a `hasOwnProperty` guard to filter these
    out. You may well come across code like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，即使是迭代`object`的键值对也是相当棘手的。不像Python的`dict`，`object`可能会从原型链继承属性，所以您必须使用`hasOwnProperty`保护来过滤这些属性。您可能会遇到这样的代码：
- en: '[PRE48]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Whereas JS arrays have a set of native functional iterator methods (`map`,
    `reduce`, `filter`, `every`, `sum`, `reduceRight`), `object`s—in their guise as
    pseudodictionaries—don’t. The good news is that the `object` class has recently
    acquired some useful additional methods that fill this gap. So you can iterate
    through the key-value pairs using the `entries` method:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JS数组有一组本地功能迭代器方法（`map`、`reduce`、`filter`、`every`、`sum`、`reduceRight`），`object`作为伪字典的外观则没有。好消息是，`object`类最近新增了一些有用的附加方法来填补这一空白。因此，您可以使用`entries`方法迭代键值对：
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO8-1)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO8-1)'
- en: Note the string template form `${foo}` for printing variables.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`${foo}`这种形式的字符串模板，用于打印变量。
- en: 'Conditionals: if, else, elif, switch'
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件语句：if, else, elif, switch
- en: Section C in Examples [2-3](#ex1_py) and [2-4](#ex1_js) shows Python and JavaScript
    conditionals in action. Aside from JavaScript’s use of brackets, the statements
    are very similar; the only real difference being Python’s extra `elif` keyword,
    a convenient conjunction of `else if`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的第C部分展示了Python和JavaScript条件语句的应用，分别为[2-3](#ex1_py)和[2-4](#ex1_js)。除了JavaScript使用括号外，语句非常相似；唯一的真正区别是Python额外的`elif`关键字，一个方便的`else
    if`联合体。
- en: 'Though much requested, Python does not have the `switch` statement found in
    most high-level languages. JS does, allowing you to do this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有很多请求，Python没有像大多数高级语言中那样的`switch`语句。JS有，允许您做到这一点：
- en: '[PRE50]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The good news for Pythonistas is that with 3.10 Python gets a very powerful
    pattern-matching conditional that can function as a `switch` statement but do
    a [whole lot more](https://oreil.ly/5x76a). So we can do this to switch between
    cases:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python 爱好者来说，好消息是在 3.10 版本中，Python 获得了一个非常强大的模式匹配条件，可以作为 `switch` 语句使用，但可以做的事情远不止于此。因此，我们可以这样在不同情况之间进行切换：
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: File Input and Output
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件输入和输出
- en: 'Browser-based JavaScript has no real equivalent of file input and output (I/O),
    but Python’s is as simple as could be:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 基于浏览器的 JavaScript 没有真正等效的文件输入和输出（I/O），但 Python 的实现非常简单：
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'One much recommended best practice is to use Python’s `with`, `as` context
    manager when opening files. This ensures they are closed automatically when leaving
    the block, essentially providing [syntactic sugar](https://oreil.ly/DPxaM) for
    a `try`, `except`, `finally` block. Here’s how to open a file using `with`, `as`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一个被强烈推荐的最佳实践是在打开文件时使用 Python 的 `with`, `as` 上下文管理器。这确保在离开代码块时自动关闭文件，本质上为 `try`,
    `except`, `finally` 块提供了语法糖。这里是使用 `with`, `as` 打开文件的方式：
- en: '[PRE53]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'JavaScript does, however, have the roughly analogous `fetch` method for fetching
    a resource from the network, based on its URL. So to fetch a dataset from the
    website’s server, in the *static/data* directory you do this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JavaScript 也有大致相似的 `fetch` 方法，用于从网络上获取资源，基于其 URL。因此，要从网站服务器获取数据集，在 *static/data*
    目录下执行如下操作：
- en: '[PRE54]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The [Fetch API](https://oreil.ly/OFjns) is thoroughly documented at Mozilla.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[Fetch API](https://oreil.ly/OFjns) 在 Mozilla 上有详细的文档。'
- en: Classes and Prototypes
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和原型
- en: Possibly the cause of more confusion that any other topic is JavaScript’s choice
    of prototypes rather than classical classes as its chief object-oriented programming
    (OOP) element. This does require some adaption for a Pythonista, where classes
    are ubiquitous, but in practice this learning curve is, in my experience, short
    and fairly shallow.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 可能比任何其他主题更容易引起混淆的是 JavaScript 选择原型而不是经典类作为其主要的面向对象编程（OOP）元素。对于 Python 程序员来说，这确实需要一些适应，因为在
    Python 中类是无处不在的，但实际上，根据我的经验，这种学习曲线是短暂且相对浅显的。
- en: I remember, when I first started my forays into more advanced languages like
    C++, falling for the promise of OOP, particularly class-based inheritance. Polymorphism
    was all the rage and shape classes were being subclassed to rectangles and ellipses,
    which were in turn subclassed to more specialized squares and circles.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得，当我第一次开始涉足像 C++ 这样更高级的语言时，迷上了面向对象编程的承诺，特别是基于类的继承。多态性当时非常流行，形状类被子类化为矩形和椭圆，这些又进一步被特化为更专门的正方形和圆形。
- en: It didn’t take long to realize that the clean class divisions found in the textbooks
    were rarely found in real programming and that trying to balance generic and specific
    APIs quickly became fraught. In this sense, I find composition and mix-ins much
    more useful as programming concepts than attempts at extended subclassing, and
    often avoid all these by using functional programming techniques, particularly
    in JavaScript. Nevertheless, the class/prototype distinction is an obvious difference
    between the two languages, and the more you understand its nuances, the better
    you’ll code.^([18](ch02.xhtml#idm45607802261472))
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 很快就意识到，在教科书中清晰的类划分在实际编程中很少能找到，并且尝试平衡通用和特定的 API 很快变得复杂。从这个意义上说，我发现组合和混合比尝试扩展子类化更有用作为编程概念，通常通过使用
    JavaScript 中的函数式编程技术来避免所有这些问题。尽管如此，类/原型区别是两种语言之间明显的差异，你理解其细微差别的越多，编码能力就会越好。^([18](ch02.xhtml#idm45607802261472))
- en: 'Python’s classes are fairly simple affairs and, as with most of the language,
    easy to use. I tend to think of them these days as a handy way to encapsulate
    data with a convenient API, and rarely extend subclassing beyond one generation.
    Here’s a simple example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的类非常简单，并且和大多数语言一样容易使用。我现在倾向于将它们视为一种方便的方式来封装数据并提供方便的 API，很少扩展子类化超过一代。这里有一个简单的示例：
- en: '[PRE55]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO9-1)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO9-1)'
- en: Python classes have a number of double-underscored special methods, `__init__`
    being the most common, called when the class instance is created. All instance
    methods have a first, explicit `self` argument (you could name it something else,
    but it’s a very bad idea), which refers to the instance. In this case, we use
    it to set name and country properties.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Python类有许多双下划线的特殊方法，`__init__`是最常见的，当创建类实例时调用。所有实例方法都有一个显式的第一个`self`参数（你可以给它取其他名字，但这是一个非常糟糕的主意），它指的是实例本身。在这种情况下，我们用它来设置名称和国家属性。
- en: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO9-2)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO9-2)'
- en: You can override the class’s string method, which is used when the `print` function
    is called on an instance.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以覆盖类的字符串方法，在调用实例的`print`函数时使用。
- en: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO9-3)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO9-3)'
- en: Creates a new `Citizen` instance, initialized with name and country.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个带有名称和国家的新`Citizen`实例。
- en: 'Python follows a fairly classical pattern of class inheritance. It’s easy to
    do, which is probably why Pythonistas make a lot of use of it. Let’s customize
    the `Citizen` class to create a (Nobel Prize) `Winner` class with a couple of
    extra properties:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Python遵循了一种相当经典的类继承模式。这很容易做到，这可能是Python程序员大量使用它的原因。让我们自定义`Citizen`类来创建一个（诺贝尔奖）`Winner`类，并添加几个额外的属性：
- en: '[PRE56]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO10-1)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO10-1)'
- en: We want to reuse the superclass `Citizen’s` `__init__` method, using this `Winner`
    instance as `self`. The `super` method scales the inheritance tree one branch
    from its first argument, supplying the second as instance to the class-instance
    method.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要重用超类`Citizen`的`__init__`方法，使用这个`Winner`实例作为`self`。`super`方法将继承树从其第一个参数扩展一个分支，并将第二个参数作为类实例方法的实例。
- en: 'I think the best article I have read on the key difference between JavaScript’s
    prototypes and classical classes is Reginald Braithwaite’s [“OOP, JavaScript,
    and so-called Classes”](https://oreil.ly/92Kxk). This quote sums up the difference
    between classes and prototypes as nicely as any I’ve found:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我读过的关于JavaScript原型和经典类之间主要区别的最佳文章是Reginald Braithwaite的[“OOP, JavaScript,
    and so-called Classes”](https://oreil.ly/92Kxk)。这段引文很好地总结了类和原型之间的区别：
- en: The difference between a prototype and a class is similar to the difference
    between a model home and a blueprint for a home.
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原型（prototype）和类之间的区别类似于模型房屋和家庭蓝图之间的区别。
- en: When you instantiate a C++ or Python class, a blueprint is followed, creating
    an object and calling its various constructors in the inheritance tree. In other
    words, you start from scratch and build a nice, pristine new class instance.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实例化一个C++或Python类时，会遵循一个蓝图，创建一个对象并调用其继承树中的各种构造函数。换句话说，你是从头开始构建一个漂亮、崭新的类实例。
- en: With JavaScript prototypes, you start with a model home (object) that has rooms
    (methods). If you want a new living room, you can just replace the old one with
    something in better colors. If you want a new conservatory, then just make an
    extension. But rather than building from scratch with a blueprint, you’re adapting
    and extending an existing object.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript原型，你从一个有房间（方法）的模型房屋（对象）开始。如果你想要一个新的客厅，你可以用更好颜色的东西替换旧的。如果你想要一个新的温室，那么只需做一个扩展。但与蓝图从头开始构建不同，你是在适应和扩展现有对象。
- en: With that necessary theory out of the way and the reminder that object inheritance
    is useful to know but hardly ubiquitous in dataviz, let’s see a simple JavaScript
    prototype object in [Example 2-5](#bridge_citizen_js).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在搞定了必要的理论并提醒对象继承虽然有用但在数据可视化中并不普遍的情况下，让我们来看一个简单的JavaScript原型对象示例[Example 2-5](#bridge_citizen_js)。
- en: Example 2-5\. A simple JavaScript object
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-5. 一个简单的JavaScript对象
- en: '[PRE57]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO11-1)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO11-1)'
- en: This function is essentially an initializer, invoked by the `new` operator.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数本质上是一个初始化器，由`new`运算符调用。
- en: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO11-2)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO11-2)'
- en: '`this` is an implicit reference to the *calling context* of the function. For
    now, it behaves as you would expect and even though it looks a little like Python’s
    `self`, the two are quite different, as we’ll see.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`this` 是函数调用上下文的隐式引用。就目前而言，它的行为与预期相符，尽管它看起来有点像 Python 的 `self`，但它们是完全不同的，我们稍后会看到。'
- en: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO11-3)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO11-3)'
- en: The methods specified here will both override any prototypical methods up the
    inheritance chain and be inherited by any objects derived from `Citizen`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 此处指定的方法将覆盖继承链上所有原型方法，并被从 `Citizen` 派生的任何对象继承。
- en: '[![4](assets/4.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO11-4)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO11-4)'
- en: '`new` is used to create a new object, set its prototype to that of the `Citizen`
    constructor function, and then call the `Citizen` constructor function on the
    new object.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`new` 用于创建一个新对象，将其原型设置为 `Citizen` 构造函数的原型，然后在新对象上调用 `Citizen` 构造函数。'
- en: 'JavaScript has recently acquired some [syntactic sugar](https://oreil.ly/43NXG)
    allowing classes to be declared. This essentially wraps the object-based form
    (see [Example 2-5](#bridge_citizen_js)) in something more familiar to programmers
    coming from `class`-based languages like Java and C#. I think it’s fair to say
    that classes haven’t really taken off in frontend, browser-based JavaScript, having
    been usurped somewhat by new frameworks with an emphasis on reusable components
    (e.g., React, Vue, Svelte). Here’s how we would implement the `Citizen` `Object`
    shown in [Example 2-5](#bridge_citizen_js):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 最近获得了一些[语法糖](https://oreil.ly/43NXG)，允许声明类。这本质上包装了面向对象形式（参见 [示例 2-5](#bridge_citizen_js)）以更加熟悉的形式呈现，如来自类似
    Java 和 C# 的编程语言的程序员。我认为可以说，在前端、基于浏览器的 JavaScript 中，类并没有真正流行起来，有点被强调可重用组件的新框架（如
    React、Vue、Svelte）所取代。这是我们如何实现 [示例 2-5](#bridge_citizen_js) 中展示的 `Citizen` 对象的方式：
- en: '[PRE58]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: I included [Example 2-5](#bridge_citizen_js), which shows `new` in JavaScript
    object instantiation, because you will run into its use a fair deal. But the syntax
    is already a little awkward and gets quite a bit worse when you try to do inheritance.
    ECMAScript 5 introduced the `Object.create` method, a better way to create objects
    and to implement inheritance. I’d recommend using it in your own code, but `new`
    will probably crop up in some third-party libraries.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我包含了 [示例 2-5](#bridge_citizen_js)，展示了 JavaScript 对象实例化中的 `new` 使用，因为你会经常遇到它的使用。但语法已经有点笨拙，当你尝试进行继承时会变得更糟。ECMAScript
    5 引入了 `Object.create` 方法，这是创建对象和实现继承的更好方式。我建议在你自己的代码中使用它，但是 `new` 可能会在一些第三方库中出现。
- en: Let’s use `Object.create` to create a `Citizen` and its `Winner` inheritor.
    To emphasize, JavaScript has many ways to do this, but [Example 2-6](#bridge_prototype_inheritance)
    shows the cleanest I have found and my personal pattern.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `Object.create` 创建一个 `Citizen` 及其 `Winner` 子类。强调一下，JavaScript 有很多方法可以做到这一点，但
    [示例 2-6](#bridge_prototype_inheritance) 展示了我找到的最干净的方法和我的个人模式。
- en: Example 2-6\. Prototypical inheritance with `Object.create`
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-6\. 使用 `Object.create` 进行原型继承
- en: '[PRE59]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO12-1)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO12-1)'
- en: '`Citizen` is now an object rather than a constructor function. Think of this
    as the base house for any new buildings such as `Winner`.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`Citizen` 现在是一个对象，而不是构造函数。将其视为任何新建筑（如 `Winner`）的基础。'
- en: To reiterate, prototypical inheritance is not seen that often in JavaScript
    dataviz, particularly the 800-pound gorilla D3 with its emphasis on declarative
    and functional patterns, with *raw* unencapsulated data being used to stamp its
    impression on the web page.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，原型继承在 JavaScript 数据可视化中并不常见，特别是在以声明式和函数式模式为重点的 800 磅大猩猩 D3 中，原始的未封装数据被用来在网页上留下印记。
- en: The tricky class/prototype comparison concludes this section on basic syntactic
    differences. Now let’s look at some common patterns seen in dataviz work with
    Python and JS.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分关于基本语法差异的内容，将以棘手的类/原型比较作结。现在让我们看看 Python 和 JS 数据可视化工作中常见的一些模式。
- en: Differences in Practice
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践中的差异
- en: The syntactic differences between JS and Python are important to know and are
    thankfully outweighed by their syntactic similarities. The meat and potatoes of
    imperative programming, loops, conditionals, data declaration, and manipulation
    is much the same. This is all the more so in the specialized domain of data processing
    and data visualization where the languages’ first-class functions allow common
    idioms.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: JS 和 Python 的语法差异很重要，必须了解，幸运的是它们的语法相似性超过了差异。命令式编程的核心部分，循环、条件语句、数据声明和操作大体相同。在数据处理和数据可视化的专业领域，语言的一级函数允许常见习惯用法更加突出。
- en: What follows is a less-than-comprehensive list of some important patterns and
    idioms seen in Python and JavaScript, from the perspective of a data visualizer.
    Where possible, a translation between the two languages is given.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是从数据可视化师的视角看到的 Python 和 JavaScript 中一些重要模式和习惯用法的非全面列表。在可能的情况下，给出了两种语言之间的翻译。
- en: Method Chaining
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法链
- en: 'A common JavaScript idiom is *method chaining*, popularized by its most-used
    library, jQuery, and much used in D3\. Method chaining involves returning an object
    from its own method in order to call another method on the result, using dot notation:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的常见习语是 *方法链*，它由最常用的库 jQuery 推广，并且在 D3 中被广泛使用。方法链涉及从自己的方法返回一个对象，以便在结果上调用另一个方法，使用点符号表示：
- en: '[PRE60]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO13-1)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO13-1)'
- en: The `attr` method returns the D3 selection that called it, which is then used
    to call another `attr` method.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`attr` 方法返回调用它的 D3 选择器，然后用于调用另一个 `attr` 方法。'
- en: Method chaining is not much seen in Python, which generally advocates one statement
    per line in keeping with simplicity and readability.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中很少见到方法链，因为它通常主张每行只有一个语句，以保持简单和可读性。
- en: Enumerating a List
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举列表
- en: 'Often it’s useful to iterate through a list while keeping track of the item’s
    index. Python has the very handy built-in `enumerate` function for just this reason:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 经常需要在遍历列表时跟踪项的索引。Python 有一个非常方便的内置函数 `enumerate` 正是为了这个原因：
- en: '[PRE61]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'JavaScript’s list methods, such as `forEach` and the functional `map`, `reduce`,
    and `filter`, supply the iterated item and its index to the callback function:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的列表方法，如 `forEach` 和函数式的 `map`、`reduce` 和 `filter`，向回调函数提供迭代的项及其索引：
- en: '[PRE63]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Tuple Unpacking
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组解包
- en: 'One of the first cool tricks Python initiates uses tuple unpacking to switch
    variables:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Python 最初采用的一个很酷的技巧是使用元组解包来交换变量：
- en: '[PRE65]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Note that the brackets are optional. This can be put to more practical purpose
    as a way of reducing the temporary variables, such as in a [Fibonacci function](https://oreil.ly/OAT8Q):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意括号是可选的。这可以更实际地用作减少临时变量的一种方法，例如在 [斐波那契函数](https://oreil.ly/OAT8Q) 中：
- en: '[PRE66]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If you want to ignore one of the unpacked variables, use an underscore:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想忽略其中一个解包的变量，可以使用下划线：
- en: '[PRE67]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO14-1)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO14-1)'
- en: 'Python 3 has an [* operator](https://oreil.ly/MFjiR) that means, in this case,
    we could unpack our variables with this: `name, *_, nationality = winner`'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3 有一个 [* 操作符](https://oreil.ly/MFjiR)，在这种情况下，我们可以使用它来解包我们的变量：`name, *_,
    nationality = winner`
- en: 'The JavaScript language is adapting rapidly and has recently acquired some
    very powerful [destructuring abilities](https://oreil.ly/97rbT). With the addition
    of the *spread operator* (`...`), this enables some very succinct data manipulation:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 语言正在迅速适应，并最近获得了一些非常强大的 [解构能力](https://oreil.ly/97rbT)。通过添加 *展开操作符*
    (`...`)，这使得一些非常简洁的数据操作成为可能：
- en: '[PRE68]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO15-1)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO15-1)'
- en: Unlike in Python, you still need to declare any variables you are going to use.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 不像 Python，你仍然需要声明你将要使用的任何变量。
- en: Collections
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: 'One of the most useful Python “batteries” is the `collections` module. This
    provides some specialized container datatypes to augment Python’s standard set.
    It has a `deque`, which provides a list-like container with fast appends and pops
    at either end; an `OrderedDict`, which remembers the order entries were added;
    a `defaultdict`, which provides a factory function to set the dictionary’s default;
    and a `Counter` container for counting hashable objects, among others. I find
    myself using the last three a lot. Here are a few examples:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中最有用的一个“电池”是 `collections` 模块。它提供了一些专门的容器数据类型来增强 Python 的标准集合。它有一个 `deque`，提供了一个类似列表的容器，在两端快速添加和弹出；一个
    `OrderedDict`，记住添加条目的顺序；一个 `defaultdict`，提供一个设置字典默认值的工厂函数；以及一个 `Counter` 容器，用于计数可散列对象，等等。我经常使用最后三个。以下是一些示例：
- en: '[PRE69]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO16-1)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO16-1)'
- en: Sets the dictionary default to an integer, with value 0 by default.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 将字典默认设置为整数，默认值为 0。
- en: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO16-2)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO16-2)'
- en: If the item-key doesn’t exist, its value is set to the default of 0 and 1 added
    to that.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目键不存在，则将其值设置为默认值 0 并添加 1。
- en: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO16-3)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO16-3)'
- en: Gets the list of items in the dictionary `d` as key-value tuple pairs, sorts
    using the integer value, and then creates an `OrderedDict` with the sorted list.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 获取字典 `d` 中项目的键值对列表，按整数值排序，然后创建一个排序后列表的 `OrderedDict`。
- en: '[![4](assets/4.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO16-4)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO16-4)'
- en: The `OrderedDict` remembers the (sorted) order of the items as they were added
    to it.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderedDict` 记住了添加到其中的项目的（排序后的）顺序。'
- en: You can get more details on the `collections` module in the [Python documentation](https://oreil.ly/IOK7c).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [Python 文档](https://oreil.ly/IOK7c) 中获取有关 `collections` 模块的更多详细信息。
- en: If you want to replicate some of Python’s `collections` function using more
    conventional JavaScript libraries, Underscore (or its functionally identical replacement
    Lodash^([20](ch02.xhtml#idm45607800747696))) is a good place to start. These libraries
    offer some enhanced functional programming utilities. Let’s take a quick look
    at this very handy tool.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用更常规的 JavaScript 库复制一些 Python 的 `collections` 函数，Underscore（或其功能上完全相同的替代品
    Lodash^([20](ch02.xhtml#idm45607800747696)）是一个很好的起点。这些库提供了一些增强的函数式编程工具。让我们快速看看这个非常方便的工具。
- en: Underscore
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下划线
- en: 'Underscore is probably the most popular JavaScript library after the ubiquitous
    jQuery and offers a bevy of functional programming utilities for the JavaScript
    dataviz programmer. The easiest way to use Underscore is to use a content delivery
    network (CDN) to load it remotely (these loads will be cached by your browser,
    making things very efficient for common libraries), like so:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore 可能是继普及的 jQuery 后最受欢迎的 JavaScript 库，为 JavaScript 数据可视化程序员提供了大量的函数式编程工具。使用
    Underscore 的最简单方法是使用内容传递网络（CDN）远程加载它（这些加载将由您的浏览器缓存，使常见库非常高效），如下所示：
- en: '[PRE70]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Underscore has loads of useful functions. There is, for example, a `countBy`
    method, which serves the same purpose as the Python’s `collections` counter just
    discussed:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore 有大量有用的函数。例如，有一个 `countBy` 方法，其作用与刚讨论的 Python 的 `collections` 计数器相同：
- en: '[PRE71]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO17-1)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO17-1)'
- en: Now you see why the library is called Underscore.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道为什么这个库叫 Underscore 了。
- en: As we’ll now see, the inclusion in modern JavaScript of native functional methods
    (`map`, `reduce`, `filter`) and a `forEach` iterator for arrays has made Underscore
    slightly less indispensable, but it still has some great utilities to augment
    vanilla JS. With a little chaining, you can produce extremely terse but very powerful
    code. Underscore was my introduction to functional programming in JavaScript,
    and the idioms are just as appealing today. Check out Underscore’s repertoire
    of utilities on [their website](https://underscorejs.org).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到，现代 JavaScript 中原生的函数方法（`map`、`reduce`、`filter`）以及数组的 `forEach` 迭代器使得
    Underscore 稍显不那么必不可少，但它仍然具有一些非常棒的实用工具来增强原生 JS。稍加链式操作，你可以编写极为简洁但非常强大的代码。Underscore
    是我在 JavaScript 中接触函数式编程的入门，这些习惯如今依然令人着迷。请访问[它们的网站](https://underscorejs.org)查看
    Underscore 的各种实用工具。
- en: 'Let’s have a look at Underscore in action, tackling a more involved task:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Underscore 在更复杂任务中的应用：
- en: '[PRE72]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO18-1)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO18-1)'
- en: Our array of morning times arrays (`[[44, 34, 56, 31], [33...]]`) needs to be
    *flattened* into a single array of numbers.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的早晨时间数组（`[[44, 34, 56, 31], [33...]]`）需要 *展平* 成一个单一的数字数组。
- en: Functional Array Methods and List Comprehensions
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式数组方法和列表推导式
- en: I find myself using Underscore a lot less since the addition, with ECMAScript
    5, of functional methods to JavaScript arrays. I don’t think I’ve used a conventional
    `for` loop since then, which, given the ugliness of JS `for` loops, is a very
    good thing.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 ECMAScript 5 加入 JavaScript 数组的函数方法以来，我使用 Underscore 的频率大大减少。我认为自那时起我几乎没有再使用传统的
    `for` 循环，考虑到 JS `for` 循环的丑陋程度，这是一件非常好的事情。
- en: 'Once you get used to processing arrays functionally, it’s hard to consider
    going back. Combined with JS’s anonymous functions, it makes for very fluid, expressive
    programming. It’s also an area where method chaining seems very natural. Let’s
    look at a highly contrived example:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你习惯了函数式处理数组，就很难再考虑回到以前。结合 JS 的匿名函数，它使得编程变得非常流畅和表达力强。这也是方法链在这里显得非常自然的一个领域。让我们看一个高度刻意的例子：
- en: '[PRE73]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO19-1)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO19-1)'
- en: Filters the list for odd numbers (i.e., returning `1` for the `modulus (%) 2`
    operation).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤列表以获取奇数（即对 `modulus (%) 2` 操作返回 `1`）。
- en: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO19-2)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO19-2)'
- en: '`map` produces a new list by applying a function to each member (i.e., `[1,
    3, 5...]` → `[1, 9, 25...]`).'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 通过将函数应用于每个成员来生成新列表（即 `[1, 3, 5...]` → `[1, 9, 25...]`）。'
- en: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO19-3)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO19-3)'
- en: '`reduce` processes the resultant mapped list in sequence, providing the current
    (in this case, summed) value (`total`) and the item value (`current`). By default,
    the initial value of the first argument (`total`) is `0` but we provide it explicitly
    here, as the second argument.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce` 逐个处理映射后的列表，依次提供当前值（在此例中为求和后的值 `total`）和项目值（`current`）。默认情况下，第一个参数（`total`）的初始值为
    `0`，但在这里我们显式地提供了它作为第二个参数。'
- en: 'Python’s powerful list comprehensions can emulate the previous example easily
    enough:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Python 强大的列表推导式可以轻松模拟上一个例子：
- en: '[PRE74]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO20-1)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO20-1)'
- en: Python has a handy built-in `range` function, which can also take a start, end,
    and step (e.g., range(2, 8, 2) → (2, 4, 6)).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有一个方便的内置 `range` 函数，也可以接受起始、结束和步长（例如，`range(2, 8, 2)` → `(2, 4, 6)`）。
- en: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO20-2)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO20-2)'
- en: The `if` condition tests for oddness of `x`, and any numbers passing this filter
    are squared and inserted into the list.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 条件检测 `x` 的奇数性，并将通过此筛选的数字进行平方并插入列表。'
- en: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO20-3)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO20-3)'
- en: Python also has a built-in and often used `sum` statement.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还有一个内置且经常使用的 `sum` 语句。
- en: Tip
  id: totrans-362
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Python’s list comprehensions can use recursive control structures, such as applying
    a second `for`/`if` expression to the iterated items. Although this can create
    terse and powerful lines of code, it goes against the grain of Python’s readability
    and I discourage its use. Even simple list comprehensions are less than intuitive
    and, as much as it appeals to the leet hacker in all of us, you risk creating
    incomprehensible code.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的列表推导可以使用递归控制结构，比如在迭代项目上应用第二个`for`/`if`表达式。虽然这可以创建简洁而强大的代码行，但它违背了 Python
    的可读性，我不鼓励其使用。即使简单的列表推导也不够直观，并且，尽管它吸引了我们所有人内心深处的精英黑客，你可能会写出难以理解的代码。
- en: Python’s list comprehensions work well for basic filtering and mapping. They
    do lack the convenience of JavaScript’s anonymous functions (which are fully fledged,
    with their own scope, control blocks, exception handling, etc.), but there are
    arguments against the use of anonymous functions. For example, they are not reusable
    and, being unnamed, they make it hard to follow exceptions and debug. See [Ultimate
    Courses](https://oreil.ly/7u1j6) for some persuasive arguments. Having said that,
    for libraries like D3, replacing the small, throwaway anonymous functions used
    to set [DOM attributes](https://oreil.ly/hYN27) and properties with named ones
    would be far too onerous and would just add to the boilerplate.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的列表推导在基本过滤和映射方面效果良好。它们确实缺乏 JavaScript 的匿名函数的便利性（这些是完全成熟的，有自己的作用域、控制块、异常处理等），但是对于匿名函数的使用存在争议。例如，它们不可重用，并且由于没有名称，使得异常跟踪和调试变得困难。参见[Ultimate
    Courses](https://oreil.ly/7u1j6)获取一些有说服力的论点。尽管如此，对于像 D3 这样的库，用命名函数替换用于设置[DOM 属性](https://oreil.ly/hYN27)和属性的小型、一次性匿名函数将会太繁琐，只会增加样板代码。
- en: 'Python does have functional lambda expressions, which we’ll look at in the
    next section, but for full functional processing in Python by necessity and JavaScript
    for best practice, we can use named functions to increase our control scope. For
    our simple odd-squares example, named functions are a contrivance—but note that
    they increase the first-glance readability of the list comprehension, which becomes
    much more important as your functions get more complex:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: Python 确实有函数式 lambda 表达式，我们将在下一节中看到，但出于必要性和 JavaScript 的最佳实践，我们可以使用命名函数来增加我们的控制范围。对于我们简单的奇数平方示例，命名函数是一种构思，但请注意，它们增加了列表推导的一目了然的可读性，这在函数变得更复杂时变得更加重要：
- en: '[PRE75]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: With JavaScript, a similar contrivance can also increase readability and facilitate
    DRY code:^([21](ch02.xhtml#idm45607799695392))
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JavaScript，类似的构思也可以增加可读性，并促进 DRY 代码：^([21](ch02.xhtml#idm45607799695392))
- en: '[PRE76]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Map, Reduce, and Filter with Python’s Lambdas
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python 的 Lambdas 进行 Map、Reduce 和 Filter
- en: Although Python lacks anonymous functions, it does have *lambdas*, which are
    nameless expressions that take arguments. Though lacking the bells and whistles
    of JavaScript’s anonymous functions, these are a powerful addition to Python’s
    functional programming repertoire, especially when combined with its functional
    methods.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Python 没有匿名函数，但它有*lambdas*，这是没有名字的表达式，接受参数。尽管缺少 JavaScript 的匿名函数的花哨和吸引力，这些对于
    Python 的函数编程来说是一个强大的补充，特别是与其函数方法结合使用时。
- en: Note
  id: totrans-371
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Python’s functional built-ins (`map`, `reduce`, `filter` methods, and lambda
    expressions) have a checkered past. It’s no secret that the creator of Python
    wanted to remove them from the language. The clamor of disapproval led to their
    reluctant preservation. With the recent trend toward functional programming, this
    looks like a very good thing. They’re not perfect but are far better than nothing.
    And given JavaScript’s strong functional emphasis, they’re a good way to leverage
    skills acquired in that language.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的函数内置（`map`、`reduce`、`filter` 方法和 lambda 表达式）历史悠久。众所周知，Python 的创始人希望将它们从语言中删除。对它们的不满导致它们不情愿地被保留下来。随着最近对函数式编程的趋势，这看起来是一件非常好的事情。它们并非完美，但比没有好得多。鉴于
    JavaScript 对函数式的强调，它们是利用在该语言中获得的技能的一种好方法。
- en: 'Python’s lambdas take a number of parameters and return an operation on them,
    using a colon separator to define the function block, in much the same way that
    standard Python functions, only pared to the bare essentials and with an implicit
    return. The following example shows a few lambdas employed in functional programming:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 lambda 接受多个参数，并对它们进行操作，使用冒号分隔符定义函数块，与标准 Python 函数非常相似，只是简化到了最基本的部分，并且有一个隐式返回。下面的例子展示了在函数式编程中使用的一些
    lambda 表达式：
- en: '[PRE77]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO21-1)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO21-1)'
- en: Here, the `reduce` method provides two arguments to the lambda, which uses them
    to return the expression after the colon.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`reduce` 方法向 lambda 函数提供两个参数，lambda 函数使用它们在冒号后返回表达式。
- en: JavaScript Closures and the Module Pattern
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 闭包与模块模式
- en: One of the key concepts in JavaScript is that of the *closure*, which is essentially
    a nested function declaration that uses variables declared in an outer (but not
    global) scope that are *kept alive* after the function is returned. Closures allow
    for a number of very useful programming patterns and are a common feature of the
    language.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的一个关键概念之一是*闭包*，它本质上是一个嵌套函数声明，使用在外部（但不是全局）作用域中声明的变量，在函数返回后仍然*保持活跃*。闭包允许实现许多非常有用的编程模式，是该语言的一个常见特性。
- en: 'Let’s look at possibly the most common usage of closures and one we’ve already
    seen exploited in our module pattern ([Example 2-2](#pyjs_module)): exposing a
    limited API while having access to essentially private member variables.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看闭包可能是最常见的用法之一，也是我们在模块模式中已经看到并利用的用法（[示例 2-2](#pyjs_module)）：在保持对本质上是私有的成员变量的访问的同时，公开了有限的
    API。
- en: 'A simple example of a closure is this little counter:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的闭包示例是这个小计数器：
- en: '[PRE78]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO22-1)'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO22-1)'
- en: The `add` function gets access to the essentially private, outer-scope `count`
    and `inc` variables.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`add` 函数可以访问本质上是私有的外部作用域中的 `count` 和 `inc` 变量。'
- en: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO22-2)'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO22-2)'
- en: This returns an `add` function with the closure variables, `count` (`0`) and
    `inc` (`2`).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个带有闭包变量 `count`（`0`）和 `inc`（`2`）的 `add` 函数。
- en: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO22-3)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_a_language_learning_bridge_between_python_and_javascript_CO22-3)'
- en: Calling `inc2` calls `add`, updating the *closed* `count` variable.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `inc2` 会调用 `add`，从而更新*封闭的* `count` 变量。
- en: 'We can extend the `Counter` to add a little API. This technique is the basis
    of JavaScript modules and many simple libraries, particularly when using script-based
    JavaScript.^([22](ch02.xhtml#idm45607799372592)) In essence, it selectively exposes
    public methods while hiding private methods and variables, which is generally
    seen as good practice in the programming world:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展 `Counter` 来添加一个小 API。这种技术是 JavaScript 模块和许多简单库的基础，尤其是在使用基于脚本的 JavaScript
    时。^([22](ch02.xhtml#idm45607799372592)) 本质上，它选择性地公开公共方法，同时隐藏私有方法和变量，这在编程界通常被视为良好的实践：
- en: '[PRE79]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Closures have all sorts of uses in JavaScript and I’d recommend getting your
    head around them—you’ll see them a lot as you start investigating other people’s
    code. These are three particularly good web articles that provide a lot of good
    use cases for closures:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，闭包有各种各样的用途，我建议你对其有个基本的了解——因为在你开始研究其他人的代码时，你会经常遇到它们。以下是三篇特别好的网络文章，提供了闭包的许多实际用例：
- en: '[Mozilla’s introduction](https://oreil.ly/T6itS)'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Mozilla 的介绍](https://oreil.ly/T6itS)'
- en: '[“JavaScript Module Pattern: In-Depth”](https://oreil.ly/0P2EI) by Ben Cherry'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“JavaScript 模块模式：深入了解”](https://oreil.ly/0P2EI) 作者 Ben Cherry'
- en: '[“Use Cases for JavaScript Closures”](https://oreil.ly/xz4G5) by Juriy Zaytsev'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“JavaScript 闭包用例”](https://oreil.ly/xz4G5) 作者 Juriy Zaytsev'
- en: Python has closures, but they are not used nearly as much as JavaScript’s, perhaps
    because of a few quirks that, though surmountable, make for some slightly awkward
    code. To demonstrate, [Example 2-7](#pyjs_pyclosure_1) tries to replicate the
    previous JavaScript counter.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: Python 也有闭包，但它们并没有像 JavaScript 那样被广泛使用，也许是因为一些使得代码略显尴尬的怪异之处。尽管如此，这些问题是可以克服的。为了演示这一点，[示例 2-7](#pyjs_pyclosure_1)
    尝试复制之前的 JavaScript 计数器。
- en: Example 2-7\. A first-pass attempt at a Python counter closure
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-7\. Python 计数器闭包的初步尝试
- en: '[PRE80]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If you create a counter with `get_counter` ([Example 2-7](#pyjs_pyclosure_1))
    and try to run it, you’ll get an `UnboundLocalError`:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用 `get_counter` 创建一个计数器（[示例 2-7](#pyjs_pyclosure_1)），然后尝试运行它，你会得到一个 `UnboundLocalError`：
- en: '[PRE81]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Interestingly, although we can read the value of `count` within the `add` function
    (comment out the `count += inc` line to try it), attempts to change it throw an
    error. This is because attempts to assign a value to something in Python assume
    it is local in scope. There is no `count` local to the `add` function and so an
    error is thrown.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，尽管我们可以在 `add` 函数内读取 `count` 的值（注释掉 `count += inc` 行来尝试），但尝试改变它会抛出错误。这是因为在
    Python 中，尝试将值分配给某些东西会假定它是局部范围的。`add` 函数中没有 `count`，因此会抛出错误。
- en: 'In Python 3, we can get around the error in [Example 2-7](#pyjs_pyclosure_1)
    by using the `nonlocal` keyword to tell Python that `count` is in a nonlocal scope:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3 中，我们可以通过使用 `nonlocal` 关键字来绕过 [示例 2-7](#pyjs_pyclosure_1) 中的错误，告诉
    Python `count` 在一个非局部范围内：
- en: '[PRE82]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'If you are obliged to use Python 2+ (please try and upgrade), we can use a
    little dictionary hack to allow mutation of our closed variables:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不得不使用 Python 2+（请尝试升级），我们可以使用一点字典技巧来允许对闭包变量进行修改：
- en: '[PRE83]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This hack works because we are not assigning a new value to `vars` but are instead
    mutating an existing container, which is perfectly valid even if it is out of
    local scope.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧之所以有效，是因为我们没有给 `vars` 赋予新值，而是改变了一个现有容器，即使它超出了局部范围，这也是完全有效的。
- en: As you can see, with a bit of effort, JavaScripters can transfer their closure
    skills to Python. The use cases are similar, but Python, being a richer language
    with lots of useful batteries included, has more options to apply to the same
    problem. Probably the most common use of closures is in Python’s decorators.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过一点努力，JavaScript 开发者可以将他们的闭包技能转移到 Python 中。用例类似，但 Python 是一种更丰富的语言，具有许多有用的内置功能，可以对同一问题应用更多选项。闭包最常见的用途可能是
    Python 中的装饰器。
- en: '*Decorators* are essentially function wrappers that extend the function’s utility
    without having to alter the function itself. They’re a relatively advanced concept,
    but you can find a user-friendly introduction [on The Code Ship website](https://oreil.ly/Skz8b).'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '*装饰器*本质上是扩展函数实用性的函数包装器，而无需更改函数本身。它们是一个相对高级的概念，但您可以在[The Code Ship 网站](https://oreil.ly/Skz8b)上找到一个用户友好的介绍。'
- en: This concludes my cherry-picked selection of patterns and hacks that I find
    myself using a lot in dataviz work. You’ll doubtless acquire your own, but I hope
    these give you a leg up.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我精心挑选的一些模式和技巧的总结，我在数据可视化工作中经常使用。你无疑会拥有自己的经验，但我希望这些可以帮助你起步。
- en: A Cheat Sheet
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 速查表
- en: As a handy reference guide, Figures [2-2](#build_cheat_basic) to [2-7](#build_cheat_classes)
    include a set of cheat sheets to translate basic operations between Python and
    JavaScript.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个方便的参考指南，图 [2-2](#build_cheat_basic) 至 [2-7](#build_cheat_classes) 包括了一组速查表，用于在
    Python 和 JavaScript 之间转换基本操作。
- en: '![dpj2 0202](assets/dpj2_0202.png)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![dpj2 0202](assets/dpj2_0202.png)'
- en: Figure 2-2\. Some basic syntax
  id: totrans-411
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. 一些基本语法
- en: '![dpj2 0203](assets/dpj2_0203.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![dpj2 0203](assets/dpj2_0203.png)'
- en: Figure 2-3\. Booleans
  id: totrans-413
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-3\. 布尔值
- en: '![dpj2 0204](assets/dpj2_0204.png)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![dpj2 0204](assets/dpj2_0204.png)'
- en: Figure 2-4\. Loops and iterations
  id: totrans-415
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-4\. 循环和迭代
- en: '![dpj2 0205](assets/dpj2_0205.png)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![dpj2 0205](assets/dpj2_0205.png)'
- en: Figure 2-5\. Conditionals
  id: totrans-417
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-5\. 条件语句
- en: '![dpj2 0206](assets/dpj2_0206.png)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![dpj2 0206](assets/dpj2_0206.png)'
- en: Figure 2-6\. Containers
  id: totrans-419
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-6\. 容器
- en: '![dpj2 0207](assets/dpj2_0207.png)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![dpj2 0207](assets/dpj2_0207.png)'
- en: Figure 2-7\. Classes and prototypes
  id: totrans-421
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-7\. 类和原型
- en: Summary
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: I hope this chapter has shown that JavaScript and Python have a lot of common
    syntax and that most common idioms and patterns from one of the languages can
    be expressed in the other without too much fuss. The meat and potatoes of programming—iteration,
    conditionals, and basic data manipulation—is simple in both languages, and the
    translation of functions is straightforward. If you can program in one to any
    degree of competency, the threshold to entry for the other is low. That’s the
    huge appeal of these simple scripting languages, which have a lot of common heritage.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望本章已经表明，JavaScript 和 Python 有很多共同的语法，而且两种语言中的大多数常见习语和模式都可以在另一种语言中表达，而不会有太多麻烦。编程的核心——迭代、条件和基本数据操作——在两种语言中都很简单，函数的转换也很直接。如果您能够以任何程度的熟练程度编程其中一种语言，那么学习另一种语言的门槛就很低。这就是这些简单的脚本语言的巨大吸引力，它们有很多共同的遗产。
- en: I provided a list of patterns, hacks, and idioms I find myself using frequently
    in dataviz work. I’m sure this list has its idiosyncrasies, but I’ve tried to
    tick the obvious boxes.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我提供了一个在数据可视化工作中我经常使用的模式、技巧和习惯。我确信这个列表有它的特殊之处，但我已经尽力满足了明显的要求。
- en: Treat this as part tutorial, part reference for the chapters to come. Anything
    not covered here will be dealt with when introduced.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 将其视为教程的一部分，也是未来章节的参考。未涵盖的任何内容将在引入时进行讨论。
- en: ^([1](ch02.xhtml#idm45607814867312-marker)) One particularly annoying little
    gotcha is that while Python uses `pop` to remove a list item, it uses `append`—not
    `push`—to add an item. JavaScript uses `push` to add an item, whereas `append`
    is used to concatenate arrays.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.xhtml#idm45607814867312-marker)) 特别讨厌的小坑之一是，Python 使用 `pop` 来移除列表项，但却使用
    `append` 而不是 `push` 来添加项。JavaScript 使用 `push` 来添加项，而 `append` 则用于连接数组。
- en: ^([2](ch02.xhtml#idm45607814847776-marker)) The ascent of [node.js](https://nodejs.org/en)
    has extended JavaScript to the server.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.xhtml#idm45607814847776-marker)) [node.js](https://nodejs.org/en)
    的兴起将 JavaScript 扩展到了服务器端。
- en: ^([3](ch02.xhtml#idm45607814841712-marker)) This is changing with libraries
    like [TensorFlow.js](https://oreil.ly/kDw6M) and [Danfo.js](https://oreil.ly/dJnOl)
    (a JavaScript pandas-alike based on TensorFlow), but JS is still well behind Python,
    R, and others.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.xhtml#idm45607814841712-marker)) 随着像 [TensorFlow.js](https://oreil.ly/kDw6M)
    和 [Danfo.js](https://oreil.ly/dJnOl)（基于 TensorFlow 的 JavaScript pandas 替代品）等库的出现，这一情况正在改变，但
    JS 仍远远落后于 Python、R 等。
- en: ^([4](ch02.xhtml#idm45607814829968-marker)) At the cost of running a Python
    interpreter on the server.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.xhtml#idm45607814829968-marker)) 以在服务器上运行 Python 解释器为代价。
- en: ^([5](ch02.xhtml#idm45607817504464-marker)) The constraint of having to deliver
    JS scripts over the web via HTTP is largely responsible for this.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch02.xhtml#idm45607817504464-marker)) 通过 HTTP 在网络上传输 JS 脚本的限制在很大程度上造成了这种情况。
- en: ^([6](ch02.xhtml#idm45607819371024-marker)) You can eliminate the possibility
    of a missing `var` by using the ECMAScript 5 `'use strict'` directive.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch02.xhtml#idm45607819371024-marker)) 通过使用 ECMAScript 5 的 `'use strict'`
    指令，可以消除遗漏 `var` 的可能性。
- en: ^([7](ch02.xhtml#idm45607813738384-marker)) This is actually done by JavaScript
    compressors to reduce the file size of downloaded web pages.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch02.xhtml#idm45607813738384-marker)) 这实际上是 JavaScript 压缩器为了减小下载网页文件大小而完成的。
- en: ^([8](ch02.xhtml#idm45607813736320-marker)) The soft versus hard tab debate
    generates controversy, with much heat and little light. PEP-8 stipulates spaces,
    which is good enough for me.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch02.xhtml#idm45607813736320-marker)) 软制表符与硬制表符的争论引发了激烈的讨论，有很多争执却鲜有建设性意见。PEP-8
    规定了使用空格，这对我来说已经足够好了。
- en: ^([9](ch02.xhtml#idm45607813735088-marker)) It could be two or even three spaces,
    but this number must be consistent throughout the module.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch02.xhtml#idm45607813735088-marker)) 可能是两个甚至三个空格，但这个数字在整个模块中必须保持一致。
- en: ^([10](ch02.xhtml#idm45607813787904-marker)) The quite fair assumption that
    JavaScript uses UTF-16 has been the cause of much bug-driven misery. See [this
    blog post by Mathias Bynens](https://oreil.ly/9otVB) for an interesting analysis.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch02.xhtml#idm45607813787904-marker)) JavaScript 使用 UTF-16 的普遍假设导致了许多由
    bug 引起的痛苦。请参阅 [Mathias Bynens 的博文](https://oreil.ly/9otVB) 进行有趣的分析。
- en: ^([11](ch02.xhtml#idm45607813786288-marker)) The change to Unicode strings in
    Python 3 is a big one. Given the confusion that often attends Unicode de/encoding,
    it’s worth reading [a little bit about it](https://oreil.ly/5FNwi). Python 2 used
    strings of bytes.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch02.xhtml#idm45607813786288-marker)) Python 3 中转向 Unicode 字符串是一个重大变化。考虑到通常伴随
    Unicode 编码/解码的混乱，值得阅读有关 [此方面的一些内容](https://oreil.ly/5FNwi)。Python 2 使用字节字符串。
- en: ^([12](ch02.xhtml#idm45607813779728-marker)) `parseInt` can do quite a bit more
    than round. For example, `parseInt(*12.5px*)` gives 12, first removing the *`px`*
    and then casting the string to a number. It also has a second `radix` argument
    to specify the base of the cast. See [the Mozilla documentation](https://oreil.ly/ZtA4n)
    for the specifics.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch02.xhtml#idm45607813779728-marker)) `parseInt` 的功能远不止四舍五入。例如，`parseInt(*12.5px*)`
    返回 12，首先去除 *`px`*，然后将字符串转换为数字。它还有第二个 `radix` 参数来指定转换的基数。具体细节请参见 [Mozilla 文档](https://oreil.ly/ZtA4n)。
- en: ^([13](ch02.xhtml#idm45607815619968-marker)) Because all numbers in JavaScript
    are floating point, it can only support 53-bit integers. Using larger integers
    (such as the commonly used 64-bit) can result in discontinuous integers. See this
    [2ality blog post](https://oreil.ly/hBxvS) for further information.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: ^([13](ch02.xhtml#idm45607815619968-marker)) 因为 JavaScript 中的所有数字都是浮点数，它只支持
    53 位整数。使用更大的整数（例如常用的 64 位）可能导致不连续的整数。请参阅这篇 [2ality 博文](https://oreil.ly/hBxvS)
    获取更多信息。
- en: ^([14](ch02.xhtml#idm45607815328112-marker)) This makes iterating over their
    properties a little trickier than it might be. See [this Stack Overflow thread](https://oreil.ly/3kJW3)
    for more details.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: ^([14](ch02.xhtml#idm45607815328112-marker)) 这使得遍历它们的属性比可能要棘手一些。查看[这个 Stack
    Overflow 线程](https://oreil.ly/3kJW3)以获取更多详情。
- en: ^([15](ch02.xhtml#idm45607815158832-marker)) For the curious, there’s a nice
    summation in a [blog post by Angus Croll](https://oreil.ly/YyUyx).
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: ^([15](ch02.xhtml#idm45607815158832-marker)) 如果你好奇，Angus Croll 的[一篇博客文章](https://oreil.ly/YyUyx)对此有一个很好的总结。
- en: ^([16](ch02.xhtml#idm45607802789056-marker)) This is one area where JS beats
    Python hands-down and which finds many of us wishing for similar functionality
    in Python.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: ^([16](ch02.xhtml#idm45607802789056-marker)) 这是 JavaScript 明显胜过 Python 的一个领域，许多人希望
    Python 也能有类似的功能。
- en: ^([17](ch02.xhtml#idm45607802786192-marker)) Added with ECMAScript 5 and available
    on all modern browsers.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: ^([17](ch02.xhtml#idm45607802786192-marker)) 从 ECMAScript 5 开始，并在所有现代浏览器中可用。
- en: ^([18](ch02.xhtml#idm45607802261472-marker)) I mentioned to a talented programmer
    friend that I was faced with the challenge of explaining prototypes to Python
    programmers, and he pointed out that most JavaScripters could probably do with
    some pointers too. There’s a lot of truth in this and many JSers do manage to
    be productive by using prototypes in a *classy* way, hacking their way around
    the edge cases.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: ^([18](ch02.xhtml#idm45607802261472-marker)) 我告诉一个有才华的程序员朋友，我面临向 Python 程序员解释原型的挑战，他指出大多数
    JavaScript 程序员可能也需要一些指导。这有很多道理，许多 JavaScript 程序员通过 *优雅* 地使用原型，在边缘情况下进行技巧性的编码来保持高效。
- en: ^([19](ch02.xhtml#idm45607801599376-marker)) This is another reason to use ECMAScript
    5’s `'use strict;'` injunction, which calls attention to such mistakes.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: ^([19](ch02.xhtml#idm45607801599376-marker)) 这是使用 ECMAScript 5 的 `'use strict;'`
    指令的另一个原因，它引起了这类错误的注意。
- en: ^([20](ch02.xhtml#idm45607800747696-marker)) My personal choice for performance
    reasons.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: ^([20](ch02.xhtml#idm45607800747696-marker)) 出于性能原因，这是我的个人选择。
- en: ^([21](ch02.xhtml#idm45607799695392-marker)) Don’t Repeat Yourself (DRY) is
    a solid coding convention.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: ^([21](ch02.xhtml#idm45607799695392-marker)) 不要重复自己（DRY）是一种可靠的编码约定。
- en: ^([22](ch02.xhtml#idm45607799372592-marker)) Modern JavaScript has proper modules
    that can import and export encapsulated variables. There is an overhead to using
    these as they currently require a build phase to make ready for the browser.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: ^([22](ch02.xhtml#idm45607799372592-marker)) 现代 JavaScript 有适当的模块，可以导入和导出封装的变量。使用这些会有额外的开销，因为它们目前需要一个构建阶段来准备好供浏览器使用。
