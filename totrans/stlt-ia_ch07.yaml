- en: 8 Building a CRUD app with Streamlit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting up a relational database for persistent storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing CRUD operations using SQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a multi-page Streamlit app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating shared database connections in a Streamlit app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In 1957, a science fiction author named Theodore Sturgeon famously said, "ninety
    percent of *everything* is crud". While this was originally a cynical defense
    of the genre of science fiction—the point being that it was no different from
    anything else in that regard—the adage has since taken on a different meaning,
    becoming the worst-kept secret in software engineering: Ninety percent of everything
    is CRUD.'
  prefs: []
  type: TYPE_NORMAL
- en: By CRUD, I'm referring to Create, Read, Update, and Delete, the four mundane
    operations that appear repeatedly in almost any notable piece of software.
  prefs: []
  type: TYPE_NORMAL
- en: Think about it. Social media platforms like Facebook revolve around creating
    posts, reading feeds, updating profiles, and deleting content. E-commerce sites
    manage products, orders, customer accounts, and reviews through similar operations.
    Even something as simple as Notepad on Windows centers around creating, reading,
    updating, and deleting text files.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering CRUD operations is essential for building a strong foundation in software
    design, as their implementation often involves tackling non-trivial challenges.
    In this chapter, we'll create a CRUD application with Streamlit, implementing
    these operations from scratch while covering related topics such as user authentication.
  prefs: []
  type: TYPE_NORMAL
- en: '8.1 Haiku Haven: A CRUD app in Streamlit'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our excursion into CRUD, we're going with the Japanese art of *haiku*—specifically,
    we will create a website that lets users write and share their own haikus.
  prefs: []
  type: TYPE_NORMAL
- en: 'For those not intimately familiar with Japanese literature, a haiku is a short
    three-line poem conforming to certain rules: the first and the third lines must
    have five syllables, while the second must have seven. For instance, here''s one
    I wrote about Streamlit:'
  prefs: []
  type: TYPE_NORMAL
- en: '*So many web apps!*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*With Python can I make one?*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Then I tried Streamlit.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I know*,* right? I sometimes wonder if I missed my calling too. Regardless,
    you'll notice that the poem adheres to the 5-7-5 syllable rule I mentioned above,
    and is therefore a valid haiku.
  prefs: []
  type: TYPE_NORMAL
- en: Haiku Haven will be a place where budding poets can author, refine, and manage
    haikus. It will enable users to *create* haikus from scratch, *read* what they've
    created, *update* a haiku once they've created it, and *delete* it if they decide
    it doesn't pass muster.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.1 Stating the concept and requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As usual, we''ll start by stating the concept of our app succinctly:'
  prefs: []
  type: TYPE_NORMAL
- en: Concept
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Haiku Haven, a website that allows users to create, edit, and manage haikus
  prefs: []
  type: TYPE_NORMAL
- en: This concept and our earlier discussion about CRUD should give you a basic idea
    of what we want, but let's spell out the concrete requirements so we're on the
    same page about the Haiku Haven vision.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A user of Haiku Haven should be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: create and log in to an account with a username and password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: create haikus under their username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: view the haikus they've created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: update haikus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: delete their haikus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hopefully you'll realize how frequently you encounter this kind of app. If you
    replace the word "haiku" in the requirements with "image", you get a barebones
    version of Instagram. Substitute "task" to get a productivity tool like Asana
    or "post" to get Twitter or WordPress.
  prefs: []
  type: TYPE_NORMAL
- en: The point is that these requirements aren't just about haikus—they represent
    a universal pattern in software design. Almost every app revolves around managing
    some kind of data, founded on CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: By building Haiku Haven, you're not just creating a playful app for poetry lovers;
    you're learning how to construct the essential workflows of modern software. You'll
    tackle user authentication, data storage, and retrieval—skills that apply to nearly
    any app or system you might create in the future.
  prefs: []
  type: TYPE_NORMAL
- en: What's out of scope
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We could fit a lot of functionality into Haiku Haven (think of everything you
    can do on Twitter), but we only have one chapter, so we''ll focus on the absolute
    core stuff. That means we *won''t* concern ourselves with:'
  prefs: []
  type: TYPE_NORMAL
- en: Making haikus visible to and searchable by other users—haikus are private to
    the author
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Social" features such as liking, commenting, and sharing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auxiliary functionality like pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced security features (though we'll get the basics right)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.1.2 Visualizing the user experience
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Haiku Haven will be our first multi-page app. We'll need to craft multiple experiences
    or flows—the account creation flow, login and logout, and the actual CRUD part
    (creating, reading, updating, and deleting haikus).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 attempts to sketch out what the different portions of our app might
    look like.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/ch08__image001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 Rough sketches of the pages we want in Haiku Haven
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Because of how common these flows are in various common apps, I won''t take
    too much space here to explain them in detail, but here are a few highlights:'
  prefs: []
  type: TYPE_NORMAL
- en: The login page uses a password for authentication, which you can set in the
    signup page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A "My haikus" page represents the logged-in experience within the app, letting
    users create, view, edit, or delete their haikus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's also a haiku editor page where the authoring of haikus takes place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.1.3 Brainstorming the implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given that Haiku Haven represents CRUD web apps—and thus, by Sturgeon's law,
    90% of *all* web apps—it stands to reason that its implementation should involve
    some very common patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, the design we''ll use consists of three components that are seen in
    most live online applications: a frontend, a backend, and a *database*. Figure
    8.2 lays out this approach.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/ch08__image002.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 Design for our app showing a frontend, backend, and database
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The frontend, as we've seen in prior apps, consists of the widgets that the
    user interacts with. Each major action, such as creating an account, or updating
    a haiku, calls a corresponding function in the backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll divide the functions available in the backend into two groups: one that
    includes actions related to users, like creating an account or authenticating
    a user, and another that includes haiku-related actions—creating, reading, updating,
    or deleting haikus.'
  prefs: []
  type: TYPE_NORMAL
- en: The interesting section here—one that's new to us—is the database, which is
    used to permanently store information related to users and haikus in *tables*.
    As we'll soon see, the database also makes it easy to retrieve the information
    we've stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'While our app is intentionally simple, it captures the core elements of most
    web applications: a frontend for user interaction, a backend for handling requests,
    and a database for storing and retrieving data. These three pillars work together
    seamlessly, forming the foundation of countless applications, whether simple or
    complex.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.2 Setting up persistent storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important deficiencies in the apps we've created thus far is
    the lack of persistent storage. Essentially, in all of our apps so far, if the
    user closes their browser window, they lose their data and progress. This won't
    do at all for Haiku Haven; we need users to be able to save and access their haikus
    after they log out and log back in again at some point in the future—we need to
    store data *outside* of the app itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several different approaches to solving the problem of data storage,
    but we''ll use a fairly common technique: a relational database.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.1 Relational database concepts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *relational database* is a type of data storage system that organizes data
    into structured *tables*, where each table consists of *rows* (also called *records*)
    and *columns* (also called *fields*). A row represents some kind of entry or entity,
    and a column is an attribute of the entity. A *schema* defines the structure of
    these tables, including the *data types* of each column and the *relationships*
    between different tables.
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases rely on a language called *Structured Query Language* (SQL)
    to create, manage and *query* tables.
  prefs: []
  type: TYPE_NORMAL
- en: If some of this rings a bell, it's likely because we've been dealing with this
    kind of thing for a while now. In Chapters 6 and 7, we worked with Pandas dataframes
    that also handle tabular data—except that dataframes are stored in memory while
    a program is running, while a database is used for *persistent* storage, i.e.
    storage that exists even when a program finishes running.
  prefs: []
  type: TYPE_NORMAL
- en: We also encountered SQL briefly in Chapter 7, where we used it to fetch the
    rows of the sales data that we stored in Google BigQuery. Indeed BigQuery is often
    considered to be a relational database itself, though of a different kind than
    the one we'll use in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.2 Haiku Haven's data model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To understand all of this better, let's try and figure out how we can *model*
    Haiku Haven's data in a relational database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Broadly speaking, modeling data for an app consists of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the *entities* involved in the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the *relationship* between those entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing the *attributes* of each entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting the entities, attributes and relationships into a relational database
    schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying the entities
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Generally speaking, a good way to identify the entities involved in an app
    is to list all the *nouns* that represent core concepts in the app. For instance,
    if you take Twitter, the following might all be considered as entities: users,
    tweets, retweets, direct messages, mentions, followers, hashtags, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Haiku Haven is way simpler, of course. We can fairly easily identify the two
    key entities our app will need to handle: **haikus** and **users**.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the relationship between the entities
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The relationship between any two entities should be defined in terms of the
    *nature* and *cardinality* of the possible interaction between them. In English,
    that means you should lay out *how* one entity is related to the other, and *how
    many* of each entity can be on each side of this relationship.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, haikus and users are related because a user **can write** a haiku
    (the "nature" we spoke of above). Also, one user can write many haikus, while
    a particular haiku can only be written by one user. So the relationship between
    a user and a haiku is **one-to-many** or 1:n (the "cardinality").
  prefs: []
  type: TYPE_NORMAL
- en: Listing the attributes of each entity
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The attributes of an entity are the fields that describe it. In our case:'
  prefs: []
  type: TYPE_NORMAL
- en: A user has a **username** and a **password**. In real life, we'd probably also
    want to capture the name of the user or the time a user's account is created,
    but let's keep things simple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A haiku has its **text**, and an **author** (who happens to be a user). We should
    also give each haiku a **numeric ID** for easy reference. The **creation time**
    for a haiku may be important to display in the app, so let's consider that too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of this can be represented in an entity-relationship diagram (or ER diagram)
    as shown in figure 8.3.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/ch08__image003.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 Entity-Relationship (ER) diagram showing the User and Haiku entities
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Of course, ER diagrams for apps in the real world tend to be much, *much* more
    complex than this, but I hope this serves to illustrate the concept.
  prefs: []
  type: TYPE_NORMAL
- en: Converting everything into a database schema
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The exercise of coming up with an ER diagram is helpful in visualizing the data
    model, but the end outcome we actually want is a schema that we can use in our
    relational database.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s no hard-and-fast rule to convert entities, attributes, and relationships
    into tables in a database, but *generally* speaking: entities become tables, attributes
    become columns, one-to-many relationships become *foreign keys* (more on this
    in a moment), and many-to-many relationships become their own tables.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/ch08__image004.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 Database schema with a foreign key relationship between the users
    and haikus tables
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In our case, as figure 8.4 shows, we'll have two tables, `users` and `haikus`,
    with the attributes we discussed earlier as columns. Each row in users represents
    a single user, and each row in `haikus` is a single haiku. Additionally, each
    table has a *primary key*, which is a field that can be used to uniquely identify
    any row in the table. For `users`, the primary key is the `username` field (which
    makes sense since every user has a username and no two users can have the same
    username). For `haikus`, it's `haiku_id`.
  prefs: []
  type: TYPE_NORMAL
- en: The relationship between `users` and `haikus` is reflected in the `author` column
    in the `haikus` table, which contains a username that must appear in the `users`
    table. Such a column (`author`) is called a *foreign key* as it points to the
    primary key (`username`) of another ("foreign") table.
  prefs: []
  type: TYPE_NORMAL
- en: '8.2.3 PostgreSQL: A real relational database'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Enough theorizing! Let's now get our hands dirty with a real relational database.
    The one we'll use in this chapter is PostgreSQL (pronounced "post-gress-cue-ell"),
    one of the oldest, most robust, and most popular databases in the industry.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Google BigQuery, which we encountered in Chapter 7, can also be considered a
    relational database (though it's better described as a cloud-based data warehouse).
    While BigQuery is optimized for analytical use cases (like querying a large amount
    of data to generate reports or uncover trends), PostgreSQL is better suited for
    transactional use cases, such as handling frequent small updates to individual
    records, and maintaining data consistency across concurrent operations.
  prefs: []
  type: TYPE_NORMAL
- en: Installing PostgreSQL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Towards the end of this chapter, when we deploy Haiku Haven to production, we'll
    use a free cloud service to set up PostgreSQL. However, for local development,
    we first need a local installation.
  prefs: []
  type: TYPE_NORMAL
- en: To install PostgreSQL, download the installer for your operating system from
    `https://www.postgresql.org/download/` and run it, following the on-screen instructions.
    For most options, you can accept the defaults. During the installation, you'll
    be prompted to set a password for the database superuser. Make sure to note this
    password—you'll need it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installation is complete, you should have access to the PostgreSQL shell,
    called `psql`, which is located in the `bin/` directory of your installation folder.
    If you kept the default options, this would typically be:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/Library/PostgreSQL/17/bin/psql` on macOS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C:\Program Files\PostgreSQL\17\bin\psql` on Windows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To simplify access, you should configure your system so you can run the `psql`
    command directly from your terminal. This requires adding the `bin/` directory
    to your system's environment variables. You may already have done something similar
    for the `streamlit` command, which you can find detailed steps for in Appendix
    A (section A.4).
  prefs: []
  type: TYPE_NORMAL
- en: 'If adding the path to your environment variables isn''t feasible for any reason,
    you can still use `psql` by typing its full path instead of just the command.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'macOS: `/Library/PostgreSQL/17/bin/psql`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows: `"C:\Program Files\PostgreSQL\17\bin\psql"` (include quotes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout the rest of this chapter, substitute the full path whenever you see
    `psql`, if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a database for Haiku Haven
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once you''ve set up the `psql` command, log in to your local PostgreSQL instance
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When prompted for a password, enter the one you configured during installation.
    This command logs you into PostgreSQL as the default user (`-U`) `postgres`—which
    is an administrative user that''s allowed to do whatever they want. The `-d` specifies
    that you want to connect to the default database, which is–~-rather confusingly
    if you ask me—also called `postgres`. You should see now see the `psql` prompt
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When your app talks to PostgreSQL, you don''t want it to be running with broad
    administrative privileges—that would be a security nightmare. Instead, let''s
    create a more narrowly-scoped user. Enter this into the `psql` prompt, replacing
    the quoted string with a password of your choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, you can use whatever username you like, but I'm going to assume we're
    going with `haiku_lord`. If that works (don't forget the ending semicolon!), you
    should get an output line that just says `CREATE ROLE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can create tables in PostgreSQL, you need to first make a **database**
    (which you can think of here as a container for tables). The `haiku_lord` user
    you just created can''t do that yet, so enter this command to let it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have an appropriately-privileged Haiku Haven-specific user, we''re
    done with the default `postgres` user, so exit out of the `psql` shell by typing
    `exit`, and then re-run it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Assuming you entered the password you selected for `haiku_db` when prompted,
    you're again connected to the `postgres` database, but now you're acting under
    the capacity of `haiku_lord` (if you like, you can verify this by typing `SELECT
    current_user;`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a database called `haikudb` to hold the tables for Haiku Haven, enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can list all the databases available in your local PostgreSQL instance by
    typing `\l`. You should now be able to see `haikudb` in there, along with `postgres`
    and a couple of others.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using our database, we need to "connect" to it. To do this, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A confirmation message—`You are now connected to database "haikudb" as user
    "haiku_lord"`—should let you know that this worked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep this terminal window with the `psql` shell open. We''re going to keep
    coming back to it throughout this chapter. If you do end up closing it, you can
    get back to this state by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 8.2.4 A crash course in SQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SQL in PostgreSQL stands for Structured Query Language. Variously pronounced
    as "sequel" and "ess-cue-ell", SQL is the language of databases, used to create
    and update tables, and most importantly, to *query* them to get exactly the data
    we need. It's also one of the most popular and useful languages to know if you're
    a developer or work in the field of data in any capacity.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't know SQL, today's your lucky day because we're going to breeze
    through the basics in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating tables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Previously in this chapter, we came up with Haiku Haven''s database schema
    that contains two tables: `users` and `haikus`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re now going to actually create these tables in PostgreSQL. Go back to
    the `psql` shell where you''re connected to the `haikudb` database (or re-run
    `psql` as indicated earlier), and enter the following SQL command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CREATE` `TABLE` command creates a table with a specific schema. In the
    above, the name of the table is `users`, and it has two columns: `username` and
    `password_hash`—which, if you recall, are the two fields we settled on earlier
    as being important attributes of a user.'
  prefs: []
  type: TYPE_NORMAL
- en: Why does it say `password_hash` instead of just `password`? Bear with me, please—I'll
    explain this a little later in the chapter. For now, let's just think of it as
    the user's password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Turn your attention to the lines where we''ve defined the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These sequences, separated by commas, are *column specifications* that let you
    configure each column—including specifying the data type.
  prefs: []
  type: TYPE_NORMAL
- en: '`VARCHAR` is one such data type in PostgreSQL; it''s a string type that can
    have a varying number of characters. `VARCHAR(100)` means that the column can
    have any number of characters up to 100\. If you try to store more than 100 characters,
    PostgreSQL will throw an error.'
  prefs: []
  type: TYPE_NORMAL
- en: You'll also notice `PRIMARY` `KEY` against the `username` column. This denotes
    that the `username` column will be used to uniquely identify a row in the users
    table. Among other things, this means that every row in `users` must have a `username`,
    and that only one user can have a particular `username`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check that this worked, you can use the `psql` command `\dt`, which lists
    all the tables in the current database. Doing so now should give you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create our second table, `haikus`, with another `CREATE` `TABLE`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few new things here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`haiku_id`, the primary key, has a data type of `SERIAL`. This means that PostgreSQL
    will automatically provide the value for this column as an auto-incrementing integer.
    The first row inserted will have `1` as its `haiku_id`, the second will have `2`,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created_at` has the data type `TIMESTAMPTZ`, which is a timestamp with time
    zone information. The `DEFAULT` keyword specifies the value to put in this column
    if one is not explicitly provided while inserting a row in the table. In this
    case, we want the current timestamp (`CURRENT_TIMESTAMP`) to be provided as this
    default value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text` has a data type of `TEXT`, which is like `VARCHAR` but with no maximum
    character length. This makes sense for the actual content of the haiku.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last line, `FOREIGN KEY (author) REFERENCES users(username)`, says that
    the author column must have a value that exists in the username column of some
    row in the users table. This is called a *foreign key constraint*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting rows into tables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, let's populate these tables with rows using SQL's `INSERT INTO` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll first create a new user by adding a row to the `users` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `INSERT INTO` command inserts a row into the table by specifying the column
    values. The `(username, password_hash)` after the table name `users` says that
    the column values we're about to specify correspond to the columns `username`
    and `password_hash`, in that order.
  prefs: []
  type: TYPE_NORMAL
- en: The part after `VALUES` gives the actual values to enter. The effect here is
    that `users` now has one row—with a `username` of `alice` and `password_hash`
    set to `Pass_word&34`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note here that though `haikus` has four columns, we're only specifying the values
    for two of them—`author` and `text`. PostgreSQL automatically provides the `haiku_id`
    as well as a default value for `created_at`.
  prefs: []
  type: TYPE_NORMAL
- en: Also notice the `E` before the starting quote of the haiku. This marks the value
    as an *escape string*, correctly translating the `\n` escape sequence into a newline
    character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we query these tables, let''s add another unsettling haiku under `alice`
    for good measure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Querying tables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The real strength of SQL lies in the versatile ways in which we can *query*
    tables (read data from them) once they have been populated with rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve data, we use the `SELECT` statement. This command allows us to
    specify the columns we want to see and filter rows based on certain criteria.
    Let''s start with a simple query to fetch all the rows and columns from the `users`
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The * indicates that we want to retrieve all columns from the table. As a result
    of this, we''ll see a list of all users along with their associated `user_id`
    and `password_hash`. We only currently have one user, so we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you're horrified to see passwords so easily queried, don't worry! As we'll
    soon see, we're not actually going to be storing passwords like this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also choose to only retrieve certain columns from the table. For example,
    if we only want the `haiku_id`, `created_at`, and `author` fields from the `haikus`
    table, we could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This would give us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also filter the rows we want to see based on a condition (or set of
    conditions) using a `WHERE` clause. For example, if we want to see the `haiku_id`
    and `text` for only haikus that are written by `alice` and contain `"fox"`, we
    could use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'to get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve filtered the `haikus` table using two conditions separated by the keyword
    `AND` here: `author = ''alice''`, and `text LIKE ''%fox%''`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `LIKE` keyword is used to perform text-matching. The `%` symbol means "zero
    or more characters," making `%fox%` a pattern that matches any text containing
    the word 'fox' anywhere within it.
  prefs: []
  type: TYPE_NORMAL
- en: The `SELECT` statement can do a *lot* more than this, such as calculating summary
    statistics, aggregating rows, fetching data from multiple tables by joining them
    and more, but these are out of the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Updating tables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can update rows in a table after you''ve inserted them, using the `UPDATE`
    statement. For example, let''s say you want to add the string "[By Alice] " to
    the start of the haiku with `haiku_id` 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we''re setting the column `text` in the `haikus` table for rows where
    the `haiku_id` is `1`. The The `||` operator is used in SQL to concatenate strings,
    so `SET text = ''[By Alice] '' || text` adds "[By Alice] " to the beginning. If
    we now `SELECT` the text for that haiku with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'we''ll get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Though we've only updated one row here, `UPDATE` will update all the rows that
    match the `WHERE` clause. If we omit the `WHERE` clause, the `UPDATE` will apply
    to every single row in the table.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting rows (and tables)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To delete rows from a table, we use the `DELETE FROM` command. Just as in the
    case of `UPDATE`, it uses a `WHERE` condition to determine the rows to delete.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we could delete the haiku with ID 2 by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Be careful with this command! If you omit the `WHERE` clause, `DELETE FROM`
    will delete *every single* row!
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can delete a table itself (as opposed to just the rows in the table),
    by using the `DROP TABLE` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we wanted to remove the `haikus` table (which we don''t, for
    now), we could have entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Of course, there's much more to SQL than what we've learned—indeed, entire careers
    can be forged by knowing it well enough—but this is all we'll need for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.5 Connecting PostgreSQL to our app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've now set up the database for Haiku Haven. We've also learned to insert
    rows and query our database *manually*. What's left is to enable our app to query
    and make changes to the database *programmatically*, through Python.
  prefs: []
  type: TYPE_NORMAL
- en: For this, we'll employ a third-party Python module named `psycopg2`, which provides
    us with a way to talk to PostgreSQL in our app.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and install it now by running `pip install psycopg2` in a new terminal
    window.
  prefs: []
  type: TYPE_NORMAL
- en: How database connections work
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before using `psycopg2`, let’s understand how PostgreSQL queries work in Python.
  prefs: []
  type: TYPE_NORMAL
- en: We learned in prior chapters that a Streamlit app is served by a Streamlit server
    process that listens to a particular port (usually 8501 or something near that)
    on a machine. Similarly, a PostgreSQL database runs on a PostgreSQL server that
    listens to a different port—5432 by default, unless you set a different port number
    when you installed it.
  prefs: []
  type: TYPE_NORMAL
- en: To execute SQL commands, the app must establish a *connection* to the PostgreSQL
    server. A single connection can handle only one command at a time.
  prefs: []
  type: TYPE_NORMAL
- en: But what if multiple users try to create or update a haiku at once? We could
    queue up the SQL commands on a single connection, but that could cause delays.
    Using multiple *connections* is better, but setting up each one can be resource-intensive—especially
    in production—as it involves network initialization and authentication.
  prefs: []
  type: TYPE_NORMAL
- en: '`psycopg2`''s answer to this is a *connection pool* that manages multiple *re-usable*
    database connections efficiently, illustrated by figure 8.5.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/ch08__image005.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 Database connection pool with 1 minimum and 5 maximum connections
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A connection pool maintains a set of connections that can be quickly reused
    by different parts of the application or different users accessing the application.
    When a part of the application needs to run a database query, it can:'
  prefs: []
  type: TYPE_NORMAL
- en: Request a connection from the pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the connection to execute the query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the connection to the pool for reuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using psycopg2 to connect to our database
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With all that in mind, let's try setting up a live database connection and running
    a query! Open a Python shell by typing `python` (or `python3`) into your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''re in, import what we need from the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`ThreadedConnectionPool` is the connection pool class we''ll use. To instantiate
    it, we''ll need the address where our PostgreSQL server is running, the port number
    it''s running on, the username and password of the PostgreSQL user we created,
    and the name of our database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can combine all of these into a *connection string* that takes the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, we''ll type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, you'll need to replace `<password>` with the actual password you
    created for `haiku_lord`. Since we're running PostgreSQL locally right now, the
    server address is simply `localhost`, but this will change when we switch to a
    managed PostgreSQL service during deployment later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now create our connection pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 1 and 5 here are the minimum and maximum connections in the pool. This means
    1 connection is always kept available even before we receive any requests, and
    a maximum of 5 simultaneous connections can be maintained.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s grab a connection from the pool using the `getconn` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute a query, we need a *cursor*, which is a pointer that allows us to
    execute SQL commands and fetch results from the database in flexible ways. We
    create one by calling the `cursor()` method on our `connection` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note the `%s` here. This makes the username of the author a parameter of the
    query. By plugging in different usernames, we could get the haikus of different
    authors. For now, we want `alice`'s haikus, so we'll create a params tuple to
    pass along with the query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`(''alice'',)` is the literal notation for a single-element tuple containing
    the string `''alice''`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Once the execution is done, let's fetch all the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The results are in the form of a list of tuples, where each tuple represents
    a single row in the database. Since our `SELECT` clause said `haiku_id, author`,
    the first element of each result tuple is the `haiku_id`, while the second is
    the `author` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re done with the query, let''s return the connection to the pool
    so other parts of the app can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'That concludes our illustration of `psycopg2`. As a final step, let''s clean
    up the connection pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This closes all connections and no more can be requested from the pool.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Database class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we know how to run SQL queries in Python, we're ready to begin writing
    the code for our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to organize our code in two folders: `backend`
    and `frontend`, and a main entrypoint script (the one we''ll use with `streamlit
    run`) that lies outside of either.'
  prefs: []
  type: TYPE_NORMAL
- en: The database connection stuff we just covered is pretty technical and we'd rather
    not have to deal with it in the remainder of our app's code. It would be nice
    if we had a database object that we could just ask to execute the queries we need,
    without having to worry about the gory details of connection pools and cursors.
    Whenever we want to run a particular query, we should be able to write `database.execute_query(query,
    params)`, passing in the query we want to execute and the parameters we want to
    give it.
  prefs: []
  type: TYPE_NORMAL
- en: To set this up, let's create a `Database` *class*.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Python file called `database.py` within the backend folder and
    copy the code in listing 8.1.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.1 backend/database.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: By this point, you should be used to the simple dataclasses we've used in prior
    chapters. Dataclasses simplify the syntax used to create classes in Python, but
    for more complex use cases, we need to peel back that layer and write a traditional
    class definition.
  prefs: []
  type: TYPE_NORMAL
- en: A class is essentially a blueprint that can be turned into a concrete Python
    object, which can have attributes—these are the object's properties or data associated
    with the object—and methods—or functions that define the object's behavior and
    can interact with its attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s study the class definition for our `Database` class, shown in listing
    8.1\. We''ll start with the `__init__` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`__init__` (pronounced "dunder init") is a special method in Python. When an
    object is first created from a class, the `__init__` method is executed automatically.
    The two arguments our `__init__` takes are `self` and `connection_string`.'
  prefs: []
  type: TYPE_NORMAL
- en: You'll see `self` extremely often in Python class definitions. The first argument
    to a method within a class is a special one that's not explicitly passed while
    calling it (as we'll see in a bit). It always refers to the object on which the
    method is being called. By convention, this argument is named `self`—though you
    can technically call it whatever you like.
  prefs: []
  type: TYPE_NORMAL
- en: '`connection_string` is meant to hold a string of the type we formed earlier,
    containing the database configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: The line `self.connection_pool = ThreadedConnectionPool(MIN_CONNECTIONS, MAX_CONNECTIONS,
    connection_string)` creates a `psycopg2` `ThreadedConnectionPool` as we demonstrated
    in the earlier section, and assigns it to `self.connection_pool`, making it an
    attribute of the object created from the class.
  prefs: []
  type: TYPE_NORMAL
- en: '`MIN_CONNECTIONS` and `MAX_CONNECTIONS` are defined at the top of the file
    where they can be easily configured or changed later.'
  prefs: []
  type: TYPE_NORMAL
- en: We're effectively initializing a connection pool as soon as the database object
    is created.
  prefs: []
  type: TYPE_NORMAL
- en: We also define methods other than `__init__`, such as `connect`, which obtains
    a connection from the pool, `close`, which returns a given connection to the pool,
    and `close_all`, which closes the connection pool itself (and prints a message
    to the terminal window). The code for these should be familiar as we discussed
    it when we were trying out `psycopg2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we generally won''t call these methods directly. Recall that what
    we really want is a simple `execute_query` method that''ll take care of all the
    underlying database connection logic. Let''s presently turn our attention to that
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`execute_query` naturally accepts a SQL query we want to execute and any params
    (set to an empty tuple, `()`, by default) we want to give the query.'
  prefs: []
  type: TYPE_NORMAL
- en: The body of the method starts by obtaining a connection from the pool. We then
    see a `try`-`finally` block.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, `try`-`except`-`finally` is a construct `that's` used for error handling.
    The idea is to write your regular code in the `try` block. If an exception occurs
    while running the `try` code, Python stops execution and jumps to an `except`
    block that "catches" the exception, allowing you to log a sensible error message,
    for example, or use some other kind of handling logic.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of whether there's an exception or not, the code in the `finally`
    block is always executed.
  prefs: []
  type: TYPE_NORMAL
- en: The code in the `try` block simply gets a cursor, executes the query and returns
    the results, just as we saw when we were exploring `psycopg2`. The only new thing
    you might notice is the line `connection.commit()`.
  prefs: []
  type: TYPE_NORMAL
- en: This line exists because we're not just going to be using `execute_query` to
    run `SELECT` queries. We're also going to run `INSERT INTO`, `UPDATE`, and `DELETE
    FROM` commands—all of which *modify* tables, not just *read* from them.
  prefs: []
  type: TYPE_NORMAL
- en: In PostgreSQL, when you modify data, the changes aren't permanently saved until
    you *commit* them.
  prefs: []
  type: TYPE_NORMAL
- en: What if some kind of error occurs (for instance, the given query might have
    incorrect SQL syntax) while Python's trying to execute this code? We enter the
    `except` block marked by `except Exception`, which contains the line `connection.rollback()`.
    This undoes any temporary changes made so that the database is left in a pristine
    state.
  prefs: []
  type: TYPE_NORMAL
- en: We also print the error we encountered and then re-raise the exception, letting
    the regular exception flow take over—such as printing the exception message to
    the screen. What we've achieved with the `try`-`except` construct is to inject
    ourselves into the flow when an exception occurs and make sure any partial changes
    are rolled back.
  prefs: []
  type: TYPE_NORMAL
- en: What about the `finally` block? Well, that calls the `close` method further
    up in the file, returning the connection to the pool. Regardless of what happens
    in the `try` block, the connection is always freed up. If we didn't have this
    code, the connection would remain allocated even after the function exits, and
    eventually the pool would run out of new connections. Putting this code in the
    `finally` block ensures the connection is returned even if an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Database class in our app
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With a `Database` class set up, all that's left to do to enable persistent storage
    and retrieval in our app is to actually use the class in our Streamlit app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an instance of the Database class requires providing it with a connection
    string. Connection strings are sensitive because they contain PostgreSQL credentials,
    so we don't want to be putting the string in our code.
  prefs: []
  type: TYPE_NORMAL
- en: You probably know where this is heading—we need to use `st.secrets` as we've
    done in the past! Without further ado, go ahead and create a `.streamlit` folder
    in your app's root folder (the parent folder where you created the `backend` directory),
    and create a `secrets.toml` within it, with contents similar to what's shown in
    listing 8.2.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.2 .streamlit/secrets.toml
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to replace `password` with your actual password. Also, as we learned
    before, you shouldn't check this file into Git.
  prefs: []
  type: TYPE_NORMAL
- en: Next, create our app's entrypoint file—say, `main.py`—in the app's root directory,
    with the code in listing 8.3.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.3 main.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where it all comes together! Firstly, we import the `Database` class
    we just created using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This line means "import the Database class from `backend/database.py`". Notice
    how, in module import paths, the path separator becomes a dot.
  prefs: []
  type: TYPE_NORMAL
- en: For this line to work, Python needs to recognize the parent folder of `backend`
    as a starting point from which it can look for modules. We can do this by adding
    the path to the parent folder of `backend` to `sys.path`, which is the list of
    paths that determines this in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, when you run the `streamlit run <script.py>` command, the parent
    folder of `<script.py>` is automatically added to `sys.path`. In this case, since
    the parent folder of `main.py` is also the parent folder of the `backend` directory,
    we don't need to do anything extra.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after displaying a title, we extract the connection string from `st.secrets`
    as we''ve done in prior chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We use this to create an instance of the `Database` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You'll probably recognize this syntax from when we've used dataclasses before,
    but this is the first time in this book that we've instantiated a traditional
    class we wrote, so a deeper explanation is warranted.
  prefs: []
  type: TYPE_NORMAL
- en: What's going on here is that by passing `connection_string` to the class `Database`
    as though it were a function, we're actually passing it to `Database`'s `__init__`
    method, which has the signature line `def __init__(self, connection_string)`.
    As I mentioned earlier, `self` is automatically set to the object that's being
    created, so we don't need to pass it explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we pass only `connection_string`, thus letting `__init__` set up the
    connection pool for us, and getting the resulting `Database` instance in the `database`
    variable (note that `__init__` will return the instance even though we didn't
    write an explicit `return` statement).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the instance `database`, we use it to execute a simple `SELECT`
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Again, even though `execute_query` takes `self` as its first argument, we don't
    need to pass it explicitly. Instead `database` itself is passed to `self`.
  prefs: []
  type: TYPE_NORMAL
- en: This query has no parameters, so we let the `params` argument have the default
    value (an empty tuple) by not specifying it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we use `st.write` to display the results of the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at the page now by typing `streamlit run main.py` (make sure you're
    in `main.py`'s containing folder first so that Streamlit can find the `.streamlit`
    folder). You should see something similar to figure 8.6.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/ch08__image006.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 The contents of the haiku table as read by executing a SELECT query
    using the Database class and displayed using st.write (see chapter_8/in_progress_01
    in the GitHub repo for the full code)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One interesting thing here is how `st.write` formats the list of tuples within
    `query_results` in an easy-to-read form.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, our app is now connected to a database! Next up, let's use this
    to allow users to create accounts!
  prefs: []
  type: TYPE_NORMAL
- en: 8.3 Creating user accounts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since our users can create their own haikus, there needs to be a way for them
    to create Haiku Haven accounts to hold their haikus. In this section, we'll wire
    up our app to enable this, taking care to store passwords securely.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get to that though, let's take a minute to talk about code organization.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.1 Splitting our app into services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Chapter 3, we discussed the principle of *separation of concerns*—the idea
    that each component of our app should focus on a specific thing and be independent
    of the other components, interacting with them only in ways that are specified
    by a contract or API.
  prefs: []
  type: TYPE_NORMAL
- en: We'll do something similar here, separating the frontend and backend as we did
    in that chapter. Since we're using classes and *object-oriented programming* this
    time, we could define a backend class*—*let's call this `Hub`—that can be the
    single point of contact for frontend code to call backend code. Any function that
    the frontend can call should be a method in the `Hub` class. This is analogous
    to `backend.py` in Chapter 3 where every backend function called from the frontend
    code was defined in `backend.py`.
  prefs: []
  type: TYPE_NORMAL
- en: We might expect the `Hub` class to have methods that fulfill actions a frontend
    user might want to take, such as `create_user`, `create_haiku`, `update_haiku`,
    etc. Over time, though, as our app grows more and more complex, the `Hub` class
    would have an increasing number of methods, slowly making it unwieldy and difficult
    to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than take this *monolithic* approach, it might be a better idea to divide
    up the actions offered by Hub into individual *service classes*, each pertaining
    to a specific kind of action, and using the `Hub` class as merely a coordinator.
    For instance, we could have a `UserService` class that offers methods pertaining
    to users, such as `create_user`, and a `HaikuService` class that offers those
    related to haikus, such as `create_haiku` and `update_haiku`.
  prefs: []
  type: TYPE_NORMAL
- en: This would make our app more modular and easier to extend and maintain. We can
    add more user-related functionality to `UserService` independently of the haiku-related
    actions in `HaikuService`, and if we wanted to add limericks to our app later,
    we could introduce a `LimerickService` without touching either.
  prefs: []
  type: TYPE_NORMAL
- en: With our overall code organization strategy in mind, let's turn our attention
    towards building one of the components—the user service.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.2 Creating the user service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as in prior chapters, we'll use a dataclass to represent the fundamental
    objects we're concerned with. In Chapters 3, 4, and 6, we had `Unit`, `Task`,
    and `Metric` classes. Here, we'll start with a `User` class.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Python file called `user.py` in the `backend` folder, with the
    text shown in listing 8.4.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.4 backend/user.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: You'll see that this directly mirrors the `users` table in our database, with
    fields for `username` and `password_hash`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now talk about the latter field, and why we called it `password_hash`
    instead of `password`.
  prefs: []
  type: TYPE_NORMAL
- en: Storing passwords securely
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passwords are naturally some of the most sensitive pieces of information software
    developers need to deal with, and much of the field of cybersecurity focuses on
    keeping them secret.
  prefs: []
  type: TYPE_NORMAL
- en: We know that we shouldn't store passwords in our code, resorting to the construct
    of `st.secrets` to avoid this. But what about storing them in a database?
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, our app needs to be able to compare a user-entered password with
    the one actually associated with the user, so passwords need to be stored in some
    form. However, storing them directly as plain text in a database introduces a
    security vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: That's because anyone who gains access to our database—through some kind of
    security breach—will be able to see passwords in their raw form. How do we avoid
    this though?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is: with *one-way cryptographic hash functions*, or in other words,
    a bit of fancy math. It turns out that there are certain mathematical operations
    that are easy to perform normally but extremely difficult to perform in reverse.
    As a trivial example, consider multiplying two prime numbers a and b to get c.
    Multiplying a and b to get c is easy, but if you''re only given c, identifying
    a and b is difficult, especially when c is very, very large (think hundreds of
    digits long).'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can think of a cryptographic hash function as an operation performed
    on a password that's very difficult to reverse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say someone''s password is `SomePassword123`. If you apply a hash function
    `H` to it, you might get a password hash that looks like a random sequence of
    characters:'
  prefs: []
  type: TYPE_NORMAL
- en: Rather than store the string `SomePassword123` directly in the database, we
    store `g53jkdlgfee09ded8d33rr45t5y5y43f2eff`. Then when someone enters a password
    in our app, we apply the hash function to *that* password and compare the result
    to `g53jkdlgfee09ded8d33rr45t5y5y43f2eff`. If the two are the same, the user is
    authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: How does this help with security? Well, if a hacker now manages to get into
    our database, they don't have the actual password, only the password hash. As
    stated, it's very difficult to obtain the password from the password hash.
  prefs: []
  type: TYPE_NORMAL
- en: The password hash itself is useless to the hacker as there's no point entering
    it in the app—if you did, the app would just apply the hash function on it and
    come up with a completely different hash that's compared against the real one.
  prefs: []
  type: TYPE_NORMAL
- en: How do we implement this in our app? Fortunately, we don't have to do it from
    scratch. There are third-party libraries that do it for us. We'll use `bcrypt`,
    which you should install now with `pip install bcrypt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add two more methods to our `User` class so it now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We've decorated the `hash_password` method with `@staticmethod`. This makes
    it belong to the class itself rather than to any specific instance of the class.
    We generally use `@staticmethod` for utility functions that are logically related
    to a class but don't actually need to access anything from a particular instance.
  prefs: []
  type: TYPE_NORMAL
- en: '`hash_password` is a good fit for this since it doesn''t need to access any
    of the instance''s attributes or methods (note the absence of a `self` parameter).
    Rather, it simply accepts a password entered by a user, converts it into a hash
    using `bcrypt`, and returns it.'
  prefs: []
  type: TYPE_NORMAL
- en: I won't go into the details of how this works, but at a high level, we're taking
    an extra measure of security here by adding a random "salt" to the password (`bcrypt.gensalt()`)
    before hashing it. This salt helps protect the password against hackers simply
    looking up the password associated with a password hash from a huge pre-computed
    table of such hashes (called a *rainbow table*).
  prefs: []
  type: TYPE_NORMAL
- en: We also have an `authenticate` method that we'll use when a user enters a password.
    `bcrypt.checkpw` compares the entered password (`password.encode()`) and the password
    hash stored in the `User` object (`self.password_hash.encode()`), returning `True`
    if they match.
  prefs: []
  type: TYPE_NORMAL
- en: The UserService class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We're now ready to create the `UserService` class, the one we determined would
    have methods for user-related operations. Create a `user_service.py` file under
    `backend/` with the content in listing 8.5.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.5 backend/user_service.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`UserService` has a `__init__` method that accepts an instance of the `Database`
    class we created earlier and assigns it to a `database` attribute (`self.database`)
    of the object.'
  prefs: []
  type: TYPE_NORMAL
- en: When a user enters a username and password to create a user, we first need to
    check if a user of that username already exists, so we have a `get_user` method
    that returns the user if one exists or `None` if it doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: The `get_user` method executes a parameterized SQL query (`SELECT username,
    password_hash FROM users WHERE username = %s`) on the database, passing the given
    username as the only parameter (`(username, )`).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''ve seen before, this returns a list of tuples. Due to the `SELECT username,
    password`, these will be of the form `(<username>, <password_hash>)`. Consider
    the last line in `get_users`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If there's no user with the given username, results will be an empty list, so
    it'll evaluate to `False`, causing `get_user` to return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: If there *is* such a user, `results[0]` will be a tuple of the form `(<username>,
    <password_hash>)`. In Python, the `*` operator when applied to a tuple (or a list),
    *destructures* it for use in things like function calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'So `User(*results[0])` is equivalent to `User(<username>, <password_hash>)`
    which creates a new instance of the `User` dataclass (which you''ll recall has
    two corresponding members: `username` and `password_hash`).'
  prefs: []
  type: TYPE_NORMAL
- en: The `create_user` method first uses `self.get_user(username)` to see if a user
    already exists with the given username. If it does, it simply returns `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it doesn''t, it issues the following query to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This is an `INSERT` query, which we've seen previously. The only new thing here
    is the line `RETURNING username, password_hash`. An `INSERT` query doesn't generally
    need to return any results, as it's a modify operation, not a read operation.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the `RETURNING` clause makes it return the specified fields in the same
    way that a `SELECT` query would. In this case, the `username` and `password_hash`
    of the newly created row are returned.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, `create_user` uses the same approach as `get_user` (`User(*results[0])`)
    to create and return a `User` object if everything is successful.
  prefs: []
  type: TYPE_NORMAL
- en: The Hub class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we spoke of code organization earlier, we mentioned the `Hub` class, which
    would be the single point that our frontend code would access. Let's write that
    class now. Create `backend/hub.py` with the code from listing 8.6.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.6 backend/hub.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Hub` class''s `__init__` is quite simple: it accepts a `config` object
    (a dictionary of configuration options, such as the one obtained by parsing the
    `secrets.toml` file we created earlier), creates a `Database` object, and passes
    it to `UserService` to create an instance of that class.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Hub` has no other methods. This makes sense because, as we''ve emphasized,
    `Hub` is simply a coordinator class that our frontend can use to access the various
    service class objects (of which `user_service`, an instance of `UserService`,
    is the only one we''ve created so far).'
  prefs: []
  type: TYPE_NORMAL
- en: The signup page
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Working our way from the bottom up, we've created a `User` class, a `UserService`
    class that accesses the `User` class, and a `Hub` class that accesses the `UserService`
    class—which currently only has a `create_user` method.
  prefs: []
  type: TYPE_NORMAL
- en: The part of our Streamlit app that accesses `create_user` will be the signup
    page, which we'll define—for now—in `main.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Our previous `main.py` initialized the `Database` object directly and executed
    a sample query. Since the database is now initialized in the `Hub` class, we'll
    rewrite `main.py` entirely, as shown in listing 8.7.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.7 main.py revised
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: By this point in the book, you should be able to read the code in listing 8.7
    fairly easily.
  prefs: []
  type: TYPE_NORMAL
- en: It starts by creating an instance of `Hub` using the `'config'` entry of `st.secrets`
    (note here that `Hub` accepts the entire `config` object rather than just the
    connection string in case there are other configurations that need to be considered).
  prefs: []
  type: TYPE_NORMAL
- en: Next, it displays the usual username-password-confirm password set of inputs
    I'm sure you've seen in various websites before. On clicking the "Create account"
    button, if the passwords in the two inputs don't match, an error is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If they do match, we call the `create_user` method defined in the `UserService`
    class to create the user in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We then show a success or error message based on the return value.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should be able to see figure 8.7 if you rerun the app.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/ch08__image007.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 Haiku Haven's signup page (see chapter_8/in_progress_02 in the GitHub
    repo for the full code)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Try creating an account with the username `bob`. To verify that it worked and
    that a user has indeed been created, you can issue the query `SELECT * from users
    where username = ''bob''` in your `psql` prompt (which you''ve hopefully kept
    open). This should give you something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, due to the hashing, `bob`'s password is no longer directly visible.
    But can `bob` log in? Not until we've completed the next part!
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 Setting up a multi-page login flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw earlier—when we sketched out the user experience—that Haiku Haven is
    meant to be a multi-page app with different pages for signup, login, and the haiku-related
    functionality, something we haven't encountered before.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.1 Multi-page apps in Streamlit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Streamlit has built-in support for multi-page apps. In this scheme, you define
    your individual pages separately, and let your entrypoint file (the one you run
    with `streamlit run`) act as a "router" that identifies the page to load and runs
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The entrypoint file is quite crucial here; it's loaded as usual in every re-run,
    and it's the one that picks the "current page" to load.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see an example. So far in our app, we've created a signup page for users
    to create their accounts, but not a login page. Once we do create the login page,
    there needs to be a way to tie the two together, making them part of the same
    app.
  prefs: []
  type: TYPE_NORMAL
- en: We'll do that by revising the `main.py` file one more time, using the multi-page
    approach discussed above. The signup flow we included in `main.py` will have to
    move to a different file (`frontend/signup.py`). The new `main.py` is shown in
    listing 8.8.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.8 main.py revised (yet again)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The first new thing you''ll notice here is the `pages` dictionary. The keys
    in `pages` are `"login"` and `"signup"`, which are the names of the pages we want
    in our app. The values are `st.Page` objects. Let''s inspect the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`st.Page` is Streamlit''s way of defining a single page in a multi-page app.
    The first argument you pass it is the path to the Python script for that page—in
    this case, `frontend/login.py`, which doesn''t exist yet. We''ve also passed it
    a sensible title.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last argument is an icon for the page. It has a curious value: `:material/login:`.'
  prefs: []
  type: TYPE_NORMAL
- en: This demonstrates a neat way to display icons in Streamlit. The syntax `:material/<icon_name>:`
    is accepted by most widgets that accept displayable text, and is converted to
    an image when rendered to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: You can see the supported icons in Google's Material Symbols library at `https://fonts.google.com/icons?icon.set=Material+Symbols`.
    In this case, we've chosen the "Login" icon. Whenever you need to show an icon,
    you can go to that URL, click the icon you want, identify its icon name from the
    sidebar that opens to the right, and substitute it within the text `:material/<icon_name>:`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now turn your focus to the following lines further below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're feeding the two `st.Page` objects in the `pages` dictionary (`pages['login']`
    and `pages['signup']`) to `st.navigation`, a new Streamlit widget.
  prefs: []
  type: TYPE_NORMAL
- en: '`st.navigation` is used to configure the available pages in a multi-page Streamlit
    app, displaying a navigation bar that users can use to select the page they want
    to go to.'
  prefs: []
  type: TYPE_NORMAL
- en: It accepts a list of `Page` objects that form the navigation options, and returns
    a single `Page` object from the list. This returned item is the page selected
    by the user, or the first item in the list if nothing has been selected yet.
  prefs: []
  type: TYPE_NORMAL
- en: Once a page has been returned, it can be loaded using its `.run()` method.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also see that we're saving the `Hub` instance (`hub`) to `st.session_state`,
    but not doing anything else with it. This is because the session state is shared
    between the pages in a multi-page app. So if you save something to `st.session_state`
    in any page, it will be accessible in the other pages too. In this case, we're
    going to be using the saved `hub` object in the other pages.
  prefs: []
  type: TYPE_NORMAL
- en: What about the signup flow we had earlier? Well, now that our app is multi-page,
    we'll move it to its own page, `signup.py`, within a new folder called `frontend`.
    As you'll see from listing 8.9, the content has mostly just been copied directly
    from our earlier `main.py` with no changes.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.9 frontend/signup.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The only change we've made (as compared to listing 8.7) is that we obtain the
    value of the `hub` variable from `st.session_state` where we saved it in the new
    `main.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.2 Implementing login
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With our multi-page app infrastructure in place, it's time to build out the
    login feature. Before we set up the login page, let's make sure our backend has
    the functionality we need.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating a user in UserService
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we''ve discussed, all user-related functionality needs to live in `UserService`.
    Currently, that class has `create_user` and `get_user` methods. We''ll implement
    a new `get_authenticated_user` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`get_authenticated_user` accepts a username and password as arguments. It first
    calls the `get_user` method we defined earlier to see if a user exists with that
    username. If there is, it calls the `authenticate` method on the returned `User`
    object. Recall that the `authenticate` method in the `User` class compares the
    hash of the given password with that of the actual password.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the authentication succeeds, the `User` object is returned. If it doesn''t,
    the method returns `None`, which the calling code can interpret in two ways: either
    no such user exists or the password is incorrect. To keep things simple, we won''t
    distinguish between these in the return value.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the login page
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: That's all we need in `UserService`. We can now go ahead and create a login
    page to complement the signup page we made earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file in `frontend/` called `login.py`, with the content shown in
    listing 8.10.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.10 frontend/login.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This page is fairly similar to `signup.py`, and should be straightforward to
    follow with your current understanding of Streamlit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The part to focus on here is what happens when the "Log in" button is clicked.
    We first call the authentication method we defined in `UserService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As we saw, if the method returns a `User` object, authentication has succeeded;
    if it returns `None`, authentication has failed.
  prefs: []
  type: TYPE_NORMAL
- en: We write this condition as if `user:`. For the actual logging in, we'll use
    a very simple approach—storing a boolean variable called `logged_in` under `st.session_state`,
    along with the `User` object for the logged-in user (named simply as `user`).
  prefs: []
  type: TYPE_NORMAL
- en: We also display a success or error message depending on whether the login succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should re-run your app using `streamlit run main.py`. Try
    logging in with the account you created previously. You should see something similar
    to figure 8.8.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/ch08__image008.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 Haiku Haven's login page (see chapter_8/in_progress_03 in the GitHub
    repo for the full code)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Note the navigation panel created by `st.navigation`, which takes up the sidebar
    and contains links to navigate to either page (along with the icons we added!).
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.3 Navigating between pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While we currently have the bare minimum that we need in a signup/login flow,
    there's definitely room for improvement. For instance, if the user is on the login
    page but doesn't have an account, there should be a helpful link right there to
    sign up, or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Also, when the user logs in, we should take them to some kind of logged-in page
    and give them the ability to log out.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.9 lays out the ideal signup/login/logout flow we want to design.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/ch08__image009.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 Diagram showing the connections between pages through redirection
    and page links
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Besides being able to go back and forth between the signup and login pages,
    and redirect to a home page when logged in, we also want the navigation panel
    to display different options based on if we're logged in or not.
  prefs: []
  type: TYPE_NORMAL
- en: If the user is logged in, they should see the home page and have the ability
    to log out—which shows them the login page again. If they're not, they should
    instead see the options to sign up or log in.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the pages dictionary to its own file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since we're now going to be navigating between individual pages, it would be
    cleaner to put the `pages` dictionary (the one in `main.py` that defines the available
    pages) in its own separate file, so let's move that part of the code to `frontend/pages.py`,
    shown in listing 8.11.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.11 frontend/pages.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll notice that we''ve added two new pages: `home`, which is supposed to
    represent the logged-in home page, and `logout`, which will log the user out.'
  prefs: []
  type: TYPE_NORMAL
- en: Links between pages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Streamlit allows you to create links between pages in a multi-page app through
    a widget that is, appropriately enough, named `st.page_link`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use this to link between the `login` and `signup` pages.
  prefs: []
  type: TYPE_NORMAL
- en: '`login.py` should look like this, with the page link added to the very bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '`st.page_link` is quite easy to understand; the first argument is the `st.Page`
    object (from `pages`, imported from `pages.py`) we want to link to, and the second
    is the label text.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also pass a regular URL as the first argument, in case you want to
    link to an external page. `signup.py` has very similar changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Dynamically changing st.navigation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next feature we'll implement is showing the user the right pages for their
    context in the navigation bar, i.e. `signup` and `login` when they're logged out,
    or `home` and `logout` when they're logged in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `main.py` so it now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, the `pages` dictionary is now defined in `pages.py` and imported
    into `main.py`.
  prefs: []
  type: TYPE_NORMAL
- en: As shown above, to dynamically change what's in the navigation panel, we use
    the `logged_in` session state variable that we save when the user logs in, and
    vary the `st.navigation` object that's assigned to `page` accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: If the user is logged in, the navigation bar will now show the `home` and `logout`
    options. Since `pages['home']` is the first item in the list passed to `st.navigation`,
    that's the page that will be loaded by default when the user logs in.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now actually set up a placeholder page in `frontend/home.py` (listing
    8.12), so that there's something for a logged-in user to see.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.12 frontend/home.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Nothing earth-shattering here for now; we just display a greeting that includes
    the logged-in user's username. Recall that we save the logged-in `User` object
    in `st.session_state.user` in `login.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic redirection for login and logout
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our proposed ideal login flow requires the user to be redirected automatically
    on login and logout. How does this work exactly?
  prefs: []
  type: TYPE_NORMAL
- en: Remember that when a user clicks the "Log in" button, the `logged_in` session
    state variable is set to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: This means that in the next re-run, `main.py` will pick up the changed value
    of `logged_in`, display the new navigation panel and load `home.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this truly seamless, we have to trigger the re-run though. So add an
    `st.rerun()` to `login.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: And logging out? Well, that's going to reverse everything that happens at login.
    Create a `logout.py` with content shown in listing 8.13.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.13 frontend/logout.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: That completes our signup/login/logout flow! Re-run the app and try it all out!
    When you log in, you should now see a different navigation panel and the loaded
    home page (see figure 8.10).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/ch08__image010.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 The logged-in page with different options in the navigation bar
    (see chapter_8/in_progress_04 in the GitHub repo for the full code)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Clicking "Log out" in the navigation bar will load the login and signup pages
    again, which have page links to each other at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 Creating, reading, updating, and deleting haikus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that user authentication is taken care of, it''s finally time to work on
    the crux of our app: the ability to create, read, update and delete haikus. We''ll
    start with haiku creation, encapsulating this behavior in a `HaikuService` class,
    and then making the appropriate changes to the frontend.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.1 Defining a HaikuService class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code structure we'll follow in the haiku service is pretty analogous to
    what we already have in `UserService`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin with a `Haiku` dataclass to represent a haiku. Create this as `haiku.py`
    in the `backend/` folder (listing 8.14).
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.14 backend/haiku.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: As in the `User` class, the fields mirror those in our corresponding database
    table (`haikus`).
  prefs: []
  type: TYPE_NORMAL
- en: '`HaikuService` itself is shown in listing 8.15.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.15 backend/haiku_service.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Again, the code is fairly analogous to that of `UserService`, so a detailed
    explanation isn't warranted.
  prefs: []
  type: TYPE_NORMAL
- en: As we've seen, we only need to supply the `author` and `text` fields in our
    SQL query; the database automatically provides `haiku_id` and `created_at`, and
    all of the fields are returned as per the `RETURNING` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'To wrap up the backend changes, let''s add an instance of `HaikuService` to
    `hub.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This will enable the haiku creation function to be accessed from the frontend,
    as we'll see presently.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.2 Enabling users to create haikus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our earlier `home.py` was, of course, just a placeholder. Our actual logged-in
    home page should ideally have a way to create haikus and display them.
  prefs: []
  type: TYPE_NORMAL
- en: For creating haikus, let's create a modal dialog similar to the one we created
    in Chapter 7.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file, `frontend/haiku_editor.py` as shown in listing 8.16.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.16 frontend/haiku_editor.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The `haiku_editor` function is decorated with `st.dialog`—which, as we saw in
    this previous chapter, executes its body in a modal screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of `haiku_editor` is uncomplicated. We first accept the haiku text
    entered by the user in an `st.text_area` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '`st.text_area` is precisely what you''d expect it to be—an area for entering
    several lines of text.'
  prefs: []
  type: TYPE_NORMAL
- en: On clicking "Save haiku", we call the `create_haiku` method under `HaikuService`
    to save it to the database, and show the appropriate success/failure message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Close the loop by including—in `home.py`—an "Add Haiku" button that triggers
    the `haiku_editor` dialog we just defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we're using a Material icon again, this time in the place of
    the word "Add" within the button label.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see everything working so far! Re-run your Streamlit app, login, and add
    a haiku (see figure 8.11).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/ch08__image011.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 Creating a haiku (see chapter_8/in_progress_05 in the GitHub repo
    for the full code)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To convince yourself that a haiku has indeed been created, you can query your
    `haikus` table.
  prefs: []
  type: TYPE_NORMAL
- en: '8.5.3 The other CRUD operations: Read, Update, Delete'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make our CRUD app feature complete, there are three more operations we need
    to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Reading* the current users'' haikus from the database and list them in the
    app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Updating* a given haiku'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deleting* a haiku altogether'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the operations in HaikuService
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As before, let''s define these operations in the backend first, by editing
    the `HaikuService` class in `haiku_service.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We define one method for each operation: `get_haikus_by_author` for reading
    haikus, `update_haiku` for updating, and `delete_haiku` for deleting a haiku.'
  prefs: []
  type: TYPE_NORMAL
- en: In each case, we use the same pattern we've seen before—we run a SQL command,
    convert the results into Haiku objects, and return them.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `get_haikus_by_author`, we return the results as a *list* of
    Haiku objects given that there may be more than one by a certain author.
  prefs: []
  type: TYPE_NORMAL
- en: In both `update_haiku` and `delete_haiku`, we accept `haiku_id`—the unique identifier
    of a haiku—as an argument, using `UPDATE..SET` and `DELETE FROM` SQL commands
    respectively to achieve the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the UI
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our backend methods return instances of the `Haiku` class, but how do we display
    these in the frontend?
  prefs: []
  type: TYPE_NORMAL
- en: 'We should probably create a `display_haiku` function that accepts a `Haiku`
    object and displays it on the screen. The next natural question is: what do we
    display? What is the user likely to be interested in seeing?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Haiku` class has four attributes: `haiku_id`, `created_at`, `author`,
    and `text`.'
  prefs: []
  type: TYPE_NORMAL
- en: Of these, `haiku_id` is an internal identifier that would be of no meaning to
    the end user, so we can exclude that. `created_at` might be useful to jog the
    user's memory of when a haiku was originally created. It would be redundant to
    show the `author` field since we're only going to be displaying haikus by the
    current logged-in user. And `text` is the content of the haiku, so we obviously
    want to display that.
  prefs: []
  type: TYPE_NORMAL
- en: 'That gives us: `created_at` and `text`. Anything else? Well, we also want to
    give the user the option to edit or delete a particular haiku, so let''s pop in
    a couple of buttons as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.17 frontend/haiku_display.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The key function to focus on here is the last one: `display_haiku`. Given `haiku`,
    an instance of the `Haiku` class, it makes four columns for the four things we
    want to display: `created_at`, `text`, the edit button, and the delete button.'
  prefs: []
  type: TYPE_NORMAL
- en: The actual rendering of each of these takes place in its own function.
  prefs: []
  type: TYPE_NORMAL
- en: '`get_haiku_created_display` takes haiku''s `created_at` property—a timestamp—
    and breaks it down into a day and a time using a method called `strftime`, which
    is used to format a timestamp in any given format based on a *format string*.
    In this case, `%Y-%m-%d` formats it as just a date, whereas `%H:%M` extracts the
    time in hours and minutes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: There are a few things going on here. The `:<color>[<text>]` syntax is used
    in Streamlit to display text in various colors. For instance, the string `:red[Hello]`
    would be interpreted by widgets like `st.write` or `st.markdown` as the word `Hello`
    in red text.
  prefs: []
  type: TYPE_NORMAL
- en: We also see the icon syntax we saw earlier. Here we're using a calendar icon
    for the date and a clock icon (`schedule`) for the time, creating a user-friendly
    display for the date and time.
  prefs: []
  type: TYPE_NORMAL
- en: '`get_haiku_text_display` is meant to display the content of the haiku. Why
    do we have the following replace method? Why not just display the content directly?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: This is something of a workaround. Streamlit handles line breaks in text rather
    strangely. To get text widgets like `st.markdown` to display the newline character
    `\n` properly, we have to precede it with two spaces, i.e. `' \n'` instead of
    just `'\n'`.
  prefs: []
  type: TYPE_NORMAL
- en: The `edit_button` and `delete_button` functions simply display `st.button` widgets.
    You'll notice that we use icons as their labels, and give them widget keys—which
    is required for Streamlit to distinguish between them when we have many haikus
    displayed on a page. We've given them placeholder bodies with `pass` for now;
    we'll come back to them later.
  prefs: []
  type: TYPE_NORMAL
- en: Since we're using icons so much throughout the app, our code would actually
    be a lot more readable if we gave them better names (e.g. `CLOCK` instead of `:material/schedule:`)
    and put them in a more central location.
  prefs: []
  type: TYPE_NORMAL
- en: Let's put all the icons in their own file, `frontend/icons.py` (listing 8.18)
    and *import* them instead.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.18 frontend/icons.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now change `haiku_display.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'There—that''s much more readable! Let''s now call `display_haiku` to show the
    user their list of created haikus! We''ll edit `home.py` to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The changes here are quite simple. After the add button we created earlier—which
    we've now changed to use an icon imported from `icons.py`—we display a header
    that says `<username>'s haikus` along with a divider (just a horizontal line underneath,
    controlled by `divider="gray"`).
  prefs: []
  type: TYPE_NORMAL
- en: We then call the `get_haikus_by_author` method we defined in `HaikuService`,
    and loop through the results, calling `display_haiku` on each. If there are no
    haikus, we display an `st.info` message that says so.
  prefs: []
  type: TYPE_NORMAL
- en: Re-run your app now to see the changes in figure 8.12 (after adding one more
    haiku)!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/ch08__image012.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 Listing created haikus (see chapter_8/in_progress_07 in the GitHub
    repo for the full code)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Note that there''s one more place we''ve been using icons: `pages.py`, where
    we''ve defined the pages for the multi-page app. Go ahead and update that file
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Adding the update and delete functionality
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s get back to the edit and delete buttons, which currently have placeholders
    under them. The edit button should let a user edit one of their existing haikus.
    We can repurpose the haiku editor dialog we''ve already created to work with the
    "Add Haiku" button for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The `haiku_editor` function now accepts a `haiku` argument which is `None` by
    default. If we're calling the editor to edit an existing haiku, we can pass the
    corresponding `Haiku` instance to `haiku`. Otherwise we're calling the dialog
    to add a haiku, so we pass `None`.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of the function, we'll use the condition `if haiku` to check if
    we're performing the edit action or the add action.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two lines, we pre-populate the existing haiku's text in the text
    area as a default value using the `value` parameter of `st.text_area` if we're
    in the edit action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Then, once the save button is clicked, we pick either the `update_haiku` or
    the `create_haiku` method from `HaikuService` to execute. In the former case,
    we pass the existing haiku's `haiku_id` to identify the haiku we want to edit.
  prefs: []
  type: TYPE_NORMAL
- en: If the operation is successful—which we determine by checking the return value,
    `new_haiku`—we issue an `st.rerun()`. This re-runs the entire app, closing the
    dialog in the process, because the button that triggered it in the first place
    is now in the "unclicked" state.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now replace the placeholder under the edit button in `haiku_display.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same page, let''s also make the delete button trigger a deletion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Here we call the `delete_haiku` method in `HaikuService`. If the deletion is
    successful, we perform an `st.rerun()` so that the list of haikus can update and
    no longer show the deleted haiku. If the deletion fails for any reason, we show
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: Re-run the app now and try editing or deleting a haiku (figure 8.13)!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/ch08__image013.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 Deleting a haiku (see chapter_8/in_progress_08 in the GitHub repo
    for the full code)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Haiku Haven has now been fully built—or at least we have a version that's fit
    to deploy to production. Before we do that though, there are a couple of final
    issues we need to address.
  prefs: []
  type: TYPE_NORMAL
- en: 8.6 Multi-user considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Haiku Haven can be used by many users simultaneously, we need to be able
    to share resources efficiently between these users. The main resource that we're
    responsible for managing here is the database.
  prefs: []
  type: TYPE_NORMAL
- en: 8.6.1 Using st.cache_resource to share the database connection pool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's consider how a Streamlit app works when there are multiple users accessing
    it simultaneously. While there's a single Streamlit server that serves the app,
    each time a user accesses it, a new instance of the app is created, with all of
    the objects required to run the app created anew for that user.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, this is what we want; it makes sure different user sessions
    don't interfere with each other. However, there are some things we *don't* want
    to create anew each time someone loads the app in a new browser tab.
  prefs: []
  type: TYPE_NORMAL
- en: A key example is the database connection pool we create in the `Database` class.
    In fact, the whole point of having a database connection pool is that when multiple
    user sessions need to access the database, they can do so by requesting connections
    from a *shared* pool, returning them when they're done.
  prefs: []
  type: TYPE_NORMAL
- en: This means that there should only be *one* instance of the `Database` class
    ever created, to be shared across all users. However, we haven't set it up that
    way. Right now, *whenever* a new user loads the app—or a user loads the app in
    a new browser tab—a new session begins, and a new instance of the `Hub` class
    is created, which means a new `Database` instance is also created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Streamlit offers a solution for this: `st.cache_resource`.'
  prefs: []
  type: TYPE_NORMAL
- en: Like `st.cache_data`—which we used in Chapter 6 to make loading the data in
    our metric dashboard faster—`st.cache_resource` is a way to make sure that only
    one instance of something exists across all users of an app.
  prefs: []
  type: TYPE_NORMAL
- en: While `st.cache_data` is used for caching things like Pandas dataframes or the
    results of API calls, `st.cache_resource` is used for resources like database
    connections. In this case, we'll use it to store the single instance we want to
    create of the `Database` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This requires refactoring our app a little. Recall that currently (in `hub.py`)
    our `Hub` class accepts a `config` object and creates the `Database` instance
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: But in our new scheme, the `Hub` class will continue to have a new instance
    created for every session, which means a new `Database` instance will *also* keep
    getting created. Instead, we'll have `Hub`'s `__init__` accept an *already-created*
    `Database` instance that it can simply pass to `UserService` and `HaikuService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'That way, we can always pass the *same* instance of the `Database` class, avoiding
    creating it every time. `hub.py` will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Where do we create the `Database` instance then? In `main.py`, which is where
    we''ll use `st.cache_resource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: As is the case with `st.cache_data`, `st.cache_resource` is a decorator that's
    applied to a function. Here we define a new function to decorate called `get_database`
    which will return the cached `Database` object.
  prefs: []
  type: TYPE_NORMAL
- en: '`get_database` will now run only once for a particular Streamlit server that''s
    started up, i.e. a single `streamlit run` command—when `main.py` is loaded for
    the first time. For all subsequent runs, `get_database` will return the cached
    `Database` instance, thereby making sure only one such instance is ever created.
    This cached instance will persist until the server process is terminated.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.6.2 Using atexit to clean up database connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've made sure that a `Database` instance is only created once per running
    instance of a Streamlit app server. That's one part of managing our database resource
    efficiently. The other is safely cleaning up any connections we create.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Database` class has a `close_all` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: If you inspect our code so far, however, we're not actually calling this method
    anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: To clean up our connections correctly, we want this method to be called only
    once, when the Streamlit server is terminated. How do we accomplish this?
  prefs: []
  type: TYPE_NORMAL
- en: The solution is the `atexit` module, which comes built-in with Python. `atexit`
    lets you register functions to be executed automatically when the Python interpreter
    is about to exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we would modify `main.py` to register a function that cleans up
    our database connections using `atexit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '`atexit.register` accepts a function to register, along with the values of
    any parameters we want to pass to the function. In the above code, the function
    we''re registering is a one-line lambda function: `lambda db: db.close_all()`.'
  prefs: []
  type: TYPE_NORMAL
- en: It accepts one parameter—`db`, which is the database instance. All the function
    does is to invoke `db`'s `close_all` method. The second parameter we pass to `atexit.register`
    is `database`, which is the `Database` instance created in the line above.
  prefs: []
  type: TYPE_NORMAL
- en: Calling `atexit.register` "schedules" a function to be executed when Python
    itself exits, which, in the case of `streamlit run`, happens when the Streamlit
    server shuts down.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we put the call to `atexit.register` within `get_database`? Why not put
    it somewhere else, perhaps at the end of the file? Well, like the creation of
    a `Database` object, we only want to perform the registration of the function
    with `atexit` *once* across all users—because there's only one Streamlit server.
    That means we have to call `atexit.register` within a function decorated with
    `st.cache_resource`, or this registration would happen multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: To see this change in action, try restarting the app server with `streamlit
    run`, and then press `Ctrl+C` to exit it. You should see the message `Closing
    all connections...` which indicates that `close_all` has been called.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7 Deploying Haiku Haven
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we have Haiku Haven working locally, it''s time to productionize our
    app on Community Cloud. The process to do so is the same as what we''ve been following
    since Chapter 5, but there''s an additional wrinkle here: our app requires a running
    PostgreSQL server to host our database.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.1 Setting up a managed PostgreSQL server in production
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While we were developing locally, it was a simple matter to install PostgreSQL
    on the same machine, but Streamlit Community Cloud doesn't provide an option to
    do that. Instead, we need to set up an external PostgreSQL server somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use a cloud-based managed PostgreSQL service called Neon, which makes
    this process super-easy, and has a significant free quota. Create an account with
    Neon now at `https://neon.tech/`. The signup process is quite painless; you can
    choose to sign up with your GitHub or Google account if you like.
  prefs: []
  type: TYPE_NORMAL
- en: You'll be asked for a project name and a database name. The project name can
    be whatever you like (`Haiku Haven`, maybe?), while the database name should be
    whatever you named your database in your local Postgres—`haikudb` if you've been
    following along faithfully.
  prefs: []
  type: TYPE_NORMAL
- en: You might also be asked to choose a cloud provider and location—these can be
    whatever you like, though I chose AWS as the provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your account is set up, navigate to the Quick Start page to see a connection
    string that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This is the connection string we'll use in production. Neon has taken the liberty
    of setting up a username (`haikudb_owner`) and password for you. Store this string
    somewhere safe.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you'll need to set up the `users` and `haikus` tables once again in Neon.
    To do this, go to the SQL Editor tab. This is where you can enter SQL commands
    as though you were in the `psql` prompt. To create the tables, refer back to section
    8.2.4 and grab the `CREATE TABLE` commands we executed locally. You can execute
    these commands in Neon's SQL Editor without any changes.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.2 Deploying to Community Cloud
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The rest of the deployment process should be straightforward, and is pretty
    much identical to what we did in Chapter 5.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to create a `requirements.txt` so that Community Cloud knows to install
    the third-party modules needed—primarily `psycopg2` and `bcrypt`.
  prefs: []
  type: TYPE_NORMAL
- en: For reference, listing 8.19 shows the requirements.txt that I used.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.19 requirements.txt
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Notice that I used `psycopg2-binary` instead of `psycopg2`; that's because Community
    Cloud threw an error when I tried to use the latter but not with the former.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've completed deployment, you'll need to copy the contents of `secrets.toml`
    and paste it in Community Cloud's Secrets setting (refer to Chapter 5 for a refresher),
    replacing the connection string with the one you copied from Neon.
  prefs: []
  type: TYPE_NORMAL
- en: That's all, folks! Haiku Haven is now live! Tell all your friends they can unleash
    their seventeen-syllable creativity on your brand new web app!
  prefs: []
  type: TYPE_NORMAL
- en: As for us, let's turn the page on CRUD and try our hand at building AI apps
    next.
  prefs: []
  type: TYPE_NORMAL
- en: 8.8 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CRUD stands for Create-Read-Update-Delete, the four fundamental operations that
    most apps perform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational databases like PostgreSQL organize data in tables with rows and columns
    according to a schema.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the data model for an application involves identifying the entities,
    defining their relationships, listing their attributes, and converting these into
    a schema, often assisted by an Entity-Relationship (ER) diagram.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL (Structured Query Language) supports commands for creating tables (`CREATE
    TABLE`), inserting rows (`INSERT INTO`), reading data (`SELECT..FROM`), updating
    rows (`UPDATE..SET`), deleting rows (`DELETE FROM`) and dropping tables (`DROP
    TABLE`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`psycopg2` is a Python module used to connect to PostgreSQL using a shared
    connection pool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never store passwords in plain text; instead hash them using a library like
    `bcrypt` and store the hashed version. To authenticate, hash the given password
    and compare with the stored hash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`st.Page` objects correspond to individual pages in multi-page apps in Streamlit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`st.navigation` is used to create a navigation bar and specify the pages in
    an app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`st.page_link` creates links between pages in a multi-page app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`st.cache_resource` is used to cache resources like database connections and
    share them between users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `atexit.register` from the built-in `atexit` module to register a function
    to execute when a Streamlit server shuts down.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When deploying to production, you need to set up your database server separately,
    potentially using a managed service like Neon for PostgreSQL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
