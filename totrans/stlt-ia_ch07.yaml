- en: 8 Building a CRUD app with Streamlit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 使用Streamlit构建CRUD应用程序
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Setting up a relational database for persistent storage
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为持久存储设置关系型数据库
- en: Performing CRUD operations using SQL
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SQL执行CRUD操作
- en: Developing a multi-page Streamlit app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发多页Streamlit应用程序
- en: Creating shared database connections in a Streamlit app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Streamlit应用程序中创建共享数据库连接
- en: Authenticating users
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户身份验证
- en: 'In 1957, a science fiction author named Theodore Sturgeon famously said, "ninety
    percent of *everything* is crud". While this was originally a cynical defense
    of the genre of science fiction—the point being that it was no different from
    anything else in that regard—the adage has since taken on a different meaning,
    becoming the worst-kept secret in software engineering: Ninety percent of everything
    is CRUD.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 1957年，一位科幻小说作家Theodore Sturgeon著名地说，“百分之九十的*一切*都是CRUD”。虽然这最初是对科幻小说体裁的一种愤世嫉俗的辩护——其观点是，在这方面它与任何其他事物没有区别——但这个谚语后来获得了不同的含义，成为软件工程中最不为人知的秘密：百分之九十的一切都是CRUD。
- en: By CRUD, I'm referring to Create, Read, Update, and Delete, the four mundane
    operations that appear repeatedly in almost any notable piece of software.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过CRUD，我指的是创建、读取、更新和删除，这四种平凡操作几乎出现在任何著名的软件中。
- en: Think about it. Social media platforms like Facebook revolve around creating
    posts, reading feeds, updating profiles, and deleting content. E-commerce sites
    manage products, orders, customer accounts, and reviews through similar operations.
    Even something as simple as Notepad on Windows centers around creating, reading,
    updating, and deleting text files.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 想想看。像Facebook这样的社交媒体平台围绕着创建帖子、阅读动态、更新个人资料和删除内容。电子商务网站通过类似操作管理产品、订单、客户账户和评论。即使是Windows上的简单记事本也围绕着创建、读取、更新和删除文本文件。
- en: Mastering CRUD operations is essential for building a strong foundation in software
    design, as their implementation often involves tackling non-trivial challenges.
    In this chapter, we'll create a CRUD application with Streamlit, implementing
    these operations from scratch while covering related topics such as user authentication.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 精通CRUD操作对于在软件设计方面打下坚实基础至关重要，因为它们的实现通常涉及解决非平凡挑战。在本章中，我们将使用Streamlit创建一个CRUD应用程序，从头开始实现这些操作，同时涵盖相关主题，如用户身份验证。
- en: '8.1 Haiku Haven: A CRUD app in Streamlit'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 Haiku Haven：Streamlit中的CRUD应用程序
- en: For our excursion into CRUD, we're going with the Japanese art of *haiku*—specifically,
    we will create a website that lets users write and share their own haikus.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的CRUD探险，我们将选择日本艺术中的*俳句*——具体来说，我们将创建一个网站，让用户能够编写和分享他们自己的俳句。
- en: 'For those not intimately familiar with Japanese literature, a haiku is a short
    three-line poem conforming to certain rules: the first and the third lines must
    have five syllables, while the second must have seven. For instance, here''s one
    I wrote about Streamlit:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不太熟悉日本文学的人来说，俳句是一种遵循某些规则的短三行诗：第一行和第三行必须包含五个音节，而第二行必须包含七个音节。例如，这是我关于Streamlit写的一首俳句：
- en: '*So many web apps!*'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*这么多网络应用！*'
- en: '*With Python can I make one?*'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*用Python我能做吗？*'
- en: '*Then I tried Streamlit.*'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*然后我尝试了Streamlit。*'
- en: I know*,* right? I sometimes wonder if I missed my calling too. Regardless,
    you'll notice that the poem adheres to the 5-7-5 syllable rule I mentioned above,
    and is therefore a valid haiku.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道*，*对吧？我有时也怀疑自己是否错过了自己的使命。不管怎样，你会发现这首诗遵循了我上面提到的5-7-5音节规则，因此是一个有效的俳句。
- en: Haiku Haven will be a place where budding poets can author, refine, and manage
    haikus. It will enable users to *create* haikus from scratch, *read* what they've
    created, *update* a haiku once they've created it, and *delete* it if they decide
    it doesn't pass muster.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Haiku Haven将是一个初学者诗人可以创作、精炼和管理俳句的地方。它将使用户能够*从头开始创建*俳句，*阅读*他们所创作的俳句，*更新*他们已经创建的俳句，如果他们决定它不符合标准，则*删除*它。
- en: 8.1.1 Stating the concept and requirements
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 陈述概念和需求
- en: 'As usual, we''ll start by stating the concept of our app succinctly:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们将首先简洁地陈述我们应用程序的概念：
- en: Concept
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 概念
- en: Haiku Haven, a website that allows users to create, edit, and manage haikus
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Haiku Haven，一个允许用户创建、编辑和管理俳句的网站
- en: This concept and our earlier discussion about CRUD should give you a basic idea
    of what we want, but let's spell out the concrete requirements so we're on the
    same page about the Haiku Haven vision.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念以及我们之前关于CRUD的讨论应该给你一个基本的概念，但让我们明确具体的需求，以便我们对Haiku Haven的愿景达成共识。
- en: Requirements
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 需求
- en: 'A user of Haiku Haven should be able to:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Haiku Haven的用户应该能够：
- en: create and log in to an account with a username and password
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用用户名和密码创建和登录账户
- en: create haikus under their username
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在他们的用户名下创建 haiku
- en: view the haikus they've created
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看他们创建的 haiku
- en: update haikus
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 haiku
- en: delete their haikus
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除他们的 haiku
- en: Hopefully you'll realize how frequently you encounter this kind of app. If you
    replace the word "haiku" in the requirements with "image", you get a barebones
    version of Instagram. Substitute "task" to get a productivity tool like Asana
    or "post" to get Twitter or WordPress.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能意识到你经常遇到这类应用。如果你在需求中将“haiku”一词替换为“image”，你将得到 Instagram 的一个基本版本。用“task”替换可以得到像
    Asana 这样的生产力工具，用“post”替换可以得到 Twitter 或 WordPress。
- en: The point is that these requirements aren't just about haikus—they represent
    a universal pattern in software design. Almost every app revolves around managing
    some kind of data, founded on CRUD operations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 重点在于，这些需求不仅仅是关于 haiku 的——它们代表了软件设计中的一个通用模式。几乎每个应用程序都围绕管理某种数据展开，这些数据基于 CRUD 操作。
- en: By building Haiku Haven, you're not just creating a playful app for poetry lovers;
    you're learning how to construct the essential workflows of modern software. You'll
    tackle user authentication, data storage, and retrieval—skills that apply to nearly
    any app or system you might create in the future.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建 Haiku Haven，你不仅为诗歌爱好者创建了一个有趣的应用程序；你还在学习如何构建现代软件的基本工作流程。你将处理用户身份验证、数据存储和检索——这些技能适用于你未来可能创建的几乎任何应用程序或系统。
- en: What's out of scope
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 超出范围的内容
- en: 'We could fit a lot of functionality into Haiku Haven (think of everything you
    can do on Twitter), but we only have one chapter, so we''ll focus on the absolute
    core stuff. That means we *won''t* concern ourselves with:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将很多功能集成到 Haiku Haven 中（想想你可以在 Twitter 上做的一切），但我们只有一个章节，所以我们将专注于绝对核心的内容。这意味着我们
    *不会* 关注：
- en: Making haikus visible to and searchable by other users—haikus are private to
    the author
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使 haiku 对其他用户可见并可搜索——haiku 对作者来说是私有的
- en: '"Social" features such as liking, commenting, and sharing'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “社交”功能，如点赞、评论和分享
- en: Auxiliary functionality like pagination
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 辅助功能，如分页
- en: Advanced security features (though we'll get the basics right)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级安全功能（尽管我们将确保基础正确）
- en: 8.1.2 Visualizing the user experience
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.2 可视化用户体验
- en: Haiku Haven will be our first multi-page app. We'll need to craft multiple experiences
    or flows—the account creation flow, login and logout, and the actual CRUD part
    (creating, reading, updating, and deleting haikus).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Haiku Haven 将是我们的第一个多页面应用。我们需要制作多个体验或流程——账户创建流程、登录和登出，以及实际的 CRUD 部分（创建、读取、更新和删除
    haiku）。
- en: Figure 8.1 attempts to sketch out what the different portions of our app might
    look like.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 尝试勾勒出我们应用的不同部分可能的样子。
- en: '![image](../Images/ch08__image001.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch08__image001.png)'
- en: Figure 8.1 Rough sketches of the pages we want in Haiku Haven
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.1 我们希望在 Haiku Haven 中出现的页面的粗略草图
- en: 'Because of how common these flows are in various common apps, I won''t take
    too much space here to explain them in detail, but here are a few highlights:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些流程在各种常见应用中的普遍性，我不会在这里占用太多空间来详细解释它们，但这里有一些亮点：
- en: The login page uses a password for authentication, which you can set in the
    signup page
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录页面使用密码进行身份验证，你可以在注册页面设置
- en: A "My haikus" page represents the logged-in experience within the app, letting
    users create, view, edit, or delete their haikus.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个“我的 haiku”页面代表了应用内的登录体验，让用户可以创建、查看、编辑或删除他们的 haiku。
- en: There's also a haiku editor page where the authoring of haikus takes place.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还有一个 haiku 编辑页面，在这里进行 haiku 的创作。
- en: 8.1.3 Brainstorming the implementation
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.3 实施构思
- en: Given that Haiku Haven represents CRUD web apps—and thus, by Sturgeon's law,
    90% of *all* web apps—it stands to reason that its implementation should involve
    some very common patterns.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Haiku Haven 代表 CRUD 网络应用——因此，根据斯特金定律，90% 的 *所有* 网络应用——它的实现应该涉及一些非常常见的模式。
- en: 'Indeed, the design we''ll use consists of three components that are seen in
    most live online applications: a frontend, a backend, and a *database*. Figure
    8.2 lays out this approach.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们将使用的设计由三个在大多数在线应用中都能看到的组件组成：前端、后端和 *数据库*。图 8.2 展示了这种方法。
- en: '![image](../Images/ch08__image002.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch08__image002.png)'
- en: Figure 8.2 Design for our app showing a frontend, backend, and database
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.2 显示前端、后端和数据库的应用设计
- en: The frontend, as we've seen in prior apps, consists of the widgets that the
    user interacts with. Each major action, such as creating an account, or updating
    a haiku, calls a corresponding function in the backend.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前端，正如我们在先前的应用程序中看到的，由用户与之交互的小部件组成。每个主要操作，如创建账户或更新俳句，都会在后台调用相应的函数。
- en: 'We''ll divide the functions available in the backend into two groups: one that
    includes actions related to users, like creating an account or authenticating
    a user, and another that includes haiku-related actions—creating, reading, updating,
    or deleting haikus.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把后端可用的功能分为两组：一组包括与用户相关的操作，如创建账户或验证用户，另一组包括与俳句相关的操作——创建、读取、更新或删除俳句。
- en: The interesting section here—one that's new to us—is the database, which is
    used to permanently store information related to users and haikus in *tables*.
    As we'll soon see, the database also makes it easy to retrieve the information
    we've stored.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的部分——对我们来说是新的——是数据库，它用于在**表格**中永久存储与用户和俳句相关的信息。正如我们很快就会看到的，数据库也使得检索我们存储的信息变得容易。
- en: 'While our app is intentionally simple, it captures the core elements of most
    web applications: a frontend for user interaction, a backend for handling requests,
    and a database for storing and retrieving data. These three pillars work together
    seamlessly, forming the foundation of countless applications, whether simple or
    complex.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的应用程序故意很简单，但它捕捉了大多数Web应用程序的核心要素：用于用户交互的前端、用于处理请求的后端以及用于存储和检索数据的数据库。这三个支柱无缝协作，形成了无数应用程序的基础，无论是简单还是复杂。
- en: 8.2 Setting up persistent storage
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 设置持久化存储
- en: One of the most important deficiencies in the apps we've created thus far is
    the lack of persistent storage. Essentially, in all of our apps so far, if the
    user closes their browser window, they lose their data and progress. This won't
    do at all for Haiku Haven; we need users to be able to save and access their haikus
    after they log out and log back in again at some point in the future—we need to
    store data *outside* of the app itself.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止创建的应用程序中存在的一个最重要的缺陷是缺乏持久化存储。本质上，在我们迄今为止的所有应用程序中，如果用户关闭浏览器窗口，他们就会丢失他们的数据和进度。这对俳句天堂来说完全不行；我们需要用户能够在将来某个时候注销并再次登录后保存和访问他们的俳句——我们需要将数据存储在**应用程序本身之外**。
- en: 'There are several different approaches to solving the problem of data storage,
    but we''ll use a fairly common technique: a relational database.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 解决数据存储问题有几种不同的方法，但我们将使用一种相当常见的技术：关系型数据库。
- en: 8.2.1 Relational database concepts
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 关系型数据库概念
- en: A *relational database* is a type of data storage system that organizes data
    into structured *tables*, where each table consists of *rows* (also called *records*)
    and *columns* (also called *fields*). A row represents some kind of entry or entity,
    and a column is an attribute of the entity. A *schema* defines the structure of
    these tables, including the *data types* of each column and the *relationships*
    between different tables.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**关系型数据库**是一种数据存储系统，它将数据组织成结构化的**表格**，其中每个表格由**行**（也称为**记录**）和**列**（也称为**字段**）组成。一行代表某种类型的条目或实体，一列是实体的属性。**模式**定义了这些表格的结构，包括每列的**数据类型**以及不同表格之间的**关系**。'
- en: Relational databases rely on a language called *Structured Query Language* (SQL)
    to create, manage and *query* tables.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库依赖于一种称为**结构化查询语言**（SQL）的语言来创建、管理和**查询**表。
- en: If some of this rings a bell, it's likely because we've been dealing with this
    kind of thing for a while now. In Chapters 6 and 7, we worked with Pandas dataframes
    that also handle tabular data—except that dataframes are stored in memory while
    a program is running, while a database is used for *persistent* storage, i.e.
    storage that exists even when a program finishes running.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些内容让你感到熟悉，那很可能是因为我们已经在处理这类事情一段时间了。在第六章和第七章中，我们与Pandas数据框一起工作，这些数据框也处理表格数据——除了数据框在程序运行时存储在内存中，而数据库用于**持久**存储，即即使在程序运行完成后仍然存在的存储。
- en: We also encountered SQL briefly in Chapter 7, where we used it to fetch the
    rows of the sales data that we stored in Google BigQuery. Indeed BigQuery is often
    considered to be a relational database itself, though of a different kind than
    the one we'll use in this chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第七章中也简要介绍了SQL，当时我们使用它来检索我们存储在Google BigQuery中的销售数据的行。确实，BigQuery通常被认为是一种关系型数据库，尽管它与我们本章将使用的关系型数据库不同。
- en: 8.2.2 Haiku Haven's data model
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 俳句天堂的数据模型
- en: To understand all of this better, let's try and figure out how we can *model*
    Haiku Haven's data in a relational database.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一切，让我们尝试弄清楚我们如何在一个关系型数据库中**建模**Haiku Haven的数据。
- en: 'Broadly speaking, modeling data for an app consists of the following steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 广义而言，为应用建模数据包括以下步骤：
- en: Identifying the *entities* involved in the app
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定应用中涉及的**实体**
- en: Defining the *relationship* between those entities
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义这些实体之间的**关系**
- en: Listing the *attributes* of each entity
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出每个实体的**属性**
- en: Converting the entities, attributes and relationships into a relational database
    schema
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将实体、属性和关系转换为关系数据库模式
- en: Identifying the entities
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 确定实体
- en: 'Generally speaking, a good way to identify the entities involved in an app
    is to list all the *nouns* that represent core concepts in the app. For instance,
    if you take Twitter, the following might all be considered as entities: users,
    tweets, retweets, direct messages, mentions, followers, hashtags, etc.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，识别应用中涉及的实体的一种好方法是列出所有代表应用核心概念的**名词**。例如，如果你考虑Twitter，以下所有这些都可能被认为是实体：用户、推文、转发、直接消息、提及、关注者、标签等。
- en: 'Haiku Haven is way simpler, of course. We can fairly easily identify the two
    key entities our app will need to handle: **haikus** and **users**.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Haiku Haven当然要简单得多。我们可以相当容易地确定我们的应用需要处理的两个关键实体：**俳句**和**用户**。
- en: Defining the relationship between the entities
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义实体之间的关系
- en: The relationship between any two entities should be defined in terms of the
    *nature* and *cardinality* of the possible interaction between them. In English,
    that means you should lay out *how* one entity is related to the other, and *how
    many* of each entity can be on each side of this relationship.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 任何两个实体之间的关系应该根据它们之间可能交互的**性质**和**基数**来定义。用英语来说，这意味着你应该说明一个实体是如何与另一个实体相关的，以及每种实体在这一关系中每一边可以有多少个。
- en: For instance, haikus and users are related because a user **can write** a haiku
    (the "nature" we spoke of above). Also, one user can write many haikus, while
    a particular haiku can only be written by one user. So the relationship between
    a user and a haiku is **one-to-many** or 1:n (the "cardinality").
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，俳句和用户是相关的，因为一个用户**可以写**俳句（我们上面提到的“性质”）。同时，一个用户可以写很多俳句，而一个特定的俳句只能由一个用户写。因此，用户和俳句之间的关系是**一对一**或1:n（“基数”）。
- en: Listing the attributes of each entity
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列出每个实体的属性
- en: 'The attributes of an entity are the fields that describe it. In our case:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 实体的属性是描述它的字段。在我们的例子中：
- en: A user has a **username** and a **password**. In real life, we'd probably also
    want to capture the name of the user or the time a user's account is created,
    but let's keep things simple.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用户有一个**用户名**和**密码**。在现实生活中，我们可能还想捕捉用户的姓名或用户账户创建的时间，但让我们保持简单。
- en: A haiku has its **text**, and an **author** (who happens to be a user). We should
    also give each haiku a **numeric ID** for easy reference. The **creation time**
    for a haiku may be important to display in the app, so let's consider that too.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 俳句有其**文本**和**作者**（碰巧是用户）。我们还应该给每个俳句一个**数字ID**以便于引用。俳句的**创建时间**在应用中显示可能很重要，所以我们也考虑这一点。
- en: All of this can be represented in an entity-relationship diagram (or ER diagram)
    as shown in figure 8.3.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以用一个实体-关系图（或ER图）表示，如图8.3所示。
- en: '![image](../Images/ch08__image003.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch08__image003.png)'
- en: Figure 8.3 Entity-Relationship (ER) diagram showing the User and Haiku entities
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.3 实体-关系（ER）图，展示了用户和俳句实体
- en: Of course, ER diagrams for apps in the real world tend to be much, *much* more
    complex than this, but I hope this serves to illustrate the concept.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现实世界中的应用程序的ER图通常比这复杂得多，但我希望这有助于说明这个概念。
- en: Converting everything into a database schema
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将所有内容转换为数据库模式
- en: The exercise of coming up with an ER diagram is helpful in visualizing the data
    model, but the end outcome we actually want is a schema that we can use in our
    relational database.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制ER图来构思数据模型是有帮助的，但我们真正想要的最终结果是一个可以在我们的关系型数据库中使用的模式。
- en: 'There''s no hard-and-fast rule to convert entities, attributes, and relationships
    into tables in a database, but *generally* speaking: entities become tables, attributes
    become columns, one-to-many relationships become *foreign keys* (more on this
    in a moment), and many-to-many relationships become their own tables.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将实体、属性和关系转换为数据库中的表没有固定的规则，但*一般来说*：实体成为表，属性成为列，一对一关系成为*外键*（稍后将有更多介绍），多对多关系成为它们自己的表。
- en: '![image](../Images/ch08__image004.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch08__image004.png)'
- en: Figure 8.4 Database schema with a foreign key relationship between the users
    and haikus tables
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.4 用户和俳句表之间的外键关系数据库模式
- en: In our case, as figure 8.4 shows, we'll have two tables, `users` and `haikus`,
    with the attributes we discussed earlier as columns. Each row in users represents
    a single user, and each row in `haikus` is a single haiku. Additionally, each
    table has a *primary key*, which is a field that can be used to uniquely identify
    any row in the table. For `users`, the primary key is the `username` field (which
    makes sense since every user has a username and no two users can have the same
    username). For `haikus`, it's `haiku_id`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，如图8.4所示，我们将有两个表，`users`和`haikus`，它们具有我们之前讨论的属性作为列。`users`表中的每一行代表一个单个用户，而`haikus`表中的每一行代表一个单个俳句。此外，每个表都有一个*主键*，这是一个可以用来唯一标识表中任何行的字段。对于`users`，主键是`username`字段（这很有道理，因为每个用户都有一个用户名，且没有两个用户可以有相同的用户名）。对于`haikus`，它是`haiku_id`。
- en: The relationship between `users` and `haikus` is reflected in the `author` column
    in the `haikus` table, which contains a username that must appear in the `users`
    table. Such a column (`author`) is called a *foreign key* as it points to the
    primary key (`username`) of another ("foreign") table.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 用户和俳句之间的关系反映在俳句表中的`author`列中，该列包含必须出现在用户表中的用户名。这样的列（`author`）被称为*外键*，因为它指向另一个（“外部”）表的主键（`username`）。
- en: '8.2.3 PostgreSQL: A real relational database'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 PostgreSQL：一个真正的关系数据库
- en: Enough theorizing! Let's now get our hands dirty with a real relational database.
    The one we'll use in this chapter is PostgreSQL (pronounced "post-gress-cue-ell"),
    one of the oldest, most robust, and most popular databases in the industry.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的理论了！现在让我们动手操作一个真实的数据库。在本章中，我们将使用 PostgreSQL（发音为“post-gress-cue-ell”），这是行业中最古老、最稳健、最受欢迎的数据库之一。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Google BigQuery, which we encountered in Chapter 7, can also be considered a
    relational database (though it's better described as a cloud-based data warehouse).
    While BigQuery is optimized for analytical use cases (like querying a large amount
    of data to generate reports or uncover trends), PostgreSQL is better suited for
    transactional use cases, such as handling frequent small updates to individual
    records, and maintaining data consistency across concurrent operations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章中我们遇到的 Google BigQuery 也可以被认为是一个关系数据库（尽管它更像是基于云的数据仓库）。虽然 BigQuery 优化用于分析用例（如查询大量数据以生成报告或发现趋势），但
    PostgreSQL 更适合事务用例，例如处理对单个记录的频繁小更新，并在并发操作中维护数据一致性。
- en: Installing PostgreSQL
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装 PostgreSQL
- en: Towards the end of this chapter, when we deploy Haiku Haven to production, we'll
    use a free cloud service to set up PostgreSQL. However, for local development,
    we first need a local installation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的末尾，当我们部署俳句天堂到生产环境时，我们将使用免费云服务来设置 PostgreSQL。然而，对于本地开发，我们首先需要一个本地安装。
- en: To install PostgreSQL, download the installer for your operating system from
    `https://www.postgresql.org/download/` and run it, following the on-screen instructions.
    For most options, you can accept the defaults. During the installation, you'll
    be prompted to set a password for the database superuser. Make sure to note this
    password—you'll need it in the next section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 PostgreSQL，从`https://www.postgresql.org/download/`下载适用于您操作系统的安装程序，并按照屏幕上的说明运行。对于大多数选项，您可以接受默认设置。在安装过程中，您将被提示为数据库超级用户设置密码。请确保记住这个密码——您将在下一节需要它。
- en: 'Once installation is complete, you should have access to the PostgreSQL shell,
    called `psql`, which is located in the `bin/` directory of your installation folder.
    If you kept the default options, this would typically be:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你应该可以访问 PostgreSQL 命令行工具，称为 `psql`，它位于安装文件夹的`bin/`目录中。如果你保留了默认选项，这通常会是：
- en: '`/Library/PostgreSQL/17/bin/psql` on macOS'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS上的`/Library/PostgreSQL/17/bin/psql`
- en: '`C:\Program Files\PostgreSQL\17\bin\psql` on Windows'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows上的`C:\Program Files\PostgreSQL\17\bin\psql`
- en: To simplify access, you should configure your system so you can run the `psql`
    command directly from your terminal. This requires adding the `bin/` directory
    to your system's environment variables. You may already have done something similar
    for the `streamlit` command, which you can find detailed steps for in Appendix
    A (section A.4).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化访问，您应该配置系统，以便您可以直接从终端运行 `psql` 命令。这需要将 `bin/` 目录添加到系统环境变量中。您可能已经为 `streamlit`
    命令做了类似的事情，详细步骤可以在附录 A（第 A.4 节）中找到。
- en: 'If adding the path to your environment variables isn''t feasible for any reason,
    you can still use `psql` by typing its full path instead of just the command.
    For example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于任何原因无法将路径添加到环境变量中，您仍然可以通过输入其完整路径而不是仅命令来使用 `psql`。例如：
- en: 'macOS: `/Library/PostgreSQL/17/bin/psql`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'macOS: `/Library/PostgreSQL/17/bin/psql`'
- en: 'Windows: `"C:\Program Files\PostgreSQL\17\bin\psql"` (include quotes)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows: `"C:\Program Files\PostgreSQL\17\bin\psql"`（包括引号）'
- en: Throughout the rest of this chapter, substitute the full path whenever you see
    `psql`, if necessary.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，如果需要，当您看到 `psql` 时，请替换为完整路径。
- en: Creating a database for Haiku Haven
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为 Haiku Haven 创建数据库
- en: 'Once you''ve set up the `psql` command, log in to your local PostgreSQL instance
    by running the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您设置了 `psql` 命令，通过运行以下命令登录到您的本地 PostgreSQL 实例：
- en: '[PRE0]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When prompted for a password, enter the one you configured during installation.
    This command logs you into PostgreSQL as the default user (`-U`) `postgres`—which
    is an administrative user that''s allowed to do whatever they want. The `-d` specifies
    that you want to connect to the default database, which is–~-rather confusingly
    if you ask me—also called `postgres`. You should see now see the `psql` prompt
    that looks like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当提示输入密码时，请输入您在安装过程中配置的密码。此命令以默认用户（`-U`）`postgres` 登录 PostgreSQL——这是一个可以随意做任何事的行政用户。`-d`
    指定您想要连接到默认数据库，而这个默认数据库——如果按照我的理解来说——也被称为 `postgres`。现在您应该能看到类似以下的 `psql` 提示符：
- en: '[PRE1]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When your app talks to PostgreSQL, you don''t want it to be running with broad
    administrative privileges—that would be a security nightmare. Instead, let''s
    create a more narrowly-scoped user. Enter this into the `psql` prompt, replacing
    the quoted string with a password of your choice:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的应用程序与 PostgreSQL 通信时，您不希望它以广泛的行政权限运行——那将是一场安全噩梦。相反，让我们创建一个范围更窄的用户。在 `psql`
    提示符中输入以下内容，并用您选择的密码替换引号内的字符串：
- en: '[PRE2]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Obviously, you can use whatever username you like, but I'm going to assume we're
    going with `haiku_lord`. If that works (don't forget the ending semicolon!), you
    should get an output line that just says `CREATE ROLE`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，您可以使用您喜欢的任何用户名，但我会假设我们使用 `haiku_lord`。如果这成功了（别忘了结尾的分号！），您应该会得到一条只说 `CREATE
    ROLE` 的输出行。
- en: 'Before you can create tables in PostgreSQL, you need to first make a **database**
    (which you can think of here as a container for tables). The `haiku_lord` user
    you just created can''t do that yet, so enter this command to let it:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以在 PostgreSQL 中创建表之前，您首先需要创建一个**数据库**（在这里您可以将其视为表的容器）。您刚刚创建的 `haiku_lord`
    用户还不能做这件事，所以输入以下命令来允许它：
- en: '[PRE3]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have an appropriately-privileged Haiku Haven-specific user, we''re
    done with the default `postgres` user, so exit out of the `psql` shell by typing
    `exit`, and then re-run it like so:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个具有适当权限的 Haiku Haven 特定用户，我们就完成了默认的 `postgres` 用户，所以通过输入 `exit` 退出 `psql`
    壳，然后按如下方式重新运行它：
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Assuming you entered the password you selected for `haiku_db` when prompted,
    you're again connected to the `postgres` database, but now you're acting under
    the capacity of `haiku_lord` (if you like, you can verify this by typing `SELECT
    current_user;`).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您在提示时输入了为 `haiku_db` 选定的密码，您再次连接到了 `postgres` 数据库，但现在您是以 `haiku_lord` 的身份操作的（如果您愿意，可以通过输入
    `SELECT current_user;` 来验证这一点）。
- en: 'To create a database called `haikudb` to hold the tables for Haiku Haven, enter:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个名为 `haikudb` 的数据库来存储 Haiku Haven 的表，请输入：
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can list all the databases available in your local PostgreSQL instance by
    typing `\l`. You should now be able to see `haikudb` in there, along with `postgres`
    and a couple of others.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过输入 `\l` 来列出您本地 PostgreSQL 实例中可用的所有数据库。现在您应该能够看到其中包含 `haikudb`、`postgres`
    以及几个其他数据库。
- en: 'To start using our database, we need to "connect" to it. To do this, type:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用我们的数据库，我们需要“连接”到它。为此，请输入：
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A confirmation message—`You are now connected to database "haikudb" as user
    "haiku_lord"`—should let you know that this worked.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个确认消息——“您现在已连接到数据库 "haikudb" 作为用户 "haiku_lord"”——应该让您知道这成功了。
- en: 'Keep this terminal window with the `psql` shell open. We''re going to keep
    coming back to it throughout this chapter. If you do end up closing it, you can
    get back to this state by typing:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 保持这个终端窗口中的`psql` shell打开。我们将在本章的整个过程中不断回到它。如果您最终关闭了它，您可以通过输入以下命令恢复到这个状态：
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 8.2.4 A crash course in SQL
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.4 SQL入门课程
- en: The SQL in PostgreSQL stands for Structured Query Language. Variously pronounced
    as "sequel" and "ess-cue-ell", SQL is the language of databases, used to create
    and update tables, and most importantly, to *query* them to get exactly the data
    we need. It's also one of the most popular and useful languages to know if you're
    a developer or work in the field of data in any capacity.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL中的SQL代表结构化查询语言。它被不同地发音为"sequel"和"ess-cue-ell"，SQL是数据库的语言，用于创建和更新表，最重要的是，用于*查询*以获取我们确切需要的数据。如果您是开发者或在任何形式的数据领域工作，SQL也是您应该知道的最受欢迎和最有用的语言之一。
- en: If you don't know SQL, today's your lucky day because we're going to breeze
    through the basics in this section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不知道SQL，今天真是您的幸运日，因为我们将在这个部分快速浏览基础知识。
- en: Creating tables
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建表
- en: 'Previously in this chapter, we came up with Haiku Haven''s database schema
    that contains two tables: `users` and `haikus`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们提出了Haiku Haven的数据库模式，其中包含两个表：`users`和`haikus`。
- en: 'We''re now going to actually create these tables in PostgreSQL. Go back to
    the `psql` shell where you''re connected to the `haikudb` database (or re-run
    `psql` as indicated earlier), and enter the following SQL command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在PostgreSQL中实际创建这些表。回到您连接到`haikudb`数据库的`psql` shell（或如之前所示重新运行`psql`），并输入以下SQL命令：
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `CREATE` `TABLE` command creates a table with a specific schema. In the
    above, the name of the table is `users`, and it has two columns: `username` and
    `password_hash`—which, if you recall, are the two fields we settled on earlier
    as being important attributes of a user.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`CREATE TABLE`命令创建了一个具有特定模式的表。在上面的例子中，表名为`users`，它有两个列：`username`和`password_hash`——如果您还记得，这是我们之前确定的重要用户属性字段。'
- en: Why does it say `password_hash` instead of just `password`? Bear with me, please—I'll
    explain this a little later in the chapter. For now, let's just think of it as
    the user's password.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它说`password_hash`而不是仅仅`password`？请稍等，我将在本章稍后解释这一点。现在，我们只需将其视为用户的密码。
- en: 'Turn your attention to the lines where we''ve defined the columns:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的注意力转向我们定义列的行：
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These sequences, separated by commas, are *column specifications* that let you
    configure each column—including specifying the data type.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些序列，由逗号分隔，是*列指定*，允许您配置每一列——包括指定数据类型。
- en: '`VARCHAR` is one such data type in PostgreSQL; it''s a string type that can
    have a varying number of characters. `VARCHAR(100)` means that the column can
    have any number of characters up to 100\. If you try to store more than 100 characters,
    PostgreSQL will throw an error.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`VARCHAR`是PostgreSQL中的一种数据类型；它是一种可以具有可变字符数的字符串类型。`VARCHAR(100)`表示该列可以包含最多100个字符。如果您尝试存储超过100个字符，PostgreSQL将抛出一个错误。'
- en: You'll also notice `PRIMARY` `KEY` against the `username` column. This denotes
    that the `username` column will be used to uniquely identify a row in the users
    table. Among other things, this means that every row in `users` must have a `username`,
    and that only one user can have a particular `username`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到`username`列旁边的`PRIMARY KEY`。这表示`username`列将被用来唯一标识用户表中的一行。这还意味着`users`表中的每一行都必须有一个`username`，并且只有一个用户可以有一个特定的`username`。
- en: 'To check that this worked, you can use the `psql` command `\dt`, which lists
    all the tables in the current database. Doing so now should give you:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查是否成功，您可以使用`psql`命令`\dt`，它列出当前数据库中的所有表。现在这样做应该会给出：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, let''s create our second table, `haikus`, with another `CREATE` `TABLE`
    command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用另一个`CREATE TABLE`命令创建我们的第二个表`haikus`：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are a few new things here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些新内容：
- en: '`haiku_id`, the primary key, has a data type of `SERIAL`. This means that PostgreSQL
    will automatically provide the value for this column as an auto-incrementing integer.
    The first row inserted will have `1` as its `haiku_id`, the second will have `2`,
    and so on.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`haiku_id`，主键，数据类型为`SERIAL`。这意味着PostgreSQL将自动为该列提供一个自增整数值。第一行插入将具有`1`作为其`haiku_id`，第二行将具有`2`，依此类推。'
- en: '`created_at` has the data type `TIMESTAMPTZ`, which is a timestamp with time
    zone information. The `DEFAULT` keyword specifies the value to put in this column
    if one is not explicitly provided while inserting a row in the table. In this
    case, we want the current timestamp (`CURRENT_TIMESTAMP`) to be provided as this
    default value.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created_at` 的数据类型为 `TIMESTAMPTZ`，这是一个带有时区信息的日期时间戳。`DEFAULT` 关键字指定了在向表中插入行时如果没有明确提供值，则放入此列的值。在这种情况下，我们希望提供当前的时间戳
    (`CURRENT_TIMESTAMP`) 作为此默认值。'
- en: '`text` has a data type of `TEXT`, which is like `VARCHAR` but with no maximum
    character length. This makes sense for the actual content of the haiku.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text` 的数据类型为 `TEXT`，类似于 `VARCHAR`，但没有最大字符长度限制。这对于俳句的实际内容来说是有意义的。'
- en: The last line, `FOREIGN KEY (author) REFERENCES users(username)`, says that
    the author column must have a value that exists in the username column of some
    row in the users table. This is called a *foreign key constraint*.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一行，`FOREIGN KEY (author) REFERENCES users(username)` 表示作者列必须有一个值，该值存在于用户表中的某些行的
    `username` 列中。这被称为 *外键约束*。
- en: Inserting rows into tables
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向表中插入行
- en: Next, let's populate these tables with rows using SQL's `INSERT INTO` statement.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用 SQL 的 `INSERT INTO` 语句向这些表中插入行。
- en: 'We''ll first create a new user by adding a row to the `users` table:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过向 `users` 表中添加一行来创建一个新用户：
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `INSERT INTO` command inserts a row into the table by specifying the column
    values. The `(username, password_hash)` after the table name `users` says that
    the column values we're about to specify correspond to the columns `username`
    and `password_hash`, in that order.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSERT INTO` 命令通过指定列值将行插入到表中。表名 `users` 后的 `(username, password_hash)` 表示我们即将指定的列值对应于
    `username` 和 `password_hash` 列，顺序如下。'
- en: The part after `VALUES` gives the actual values to enter. The effect here is
    that `users` now has one row—with a `username` of `alice` and `password_hash`
    set to `Pass_word&34`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`VALUES` 后的部分给出了要输入的实际值。这里的效果是 `users` 现在有一行——`username` 为 `alice`，`password_hash`
    设置为 `Pass_word&34`。'
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note here that though `haikus` has four columns, we're only specifying the values
    for two of them—`author` and `text`. PostgreSQL automatically provides the `haiku_id`
    as well as a default value for `created_at`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管 `haikus` 有四个列，但我们只指定了其中两个的值——`author` 和 `text`。PostgreSQL 会自动提供 `haiku_id`
    以及 `created_at` 的默认值。
- en: Also notice the `E` before the starting quote of the haiku. This marks the value
    as an *escape string*, correctly translating the `\n` escape sequence into a newline
    character.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意俳句开头引号前的 `E`。这标志着值是一个 *转义字符串*，正确地将 `\n` 转义序列转换为换行符。
- en: 'Before we query these tables, let''s add another unsettling haiku under `alice`
    for good measure:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查询这些表之前，为了以防万一，让我们在 `alice` 下再添加一首令人不安的俳句：
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Querying tables
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查询表
- en: The real strength of SQL lies in the versatile ways in which we can *query*
    tables (read data from them) once they have been populated with rows.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 的真正优势在于我们可以在表被行填充后以多种灵活的方式 *查询* 表（从它们中读取数据）。
- en: 'To retrieve data, we use the `SELECT` statement. This command allows us to
    specify the columns we want to see and filter rows based on certain criteria.
    Let''s start with a simple query to fetch all the rows and columns from the `users`
    table:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索数据，我们使用 `SELECT` 语句。此命令允许我们指定我们想要看到的列，并根据某些标准过滤行。让我们从一个简单的查询开始，以检索 `users`
    表中的所有行和列：
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The * indicates that we want to retrieve all columns from the table. As a result
    of this, we''ll see a list of all users along with their associated `user_id`
    and `password_hash`. We only currently have one user, so we get:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 星号 * 表示我们想要检索表中的所有列。因此，我们将看到所有用户及其相关的 `user_id` 和 `password_hash` 列表。我们目前只有一个用户，所以我们得到：
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you're horrified to see passwords so easily queried, don't worry! As we'll
    soon see, we're not actually going to be storing passwords like this.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到密码如此容易被查询而感到惊恐，请不要担心！正如我们很快就会看到的，我们实际上并不会以这种方式存储密码。
- en: 'We could also choose to only retrieve certain columns from the table. For example,
    if we only want the `haiku_id`, `created_at`, and `author` fields from the `haikus`
    table, we could write:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以选择只从表中检索某些列。例如，如果我们只想从 `haikus` 表中检索 `haiku_id`、`created_at` 和 `author`
    字段，我们可以这样写：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This would give us:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can also filter the rows we want to see based on a condition (or set of
    conditions) using a `WHERE` clause. For example, if we want to see the `haiku_id`
    and `text` for only haikus that are written by `alice` and contain `"fox"`, we
    could use the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `WHERE` 子句根据条件（或条件集）过滤我们想要看到的行。例如，如果我们只想看到由 `alice` 编写的且包含 `"fox"` 的俳句的
    `haiku_id` 和 `text`，我们可以使用以下内容：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'to get:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以获得：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''ve filtered the `haikus` table using two conditions separated by the keyword
    `AND` here: `author = ''alice''`, and `text LIKE ''%fox%''`.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用两个由关键字 `AND` 分隔的条件过滤了 `haikus` 表：`author = 'alice'` 和 `text LIKE '%fox%'`。
- en: The `LIKE` keyword is used to perform text-matching. The `%` symbol means "zero
    or more characters," making `%fox%` a pattern that matches any text containing
    the word 'fox' anywhere within it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`LIKE` 关键字用于执行文本匹配。`%` 符号表示“零个或多个字符”，使 `%fox%` 成为一个匹配包含单词 ''fox'' 的任何文本的模式。'
- en: The `SELECT` statement can do a *lot* more than this, such as calculating summary
    statistics, aggregating rows, fetching data from multiple tables by joining them
    and more, but these are out of the scope of this chapter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT` 语句可以做得比这更多，例如计算汇总统计信息、聚合行、通过连接从多个表中获取数据等等，但这些内容超出了本章的范围。'
- en: Updating tables
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新表
- en: 'You can update rows in a table after you''ve inserted them, using the `UPDATE`
    statement. For example, let''s say you want to add the string "[By Alice] " to
    the start of the haiku with `haiku_id` 1:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入行后，您可以使用 `UPDATE` 语句更新表中的行。例如，假设您想将字符串 "[By Alice] " 添加到 `haiku_id` 为 1 的俳句的开头：
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here we''re setting the column `text` in the `haikus` table for rows where
    the `haiku_id` is `1`. The The `||` operator is used in SQL to concatenate strings,
    so `SET text = ''[By Alice] '' || text` adds "[By Alice] " to the beginning. If
    we now `SELECT` the text for that haiku with:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在设置 `haikus` 表中 `haiku_id` 为 `1` 的行的 `text` 列。SQL 中使用 `||` 运算符来连接字符串，因此
    `SET text = '[By Alice] ' || text` 将 "[By Alice] " 添加到开头。如果我们现在通过以下方式 `SELECT`
    该俳句的文本：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'we''ll get:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Though we've only updated one row here, `UPDATE` will update all the rows that
    match the `WHERE` clause. If we omit the `WHERE` clause, the `UPDATE` will apply
    to every single row in the table.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里只更新了一行，但 `UPDATE` 将更新所有与 `WHERE` 子句匹配的行。如果我们省略了 `WHERE` 子句，则 `UPDATE`
    将应用于表中的每一行。
- en: Deleting rows (and tables)
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 删除行（和表）
- en: To delete rows from a table, we use the `DELETE FROM` command. Just as in the
    case of `UPDATE`, it uses a `WHERE` condition to determine the rows to delete.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要从表中删除行，我们使用 `DELETE FROM` 命令。与 `UPDATE` 的情况一样，它使用 `WHERE` 条件来确定要删除的行。
- en: 'So we could delete the haiku with ID 2 by running:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过以下命令删除 ID 为 2 的俳句：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Be careful with this command! If you omit the `WHERE` clause, `DELETE FROM`
    will delete *every single* row!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 小心使用此命令！如果您省略了 `WHERE` 子句，`DELETE FROM` 将删除 *每个* 单独的行！
- en: Finally, we can delete a table itself (as opposed to just the rows in the table),
    by using the `DROP TABLE` command.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过使用 `DROP TABLE` 命令本身删除一个表（而不是仅删除表中的行）。
- en: 'For instance, if we wanted to remove the `haikus` table (which we don''t, for
    now), we could have entered:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想删除 `haikus` 表（目前我们不需要这样做），我们可以输入以下内容：
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Of course, there's much more to SQL than what we've learned—indeed, entire careers
    can be forged by knowing it well enough—but this is all we'll need for this chapter.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，SQL 的内容远不止我们所学的这些——实际上，整个职业生涯都可以通过对其有足够的了解来塑造——但这正是我们本章所需的所有内容。
- en: 8.2.5 Connecting PostgreSQL to our app
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.5 将 PostgreSQL 连接到我们的应用程序
- en: We've now set up the database for Haiku Haven. We've also learned to insert
    rows and query our database *manually*. What's left is to enable our app to query
    and make changes to the database *programmatically*, through Python.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经为“俳句天堂”数据库设置了数据库。我们还学会了手动插入行和查询数据库 *手动*。接下来要做的就是使我们的应用程序能够通过 Python *程序化*地查询和修改数据库。
- en: For this, we'll employ a third-party Python module named `psycopg2`, which provides
    us with a way to talk to PostgreSQL in our app.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将使用一个名为 `psycopg2` 的第三方 Python 模块，它为我们提供了一种在应用程序中与 PostgreSQL 通信的方式。
- en: Go ahead and install it now by running `pip install psycopg2` in a new terminal
    window.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就安装它，通过在新终端窗口中运行 `pip install psycopg2` 来完成。
- en: How database connections work
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据库连接是如何工作的
- en: Before using `psycopg2`, let’s understand how PostgreSQL queries work in Python.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `psycopg2` 之前，让我们了解 PostgreSQL 查询在 Python 中的工作方式。
- en: We learned in prior chapters that a Streamlit app is served by a Streamlit server
    process that listens to a particular port (usually 8501 or something near that)
    on a machine. Similarly, a PostgreSQL database runs on a PostgreSQL server that
    listens to a different port—5432 by default, unless you set a different port number
    when you installed it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们了解到Streamlit应用程序由一个Streamlit服务器进程提供服务，该进程监听机器上的特定端口（通常是8501或附近某个端口）。同样，PostgreSQL数据库在PostgreSQL服务器上运行，该服务器监听不同的端口——默认为5432，除非你在安装时设置了不同的端口号。
- en: To execute SQL commands, the app must establish a *connection* to the PostgreSQL
    server. A single connection can handle only one command at a time.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行SQL命令，应用程序必须与PostgreSQL服务器建立*连接*。单个连接一次只能处理一个命令。
- en: But what if multiple users try to create or update a haiku at once? We could
    queue up the SQL commands on a single connection, but that could cause delays.
    Using multiple *connections* is better, but setting up each one can be resource-intensive—especially
    in production—as it involves network initialization and authentication.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果多个用户同时尝试创建或更新一个俳句，怎么办？我们可以在单个连接上排队SQL命令，但这可能会导致延迟。使用多个*连接*更好，但设置每个连接可能会消耗资源——尤其是在生产环境中，因为它涉及到网络初始化和身份验证。
- en: '`psycopg2`''s answer to this is a *connection pool* that manages multiple *re-usable*
    database connections efficiently, illustrated by figure 8.5.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`psycopg2`的解决方案是一个*连接池*，它高效地管理多个*可重用*的数据库连接，如图8.5所示。'
- en: '![image](../Images/ch08__image005.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch08__image005.png)'
- en: Figure 8.5 Database connection pool with 1 minimum and 5 maximum connections
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.5具有1个最小连接和5个最大连接的数据库连接池
- en: 'A connection pool maintains a set of connections that can be quickly reused
    by different parts of the application or different users accessing the application.
    When a part of the application needs to run a database query, it can:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 连接池维护一组可以被应用程序的不同部分或访问应用程序的不同用户快速重用的连接。当应用程序的一部分需要运行数据库查询时，它可以：
- en: Request a connection from the pool
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从池中请求一个连接
- en: Use the connection to execute the query
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用连接来执行查询
- en: Return the connection to the pool for reuse
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将连接返回到池中以供重用
- en: Using psycopg2 to connect to our database
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`psycopg2`连接到我们的数据库
- en: With all that in mind, let's try setting up a live database connection and running
    a query! Open a Python shell by typing `python` (or `python3`) into your terminal.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，让我们尝试设置一个实时数据库连接并运行一个查询！在终端中输入`python`（或`python3`）以打开Python shell。
- en: 'Once you''re in, import what we need from the module:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你连接上了，从模块中导入我们需要的内容：
- en: '[PRE26]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`ThreadedConnectionPool` is the connection pool class we''ll use. To instantiate
    it, we''ll need the address where our PostgreSQL server is running, the port number
    it''s running on, the username and password of the PostgreSQL user we created,
    and the name of our database.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadedConnectionPool`是我们将要使用的连接池类。为了实例化它，我们需要知道我们的PostgreSQL服务器运行的地址、端口号、我们创建的PostgreSQL用户的用户名和密码，以及我们数据库的名称。'
- en: 'We can combine all of these into a *connection string* that takes the form:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将所有这些组合成一个*连接字符串*，其形式如下：
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In our case, we''ll type:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将输入：
- en: '[PRE28]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Obviously, you'll need to replace `<password>` with the actual password you
    created for `haiku_lord`. Since we're running PostgreSQL locally right now, the
    server address is simply `localhost`, but this will change when we switch to a
    managed PostgreSQL service during deployment later in the chapter.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你需要将`<password>`替换为你为`haiku_lord`创建的实际密码。由于我们现在在本地运行PostgreSQL，服务器地址简单地是`localhost`，但在本章后面切换到托管PostgreSQL服务时，这将会改变。
- en: 'We can now create our connection pool:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建我们的连接池：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 1 and 5 here are the minimum and maximum connections in the pool. This means
    1 connection is always kept available even before we receive any requests, and
    a maximum of 5 simultaneous connections can be maintained.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的1和5是池中的最小和最大连接数。这意味着即使在我们收到任何请求之前，也始终保留一个连接可用，并且可以维护最多5个并发连接。
- en: 'Let''s grab a connection from the pool using the `getconn` method:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`getconn`方法从池中获取一个连接：
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To execute a query, we need a *cursor*, which is a pointer that allows us to
    execute SQL commands and fetch results from the database in flexible ways. We
    create one by calling the `cursor()` method on our `connection` object:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行查询，我们需要一个*游标*，它是一个指针，允许我们以灵活的方式执行SQL命令并从数据库中检索结果。我们通过在`connection`对象上调用`cursor()`方法来创建一个：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note the `%s` here. This makes the username of the author a parameter of the
    query. By plugging in different usernames, we could get the haikus of different
    authors. For now, we want `alice`'s haikus, so we'll create a params tuple to
    pass along with the query.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里的 `%s`。这使得作者的用户名成为查询的参数。通过插入不同的用户名，我们可以获取不同作者的俳句。现在，我们想要 `alice` 的俳句，所以我们将创建一个包含查询的元组来传递。
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`(''alice'',)` is the literal notation for a single-element tuple containing
    the string `''alice''`.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`(''alice'',)` 是包含字符串 `''alice''` 的单元素元组的字面表示。'
- en: '[PRE33]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Once the execution is done, let's fetch all the results.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行完成，让我们获取所有结果。
- en: '[PRE34]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The results are in the form of a list of tuples, where each tuple represents
    a single row in the database. Since our `SELECT` clause said `haiku_id, author`,
    the first element of each result tuple is the `haiku_id`, while the second is
    the `author` field.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 结果以元组列表的形式出现，其中每个元组代表数据库中的一行。由于我们的 `SELECT` 子句说了 `haiku_id, author`，每个结果元组的第一个元素是
    `haiku_id`，而第二个是 `author` 字段。
- en: 'Since we''re done with the query, let''s return the connection to the pool
    so other parts of the app can use it:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经完成了查询，让我们将连接返回到连接池，以便应用程序的其他部分可以使用它：
- en: '[PRE35]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'That concludes our illustration of `psycopg2`. As a final step, let''s clean
    up the connection pool:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对 `psycopg2` 的说明。作为最后一步，让我们清理连接池：
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This closes all connections and no more can be requested from the pool.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这将关闭所有连接，并且无法再从连接池中请求更多。
- en: Creating a Database class
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建数据库类
- en: Now that we know how to run SQL queries in Python, we're ready to begin writing
    the code for our app.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何在 Python 中运行 SQL 查询，我们准备开始编写应用程序的代码。
- en: 'In this chapter, we''re going to organize our code in two folders: `backend`
    and `frontend`, and a main entrypoint script (the one we''ll use with `streamlit
    run`) that lies outside of either.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把我们的代码组织在两个文件夹中：`backend` 和 `frontend`，以及一个主入口脚本（我们将使用 `streamlit run`），它位于这两个文件夹之外。
- en: The database connection stuff we just covered is pretty technical and we'd rather
    not have to deal with it in the remainder of our app's code. It would be nice
    if we had a database object that we could just ask to execute the queries we need,
    without having to worry about the gory details of connection pools and cursors.
    Whenever we want to run a particular query, we should be able to write `database.execute_query(query,
    params)`, passing in the query we want to execute and the parameters we want to
    give it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才提到的数据库连接内容相当技术性，我们宁愿不在应用程序代码的其余部分处理它。如果我们可以有一个数据库对象，我们可以直接要求执行所需的查询，而不必担心连接池和游标的细节。每当我们要运行特定的查询时，我们应该能够编写
    `database.execute_query(query, params)`，传递我们想要执行的查询和想要提供的参数。
- en: To set this up, let's create a `Database` *class*.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置这个环境，让我们创建一个 `Database` *类*。
- en: Create a new Python file called `database.py` within the backend folder and
    copy the code in listing 8.1.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在后端文件夹中创建一个新的 Python 文件，命名为 `database.py`，并将列表 8.1 中的代码复制进去。
- en: Listing 8.1 backend/database.py
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.1 后端/database.py
- en: '[PRE37]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: By this point, you should be used to the simple dataclasses we've used in prior
    chapters. Dataclasses simplify the syntax used to create classes in Python, but
    for more complex use cases, we need to peel back that layer and write a traditional
    class definition.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经习惯了我们在前几章中使用过的简单数据类。数据类简化了在 Python 中创建类所使用的语法，但对于更复杂的使用场景，我们需要剥去这一层，并编写传统的类定义。
- en: A class is essentially a blueprint that can be turned into a concrete Python
    object, which can have attributes—these are the object's properties or data associated
    with the object—and methods—or functions that define the object's behavior and
    can interact with its attributes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 类本质上是一个可以被转换成具体的 Python 对象的蓝图，它可以拥有属性——这些是对象的属性或与对象关联的数据——以及方法——或定义对象行为并能与其属性交互的函数。
- en: 'Let''s study the class definition for our `Database` class, shown in listing
    8.1\. We''ll start with the `__init__` method:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们研究 `Database` 类的定义，如列表 8.1 所示。我们将从 `__init__` 方法开始：
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`__init__` (pronounced "dunder init") is a special method in Python. When an
    object is first created from a class, the `__init__` method is executed automatically.
    The two arguments our `__init__` takes are `self` and `connection_string`.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__`（发音为“dunder init”）是 Python 中的一个特殊方法。当一个对象首次从一个类创建时，`__init__` 方法会自动执行。我们的
    `__init__` 方法接受的两个参数是 `self` 和 `connection_string`。'
- en: You'll see `self` extremely often in Python class definitions. The first argument
    to a method within a class is a special one that's not explicitly passed while
    calling it (as we'll see in a bit). It always refers to the object on which the
    method is being called. By convention, this argument is named `self`—though you
    can technically call it whatever you like.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 类定义中，你会非常频繁地看到 `self`。类内部方法的第一参数是一个特殊的参数，在调用它时不会明确传递（我们稍后会看到）。它始终指向被调用方法的对象。按照惯例，这个参数被命名为
    `self`——尽管技术上你可以称它为任何你喜欢的名字。
- en: '`connection_string` is meant to hold a string of the type we formed earlier,
    containing the database configuration.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`connection_string` 的目的是存储我们之前形成的字符串类型，其中包含数据库配置。'
- en: The line `self.connection_pool = ThreadedConnectionPool(MIN_CONNECTIONS, MAX_CONNECTIONS,
    connection_string)` creates a `psycopg2` `ThreadedConnectionPool` as we demonstrated
    in the earlier section, and assigns it to `self.connection_pool`, making it an
    attribute of the object created from the class.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这行 `self.connection_pool = ThreadedConnectionPool(MIN_CONNECTIONS, MAX_CONNECTIONS,
    connection_string)` 创建了一个 `psycopg2` 的 `ThreadedConnectionPool`，就像我们在前面的部分中所演示的那样，并将其分配给
    `self.connection_pool`，使其成为从类创建的对象的属性。
- en: '`MIN_CONNECTIONS` and `MAX_CONNECTIONS` are defined at the top of the file
    where they can be easily configured or changed later.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`MIN_CONNECTIONS` 和 `MAX_CONNECTIONS` 在文件顶部定义，可以轻松配置或稍后更改。'
- en: We're effectively initializing a connection pool as soon as the database object
    is created.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上是在创建数据库对象时立即初始化连接池。
- en: We also define methods other than `__init__`, such as `connect`, which obtains
    a connection from the pool, `close`, which returns a given connection to the pool,
    and `close_all`, which closes the connection pool itself (and prints a message
    to the terminal window). The code for these should be familiar as we discussed
    it when we were trying out `psycopg2`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了除 `__init__` 之外的方法，例如 `connect`，它从连接池中获取连接，`close`，它将给定的连接返回到连接池，以及 `close_all`，它关闭连接池本身（并在终端窗口中打印一条消息）。这些代码应该很熟悉，因为我们之前在尝试
    `psycopg2` 时讨论过。
- en: 'However, we generally won''t call these methods directly. Recall that what
    we really want is a simple `execute_query` method that''ll take care of all the
    underlying database connection logic. Let''s presently turn our attention to that
    method:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们通常不会直接调用这些方法。回想一下，我们真正想要的是一个简单的 `execute_query` 方法，它会处理所有底层的数据库连接逻辑。让我们现在将注意力转向该方法：
- en: '[PRE39]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`execute_query` naturally accepts a SQL query we want to execute and any params
    (set to an empty tuple, `()`, by default) we want to give the query.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute_query` 自然接受我们想要执行的 SQL 查询以及我们想要提供给查询的任何参数（默认设置为空元组 `()`）。'
- en: The body of the method starts by obtaining a connection from the pool. We then
    see a `try`-`finally` block.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的主体首先从连接池中获取一个连接。然后我们看到一个 `try`-`finally` 块。
- en: In Python, `try`-`except`-`finally` is a construct `that's` used for error handling.
    The idea is to write your regular code in the `try` block. If an exception occurs
    while running the `try` code, Python stops execution and jumps to an `except`
    block that "catches" the exception, allowing you to log a sensible error message,
    for example, or use some other kind of handling logic.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，`try`-`except`-`finally` 是一个用于错误处理的构造 `that's`。其思路是将你的常规代码写在 `try`
    块中。如果在运行 `try` 代码时发生异常，Python 会停止执行并跳转到 `except` 块，该块会 "捕获" 异常，允许你记录一个合理的错误信息，例如，或者使用其他类型的处理逻辑。
- en: Regardless of whether there's an exception or not, the code in the `finally`
    block is always executed.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是否有异常，`finally` 块中的代码总是会执行。
- en: The code in the `try` block simply gets a cursor, executes the query and returns
    the results, just as we saw when we were exploring `psycopg2`. The only new thing
    you might notice is the line `connection.commit()`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 块中的代码只是获取一个游标，执行查询并返回结果，就像我们在探索 `psycopg2` 时所看到的那样。你可能注意到的唯一新事物是 `connection.commit()`
    这一行。'
- en: This line exists because we're not just going to be using `execute_query` to
    run `SELECT` queries. We're also going to run `INSERT INTO`, `UPDATE`, and `DELETE
    FROM` commands—all of which *modify* tables, not just *read* from them.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行存在是因为我们不仅仅会使用 `execute_query` 来运行 `SELECT` 查询。我们还会运行 `INSERT INTO`、`UPDATE`
    和 `DELETE FROM` 命令——所有这些都会 *修改* 表，而不仅仅是 *读取* 它们。
- en: In PostgreSQL, when you modify data, the changes aren't permanently saved until
    you *commit* them.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PostgreSQL 中，当你修改数据时，直到你 *提交* 它们之前，这些更改不会被永久保存。
- en: What if some kind of error occurs (for instance, the given query might have
    incorrect SQL syntax) while Python's trying to execute this code? We enter the
    `except` block marked by `except Exception`, which contains the line `connection.rollback()`.
    This undoes any temporary changes made so that the database is left in a pristine
    state.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在Python尝试执行此代码时发生某种错误（例如，给定的查询可能包含不正确的SQL语法），该怎么办？我们进入由`except Exception`标记的`except`块，其中包含`connection.rollback()`这一行。这将撤销所做的任何临时更改，以便数据库保持原始状态。
- en: We also print the error we encountered and then re-raise the exception, letting
    the regular exception flow take over—such as printing the exception message to
    the screen. What we've achieved with the `try`-`except` construct is to inject
    ourselves into the flow when an exception occurs and make sure any partial changes
    are rolled back.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还打印出我们遇到的错误，然后重新抛出异常，让常规的异常流程接管——例如，将异常消息打印到屏幕上。我们通过`try`-`except`结构实现的是，在发生异常时将自己注入流程中，并确保任何部分更改都被回滚。
- en: What about the `finally` block? Well, that calls the `close` method further
    up in the file, returning the connection to the pool. Regardless of what happens
    in the `try` block, the connection is always freed up. If we didn't have this
    code, the connection would remain allocated even after the function exits, and
    eventually the pool would run out of new connections. Putting this code in the
    `finally` block ensures the connection is returned even if an error occurs.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`finally`块呢？嗯，它调用文件中更高处的`close`方法，将连接返回到池中。无论`try`块中发生什么，连接总是会被释放。如果我们没有这段代码，连接在函数退出后仍然会被分配，最终池将耗尽新的连接。将此代码放在`finally`块中确保即使在发生错误的情况下，连接也会被返回。
- en: Using the Database class in our app
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在我们的应用中使用数据库类
- en: With a `Database` class set up, all that's left to do to enable persistent storage
    and retrieval in our app is to actually use the class in our Streamlit app.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了`Database`类之后，要使我们的应用实现持久存储和检索，剩下的就是实际上在我们的Streamlit应用中使用这个类。
- en: Creating an instance of the Database class requires providing it with a connection
    string. Connection strings are sensitive because they contain PostgreSQL credentials,
    so we don't want to be putting the string in our code.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数据库类的实例需要提供一个连接字符串。连接字符串是敏感的，因为它们包含PostgreSQL凭据，所以我们不希望将字符串放入我们的代码中。
- en: You probably know where this is heading—we need to use `st.secrets` as we've
    done in the past! Without further ado, go ahead and create a `.streamlit` folder
    in your app's root folder (the parent folder where you created the `backend` directory),
    and create a `secrets.toml` within it, with contents similar to what's shown in
    listing 8.2.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道接下来会发生什么——我们需要像过去一样使用`st.secrets`！无需多言，立即在你的应用根目录（即创建`backend`目录的父文件夹）中创建一个`.streamlit`文件夹，并在其中创建一个`secrets.toml`文件，其内容类似于列表8.2中所示。
- en: Listing 8.2 .streamlit/secrets.toml
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.2 .streamlit/secrets.toml
- en: '[PRE40]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Don't forget to replace `password` with your actual password. Also, as we learned
    before, you shouldn't check this file into Git.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将`password`替换为你的实际密码。此外，正如我们之前所学的，你不应该将此文件提交到Git。
- en: Next, create our app's entrypoint file—say, `main.py`—in the app's root directory,
    with the code in listing 8.3.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在应用的根目录中创建我们的应用入口文件——比如说，`main.py`——，其中的代码如列表8.3所示。
- en: Listing 8.3 main.py
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.3 main.py
- en: '[PRE41]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is where it all comes together! Firstly, we import the `Database` class
    we just created using:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是一切汇聚在一起的地方！首先，我们使用以下方式导入我们刚刚创建的`Database`类：
- en: '[PRE42]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This line means "import the Database class from `backend/database.py`". Notice
    how, in module import paths, the path separator becomes a dot.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码的意思是“从`backend/database.py`导入数据库类”。注意，在模块导入路径中，路径分隔符变成了点。
- en: For this line to work, Python needs to recognize the parent folder of `backend`
    as a starting point from which it can look for modules. We can do this by adding
    the path to the parent folder of `backend` to `sys.path`, which is the list of
    paths that determines this in Python.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这一行代码能够正常工作，Python需要识别`backend`的父文件夹作为起点，从该起点它可以查找模块。我们可以通过将`backend`父文件夹的路径添加到`sys.path`（Python中确定此内容的路径列表）来实现这一点。
- en: Fortunately, when you run the `streamlit run <script.py>` command, the parent
    folder of `<script.py>` is automatically added to `sys.path`. In this case, since
    the parent folder of `main.py` is also the parent folder of the `backend` directory,
    we don't need to do anything extra.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，当你运行`streamlit run <script.py>`命令时，`<script.py>`的父文件夹会自动添加到`sys.path`中。在这种情况下，由于`main.py`的父文件夹也是`backend`目录的父文件夹，我们不需要做任何额外的事情。
- en: 'Next, after displaying a title, we extract the connection string from `st.secrets`
    as we''ve done in prior chapters:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在显示标题之后，我们像之前章节中做的那样，从`st.secrets`中提取连接字符串：
- en: '[PRE43]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We use this to create an instance of the `Database` class:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个来创建`Database`类的实例：
- en: '[PRE44]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You'll probably recognize this syntax from when we've used dataclasses before,
    but this is the first time in this book that we've instantiated a traditional
    class we wrote, so a deeper explanation is warranted.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在我们之前使用dataclasses时已经认识到了这种语法，但这是本书中我们第一次实例化我们编写的传统类，因此需要更深入的说明。
- en: What's going on here is that by passing `connection_string` to the class `Database`
    as though it were a function, we're actually passing it to `Database`'s `__init__`
    method, which has the signature line `def __init__(self, connection_string)`.
    As I mentioned earlier, `self` is automatically set to the object that's being
    created, so we don't need to pass it explicitly.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情是，通过将`connection_string`传递给类`Database`，就像传递给一个函数一样，我们实际上是在将其传递给`Database`的`__init__`方法，该方法具有签名行`def
    __init__(self, connection_string)`。正如我之前提到的，`self`会自动设置为正在创建的对象，所以我们不需要显式地传递它。
- en: Instead, we pass only `connection_string`, thus letting `__init__` set up the
    connection pool for us, and getting the resulting `Database` instance in the `database`
    variable (note that `__init__` will return the instance even though we didn't
    write an explicit `return` statement).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们只传递`connection_string`，这样`__init__`就会为我们设置连接池，并将得到的`Database`实例存储在`database`变量中（注意，即使我们没有写一个显式的`return`语句，`__init__`也会返回实例）。
- en: 'Once we have the instance `database`, we use it to execute a simple `SELECT`
    query:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`database`实例，我们就用它来执行一个简单的`SELECT`查询：
- en: '[PRE45]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Again, even though `execute_query` takes `self` as its first argument, we don't
    need to pass it explicitly. Instead `database` itself is passed to `self`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，尽管`execute_query`将`self`作为其第一个参数，我们不需要显式地传递它。相反，`database`本身被传递给`self`。
- en: This query has no parameters, so we let the `params` argument have the default
    value (an empty tuple) by not specifying it.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询没有参数，所以我们通过不指定它，让`params`参数保持默认值（一个空元组）。
- en: 'Finally, we use `st.write` to display the results of the query:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`st.write`来显示查询的结果：
- en: '[PRE46]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Take a look at the page now by typing `streamlit run main.py` (make sure you're
    in `main.py`'s containing folder first so that Streamlit can find the `.streamlit`
    folder). You should see something similar to figure 8.6.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入`streamlit run main.py`来查看页面（确保你首先在`main.py`的包含文件夹中，这样Streamlit才能找到`.streamlit`文件夹）。你应该会看到类似于图8.6的内容。
- en: '![image](../Images/ch08__image006.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch08__image006.png)'
- en: Figure 8.6 The contents of the haiku table as read by executing a SELECT query
    using the Database class and displayed using st.write (see chapter_8/in_progress_01
    in the GitHub repo for the full code)
  id: totrans-306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.6 使用Database类执行SELECT查询并使用st.write显示的俳句表内容（完整代码请见GitHub仓库中的chapter_8/in_progress_01）
- en: One interesting thing here is how `st.write` formats the list of tuples within
    `query_results` in an easy-to-read form.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的一点是`st.write`如何以易于阅读的格式格式化`query_results`中的元组列表。
- en: In any case, our app is now connected to a database! Next up, let's use this
    to allow users to create accounts!
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们的应用现在已经连接到数据库了！接下来，让我们使用这个来允许用户创建账户！
- en: 8.3 Creating user accounts
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 创建用户账户
- en: Since our users can create their own haikus, there needs to be a way for them
    to create Haiku Haven accounts to hold their haikus. In this section, we'll wire
    up our app to enable this, taking care to store passwords securely.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的用户可以创建他们自己的俳句，因此他们需要有一种方式来创建Haiku Haven账户来保存他们的俳句。在本节中，我们将连接我们的应用以启用此功能，并注意安全地存储密码。
- en: Before we get to that though, let's take a minute to talk about code organization.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们到达那里之前，让我们花一分钟来谈谈代码组织。
- en: 8.3.1 Splitting our app into services
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 将我们的应用拆分为服务
- en: In Chapter 3, we discussed the principle of *separation of concerns*—the idea
    that each component of our app should focus on a specific thing and be independent
    of the other components, interacting with them only in ways that are specified
    by a contract or API.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我们讨论了*关注点分离*的原则——即我们的应用程序的每个组件都应该专注于特定的事情，并且与其他组件独立，仅以合同或API指定的方式与之交互。
- en: We'll do something similar here, separating the frontend and backend as we did
    in that chapter. Since we're using classes and *object-oriented programming* this
    time, we could define a backend class*—*let's call this `Hub`—that can be the
    single point of contact for frontend code to call backend code. Any function that
    the frontend can call should be a method in the `Hub` class. This is analogous
    to `backend.py` in Chapter 3 where every backend function called from the frontend
    code was defined in `backend.py`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将做类似的事情，就像在第3章中那样，将前端和后端分开。由于我们这次使用类和*面向对象编程*，我们可以定义一个后端类*——*让我们称它为`Hub`——它可以作为前端代码调用后端代码的单一点。任何前端可以调用的函数都应该在`Hub`类中是一个方法。这与第3章中的`backend.py`类似，其中每个从前端代码调用的后端函数都在`backend.py`中定义。
- en: We might expect the `Hub` class to have methods that fulfill actions a frontend
    user might want to take, such as `create_user`, `create_haiku`, `update_haiku`,
    etc. Over time, though, as our app grows more and more complex, the `Hub` class
    would have an increasing number of methods, slowly making it unwieldy and difficult
    to manage.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能期望`Hub`类拥有满足前端用户可能想要执行的操作的方法，例如`create_user`、`create_haiku`、`update_haiku`等。然而，随着时间的推移，随着我们的应用程序变得越来越复杂，`Hub`类的方法数量会不断增加，慢慢地使其变得难以驾驭和管理。
- en: Rather than take this *monolithic* approach, it might be a better idea to divide
    up the actions offered by Hub into individual *service classes*, each pertaining
    to a specific kind of action, and using the `Hub` class as merely a coordinator.
    For instance, we could have a `UserService` class that offers methods pertaining
    to users, such as `create_user`, and a `HaikuService` class that offers those
    related to haikus, such as `create_haiku` and `update_haiku`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是采取这种*单体*方法，将`Hub`提供的操作分成单独的*服务类*可能更好，每个类都针对特定类型的操作，并使用`Hub`类仅作为协调者。例如，我们可以有一个`UserService`类，它提供与用户相关的操作，如`create_user`，以及一个`HaikuService`类，它提供与俳句相关的操作，如`create_haiku`和`update_haiku`。
- en: This would make our app more modular and easier to extend and maintain. We can
    add more user-related functionality to `UserService` independently of the haiku-related
    actions in `HaikuService`, and if we wanted to add limericks to our app later,
    we could introduce a `LimerickService` without touching either.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们的应用程序更加模块化，更容易扩展和维护。我们可以独立于`HaikuService`中的俳句相关操作，向`UserService`添加更多与用户相关的功能，如果我们想在以后添加打油诗到我们的应用程序中，我们可以引入一个`LimerickService`而不需要触及任何东西。
- en: With our overall code organization strategy in mind, let's turn our attention
    towards building one of the components—the user service.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们的整体代码组织策略，让我们将注意力转向构建组件之一——用户服务。
- en: 8.3.2 Creating the user service
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 创建用户服务
- en: Just as in prior chapters, we'll use a dataclass to represent the fundamental
    objects we're concerned with. In Chapters 3, 4, and 6, we had `Unit`, `Task`,
    and `Metric` classes. Here, we'll start with a `User` class.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在先前的章节中一样，我们将使用dataclass来表示我们关心的基本对象。在第3、4和6章中，我们有`Unit`、`Task`和`Metric`类。在这里，我们将从`User`类开始。
- en: Create a new Python file called `user.py` in the `backend` folder, with the
    text shown in listing 8.4.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在`backend`文件夹中创建一个新的Python文件，命名为`user.py`，其文本如列表8.4所示。
- en: Listing 8.4 backend/user.py
  id: totrans-322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.4 backend/user.py
- en: '[PRE47]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You'll see that this directly mirrors the `users` table in our database, with
    fields for `username` and `password_hash`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到这直接反映了我们数据库中的`users`表，其中包含`username`和`password_hash`字段。
- en: Let's now talk about the latter field, and why we called it `password_hash`
    instead of `password`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈后一个字段，以及为什么我们称之为`password_hash`而不是`password`。
- en: Storing passwords securely
  id: totrans-326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安全存储密码
- en: Passwords are naturally some of the most sensitive pieces of information software
    developers need to deal with, and much of the field of cybersecurity focuses on
    keeping them secret.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 密码自然是软件开发者需要处理的最敏感的信息之一，而网络安全领域的很大一部分都集中在保持它们的秘密性。
- en: We know that we shouldn't store passwords in our code, resorting to the construct
    of `st.secrets` to avoid this. But what about storing them in a database?
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们不应该在我们的代码中存储密码，而是求助于`st.secrets`构造来避免这种情况。但是，将它们存储在数据库中又如何呢？
- en: Obviously, our app needs to be able to compare a user-entered password with
    the one actually associated with the user, so passwords need to be stored in some
    form. However, storing them directly as plain text in a database introduces a
    security vulnerability.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们的应用程序需要能够将用户输入的密码与实际关联的用户密码进行比较，因此密码需要以某种形式存储。然而，直接将它们以纯文本形式存储在数据库中会引入安全漏洞。
- en: That's because anyone who gains access to our database—through some kind of
    security breach—will be able to see passwords in their raw form. How do we avoid
    this though?
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为任何通过某种安全漏洞获得我们数据库访问权限的人——将能够看到以原始形式存储的密码。但我们如何避免这种情况呢？
- en: 'The answer is: with *one-way cryptographic hash functions*, or in other words,
    a bit of fancy math. It turns out that there are certain mathematical operations
    that are easy to perform normally but extremely difficult to perform in reverse.
    As a trivial example, consider multiplying two prime numbers a and b to get c.
    Multiplying a and b to get c is easy, but if you''re only given c, identifying
    a and b is difficult, especially when c is very, very large (think hundreds of
    digits long).'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是：使用**单向加密哈希函数**，或者说，一点复杂的数学。事实证明，有一些数学运算在正常情况下很容易执行，但在反向执行时却极其困难。作为一个简单的例子，考虑将两个质数a和b相乘得到c。a和b相乘得到c很容易，但如果你只得到c，识别a和b就困难了，尤其是当c非常大时（想想有几百位长）。
- en: Similarly, you can think of a cryptographic hash function as an operation performed
    on a password that's very difficult to reverse.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以将加密哈希函数视为对密码执行的操作，这种操作很难逆转。
- en: 'Let''s say someone''s password is `SomePassword123`. If you apply a hash function
    `H` to it, you might get a password hash that looks like a random sequence of
    characters:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 假设某个人的密码是`SomePassword123`。如果你对它应用一个哈希函数`H`，你可能会得到一个看起来像随机字符序列的密码哈希：
- en: Rather than store the string `SomePassword123` directly in the database, we
    store `g53jkdlgfee09ded8d33rr45t5y5y43f2eff`. Then when someone enters a password
    in our app, we apply the hash function to *that* password and compare the result
    to `g53jkdlgfee09ded8d33rr45t5y5y43f2eff`. If the two are the same, the user is
    authenticated.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是直接将字符串`SomePassword123`存储在数据库中，我们存储`g53jkdlgfee09ded8d33rr45t5y5y43f2eff`。然后当有人在我们的应用程序中输入密码时，我们将哈希函数应用于**那个**密码，并将结果与`g53jkdlgfee09ded8d33rr45t5y5y43f2eff`进行比较。如果两者相同，则用户被验证。
- en: How does this help with security? Well, if a hacker now manages to get into
    our database, they don't have the actual password, only the password hash. As
    stated, it's very difficult to obtain the password from the password hash.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这如何帮助提高安全性？好吧，如果黑客现在设法进入我们的数据库，他们只能得到密码的哈希值，而不是实际的密码。正如所述，从密码哈希中获取密码非常困难。
- en: The password hash itself is useless to the hacker as there's no point entering
    it in the app—if you did, the app would just apply the hash function on it and
    come up with a completely different hash that's compared against the real one.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 对于黑客来说，密码哈希本身是无用的，因为没有理由在应用程序中输入它——如果你这样做，应用程序会对其应用哈希函数，并得出一个与真实哈希值完全不同的哈希值。
- en: How do we implement this in our app? Fortunately, we don't have to do it from
    scratch. There are third-party libraries that do it for us. We'll use `bcrypt`,
    which you should install now with `pip install bcrypt`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在我们的应用程序中实现这一点？幸运的是，我们不必从头开始。有一些第三方库为我们做了这件事。我们将使用`bcrypt`，你现在应该使用`pip install
    bcrypt`来安装它。
- en: 'Let''s add two more methods to our `User` class so it now looks like this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`User`类中添加两个更多的方法，使其现在看起来像这样：
- en: '[PRE48]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We've decorated the `hash_password` method with `@staticmethod`. This makes
    it belong to the class itself rather than to any specific instance of the class.
    We generally use `@staticmethod` for utility functions that are logically related
    to a class but don't actually need to access anything from a particular instance.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`@staticmethod`装饰了`hash_password`方法。这使得它属于类本身，而不是属于类的任何特定实例。我们通常使用`@staticmethod`来表示与类逻辑相关但不需要访问特定实例的实用函数。
- en: '`hash_password` is a good fit for this since it doesn''t need to access any
    of the instance''s attributes or methods (note the absence of a `self` parameter).
    Rather, it simply accepts a password entered by a user, converts it into a hash
    using `bcrypt`, and returns it.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`hash_password` 函数非常适合这个用途，因为它不需要访问实例的任何属性或方法（注意没有`self`参数）。相反，它只是接受用户输入的密码，使用`bcrypt`将其转换为哈希值，并返回它。'
- en: I won't go into the details of how this works, but at a high level, we're taking
    an extra measure of security here by adding a random "salt" to the password (`bcrypt.gensalt()`)
    before hashing it. This salt helps protect the password against hackers simply
    looking up the password associated with a password hash from a huge pre-computed
    table of such hashes (called a *rainbow table*).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会深入讲解其工作原理的细节，但总的来说，我们在对密码进行散列之前，通过添加一个随机的“盐”（`bcrypt.gensalt()`）来采取额外的安全措施。这种盐有助于保护密码免受黑客通过从巨大的预计算散列表（称为*彩虹表*）中查找与密码散列关联的密码的攻击。
- en: We also have an `authenticate` method that we'll use when a user enters a password.
    `bcrypt.checkpw` compares the entered password (`password.encode()`) and the password
    hash stored in the `User` object (`self.password_hash.encode()`), returning `True`
    if they match.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个`authenticate`方法，当用户输入密码时我们将使用它。`bcrypt.checkpw`比较输入的密码（`password.encode()`）和存储在`User`对象中的密码散列（`self.password_hash.encode()`），如果它们匹配则返回`True`。
- en: The UserService class
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: UserService类
- en: We're now ready to create the `UserService` class, the one we determined would
    have methods for user-related operations. Create a `user_service.py` file under
    `backend/` with the content in listing 8.5.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备创建`UserService`类，这是我们确定将具有用户相关操作方法的类。在`backend/`目录下创建一个名为`user_service.py`的文件，其内容如列表8.5所示。
- en: Listing 8.5 backend/user_service.py
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.5 backend/user_service.py
- en: '[PRE49]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`UserService` has a `__init__` method that accepts an instance of the `Database`
    class we created earlier and assigns it to a `database` attribute (`self.database`)
    of the object.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserService`类有一个`__init__`方法，它接受我们之前创建的`Database`类的一个实例，并将其分配给对象的`database`属性（`self.database`）。'
- en: When a user enters a username and password to create a user, we first need to
    check if a user of that username already exists, so we have a `get_user` method
    that returns the user if one exists or `None` if it doesn't.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入用户名和密码以创建用户时，我们首先需要检查是否存在具有该用户名的用户，因此我们有一个`get_user`方法，如果存在用户，则返回用户，如果不存在，则返回`None`。
- en: The `get_user` method executes a parameterized SQL query (`SELECT username,
    password_hash FROM users WHERE username = %s`) on the database, passing the given
    username as the only parameter (`(username, )`).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_user`方法在数据库上执行一个参数化的SQL查询（`SELECT username, password_hash FROM users WHERE
    username = %s`），传递给定的用户名作为唯一参数（`(username, )`）。'
- en: 'As we''ve seen before, this returns a list of tuples. Due to the `SELECT username,
    password`, these will be of the form `(<username>, <password_hash>)`. Consider
    the last line in `get_users`:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，这返回了一个元组的列表。由于`SELECT username, password`，这些将具有形式`(<username>, <password_hash>)`。考虑`get_users`中的最后一行：
- en: '[PRE50]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If there's no user with the given username, results will be an empty list, so
    it'll evaluate to `False`, causing `get_user` to return `None`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有给定用户名的用户，结果将是一个空列表，因此它将评估为`False`，导致`get_user`返回`None`。
- en: If there *is* such a user, `results[0]` will be a tuple of the form `(<username>,
    <password_hash>)`. In Python, the `*` operator when applied to a tuple (or a list),
    *destructures* it for use in things like function calls.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果确实存在这样的用户，`results[0]`将是一个形式为`(<username>, <password_hash>)`的元组。在Python中，当`*`运算符应用于元组（或列表）时，它会*解构*它以用于函数调用等。
- en: 'So `User(*results[0])` is equivalent to `User(<username>, <password_hash>)`
    which creates a new instance of the `User` dataclass (which you''ll recall has
    two corresponding members: `username` and `password_hash`).'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 因此`User(*results[0])`等价于`User(<username>, <password_hash>)`，这创建了一个新的`User`数据类实例（您会记得它有两个相应的成员：`username`和`password_hash`）。
- en: The `create_user` method first uses `self.get_user(username)` to see if a user
    already exists with the given username. If it does, it simply returns `None`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_user`方法首先使用`self.get_user(username)`来查看是否存在具有给定用户名的用户。如果存在，它将简单地返回`None`。'
- en: 'If it doesn''t, it issues the following query to the database:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它不存在，它将向数据库发出以下查询：
- en: '[PRE51]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is an `INSERT` query, which we've seen previously. The only new thing here
    is the line `RETURNING username, password_hash`. An `INSERT` query doesn't generally
    need to return any results, as it's a modify operation, not a read operation.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`INSERT`查询，我们之前已经见过。这里唯一的新内容是行`RETURNING username, password_hash`。通常，`INSERT`查询不需要返回任何结果，因为它是一个修改操作，而不是读取操作。
- en: Adding the `RETURNING` clause makes it return the specified fields in the same
    way that a `SELECT` query would. In this case, the `username` and `password_hash`
    of the newly created row are returned.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`RETURNING`子句使其以与`SELECT`查询相同的方式返回指定的字段。在这种情况下，返回新创建行的`username`和`password_hash`。
- en: Once again, `create_user` uses the same approach as `get_user` (`User(*results[0])`)
    to create and return a `User` object if everything is successful.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`create_user`使用与`get_user`（`User(*results[0])`）相同的方法来创建并返回一个`User`对象，如果一切顺利的话。
- en: The Hub class
  id: totrans-362
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Hub`类'
- en: When we spoke of code organization earlier, we mentioned the `Hub` class, which
    would be the single point that our frontend code would access. Let's write that
    class now. Create `backend/hub.py` with the code from listing 8.6.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们之前提到代码组织时，我们提到了`Hub`类，它将是我们的前端代码访问的单一点。现在让我们编写这个类。创建`backend/hub.py`，并使用列表8.6中的代码。
- en: Listing 8.6 backend/hub.py
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.6 backend/hub.py
- en: '[PRE52]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `Hub` class''s `__init__` is quite simple: it accepts a `config` object
    (a dictionary of configuration options, such as the one obtained by parsing the
    `secrets.toml` file we created earlier), creates a `Database` object, and passes
    it to `UserService` to create an instance of that class.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hub`类的`__init__`非常简单：它接受一个`config`对象（一个配置选项的字典，例如我们之前解析的`secrets.toml`文件中获得的），创建一个`Database`对象，并将其传递给`UserService`以创建该类的实例。'
- en: '`Hub` has no other methods. This makes sense because, as we''ve emphasized,
    `Hub` is simply a coordinator class that our frontend can use to access the various
    service class objects (of which `user_service`, an instance of `UserService`,
    is the only one we''ve created so far).'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hub`没有其他方法。这很有道理，因为我们之前强调过，`Hub`只是一个协调器类，我们的前端可以使用它来访问各种服务类对象（其中`user_service`是一个`UserService`的实例，这是我们迄今为止创建的唯一一个）。'
- en: The signup page
  id: totrans-368
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注册页面
- en: Working our way from the bottom up, we've created a `User` class, a `UserService`
    class that accesses the `User` class, and a `Hub` class that accesses the `UserService`
    class—which currently only has a `create_user` method.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 从下往上，我们创建了一个`User`类，一个访问`User`类的`UserService`类，以及一个访问`UserService`类的`Hub`类——目前它只有一个`create_user`方法。
- en: The part of our Streamlit app that accesses `create_user` will be the signup
    page, which we'll define—for now—in `main.py`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`create_user`的我们的Streamlit应用程序部分将是注册页面，我们暂时在`main.py`中定义它。
- en: Our previous `main.py` initialized the `Database` object directly and executed
    a sample query. Since the database is now initialized in the `Hub` class, we'll
    rewrite `main.py` entirely, as shown in listing 8.7.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的`main.py`直接初始化了`Database`对象并执行了一个示例查询。由于数据库现在在`Hub`类中初始化，我们将完全重写`main.py`，如列表8.7所示。
- en: Listing 8.7 main.py revised
  id: totrans-372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.7 main.py修订版
- en: '[PRE53]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: By this point in the book, you should be able to read the code in listing 8.7
    fairly easily.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 到这本书的这一部分，你应该能够比较容易地阅读列表8.7中的代码。
- en: It starts by creating an instance of `Hub` using the `'config'` entry of `st.secrets`
    (note here that `Hub` accepts the entire `config` object rather than just the
    connection string in case there are other configurations that need to be considered).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先通过使用`st.secrets`的`'config'`条目来创建一个`Hub`实例（注意这里，`Hub`接受整个`config`对象，而不仅仅是连接字符串，以防需要考虑其他配置）。
- en: Next, it displays the usual username-password-confirm password set of inputs
    I'm sure you've seen in various websites before. On clicking the "Create account"
    button, if the passwords in the two inputs don't match, an error is displayed.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它显示了通常的用户名-密码-确认密码的输入组合，我相信你之前在各种网站上已经见过。点击“创建账户”按钮时，如果两个输入框中的密码不匹配，会显示错误。
- en: 'If they do match, we call the `create_user` method defined in the `UserService`
    class to create the user in the database:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们匹配，我们调用在`UserService`类中定义的`create_user`方法来在数据库中创建用户：
- en: '[PRE54]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We then show a success or error message based on the return value.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们根据返回值显示成功或错误消息。
- en: At this point, you should be able to see figure 8.7 if you rerun the app.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，如果你重新运行应用程序，你应该能够看到图8.7。
- en: '![image](../Images/ch08__image007.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch08__image007.png)'
- en: Figure 8.7 Haiku Haven's signup page (see chapter_8/in_progress_02 in the GitHub
    repo for the full code)
  id: totrans-382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.7 Haiku Haven的注册页面（完整代码请见GitHub仓库中的chapter_8/in_progress_02）
- en: 'Try creating an account with the username `bob`. To verify that it worked and
    that a user has indeed been created, you can issue the query `SELECT * from users
    where username = ''bob''` in your `psql` prompt (which you''ve hopefully kept
    open). This should give you something like:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用用户名`bob`创建一个账户。为了验证它是否成功并且确实创建了一个用户，你可以在你的`psql`提示符（希望你保持打开状态）中发出查询`SELECT
    * from users where username = 'bob'`。这应该会给你类似以下的结果：
- en: '[PRE55]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As you can see, due to the hashing, `bob`'s password is no longer directly visible.
    But can `bob` log in? Not until we've completed the next part!
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，由于散列，`bob` 的密码不再直接可见。但 `bob` 能登录吗？除非我们完成了下一部分！
- en: 8.4 Setting up a multi-page login flow
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 设置多页登录流程
- en: We saw earlier—when we sketched out the user experience—that Haiku Haven is
    meant to be a multi-page app with different pages for signup, login, and the haiku-related
    functionality, something we haven't encountered before.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在绘制用户体验草图时看到——Haiku Haven 意味着它应该是一个多页应用，具有注册、登录和俳句相关功能的不同页面，这是我们之前没有遇到过的。
- en: 8.4.1 Multi-page apps in Streamlit
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.1 Streamlit 中的多页应用
- en: Streamlit has built-in support for multi-page apps. In this scheme, you define
    your individual pages separately, and let your entrypoint file (the one you run
    with `streamlit run`) act as a "router" that identifies the page to load and runs
    it.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 内置了对多页应用的支持。在这个方案中，你单独定义你的各个页面，让你的入口文件（你用 `streamlit run` 运行的文件）充当一个“路由器”，它识别要加载的页面并运行它。
- en: The entrypoint file is quite crucial here; it's loaded as usual in every re-run,
    and it's the one that picks the "current page" to load.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 入口文件在这里非常关键；它通常在每次重新运行时加载，并且是选择要加载的“当前页面”的那个文件。
- en: Let's see an example. So far in our app, we've created a signup page for users
    to create their accounts, but not a login page. Once we do create the login page,
    there needs to be a way to tie the two together, making them part of the same
    app.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。到目前为止，在我们的应用中，我们已经为用户创建了一个注册页面，以便他们创建自己的账户，但还没有登录页面。一旦我们创建了登录页面，就需要有一种方法将这两个页面联系起来，使它们成为同一个应用的一部分。
- en: We'll do that by revising the `main.py` file one more time, using the multi-page
    approach discussed above. The signup flow we included in `main.py` will have to
    move to a different file (`frontend/signup.py`). The new `main.py` is shown in
    listing 8.8.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过再次修订 `main.py` 文件来实现这一点，使用上面讨论的多页方法。我们在 `main.py` 中包含的注册流程将不得不移动到不同的文件（`frontend/signup.py`）。新的
    `main.py` 如列表 8.8 所示。
- en: Listing 8.8 main.py revised (yet again)
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.8 main.py 修订（再次）
- en: '[PRE56]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The first new thing you''ll notice here is the `pages` dictionary. The keys
    in `pages` are `"login"` and `"signup"`, which are the names of the pages we want
    in our app. The values are `st.Page` objects. Let''s inspect the first one:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里首先会注意到的是 `pages` 字典。`pages` 中的键是 `"login"` 和 `"signup"`，这是我们希望在应用中出现的页面名称。值是
    `st.Page` 对象。让我们检查第一个：
- en: '[PRE57]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`st.Page` is Streamlit''s way of defining a single page in a multi-page app.
    The first argument you pass it is the path to the Python script for that page—in
    this case, `frontend/login.py`, which doesn''t exist yet. We''ve also passed it
    a sensible title.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.Page` 是 Streamlit 定义多页应用中单个页面的方式。你传递给它的第一个参数是该页面的 Python 脚本路径——在本例中是 `frontend/login.py`，但目前还不存在。我们还传递给它一个合理的标题。'
- en: 'The last argument is an icon for the page. It has a curious value: `:material/login:`.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数是页面的图标。它有一个奇特的价值：`:material/login:`。
- en: This demonstrates a neat way to display icons in Streamlit. The syntax `:material/<icon_name>:`
    is accepted by most widgets that accept displayable text, and is converted to
    an image when rendered to the screen.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了在 Streamlit 中显示图标的一种巧妙方法。语法 `:material/<icon_name>` 被大多数接受可显示文本的小部件所接受，并在渲染到屏幕上时转换为图像。
- en: You can see the supported icons in Google's Material Symbols library at `https://fonts.google.com/icons?icon.set=Material+Symbols`.
    In this case, we've chosen the "Login" icon. Whenever you need to show an icon,
    you can go to that URL, click the icon you want, identify its icon name from the
    sidebar that opens to the right, and substitute it within the text `:material/<icon_name>:`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Google 的 Material Symbols 库中看到支持的图标，网址是 `https://fonts.google.com/icons?icon.set=Material+Symbols`。在这种情况下，我们选择了“登录”图标。每次你需要显示一个图标时，你都可以访问那个
    URL，点击你想要的图标，从右侧打开的侧边栏中识别其图标名称，并将其替换为文本 `:material/<icon_name>:` 中的。
- en: 'Now turn your focus to the following lines further below:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将你的注意力转向下面更下面的以下几行：
- en: '[PRE58]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, we're feeding the two `st.Page` objects in the `pages` dictionary (`pages['login']`
    and `pages['signup']`) to `st.navigation`, a new Streamlit widget.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `pages` 字典中的两个 `st.Page` 对象（`pages['login']` 和 `pages['signup']`）传递给
    `st.navigation`，一个新的 Streamlit 小部件。
- en: '`st.navigation` is used to configure the available pages in a multi-page Streamlit
    app, displaying a navigation bar that users can use to select the page they want
    to go to.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.navigation` 用于配置多页 Streamlit 应用中可用的页面，显示一个用户可以使用它来选择要访问的页面的导航栏。'
- en: It accepts a list of `Page` objects that form the navigation options, and returns
    a single `Page` object from the list. This returned item is the page selected
    by the user, or the first item in the list if nothing has been selected yet.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个由形成导航选项的`Page`对象组成的列表，并从列表中返回一个单一的`Page`对象。这个返回项是用户选择的页面，如果没有选择任何项，则是列表中的第一个项目。
- en: Once a page has been returned, it can be loaded using its `.run()` method.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦返回了一个页面，就可以使用它的`.run()`方法来加载它。
- en: You'll also see that we're saving the `Hub` instance (`hub`) to `st.session_state`,
    but not doing anything else with it. This is because the session state is shared
    between the pages in a multi-page app. So if you save something to `st.session_state`
    in any page, it will be accessible in the other pages too. In this case, we're
    going to be using the saved `hub` object in the other pages.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会看到我们将`Hub`实例（`hub`）保存到`st.session_state`中，但没有对它做任何其他操作。这是因为会话状态在多页应用中的页面之间是共享的。所以如果你在任意页面将某个东西保存到`st.session_state`中，它也会在其他页面中可访问。在这种情况下，我们将在其他页面中使用保存的`hub`对象。
- en: What about the signup flow we had earlier? Well, now that our app is multi-page,
    we'll move it to its own page, `signup.py`, within a new folder called `frontend`.
    As you'll see from listing 8.9, the content has mostly just been copied directly
    from our earlier `main.py` with no changes.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们之前提到的注册流程呢？嗯，现在我们的应用是多页的，我们将它移动到自己的页面，即`signup.py`，在名为`frontend`的新文件夹中。正如列表8.9所示，内容大部分只是直接从我们之前的`main.py`复制过来，没有做任何修改。
- en: Listing 8.9 frontend/signup.py
  id: totrans-409
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.9 frontend/signup.py
- en: '[PRE59]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The only change we've made (as compared to listing 8.7) is that we obtain the
    value of the `hub` variable from `st.session_state` where we saved it in the new
    `main.py`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表8.7相比，我们做的唯一改变是从我们之前在新的`main.py`中保存的`st.session_state`中获取`hub`变量的值。
- en: 8.4.2 Implementing login
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.2 实现登录
- en: With our multi-page app infrastructure in place, it's time to build out the
    login feature. Before we set up the login page, let's make sure our backend has
    the functionality we need.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的多页应用基础设施到位后，是时候构建登录功能了。在我们设置登录页面之前，让我们确保我们的后端有我们需要的功能。
- en: Authenticating a user in UserService
  id: totrans-414
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在UserService中认证用户
- en: 'As we''ve discussed, all user-related functionality needs to live in `UserService`.
    Currently, that class has `create_user` and `get_user` methods. We''ll implement
    a new `get_authenticated_user` method:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，所有与用户相关的功能都需要在`UserService`中实现。目前，这个类有`create_user`和`get_user`方法。我们将实现一个新的`get_authenticated_user`方法：
- en: '[PRE60]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`get_authenticated_user` accepts a username and password as arguments. It first
    calls the `get_user` method we defined earlier to see if a user exists with that
    username. If there is, it calls the `authenticate` method on the returned `User`
    object. Recall that the `authenticate` method in the `User` class compares the
    hash of the given password with that of the actual password.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_authenticated_user`接受用户名和密码作为参数。它首先调用我们之前定义的`get_user`方法，查看是否存在具有该用户名的用户。如果存在，它将在返回的`User`对象上调用`authenticate`方法。回想一下，`User`类中的`authenticate`方法比较给定密码的哈希值与实际密码的哈希值。'
- en: 'If the authentication succeeds, the `User` object is returned. If it doesn''t,
    the method returns `None`, which the calling code can interpret in two ways: either
    no such user exists or the password is incorrect. To keep things simple, we won''t
    distinguish between these in the return value.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果认证成功，将返回`User`对象。如果失败，该方法返回`None`，调用代码可以有两种解释：要么不存在这样的用户，要么密码不正确。为了简化，我们不会在返回值中区分这两种情况。
- en: Creating the login page
  id: totrans-419
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建登录页面
- en: That's all we need in `UserService`. We can now go ahead and create a login
    page to complement the signup page we made earlier.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UserService`中我们就需要这些了。现在我们可以继续创建一个登录页面，以补充我们之前创建的注册页面。
- en: Create a new file in `frontend/` called `login.py`, with the content shown in
    listing 8.10.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在`frontend/`目录下创建一个名为`login.py`的新文件，内容如列表8.10所示。
- en: Listing 8.10 frontend/login.py
  id: totrans-422
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.10 frontend/login.py
- en: '[PRE61]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This page is fairly similar to `signup.py`, and should be straightforward to
    follow with your current understanding of Streamlit.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面与`signup.py`相当相似，应该很容易根据你对Streamlit当前的理解来理解。
- en: 'The part to focus on here is what happens when the "Log in" button is clicked.
    We first call the authentication method we defined in `UserService`:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要关注的部分是当点击“登录”按钮时会发生什么。我们首先调用在`UserService`中定义的认证方法：
- en: '[PRE62]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As we saw, if the method returns a `User` object, authentication has succeeded;
    if it returns `None`, authentication has failed.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，如果该方法返回`User`对象，则认证成功；如果返回`None`，则认证失败。
- en: We write this condition as if `user:`. For the actual logging in, we'll use
    a very simple approach—storing a boolean variable called `logged_in` under `st.session_state`,
    along with the `User` object for the logged-in user (named simply as `user`).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个条件写成`user:`。对于实际的登录，我们将使用一个非常简单的方法——在`st.session_state`下存储一个名为`logged_in`的布尔变量，以及登录用户的`User`对象（简单地命名为`user`）。
- en: We also display a success or error message depending on whether the login succeeds.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会根据登录是否成功显示成功或错误消息。
- en: At this point, you should re-run your app using `streamlit run main.py`. Try
    logging in with the account you created previously. You should see something similar
    to figure 8.8.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该使用`streamlit run main.py`重新运行你的应用。尝试使用你之前创建的账户登录。你应该看到类似于图8.8的内容。
- en: '![image](../Images/ch08__image008.png)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch08__image008.png)'
- en: Figure 8.8 Haiku Haven's login page (see chapter_8/in_progress_03 in the GitHub
    repo for the full code)
  id: totrans-432
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.8 Haiku Haven的登录页面（完整代码请见GitHub仓库中的chapter_8/in_progress_03）
- en: Note the navigation panel created by `st.navigation`, which takes up the sidebar
    and contains links to navigate to either page (along with the icons we added!).
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 注意由`st.navigation`创建的导航面板，它占据了侧边栏，并包含导航到任一页面的链接（以及我们添加的图标！）。
- en: 8.4.3 Navigating between pages
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.3 在页面之间导航
- en: While we currently have the bare minimum that we need in a signup/login flow,
    there's definitely room for improvement. For instance, if the user is on the login
    page but doesn't have an account, there should be a helpful link right there to
    sign up, or vice versa.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们目前在注册/登录流程中已经有了最基本的需求，但肯定有改进的空间。例如，如果用户在登录页面但没有账户，应该有一个有用的链接直接注册，反之亦然。
- en: Also, when the user logs in, we should take them to some kind of logged-in page
    and give them the ability to log out.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当用户登录时，我们应该带他们到一个登录页面，并给他们提供登出的能力。
- en: Figure 8.9 lays out the ideal signup/login/logout flow we want to design.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9展示了我们想要设计的理想的注册/登录/登出流程。
- en: '![image](../Images/ch08__image009.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch08__image009.png)'
- en: Figure 8.9 Diagram showing the connections between pages through redirection
    and page links
  id: totrans-439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.9通过重定向和页面链接展示页面之间连接的图表
- en: Besides being able to go back and forth between the signup and login pages,
    and redirect to a home page when logged in, we also want the navigation panel
    to display different options based on if we're logged in or not.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够在注册和登录页面之间来回切换，并在登录时重定向到主页外，我们还想根据我们是否登录来显示导航面板的不同选项。
- en: If the user is logged in, they should see the home page and have the ability
    to log out—which shows them the login page again. If they're not, they should
    instead see the options to sign up or log in.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户已登录，他们应该看到主页并能够登出——这会再次显示登录页面。如果他们未登录，他们应该看到注册或登录的选项。
- en: Moving the pages dictionary to its own file
  id: totrans-442
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将页面字典移动到自己的文件中
- en: Since we're now going to be navigating between individual pages, it would be
    cleaner to put the `pages` dictionary (the one in `main.py` that defines the available
    pages) in its own separate file, so let's move that part of the code to `frontend/pages.py`,
    shown in listing 8.11.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们接下来将要在各个页面之间进行导航，因此将`pages`字典（位于`main.py`中，定义了可用的页面）放入一个单独的文件中会更清晰，所以让我们将这部分代码移动到`frontend/pages.py`，如列表8.11所示。
- en: Listing 8.11 frontend/pages.py
  id: totrans-444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.11 frontend/pages.py
- en: '[PRE63]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You''ll notice that we''ve added two new pages: `home`, which is supposed to
    represent the logged-in home page, and `logout`, which will log the user out.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们添加了两个新页面：`home`，它应该代表登录后的主页，以及`logout`，它将用户登出。
- en: Links between pages
  id: totrans-447
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 页面之间的链接
- en: Streamlit allows you to create links between pages in a multi-page app through
    a widget that is, appropriately enough, named `st.page_link`.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit允许你通过一个名为`st.page_link`的小部件在多页面应用中创建页面之间的链接。
- en: Let's use this to link between the `login` and `signup` pages.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个链接在`login`和`signup`页面之间建立联系。
- en: '`login.py` should look like this, with the page link added to the very bottom:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '`login.py`应该看起来像这样，在底部添加了页面链接：'
- en: '[PRE64]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`st.page_link` is quite easy to understand; the first argument is the `st.Page`
    object (from `pages`, imported from `pages.py`) we want to link to, and the second
    is the label text.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.page_link`非常容易理解；第一个参数是我们想要链接到的`st.Page`对象（从`pages`导入，位于`pages.py`），第二个是标签文本。'
- en: 'You can also pass a regular URL as the first argument, in case you want to
    link to an external page. `signup.py` has very similar changes:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将常规URL作为第一个参数传递，以防你想链接到外部页面。`signup.py`有非常相似的改变：
- en: '[PRE65]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Dynamically changing st.navigation
  id: totrans-455
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 动态更改st.navigation
- en: The next feature we'll implement is showing the user the right pages for their
    context in the navigation bar, i.e. `signup` and `login` when they're logged out,
    or `home` and `logout` when they're logged in.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个我们将实现的功能是，在导航栏中显示用户当前上下文正确的页面，即当用户注销时显示`signup`和`login`，当用户登录时显示`home`和`logout`。
- en: 'Edit `main.py` so it now looks like this:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`main.py`使其看起来像这样：
- en: '[PRE66]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Obviously, the `pages` dictionary is now defined in `pages.py` and imported
    into `main.py`.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`pages`字典现在定义在`pages.py`中，并导入到`main.py`中。
- en: As shown above, to dynamically change what's in the navigation panel, we use
    the `logged_in` session state variable that we save when the user logs in, and
    vary the `st.navigation` object that's assigned to `page` accordingly.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，为了动态更改导航面板中的内容，我们使用用户登录时保存的`logged_in`会话状态变量，并相应地改变分配给`page`的`st.navigation`对象。
- en: If the user is logged in, the navigation bar will now show the `home` and `logout`
    options. Since `pages['home']` is the first item in the list passed to `st.navigation`,
    that's the page that will be loaded by default when the user logs in.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户已登录，导航栏现在将显示`home`和`logout`选项。由于`pages['home']`是传递给`st.navigation`列表中的第一个项目，因此当用户登录时，默认加载的页面就是`home`页面。
- en: Let's now actually set up a placeholder page in `frontend/home.py` (listing
    8.12), so that there's something for a logged-in user to see.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`frontend/home.py`（列表8.12）中实际设置一个占位符页面，以便让已登录用户有所见。
- en: Listing 8.12 frontend/home.py
  id: totrans-463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.12 frontend/home.py
- en: '[PRE67]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Nothing earth-shattering here for now; we just display a greeting that includes
    the logged-in user's username. Recall that we save the logged-in `User` object
    in `st.session_state.user` in `login.py`.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这里没有什么惊天动地的事情；我们只是显示一个包含已登录用户用户名的问候语。回想一下，我们在`login.py`中将已登录的`User`对象保存到`st.session_state.user`中。
- en: Automatic redirection for login and logout
  id: totrans-466
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 登录和注销的自动重定向
- en: Our proposed ideal login flow requires the user to be redirected automatically
    on login and logout. How does this work exactly?
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提出的理想登录流程要求用户在登录和注销时自动重定向。这究竟是如何工作的呢？
- en: Remember that when a user clicks the "Log in" button, the `logged_in` session
    state variable is set to `True`.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当用户点击“登录”按钮时，`logged_in`会话状态变量被设置为`True`。
- en: This means that in the next re-run, `main.py` will pick up the changed value
    of `logged_in`, display the new navigation panel and load `home.py`.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在下次重新运行时，`main.py`将获取`logged_in`的更改值，显示新的导航面板并加载`home.py`。
- en: 'To make this truly seamless, we have to trigger the re-run though. So add an
    `st.rerun()` to `login.py`:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正实现无缝操作，我们必须触发重新运行。因此，在`login.py`中添加一个`st.rerun()`。
- en: '[PRE68]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: And logging out? Well, that's going to reverse everything that happens at login.
    Create a `logout.py` with content shown in listing 8.13.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 至于注销？嗯，那将逆转登录时发生的所有事情。创建一个包含列表8.13内容的`logout.py`。
- en: Listing 8.13 frontend/logout.py
  id: totrans-473
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.13 frontend/logout.py
- en: '[PRE69]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: That completes our signup/login/logout flow! Re-run the app and try it all out!
    When you log in, you should now see a different navigation panel and the loaded
    home page (see figure 8.10).
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了我们的注册/登录/注销流程！重新运行应用程序并尝试一下！当你登录时，你现在应该看到一个不同的导航面板和加载的首页（见图8.10）。
- en: '![image](../Images/ch08__image010.png)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch08__image010.png)'
- en: Figure 8.10 The logged-in page with different options in the navigation bar
    (see chapter_8/in_progress_04 in the GitHub repo for the full code)
  id: totrans-477
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.10 登录页面中导航栏的不同选项（完整代码请见GitHub仓库中的chapter_8/in_progress_04）
- en: Clicking "Log out" in the navigation bar will load the login and signup pages
    again, which have page links to each other at the bottom.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 点击导航栏中的“注销”将重新加载登录和注册页面，底部有页面链接相互跳转。
- en: 8.5 Creating, reading, updating, and deleting haikus
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 创建、读取、更新和删除俳句
- en: 'Now that user authentication is taken care of, it''s finally time to work on
    the crux of our app: the ability to create, read, update and delete haikus. We''ll
    start with haiku creation, encapsulating this behavior in a `HaikuService` class,
    and then making the appropriate changes to the frontend.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户身份验证已经处理完毕，我们终于可以着手处理我们应用程序的核心功能：创建、读取、更新和删除俳句。我们将从创建俳句开始，将这种行为封装在`HaikuService`类中，然后对前端进行适当的修改。
- en: 8.5.1 Defining a HaikuService class
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.1 定义HaikuService类
- en: The code structure we'll follow in the haiku service is pretty analogous to
    what we already have in `UserService`.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在俳句服务中遵循的代码结构与我们已经在`UserService`中拥有的结构非常相似。
- en: Let's begin with a `Haiku` dataclass to represent a haiku. Create this as `haiku.py`
    in the `backend/` folder (listing 8.14).
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从表示俳句的 `Haiku` 数据类开始。在 `backend/` 文件夹中创建 `haiku.py`，如列表 8.14 所示。
- en: Listing 8.14 backend/haiku.py
  id: totrans-484
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.14 backend/haiku.py
- en: '[PRE70]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: As in the `User` class, the fields mirror those in our corresponding database
    table (`haikus`).
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `User` 类一样，字段反映了我们相应的数据库表（`haikus`）中的字段。
- en: '`HaikuService` itself is shown in listing 8.15.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '`HaikuService` 本身如列表 8.15 所示。'
- en: Listing 8.15 backend/haiku_service.py
  id: totrans-488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.15 backend/haiku_service.py
- en: '[PRE71]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Again, the code is fairly analogous to that of `UserService`, so a detailed
    explanation isn't warranted.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，代码与 `UserService` 的代码相当类似，因此不需要详细的解释。
- en: As we've seen, we only need to supply the `author` and `text` fields in our
    SQL query; the database automatically provides `haiku_id` and `created_at`, and
    all of the fields are returned as per the `RETURNING` clause.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们只需要在我们的 SQL 查询中提供 `author` 和 `text` 字段；数据库自动提供 `haiku_id` 和 `created_at`，并且所有字段都按照
    `RETURNING` 子句返回。
- en: 'To wrap up the backend changes, let''s add an instance of `HaikuService` to
    `hub.py`:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结后端更改，让我们在 `hub.py` 中添加一个 `HaikuService` 实例：
- en: '[PRE72]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This will enable the haiku creation function to be accessed from the frontend,
    as we'll see presently.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使俳句创建功能可以从前端访问，正如我们即将看到的。
- en: 8.5.2 Enabling users to create haikus
  id: totrans-495
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.2 允许用户创建俳句
- en: Our earlier `home.py` was, of course, just a placeholder. Our actual logged-in
    home page should ideally have a way to create haikus and display them.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的 `home.py` 当然只是一个占位符。我们的实际登录主页理想上应该有创建俳句并显示俳句的方式。
- en: For creating haikus, let's create a modal dialog similar to the one we created
    in Chapter 7.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建俳句，让我们创建一个类似于第 7 章中创建的模态对话框。
- en: Create a new file, `frontend/haiku_editor.py` as shown in listing 8.16.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，`frontend/haiku_editor.py`，如列表 8.16 所示。
- en: Listing 8.16 frontend/haiku_editor.py
  id: totrans-499
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.16 frontend/haiku_editor.py
- en: '[PRE73]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `haiku_editor` function is decorated with `st.dialog`—which, as we saw in
    this previous chapter, executes its body in a modal screen.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '`haiku_editor` 函数被 `st.dialog` 装饰器装饰——正如我们在上一章中看到的，它在模态屏幕中执行其主体。'
- en: 'The body of `haiku_editor` is uncomplicated. We first accept the haiku text
    entered by the user in an `st.text_area` widget:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '`haiku_editor` 的主体很简单。我们首先接受用户在 `st.text_area` 小部件中输入的俳句文本：'
- en: '[PRE74]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`st.text_area` is precisely what you''d expect it to be—an area for entering
    several lines of text.'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.text_area` 正如您所期望的那样——一个用于输入多行文本的区域。'
- en: On clicking "Save haiku", we call the `create_haiku` method under `HaikuService`
    to save it to the database, and show the appropriate success/failure message.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击“保存俳句”时，我们调用 `HaikuService` 下的 `create_haiku` 方法将其保存到数据库，并显示相应的成功/失败消息。
- en: 'Close the loop by including—in `home.py`—an "Add Haiku" button that triggers
    the `haiku_editor` dialog we just defined:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `home.py` 中包含一个“添加俳句”按钮来关闭循环，该按钮触发我们刚刚定义的 `haiku_editor` 对话框：
- en: '[PRE75]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As you can see, we're using a Material icon again, this time in the place of
    the word "Add" within the button label.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们再次使用了一个 Material 图标，这次是在按钮标签中的“添加”一词的位置。
- en: Let's see everything working so far! Re-run your Streamlit app, login, and add
    a haiku (see figure 8.11).
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看到目前为止一切是否正常工作！重新运行您的 Streamlit 应用程序，登录，并添加一个俳句（请参阅图 8.11）。
- en: '![image](../Images/ch08__image011.png)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch08__image011.png)'
- en: Figure 8.11 Creating a haiku (see chapter_8/in_progress_05 in the GitHub repo
    for the full code)
  id: totrans-511
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.11 创建俳句（有关完整代码，请参阅 GitHub 仓库中的 chapter_8/in_progress_05）
- en: To convince yourself that a haiku has indeed been created, you can query your
    `haikus` table.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你确信确实创建了一个俳句，你可以查询你的 `haikus` 表。
- en: '8.5.3 The other CRUD operations: Read, Update, Delete'
  id: totrans-513
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.3 其他 CRUD 操作：读取、更新、删除
- en: 'To make our CRUD app feature complete, there are three more operations we need
    to implement:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的 CRUD 应用程序功能完整，我们还需要实现三个更多操作：
- en: '*Reading* the current users'' haikus from the database and list them in the
    app'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*读取* 当前用户的俳句从数据库中读取并在应用程序中列出'
- en: '*Updating* a given haiku'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更新* 给定的俳句'
- en: '*Deleting* a haiku altogether'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*完全删除* 一个俳句'
- en: Defining the operations in HaikuService
  id: totrans-518
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 `HaikuService` 中定义操作
- en: 'As before, let''s define these operations in the backend first, by editing
    the `HaikuService` class in `haiku_service.py`:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，让我们首先在 `haiku_service.py` 中的 `HaikuService` 类中定义这些操作：
- en: '[PRE76]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We define one method for each operation: `get_haikus_by_author` for reading
    haikus, `update_haiku` for updating, and `delete_haiku` for deleting a haiku.'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个操作定义一个方法：`get_haikus_by_author` 用于读取俳句，`update_haiku` 用于更新，`delete_haiku`
    用于删除俳句。
- en: In each case, we use the same pattern we've seen before—we run a SQL command,
    convert the results into Haiku objects, and return them.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，我们都使用之前看到的相同模式——我们运行一个SQL命令，将结果转换为Haiku对象，并返回它们。
- en: In the case of `get_haikus_by_author`, we return the results as a *list* of
    Haiku objects given that there may be more than one by a certain author.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在`get_haikus_by_author`的情况下，由于可能存在多个作者，我们返回一个包含Haiku对象的*列表*作为结果。
- en: In both `update_haiku` and `delete_haiku`, we accept `haiku_id`—the unique identifier
    of a haiku—as an argument, using `UPDATE..SET` and `DELETE FROM` SQL commands
    respectively to achieve the desired result.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update_haiku`和`delete_haiku`中，我们分别使用`haiku_id`——俳句的唯一标识符作为参数，分别使用`UPDATE..SET`和`DELETE
    FROM` SQL命令来实现所需的结果。
- en: Creating the UI
  id: totrans-525
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建用户界面
- en: Our backend methods return instances of the `Haiku` class, but how do we display
    these in the frontend?
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的后端方法返回`Haiku`类的实例，但我们如何在前端显示这些实例？
- en: 'We should probably create a `display_haiku` function that accepts a `Haiku`
    object and displays it on the screen. The next natural question is: what do we
    display? What is the user likely to be interested in seeing?'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要创建一个`display_haiku`函数，它接受一个`Haiku`对象并在屏幕上显示它。下一个自然的问题是：我们显示什么？用户可能想看到什么？
- en: 'The `Haiku` class has four attributes: `haiku_id`, `created_at`, `author`,
    and `text`.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '`Haiku`类有四个属性：`haiku_id`、`created_at`、`author`和`text`。'
- en: Of these, `haiku_id` is an internal identifier that would be of no meaning to
    the end user, so we can exclude that. `created_at` might be useful to jog the
    user's memory of when a haiku was originally created. It would be redundant to
    show the `author` field since we're only going to be displaying haikus by the
    current logged-in user. And `text` is the content of the haiku, so we obviously
    want to display that.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些中，`haiku_id`是一个内部标识符，对最终用户没有意义，因此我们可以排除它。`created_at`可能有助于唤醒用户对俳句最初创建时间的记忆。由于我们只将显示当前登录用户的俳句，因此显示`author`字段将是多余的。而`text`是俳句的内容，所以我们显然想显示它。
- en: 'That gives us: `created_at` and `text`. Anything else? Well, we also want to
    give the user the option to edit or delete a particular haiku, so let''s pop in
    a couple of buttons as well.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 这就给出了：`created_at`和`text`。还有其他什么吗？嗯，我们还想给用户编辑或删除特定俳句的选项，所以让我们加入几个按钮。
- en: Listing 8.17 frontend/haiku_display.py
  id: totrans-531
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.17 frontend/haiku_display.py
- en: '[PRE77]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The key function to focus on here is the last one: `display_haiku`. Given `haiku`,
    an instance of the `Haiku` class, it makes four columns for the four things we
    want to display: `created_at`, `text`, the edit button, and the delete button.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要关注的关键函数是最后一个：`display_haiku`。给定`haiku`，即`Haiku`类的一个实例，它为我们要显示的四个事物创建了四个列：`created_at`、`text`、编辑按钮和删除按钮。
- en: The actual rendering of each of these takes place in its own function.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 这些的实际渲染在每个自己的函数中完成。
- en: '`get_haiku_created_display` takes haiku''s `created_at` property—a timestamp—
    and breaks it down into a day and a time using a method called `strftime`, which
    is used to format a timestamp in any given format based on a *format string*.
    In this case, `%Y-%m-%d` formats it as just a date, whereas `%H:%M` extracts the
    time in hours and minutes.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_haiku_created_display`接受俳句的`created_at`属性——一个时间戳，并使用名为`strftime`的方法将其分解为日期和时间，该方法用于根据*格式字符串*格式化时间戳。在这种情况下，`%Y-%m-%d`将其格式化为仅日期，而`%H:%M`提取小时和分钟。'
- en: '[PRE78]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: There are a few things going on here. The `:<color>[<text>]` syntax is used
    in Streamlit to display text in various colors. For instance, the string `:red[Hello]`
    would be interpreted by widgets like `st.write` or `st.markdown` as the word `Hello`
    in red text.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个事情在进行。在Streamlit中，`:<color>[<text>]`语法用于显示不同颜色的文本。例如，字符串`:red[Hello]`会被`st.write`或`st.markdown`等小部件解释为红色文本的单词`Hello`。
- en: We also see the icon syntax we saw earlier. Here we're using a calendar icon
    for the date and a clock icon (`schedule`) for the time, creating a user-friendly
    display for the date and time.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了之前看到的图标语法。在这里，我们使用日历图标表示日期，使用时钟图标（`schedule`）表示时间，为日期和时间创建了一个用户友好的显示。
- en: '`get_haiku_text_display` is meant to display the content of the haiku. Why
    do we have the following replace method? Why not just display the content directly?'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_haiku_text_display`的目的是显示俳句的内容。为什么我们有以下替换方法？为什么不直接显示内容呢？'
- en: '[PRE79]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This is something of a workaround. Streamlit handles line breaks in text rather
    strangely. To get text widgets like `st.markdown` to display the newline character
    `\n` properly, we have to precede it with two spaces, i.e. `' \n'` instead of
    just `'\n'`.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种解决方案。Streamlit处理文本中的换行符相当奇怪。为了使文本小部件如`st.markdown`正确显示换行符`\n`，我们必须在它前面加上两个空格，即`'
    \n'`而不是仅仅`'\n'`。
- en: The `edit_button` and `delete_button` functions simply display `st.button` widgets.
    You'll notice that we use icons as their labels, and give them widget keys—which
    is required for Streamlit to distinguish between them when we have many haikus
    displayed on a page. We've given them placeholder bodies with `pass` for now;
    we'll come back to them later.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '`edit_button`和`delete_button`函数简单地显示`st.button`小部件。你会注意到我们使用图标作为它们的标签，并给它们小部件键——这是Streamlit在页面上显示许多俳句时区分它们所必需的。我们现在给它们带有`pass`的占位符主体；我们稍后会回来处理它们。'
- en: Since we're using icons so much throughout the app, our code would actually
    be a lot more readable if we gave them better names (e.g. `CLOCK` instead of `:material/schedule:`)
    and put them in a more central location.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在整个应用程序中使用了这么多图标，如果我们给它们更好的名字（例如，`CLOCK`而不是`:material/schedule:`）并将它们放在更中心的位置，我们的代码实际上会更容易阅读。
- en: Let's put all the icons in their own file, `frontend/icons.py` (listing 8.18)
    and *import* them instead.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把所有的图标放入它们自己的文件中，`frontend/icons.py`（列表 8.18）并*导入*它们。
- en: Listing 8.18 frontend/icons.py
  id: totrans-545
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.18 frontend/icons.py
- en: '[PRE80]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We can now change `haiku_display.py`:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更改`haiku_display.py`：
- en: '[PRE81]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'There—that''s much more readable! Let''s now call `display_haiku` to show the
    user their list of created haikus! We''ll edit `home.py` to do this:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就更容易阅读了！现在让我们调用`display_haiku`来显示用户创建的俳句列表！我们将编辑`home.py`来完成此操作：
- en: '[PRE82]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The changes here are quite simple. After the add button we created earlier—which
    we've now changed to use an icon imported from `icons.py`—we display a header
    that says `<username>'s haikus` along with a divider (just a horizontal line underneath,
    controlled by `divider="gray"`).
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的更改相当简单。在之前创建的添加按钮之后——我们现在将其更改为使用从`icons.py`导入的图标——我们显示一个标题，说明`<username>'s
    haikus`，以及一个分隔符（由`divider="gray"`控制的水平线）。
- en: We then call the `get_haikus_by_author` method we defined in `HaikuService`,
    and loop through the results, calling `display_haiku` on each. If there are no
    haikus, we display an `st.info` message that says so.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用在`HaikuService`中定义的`get_haikus_by_author`方法，并遍历结果，对每个结果调用`display_haiku`。如果没有俳句，我们显示一个`st.info`消息来说明这一点。
- en: Re-run your app now to see the changes in figure 8.12 (after adding one more
    haiku)!
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新运行你的应用程序，以查看图 8.12 中的更改（在添加另一个俳句后）！
- en: '![image](../Images/ch08__image012.png)'
  id: totrans-554
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/ch08__image012.png)'
- en: Figure 8.12 Listing created haikus (see chapter_8/in_progress_07 in the GitHub
    repo for the full code)
  id: totrans-555
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.12 列表创建的俳句（在 GitHub 仓库的 chapter_8/in_progress_07 中查看完整代码）
- en: 'Note that there''s one more place we''ve been using icons: `pages.py`, where
    we''ve defined the pages for the multi-page app. Go ahead and update that file
    too:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还在一个地方使用了图标：`pages.py`，在那里我们定义了多页应用程序的页面。请继续更新该文件：
- en: '[PRE83]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Adding the update and delete functionality
  id: totrans-558
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加更新和删除功能
- en: 'Let''s get back to the edit and delete buttons, which currently have placeholders
    under them. The edit button should let a user edit one of their existing haikus.
    We can repurpose the haiku editor dialog we''ve already created to work with the
    "Add Haiku" button for this:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到编辑和删除按钮，它们目前下面有占位符。编辑按钮应该允许用户编辑他们现有的俳句之一。我们可以重用我们已创建的俳句编辑器对话框来与“添加俳句”按钮一起使用：
- en: '[PRE84]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The `haiku_editor` function now accepts a `haiku` argument which is `None` by
    default. If we're calling the editor to edit an existing haiku, we can pass the
    corresponding `Haiku` instance to `haiku`. Otherwise we're calling the dialog
    to add a haiku, so we pass `None`.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '`haiku_editor`函数现在接受一个`haiku`参数，默认值为`None`。如果我们调用编辑器来编辑现有的俳句，我们可以将相应的`Haiku`实例传递给`haiku`。否则，我们正在调用对话框来添加俳句，因此我们传递`None`。'
- en: In the rest of the function, we'll use the condition `if haiku` to check if
    we're performing the edit action or the add action.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的其余部分，我们将使用条件`if haiku`来检查我们是在执行编辑操作还是添加操作。
- en: In the next two lines, we pre-populate the existing haiku's text in the text
    area as a default value using the `value` parameter of `st.text_area` if we're
    in the edit action.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两行中，如果我们处于编辑操作，我们将使用`st.text_area`的`value`参数将现有的俳句文本预先填充到文本区域作为默认值。
- en: '[PRE85]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Then, once the save button is clicked, we pick either the `update_haiku` or
    the `create_haiku` method from `HaikuService` to execute. In the former case,
    we pass the existing haiku's `haiku_id` to identify the haiku we want to edit.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一旦点击保存按钮，我们就从 `HaikuService` 中选择 `update_haiku` 或 `create_haiku` 方法来执行。在前者的情况下，我们传递现有俳句的
    `haiku_id` 来标识我们想要编辑的俳句。
- en: If the operation is successful—which we determine by checking the return value,
    `new_haiku`—we issue an `st.rerun()`. This re-runs the entire app, closing the
    dialog in the process, because the button that triggered it in the first place
    is now in the "unclicked" state.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作成功——我们通过检查返回值 `new_haiku` 来确定——我们发出 `st.rerun()`。这会重新运行整个应用程序，在这个过程中关闭对话框，因为最初触发它的按钮现在处于“未点击”状态。
- en: 'We can now replace the placeholder under the edit button in `haiku_display.py`:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以替换 `haiku_display.py` 中编辑按钮下的占位符：
- en: '[PRE86]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In the same page, let''s also make the delete button trigger a deletion:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一页面上，让我们也让删除按钮触发删除操作：
- en: '[PRE87]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Here we call the `delete_haiku` method in `HaikuService`. If the deletion is
    successful, we perform an `st.rerun()` so that the list of haikus can update and
    no longer show the deleted haiku. If the deletion fails for any reason, we show
    an error.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在 `HaikuService` 中调用 `delete_haiku` 方法。如果删除成功，我们执行 `st.rerun()` 以更新俳句列表并不再显示已删除的俳句。如果由于任何原因删除失败，我们将显示错误。
- en: Re-run the app now and try editing or deleting a haiku (figure 8.13)!
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新运行应用程序并尝试编辑或删除俳句（图8.13）！
- en: '![image](../Images/ch08__image013.png)'
  id: totrans-573
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/ch08__image013.png)'
- en: Figure 8.13 Deleting a haiku (see chapter_8/in_progress_08 in the GitHub repo
    for the full code)
  id: totrans-574
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.13 删除俳句（完整代码请参阅GitHub仓库中的 chapter_8/in_progress_08）
- en: Haiku Haven has now been fully built—or at least we have a version that's fit
    to deploy to production. Before we do that though, there are a couple of final
    issues we need to address.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 俳句天堂现在已经完全建成——至少我们有一个适合部署到生产的版本。不过，在那样做之前，还有一些最终问题需要我们解决。
- en: 8.6 Multi-user considerations
  id: totrans-576
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 多用户考虑
- en: While Haiku Haven can be used by many users simultaneously, we need to be able
    to share resources efficiently between these users. The main resource that we're
    responsible for managing here is the database.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然“俳句天堂”可以由许多用户同时使用，但我们需要能够在这类用户之间有效地共享资源。我们在这里负责管理的主要资源是数据库。
- en: 8.6.1 Using st.cache_resource to share the database connection pool
  id: totrans-578
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.6.1 使用 st.cache_resource 共享数据库连接池
- en: Let's consider how a Streamlit app works when there are multiple users accessing
    it simultaneously. While there's a single Streamlit server that serves the app,
    each time a user accesses it, a new instance of the app is created, with all of
    the objects required to run the app created anew for that user.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑当有多个用户同时访问 Streamlit 应用程序时，应用程序是如何工作的。虽然有一个单独的 Streamlit 服务器提供应用程序服务，但每次用户访问它时，都会创建一个新的应用程序实例，为该用户创建所有运行应用程序所需的对象。
- en: Most of the time, this is what we want; it makes sure different user sessions
    don't interfere with each other. However, there are some things we *don't* want
    to create anew each time someone loads the app in a new browser tab.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们希望这样；这确保了不同的用户会话不会相互干扰。然而，有些东西我们 *不* 每次有人在新浏览器标签页中加载应用程序时都希望重新创建。
- en: A key example is the database connection pool we create in the `Database` class.
    In fact, the whole point of having a database connection pool is that when multiple
    user sessions need to access the database, they can do so by requesting connections
    from a *shared* pool, returning them when they're done.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键示例是我们 `Database` 类中创建的数据库连接池。事实上，拥有数据库连接池的全部意义在于，当多个用户会话需要访问数据库时，他们可以通过从
    *共享* 池中请求连接来实现，完成使用后将其返回。
- en: This means that there should only be *one* instance of the `Database` class
    ever created, to be shared across all users. However, we haven't set it up that
    way. Right now, *whenever* a new user loads the app—or a user loads the app in
    a new browser tab—a new session begins, and a new instance of the `Hub` class
    is created, which means a new `Database` instance is also created.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着应该只创建 `Database` 类的一个实例，以便所有用户共享。然而，我们还没有这样设置。目前，*每次* 新用户加载应用程序——或者用户在新的浏览器标签页中加载应用程序——就会开始一个新的会话，并创建一个新的
    `Hub` 类实例，这意味着也会创建一个新的 `Database` 实例。
- en: 'Fortunately, Streamlit offers a solution for this: `st.cache_resource`.'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Streamlit 提供了一个解决方案：`st.cache_resource`。
- en: Like `st.cache_data`—which we used in Chapter 6 to make loading the data in
    our metric dashboard faster—`st.cache_resource` is a way to make sure that only
    one instance of something exists across all users of an app.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在第 6 章中使用的 `st.cache_data`——它使我们的度量仪表板中的数据加载更快——`st.cache_resource` 是确保在应用程序的所有用户中只存在一个实例的一种方式。
- en: While `st.cache_data` is used for caching things like Pandas dataframes or the
    results of API calls, `st.cache_resource` is used for resources like database
    connections. In this case, we'll use it to store the single instance we want to
    create of the `Database` class.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `st.cache_data` 用于缓存像 Pandas 数据框或 API 调用结果这样的东西，但 `st.cache_resource` 用于像数据库连接这样的资源。在这种情况下，我们将用它来存储我们想要创建的
    `Database` 类的单个实例。
- en: 'This requires refactoring our app a little. Recall that currently (in `hub.py`)
    our `Hub` class accepts a `config` object and creates the `Database` instance
    itself:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要我们对应用程序进行一点重构。回想一下，目前（在 `hub.py` 中）我们的 `Hub` 类接受一个 `config` 对象并自己创建 `Database`
    实例：
- en: '[PRE88]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: But in our new scheme, the `Hub` class will continue to have a new instance
    created for every session, which means a new `Database` instance will *also* keep
    getting created. Instead, we'll have `Hub`'s `__init__` accept an *already-created*
    `Database` instance that it can simply pass to `UserService` and `HaikuService`.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们的新方案中，`Hub` 类将为每个会话创建一个新的实例，这意味着一个新的 `Database` 实例也将持续被创建。相反，我们将让 `Hub`
    的 `__init__` 接受一个已经创建的 `Database` 实例，它可以简单地将其传递给 `UserService` 和 `HaikuService`。
- en: 'That way, we can always pass the *same* instance of the `Database` class, avoiding
    creating it every time. `hub.py` will now look like this:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以始终传递 `Database` 类的相同实例，避免每次都创建它。`hub.py` 现在将看起来像这样：
- en: '[PRE89]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Where do we create the `Database` instance then? In `main.py`, which is where
    we''ll use `st.cache_resource`:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们在哪里创建 `Database` 实例呢？在 `main.py` 中，这是我们使用 `st.cache_resource` 的地方：
- en: '[PRE90]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: As is the case with `st.cache_data`, `st.cache_resource` is a decorator that's
    applied to a function. Here we define a new function to decorate called `get_database`
    which will return the cached `Database` object.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `st.cache_data` 一样，`st.cache_resource` 是一个应用于函数的装饰器。在这里，我们定义了一个新的函数来装饰，称为
    `get_database`，它将返回缓存的 `Database` 对象。
- en: '`get_database` will now run only once for a particular Streamlit server that''s
    started up, i.e. a single `streamlit run` command—when `main.py` is loaded for
    the first time. For all subsequent runs, `get_database` will return the cached
    `Database` instance, thereby making sure only one such instance is ever created.
    This cached instance will persist until the server process is terminated.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_database` 现在将只为启动的特定 Streamlit 服务器运行一次，即单个 `streamlit run` 命令——当 `main.py`
    首次加载时。对于所有后续运行，`get_database` 将返回缓存的 `Database` 实例，从而确保永远只创建这样一个实例。这个缓存的实例将一直持续到服务器进程终止。'
- en: 8.6.2 Using atexit to clean up database connections
  id: totrans-595
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.6.2 使用 atexit 清理数据库连接
- en: We've made sure that a `Database` instance is only created once per running
    instance of a Streamlit app server. That's one part of managing our database resource
    efficiently. The other is safely cleaning up any connections we create.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保每个 Streamlit 应用服务器运行实例只创建一个 `Database` 实例。这是高效管理数据库资源的一部分。另一部分是安全地清理我们创建的任何连接。
- en: 'Our `Database` class has a `close_all` method:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Database` 类有一个 `close_all` 方法：
- en: '[PRE91]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: If you inspect our code so far, however, we're not actually calling this method
    anywhere.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你检查我们到目前为止的代码，我们实际上并没有在任何地方调用这个方法。
- en: To clean up our connections correctly, we want this method to be called only
    once, when the Streamlit server is terminated. How do we accomplish this?
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确清理我们的连接，我们希望这个方法只在 Streamlit 服务器终止时被调用一次。我们如何实现这一点？
- en: The solution is the `atexit` module, which comes built-in with Python. `atexit`
    lets you register functions to be executed automatically when the Python interpreter
    is about to exit.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是 `atexit` 模块，它是 Python 内置的。`atexit` 允许你在 Python 解释器即将退出时自动执行函数。
- en: 'Here''s how we would modify `main.py` to register a function that cleans up
    our database connections using `atexit`:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将如何修改 `main.py` 以使用 `atexit` 注册一个清理数据库连接的函数：
- en: '[PRE92]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '`atexit.register` accepts a function to register, along with the values of
    any parameters we want to pass to the function. In the above code, the function
    we''re registering is a one-line lambda function: `lambda db: db.close_all()`.'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '`atexit.register` 接受一个要注册的函数，以及我们想要传递给该函数的任何参数的值。在上面的代码中，我们注册的函数是一个单行 lambda
    函数：`lambda db: db.close_all()`。'
- en: It accepts one parameter—`db`, which is the database instance. All the function
    does is to invoke `db`'s `close_all` method. The second parameter we pass to `atexit.register`
    is `database`, which is the `Database` instance created in the line above.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个参数——`db`，这是数据库实例。这个函数所做的只是调用 `db` 的 `close_all` 方法。我们传递给 `atexit.register`
    的第二个参数是 `database`，这是上面一行创建的 `Database` 实例。
- en: Calling `atexit.register` "schedules" a function to be executed when Python
    itself exits, which, in the case of `streamlit run`, happens when the Streamlit
    server shuts down.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `atexit.register` “安排”一个函数在 Python 本身退出时执行，在 `streamlit run` 的情况下，这发生在 Streamlit
    服务器关闭时。
- en: Why do we put the call to `atexit.register` within `get_database`? Why not put
    it somewhere else, perhaps at the end of the file? Well, like the creation of
    a `Database` object, we only want to perform the registration of the function
    with `atexit` *once* across all users—because there's only one Streamlit server.
    That means we have to call `atexit.register` within a function decorated with
    `st.cache_resource`, or this registration would happen multiple times.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们把 `atexit.register` 的调用放在 `get_database` 中？为什么不放在文件的其他地方，比如文件末尾？嗯，就像创建
    `Database` 对象一样，我们只想在整个用户中执行一次 `atexit` 函数的注册——因为只有一个 Streamlit 服务器。这意味着我们必须在带有
    `st.cache_resource` 装饰器的函数中调用 `atexit.register`，否则这个注册将会多次发生。
- en: To see this change in action, try restarting the app server with `streamlit
    run`, and then press `Ctrl+C` to exit it. You should see the message `Closing
    all connections...` which indicates that `close_all` has been called.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这一变化的效果，尝试使用 `streamlit run` 重新启动应用服务器，然后按 `Ctrl+C` 退出它。您应该会看到消息 `Closing
    all connections...`，这表明已经调用了 `close_all`。
- en: 8.7 Deploying Haiku Haven
  id: totrans-609
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7 部署 Haiku Haven
- en: 'Since we have Haiku Haven working locally, it''s time to productionize our
    app on Community Cloud. The process to do so is the same as what we''ve been following
    since Chapter 5, but there''s an additional wrinkle here: our app requires a running
    PostgreSQL server to host our database.'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Haiku Haven 在本地已经运行，现在是时候在 Community Cloud 上将我们的应用投入生产。这个过程与我们在第 5 章以来一直遵循的过程相同，但这里有一个额外的复杂因素：我们的应用需要一个正在运行的
    PostgreSQL 服务器来托管我们的数据库。
- en: 8.7.1 Setting up a managed PostgreSQL server in production
  id: totrans-611
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7.1 在生产中设置托管 PostgreSQL 服务器
- en: While we were developing locally, it was a simple matter to install PostgreSQL
    on the same machine, but Streamlit Community Cloud doesn't provide an option to
    do that. Instead, we need to set up an external PostgreSQL server somewhere.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们本地开发时，在相同机器上安装 PostgreSQL 是一件简单的事情，但 Streamlit Community Cloud 并不提供这样的选项。相反，我们需要在某个地方设置一个外部
    PostgreSQL 服务器。
- en: We'll use a cloud-based managed PostgreSQL service called Neon, which makes
    this process super-easy, and has a significant free quota. Create an account with
    Neon now at `https://neon.tech/`. The signup process is quite painless; you can
    choose to sign up with your GitHub or Google account if you like.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为 Neon 的基于云的托管 PostgreSQL 服务，这使得这个过程变得非常简单，并且有显著的免费配额。现在就使用 Neon 创建一个账户，网址为
    `https://neon.tech/`。注册过程相当简单；如果您愿意，可以选择使用 GitHub 或 Google 账户注册。
- en: You'll be asked for a project name and a database name. The project name can
    be whatever you like (`Haiku Haven`, maybe?), while the database name should be
    whatever you named your database in your local Postgres—`haikudb` if you've been
    following along faithfully.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被要求输入一个项目名称和一个数据库名称。项目名称可以是您喜欢的任何名称（例如 `Haiku Haven`？），而数据库名称应该是您在本地 Postgres
    中命名数据库的名称——如果您一直忠实地跟随，那么应该是 `haikudb`。
- en: You might also be asked to choose a cloud provider and location—these can be
    whatever you like, though I chose AWS as the provider.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还会被要求选择一个云提供商和位置——这些可以是您喜欢的任何内容，尽管我选择了 AWS 作为提供商。
- en: 'Once your account is set up, navigate to the Quick Start page to see a connection
    string that looks something like this:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的账户设置好，导航到快速入门页面，您会看到一个看起来像这样的连接字符串：
- en: '[PRE93]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This is the connection string we'll use in production. Neon has taken the liberty
    of setting up a username (`haikudb_owner`) and password for you. Store this string
    somewhere safe.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在生产中使用的连接字符串。Neon 已经为您设置了一个用户名（`haikudb_owner`）和密码。请将此字符串保存在安全的地方。
- en: Next, you'll need to set up the `users` and `haikus` tables once again in Neon.
    To do this, go to the SQL Editor tab. This is where you can enter SQL commands
    as though you were in the `psql` prompt. To create the tables, refer back to section
    8.2.4 and grab the `CREATE TABLE` commands we executed locally. You can execute
    these commands in Neon's SQL Editor without any changes.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要在 Neon 中再次设置 `users` 和 `haikus` 表。为此，转到 SQL 编辑器标签。这就是你可以像在 `psql` 提示符中一样输入
    SQL 命令的地方。要创建表，请参考第 8.2.4 节并获取我们本地执行的 `CREATE TABLE` 命令。你可以在 Neon 的 SQL 编辑器中执行这些命令，无需任何更改。
- en: 8.7.2 Deploying to Community Cloud
  id: totrans-620
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7.2 部署到社区云
- en: The rest of the deployment process should be straightforward, and is pretty
    much identical to what we did in Chapter 5.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 部署过程的其余部分应该很简单，基本上与我们在第 5 章中做的是一样的。
- en: Make sure to create a `requirements.txt` so that Community Cloud knows to install
    the third-party modules needed—primarily `psycopg2` and `bcrypt`.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 确保创建一个 `requirements.txt` 文件，这样社区云就会知道安装所需的第三方模块——主要是 `psycopg2` 和 `bcrypt`。
- en: For reference, listing 8.19 shows the requirements.txt that I used.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 为了参考，列表 8.19 显示了我使用的 requirements.txt。
- en: Listing 8.19 requirements.txt
  id: totrans-624
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.19 requirements.txt
- en: '[PRE94]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Notice that I used `psycopg2-binary` instead of `psycopg2`; that's because Community
    Cloud threw an error when I tried to use the latter but not with the former.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我使用了 `psycopg2-binary` 而不是 `psycopg2`；这是因为当我尝试使用后者时，社区云抛出了一个错误，但使用前者时没有。
- en: Once you've completed deployment, you'll need to copy the contents of `secrets.toml`
    and paste it in Community Cloud's Secrets setting (refer to Chapter 5 for a refresher),
    replacing the connection string with the one you copied from Neon.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 完成部署后，你需要复制 `secrets.toml` 的内容，并将其粘贴到社区云的秘密设置中（参考第 5 章以刷新记忆），用从 Neon 复制的连接字符串替换连接字符串。
- en: That's all, folks! Haiku Haven is now live! Tell all your friends they can unleash
    their seventeen-syllable creativity on your brand new web app!
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了，朋友们！Haiku Haven 现已上线！告诉你的所有朋友，他们可以在你全新的网络应用上释放他们十七音节的创造力！
- en: As for us, let's turn the page on CRUD and try our hand at building AI apps
    next.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 至于我们，让我们翻过 CRUD 一页，尝试构建 AI 应用程序。
- en: 8.8 Summary
  id: totrans-630
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.8 摘要
- en: CRUD stands for Create-Read-Update-Delete, the four fundamental operations that
    most apps perform.
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CRUD 代表创建-读取-更新-删除，这是大多数应用执行的四项基本操作。
- en: Relational databases like PostgreSQL organize data in tables with rows and columns
    according to a schema.
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系型数据库如 PostgreSQL 根据模式在表中组织数据，具有行和列。
- en: Designing the data model for an application involves identifying the entities,
    defining their relationships, listing their attributes, and converting these into
    a schema, often assisted by an Entity-Relationship (ER) diagram.
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计应用程序的数据模型涉及识别实体、定义它们之间的关系、列出它们的属性，并将这些转换为模式，通常在实体-关系（ER）图的辅助下完成。
- en: SQL (Structured Query Language) supports commands for creating tables (`CREATE
    TABLE`), inserting rows (`INSERT INTO`), reading data (`SELECT..FROM`), updating
    rows (`UPDATE..SET`), deleting rows (`DELETE FROM`) and dropping tables (`DROP
    TABLE`).
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL（结构化查询语言）支持创建表（`CREATE TABLE`）、插入行（`INSERT INTO`）、读取数据（`SELECT..FROM`）、更新行（`UPDATE..SET`）、删除行（`DELETE
    FROM`）和删除表（`DROP TABLE`）的命令。
- en: '`psycopg2` is a Python module used to connect to PostgreSQL using a shared
    connection pool.'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`psycopg2` 是一个用于通过共享连接池连接到 PostgreSQL 的 Python 模块。'
- en: Never store passwords in plain text; instead hash them using a library like
    `bcrypt` and store the hashed version. To authenticate, hash the given password
    and compare with the stored hash.
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要以纯文本形式存储密码；相反，使用像 `bcrypt` 这样的库对它们进行散列，并存储散列版本。为了进行身份验证，散列给定的密码并与存储的散列进行比较。
- en: '`st.Page` objects correspond to individual pages in multi-page apps in Streamlit.'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`st.Page` 对象对应于 Streamlit 中多页应用中的单个页面。'
- en: '`st.navigation` is used to create a navigation bar and specify the pages in
    an app.'
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`st.navigation` 用于创建导航栏并指定应用中的页面。'
- en: '`st.page_link` creates links between pages in a multi-page app.'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`st.page_link` 在多页应用中创建页面之间的链接。'
- en: '`st.cache_resource` is used to cache resources like database connections and
    share them between users.'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`st.cache_resource` 用于缓存资源，如数据库连接，并在用户之间共享。'
- en: Use `atexit.register` from the built-in `atexit` module to register a function
    to execute when a Streamlit server shuts down.
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置的 `atexit` 模块的 `atexit.register` 来注册一个在 Streamlit 服务器关闭时执行的函数。
- en: When deploying to production, you need to set up your database server separately,
    potentially using a managed service like Neon for PostgreSQL.
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当部署到生产环境时，你需要单独设置你的数据库服务器，可能使用 Neon 这样的托管服务来处理 PostgreSQL。
