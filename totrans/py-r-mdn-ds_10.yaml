- en: Chapter 6\. Using the Two Languages Synergistically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rick J. Scavetta
  prefs: []
  type: TYPE_NORMAL
- en: Interoperability, the ability for different programming languages to work together,
    is a cornerstone of computing. Ideally objects can be shared directly between
    the two languages. As you can imagine, this can be problematic for a variety of
    reasons, like memory usage and incompatible data storage structures to name just
    two. Although there have been several attempts to implement this smoothly between
    Python and R, it’s only been in the past couple of years that a reasonably functional
    kit had come to fruition. I’ll discuss this in [“Interoperability”](#interOp).
    But it’s useful to first return to the basics. This will not only give context
    to appreciate smooth interoperability later on, but you a basic solution may already
    meet your needs. Nonetheless, if you want to get started with interoperability,
    you can skip the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Faux-operability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic type of interoperability, which we’ll call cross-talk, is more
    of a faux-operability. Here, we execute pre-defined scripts across languages,
    passing information between them using files as intermediaries. Imagine the following
    situation, which I’ve diagramed in [Figure 6-1](#crosstalk).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/prds_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. An example of cross-talk to facilate interoperability.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In R, after performing some necessary work on an object, e.g. `PlantGrowth`,
    we execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `system()` function executes a system command, provided as a character argument.
    The command is made up of four parts.
  prefs: []
  type: TYPE_NORMAL
- en: First, `~/.venv/bin/python3` is the location of the Python executable within
    our virtual environment, assuming that you’ve created one. We could have also
    included this in the scripts *shebang* first line as `#!/.venv/bin/env python3`.
    This ensures that the script is executed in the environment in which it was created.
    See [“Virtual environments”](ch03.xhtml#pyvenv) if this sounds strange to you.
  prefs: []
  type: TYPE_NORMAL
- en: Second, `myScript_2.py` is the name of the Python file that contains the commands
    we want to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Third, `<` allow us to redirect `stdin` from the rhs to the file on the lhs^([1](ch06.xhtml#idm45127448988616)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Fourth, `"pg.csv"` is the `stdin`. You may recall that there are three standard
    *channels*, or *streams*, for command line functions. `stdin` for the *standard
    input*, `stdout` for the *standard output* and `stderr` for the `standard error`.
    Here, `stdin` is hardcoded. It’s a character string which corresponds to a file:
    `"pg.csv"`, which was exported in the previous command. Hard-coding should be
    avoided for the most part and we’re sure you can imagine many ways to make this
    dynamic. That’s not really our focus here; the point is to feed some input into
    a Python script.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we’re executing a Python script that takes `stdin` from within an R script,
    and that `stdin` in itself a product of the R script. Let’s take a look at the
    minimal components of this Python script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: First we need the `sys` module to handle `stdin` (`sys.stdin`). We import the
    file, represented by `sys.stdin` using pandas and after our Python script works
    it’s magic we export some other output using the `to_csv()` method.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of things wrong with this method, and we’ll get to them soon.
    But the point is that it works, and sometimes, it’s exactly what you need. Working
    in a research laboratory I often had to provide results to colleagues quickly.
    I mean this literally, since very expensive cell cultures would die and a week’s
    worth of work would be wasted if the results were not ready. Pre-processing of
    proprietary raw data and access to a secure server prohibited my colleagues from
    executing automated R scripts. My solution was to first process the machine-generated
    proprietary data with software specialized for the task. Then I was able to use
    a Mac OS Automator service to execute a Perl script on that output, which was
    now my `stdin`. This Perl script then called an R script that produced a file
    of a plot with all the relevant information clearly displayed in the title. It
    wasn’t the most open or elegant solution, but it worked and I got my plots with
    one mouse click in about half a second without any extra web-sites or logins.
    Life was good, so what’s the problem?
  prefs: []
  type: TYPE_NORMAL
- en: Well, there are several problems. Let’s consider three.
  prefs: []
  type: TYPE_NORMAL
- en: First, in retrospect, I could have probably executed the entire workflow in
    R (excluding the proprietary pre-processing). It’s necessary to consider simplifying
    a workflow and having a good reason to use multiple languages. Deciding when and
    why to combine Python & R has come up throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Second, there are a lot of moving parts. We have several files and we’re even
    producing additional intermediate ones. This increases the chance for error and
    confusion. That’s not terrible, but we better take care to keep things organized.
  prefs: []
  type: TYPE_NORMAL
- en: Third, in many cases, this workflow works well when we can export an R `data.frame`
    as a csv file, which `pandas` can easily import. For more complex data structures,
    you can export 1 or more R objects as an `RData` or `Rds` format file. The python
    `pyreadr` package provides functions to import these files and provide access
    to each object stored in a `dict`.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-talk is great, but true interoperability smooths out the wrinkles in this
    process quite nicely. There are two widely-used frameworks, the choice of which
    to use will depend on which language is your starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Interoperability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re primarily using R and want access to Python, then the R package `reticulate`
    is the way to go. Conversely, if you’re primarily using Python and want access
    to R, then the Python module `rpy2` is the tool for you. We can summarize this
    in [Table 6-1](#ret_table) and [Table 6-2](#rpy2_table)^([2](ch06.xhtml#idm45127448806536)).
    In each table, read each line as a sentence beginning with the column headers.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-1\. Interoperability granted by reticulate.
  prefs: []
  type: TYPE_NORMAL
- en: '| Access | Using command |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Python Functions | in R, `pd <- library(pandas)`; `pd$read_csv()` |'
  prefs: []
  type: TYPE_TB
- en: '| Python Objects | in R, `py$objName` |'
  prefs: []
  type: TYPE_TB
- en: '| R Objects | in Python, `r.objName` in Python |'
  prefs: []
  type: TYPE_TB
- en: Table 6-2\. Interoperability granted by rpy2 when writing in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '| Access | Using command |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| R Functions | in Python, `import rpy2.robjects.lib.ggplot2 as ggplot2` |'
  prefs: []
  type: TYPE_TB
- en: '| R Packages | in Python, `r_cluster = importr(''cluster'')` |'
  prefs: []
  type: TYPE_TB
- en: '| R Objects | in Python, `foo_py = robjects.r[''foo_r'']` |'
  prefs: []
  type: TYPE_TB
- en: The commands in [Table 6-1](#ret_table) and [Table 6-2](#rpy2_table) reveal
    how to access all variety of objects from one language directly from the other.
    In addition, we can also directly call functions. This is a real milestone since
    it relieves us of having to force one language to do tasks that it doesn’t excel
    at and means that we don’t need to reinvent the wheel, introducing redundancy
    between the languages. At the time of writing it was not possible to access R
    functions from within Python in `reticulate`. You may attempt to use `reticulate`
    for this task, but it would be easier to pass an object back to R and execute
    R commands natively.
  prefs: []
  type: TYPE_NORMAL
- en: Up and running with reticulate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`reticulate` first appeared on CRAN in 2017, and has recently gained in popularity
    as it matured. This package is developed by RStudio, and is well-integrated into
    the RStudio IDE itself, which is pretty convenient. However, at the time of writing,
    there are some troublesome features (bugs?) that require some finesse (see the
    warning box [“State of reticulate”](#state_reticulate)). A good first step is
    to ensure you are using the latest public release of RStudio and the latest version
    of the `reticulate` package and any associated packages, such as `knitr`.'
  prefs: []
  type: TYPE_NORMAL
- en: State of `reticulate`
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`reticulate` is well-supported and stable enough to be used in production.
    Nonetheless, you may encounter issues depending on your system, and software versions.
    Since this tool combines technologies, it can also be difficult to debug, and
    documentation is still somewhat scarce. Stay up-to-date with new versions as they
    are released. If you encounter issues on your local machine, call up our [RStudio
    Cloud](https://rstudio.cloud/project/2534578) project.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section we’ll begin with two scripts, listed in [Table 6-3](#ret_table_start).
    You’ll find these in this chapter’s folder in the book’s [repository](https://github.com/moderndatadesign/PyR4MDS).
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-3\. Up and running with reticulate.
  prefs: []
  type: TYPE_NORMAL
- en: '| File | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0 - Setup.Rmd` | Setting up reticulate and virtual environments |'
  prefs: []
  type: TYPE_TB
- en: '| `1 - Activate.R` | Activating a Python virtual environment |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s begin with the R script, `0 - Setup.R`. Make sure you’ve installed `reticulate`
    and have initialized it in your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to specify which build of Python we’ll use. You can let R use
    your system default, or set the specific build of Python you want to use by going
    to `tools > Project options` and selecting the Python icon.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/prds_0602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2\. Selecting a specific Python version and build to use.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s check to see the version we’re using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To be clear, we don’t need to use RStudio to set the Python version. This is
    just a convenience feature. We could have executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that this function just makes a *suggestion* and doesn’t result in an error
    if the desired build is not found unless the `required` argument is set to `TRUE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we proceed, we’ll want to establish a virtual environment. If you’re
    on Windows you’ll have to use a `conda` environment, which we’ll get to in a minute.
    For everyone else, use the following command to create a virtual environment called
    `modern_data`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, when we used the `venv` package in Python, the virtual environment
    was stored as a hidden directory (typically called `.venv` in the project directory).
    So where are the Python virtual environments now? We can have a look with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'They are all stored in a hidden folder in the *root* directory. We can see
    all our virtual environment using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The reticulate cheat sheet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As is the case for most popular data science packages, there is a cheat sheet
    available for `reticulate`. You can download it directly from [here](https://raw.githubusercontent.com/rstudio/cheatsheets/master/reticulate.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: This is a departure from what we saw with virtual environments in Python, where
    they were stored within the project directory. Nonetheless, it’s convenient, since
    we can easily reuse a good environment for many projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that to remove a virtual environment, we need to pass the path, as such:
    `virtualenv_remove("~/modern_data")`.'
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to install the appropriate packages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the tidyverse `purrr::map()` function to install
    many packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re on Windows, use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The final step is to activate our virtual environment. This seems to be an area
    under rapid development. Different error messages, or none at all are produced
    depending on your versions of `reticulate` and RStudio, making them harder to
    debug. From my experience, your safest bet is to (i) make sure all your R packages,
    as well as RStudio, are up to date, and (ii) restart R before activating your
    virtual environment. You can do this in the RStudio menu `Session > Restart R`,
    the keyboard shortcut `shift + cmd/ctrl + F10` or executing the command `.rs.restartR()`.
    You can also literally close and restart RStudio. This ensures that there is no
    Python build in active use and we can establish one from scratch. Thus, we have
    one R script for setup, where we create a virtual environment and install packages,
    and another with our actual analysis, where we load `reticulate` and activate
    our virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally we can confirm which build we have using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output. Importantly, make sure that the path to
    your virtual environment is stated in the first line: `/.virtualenvs/modern_data/bin/python`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you see something like `/usr/local/bin/python3.8` then RStudio is still directed
    to use the Python version you defined at the beginning of the chapter and not
    a virtual environment. This may serve you well, but it is preferable to use a
    virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: Going deeper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we’ve created a virtual environment, installed some packages
    in it, restarted R and have activated the virtual environment. These step are
    covered in the the scripts `0 - Setup.R` and `1 - Activate.R`. For the rest of
    this section I’ll cover ways to pass information between R and Python, which I’ve
    summarized in [Table 6-1](#ret_table).
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-4\. Interoperability granted by reticulate.
  prefs: []
  type: TYPE_NORMAL
- en: '| File | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `2 - Passing objects.Rmd` | Pass objects between R and Python in an RMarkdown
    document |'
  prefs: []
  type: TYPE_TB
- en: '| `3 - Using functions.Rmd` | Call Python in an RMarkdown document |'
  prefs: []
  type: TYPE_TB
- en: '| `4 - Calling scripts.Rmd` | Call Python by sourcing a Python script |'
  prefs: []
  type: TYPE_TB
- en: '| `5 - Interactive mode.R` | Call Python using a Python REPL console |'
  prefs: []
  type: TYPE_TB
- en: '| `6 - Interactive document.Rmd` | Call Python with dynamic input in an interactive
    document |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Why “reticulate”? The reticulated python is a species of python found in Southeast
    Asia. They are the world’s longest snakes and longest reptiles. The species name,
    *Malayopython reticulatus*, is Latin meaning “net-like”, or reticulated, and is
    a reference to the complex colour pattern.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll consider the scenarios in [Table 6-1](#ret_table) in the subsections below.
    To follow along with these examples, please ensure that you have followed the
    setup and activation instructions found in `0 - Setup.R` and `1 - Activate.R`
    (both in the book code [repository](https://github.com/moderndatadesign/PyR4MDS)).
    You’ll need to have the modern_data virtual environment and the above list of
    packages installed. If you’re using `miniconda`, be sure to use the correct command
    given in each file to activate your virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: Pass objects between R and Python in an RMarkdown document
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following commands can be found in the file `2 - Passing objects.Rmd`.
    To access an R object in python use the `r` object, and to access a Python in
    R, use the `py` object. Consider the following chunks found in an RMarkdown document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]{python}'
  prefs: []
  type: TYPE_NORMAL
- en: a = 3.14
  prefs: []
  type: TYPE_NORMAL
- en: a
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]{r}'
  prefs: []
  type: TYPE_NORMAL
- en: py$a
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The python object `a` is accessed in the R object `py` using the `$` notation.
    In the opposite direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]{r}'
  prefs: []
  type: TYPE_NORMAL
- en: b <- 42
  prefs: []
  type: TYPE_NORMAL
- en: b
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]{python}'
  prefs: []
  type: TYPE_NORMAL
- en: r.b
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python, call the `r` object and use `.` notation to access R objects by
    name. These are scalars, or simple vectors, but of course we can pass more complex
    items directly between the two languages. `reticulate` will take care of object
    conversion for us. Consider the following case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]{r}'
  prefs: []
  type: TYPE_NORMAL
- en: A build-in data frame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: head(PlantGrowth)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]{python}'
  prefs: []
  type: TYPE_NORMAL
- en: r.PlantGrowth.head()
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: An R `data.frame` is accessed as a Python `pandas.DataFrame`. However, if you
    don’t have pandas installed you’ll see a `dict` object, a Python dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Python `NumPy` `ndarray` will be converted to an R `matrix`^([3](ch06.xhtml#idm45127448026744)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]{python eval = TRUE}'
  prefs: []
  type: TYPE_NORMAL
- en: from sklearn.datasets import load_iris
  prefs: []
  type: TYPE_NORMAL
- en: iris = load_iris()
  prefs: []
  type: TYPE_NORMAL
- en: iris.data[:6]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A Python NumPy `ndarray` as an R `matrix`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]{r eval = TRUE}'
  prefs: []
  type: TYPE_NORMAL
- en: head(py$iris$data)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the `.` notation in Python, `iris.data` is automatically accessible
    using the `$` notation in R: `py$iris$data`. This holds true for nested objects,
    methods and attributes, just as they would in Python,'
  prefs: []
  type: TYPE_NORMAL
- en: Call Python in an RMarkdown document
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following commands can be found in the file `3 - Using functions.Rmd`. We’ll
    continue to use the classic iris dataset that we accessed in Python in the previous
    section. Inside an RMarkdown document, we’ll access a Python function, which allows
    us to access the trained support vector machine classifier to predict classification
    on new values. This is a very naïve machine learning workflow and is not intended
    to produce a valuable model. The point is to demonstrate how to access a model
    from Python in R.
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire model configuration is defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]{python}'
  prefs: []
  type: TYPE_NORMAL
- en: import modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from sklearn import datasets
  prefs: []
  type: TYPE_NORMAL
- en: from sklearn.svm import SVC
  prefs: []
  type: TYPE_NORMAL
- en: 'load the data:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: iris = datasets.load_iris()
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of the SVC, _Support Vector Classification_, class.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: clf = SVC()
  prefs: []
  type: TYPE_NORMAL
- en: Train the model by calling the fit method on the target data, using target names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: clf.fit(iris.data, iris.target_names[iris.target])
  prefs: []
  type: TYPE_NORMAL
- en: Predict the class of new values, here the first three
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: clf.predict(iris.data[:3])
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The method `clf.predict()` takes an `ndarray` as input and returns the named
    classification. To access this function in R, we can once again use the `py` object,
    as in `py$clf$predict()`. The `iris` dataset in R is a `data.frame`, where the
    5th column is the classification. We must convert this to a Python object using
    `r_to_py()`, in this case excluding the 5th column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]{r}'
  prefs: []
  type: TYPE_NORMAL
- en: py$clf$predict(r_to_py(iris[-5]))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Call Python by sourcing a Python script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following commands can be found in the file `4 - Calling scripts.Rmd` and
    `4b - Calling scripts.R`. In this scenario we’ll execute an entire Python script
    and access all object and functions available therein. To do this we can call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This works just as well in an RMarkdown document as in a script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this appears very similar to the previous section, there is a very
    important distinction. Python environments activated in this manner provide functions
    and objects directly. Thus we can call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is convenient, but also disconcerting. Not only has the syntax changes,
    i.e. no need for `py$`, but objects loaded in the R environment may conflict.
    Python objects will mask R objects, so be very careful about naming conflicts!
    You’ll notice that in `SVC_iris.py` we’ve renamed the Python `iris` dataset to
    `iris_py` to avoid problems when calling `iris` in R.
  prefs: []
  type: TYPE_NORMAL
- en: Call Python using the REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following commands can be found in the file `5 - Interactive mode.R`. In
    this scenario we’ll start up a Python REPL console, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: REPL stands for Read-eval-print loop. It is a common feature in many languages
    where the user can experiment in an interactive way, as opposed to writing a script
    that needs to be run.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will allow you to directly execute Python commands in an interpreter.
    For example, try executing the commands we saw in the last example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We can exit the interpreter by executing the Python `exit` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Just like we’ve seen before, the functions and objects in this Python environment
    can be accessed in R. This is truly interactive programming, since we’re executing
    commands directly in the console. Although we present this scenario for the sake
    of completeness, `repl_python()` is not really meant to be used in everyday practice.
    Actually, it’s what is called when an RMarkdown chunk uses a Python kernel. So
    although you can do this, be cautious! This presents a considerable problem in
    reproducibility and automation, but you may find it useful for quickly checking
    some commands.
  prefs: []
  type: TYPE_NORMAL
- en: Call Python with dynamic input in an interactive document
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following commands can be found in the file `6 - Interactive document.Rmd`.
  prefs: []
  type: TYPE_NORMAL
- en: By now we’ve see all the core functionality of reticulate. Here we’ll go beyond
    that and show a very simple way to introduce interactivity using a `shiny` runtime
    in an RMarkdown document. To see the interactivity, make sure you have the `shiny`
    package installed and the you render the document to HTML. In RStudio, you can
    do this by clicking on the “Run Document” button when the file is open.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in the header of our document we need to specify this new runtime environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following Python code, which we’ve seen above, is executed in a Python
    chunk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]{python}'
  prefs: []
  type: TYPE_NORMAL
- en: from sklearn import datasets
  prefs: []
  type: TYPE_NORMAL
- en: from sklearn.svm import SVC
  prefs: []
  type: TYPE_NORMAL
- en: iris = datasets.load_iris()
  prefs: []
  type: TYPE_NORMAL
- en: clf = SVC()
  prefs: []
  type: TYPE_NORMAL
- en: clf.fit(iris.data, iris.target_names[iris.target])
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the final two chunks we use functions from the `shiny` package to (i) produce
    sliders for each of the four features, and (ii) render the output from `py$clf$predict()`
    as HTML text, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: and… n
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we call the R object `prediction` as an in-line command, `r prediction`
    to print the result to the screen as a sentence.
  prefs: []
  type: TYPE_NORMAL
- en: Final thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we’ve covered the core components of the `reticulate` package,
    progressing from the essential setup to the basics and finally a simple yet powerful
    implementation that showcases the strengths R, Python and `reticulate`. Using
    this knowledge we’ll continue onto a larger case study in the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch06.xhtml#idm45127448988616-marker)) Recall that rhs is the *right-hand
    side* and lhs is the *left-hand side* when calling operators, in this case `<`
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch06.xhtml#idm45127448806536-marker)) In these tables we make a distinction
    between functions and objects. Recall that functions are themselves just objects,
    but we don’t need to worry about these details at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch06.xhtml#idm45127448026744-marker)) Refer the Appendix A for a summary
    of data structures.
  prefs: []
  type: TYPE_NORMAL
