<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>chapter-6</title>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
 </head>
 <body>
  <div class="readable-text " id="p1"> 
   <h1 class=" readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">6</span></span> A dashboard fit for a CEO</h1>
  </div>
  <div class="introduction-summary"> 
   <h3>This chapter covers</h3>
   <ul> 
    <li class="readable-text" id="p2">Building an interactive metrics dashboard</li>
    <li class="readable-text" id="p3">Wrangling data using the Pandas library</li>
    <li class="readable-text" id="p4">Caching the results of functions to improve Streamlit app performance</li>
    <li class="readable-text" id="p5">Creating filters, panels and other widgets in a dashboard</li>
    <li class="readable-text" id="p6">Developing data visualizations and charts using Plotly</li>
   </ul>
  </div>
  <div class="readable-text " id="p7"> 
   <p>Ever wondered how executives at large companies are able to stay on top of the business they run? Imagine the complexity and the sheer <em>number</em> of products and services offered by a company like Amazon, 3M, or Google. How can one person make sense of it all? How do they know if their business is meeting expectations and what areas need their focus?</p>
  </div>
  <div class="readable-text  intended-text" id="p8"> 
   <p>In well-run companies, the answer—or part of it—is metrics. Executives rely on a carefully curated set of metrics, or numbers that give them a high-level overview of the company’s performance. Metrics help leaders make informed decisions, identify potential issues before they become major problems, and pinpoint areas where the company can improve or innovate.</p>
  </div>
  <div class="readable-text  intended-text" id="p9"> 
   <p>But metrics alone are not enough—they need to be presented in a clear, digestible way. That's where dashboards come into play. A good dashboard allows users to explore various cuts of data, transforming raw data into a story, highlighting what's important and helping leaders stay focused on the bigger picture.</p>
  </div>
  <div class="readable-text  intended-text" id="p10"> 
   <p>In this chapter, we'll develop such a dashboard designed for a CEO to monitor key performance indicators (KPIs) for their business. By its end, you'll not only know how to build a robust, interactive metrics dashboard using Streamlit, but also understand how to present data in a way that empowers decision-makers to focus on what truly matters.</p>
  </div>
  <div class="readable-text" id="p11"> 
   <h2 class=" readable-text-h2">6.1 A metrics dashboard</h2>
  </div>
  <div class="readable-text " id="p12"> 
   <p>Change is afoot at Note n' Nib Inc., everyone's favorite fictional online shopping site for stationery! The founder-CEO has retired to enjoy his millions in Ibiza, and his successor, a data-obsessed bigwig from Silicon Valley, has big plans for the company.</p>
  </div>
  <div class="readable-text  intended-text" id="p13"> 
   <p>His enthusiasm is punctured a little when, in his first staff meeting, he asks the VP of Sales where he can look up the latest sales numbers and the VP fishes into his suitcase and retrieves a <em>paper</em> report from two months ago.</p>
  </div>
  <div class="readable-text  intended-text" id="p14"> 
   <p>"Don't we have a dashboard where we keep track of daily sales data?", the CEO asks, dreading the answer. His fears are confirmed when the VP mutters something about the <em>old</em> CEO having possessed a marvelous <em>intuition</em> that he frequently relied upon to make decisions—and pen-and-paper being the core of the business after all.</p>
  </div>
  <div class="readable-text  intended-text" id="p15"> 
   <p>An hour later, the VP of Sales summons you, a rising star in the department (and his go-to for stuff he doesn't want to deal with himself) and tasks you with building "one of those fancy metrics pages with line charts" for his boss.</p>
  </div>
  <div class="readable-text  intended-text" id="p16"> 
   <p>You know Engineering is busy with a major overhaul of the website, so you don't want to drop this on their plate. Luckily, you've been experimenting with this cool new Python framework called Streamlit and you're raring to use it at work.</p>
  </div>
  <div class="readable-text" id="p17"> 
   <h3 class=" readable-text-h3">6.1.1 Stating the concept</h3>
  </div>
  <div class="readable-text " id="p18"> 
   <p>The VP didn't give you a lot to work with, but you've been around long enough to have a pretty good idea of what the boss wants. As always, let's start by spelling this out:</p>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p19"> 
    <h5 class=" callout-container-h5 readable-text-h5">Concept</h5>
   </div>
   <div class="readable-text" id="p20"> 
    <p>A dashboard that lets executives view various cuts of sales data and track key metrics to make decisions.</p>
   </div>
  </div>
  <div class="readable-text" id="p21"> 
   <h3 class=" readable-text-h3">6.1.2 Defining the requirements</h3>
  </div>
  <div class="readable-text " id="p22"> 
   <p>We have our work cut out for us to translate the concept into concrete requirements. Specifically, the phrases "sales data", "various cuts", and "key metrics" need to be expanded upon.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p23"> 
   <h4 class=" readable-text-h4">Exploring the data</h4>
  </div>
  <div class="readable-text " id="p24"> 
   <p>You've managed to get Engineering to export key data fields from their systems that you think will be relevant to your project into a Comma-Separated Values (CSV) file. You can download this file from the GitHub repo for this book (the file is called <kbd>sales_data.csv</kbd> and is in the <kbd>chapter_6</kbd> directory).</p>
  </div>
  <div class="readable-text  intended-text" id="p25"> 
   <p>Once you've downloaded it, open it up in a spreadsheet program like Microsoft Excel or Numbers on macOS, and inspect the first few lines (shown in Figure 6.1)</p>
  </div>
  <div class="browsable-container figure-container" id="p26">  
   <img src="../Images/06__image001.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 6.1 The first two rows of the CSV data we'll work with</h5>
  </div>
  <div class="readable-text " id="p27"> 
   <p>The data represents the sales of various products sold by Note n' Nib, broken out by various <em>dimensions </em>such as segment and category. It also has demographic information about the kind of people who bought these products—specifically their gender and age group, as well as the state they hailed from. The file has data from January 2019 to August 2024, and contains <em>measures </em>such as sales (how much revenue did Note n' Nib make), gross margin (how much of the sales was profit, accounting for the cost), and the number of transactions covered by each row.</p>
  </div>
  <div class="readable-text  intended-text" id="p28"> 
   <p>For instance, here's how we would interpret the first row: On Jan 1 2019, men aged 18-25 from California buying Inkstream fountain pens (classified as "writing tools") made 8 transactions on the Note n' Nib website, bringing in $134.91 in sales to the company, of which $83.91 remained after subtracting costs.</p>
  </div>
  <div class="readable-text  intended-text" id="p29"> 
   <p>The <em>primary key</em> (the set of columns that uniquely identify a row) here is the combination of <kbd>date</kbd>, <kbd>product_name</kbd>, <kbd>segment</kbd>, <kbd>category</kbd>, <kbd>gender</kbd>, <kbd>age_group</kbd>, and <kbd>state</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p30"> 
   <p>After speaking to the CEO, you also determine that he cares primarily about the following numbers: <strong>total sales</strong>, <strong>gross margin</strong>, <strong>margin percentage</strong>, and <strong>average transaction value</strong>. We'll dive into these and how they're calculated later in the chapter, but these are the "key metrics" from our stated concept.</p>
  </div>
  <div class="readable-text  intended-text" id="p31"> 
   <p>The CEO wants to be able to see how these numbers differ across different <strong>products</strong>, <strong>categories</strong>, <strong>age groups</strong>, <strong>genders</strong>, and <strong>states</strong>—the "various cuts" from the concept—as well as across time.</p>
  </div>
  <div class="readable-text  intended-text" id="p32"> 
   <p>You also do some thinking about <em>how </em>the data should be represented, and finally come up with an initial set of requirements.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p33"> 
   <h4 class=" readable-text-h4">Requirements</h4>
  </div>
  <div class="readable-text " id="p34"> 
   <p>The user should be able to:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p35">view in aggregate the total sales, gross margin, margin percentage, and average transaction value of products sold on Note n' Nib</li>
   <li class="readable-text" id="p36">view how these numbers differ across different years, products, categories, age groups, genders, and states</li>
   <li class="readable-text" id="p37">filter data by these dimensions to explore cross-sections of the data</li>
   <li class="readable-text" id="p38">visualize the trends and breakdowns of the metrics over time, broken down by each dimension</li>
  </ul>
  <div class="readable-text " id="p39"> 
   <p>You want to deliver an initial version of the dashboard quickly without getting bogged down in additional feature requests, so you clearly define what's out of scope too.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p40"> 
   <h4 class=" readable-text-h4">What's out of scope</h4>
  </div>
  <div class="readable-text " id="p41"> 
   <p>At first launch, the dashboard will <em>not</em> support:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p42">Drilling down into the data to view specific rows</li>
   <li class="readable-text" id="p43">Forecasting future values of any metrics</li>
   <li class="readable-text" id="p44">Providing explanations about why a metric has changed over time</li>
  </ul>
  <div class="readable-text " id="p45"> 
   <p>Some of these can be future expansions to the dashboard, but for now we'll try and limit its functionality to <em>observing</em> data as opposed to actively <em>analyzing</em> or <em>predicting</em> it.</p>
  </div>
  <div class="readable-text" id="p46"> 
   <h3 class=" readable-text-h3">6.1.3 Visualizing the user experience</h3>
  </div>
  <div class="readable-text " id="p47"> 
   <p>The next step in the app development flow we explored in Chapter 3 is to visualize the user experience. From the requirements, it's evident that the four key metrics are of vital importance, so we should display them prominently, ideally in such a way that the user's eye is immediately drawn towards them. The requirements also mention filtering the data based on the dimensions and cuts we discussed. It seems reasonable to include a panel where users can do this.</p>
  </div>
  <div class="readable-text  intended-text" id="p48"> 
   <p>A picture speaks a thousand words, so we want to provide clear visualizations of the data; the trends and breakdowns indicated in the requirements could be realized through <em>time series charts, </em>which show the progression of a number over time, and <em>pie charts</em>, which tell you how a whole quantity breaks down into its components.</p>
  </div>
  <div class="readable-text  intended-text" id="p49"> 
   <p>Figure 6.2 shows a mock interface designed based on the above.</p>
  </div>
  <div class="browsable-container figure-container" id="p50">  
   <img src="../Images/06__image002.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 6.2 A UI mock for the dashboard</h5>
  </div>
  <div class="readable-text " id="p51"> 
   <p>As you can see, this design incorporates everything we discussed: the four key metrics are shown in a large unmissable font, and their values correspond to a slice of the data that is controlled by the filters at the top and a date range selector on the left.</p>
  </div>
  <div class="readable-text  intended-text" id="p52"> 
   <p>There's a line chart that shows how any selected metric has changed over time, and a pie chart that breaks down the total sales or gross margin by a selected dimension, like the product category.</p>
  </div>
  <div class="readable-text" id="p53"> 
   <h3 class=" readable-text-h3">6.1.4 Brainstorming the implementation</h3>
  </div>
  <div class="readable-text " id="p54"> 
   <p>Before we get started with actually writing code, let's map out the flow of logic and data in our dashboard at a high level. Figure 6.3 shows one way we might choose to structure this.</p>
  </div>
  <div class="browsable-container figure-container" id="p55">  
   <img src="../Images/06__image003.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 6.3 Flow of logic and data in the dashboard</h5>
  </div>
  <div class="readable-text " id="p56"> 
   <p>The first step is to read the raw data from our CSV file and to load it into memory. There may be some basic data "preparation" or "cleaning" we want to perform next, such as renaming columns for convenience.</p>
  </div>
  <div class="readable-text  intended-text" id="p57"> 
   <p>In our mock UI in figure 6.2, the filter bar at the top and the date range selectors to the side are meant to be <em>global</em>, i.e. they affect all of the widgets in the dashboard. So it stands to reason that we should apply the filters and select just the range we need before we pass the data around to the other parts of the dashboard.</p>
  </div>
  <div class="readable-text  intended-text" id="p58"> 
   <p>There are three sections in the dashboard where we'll display data in some form: the metric bar with the overall metric values, the change-over-time line chart, and the pie chart. To obtain the content to show in each of these, we need to apply <em>transformations</em> to the filtered data, meaning we'll need to group, aggregate and otherwise <em>transform</em> it.</p>
  </div>
  <div class="readable-text  intended-text" id="p59"> 
   <p>The line and pie charts have additional options (you need to choose a metric to display in both charts, and a breakdown dimension—like the product category or gender—in the pie chart), which will serve as inputs to the transformations we'll apply.</p>
  </div>
  <div class="readable-text  intended-text" id="p60"> 
   <p>This hopefully gave you an overview of the design we'll be implementing in the rest of the chapter. Don't worry if some of these parts aren't quite clear to you yet; we're about to explore each part in a lot more detail.</p>
  </div>
  <div class="readable-text" id="p61"> 
   <h2 class=" readable-text-h2">6.2 Loading the data</h2>
  </div>
  <div class="readable-text " id="p62"> 
   <p>In any application that presents or visualizes data, the first step involves obtaining data from some source. Sometimes this source is simply information entered by the user, but often it's an external source such as a database or a file. We'll talk about connecting to databases in later chapters, but for now we'll use the CSV file we reviewed earlier.</p>
  </div>
  <div class="readable-text  intended-text" id="p63"> 
   <p>In this section, we'll walk through how to load data into your app from an external file, keep it in memory, and display it in Streamlit. Along the way, we'll introduce Pandas, the quintessential Python library for data manipulation. We'll also discuss how to improve your app's performance through caching when the data you need to load is very large.</p>
  </div>
  <div class="readable-text" id="p64"> 
   <h3 class=" readable-text-h3">6.2.1 The Pandas library</h3>
  </div>
  <div class="readable-text " id="p65"> 
   <p>I mentioned Pandas in passing in Chapter 1, describing it as a popular library for working with tabular data. In truth, Pandas has become such an integral part of the data ecosystem that it’s hard to imagine working with data in Python without it (or something like it at any rate).</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p66"> 
   <h4 class=" readable-text-h4">Installing Pandas</h4>
  </div>
  <div class="readable-text " id="p67"> 
   <p>You can install Pandas the same way you would install any other Python library: using<kbd> pip</kbd>. Type the following to set it up now:</p>
  </div>
  <div class="browsable-container listing-container" id="p68"> 
   <div class="code-area-container"> 
    <pre class="code-area">pip install pandas</pre>
   </div>
  </div>
  <div class="readable-text " id="p69"> 
   <p>Once that finishes running, verify that everything's set up right by running <kbd>pip show pandas</kbd>, which should display some information about the library.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p70"> 
   <h4 class=" readable-text-h4">Exploring our sales data in Pandas</h4>
  </div>
  <div class="readable-text " id="p71"> 
   <p>Pandas revolves around the concept of the dataframe, which is a two-dimensional, tabular data structure similar to a table in a spreadsheet. It consists of rows and columns, where each column holds data of a specific type (eg. integer, float, string). Dataframes allow for efficient data manipulation and analysis, making them a versatile tool for handling structured data.</p>
  </div>
  <div class="readable-text  intended-text" id="p72"> 
   <p>To see dataframes in action, let's load our sales data CSV into a Pandas dataframe.</p>
  </div>
  <div class="readable-text  intended-text" id="p73"> 
   <p>Navigate to the local directory where you downloaded <kbd>sales_data.csv</kbd>, open a Python shell and type the following commands:</p>
  </div>
  <div class="browsable-container listing-container" id="p74"> 
   <div class="code-area-container"> 
    <pre class="code-area">&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; df = pd.read_csv('sales_data.csv')
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p75"> 
   <p>The <kbd>import pandas as pd</kbd> is a regular Python import statement. It's conventional to refer to the Pandas module as <kbd>pd</kbd> (just as we use <kbd>st</kbd> for Streamlit).</p>
  </div>
  <div class="browsable-container listing-container" id="p76"> 
   <div class="code-area-container"> 
    <pre class="code-area">&gt;&gt;&gt; df = pd.read_csv('sales_data.csv')</pre>
   </div>
  </div>
  <div class="readable-text " id="p77"> 
   <p>This is where we actually load the CSV file. Pandas makes this incredibly easy using the <kbd>read_csv</kbd> method. <kbd>read_csv</kbd> actually has a ton of parameters you can pass it (such as whether the file contains a header, what column names and types to use, and so on), but since all of these have sensible default values, you can also just pass it the path to the file and nothing else.</p>
  </div>
  <div class="readable-text  intended-text" id="p78"> 
   <p>At the end of this, we have a variable <kbd>df</kbd> that holds a Pandas dataframe.</p>
  </div>
  <div class="readable-text  intended-text" id="p79"> 
   <p>Let's verify this using Python's built-in <kbd>type</kbd> function, which returns the type of the object that a particular variable holds:</p>
  </div>
  <div class="browsable-container listing-container" id="p80"> 
   <div class="code-area-container"> 
    <pre class="code-area">&gt;&gt;&gt; type(df)
&lt;class 'pandas.core.frame.DataFrame'&gt;</pre>
   </div>
  </div>
  <div class="readable-text " id="p81"> 
   <p>We can also get more information about the dataframe using its <kbd>info()</kbd> method:</p>
  </div>
  <div class="browsable-container listing-container" id="p82"> 
   <div class="code-area-container"> 
    <pre class="code-area">&gt;&gt;&gt; df.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 1035000 entries, 0 to 1034999
Data columns (total 10 columns):
 #   Column        Non-Null Count    Dtype
---  ------        --------------    -----
 0   date          1035000 non-null  object
 1   product_name  1035000 non-null  object
 2   segment       1035000 non-null  object
 3   category      1035000 non-null  object
 4   gender        1035000 non-null  object
 5   age_group     1035000 non-null  object
 6   state         1035000 non-null  object
 7   sales         1035000 non-null  float64
 8   gross_margin  1035000 non-null  float64
 9   transactions  1035000 non-null  float64
dtypes: float64(3), object(7)
memory usage: 79.0+ MB
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p83"> 
   <p>This tells us a variety of things. The dataframe has more than a million rows, numbered from 0 to 1034999. It has ten columns, with the first seven being of the<kbd> object</kbd> type (strings, essentially) and the last three being <kbd>float64s</kbd> (or floating-point numbers).</p>
  </div>
  <div class="callout-container sidebar-container"> 
   <div class="readable-text" id="p84"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p85"> 
    <p>These names may be confusing to you since they're not the regular Python types (str, float, etc.) that you're likely used to. This is because Pandas uses its own data types (or dtypes), derived from a related Python library called <kbd>numpy</kbd>, for efficient computations.</p>
   </div>
   <div class="readable-text" id="p86"> 
    <p>You also have the option of having Pandas use the Apache Arrow format, which can be more performant for large datasets. To do so, while reading the CSV, add a <kbd>dtype_backend</kbd> parameter like so:</p>
   </div>
   <div class="browsable-container listing-container" id="p87"> 
    <div class="code-area-container"> 
     <pre class="code-area">pd.read_csv('sales_data.csv', dtype_backend='pyarrow')</pre>
    </div>
   </div>
   <div class="readable-text" id="p88"> 
    <p>If you do this, you'll notice that the data types shown by .info() are <kbd>string[pyarrow]</kbd> and <kbd>double[pyarrow]</kbd> rather than <kbd>object</kbd> and <kbd>float64</kbd>.</p>
   </div>
  </div>
  <div class="readable-text " id="p89"> 
   <p>Let's look at some of the content in the dataframe next. Since we don't have enough space on this page to print all the columns, we first select a subset of them:</p>
  </div>
  <div class="browsable-container listing-container" id="p90"> 
   <div class="code-area-container"> 
    <pre class="code-area">&gt;&gt;&gt; only_some_cols = df[['date', 'product_name', 'segment', 'state']]</pre>
   </div>
  </div>
  <div class="readable-text " id="p91"> 
   <p>You can create a new Pandas dataframe by performing some operation on another dataframe. That's essentially what happened here. When we pass a list of columns to a dataframe using Pandas' user-friendly square-bracket notation (<kbd>df[&lt;list of column names&gt;]</kbd>), we get a new dataframe containing only the columns we passed, which we can then assign to another variable (<kbd>only_some_cols</kbd> in this case).</p>
  </div>
  <div class="readable-text  intended-text" id="p92"> 
   <p>Finally, to see the first few rows, we use the<kbd> .head()</kbd> method on our smaller dataframe, which shows us the values in the first five rows.</p>
  </div>
  <div class="browsable-container listing-container" id="p93"> 
   <div class="code-area-container"> 
    <pre class="code-area">&gt;&gt;&gt; only_some_cols.head()
         date product_name        segment state
0  2019-01-01    InkStream  Fountain pens    CA
1  2019-01-01    InkStream  Fountain pens    TX
2  2019-01-01    InkStream  Fountain pens    FL
3  2019-01-01    InkStream  Fountain pens    UT
4  2019-01-01    InkStream  Fountain pens    RI</pre>
   </div>
  </div>
  <div class="readable-text " id="p94"> 
   <p>We'll learn more Pandas as we go along, so let's stop here for now and get back to building our dashboard.</p>
  </div>
  <div class="readable-text" id="p95"> 
   <h3 class=" readable-text-h3">6.2.2 Reading and displaying a dataframe</h3>
  </div>
  <div class="readable-text " id="p96"> 
   <p>Our dashboard app is going to involve a lot more code than some of the previous apps we've written, so it would be a good idea to spread it across multiple modules or <kbd>.py</kbd> files.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p97"> 
   <h4 class=" readable-text-h4">Loading data from the right file path</h4>
  </div>
  <div class="readable-text " id="p98"> 
   <p>We'll start with a dedicated Python script file to read in the data from our CSV. Copy <kbd>sales_data.csv</kbd> to the folder where you intend to keep your code files, and then create <kbd>data_loader.py</kbd> with the content shown in listing 6.1.</p>
  </div>
  <div class="browsable-container listing-container" id="p99"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 6.1 data_loader.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import pandas as pd
from pathlib import Path
 
BASE_DIR = Path(__file__).resolve().parent
SALES_DATA_PATH = BASE_DIR / "sales_data.csv"
 
def load_data():
  return pd.read_csv(SALES_DATA_PATH)
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p100"> 
   <p>The <kbd>load_data</kbd> function simply uses Pandas to read in the CSV as we saw in the last section, but there seems to be more going on here. How are we populating the <kbd>SALES_DATA_PATH</kbd> variable? Why couldn't we just set it to <kbd>"sales_data.csv"</kbd> directly, given that <kbd>data_loader.py</kbd> is in the same directory as <kbd>sales_data.csv</kbd>?</p>
  </div>
  <div class="readable-text  intended-text" id="p101"> 
   <p>The trouble here is that file paths in Python are considered to be relative to the <em>working directory you're executing a script from</em>, not the directory that the file containing the line currently being executed is located in.</p>
  </div>
  <div class="readable-text  intended-text" id="p102"> 
   <p>For instance, if you're currently in <kbd>'/Users/alice/'</kbd>, your<kbd> .py</kbd> file and CSV are in the folder <kbd>'/Users/alice/streamlit_project/'</kbd> and you write<kbd> pd.read_csv('sales_data.csv')</kbd>, Python will look for the path <kbd>'/Users/alice/sales_data.csv'</kbd>, which doesn't exist.</p>
  </div>
  <div class="readable-text  intended-text" id="p103"> 
   <p>You could hardcode the absolute path to the CSV and pass <kbd>'/Users/alice/streamlit_project/sales_data.csv'</kbd>, but that will obviously create issues when your app is deployed on a different computer where it won't be in that exact path.</p>
  </div>
  <div class="readable-text  intended-text" id="p104"> 
   <p>No, what we need is a way to refer to the current <kbd>.py</kbd> file and construct a path relative to that file's path.</p>
  </div>
  <div class="readable-text  intended-text" id="p105"> 
   <p>This is what the two lines near the top do:</p>
  </div>
  <div class="browsable-container listing-container" id="p106"> 
   <div class="code-area-container"> 
    <pre class="code-area">BASE_DIR = Path(__file__).resolve().parent
SALES_DATA_PATH = BASE_DIR / "sales_data.csv"</pre>
   </div>
  </div>
  <div class="readable-text " id="p107"> 
   <p><kbd>__file__</kbd> is a special variable in Python that contains the path of the file currently being executed.</p>
  </div>
  <div class="readable-text  intended-text" id="p108"> 
   <p><kbd>Path</kbd> is a class from the <kbd>pathlib</kbd> module (which comes built-in with Python) that lets you work with file paths in a user-friendly, object-oriented way. <kbd>Path(__file__)</kbd> creates a Path object corresponding to the current Python script, <kbd>data_loader.py</kbd>, and <kbd>.resolve()</kbd> dynamically generates the absolute path to <kbd>data_loader.py</kbd> (regardless of whether it's in your local machine or a production deployment). The<kbd> .parent</kbd> then refers to the directory <kbd>data_loader.py</kbd> is in.</p>
  </div>
  <div class="readable-text  intended-text" id="p109"> 
   <p>Finally, we use the <kbd>'/'</kbd> operator which works with <kbd>Path</kbd> objects (and is <em>not</em> the mathematical divided-by operator in this context) to generate the final path to our CSV, stored in <kbd>SALES_DATA_PATH</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p110"> 
   <p>It's worth noting that <kbd>SALES_DATA_PATH</kbd> is not a string, it's still a <kbd>Path</kbd> object. Fortunately, Pandas' <kbd>read_csv</kbd> knows how to handle those, so we can pass it directly to that function.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p111"> 
   <h4 class=" readable-text-h4">Using st.write to display the dataframe</h4>
  </div>
  <div class="readable-text " id="p112"> 
   <p>Let's now use the <kbd>load_data</kbd> function we just created in our Streamlit app. Create an entrypoint (the file we'll use with <kbd>streamlit run</kbd>) to the app called<kbd> dashboard.py</kbd>, shown in listing 6.2.</p>
  </div>
  <div class="browsable-container listing-container" id="p113"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 6.2 dashboard.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
from data_loader import load_data
 
data = load_data()
st.write(data.head(5))
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p114"> 
   <p>This part is fairly straightforward. <kbd>data</kbd> is a Pandas dataframe with data from our CSV (since that's what <kbd>load_data</kbd> returns).</p>
  </div>
  <div class="readable-text  intended-text" id="p115"> 
   <p>The last line, <kbd>st.write(data.head(5))</kbd>, is interesting. We've briefly encountered <kbd>st.write</kbd> before, in Chapter 2. Streamlit's docs describe <kbd>st.write</kbd> as "the Swiss Army knife of Streamlit commands" and that's fairly accurate.</p>
  </div>
  <div class="readable-text  intended-text" id="p116"> 
   <p>You can basically pass pretty much any kind of object to <kbd>st.write</kbd> and it'll display the passed object in a graceful and sensible way. This means you can pass it a string and it'll write the string to the screen, but you can also pass it a dictionary and it'll print out the contents of the dictionary in a well-formatted way (try it out!). You can even pass it internal Python objects like classes or functions and it'll display information about them.</p>
  </div>
  <div class="readable-text  intended-text" id="p117"> 
   <p><kbd>st.write</kbd> works well for our purposes because we can pass it a Pandas dataframe and it'll show the data on the screen. <kbd>data.head(5)</kbd> returns a dataframe with only the first 5 rows of the data, and using <kbd>st.write</kbd> on it helps us verify that the data was loaded correctly, as shown in figure 6.4—which is what you'll get if you execute <kbd>streamlit run dashboard.py</kbd>.</p>
  </div>
  <div class="browsable-container figure-container" id="p118">  
   <img src="../Images/06__image004.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 6.4 Streamlit can display Pandas dataframes natively</h5>
  </div>
  <div class="readable-text " id="p119"> 
   <p>You may notice that it takes a few seconds for the app to load. This is because our CSV file is rather large (more than 90 megabytes) and reading it takes a while. At first glance, this might not sound like a huge deal, but recall once again that Streamlit reruns your <em>entire</em> script every time anything needs to change on the screen.</p>
  </div>
  <div class="readable-text  intended-text" id="p120"> 
   <p>That means that each time the user changes a selection or clicks out of a textbox, your app will re-read the CSV, slowing down the whole app. Besides being incredibly wasteful, that would degrade your dashboard's user experience, so let's address that next.</p>
  </div>
  <div class="readable-text" id="p121"> 
   <h3 class=" readable-text-h3">6.2.3 Caching data</h3>
  </div>
  <div class="readable-text " id="p122"> 
   <p>One of the effects of Streamlit's execution model is that, without intervention, expensive operations such as reading a file or performing a complex computation are executed over and over again to get the same results every time. This can be problematic for data apps like the one we're building now since they frequently rely upon such operations.</p>
  </div>
  <div class="readable-text  intended-text" id="p123"> 
   <p>In prior chapters, we've seen one way to deal with the problem: we could save the data into <kbd>st.session_state</kbd>. That way the data would only have to be read once per user session, and the app wouldn't slow down during user interactions.</p>
  </div>
  <div class="readable-text  intended-text" id="p124"> 
   <p>This is an <em>okay</em> solution, but doesn't solve a couple of issues:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p125">The data would still need to be loaded every time the web page is refreshed. If the user opens the dashboard in multiple tabs—and given the number of browser tabs the average person has open at any point, they probably will—it would take a while to load each time.</li>
   <li class="readable-text" id="p126">The dashboard would have to read the data from scratch for <em>each</em> user even though it's the exact same data.</li>
  </ul>
  <div class="readable-text " id="p127"> 
   <p>Streamlit offers a better way to deal with this situation, in the form of <kbd>st.cache_data</kbd>.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p128"> 
   <h4 class=" readable-text-h4">st.cache_data</h4>
  </div>
  <div class="readable-text " id="p129"> 
   <p><kbd>st.cache_data</kbd> is Streamlit's way of <em>caching</em> or storing the results of a slow function call so that the next time the function is called with the same parameters, it can simply look up the stored result of the <em>last</em> call rather than actually executing the function again.</p>
  </div>
  <div class="readable-text  intended-text" id="p130"> 
   <p>For our use case, we can simply cache the result of the <kbd>load_data</kbd> function we wrote earlier. Streamlit would then store the Pandas dataframe it returns, and subsequent app reruns or even page refreshes wouldn't cause the function to be executed again.</p>
  </div>
  <div class="readable-text  intended-text" id="p131"> 
   <p><kbd>st.cache_data</kbd> uses a different Python construct from the Streamlit elements we've seen so far: it's a <em>decorator,</em> which you can think of as something that takes a function or a class and adds some new feature to it without you having to rewrite the function or class.</p>
  </div>
  <div class="readable-text  intended-text" id="p132"> 
   <p>To apply <kbd>st.cache_data</kbd> on the <kbd>load_data</kbd> function (in <kbd>data_loader.py</kbd>), simply write <kbd>@st.cache_data</kbd> above it, like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p133"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area"><b>@st.cache_data</b>
def load_data():
  return pd.read_csv(SALES_DATA_PATH)</pre>
   </div>
  </div>
  <div class="readable-text " id="p134"> 
   <p>Here, <kbd>st.cache_data</kbd> is <em>decorating</em> the <kbd>load_data</kbd> function, transforming it with the caching feature so that when it's called again, it'll return the previous cached result rather than executing its logic.</p>
  </div>
  <div class="readable-text  intended-text" id="p135"> 
   <p>Since we're now referring to a Streamlit element within <kbd>data_loader.py</kbd>, we also need to include the Streamlit import at the top:</p>
  </div>
  <div class="browsable-container listing-container" id="p136"> 
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st</pre>
   </div>
  </div>
  <div class="readable-text " id="p137"> 
   <p>If you run the app now, you'll briefly see a spinning icon with the text "Running<kbd> load_data()."</kbd> (see figure 6.5) before your dataframe is displayed, but if you reload the page your data should now load instantly.</p>
  </div>
  <div class="browsable-container figure-container" id="p138">  
   <img src="../Images/06__image005.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 6.5 By default, st.cache_data shows a spinner with a function name when actually running the function</h5>
  </div>
  <div class="readable-text " id="p139"> 
   <p>Looks like the caching is working! Here's a question though: what happens when the data changes? The CEO wants a dashboard with <em>up-to-date</em> sales data, so we can assume that the source data will change periodically—at least daily if not more frequently than that. For our example, let's assume that Engineering will overwrite the existing CSV with a version with newer data every day.</p>
  </div>
  <div class="readable-text  intended-text" id="p140"> 
   <p>If the data is cached the way we've set it up, Streamlit won't pull in the updated CSV when it changes. It will just see that the return value of <kbd>load_data</kbd> is cached from the first run (perhaps several days ago) and use that.</p>
  </div>
  <div class="readable-text  intended-text" id="p141"> 
   <p>We need a way to set an <em>expiry date</em> for the cache, essentially telling it that if the cached data is older than a certain threshold, the function needs to actually be executed and the results re-cached.</p>
  </div>
  <div class="readable-text  intended-text" id="p142"> 
   <p>We achieve this using the <kbd>ttl</kbd> argument of <kbd>st.cache_data</kbd>. <kbd>ttl</kbd> stands for "time-to-live" and sets the amount of time that the cached data is valid for before Streamlit will re-execute the function during a rerun.</p>
  </div>
  <div class="readable-text  intended-text" id="p143"> 
   <p>If we assume that our CSV data will change every day, we could set a <kbd>ttl</kbd> of 1 day like so:</p>
  </div>
  <div class="browsable-container listing-container" id="p144"> 
   <div class="code-area-container"> 
    <pre class="code-area">@st.cache_data(ttl="1d")</pre>
   </div>
  </div>
  <div class="readable-text " id="p145"> 
   <p>This way, the loaded data will be pulled once every day when a user runs the app. That run will take a while, but all subsequent runs in the following 24 hours will use the newly cached data and therefore be quick.</p>
  </div>
  <div class="readable-text  intended-text" id="p146"> 
   <p>Figure 6.6 illustrates how this works.</p>
  </div>
  <div class="browsable-container figure-container" id="p147">  
   <img src="../Images/06__image006.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 6.6 How st.cache_data works</h5>
  </div>
  <div class="readable-text " id="p148"> 
   <p>Another thing we probably want to change is the message displayed with the spinning icon. The name <kbd>load_data</kbd> is internal to our code and we don't want it exposed to users. We can change this message using the <kbd>show_spinner</kbd> argument of <kbd>st.cache_data</kbd> so our code becomes:</p>
  </div>
  <div class="browsable-container listing-container" id="p149"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area"><b>@st.cache_data(show_spinner="Reading sales data...", ttl="1d")</b>
def load_data():
  return pd.read_csv(SALES_DATA_PATH)</pre>
   </div>
  </div>
  <div class="readable-text " id="p150"> 
   <p>Run the app again and you'll notice the loading indicator has changed to figure 6.7.</p>
  </div>
  <div class="browsable-container figure-container" id="p151">  
   <img src="../Images/06__image007.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 6.7 Setting the show_spinner parameter in st.cache_data displays a user-friendly message when the data is loading</h5>
  </div>
  <div class="readable-text " id="p152"> 
   <p>It's valuable to realize that when a user runs the app and the data is cached, the cached values are available to <em>all</em> users of the app, not just the current one. There are times when this can lead to unexpected results (we'll probably encounter some of these in later chapters), but in this case, since we want to show all users the same data, it's desirable behavior.</p>
  </div>
  <div class="readable-text  intended-text" id="p153"> 
   <p>With the data loaded and available within our app, let's move on to constructing the dashboard itself.</p>
  </div>
  <div class="readable-text" id="p154"> 
   <h2 class=" readable-text-h2">6.3 Prepping and filtering the data</h2>
  </div>
  <div class="readable-text " id="p155"> 
   <p>A key requirement our dashboard needs to meet is the ability to inspect various <em>slices</em> of the data, as opposed to its entirety. This is quite logical; our source data runs across 5+ years. A user today would probably be more interested in the most recent year of data than older years. Similarly, a user may only be interested in sales related to the "Paper products" category.</p>
  </div>
  <div class="readable-text  intended-text" id="p156"> 
   <p><em>Filtering</em> a table of data is the act of considering only the rows of data that we care about, and excluding everything else. Our envisioned dashboard has two areas that enable this: a <em>filter panel</em> where users can choose the values of each field they want to consider, and a <em>date range selector</em>.</p>
  </div>
  <div class="readable-text  intended-text" id="p157"> 
   <p>In this section we'll build both of these components visually, and perform the Pandas data wrangling that enables their functionality.</p>
  </div>
  <div class="readable-text" id="p158"> 
   <h3 class=" readable-text-h3">6.3.1 Creating a filter panel</h3>
  </div>
  <div class="readable-text " id="p159"> 
   <p>Let's revisit our UI mock, focusing on the filter panel at the top, reproduced in figure 6.8.</p>
  </div>
  <div class="browsable-container figure-container" id="p160">  
   <img src="../Images/06__image008.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 6.8 The filter panel from our UI mock</h5>
  </div>
  <div class="readable-text " id="p161"> 
   <p>The panel is essentially a collection of dropdown menus, one for each field that we want to filter by.</p>
  </div>
  <div class="readable-text  intended-text" id="p162"> 
   <p>Each menu presumably contains the unique values corresponding to each field as options, and the user can choose multiple options (eg. in figure 6.8, the "State" filter has CA, TX and FL all selected). Also, the user can choose not to select <em>any </em>option (eg. "Gender" in figure 6.8), which we should probably treat as there not being any filter on that field.</p>
  </div>
  <div class="readable-text  intended-text" id="p163"> 
   <p>The selections shown in figure 6.8 should cut the data down to rows corresponding to the 18-25 and 26-35 age groups for customers in CA, TX or FL. Since there's no filter on, say, "Product name", the data should include all products sold by Note n' Nib.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p164"> 
   <h4 class=" readable-text-h4">Obtaining the list of unique values for a field</h4>
  </div>
  <div class="readable-text " id="p165"> 
   <p>Clearly, we need a way to populate the options in the dropdowns when we create them. A plausible way to do this might be to hardcode the list of possible values for each field, but this presents some glaring issues: we would need to change our code every time there's a new product or category, or if the way we're grouping ages changes, or for plenty of other reasons.</p>
  </div>
  <div class="readable-text  intended-text" id="p166"> 
   <p>A better approach is to get the list of options dynamically, from the data <em>itself</em>. Start a new Python file called <kbd>data_wrangling.py</kbd> and add a function to do this, as shown in listing 6.3.</p>
  </div>
  <div class="browsable-container listing-container" id="p167"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 6.3 data_wrangling.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">def get_unique_values(df, column):
  return list(df[column].unique())
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p168"> 
   <p>The <kbd>get_unique_values</kbd> function accepts a Pandas dataframe <kbd>df</kbd> and a column name <kbd>column</kbd>. It returns a list of unique values for that column in the dataframe.</p>
  </div>
  <div class="readable-text  intended-text" id="p169"> 
   <p>When you pass a column name to a Pandas dataframe within square brackets (an operation named <em>column selection</em>), you get a Pandas <em>series</em>, which is a one-dimensional array-like object (you could think of it as a single-column dataframe).</p>
  </div>
  <div class="readable-text  intended-text" id="p170"> 
   <p>For instance, <kbd>df['age_group']</kbd> would return a series with the same number of elements as there are rows in <kbd>df</kbd>, with each element being the <kbd>age_group</kbd> corresponding to a row.</p>
  </div>
  <div class="readable-text  intended-text" id="p171"> 
   <p>Calling<kbd> .unique()</kbd> on it dedupes the elements and gives you a new series with just the five or six distinct age groups in the data. We finally convert it into a regular Python list with the <kbd>list</kbd> function.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p172"> 
   <h4 class=" readable-text-h4">Adding the dropdowns with st.multiselect</h4>
  </div>
  <div class="readable-text " id="p173"> 
   <p>As we've seen, the user should be able to select any combination of options in each filter. Streamlit provides this functionality through <kbd>st.multiselect</kbd>, which is quite similar to <kbd>st.selectbox</kbd>, which we've come across before. As in the case of <kbd>st.selectbox</kbd>, the first two parameters (the only required ones) that you pass to <kbd>st.multiselect</kbd> are the label and the list of options.</p>
  </div>
  <div class="readable-text  intended-text" id="p174"> 
   <p>For example, you could write <kbd>st.multiselect('Color', ['blue', 'green', 'red'])</kbd> to display a dropdown labeled "Color" from which you can select one or more colors.</p>
  </div>
  <div class="readable-text  intended-text" id="p175"> 
   <p>Keeping with our approach of spreading our code into several modules, we'll create a new one for the filter panel and call it <kbd>filter_panel.py</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p176"> 
   <p>Listing 6.4 shows a starting draft of <kbd>filter_panel.py</kbd>.</p>
  </div>
  <div class="browsable-container listing-container" id="p177"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 6.4 dashboard.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
from data_wrangling import get_unique_values
 
filter_dims = ["age_group", "gender", "category", "segment",
               "product_name", "state"]
 
def filter_panel(df):
  with st.expander("Filters"):
    filter_cols = st.columns(len(filter_dims))
    for idx, dim in enumerate(filter_dims):
      with filter_cols[idx]:
        unique_vals = get_unique_values(df, dim)
        st.multiselect(dim, unique_vals)</pre>
   </div>
  </div>
  <div class="readable-text " id="p178"> 
   <p><kbd>filter_dims</kbd> holds the list of fields from the dataframe that we want to filter on.</p>
  </div>
  <div class="readable-text  intended-text" id="p179"> 
   <p>The <kbd>filter_panel</kbd> function is what actually displays the dropdowns. It takes a dataframe as input and renders the dropdowns using the unique values for each field.</p>
  </div>
  <div class="readable-text  intended-text" id="p180"> 
   <p>Some of this code should look familiar by this point. We want to display the dropdowns side by side, so we use <kbd>st.columns(len(filter_dims))</kbd> to create as many display columns as there are fields we want to filter on.</p>
  </div>
  <div class="readable-text  intended-text" id="p181"> 
   <p>For each field, we obtain the unique values using our <kbd>get_unique_values</kbd> function from <kbd>data_wrangling.py</kbd>, and use them to populate the dropdown:</p>
  </div>
  <div class="browsable-container listing-container" id="p182"> 
   <div class="code-area-container"> 
    <pre class="code-area">with filter_cols[idx]:
    unique_vals = get_unique_values(df, dim)
    st.multiselect(dim, unique_vals)</pre>
   </div>
  </div>
  <div class="readable-text " id="p183"> 
   <p>Listing 6.4 also shows the use of a new Streamlit widget called <kbd>st.expander</kbd>, which is a collapsible box that users can expand or contract as needed. This makes sense because the user probably doesn't want to see the filters all the time. It's a good idea to have the option of hiding them so they can focus on the actual displayed data.</p>
  </div>
  <div class="readable-text  intended-text" id="p184"> 
   <p>Let's include the <kbd>filter_panel</kbd> in our main dashboard by editing <kbd>dashboard.py</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p185"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">...
<b>from filter_panel import filter_panel</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
data = load_data()
<b>filter_panel(data)</b>
st.write(data.head(5))
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span></pre>
   </div>
  </div>
  <div class="readable-text " id="p186"> 
   <p>This should yield the output in figure 6.9.</p>
  </div>
  <div class="browsable-container figure-container" id="p187">  
   <img src="../Images/06__image009.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 6.9 By default, our Streamlit app's layout is centered, which can be problematic if there's a lot to display horizontally</h5>
  </div>
  <div class="readable-text " id="p188"> 
   <p>One issue we can see immediately is that with six fields to filter on, each individual filter seems to be squished against its neighbors.</p>
  </div>
  <div class="readable-text  intended-text" id="p189"> 
   <p>Additionally, the filter field names are currently the raw column names from the CSV, including underscores. A more polished design would present these as user-friendly labels, such as "Age group," instead of technical identifiers like "age_group."</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p190"> 
   <h4 class=" readable-text-h4">Fixing the width issue</h4>
  </div>
  <div class="readable-text " id="p191"> 
   <p>Notice in figure 6.9 that there's a lot of unused whitespace to the sides of the filter panel. By default, Streamlit apps have a "centered" layout where the body of the app is rendered horizontally at the center of the window, and the sides are blank.</p>
  </div>
  <div class="readable-text  intended-text" id="p192"> 
   <p>This is usually fine, but with a UI as dense as what we're building, screen real estate comes at a premium. Thankfully, Streamlit allows us to change this and use more of the screen. We can do this using the <kbd>st.set_page_config</kbd> method in <kbd>dashboard.py</kbd>.</p>
  </div>
  <div class="browsable-container listing-container" id="p193"> 
   <div class="code-area-container"> 
    <pre class="code-area">st.set_page_config(layout='wide')</pre>
   </div>
  </div>
  <div class="readable-text " id="p194"> 
   <p>Importantly, this only works if it's the very first Streamlit command executed in an app, so make sure it's at the top of<kbd> dashboard.py</kbd>, right after the imports.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p195"> 
   <h4 class=" readable-text-h4">Displaying user-friendly labels for fields</h4>
  </div>
  <div class="readable-text " id="p196"> 
   <p>To swap out the raw field names for labels, we could retain a mapping between the raw names and their associated labels in a dictionary, and look up the label every time we needed to display the name of a field. That sounds quite tedious though, so instead let's just rename the fields in the data frame to be user-friendly ones.</p>
  </div>
  <div class="readable-text  intended-text" id="p197"> 
   <p>There will probably be a bunch of similar "cleaning-up" modifications we'll need to make to the data. We'll bundle these up into a <kbd>prep_data</kbd> function in <kbd>data_wrangling.py</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p198"> 
   <div class="code-area-container"> 
    <pre class="code-area">...
from data_loader import load_data   #A
 
...
def clean_column_names(df):
  df.columns = df.columns.str.replace('_', ' ').str.capitalize()
  return df
 
@st.cache_data(show_spinner="Reading sales data...", ttl="1d")    #B
def prep_data():
  return clean_column_names(load_data())</pre>
    <div class="code-annotations-overlay-container">
     #A Don't forget to import the functions we need from other modules
     <br/>#B Move the st.cache_data decorator so it applies to prep_data instead of load_data
     <br/>
    </div>
   </div>
  </div>
  <div class="readable-text " id="p199"> 
   <p>Here we define a function called <kbd>clean_column_names</kbd> that replaces the underscores in each column name of a dataframe with spaces and capitalizes it. <kbd>df.columns</kbd> returns the dataframe column names, and<kbd> .str.replace()</kbd> and <kbd>.str.capitalize()</kbd> are the respective string operations. We use <kbd>.str</kbd> to apply the replace and capitalize operations to each element in <kbd>df.columns</kbd> in one go, which is something which you'll see quite frequently in Pandas.</p>
  </div>
  <div class="readable-text  intended-text" id="p200"> 
   <p>For now, the <kbd>prep_data</kbd> function calls <kbd>load_data</kbd> internally and then simply returns the result of applying <kbd>clean_column_names</kbd> to the returned dataframe, but we'll add more logic to it later.</p>
  </div>
  <div class="readable-text  intended-text" id="p201"> 
   <p>We've also moved <kbd>st.cache_data</kbd> decorator to the <kbd>prep_data</kbd> function (remove it from <kbd>load_data</kbd> in <kbd>data_loader.py</kbd>) because <kbd>prep_data</kbd> is supposed to contain basic operations we always want done on the data. After this, Streamlit will cache the result only after prepping the data, not immediately after loading it.</p>
  </div>
  <div class="readable-text  intended-text" id="p202"> 
   <p>To close the loop, in <kbd>dashboard.py</kbd>, replace the line <kbd>data = load_data()</kbd> with <kbd>data = prep_data()</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p203"> 
   <p>Finally, in <kbd>filter_panel.py</kbd>, modify <kbd>filter_dims</kbd> to use the newly polished field names:</p>
  </div>
  <div class="browsable-container listing-container" id="p204"> 
   <div class="code-area-container"> 
    <pre class="code-area">filter_dims = ["Age group", "Gender", "Category", "Segment",
               "Product name", "State"]</pre>
   </div>
  </div>
  <div class="readable-text " id="p205"> 
   <p>Save and re-run to see the result shown in figure 6.10</p>
  </div>
  <div class="browsable-container figure-container" id="p206">  
   <img src="../Images/06__image010.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 6.10 Filter panel with user-friendly field names and a wide layout</h5>
  </div>
  <div class="readable-text " id="p207"> 
   <p>The dashboard now uses up the full width of the screen, and we're using labels for the filters.</p>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p208"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p209"> 
    <p>Due to the amount of code in this chapter and the limited amount of space available on the printed page, while providing code snippets here, we'll focus primarily on how the code in a particular file has <em>changed </em>rather than reproducing the entire file as we did in previous chapters. However, at any point, if you're stuck and would like to compare your code to what it should be at that point, you can see complete in-progress snapshots of the code in the GitHub repo for this book (github.com/aneevdavis/streamlit-in-action), under the chapter_6 folder. For instance, the code files you should be comparing to at the moment are in the in_progress_4 directory.</p>
   </div>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p210"> 
   <h4 class=" readable-text-h4">Applying the filters to the data</h4>
  </div>
  <div class="readable-text " id="p211"> 
   <p>So far, we've created the UI elements corresponding to the filters, but we haven't actually applied them to the data.</p>
  </div>
  <div class="readable-text  intended-text" id="p212"> 
   <p>To do this, let's first think of how we should represent the output we get from the filter panel. To be able to apply the filters, we need to look up the values the user has selected in the filter for each dimension. This is a good use case for a dictionary that has each field name as a key and the list of selected options as the value for the key.</p>
  </div>
  <div class="readable-text  intended-text" id="p213"> 
   <p>Our current <kbd>filter_panel</kbd> function (from <kbd>filter_panel.py</kbd>) simply displays the filter bar, but we want to modify it so that it actually returns such a dictionary that we can use for further processing.</p>
  </div>
  <div class="browsable-container listing-container" id="p214"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">def filter_panel(df):
  <b>filters = {}</b>
  with st.expander("Filters"):
    filter_cols = st.columns(len(filter_dims))
    for idx, dim in enumerate(filter_dims):
      with filter_cols[idx]:
        unique_vals = get_unique_values(df, dim)
        <b>filters[dim] =</b> st.multiselect(dim, unique_vals)
  <b>return filters</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span></pre>
   </div>
  </div>
  <div class="readable-text " id="p215"> 
   <p>Though we weren't making use of this earlier, <kbd>st.multiselec</kbd>t actually returns the list of options a user has selected in the UI. As the highlighted lines show, we're now storing this returned value in the <kbd>filters</kbd> dictionary using <kbd>dim</kbd> (the field name) as the key, and returning filters at the end.</p>
  </div>
  <div class="readable-text  intended-text" id="p216"> 
   <p>Next, we need to use the dictionary to produce the slice of the data the user wants. Since this involves data manipulation operations, let's put this functionality in<kbd> data_wrangling.py</kbd>, in a function called <kbd>apply_filters</kbd>.</p>
  </div>
  <div class="browsable-container listing-container" id="p217"> 
   <div class="code-area-container"> 
    <pre class="code-area">def apply_filters(df, filters):
  for col, values in filters.items():
    if values:
      df = df[df[col].isin(values)]
  return df
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p218"> 
   <p><kbd>apply_filters</kbd> takes <kbd>df</kbd>—a Pandas dataframe—and the filters dictionary returned by <kbd>filter_panel</kbd>. It goes through each of the key-value pairs in filters and iteratively modifies the dataframe by filtering it using the statement:</p>
  </div>
  <div class="browsable-container listing-container" id="p219"> 
   <div class="code-area-container"> 
    <pre class="code-area">df = df[df[col].isin(values)]
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p220"> 
   <p>This is worth breaking down a little. The square brackets are quite versatile in Pandas. When you pass a column name in the brackets following a dataframe variable (like<kbd> df['Age group']</kbd>), it returns that column as a Pandas series—as we've seen previously.</p>
  </div>
  <div class="readable-text  intended-text" id="p221"> 
   <p>If, instead, you pass a Pandas boolean series (a series where each item is a boolean) instead, it will match the numbered elements of the series against the ordered rows of the dataframe, returning only the rows where the corresponding boolean value is <kbd>True</kbd>. This is called <em>boolean indexing</em>.</p>
  </div>
  <div class="readable-text  intended-text" id="p222"> 
   <p>You can see both of these usages in the line above:</p>
  </div>
  <div class="readable-text  intended-text" id="p223"> 
   <p><kbd>df[col]</kbd> does column selection, selecting the col (the column to filter) in df.</p>
  </div>
  <div class="readable-text  intended-text" id="p224"> 
   <p>The<kbd> .isin(values)</kbd> applies an element-wise operation on the column, checking whether each value in it is present in values, the list of dropdown options selected by the user. This returns another series with a <kbd>True</kbd>/<kbd>False</kbd> value for every corresponding item in <kbd>df[col]</kbd>. This is an example of a <em>vectorized</em> calculation, which is responsible for much of Pandas' performance.</p>
  </div>
  <div class="readable-text  intended-text" id="p225"> 
   <p>Finally, we perform boolean indexing, using the boolean series obtained in the previous step to produce a new filtered dataframe and assign <em>that</em> to df.</p>
  </div>
  <div class="readable-text  intended-text" id="p226"> 
   <p>Effectively, each time it executes, the line <kbd>df = df[df[col].isin(values)]</kbd> filters the dataframe to include only rows where the column we're currently looking at contains one of the values the user selected.</p>
  </div>
  <div class="readable-text  intended-text" id="p227"> 
   <p>The<kbd> if values</kbd> part ensures that we don't do the filtering if the user hasn't selected any values for a field, thus correctly implementing our requirement.</p>
  </div>
  <div class="readable-text  intended-text" id="p228"> 
   <p>To see this in action, make the required modifications to <kbd>dashboard.py</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p229"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">...
from data_wrangling import <b>apply_filters</b>, prep_data
...
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
data = prep_data()
<b>filters = </b>filter_panel(data)    #A
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
<b>main_df = apply_filters(data, filters)</b>
st.write(<b>main_df</b>.head(5))</pre>
    <div class="code-annotations-overlay-container">
     #A We now put the dictionary returned by filter_panel(data) in a variable
     <br/>
    </div>
   </div>
  </div>
  <div class="readable-text " id="p230"> 
   <p>We're now capturing the dictionary of filters, using <kbd>apply_filters</kbd> to create a new dataframe called <kbd>main_df</kbd>, and displaying that instead of data. This should give us the result in figure 6.11.</p>
  </div>
  <div class="browsable-container figure-container" id="p231">  
   <img src="../Images/06__image011.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 6.11 The selections in the filter panel correctly filter the displayed rows (see chapter_6/in_progress_5 in the GitHub repo for a snapshot of the full code)</h5>
  </div>
  <div class="readable-text " id="p232"> 
   <p>As you can see, the displayed dataframe only shows rows corresponding to the user's selections in the filter panel (18-25, M, Staples, CA).</p>
  </div>
  <div class="readable-text  intended-text" id="p233"> 
   <p>There's still one more kind of filter to apply: the date range! Let's deal with that next.</p>
  </div>
  <div class="readable-text" id="p234"> 
   <h3 class=" readable-text-h3">6.3.2 Creating a date range selector</h3>
  </div>
  <div class="readable-text " id="p235"> 
   <p>As usual, Streamlit offers an easy way to enable users to select a date range. In its typical intuitive naming fashion, the widget we want is called <kbd>st.date_input</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p236"> 
   <p><kbd>st.date_input</kbd> accepts a label, a default value, minimum and maximum values and more. You can have the user select a single date or a range of dates.</p>
  </div>
  <div class="readable-text  intended-text" id="p237"> 
   <p>For instance, to allow the user to select a single date with today's date as the default:</p>
  </div>
  <div class="browsable-container listing-container" id="p238"> 
   <div class="code-area-container"> 
    <pre class="code-area">date = st.date_input("Select a date", value=datetime.date.today())</pre>
   </div>
  </div>
  <div class="readable-text " id="p239"> 
   <p>To enable a date range selection between a default start and end date:</p>
  </div>
  <div class="browsable-container listing-container" id="p240"> 
   <div class="code-area-container"> 
    <pre class="code-area">range = st.date_input("Select a date range", value=(datetime.date(2023, 1, 1),
datetime.date(2023, 12, 31)))
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p241"> 
   <p>We'll put our date range selector in a new file called <kbd>date_range_panel.py</kbd>, shown in listing 6.5.</p>
  </div>
  <div class="browsable-container listing-container" id="p242"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 6.5 date_range_panel.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
from datetime import date, timedelta
 
# Hardcode this to the last date in dataset to ensure reproducibility
LATEST_DATE = date.fromisoformat("2024-08-31")
THIRTY_DAYS_AGO = LATEST_DATE - timedelta(days=30)
 
def date_range_panel():
  start = st.date_input("Start date", value=THIRTY_DAYS_AGO)
  end = st.date_input("End date", value=LATEST_DATE)
  return start, end
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p243"> 
   <p>The <kbd>date_range_panel</kbd> function displays two date selector widgets—one each for the start and end of the range—and returns the dates selected by the user. We're opting to use two separate single-date inputs here instead of a single range input to prevent temporary errors when the end of the range hasn't been selected yet.</p>
  </div>
  <div class="readable-text  intended-text" id="p244"> 
   <p>For the default date range values, we show a start date of one month ago and an end date of today, using the variables <kbd>THIRTY_DAYS_AGO</kbd> and <kbd>LATEST_DATE</kbd>. Since we're dealing with a static dataset, we hardcode <kbd>LATEST_DATE</kbd> to a particular date that's available in the CSV. If we were working with real-time or regularly updated data, we would have replaced this with<kbd> LATEST_DATE = date.today()</kbd>. <kbd>THIRTY_DAYS_AGO</kbd> is obtained by subtracting 30 days from <kbd>LATEST_DATE</kbd> using the <kbd>timedelta</kbd> class from the <kbd>datetime</kbd> module.</p>
  </div>
  <div class="readable-text  intended-text" id="p245"> 
   <p>The values <kbd>LATEST_DATE</kbd> and <kbd>THIRTY_DAYS_AGO</kbd> are of the type <kbd>date</kbd>, from the built-in <kbd>datetime</kbd> module. <kbd>st.date_input</kbd> understands this type and even returns it. The variables <kbd>start</kbd> and <kbd>end</kbd> returned by <kbd>date_range_panel</kbd> are thus both also of type <kbd>date</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p246"> 
   <p>In fact, let's make use of those values presently by editing <kbd>data_wrangling.py</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p247"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area"><b>import pandas as pd</b>
import streamlit as st
...
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
@st.cache_data(show_spinner="Reading sales data...", ttl="1d")
def prep_data() -&gt; pd.DataFrame:
  <b>df = </b>clean_column_names(load_data())
  <b>df['Day'] = pd.to_datetime(df['Date'])</b>
  <b>return df</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
def get_data_within_date_range(df, start, end):
  if start is not None and end is not None:
    dt_start, dt_end = pd.to_datetime(start), pd.to_datetime(end)
    return df[(df['Day'] &gt;= dt_start) &amp; (df['Day'] &lt;= dt_end)]
  return df
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
def get_filtered_data_within_date_range(df, start, end, filters):
  df_within_range = get_data_within_date_range(df.copy(), start, end)
  return apply_filters(df_within_range, filters)
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span></pre>
   </div>
  </div>
  <div class="readable-text " id="p248"> 
   <p>We've made a few changes here:</p>
  </div>
  <div class="readable-text  intended-text" id="p249"> 
   <p>In addition to cleaning up the column names, <kbd>prep_data</kbd> adds a new column called 'Day', the result of applying <kbd>pd.to_datetime()</kbd> to the existing 'Date' column. Recall that the 'Date' column is currently an opaque "object" type. <kbd>pd.to_datetime()</kbd> converts it to <kbd>datetime[ns]</kbd> which can be optimized by Pandas.</p>
  </div>
  <div class="readable-text  intended-text" id="p250"> 
   <p>We've wrapped a call to <kbd>apply_filters</kbd> within the <kbd>get_filtered_data_within_date_range</kbd> function, which first accepts the start and end dates of the date range and uses them to call <kbd>get_data_within_date_range</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p251"> 
   <p><kbd>get_data_within_date_range</kbd> is the function that actually applies the date range filter on our dataframe. The first line in this function does a date format conversion:</p>
  </div>
  <div class="browsable-container listing-container" id="p252"> 
   <div class="code-area-container"> 
    <pre class="code-area">dt_start, dt_end = pd.to_datetime(start), pd.to_datetime(end)
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p253"> 
   <p>This is because Pandas uses a <kbd>datetime[ns]</kbd> type to represent dates. This is different from Python's <kbd>date</kbd> type that <kbd>start</kbd> and <kbd>end</kbd> are in, and is more efficient for use in dataframe operations.</p>
  </div>
  <div class="browsable-container listing-container" id="p254"> 
   <div class="code-area-container"> 
    <pre class="code-area">return df[(df['Day'] &gt;= dt_start) &amp; (df['Day'] &lt;= dt_end)]
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p255"> 
   <p>This is boolean indexing again, similar to what we encountered in the <kbd>apply_filters</kbd> function, but we're using a combination of two conditions (<kbd>df['Day'] &gt;= dt_start and df['Day'] &lt;= dt_end</kbd>) to filter the dataframe, joining them with<kbd> &amp;</kbd>, which is Pandas' element-wise logical <kbd>AND</kbd> operator.</p>
  </div>
  <div class="readable-text  intended-text" id="p256"> 
   <p>We also need to update dashboard.py again:</p>
  </div>
  <div class="browsable-container listing-container" id="p257"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">import streamlit as st
from data_wrangling import <b>get_filtered_data_within_date_range</b>, prep_data
from filter_panel import filter_panel
<b>from date_range_panel import date_range_panel</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
st.set_page_config(layout='wide')
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
<b>with st.sidebar:</b>
<b>  start, end = date_range_panel()</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
data = prep_data()
filters = filter_panel(data)
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
main_df = <b>get_filtered_data_within_date_range(data, start, end, filters)</b>
st.write(main_df.head(5))
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span></pre>
   </div>
  </div>
  <div class="readable-text " id="p258"> 
   <p>We place the date range panel in a sidebar (which you should be quite comfortable with by now).</p>
  </div>
  <div class="readable-text  intended-text" id="p259"> 
   <p>And since <kbd>apply_data</kbd> is now contained within <kbd>get_filtered_data_within_date_range</kbd>, we assign the result of this wrapping function to <kbd>main_df</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p260"> 
   <p>Figure 6.12 shows our new date range panel.</p>
  </div>
  <div class="browsable-container figure-container" id="p261">  
   <img src="../Images/06__image012.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 6.12 Date range inputs displayed in a sidebar (see chapter_6/in_progress_6 in the GitHub repo for a full code snapshot)</h5>
  </div>
  <div class="readable-text " id="p262"> 
   <p>Our dashboard is slowly starting to take form! It's not very useful to the CEO at the moment, however, since it doesn't show any summary information or metrics. That's up next!</p>
  </div>
  <div class="readable-text" id="p263"> 
   <h2 class=" readable-text-h2">6.4 Calculating and displaying metrics</h2>
  </div>
  <div class="readable-text " id="p264"> 
   <p>Imagine you're running a business. How do you know if it's thriving or struggling, whether it's about to go through the roof or come crashing down?</p>
  </div>
  <div class="readable-text  intended-text" id="p265"> 
   <p>One obvious answer is that you'd look at how much the company is earning and the amount of profit it's making. You'll likely also want to know the rate at which your revenue is growing. If you're a fan of Shark Tank's Mr. Wonderful, you probably also keep track of more esoteric numbers such as how much it costs you to acquire a customer.</p>
  </div>
  <div class="readable-text  intended-text" id="p266"> 
   <p>All of these numbers are called <em>metrics</em>. Metrics are useful because they help you boil down all the complexity of a vast business (or any project, really) into a few figures. If a positive metric (like profit) is going up or a negative metric (like cost) is going down, that means things are going well. If the opposite is happening, something likely needs to change.</p>
  </div>
  <div class="readable-text  intended-text" id="p267"> 
   <p>In this section, we'll calculate and display the metrics that Note n' Nib's CEO cares about. To do this, we'll first understand what the metrics mean and how to calculate them. We'll then set up a scalable way to define new metrics for our dashboard to use, and display them prominently in the dashboard.</p>
  </div>
  <div class="readable-text" id="p268"> 
   <h3 class=" readable-text-h3">6.4.1 Calculating the metrics</h3>
  </div>
  <div class="readable-text " id="p269"> 
   <p>Referring back to our requirements, there are four metrics we care about: <em>total sales</em>, <em>gross margin</em>, <em>margin percentage</em>, and <em>average transaction value</em>.</p>
  </div>
  <div class="readable-text  intended-text" id="p270"> 
   <p>Let's try and understand these in reference to our data. Recall that our source CSV has one row for every combination of date, product (and its associated segment and category), gender, age group and state. For each row, it gives us three numeric fields: <em>sales</em>, <em>gross margin</em>, and <em>transactions</em>.</p>
  </div>
  <div class="readable-text  intended-text" id="p271"> 
   <p>A transaction refers to a single purchase of some number of items, and the figure "transactions" refers to the number of them represented by a row. Sales is pretty easy to understand: it's the amount in dollars Note n' Nib collected from those transactions. Gross margin is the profit, or sales minus the cost that the company paid to acquire what the items it sold.</p>
  </div>
  <div class="readable-text  intended-text" id="p272"> 
   <p>Given this, let's figure out how to calculate our metrics for any given slice of our CSV:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p273"><strong>Total sales</strong> is simply the sum of the sales column</li>
   <li class="readable-text" id="p274">Similarly,<strong> gross margin </strong>is the sum of the gross margin column</li>
   <li class="readable-text" id="p275"><strong>Margin percentage</strong> is the gross margin expressed as a percentage of total sales, so it's calculated as total sales / gross margin * 100</li>
   <li class="readable-text" id="p276"><strong>Average transaction value </strong>is the what Note n' Nib earned per transaction, so we can calculate it as total sales / sum of the transactions column</li>
  </ul>
  <div class="readable-text " id="p277"> 
   <p>Let's consider a quick example to crystallize this. Imagine you have the following rows:</p>
  </div>
  <div class="browsable-container listing-container" id="p278"> 
   <div class="code-area-container"> 
    <pre class="code-area">| Date       | Product      | State |  Sales | Gross Margin | Transactions |
|------------|--------------|-------|--------|--------------|--------------|
| 2024-01-01 | Fountain Pen | CA    |    500 |          200 |           10 |
| 2024-01-01 | Notebook     | TX    |    300 |          120 |            5 |
| 2024-01-01 | Pencil       | NY    |    200 |           80 |            8 |
 </pre>
   </div>
  </div>
  <ul> 
   <li class="readable-text" id="p279"><em>Total sales</em> is $500 + $300 + $200 = $1000</li>
   <li class="readable-text" id="p280"><em>Gross margin</em> is $200 + $120 + $80 = $400</li>
   <li class="readable-text" id="p281"><em>Margin percentage</em> is $400 / $1000 = 0.4 = 40%</li>
   <li class="readable-text" id="p282"><em>Average transaction value</em> is $1000 / (10 + 5 + 8) = $1000 / 23 = $43.48</li>
  </ul>
  <div class="readable-text" id="p283"> 
   <h3 class=" readable-text-h3">6.4.2 Setting up the metrics configuration</h3>
  </div>
  <div class="readable-text " id="p284"> 
   <p>A recurring theme you'll come across in software development is that it's a good idea to keep your design reasonably <em>general</em>. By this, I mean that if you have a choice between coding something in a very specific way (hardcoding a list of values, for instance) and coding it in a flexible way (populating the list from a configuration file), it's often better practice to do the latter.</p>
  </div>
  <div class="readable-text  intended-text" id="p285"> 
   <p>A more general design makes your code more adaptable to future changes, and easier to maintain. We saw this when we developed a unit converter app in Chapter 3, where rather than putting the conversion factors directly in our code, we opted to use a configuration file.</p>
  </div>
  <div class="readable-text  intended-text" id="p286"> 
   <p>This is exactly what we'll do to set up the metrics in our dashboard—define a configuration file that defines how to calculate them.</p>
  </div>
  <div class="readable-text  intended-text" id="p287"> 
   <p>As we did in Chapter 3, we'll start by creating a dataclass—<kbd>Metric</kbd>—to hold the object we want to configure. Let's put this in a new file called <kbd>metric.py</kbd> (see listing 6.6).</p>
  </div>
  <div class="browsable-container listing-container" id="p288"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 6.6 metric.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">from dataclasses import dataclass
@dataclass
class Metric:
  title: str
  func: callable
  type: str</pre>
   </div>
  </div>
  <div class="readable-text " id="p289"> 
   <p>The <kbd>Metric</kbd> class contains a title, which is the label we'll display on the interface, and a type, which indicates how it should be formatted (eg. "dollars" as the type would instruct our app to prefix a '$' sign before the number).</p>
  </div>
  <div class="readable-text  intended-text" id="p290"> 
   <p>It also has a member called <kbd>func</kbd> which is apparently a <em>callable. </em>Callables are essentially just functions, and <kbd>func</kbd> is meant to be a function that accepts a Pandas dataframe object and calculates the value of the metric.</p>
  </div>
  <div class="readable-text  intended-text" id="p291"> 
   <p>To truly understand this, let's see how objects of the <kbd>Metric</kbd> class are defined in our configuration file, <kbd>metric_config.py</kbd>, shown in listing 6.7.</p>
  </div>
  <div class="browsable-container listing-container" id="p292"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 6.7 metric_config.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">from metric import Metric
 
def margin_percent(df):
  total_sales = df["Sales"].sum()
  return df["Gross margin"].sum() / total_sales if total_sales &gt; 0 else 0
 
def average_transaction_value(df):
  total_sales = df["Sales"].sum()
  return total_sales / df["Transactions"].sum() if total_sales &gt; 0 else 0
 
metrics = {
  "Total sales": Metric(
    title="Total sales",
    func=lambda df: df["Sales"].sum(),
    type="dollars"
  ),
  "Gross margin": Metric(
    title="Gross margin",
    func=lambda df: df["Gross margin"].sum(),
    type="dollars"
  ),
  "Margin %": Metric(
    title="Margin %",
    func=margin_percent,
    type="percent"
  ),
  "ATV": Metric(
    title="Average transaction value",
    func=average_transaction_value,
    type="dollars"
  )
}
 
display_metrics = ["Total sales", "Gross margin", "Margin %", "ATV"]
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p293"> 
   <p>Turn your attention to the variable <kbd>metrics</kbd>, a dictionary with the names of each of our metrics as keys, and their corresponding <kbd>Metric</kbd> objects as values. Again, this is reminiscent of <kbd>unit_config.py</kbd> from Chapter 3, where we did essentially the same thing.</p>
  </div>
  <div class="readable-text  intended-text" id="p294"> 
   <p>Let's inspect the first item in the dictionary:</p>
  </div>
  <div class="browsable-container listing-container" id="p295"> 
   <div class="code-area-container"> 
    <pre class="code-area">metrics = {
  "Total sales": Metric(
    title="Total sales",
    func=lambda df: df["Sales"].sum(),
    type="dollars"
  ),
  ...</pre>
   </div>
  </div>
  <div class="readable-text " id="p296"> 
   <p>This is the "total sales" metric, which has a sensible display label as its <kbd>title</kbd>, and "dollars" as its <kbd>type</kbd>. <kbd>func</kbd> here is a lambda (which, you might remember from Chapter 2, is an anonymous one-line function). It accepts a single argument—<kbd>df</kbd>, a Pandas dataframe-~-and calculates total sales using the expression:</p>
  </div>
  <div class="browsable-container listing-container" id="p297"> 
   <div class="code-area-container"> 
    <pre class="code-area">df["Sales"].sum()
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p298"> 
   <p><kbd>df["Sales"]</kbd>, as we've discussed before, selects just the "Sales" column from <kbd>df</kbd>, and <kbd>.sum()</kbd> adds up all the values in it to obtain the final value of the metric.</p>
  </div>
  <div class="readable-text  intended-text" id="p299"> 
   <p>The other metrics defined in the dictionary are fairly similar, and their calculations should make sense after the discussion in the previous section. The "Margin %" and "ATV" metrics <em>don't </em>use a lambda for their funcs.</p>
  </div>
  <div class="readable-text  intended-text" id="p300"> 
   <p>Rather, in each of these cases, <kbd>func</kbd> points to a regular function (<kbd>margin_percent</kbd> and <kbd>average_transaction_value</kbd>) defined above. Since these metrics are both ratios, we need to handle the possibility that the denominator is zero, preventing a division-by-zero error:</p>
  </div>
  <div class="browsable-container listing-container" id="p301"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">def margin_percent(df):
  total_sales = df["Sales"].sum()
  return df["Gross margin"].sum() / total_sales <b>if total_sales &gt; 0 else 0</b></pre>
   </div>
  </div>
  <div class="readable-text " id="p302"> 
   <p>The bottom of our configuration file has the following line:</p>
  </div>
  <div class="browsable-container listing-container" id="p303"> 
   <div class="code-area-container"> 
    <pre class="code-area">display_metrics = ["Total sales", "Gross margin", "Margin %", "ATV"]</pre>
   </div>
  </div>
  <div class="readable-text " id="p304"> 
   <p>The variable is meant to hold the metrics we'll actually display in our metric bar. This may seem kind of pointless since we're just listing out all of the keys in the <kbd>metrics</kbd> dictionary. However, this might come in handy if we ever decided to include more metrics and don't want to display all of them, or want to display them in a specific order. We'll see in a bit how <kbd>display_metrics</kbd> is actually used.</p>
  </div>
  <div class="readable-text" id="p305"> 
   <h3 class=" readable-text-h3">6.4.3 Formatting the metrics</h3>
  </div>
  <div class="readable-text " id="p306"> 
   <p>One of the pieces of information we capture in the <kbd>Metric</kbd> class is the "type" of the metric, used primarily for formatting.</p>
  </div>
  <div class="readable-text  intended-text" id="p307"> 
   <p>In our configuration file, three of our metrics are of the "dollars" type, while Margin % is of the "percent" type.</p>
  </div>
  <div class="readable-text  intended-text" id="p308"> 
   <p>Let's now define the formatting logic in its own module, <kbd>formatting.py</kbd> (see listing 6.8). For this, we'll be using a third-party library called <kbd>humanize</kbd> (install it the usual way, i.e. by running <kbd>pip install humanize</kbd>), which provides some nice formatting features.</p>
  </div>
  <div class="browsable-container listing-container" id="p309"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 6.8 formatting.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import humanize
 
def format_metric(value, metric_type):
  if metric_type == "dollars":
    return f'${humanize.metric(value)}'
  elif metric_type == "percent":
    return f'{round(value * 100, 1)}%'
  return f'{value}'
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p310"> 
   <p>The <kbd>format_metric</kbd> function takes a numeric value and a metric type, and returns a formatted display string.</p>
  </div>
  <div class="readable-text  intended-text" id="p311"> 
   <p>The <kbd>humanize</kbd> library we just installed comes into play while formatting a dollar-type metric. Since Note n' Nib is such a popular retailer, its sales figures are in the millions. If the raw revenue number we're tasked with displaying is $25,125,367, we'd rather not show the precise value to the CEO. An abbreviated version like "$25.1m" will do the trick while reducing cognitive load for the user.</p>
  </div>
  <div class="readable-text  intended-text" id="p312"> 
   <p>This is exactly what the <kbd>humanize.metric</kbd> method does. Given a raw number, it will return a rounded number with a sensible lower precision and a suffix ("k" for thousands, "m" for millions, etc). We add the "$" sign manually to get the f-string<kbd> f'${humanize.metric(value)}'</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p313"> 
   <p>For percent-metrics, we multiply the actual value by 100 to convert it from a fraction to a percentage, and round it to a single decimal point before adding the "%" sign.</p>
  </div>
  <div class="readable-text  intended-text" id="p314"> 
   <p>For anything else, we don't do any formatting and just print the value as-is.</p>
  </div>
  <div class="readable-text" id="p315"> 
   <h3 class=" readable-text-h3">6.4.4 Displaying the metrics</h3>
  </div>
  <div class="readable-text " id="p316"> 
   <p>With all the building blocks in place, we can now go ahead and create the metric bar in Streamlit. To do this, create yet another Python module, called <kbd>metric_bar.py</kbd>, with the code from listing 6.9</p>
  </div>
  <div class="browsable-container listing-container" id="p317"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 6.9 metric_bar.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
from metric_config import metrics, display_metrics
from formatting import format_metric
 
def get_metric(df, metric):
  return metric.func(df)
 
def metric_bar(main_df):
  with st.container(border=True):
    metric_cols = st.columns(len(display_metrics))
    for idx, metric_name in enumerate(display_metrics):
      metric = metrics[metric_name]
      with metric_cols[idx]:
        value = get_metric(main_df, metric)
        formatted_value = format_metric(value, metric.type)
        c1, c2, c3 = st.columns([1, 3, 1])
        with c2:
          st.metric(metric.title, formatted_value)
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p318"> 
   <p>The <kbd>metric_bar</kbd> function iterates through the list of metrics we flagged for display (<kbd>display_metrics</kbd> from <kbd>metric_config.p</kbd>y), adding an <kbd>st.metric</kbd> element within a display column for each of them.</p>
  </div>
  <div class="readable-text  intended-text" id="p319"> 
   <p>That's the gist of it, but there are a few interesting bits here.</p>
  </div>
  <div class="readable-text  intended-text" id="p320"> 
   <p>The first is the use of <kbd>st.container</kbd>, a new Streamlit element. Here we're just using it to put the metric bar within a box with a border:</p>
  </div>
  <div class="browsable-container listing-container" id="p321"> 
   <div class="code-area-container"> 
    <pre class="code-area">with st.container(border=True):</pre>
   </div>
  </div>
  <div class="readable-text " id="p322"> 
   <p>There is more to <kbd>st.container</kbd>, however. One use case for it is when we want to display elements "out of order", or in a different order than they are written in the code. We'll come across this later in the book.</p>
  </div>
  <div class="readable-text  intended-text" id="p323"> 
   <p>We use the <kbd>get_metric</kbd> function to extract the value of a metric, given a dataframe and a Metric object. Since each Metric object already has a <kbd>func</kbd> member that defines how to do this, the body of <kbd>get_metric</kbd> is as simple as calling it:</p>
  </div>
  <div class="browsable-container listing-container" id="p324"> 
   <div class="code-area-container"> 
    <pre class="code-area">def get_metric(df, metric):
  return metric.func(df)</pre>
   </div>
  </div>
  <div class="readable-text " id="p325"> 
   <p>The last interesting bit is this part:</p>
  </div>
  <div class="browsable-container listing-container" id="p326"> 
   <div class="code-area-container"> 
    <pre class="code-area">c1, c2, c3 = st.columns([1, 3, 1])
    with c2:
        st.metric(metric.title, formatted_value)</pre>
   </div>
  </div>
  <div class="readable-text " id="p327"> 
   <p>You may find this rather strange. We've already defined a column for the metric (<kbd>metric_cols[idx]</kbd>), but it seems like we're splitting that column into three <em>sub</em>-columns, and then putting the <kbd>st.metric</kbd> widget in only the second one! What's the point of this?</p>
  </div>
  <div class="readable-text  intended-text" id="p328"> 
   <p>Well, this is actually a layout hack. Unfortunately, as of time of writing, Streamlit doesn't offer a great way of horizontally centering items within a column without HTML. So instead, here we're creating three columns within the main column, with the first and third being equal-width blank ones and the second holding the actual content. The overall effect is that the content of the second sub-column appears centered within the main column.</p>
  </div>
  <div class="readable-text  intended-text" id="p329"> 
   <p>With that, all we need is a quick update to <kbd>dashboard.py</kbd> and we should be good to move on:</p>
  </div>
  <div class="browsable-container listing-container" id="p330"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">...
from metric_bar import metric_bar
 
...
main_df = get_filtered_data_within_date_range(data, start, end, filters)
<b>if main_df.empty:</b>
<b>  st.warning("No data to display")</b>
<b>else:</b>
<b>  metric_bar(main_df)</b></pre>
   </div>
  </div>
  <div class="readable-text " id="p331"> 
   <p>We've removed the sample dataframe rows from the display and replaced it with the metric bar. Re-run the dashboard to find the output in figure 6.13.</p>
  </div>
  <div class="browsable-container figure-container" id="p332">  
   <img src="../Images/06__image013.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 6.13 Metrics bar showing key metrics in aggregate (see chapter_6/in_progress_7 in the GitHub repo for the full code)</h5>
  </div>
  <div class="readable-text " id="p333"> 
   <p>Let's tackle some of the visualization components of the dashboard next.</p>
  </div>
  <div class="readable-text" id="p334"> 
   <h2 class=" readable-text-h2">6.5 Constructing visualizations</h2>
  </div>
  <div class="readable-text " id="p335"> 
   <p>Humans are intuitively visual beings. When you're trying to convey a message through data, it's usually more memorable and <em>clicks</em> much faster when you use a graph rather than a table of numbers. This is especially important for busy executives who may have to deal with a breadth of matters and need to develop an understanding of the business so they can make decisions quickly.</p>
  </div>
  <div class="readable-text  intended-text" id="p336"> 
   <p>In this section, we'll add visualizations to our dashboard in the form of a line chart to show how the metrics we're tracking have changed over time, and a pie chart to show the breakdown of those metrics across a chosen dimension. In each case, we'll use Pandas to wrangle the data into a form we can visualize easily, whip up the actual images using a library called Plotly, and display them using Streamlit.</p>
  </div>
  <div class="readable-text" id="p337"> 
   <h3 class=" readable-text-h3">6.5.1 Creating a time series chart</h3>
  </div>
  <div class="readable-text " id="p338"> 
   <p>A time series is simply a sequence of data points recorded at regular time intervals, showing how a particular metric or variable changes over time. This is crucial for spotting trends, seasonality, and outliers, which can inform decision-making.</p>
  </div>
  <div class="readable-text  intended-text" id="p339"> 
   <p>You can think of a simple time series as a series of data with two variables—one representing a date or time, and another representing the measure we're tracking.</p>
  </div>
  <div class="readable-text  intended-text" id="p340"> 
   <p>For instance, this is a time series:</p>
  </div>
  <div class="browsable-container listing-container" id="p341"> 
   <div class="code-area-container"> 
    <pre class="code-area">+------------+-------+
|   Date     | Sales |
+------------+-------+
| 2024-01-01 |  120  |
| 2024-01-02 |  135  |
| 2024-01-03 |  142  |
| 2024-01-04 |  130  |
| 2024-01-05 |  155  |
+------------+-------+</pre>
   </div>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p342"> 
   <h4 class=" readable-text-h4">Obtaining a time series from our dataframe</h4>
  </div>
  <div class="readable-text " id="p343"> 
   <p>Recall that the data we're dealing with have many different fields—date, product name, gender, sales, and so on. We're going to have to transform it into the specific shape of a time series before we can pass it to the visualization we'll build.</p>
  </div>
  <div class="readable-text  intended-text" id="p344"> 
   <p>We have a "Day" field in our data, but one particular row in our dataframe represents the value for a particular combination of gender, age group, product name, etc. What we need is something that, given any particular slice of our full dataframe (which is what our filters give us), <em>aggregates</em> the data up to the "Day" level.</p>
  </div>
  <div class="readable-text  intended-text" id="p345"> 
   <p>For example, a user may have applied the filters "State = CA" giving us the following slice of data (simplified for clarity, excluding the other fields):</p>
  </div>
  <div class="browsable-container listing-container" id="p346"> 
   <div class="code-area-container"> 
    <pre class="code-area">+------------+-------+--------+-----------+------------+
|    Day     | State | Gender | Product   |   Sales    |
+------------+-------+--------+-----------+------------+
| 2024-08-01 |   CA  |   M    | RoyalQuill|   1500     |
| 2024-08-01 |   CA  |   M    | GripLink  |   1300     |
| 2024-08-02 |   CA  |   M    | RoyalQuill|   1600     |
| 2024-08-02 |   CA  |   M    | GripLink  |   1200     |
+------------+-------+--------+-----------+------------+
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p347"> 
   <p>Our time series should contain only "Day" and "Total sales", so we need to add up the sales for each date across state, gender and product:</p>
  </div>
  <div class="browsable-container listing-container" id="p348"> 
   <div class="code-area-container"> 
    <pre class="code-area">+------------+--------+
|    Day     | Sales  |
+------------+--------+
| 2024-08-01 |  2800  |
| 2024-08-02 |  2800  |
+------------+--------+
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p349"> 
   <p>To do this in Pandas, assuming our dataframe is called <kbd>df</kbd>, we could write the following:</p>
  </div>
  <div class="browsable-container listing-container" id="p350"> 
   <div class="code-area-container"> 
    <pre class="code-area">grouped = df.groupby('Day')
data = grouped.apply(lambda df: df['Sales'].sum(), include_groups=False).reset_index()
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p351"> 
   <p>Let's break this down. <kbd>df.groupby('Day')</kbd> would give us a grouped dataframe, which you can imagine as being represented internally like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p352"> 
   <div class="code-area-container"> 
    <pre class="code-area">+------------+------------------------------------------------------+
|    Day     |                  Grouped Rows                        |
+------------+------------------------------------------------------+
| 2024-08-01 | (2024-08-01, CA, M, RoyalQuill, 1500)                |
|            | (2024-08-01, CA, M, GripLink, 1300)                  |
| 2024-08-02 | (2024-08-02, CA, M, RoyalQuill, 1600)                |
|            | (2024-08-02, CA, M, GripLink, 1200)                  |
+------------+------------------------------------------------------+</pre>
   </div>
  </div>
  <div class="readable-text " id="p353"> 
   <p>Next, consider the line <kbd>grouped.apply(lambda df: df['Sales'].sum(), include_groups=False)</kbd></p>
  </div>
  <div class="readable-text  intended-text" id="p354"> 
   <p>The apply method is an extremely powerful Pandas construct that lets you apply a function to each row or column of a dataframe or to the values of a series. When used on a grouped dataframe like the one above, it allows you to perform operations on each group separately.</p>
  </div>
  <div class="readable-text  intended-text" id="p355"> 
   <p>In this case, the lambda function <kbd>lambda df: df['Sales'].sum()</kbd> takes each group (which corresponds to a specific day) and calculates the total sales for that day by summing the <kbd>Sales</kbd> values. In the example above, the day 2024-08-01 would have a total <kbd>Sales</kbd> value of 2800, adding up the sales for the RoyalQuill and GripLink rows.</p>
  </div>
  <div class="readable-text  intended-text" id="p356"> 
   <p>The<kbd> include_groups = False</kbd> bit indicates that we don't want the function to also operate on group labels (the<kbd> Day</kbd> values). It's kind of redundant here as our lambda function specifically refers to the <kbd>"Sales"</kbd> column, but if you don't include this, Pandas will whine about it.</p>
  </div>
  <div class="readable-text  intended-text" id="p357"> 
   <p>Finally, the <kbd>reset_index()</kbd> method converts the results back to a standard DataFrame format. An <em>index</em> is a Pandas concept referring to a unique identifier column for each row, enabling efficient data retrieval and alignment; after summing, the <kbd>Day</kbd> column becomes the index. By calling reset_index(), we restore <kbd>Day</kbd> as a regular column and create a new index that ranges from 0 to n-1, where n is the number of unique days.</p>
  </div>
  <div class="readable-text  intended-text" id="p358"> 
   <p>We need a slightly more generalized version of the above code for our dashboard, as our line chart may need to show any of our four key metrics, not just sales (see figure 6.14 from our UI mock).</p>
  </div>
  <div class="browsable-container figure-container" id="p359">  
   <img src="../Images/06__image014.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 6.14 The time series chart from our UI mock</h5>
  </div>
  <div class="readable-text " id="p360"> 
   <p>So rather than passing in <kbd>df["Sales"].sum()</kbd> as the function to apply, we'll obtain this function from the <kbd>func</kbd> attribute of the <kbd>Metric</kbd> class we defined in <kbd>metric.py</kbd> and instantiated in <kbd>metric_config.py</kbd>.</p>
  </div>
  <div class="browsable-container listing-container" id="p361"> 
   <div class="code-area-container"> 
    <pre class="code-area">Let's add such a function to the bottom of data_wrangling.py:
def get_metric_time_series(df, metric):
  grouped = df.groupby('Day')
  data = grouped.apply(metric.func, include_groups=False).reset_index()
  data.columns = ['Day', 'Value']
  return data
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p362"> 
   <p>Our function accepts a dataframe <kbd>df</kbd> and <kbd>metric</kbd>, one of the <kbd>Metric</kbd> objects from <kbd>metric_config.py</kbd>. As you can see, we pass <kbd>metric.func</kbd> to <kbd>grouped.apply</kbd> to make it general.</p>
  </div>
  <div class="readable-text  intended-text" id="p363"> 
   <p>The line <kbd>data.columns = ['Day', 'Value']</kbd> resets the column names of the resultant dataframe to new ones.</p>
  </div>
  <div class="readable-text  intended-text" id="p364"> 
   <p>Now that we have our time series, let's build our line chart.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p365"> 
   <h4 class=" readable-text-h4">Using Plotly to build a line chart with our time series</h4>
  </div>
  <div class="readable-text " id="p366"> 
   <p>As we touched upon briefly in Chapter 1, Streamlit supports many different data visualization libraries. Plotly is one such library that tends to be fairly easy to use and offers a range of engaging interactive visualizations.</p>
  </div>
  <div class="readable-text  intended-text" id="p367"> 
   <p>To use it, you first need to install it with <kbd>pip install plotly.</kbd></p>
  </div>
  <div class="readable-text  intended-text" id="p368"> 
   <p>The flavor of Plotly we'll use is called Plotly Graph Objects (GO for short). GO allows you to construct plots with a high degree of control and customization, making it ideal for interactive charts where you can define every detail.</p>
  </div>
  <div class="readable-text  intended-text" id="p369"> 
   <p>Create a new Python module named <kbd>time_series_chart.py</kbd> with the code in listing 6.10.</p>
  </div>
  <div class="browsable-container listing-container" id="p370"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 6.10 time_series_chart.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import plotly.graph_objs as go
from data_wrangling import get_metric_time_series
 
def get_time_series_chart(df, metric):
  data = get_metric_time_series(df, metric)
  fig = go.Figure()
  fig.add_trace(
    go.Scatter(x=data['Day'], y=data['Value'], mode='lines+markers')
  )
 
  fig.update_layout(
    title=f"{metric.title}",
    xaxis_title='Day',
    yaxis_title=metric.title
  )
  return fig
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p371"> 
   <p>The import statement at the top makes Plotly Graph Objects available; the abbreviation <kbd>go</kbd> is conventionally used to refer to it.</p>
  </div>
  <div class="readable-text  intended-text" id="p372"> 
   <p>The <kbd>get_time_series_chart</kbd> metric takes our dataframe as well as an object of type <kbd>Metric</kbd> and returns the line chart (a Plotly <kbd>Figure</kbd> object) that we can pass later to a Streamlit widget for display.</p>
  </div>
  <div class="readable-text  intended-text" id="p373"> 
   <p>We first obtain our time series data by calling the <kbd>get_metric_time_series</kbd> function we defined earlier.</p>
  </div>
  <div class="readable-text  intended-text" id="p374"> 
   <p>Plotly charts are constructed incrementally. We start with an empty chart and add the components we need bit-by-bit. Here, the line <kbd>fig = go.Figure()</kbd> initializes the chart and assigns it to <kbd>fig</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p375"> 
   <p>The next part adds the actual line to the chart:</p>
  </div>
  <div class="browsable-container listing-container" id="p376"> 
   <div class="code-area-container"> 
    <pre class="code-area">fig.add_trace(
  go.Scatter(x=data['Day'], y=data['Value'], mode='lines+markers')
)</pre>
   </div>
  </div>
  <div class="readable-text " id="p377"> 
   <p>We're creating a <kbd>go.Scatter</kbd> object here, which represents a scatterplot. A scatterplot simply plots points on a graph with two axes (the x-axis and the y-axis). Each point has a pair of coordinates. In this case, the x-coordinates are supplied by <kbd>data['Day']</kbd>, or the dates we want to show in the chart, and the y-coordinates are in <kbd>data['Value']</kbd>, which will be the values of one of our key metrics (depending on which one the variable <kbd>metric</kbd> contains).</p>
  </div>
  <div class="readable-text  intended-text" id="p378"> 
   <p>We also pass <kbd>mode='lines+markers'</kbd>, which makes it so that in addition to plotting the points (using "markers"), Plotly also puts lines between them. The effect is that every (<kbd>Day</kbd>, <kbd>Value</kbd>) pair in our dataframe has a marker, and all the markers are connected by lines, forming the line chart we need.</p>
  </div>
  <div class="readable-text  intended-text" id="p379"> 
   <p>We then add the plot we just created to our <kbd>Figure</kbd> object by passing it to <kbd>fig.add_trace()</kbd>.</p>
  </div>
  <div class="browsable-container listing-container" id="p380"> 
   <div class="code-area-container"> 
    <pre class="code-area">fig.update_layout(
    title=f"{metric.title}",
    xaxis_title='Day',
    yaxis_title=metric.title
  )</pre>
   </div>
  </div>
  <div class="readable-text " id="p381"> 
   <p>The last part, shown above, simply adds some text to our graph, such as a title (which we get from our <kbd>Metric</kbd> object's <kbd>title</kbd> attribute, defined in <kbd>metric_config.py</kbd>), and the titles of the x- and y-axes.</p>
  </div>
  <div class="readable-text  intended-text" id="p382"> 
   <p>We now know how to create the chart we require. We still need to actually display it though, so go ahead and update <kbd>time_series_chart.py</kbd>, adding a <kbd>time_series_chart</kbd> function at the bottom and the corresponding imports at the top:</p>
  </div>
  <div class="browsable-container listing-container" id="p383"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">import plotly.graph_objs as go
<b>import streamlit as st</b>
from data_wrangling import get_metric_time_series
<b>from metric_config import metrics, display_metrics</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
...
def time_series_chart(df):
  with st.container(border=True):
    chart_tabs = st.tabs(display_metrics)
    for idx, met in enumerate(display_metrics):
      with chart_tabs[idx]:
        chart = get_time_series_chart(df, metrics[met])
        st.plotly_chart(chart, use_container_width=True)
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span></pre>
   </div>
  </div>
  <div class="readable-text " id="p384"> 
   <p>Once again, we use <kbd>st.container(border=True)</kbd> to make a box to put our line chart in.</p>
  </div>
  <div class="readable-text  intended-text" id="p385"> 
   <p>The next bit, <kbd>chart_tabs = st.tabs(display_metrics)</kbd>, introduces a new Streamlit UI widget: <kbd>st.tabs</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p386"> 
   <p>As the name suggests, <kbd>st.tabs</kbd> creates a tabbed area in your app that lets users switch between pieces of content by clicking tabs at the top. The argument to <kbd>st.tabs</kbd> is the list of tab titles to use.</p>
  </div>
  <div class="readable-text  intended-text" id="p387"> 
   <p>For instance, <kbd>st.tabs(["Home", "About us", "Careers"])</kbd> would create three tabs with the titles "Home", "About us", and "Careers".</p>
  </div>
  <div class="readable-text  intended-text" id="p388"> 
   <p>We're trying to create one tab for each metric with its respective line chart, so we can pass the variable <kbd>display_metrics</kbd> from <kbd>metric_config.py</kbd>—which, you may recall, is a list of the metrics we care about that we can use as tab titles.</p>
  </div>
  <div class="readable-text  intended-text" id="p389"> 
   <p>We define the content within a tab in the same way that we would do it for <kbd>st.column</kbd>: using the with context manager. Since <kbd>chart_tabs</kbd> now contains the list of tabs (returned by <kbd>st.tabs</kbd>), we can iterate through each list index/metric name pair (<kbd>idx, met</kbd>) in <kbd>display_metrics</kbd> and use <kbd>chart_tabs[idx]</kbd> to refer to the corresponding tab, calling <kbd>get_time_series_chart</kbd> to create the Plotly line chart for that metric.</p>
  </div>
  <div class="readable-text  intended-text" id="p390"> 
   <p>Finally, we pass the created chart to the <kbd>st.plotly_chart</kbd> element to render it on the screen:</p>
  </div>
  <div class="browsable-container listing-container" id="p391"> 
   <div class="code-area-container"> 
    <pre class="code-area">st.plotly_chart(chart, use_container_width=True)</pre>
   </div>
  </div>
  <div class="readable-text " id="p392"> 
   <p>The <kbd>use_container_width=True</kbd> ensures that the line chart expands to fill the width of the box that contains it. This prevents weird layout issues where the chart ends up being larger than the container or leaves a lot of whitespace around it.</p>
  </div>
  <div class="readable-text  intended-text" id="p393"> 
   <p>Let's now include the line chart in our main app by updating <kbd>dashboard.py</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p394"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">...
<b>from time_series_chart import time_series_chart</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
...
if main_df.empty:
  st.warning("No data to display")
else:
  metric_bar(main_df)
  <b>time_series_chart(main_df)</b></pre>
   </div>
  </div>
  <div class="readable-text " id="p395"> 
   <p>If you save and re-run the app now, you'll see your first Streamlit visualization (see figure 6.15)</p>
  </div>
  <div class="browsable-container figure-container" id="p396">  
   <img src="../Images/06__image015.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 6.15 Time series chart created using Plotly (chapter_6/in_progress_8 in the GitHub repo has the full code)</h5>
  </div>
  <div class="readable-text " id="p397"> 
   <p>Pretty, ce n'est pas? You can see the tabs and switch between them to see how each metric has changed over the given data range. Visualizations created using <kbd>st.plotly_chart</kbd> throw in a lot of useful functionality for free, such as the ability to zoom in to specific points in the chart, tooltips when you hover over specific data points, a full-screen mode, and a download button to save the image.</p>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p398"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p399"> 
    <p>We could have used radio buttons as our metric selection widget as our UI mock indicates, but I didn't want to pass up the chance to introduce st.tabs. Also, there is one important difference in how selection via st.radio and that via st.tabs works: switching between tabs does not trigger an app rerun while changing between radio button options does. This makes using tabs faster and more efficient with the tradeoff that charts for all the metrics need to be created at once, during the initial load.</p>
   </div>
  </div>
  <div class="readable-text" id="p400"> 
   <h3 class=" readable-text-h3">6.5.2 Creating a pie chart</h3>
  </div>
  <div class="readable-text " id="p401"> 
   <p>The time series chart we just created lets us identify trends over time, but we also need to be able to break a particular data point down and see what contributes to it. For instance, if we know that the total sales for the "Fountain pens" segment are $500k, it would be helpful to know that 70% of that was driven by the RoyalQuill brand, while Inkstream only accounted for 30%, or that 45% of stapler sales are from the 56+ age group.</p>
  </div>
  <div class="readable-text  intended-text" id="p402"> 
   <p>Pie charts, which illustrate the percentage breakdown of a whole into its component parts, are a good way to instantly form a picture of the data.</p>
  </div>
  <div class="readable-text  intended-text" id="p403"> 
   <p>Figure 6.16 shows the pie chart from our UI mock again.</p>
  </div>
  <div class="browsable-container figure-container" id="p404">  
   <img src="../Images/06__image016.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 6.16 The pie chart from our UI mock</h5>
  </div>
  <div class="readable-text " id="p405"> 
   <p>There are two selections you can make here: a metric for the pie chart to display, and a breakdown dimension. The metric can only be "Total sales" or "Gross margin", not "Margin %" or ATV. This is because the latter two metrics are ratios, and the corresponding dimension-wise ratios won't add up to 100%—so a pie chart does not apply.</p>
  </div>
  <div class="readable-text  intended-text" id="p406"> 
   <p>For instance, let's say the average transaction value (sales divided by transaction count) for fountain pens is $50. We can't break this down by gender and say that 60% ($30) of that comes from males and 40% ($20) comes from females. To get the ATV for males, we have to calculate the ratio by dividing total sales for males by the corresponding transaction count.</p>
  </div>
  <div class="readable-text  intended-text" id="p407"> 
   <p>Let's record this smaller list of pie-chart-applicable metrics in a new variable at the bottom of metric_config.py:</p>
  </div>
  <div class="browsable-container listing-container" id="p408"> 
   <div class="code-area-container"> 
    <pre class="code-area">pie_chart_display_metrics = ["Total sales", "Gross margin"]</pre>
   </div>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p409"> 
   <h4 class=" readable-text-h4">Getting data into the right shape</h4>
  </div>
  <div class="readable-text " id="p410"> 
   <p>Just as we wrangled our data into a date/value time series to feed it to the time series chart, we need to prepare our data for the pie chart too. The pie chart needs to know the value of our metric corresponding to each dimension value; it will do the conversion to percentages on its own.</p>
  </div>
  <div class="readable-text  intended-text" id="p411"> 
   <p>For example, consider the earlier sample data we processed into a time series earlier:</p>
  </div>
  <div class="browsable-container listing-container" id="p412"> 
   <div class="code-area-container"> 
    <pre class="code-area">+------------+-------+--------+-----------+------------+
|    Day     | State | Gender | Product   |   Sales    |
+------------+-------+--------+-----------+------------+
| 2024-08-01 |   CA  |   M    | RoyalQuill|   1500     |
| 2024-08-01 |   CA  |   M    | GripLink  |   1300     |
| 2024-08-02 |   CA  |   M    | RoyalQuill|   1600     |
| 2024-08-02 |   CA  |   M    | GripLink  |   1200     |
+------------+-------+--------+-----------+------------+
 </pre>
   </div>
  </div>
  <div class="readable-text " id="p413"> 
   <p>If we want to show a breakdown of the total sales by product, you would group by product and add up the sales:</p>
  </div>
  <div class="browsable-container listing-container" id="p414"> 
   <div class="code-area-container"> 
    <pre class="code-area">+-----------+-------------+
|  Product  |    Sales    |
+-----------+-------------+
| RoyalQuill|     3100    |
| GripLink  |     2500    |
+-----------+-------------+</pre>
   </div>
  </div>
  <div class="readable-text " id="p415"> 
   <p>This is remarkably similar to what we did earlier; the only difference is that instead of grouping by the date field, we're grouping by a particular dimension ("Product") instead.</p>
  </div>
  <div class="readable-text  intended-text" id="p416"> 
   <p>The function we'll include at the bottom of <kbd>data_wrangling.py</kbd> is thus also very similar to <kbd>get_metric_time_series</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p417"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">...
 
def get_metric_time_series(df, metric):
  grouped = df.groupby('Day')
  data = grouped.apply(metric.func, include_groups=False).reset_index()
  data.columns = ['Day', 'Value']
  return data
 
<b>def get_metric_grouped_by_dimension(df, metric, dimension):</b>
<b>  grouped = df.groupby(dimension)</b>
<b>  data = grouped.apply(metric.func, include_groups=False).reset_index()</b>
<b>  data.columns = [dimension, 'Value']</b>
<b>  return data</b></pre>
   </div>
  </div>
  <div class="readable-text " id="p418"> 
   <p>The sole distinction between the newly added <kbd>get_metric_grouped_by_dimension</kbd> and <kbd>get_metric_time_series</kbd> is that in the former, we're accepting dimension as an input and grouping by that instead of <kbd>Day</kbd>.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p419"> 
   <h4 class=" readable-text-h4">A Plotly pie chart</h4>
  </div>
  <div class="readable-text " id="p420"> 
   <p>The ever-versatile Plotly Graph Objects can also be used to create the pie chart we want. In fact, the code you'll put in <kbd>pie_chart.py</kbd> (a new file shown in listing 6.11), is closely related to that in <kbd>time_series_chart.py</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p421"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 6.11 pie_chart.py</h5>
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">import plotly.graph_objects as go
from data_wrangling import <b>get_metric_grouped_by_dimension</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
def get_pie_chart(df, metric, <b>dimension</b>):
  data = <b>get_metric_grouped_by_dimension(df, metric, dimension)</b>
  fig = go.Figure()
  fig.add_trace(
    <b>go.Pie(labels=data[dimension], values=data['Value'], hole=0.4)</b>
  )
  return fig</pre>
   </div>
  </div>
  <div class="readable-text " id="p422"> 
   <p>The differences should be fairly obvious: we use <kbd>get_metric_grouped_by_dimension</kbd> in the place of <kbd>get_metric_time_series</kbd>, and <kbd>go.Pie</kbd> instead of <kbd>go.Scatter</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p423"> 
   <p><kbd>go.Pie</kbd> accepts <kbd>labels</kbd>, which will be displayed in a color legend, <kbd>values</kbd>, and <kbd>hole</kbd>, which indicates how large the "donut hole" in the pie chart should be.</p>
  </div>
  <div class="readable-text  intended-text" id="p424"> 
   <p>We're not using<kbd> fig.update_layout()</kbd> here to set any text in the chart, since the title will simply be the tab header (which we'll get to in a second), and there are no x- or y-axes.</p>
  </div>
  <div class="readable-text  intended-text" id="p425"> 
   <p>As we did previously, we also need to write another function in <kbd>pie_chart.py</kbd> to render the image:</p>
  </div>
  <div class="browsable-container listing-container" id="p426"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">import plotly.graph_objects as go
<b>import streamlit as st</b>
from data_wrangling import get_metric_grouped_by_dimension
<b>from metric_config import metrics, pie_chart_display_metrics</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
...
def pie_chart(df):
  with st.container(border=True):
    split_dimension = st.selectbox(
      "Group by",
      ["Age group", "Gender", "State", "Category",
       "Segment", "Product name"]
    )
    metric_tabs = st.tabs(pie_chart_display_metrics)
    for idx, met in enumerate(pie_chart_display_metrics):
      with metric_tabs[idx]:
        chart = get_pie_chart(df, metrics[met], split_dimension)
        st.plotly_chart(chart, use_container_width=True)
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span></pre>
   </div>
  </div>
  <div class="readable-text " id="p427"> 
   <p>The <kbd>pie_chart</kbd> function, too, is similar to its counterpart—<kbd>time_series_chart</kbd>—from <kbd>time_series.chart.py</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p428"> 
   <p>The key difference is the added <kbd>split_dimension</kbd> variable (the dimension to break down the metric for) that we need to collect from users using <kbd>st.selectbox</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p429"> 
   <p>Everything else stays more or less analogous; we create a tab for each metric in <kbd>pie_chart_display_metrics</kbd> (that we defined in <kbd>metric_config.py</kbd>), iterate through those metrics, create the Plotly object with <kbd>get_pie_chart</kbd>, and display it using <kbd>st.plotly_chart</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p430"> 
   <p>In <kbd>dashboard.py</kbd>, we want to display the line and pie charts side-by-side, so we use <kbd>st.columns</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p431"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">...
<b>from pie_chart import pie_chart</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
...
if main_df.empty:
  st.warning("No data to display")
else:
  metric_bar(main_df)
  <b>time_series_col, pie_chart_col = st.columns(2)</b>
<b>  with time_series_col:</b>
<b>    time_series_chart(main_df)</b>
<b>  with pie_chart_col:</b>
<b>    pie_chart(main_df)</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span></pre>
   </div>
  </div>
  <div class="readable-text " id="p432"> 
   <p>With this, our dashboard's UI is complete! Re-run to see figure 6.17.</p>
  </div>
  <div class="browsable-container figure-container" id="p433">  
   <img src="../Images/06__image017.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 6.17 Our completed app, with the newly-added pie chart at the bottom right (chapter_6/in_progress_9 in the GitHub repo has the full code)</h5>
  </div>
  <div class="readable-text " id="p434"> 
   <p>We've covered a lot of ground in this chapter, and we're ready to launch our dashboard. We're not quite done with Note n' Nib though. In the next chapter, we'll see several ways in which our app can be improved-~-including usability tweaks and shifting from a static CSV file to a data warehouse.</p>
  </div>
  <div class="readable-text" id="p435"> 
   <h2 class=" readable-text-h2">6.6 Summary</h2>
  </div>
  <ul> 
   <li class="readable-text" id="p436">A metrics dashboard is an essential decision-making tool for executives.</li>
   <li class="readable-text" id="p437">Pandas is a popular Python library for manipulating tabular data in dataframes. Streamlit can display Pandas dataframes natively.</li>
   <li class="readable-text" id="p438">Use Pandas' <kbd>read_csv</kbd> function to load data from a comma-separated values (CSV) file</li>
   <li class="readable-text" id="p439">The <kbd>st.cache_data</kbd> decorator can be used to cache the results of functions to improve performance. Its <kbd>ttl</kbd> parameter sets the time period for which a cached result is valid.</li>
   <li class="readable-text" id="p440">The dataframe square bracket notation is quite versatile in Pandas; you can use them to select columns, filter rows, and more.</li>
   <li class="readable-text" id="p441"><kbd>st.container</kbd> can be used to hold other Streamlit widgets, displaying them out of order or with a border around them.</li>
   <li class="readable-text" id="p442"><kbd>st.multiselect</kbd> creates a dropdown menu where you can select multiple options.</li>
   <li class="readable-text" id="p443"><kbd>st.set_page_config</kbd> can set app configurations in Streamlit, including switching from a centered layout to a maximized one.</li>
   <li class="readable-text" id="p444"><kbd>st.date_input</kbd> can be used to display date selectors in your app.</li>
   <li class="readable-text" id="p445">The <kbd>humanize</kbd> library is useful for formatting numbers in a user-friendly way.</li>
   <li class="readable-text" id="p446">A time series is a sequence of data points, each with a date and a value.</li>
   <li class="readable-text" id="p447">The <kbd>groupby</kbd> method on Pandas dataframes can aggregate data across dimensions.</li>
   <li class="readable-text" id="p448">Plotly Graph Objects (abbreviated to <kbd>go</kbd>) is a Python library used to create visualizations that can be displayed directly by Streamlit.</li>
   <li class="readable-text" id="p449"><kbd>go.Scatter</kbd> can be used to create scatterplots and line charts, while <kbd>go.Pie</kbd> can make pie charts.</li>
   <li class="readable-text" id="p450">A data warehouse is a specialized system designed to store and retrieve large amounts of data.</li>
   <li class="readable-text" id="p451">Google BigQuery—part of GCP—is an example of a data warehouse. To enable an app to connect to it, you need to create a service account with a key, and record the credentials in <kbd>st.secrets</kbd>.</li>
  </ul>
</body>
</html>