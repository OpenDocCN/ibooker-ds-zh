- en: 3 Taking an app from concept to code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 从概念到代码的应用
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Defining the scope of an application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义应用程序的范围
- en: Designing the user interface
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计用户界面
- en: Organizing the code for an app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织应用程序的代码
- en: Streamlit's workhorse input widgets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Streamlit的工作马输入组件
- en: In my beginning days as a software engineer, I was often surprised by how much
    of my time was spent on activities other than writing code. I'd spend multiple
    days or even weeks simply understanding the problem I was trying to solve and
    even more time in design, all before typing a single line of code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我作为软件工程师的初期，我经常惊讶于我花在编写代码以外的活动上的时间有多少。我会花上好几天甚至几周的时间仅仅理解我试图解决的问题，在设计上花费的时间更多，所有这些都是在敲打第一行代码之前。
- en: At the time, I felt anxious because I didn't feel *productive*. Scribbled meeting
    notes and design docs didn't *do* anything. With time, I realized that those days
    and weeks weren't actually wasted; they made the end-product better because of
    how deeply I'd thought about what I was trying to do.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当时，我感到焦虑，因为我感觉**不 productive**。潦草的会议笔记和设计文档并没有**做**任何事情。随着时间的推移，我意识到那些日子和星期实际上并没有浪费；由于我对我要做的事情进行了深入的思考，这些日子和星期让最终产品变得更好。
- en: Likewise, this book is not *just* about teaching you to write Streamlit code.
    It's about helping you learn to develop apps in the real world. Planning and design
    are inescapable parts of this process.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这本书不仅仅是为了教你编写Streamlit代码。它是关于帮助你学习在现实世界中开发应用程序。规划和设计是这个过程中的不可避免的部分。
- en: Though we don't have weeks to spend on these topics, this chapter will give
    you a taste of the end-to-end experience of developing an app.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们没有时间来深入探讨这些主题，但本章将给你一个开发应用的端到端体验的尝鲜。
- en: We'll start with the concept for an app and convert it into a set of requirements.
    We'll then come up with a design that meets those requirements, working backwards
    from the user experience, and also think about code organization.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从应用的概念开始，将其转化为一系列需求。然后，我们将设计满足这些需求的设计方案，从用户体验出发，逆向工作，同时也要考虑代码的组织结构。
- en: Finally, we'll walk through our code and logic, introducing some of Streamlit's
    most common widgets as we go. That's a lot to get done, so let's get started!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将审查我们的代码和逻辑，在介绍过程中介绍一些Streamlit最常用的组件。有很多事情要做，所以让我们开始吧！
- en: '3.1 Concept to code: A six-step process'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 从概念到代码：六个步骤的过程
- en: Writing a piece of software can be an overwhelming task once you get past the
    initial spark of inspiration. There are so many things to consider! Where do you
    start? What features are you going to develop and how long will it take? How will
    users interact with your app? Should you start coding right away and figure it
    out as you go?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你超越了最初的灵感火花，编写软件可能是一项令人压倒性的任务。有很多事情需要考虑！你从哪里开始？你将开发哪些功能以及需要多长时间？用户将如何与你的应用互动？你应该立即开始编码并在过程中弄清楚吗？
- en: 'To quote Desmond Tutu: "There is only one way to eat an elephant: a bite at
    a time.”'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 引用德斯蒙德·图图的话：“吃大象的唯一方法：一口一口吃。”
- en: 'In creating Streamlit apps, as in consuming large land mammals, the optimal
    approach is to break it down into smaller chunks. Figure 3.1 displays a simple,
    logical six-step process you can follow while developing an app, or really just
    about any piece of software:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Streamlit应用时，就像在消费大型陆地哺乳动物一样，最佳的方法是将它分解成更小的块。图3.1显示了一个简单的、逻辑的六个步骤的过程，你可以在开发应用时遵循，或者实际上在开发任何软件时都可以遵循：
- en: '![image](../Images/03__image001.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/03__image001.png)'
- en: Figure 3.1 The six-stage app development flow
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1 六阶段应用开发流程
- en: '**State the concept:** To solve a problem—or to describe it to others—you first
    need to be able to state it succinctly at a high level.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**阐述概念**：为了解决问题——或者向他人描述它——你首先需要能够以高度概括的方式简洁地表述它。'
- en: '**Define the requirements:** This is where you refine your concept and break
    it down into cold, hard requirements. Part of this is to define the scope of what
    your app will and—perhaps more importantly—*won''t* do.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义需求**：这是你细化概念并将其分解为冷冰冰的需求的地方。这包括定义你的应用将做什么——也许更重要的是——**不会**做什么。'
- en: '**Visualize the user experience:** Draw diagrams and mocks of what your envisioned
    user''s experience will be when they use your app.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可视化用户体验**：绘制你设想的使用者在使用你的应用时的体验的图表和原型。'
- en: '**Brainstorm implementation:** What components will your solution have, how
    will they integrate with each other, and what tradeoffs do you face?'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**头脑风暴实现**：你的解决方案将包含哪些组件，它们将如何相互集成，你将面临哪些权衡？'
- en: '**Write code:** Actually implement your app.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写代码**：实际实现你的应用。'
- en: '**Iterate:** Inspect your output and refine steps 1 through 5 as necessary.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**迭代**：检查你的输出并根据需要调整步骤1至5。'
- en: 'This may sound like a lot, and you may find yourself thinking: "Is this all
    really necessary? I''m not building enterprise software in a large team, I''m
    making a fairly small app for a handful of users."'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来很多，你可能会想：“这一切真的有必要吗？我并不是在大型团队中构建企业级软件，我只是在为少数用户制作一个相当小的应用程序。”
- en: The beauty of the above steps is that you can adjust them to what makes sense
    for your project. If you're working on a large project, each of the above steps
    may take a long time since there's probably a lot of people that need to agree
    on the overall approach.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以上步骤的美丽之处在于，你可以根据项目的需求调整它们。如果你在处理一个大型项目，上述每个步骤可能都需要很长时间，因为可能有很多需要就整体方法达成一致的人。
- en: But if you're building something small, you can scale each step down to something
    more reasonable. For instance, you can define the requirements in a quick bullet-point
    list that takes maybe five minutes to generate, and your visualization of the
    user experience can be a simple sketch.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你在构建一个小型项目，你可以将每个步骤缩小到更合理的大小。例如，你可以快速列出需求，可能只需要五分钟就能完成，你的用户体验可视化可以是一个简单的草图。
- en: In the rest of this chapter, we'll go through each of these steps in the context
    of an example app.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将以一个示例应用程序的上下文来逐一介绍这些步骤。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'For much of this chapter, our attention is going to be on the end-to-end app
    development process; we''ll only cover various Streamlit elements towards the
    end when we discuss the implementation of the frontend. This is by design, to
    reflect the real world, where your primary focus in developing a graphical app
    will be the app itself, not Streamlit. That actually explains the success of Streamlit:
    it *gets out of your way* so you can develop your app without worrying too much
    about how you''re going to implement the UI.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的大部分内容中，我们的注意力将集中在端到端的应用程序开发流程上；我们将在讨论前端实现时才介绍各种Streamlit元素。这是有意为之，以反映现实世界，在开发图形应用程序时，你的主要关注点将是应用程序本身，而不是Streamlit。这也解释了Streamlit的成功：它*不会妨碍你*，这样你就可以开发应用程序而无需过多担心如何实现UI。
- en: So even though you won't see a lot of discussion about Streamlit itself in the
    beginning parts of this chapter, hang in there! We'll get to it organically where
    it fits best!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所以尽管在本书的早期部分你不会看到很多关于Streamlit本身的讨论，但请耐心等待！我们会自然而然地找到最合适的位置来介绍它！
- en: '3.2 Stating our concept: A unit converter'
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 提出我们的概念：一个单位转换器
- en: Whether it's while studying physics, cooking a meal based on a recipe, or traveling
    internationally, I'm sure you've been in situations where you've had to convert
    between different units of measurement like cups to ounces, yards to meters, and
    so on. You may have had to look up the conversion factor online and then use a
    calculator to do the actual conversion.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是在学习物理学、根据食谱烹饪一顿饭，还是在国际旅行中，我相信你一定遇到过需要在不同测量单位之间转换的情况，比如将杯转换为盎司，码转换为米等等。你可能不得不在网上查找转换系数，然后使用计算器进行实际转换。
- en: The app we'll be working on in this chapter will make this task easier and more
    streamlined.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将要工作的应用程序将使这项任务更容易、更流畅。
- en: As we discussed in the last section, the first step in the development process
    is to "state the concept,” i.e., to express the problem we're trying to solve
    succinctly, preferably in a single sentence or line.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中讨论的，开发过程的第一步是“提出概念”，即简洁地表达我们要解决的问题，最好是单句或一行。
- en: 'Here''s our concept:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的概念：
- en: Concept
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 概念
- en: A Streamlit app that allows users to effortlessly convert between different
    units of measurement like distance, mass, and time.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Streamlit应用程序，允许用户轻松地在不同的测量单位之间转换，如距离、质量和时间。
- en: Stating the concept uncovers the core of what you're trying to do and focuses
    your thinking, preventing it from wandering off in a dozen directions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 提出概念揭示了你要做的核心内容，并集中你的思考，防止你偏离数十个方向。
- en: As you're developing the app, you may hit upon various new possibilities and
    potential features to incorporate. The stated concept is there as a reference
    point to ensure that whatever changes you're considering still satisfy the core
    idea laid out in it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序的过程中，你可能会遇到各种新的可能性以及要整合的潜在功能。提出的概念作为一个参考点，确保你考虑的任何变化仍然满足其中阐述的核心思想。
- en: For instance, you might think, "Maybe I should make a unit overview page where
    I explain the history of the unit and what it was named after.” If you compare
    it to our one-line concept, you'll realize that such a page doesn't really help
    with our goal of having users convert between units effortlessly, so it's probably
    wise to drop it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能会想，“也许我应该制作一个单位概述页面，解释单位的历史以及它是以什么命名的。”如果你将它与我们的单行概念进行比较，你会发现这样的页面实际上并不帮助我们实现让用户轻松转换单位的目标，所以可能明智地将其删除。
- en: Of course, this doesn't mean that the concept you've stated is set in stone.
    If you encounter an idea that significantly enriches the experience you could
    provide the user but it doesn't fit well with the concept, feel free to re-state
    the concept.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不意味着你阐述的概念是固定不变的。如果你遇到一个可以显著丰富你为用户提供体验的想法，但它与概念不太吻合，你可以自由地重新阐述概念。
- en: Finally, stating the concept also has the benefit of giving you a one-line description
    that you can share with other people to help them understand your work. This can
    be especially valuable in helping you gain users or find collaborators to partner
    with.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，阐述概念的好处是给你提供一个可以与他人分享的一行描述，以帮助他们理解你的工作。这在你获取用户或寻找合作伙伴时特别有价值。
- en: 3.3 Defining the requirements
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 定义需求
- en: Your concept works great as a sort of mission statement for your app, but it's
    somewhat hand-wavy about the details. The next step then is to break the concept
    down into concrete *requirements* you can build towards.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你的概念作为你应用的一种使命宣言效果很好，但它对细节的描述有些模糊。接下来的步骤是将概念分解成具体的*需求*，你可以朝着这些需求去构建。
- en: Think of these as the specific list of things your *stakeholders* (your users,
    teams that you work with, etc.,) would want the app to do.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些视为你的利益相关者（你的用户、你合作的团队等）希望应用执行的具体事项列表。
- en: 'Requirements should:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 需求应：
- en: express a capability the app should have
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达应用应具备的能力
- en: be free of "implementation" language, e.g., it should not refer to any technology
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用“实现”语言，例如，不应提及任何技术
- en: For an app you're building in real life, coming up with the list of requirements
    might involve interviewing people to understand their needs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你在现实生活中构建的应用程序，制定需求列表可能需要通过采访人们来了解他们的需求。
- en: 'For the purposes of our example, here''s the list of requirements we want to
    center our app around:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的示例，以下是我们要围绕应用中心化的需求列表：
- en: 'Requirements:'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 需求：
- en: The user should be able to enter a numeric quantity and the unit the quantity
    is in (the "from-unit").
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应能够输入一个数值数量及其单位（“源单位”）。
- en: The user should be able to select a unit to convert to (the "to-unit"), which
    must measure the same type of thing as the from-unit. No converting from pounds
    to yards, for instance.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应能够选择要转换到的单位（“目标单位”），该单位必须测量与“源单位”相同类型的事物。例如，不能从磅转换为码。
- en: The app should display the converted value as output.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用应显示转换后的输出值。
- en: The app should be able to handle conversions within the imperial or metric systems
    (e.g., feet to inches or meters to centimeters), and across metric systems (e.g.,
    feet to meters).
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用应能够处理英制或公制系统内的转换（例如，英尺到英寸或米到厘米），以及跨公制系统的转换（例如，英尺到米）。
- en: Adding new units or quantities to the app should be straightforward.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向应用中添加新的单位或数量应该是直接的。
- en: Notice how the above points are a lot more concrete than our initial concept.
    Also note how requirements don't just come from the user; they can also come from
    other people.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到上述要点比我们最初的构想要具体得多。同时，请注意需求不仅仅来自用户；它们也可以来自其他人。
- en: To elaborate, the first four requirements listed above are things that the *user*
    wants, while the last one is something that makes life easier for the *developer*
    or *maintainer* as you'd want to minimize the time you spend in responding to
    common requests like adding another unit of measurement to the app.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了详细说明，上述列出的前四个需求是用户想要的东西，而最后一个是为了让开发者或维护者生活更轻松，因为你希望尽量减少在响应常见请求（如向应用添加另一个测量单位）上花费的时间。
- en: In an organizational setting, you can also imagine requirements from other stakeholders,
    such as the analytics team ("we should be able to monitor and track usage of the
    app") or the monetization tram ("the app should allow the user to subscribe for
    a monthly fee").
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在组织环境中，你也可以想象来自其他利益相关者的需求，例如分析团队（“我们应该能够监控和跟踪应用的用量”）或货币化团队（“应用应允许用户以月费订阅”）。
- en: You may have realized that the requirements don't mention anything about the
    *technology* used to accomplish them. For example, they don't say "the app should
    display a Streamlit button the user can click to perform the conversion.”
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经意识到，需求没有提到实现它们的*技术*。例如，它们没有说“应用应该显示一个用户可以点击以执行转换的Streamlit按钮”。
- en: This is intentional; requirements are about what stakeholders actually need.
    How you fulfill them is up to you, the developer.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是故意的；需求是关于利益相关者实际需要的内容。如何实现它们取决于你，开发者。
- en: 3.3.1 Defining what the app won't do
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 定义应用不会做什么
- en: While listing the requirements is an important step that provides clear goals
    to accomplish, it can sometimes feel like you're spelling out the obvious. In
    practice, there's value in doing it even if that's the case because what's obvious
    to you may not be obvious to your users or your collaborators. It's quite common
    for people to form a picture in their head about what you're promising that bears
    no resemblance to reality.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然列出需求是一个重要的步骤，它为完成目标提供了清晰的指导，但有时可能会感觉你只是在重复显而易见的事情。在实践中，即使如此，做这件事也是有价值的，因为对你来说显而易见的事情可能对你的用户或合作伙伴来说并不明显。人们常常会在脑海中形成一个关于你所承诺的内容的图像，这与现实毫不相干。
- en: For that reason, it's vital—and possibly more enlightening—to also define what's
    *not* in your app's scope.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，定义不在应用范围内的内容同样至关重要——可能更有启发性。
- en: For the unit conversion app in this chapter, we want to keep things as simple
    as possible because we don't want to spend too much time on it; we're mainly building
    it to get familiar with Streamlit.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中的单位转换应用，我们希望尽可能保持简单，因为我们不希望在这上面花费太多时间；我们主要构建它是为了熟悉Streamlit。
- en: Any sort of auxiliary functionality that doesn't directly relate to the goal
    of unit conversion is then immediately out. We don't want to build any usage logging
    or fancy visualizations.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 任何与单位转换目标无直接关系的辅助功能都应立即排除。我们不希望构建任何使用跟踪或复杂的可视化。
- en: We should also try to keep our conversion logic simple. Converting from pounds
    to kilograms is easy enough since you can bake the conversion factor into your
    app, but how about, say, currencies?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该尝试保持我们的转换逻辑简单。从英镑转换成千克很容易，因为你可以将转换因子嵌入到你的应用中，但比如说货币呢？
- en: Converting from dollars to euros is hard because the exchange rate changes from
    day to day, or even from hour to hour. To incorporate that, you'd need to read
    the exchange rates from somewhere, like an online API. We'll read from an API
    in later projects in this book, but for now, it's probably best to avoid the additional
    complexity. So currencies are out.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从美元转换成欧元很难，因为汇率每天甚至每小时都在变化。为了包含这一点，你需要从某处读取汇率，比如在线API。我们将在本书后面的项目中从API读取，但就目前而言，最好避免额外的复杂性。所以货币被排除在外。
- en: 'To state it formally:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正式来说：
- en: What's out of scope
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 范围之外的内容
- en: Usage tracking, logging, visualizations etc., that do not directly relate to
    unit conversion
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用跟踪、日志记录、可视化等，这些与单位转换无直接关系
- en: Conversions between units that don't share a simple, constant conversion factor,
    such as those between currencies
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之间没有简单、恒定的转换因子，如货币之间的转换
- en: This can be a useful tool for prioritization and phasing. Even if you're placing
    something out of scope at the moment, you may want to build it later on.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是一个有用的工具，用于优先级排序和分阶段实施。即使你现在将某些内容排除在范围之外，你也可能希望在以后构建它们。
- en: Articulating the requirements and scope lets you express what features you consider
    to be priority and which ones you might want to push to a future version.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 明确需求和范围让你可以表达你认为优先考虑的功能，以及你可能希望推迟到未来版本的功能。
- en: If you have additional stakeholders, having these written down is a good way
    to elicit feedback and start a conversation about prioritization.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还有其他利益相关者，将这些内容写下来是征求反馈和开始关于优先级对话的好方法。
- en: 3.4 Visualizing the user experience
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 可视化用户体验
- en: So far, we've spent a fair amount of time thinking about the problem we want
    to solve; we've conceptualized what we'll be building, refined our understanding
    of what our app needs to do, and even articulated what it *won't* do.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经花了不少时间思考我们想要解决的问题；我们已经概念化了我们将要构建的内容，细化了我们对我们应用需要做什么的理解，甚至明确了我们*不会*做什么。
- en: What we haven't done yet is to start designing a solution. That's what we'll
    do in this next step.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有开始设计解决方案。这正是我们接下来要做的。
- en: When you start the process of actually developing an app, you may find yourself
    wondering what to do first. Do you simply start coding your Python app from top
    to bottom, figuring out your design as you go? Do you try to figure out what the
    basic components of your app are and how they'll fit together? Or maybe you work
    on what you think will be the hardest part of the problem to get it out of the
    way?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始实际开发应用程序的过程时，你可能发现自己想知道先做什么。你是简单地从上到下编写你的Python应用程序代码，边做边设计吗？或者你试图弄清楚应用程序的基本组件以及它们如何组合在一起？或者你可能专注于你认为将是问题中最困难的部分，以便将其排除在外？
- en: Those are all valid approaches and there are arguments to be made in favor of
    each of them. One approach I've always found valuable, and the one we'll follow
    in this chapter, is to *work backwards from the user experience*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是有效的方法，并且可以为每种方法提出论据。我一直认为一种方法非常有价值，我们将在本章中采用这种方法，那就是*从用户体验开始倒推*。
- en: Beginning from the user experience is a good way of ensuring the quality of
    the end product, because it puts the user front and center, directly addressing
    their needs and preferences. It also helps identify and solve potential usability
    issues early on in the process.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户体验开始是一个确保最终产品质量的好方法，因为它将用户置于首位，直接满足他们的需求和偏好。它还有助于在早期过程中识别和解决潜在的可用性问题。
- en: 3.4.1 Creating a mock
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 创建模拟
- en: So what experience do we want the users of our app to have? To answer that,
    let's create a mock or sketch of what the UI might look like.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们希望我们的应用程序用户有什么样的体验？为了回答这个问题，让我们创建一个模拟或草图，看看UI可能看起来像什么。
- en: Looking back at the requirements we enumerated in section 3.3, at its core,
    the app needs to provide a way for users to input a numeric quantity and the units
    to convert from and to.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们在3.3节中列出的需求，其核心是，应用程序需要提供一种方式，让用户输入数值量以及要转换的单位和目标单位。
- en: Figure 3.2 shows a quick initial sketch.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2显示了一个快速的初步草图。
- en: '![image](../Images/03__image002.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/03__image002.png)'
- en: Figure 3.2 An initial mock of the unit conversion app
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.2 单位转换应用程序的初步模拟
- en: 'Figure 3.2 shows a first attempt at a UI design. It''s quite simple: there''s
    a box where you can type in the value to convert, and you can choose the from-
    and to- units from a select box. Once you''re done you click a "Convert" button
    and the answer appears below.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2显示了UI设计的第一次尝试。它相当简单：有一个框，你可以输入要转换的值，你可以从选择框中选择“从”单位和“到”单位。完成之后，你点击“转换”按钮，答案就会出现在下面。
- en: You can make a diagram like this with a pen and paper, a marker and whiteboard,
    or any graphics program you prefer. It doesn't really have to be elaborate or
    even particularly neat. The important thing is that it should show the end outcome
    you're trying to create, forcing you to think about your app from the user's perspective.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用笔和纸、记号笔和白板，或者你喜欢的任何图形程序制作这样的图表。它实际上不需要太复杂，甚至不需要特别整洁。重要的是它应该显示你试图创建的最终结果，迫使你从用户的角度思考你的应用程序。
- en: 3.4.2 Getting the user experience right
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2 确保用户体验正确
- en: Let's take a closer look at our mock. There are select boxes to pick a from-
    unit and a to- unit, but what if the units aren't compatible? What if the user
    chooses "Pounds" (a unit of mass) as the from-unit and "Feet" (which measures
    length) as the to-unit and tries to convert between them (see figure 3.3)?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们的模拟。这里有一些选择框来选择一个“从”单位和“到”单位，但如果这些单位不兼容怎么办？如果用户选择“磅”（质量单位）作为“从”单位，而选择“英尺”（测量长度）作为“到”单位，并尝试在它们之间进行转换（见图3.3）？
- en: '![image](../Images/03__image003.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/03__image003.png)'
- en: Figure 3.3 Our initial UI makes it possible for users to select incompatible
    units, like "Pounds" to "Feet"
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.3 我们最初的UI允许用户选择不兼容的单位，如“磅”到“英尺”
- en: You could display an error message, of course. That would work, but it wouldn't
    be a great experience for the user. Users generally like their experience to be
    as frictionless as possible, and they *hate* getting errors. A better UI would
    render it impossible to make the mistake in the first place.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以显示一个错误消息。这会起作用，但这对用户来说可能不是一次很好的体验。用户通常希望他们的体验尽可能无摩擦，他们*讨厌*收到错误。更好的UI将使最初犯错误变得不可能。
- en: For example, perhaps when the user selects "Pounds,” we could narrow the options
    in the to-unit dropdown to only units that are compatible with pounds (see figure
    3.4).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当用户选择“磅”时，我们可以将“到”单位的下拉菜单中的选项缩小到仅与磅兼容的单位（见图3.4）。
- en: '![image](../Images/03__image004.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/03__image004.png)'
- en: Figure 3.4 We could update the to-unit dropdown to only show units compatible
    with the selected from-unit
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.4 我们可以将目标单位下拉菜单更新为只显示与所选源单位兼容的单位
- en: That solves the incompatible-units problem, but may introduce another issue.
    What if the user wants to select the *to-unit* first? We could potentially apply
    the reverse logic and update the from-unit list to only contain units compatible
    with the selected to-unit. Essentially, whatever unit is selected first, the other
    dropdown is restricted to units compatible with that one, as seen in figure 3.5.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就解决了不兼容单位的问题，但可能会引入另一个问题。如果用户想要首先选择目标单位怎么办？我们可以潜在地应用反向逻辑，并更新源单位列表，使其只包含与所选目标单位兼容的单位。本质上，无论先选择哪个单位，另一个下拉菜单都限制为与该单位兼容的单位，如图3.5所示。
- en: '![image](../Images/03__image005.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/03__image005.png)'
- en: 'Figure 3.5 Two-way restriction: When a unit is selected, the other dropdown
    updates to only show compatible units'
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.5 双向限制：当选择一个单位时，另一个下拉菜单更新为只显示兼容的单位
- en: But what if the user *now* wants to do a conversion between units of a different
    quantity altogether, say a length conversion from feet to inches?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果用户现在想要在完全不同的量单位之间进行转换，比如从英尺到英寸的长度转换呢？
- en: When they try to select "Feet" in the from-unit list, they find it's not in
    the list any more, because the from-unit is artificially restricted to only units
    of mass by the selection in the to-unit dropdown, which says "Kilograms" (see
    figure 3.6).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当他们尝试在源单位列表中选择“英尺”时，他们会发现它不再列表中，因为源单位被目标单位下拉菜单中的选择人为地限制为只有质量单位，该下拉菜单显示“千克”（见图3.6）。
- en: '![image](../Images/03__image006.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/03__image006.png)'
- en: Figure 3.6 Prior selections create a confusing experience because the user can't
    now select units from other quantities
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.6 前面的选择会创建一个令人困惑的体验，因为用户现在无法从其他量中选择单位
- en: There are multiple ways to fix this.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以解决这个问题。
- en: We could enforce a rule that the user has to select a from-unit first. This
    feels like a somewhat artificial restriction though, and not one that's inherent
    to the business problem.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以强制执行一条规则，即用户必须首先选择源单位。但这感觉有点人为的限制，并不是业务问题的固有属性。
- en: We could instead introduce a reset button for the user to click whenever they
    want to start a new conversion, resetting both dropdowns. This works and isn't
    *terrible* but it seems like a lot of work for the user.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以引入一个重置按钮，用户可以在想要开始新的转换时点击，重置两个下拉菜单。这可以工作，而且并不算太糟糕，但似乎对用户来说工作量很大。
- en: The most intuitive way to handle this would be to simply add another input for
    the type of quantity the user wants to convert. If the user selects "Mass" in
    this new dropdown, for example, the from- and to- units would only have units
    of mass as seen in figure 3.7\. Thus, instead of restricting the dropdowns based
    on each other, we restrict them based on a third external selection.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题最直观的方法是简单地为用户想要转换的量类型添加另一个输入。例如，如果用户在这个新的下拉菜单中选择“质量”，那么源单位和目标单位将只显示质量单位，如图3.7所示。因此，我们不是根据下拉菜单之间的相互关系来限制它们，而是根据第三个外部选择来限制它们。
- en: '![image](../Images/03__image007.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/03__image007.png)'
- en: Figure 3.7 Adding a quantity-type selector makes the app more intuitive
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.7 添加量类型选择器使应用程序更直观
- en: 'This solves the issue much more elegantly while being quite intuitive to the
    user. It''s obvious what the user needs to do here: pick a quantity, enter a value,
    pick the from- and to- units and click "Convert.”'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这以一种非常优雅的方式解决了问题，同时用户界面也非常直观。用户需要做什么一目了然：选择一个量，输入一个值，选择源单位和目标单位，然后点击“转换”。
- en: Note that while figure 3.7 shows radio buttons for the quantity type, we could
    have gone with a dropdown too. The radio button switches things up a bit and involves
    one less click than a dropdown, but the experience with a dropdown isn't significantly
    worse. In any case, when you actually get to the implementation using Streamlit,
    you may identify entirely new possibilities for how to present inputs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然图3.7显示了量类型的选择按钮，我们也可以使用下拉菜单。选择按钮稍微改变了事情，并且比下拉菜单少一个点击，但使用下拉菜单的体验并不明显更差。无论如何，当您实际使用Streamlit进行实现时，您可能会发现如何呈现输入的新可能性。
- en: I hope this gives you an understanding of how to start designing a UI and some
    of the tradeoffs involved. There will, of course, always be more factors we *could*
    concern ourselves with—for example, does our user care about imperial vs metric
    system units and should our UI differentiate between them in some way?—but this
    is already a solid foundation we can feel comfortable with.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这能让你了解如何开始设计UI以及其中的一些权衡。当然，我们总会关心更多因素——例如，用户是否关心英制和公制系统单位，我们的UI是否应该以某种方式区分它们？——但这已经是一个我们可以感到舒适的坚实基础。
- en: We've done a fair amount of refinement to our UI, but you still shouldn't feel
    that it's necessarily final. As we dive deeper into implementation, you may find
    more optimizations you'd like to make. In fact, we'll encounter some of these
    in the following sections and iterate upon our design.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对我们的UI进行了相当多的细化，但你仍然不应该觉得它一定是最终的。随着我们深入实施，你可能会发现更多你想做的优化。实际上，我们将在接下来的章节中遇到一些这些优化，并对我们的设计进行迭代。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Since you'll be implementing your UI design using Streamlit, a natural question
    that might arise while visualizing the user experience is whether you should keep
    in mind the various elements available in Streamlit so you don't design something
    you can't actually build.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你将使用Streamlit来实现你的UI设计，在可视化用户体验时可能会出现的一个自然问题是，你是否应该考虑Streamlit中可用的各种元素，这样你就不会设计出无法实际构建的东西。
- en: In my opinion, that's putting the cart before the horse. In the ideal world,
    you want to figure out the best experience for your users, and then *implement*
    it using Streamlit. You don't want to let Streamlit limit your thinking about
    what the ideal user experience looks like.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，这是本末倒置。在理想的世界里，你想要弄清楚用户最佳体验，然后使用Streamlit*实现*它。你不希望让Streamlit限制你对理想用户体验的想法。
- en: Of course, this carries some risk; you may, on rare occasions, find that Streamlit
    doesn't have the exact elements that you were hoping for in your design, and need
    to adjust your implementation. But that will actually enrich your learning journey
    by making Streamlit's deficiencies clearer. It will also ensure your user experience
    won't be constrained by your preconceptions of Streamlit's feature set, which
    is expanding all the time.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这也存在一些风险；在罕见的情况下，你可能会发现Streamlit没有你设计中所期望的精确元素，需要调整你的实现。但实际上，这会通过使Streamlit的不足更加明显来丰富你的学习之旅。它还将确保用户体验不会受到你对Streamlit功能集预设的约束，而Streamlit的功能集一直在不断扩展。
- en: 3.5 Brainstorming the implementation
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 实施方案构思
- en: We now know roughly what the end-user experience in our app will be like. Let's
    turn our attention to making that experience happen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在大致知道了我们应用中最终用户的体验将是什么样的。让我们把注意力转向让这种体验成为现实。
- en: In this step of the process, we'll enumerate the various parts of our solution,
    discuss how they fit together, and map out the flow of logic.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程的这一步，我们将列举我们解决方案的各个部分，讨论它们如何配合，并绘制逻辑流程图。
- en: 'There are two big parts to pretty much any application: a frontend and a backend.
    The frontend handles how the user interacts with your app, i.e., how we collect
    inputs and display outputs. The backend is the app''s "brain" that takes inputs
    from the frontend, processes them, and hands the output to the frontend to display
    to the user.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何应用程序都有两个主要部分：前端和后端。前端处理用户如何与你的应用交互，即我们如何收集输入并显示输出。后端是应用的“大脑”，它从前端接收输入，处理它们，并将输出交给前端以显示给用户。
- en: Based on the last section, we already have a fair idea of what the frontend
    of our app looks like; we just need to translate the UI to the corresponding elements
    available in Streamlit, which we'll do in our code walkthrough.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上一节，我们已经对应用的前端有了相当的了解；我们只需要将UI翻译成Streamlit中相应的元素，我们将在代码讲解中完成这一步。
- en: We'll therefore turn our attention to the backend, starting with the actual
    unit conversion.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将把注意力转向后端，从实际的单位转换开始。
- en: 3.5.1 Performing the actual unit conversion
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.1 执行实际的单位转换
- en: Let's say we want to convert 5 pounds (lbs) to ounces (oz). From an online search
    (I grew up with the metric system), 1 pound equals 16 oz.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将5磅（lbs）转换为盎司（oz）。通过在线搜索（我是在公制系统中长大的），1磅等于16盎司。
- en: Thus, to convert 5 lb to oz, we would multiply 16 by 5 to get 80 oz.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要将5磅转换为盎司，我们需要将16乘以5得到80盎司。
- en: We'll refer to the number 16 here as the *lb-to-oz conversion factor.*
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把数字16称为*磅到盎司转换系数*。
- en: Every pair of units has a similar conversion factor. For instance, 1 yard equals
    3 feet, so the yard-to-foot conversion factor is 3\. To take an imperial-to-metric
    example, 1 mile equals 1.609344 km, so the mile-to-km conversion factor is 1.609344.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每一对单位都有一个类似的转换系数。例如，1码等于3英尺，因此码到英尺的转换系数是3。以英制到公制的例子来说，1英里等于1.609344公里，因此英里到公里的转换系数是1.609344。
- en: To state this generally, given any pair of units X and Y, to convert a given
    value expressed in X to Y,
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了一般性地说明，对于任何一对单位X和Y，要将用X表示的给定值转换为Y，
- en: Value in unit Y = Value in unit X * X-to-Y conversion factor
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 单位Y中的值 = 单位X中的值 * X到Y的转换系数
- en: To do the reverse conversions (e.g., ounces to pounds), you can use a conversion
    factor calculated as 1 divided by the original conversion factor.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行反向转换（例如，盎司到磅），你可以使用计算为原始转换系数倒数的转换系数。
- en: So,
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，
- en: 1 yard = 3 feet; 1 foot = ⅓ yards; foot-to-yard conversion factor = ⅓1 mile
    = 1.609344 km; 1 km = 1/1.609344 = 0.621372 miles; km-to-mile conversion factor
    = 0.621372
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 1码 = 3英尺；1英尺 = ⅓码；英尺到码的转换系数 = ⅓1英里 = 1.609344公里；1公里 = 1/1.609344 = 0.621372英里；公里到英里的转换系数
    = 0.621372
- en: With this information, it seems like all we need to do is to collect the conversion
    factor for every pair of possible units within a quantity type, and apply the
    formula given above.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些信息，似乎我们只需要收集一个数量类型中所有可能单位对之间的转换系数，并应用上述公式。
- en: 'But there''s a problem: we could end up with a lot of conversion factors to
    keep track of.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有一个问题：我们可能会遇到很多需要跟踪的转换系数。
- en: 'Let''s say that we want users to be able to convert between 3 units: pounds,
    kilograms, and ounces'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想让用户能够在3个单位之间进行转换：磅、千克和盎司
- en: 'There are 3 x (3-1) = 3 x 2 = 6 possible types of conversions that can be done:
    pounds to kilograms, kilograms to pounds, pounds to ounces, ounces to pounds,
    ounces to kilograms, and kilograms to ounces.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有3 x (3-1) = 3 x 2 = 6种可能的转换类型可以进行：磅到千克，千克到磅，磅到盎司，盎司到磅，盎司到千克，以及千克到盎司。
- en: This means we need to keep track of 6 conversion factors. From our discussion
    above, we've seen that if we know the X-to-Y conversion factor, then the Y-to-X
    conversion factor is simply 1 divided by the X-to-Y conversion factor. Using this,
    we can whittle down the number of conversion factors we need to keep track of
    from 6 to 6 / 2 = 3.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要跟踪6个转换系数。从我们上面的讨论中，我们已经看到，如果我们知道X到Y的转换系数，那么Y到X的转换系数就是X到Y转换系数的倒数。利用这一点，我们可以将需要跟踪的转换系数数量从6个减少到6
    / 2 = 3个。
- en: In general, if you have n units, to be able to convert between any pair of them,
    we would need n (n-1) / 2 conversion factors.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，如果你有n个单位，为了能够在任意一对单位之间进行转换，我们需要n (n-1) / 2个转换系数。
- en: Our example above didn't seem too bad. But what if we have a lot more than 3
    units of a particular quantity type? What if we have 20?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面的例子看起来并不太糟糕。但如果我们有超过3个单位的特定数量类型怎么办？如果我们有20个呢？
- en: In this scenario, we would need to keep track of 20 * (20-1) / 2 = 20 * 19 /
    2 = 190 conversion factors. Whew! That's a *lot* of numbers to track in your code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要跟踪20 * (20-1) / 2 = 20 * 19 / 2 = 190个转换系数。哇！这需要跟踪的数字太多了。
- en: 'But isn''t 20 units for a single quantity type a little extreme? Not really.
    Take distance or length. If you count the metric system''s prefixes that signify
    magnitude and include units used in astronomy or navigation, you''ll come up with
    something like the following list:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于单一数量类型的20个单位来说，这有点极端吗？其实并不。以距离或长度为例。如果你计算表示量级的公制系统前缀，以及在天文学或导航中使用的单位，你会得到以下列表：
- en: kilometers, meters, decimeters, centimeters, millimeters, micrometers, nanometers,
    angstroms, inches, feet, yards, miles, furlongs, astronomical units, parsecs,
    light years, nautical miles, fathoms, leagues, cubits, picometers, decameters,
    hectometers… you get the picture.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 千米、米、分米、厘米、毫米、微米、纳米、埃、英寸、英尺、码、英里、英里、天文单位、秒差距、光年、海里、英寻、里、肘、皮米、分米、百米…你懂的。
- en: Clearly, keeping track of conversion factors for every single pair of units
    is not sustainable.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，跟踪每一对单位的转换系数是不可持续的。
- en: Instead, what we want to do is to designate one unit from each quantity as the
    *standard unit* for that quantity and only keep track of conversion factors to
    that unit from all the others.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们想要做的是为每个数量指定一个单位作为该数量的*标准单位*，并且只跟踪从所有其他单位到该单位的转换系数。
- en: For instance, if we make meters the standard unit for distance, we would only
    keep track of the conversion factor from each unit to meters, i.e. "what is the
    value 1 in this unit in meters?"
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们将米作为距离的标准单位，我们只需跟踪每个单位到米的转换系数，即“在这个单位中1的值是多少米？”
- en: Then, to convert from unit X to unit Y, we could convert from unit X to meters
    and then from meters to unit Y.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要从单位X转换为单位Y，我们可以先从单位X转换为米，然后再从米转换为单位Y。
- en: 'So if we want to convert 5 yards to centimeters:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们想将5码转换为厘米：
- en: Yard-to-meter conversion factor = 0.9144
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 码到米转换系数 = 0.9144
- en: Centimeter-to-meter conversion factor = 0.01
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 厘米到米转换系数 = 0.01
- en: 'We can then follow a two-step conversion process (see figure 3.8):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以遵循两步转换过程（见图3.8）：
- en: 5 yards = 5 x 0.9144 meters = 4.572 meters
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5码 = 5 x 0.9144米 = 4.572米
- en: 4.572 meters = 4.572 x 1 / 0.01 centimeters = 457.2 centimeters
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4.572米 = 4.572 x 1 / 0.01厘米 = 457.2厘米
- en: '![image](../Images/03__image008.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/03__image008.png)'
- en: Figure 3.8 Converting from yards to centimeters using meters as a standard intermediate
    unit
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.8 使用米作为标准中间单位将码转换为厘米
- en: Notice that since we always store the conversion factor of a unit *to* meters,
    in step 2, we had to divide 1 by the factor to get the reverse conversion factor,
    i.e., meter-to-centimeter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们总是存储单位到米的转换系数，在步骤2中，我们必须除以系数以获得反向转换系数，即米到厘米。
- en: Putting this more generally, given a pair of units X and Y and a standard unit
    S, to convert a value expressed in X to Y,
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 更普遍地说，给定一对单位X和Y以及一个标准单位S，要将用X表示的值转换为Y，
- en: Value in unit S = Value in unit X * X-to-S conversion factorValue in unit Y
    = Value in unit S * 1 / Y-to-S conversion factor
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 单位S中的值 = 单位X中的值 * X到S转换系数单位Y中的值 = 单位S中的值 * 1 / Y到S转换系数
- en: 'We now end up with a much more manageable number of conversion factors: since
    we only care about how many standard units a given unit is, we can get away with
    storing just one factor per unit.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有一个更易于管理的转换系数数量：因为我们只关心给定单位有多少标准单位，所以我们只需为每个单位存储一个系数。
- en: 3.5.2 Tracking units and conversion factors
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.2 跟踪单位和转换系数
- en: Recall that one of our original requirements is that adding new units to the
    app must be straightforward.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们最初的要求之一是向应用程序添加新单位必须简单明了。
- en: When we speak of "adding new units" here, we're referring to us updating the
    app to include more conversion units to convert between, not the user being able
    to dynamically add units themselves.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提到“添加新单位”时，我们是指我们更新应用程序以包括更多的转换单位进行转换，而不是用户能够动态地添加单位。
- en: This is an example of a *non-user requirement*. Our user presumably does not
    care about how easy it is for us to add new units; they care that the units are
    available for them to convert between. So who *does* care? The developer does.
    *We* do.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个**非用户需求**的例子。我们的用户可能并不关心我们添加新单位有多容易；他们关心的是单位是否可供他们进行转换。那么，谁**会**关心呢？开发者会。**我们**会。
- en: As a developer, you're usually never done with a piece of software once you've
    launched it. If your app is used by enough people, you can count on a consistent
    stream of feedback, reported bugs, and requested features coming your way and
    eating up the time that you were planning to spend on other projects. Or worse,
    someone *else* will be tasked with maintaining your code, and they'll have no
    idea how it works.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，一旦你发布了软件，你通常永远不会完成它。如果你的应用程序被足够多的人使用，你可以期待持续不断的反馈、报告的bug和请求的功能源源不断地到来，并消耗你原本计划用于其他项目的时光。或者更糟糕的是，有人**其他**人将负责维护你的代码，而他们将不知道它的工作原理。
- en: In this situation, if you haven't designed your app's implementation for ease
    of maintenance, someone will have to spend a significant amount of time digging
    through your code to figure out the right place to make a change and make sure
    there are no side-effects. Even if you're not feeling particularly charitable
    towards other developers, there's always the likelihood that the *someone* will
    be you. Speaking from personal experience, you'd be surprised at how little you'll
    remember about the code you wrote as recently as a month ago.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果你没有为应用程序的实现设计易于维护，那么有人将不得不花费大量时间挖掘你的代码，以找出正确的更改位置并确保没有副作用。即使你对其他开发者并不特别慷慨，也总是有可能那个人**就是**你。从个人经验来说，你会惊讶于你甚至一个月前写的代码你记得有多少。
- en: Coming back to our unit converter, one of the most common maintenance tasks
    you might need to perform is to add new units, and we want to make that as simple
    as possible. Ideally, there should be exactly one place in the code where you'd
    need to add the unit and its conversion factor, and it should be the most obvious
    place.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的单位转换器，你可能需要执行的最常见的维护任务之一是添加新单位，我们希望使其尽可能简单。理想情况下，代码中应该只有一个地方需要添加单位及其转换系数，并且它应该是最明显的地方。
- en: A good way to achieve this is to keep a master list of all quantities, units
    and conversion factors in a single configuration file. The file should have an
    obvious format, and adding a new unit should be as easy as appending a few lines
    in the file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的有效方法是将所有量、单位和转换系数的列表保存在一个单独的配置文件中。该文件应具有明显的格式，添加新单位应像在文件中追加几行一样简单。
- en: Critically, this configuration file should be the *only* file that refers to
    any specific quantities. That means that no other places in the app should refer
    to specific quantities or units, like meters or pounds. That's because if they
    did, adding a new quantity or unit would require updating that part of the code
    too, which breaks our requirement of it being straightforward to update the code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的是，这个配置文件应该是*唯一*引用任何特定量的文件。这意味着应用中的其他地方不应引用特定的量或单位，如米或磅。这是因为如果它们这样做，添加新量或单位将需要更新代码的这一部分，这违反了我们要求代码易于更新的要求。
- en: 'This has an interesting implication: we can''t hard-code quantities or units
    into our UI code at any point. Everything related to specific quantities or units
    needs to be pulled from the configuration file. The rest of our code needs to
    be independent of them.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个有趣的含义：我们任何时候都不能在我们的UI代码中硬编码量或单位。与特定量或单位相关的所有内容都需要从配置文件中提取。我们的其余代码需要与它们独立。
- en: We'll see how to do this in our code walkthrough later in the chapter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面的代码演练中看到如何做到这一点。
- en: 3.5.3 Mapping the flow of logic
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.3 逻辑流程映射
- en: 'We now have a good understanding of all of the individual pieces of our app:
    the frontend, the conversion logic, and the configuration.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对应用的所有单个部分都有了很好的理解：前端、转换逻辑和配置。
- en: Before we code them up, it's useful to have a mental model of how they fit together.
    Figure 3.9 shows the overall design of our app.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写代码之前，有一个如何将它们组合在一起的心理模型是有用的。图3.9展示了我们应用的整体设计。
- en: '![image](../Images/03__image009.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/03__image009.png)'
- en: Figure 3.9 Overall design and logic flow for our unit conversion app
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.9 我们单位转换应用的整体设计和逻辑流程
- en: The configuration file that we discussed in the previous section powers the
    quantity selector radio buttons from the UI we visualized earlier (figure 3.10).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中讨论的配置文件为从我们之前可视化的UI（图3.10）中的量选择单选按钮提供动力。
- en: '![image](../Images/03__image010.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/03__image010.png)'
- en: Figure 3.10 Quantity selector radio buttons from our mocks
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.10 来自我们模拟的量选择单选按钮
- en: Once the user has selected a quantity, the from- and to- unit dropdowns update
    based on the selected quantity (again powered by the configuration file).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户选择了量，从单位和到单位下拉列表将根据所选量更新（同样由配置文件提供动力）。
- en: When the user has selected the from- and to- units and clicked the "Convert"
    button, all entries are sent to the backend where the conversion factors from
    the configuration are used to perform the two-step conversion outlined in section
    3.5.1.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择了从单位和到单位并点击“转换”按钮后，所有条目都会发送到后端，在那里使用配置中的转换系数执行第3.5.1节中概述的两步转换。
- en: The converted value is then returned to the frontend where the user can see
    it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 转换后的值随后返回到前端，用户可以查看它。
- en: 3.5.4 The backend API
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.4 后端API
- en: There's a key concept in software development called *separation of concerns*.
    In essence, this means that each building block in a piece of software should
    focus on one aspect of the overall system's functionality, and should be independent
    of the other building blocks. Where a block interacts with another, it should
    do so in strictly controlled ways as defined by a *contract*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中有一个关键概念叫做*关注点分离*。本质上，这意味着软件中的每个构建块都应该关注整体系统功能的一个方面，并且应该独立于其他构建块。当一个块与另一个块交互时，它应该按照由*契约*定义的严格受控的方式进行交互。
- en: To understand this better, consider how a drive-in fast food restaurant might
    operate. There's a person at the front taking orders from customers and a kitchen
    that prepares the food based on a menu. The order-taker doesn't care what ingredients
    the kitchen uses as long as it can make the items on the menu, and the kitchen
    doesn't care what language the order-taker speaks to the customer in, as long
    as the items ordered are from the menu.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，考虑一下一家快餐店的运作方式。前面有一个人在接顾客的订单，厨房根据菜单准备食物。接单的人不在乎厨房使用什么食材，只要它能做出菜单上的菜肴即可，厨房也不在乎接单的人对顾客说什么语言，只要订单上的菜肴来自菜单即可。
- en: If the kitchen wants to hire new cooks or use different ingredients, it can
    do so without informing the order-taker, as long as the dishes prepared match
    the menu. If we want to replace the in-person order taker with someone on the
    phone, we can do that too, without affecting the kitchen.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果厨房想要雇佣新厨师或使用不同的食材，它可以这样做，只要准备的菜肴与菜单相符。如果我们想用电话接单的人替换现场接单的人，我们也可以这样做，而不会影响厨房。
- en: The thing that makes this possible is the menu, which is a common shared *contract*
    through which the order-taker and kitchen interact.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使这一切成为可能的是菜单，这是一个共同的共享*合同*，通过这个合同，接单人和厨房进行交互。
- en: Similarly, it's a good idea while developing an app to separate its components
    and have them interact exclusively through a contract called an *Application Programming
    Interface* (API for short). In the context of our app, we should maintain this
    separation between the frontend and the backend.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，将组件分离并让它们通过称为*应用程序编程接口*（简称API）的合同进行独家交互是一个好主意。在我们的应用程序的上下文中，我们应该在前后端之间保持这种分离。
- en: This means that our frontend should only interact with the backend to ask it
    to perform any of a certain list of actions.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的前端应该只与后端交互，请求它执行一系列特定的操作。
- en: 'What exactly are these actions? Let''s revisit our logic flow diagram in figure
    3.11\. There are four arrows between the frontend and the backend:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作究竟是什么呢？让我们回顾一下图3.11中的逻辑流程图。前端和后端之间有四条箭头：
- en: one where the frontend pulls in the quantities to show the user,
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个前端从后端拉取数量以向用户展示的场景，
- en: one where it pulls in the units corresponding to the quantity selected by the
    user,
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个它拉入用户选择的数量对应的单位的情况，
- en: one where the frontend provides the values to be converted, and
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个前端提供要转换的值的情况，
- en: one where the backend returns the conversion value
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个后端返回转换值的情况
- en: '![image](../Images/03__image011.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/03__image011.png)'
- en: Figure 3.11 Flow diagram for our app with the API actions highlighted
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.11展示了我们的应用程序的流程图，其中API操作被突出显示
- en: 'These can be boiled down into three interactions (the last two arrows are really
    two parts of the same interaction) that the frontend has with the backend:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以归结为前端与后端之间的三种交互（最后两条箭头实际上是同一交互的两个部分）：
- en: '**List-quantities:** The frontend asks the backend to provide the list of quantities
    it supports.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列出数量**：前端请求后端提供它支持的数量的列表。'
- en: '**List-units:** The frontend gives the backend a quantity and asks it to list
    the units it knows how to convert between in that quantity.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列出单位**：前端给后端一个数量，并请求它列出它知道如何在该数量之间转换的单位。'
- en: '**Convert-value:** The frontend gives the backend the value to convert and
    the units selected by the user, and asks it to do the conversion.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换值**：前端给后端提供要转换的值和用户选择的单位，并请求它进行转换。'
- en: The above actions form the menu or API of our backend. As in our fast food example,
    as long as the backend can fulfill these responsibilities, it's free to implement
    them however it wants. Perhaps at some point, we'll find a more efficient way
    to perform conversions. Or maybe want to hook up the backend to an external service
    to perform the conversion. In either case, we can change the backend implementation
    without touching the frontend code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 上述操作构成了我们后端的菜单或API。正如在我们的快餐示例中，只要后端能够履行这些职责，它就可以自由地以任何方式实现它们。也许在某个时候，我们会找到一种更有效的方法来执行转换。或者可能想要将后端连接到外部服务以执行转换。在两种情况下，我们都可以在不触及前端代码的情况下更改后端实现。
- en: Or maybe at some point we'll want to enable a command-line interface to our
    conversion app in addition to our graphical UI. In that instance, we can simply
    add it with no changes required to our existing frontend code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也许在某个时候，我们希望在我们的图形用户界面之外，为我们的转换应用程序启用命令行界面。在这种情况下，我们可以简单地添加它，而无需对现有的前端代码进行任何更改。
- en: As you can see, separating concerns between the frontend and the backend gives
    us a lot of flexibility. Our app is simple enough that the benefits may not be
    obvious, but this is a good habit to develop as it'll help you in the real world
    when you develop more complex apps and need to switch out components easily.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，将前端和后端之间的关注点分离给我们带来了很多灵活性。我们的应用程序足够简单，其好处可能并不明显，但这是一个好习惯，因为它将在您开发更复杂的应用程序并需要轻松更换组件时在现实世界中帮助您。
- en: We'll see how to actually implement this API approach very soon.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会看到如何实际实现这种API方法。
- en: 3.6 Writing code
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 编写代码
- en: At this point, we've spent enough time thinking about the design of our app
    that we're ready to write some code.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经花了很多时间思考我们应用程序的设计，现在我们准备好编写一些代码了。
- en: In this section, we'll walk through the code for our app, starting with our
    configuration file, which plays a central role in our design. We'll define a *contract*
    or *API* between our frontend and backend, then make our backend fulfill that
    contract.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将遍历我们的应用程序代码，从我们的配置文件开始，它在我们的设计中扮演着核心角色。我们将定义前端和后端之间的*契约*或*API*，然后让后端履行该契约。
- en: Finally, we'll write our frontend, learning about the Streamlit elements that
    make our UI possible as we do so, and have it issue calls to the backend through
    our defined contract to close the loop.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将编写我们的前端，在这样做的同时了解使我们的用户界面成为可能的Streamlit元素，并通过我们定义的契约对后端进行调用，以完成循环。
- en: 3.6.1 Creating the configuration file
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.1 创建配置文件
- en: Our configuration file is what holds information about the quantities and units
    our app understands.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的配置文件是我们应用程序理解的单位和数量的信息存储处。
- en: From our design, we know that the app needs to look up the units for a given
    quantity. Furthermore, given a unit, it needs to be able to look up its conversion
    factor with respect to the standard unit for that quantity.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的设计来看，我们知道应用程序需要查找给定数量的单位。此外，给定一个单位，它需要能够查找相对于该数量的标准单位的转换系数。
- en: A Python dictionary sounds like it would be ideal for this task. Each key in
    this dictionary would be a quantity, and the associated values would be a list
    of units, or better yet, *another* dictionary where the keys are units and values
    are the corresponding conversion factors.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Python字典听起来像是完成这项任务的理想选择。这个字典中的每个键都是一个数量，相关值是一个单位列表，或者更好的是，*另一个*字典，其中键是单位，值是对应的转换系数。
- en: 'One possible way to write this might be something like the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 写作这种代码的一种可能方式可能是以下内容：
- en: '[PRE0]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This certainly works, but it would be nice if we could also display the abbreviation
    for a unit (e.g., 'oz' for ounces or 'kg' for kilograms), and maybe we should
    store the standard unit for a quantity as well.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然有效，但如果我们也能显示单位的缩写（例如，'oz'代表盎司或'kg'代表千克），并且我们可能还应该将数量的标准单位存储起来，那就更好了。
- en: We're getting to the point where units and quantities are well-defined "things"
    with their own attributes (a unit has an abbreviation and a conversion factor,
    a quantity has a bunch of units and one unit that's designated as the standard
    one). We *could* represent this complexity by expanding our dictionary to have
    more "layers,” but it would be better practice to define *classes* for units and
    quantities.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了一个阶段，单位与数量被明确定义为具有自身属性的“事物”（一个单位有一个缩写和一个转换系数，一个数量有一系列单位以及一个被指定为标准单位的一个单位）。我们*可以*通过扩展我们的字典以拥有更多的“层”来表示这种复杂性，但定义*类*来表示单位和数量会是一个更好的实践。
- en: So spin up your code editor and create a file called `unit.py` (see listing
    3.1) to define the Unit class. We're going to use a *dataclass* here, which is
    a special type of class in Python, enabled through the `dataclasses` module, which
    is part of Python's standard library.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，启动您的代码编辑器并创建一个名为`unit.py`的文件（见列表3.1），以定义单位类。在这里，我们将使用一个*数据类*，这是Python中的一种特殊类型类，通过`dataclasses`模块启用，它是Python标准库的一部分。
- en: Listing 3.1 unit.py
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.1 unit.py
- en: '[PRE1]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A dataclass is an easy way to create a class with some standard basic functionality.
    For instance, with dataclasses, you don''t need to specify a `__init__` method
    as you would do with a normal class, and once you have an object of the dataclass,
    you can access its attributes with the dot-notation, like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类是创建具有一些标准基本功能类的简单方法。例如，使用数据类，你不需要像使用普通类那样指定`__init__`方法，一旦你有一个数据类的对象，你可以使用点符号访问其属性，就像这样：
- en: '[PRE2]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To achieve the same functionality with a regular class, you would have had
    to write:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用普通类实现相同的功能，你将不得不编写：
- en: '[PRE3]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With dataclasses, you can use the much more concise syntax from Listing 3.1
    by including the `@dataclass` decorator above your class definition.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据类，你可以通过在类定义上方包含`@dataclass`装饰器来使用列表3.1中的更简洁的语法。
- en: Turning to the contents of the class, you can see that they're pretty simple;
    there's an `abbrev` string field that holds the abbreviation for the unit, and
    a `value_in_std_units`, a floating point number which represents the conversion
    factor we discussed in Section 3.5.1.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 转到类的内容，你可以看到它们相当简单；有一个`abbrev`字符串字段，用于存储单位的缩写，还有一个`value_in_std_units`，它是一个表示我们在3.5.1节中讨论的转换系数的浮点数。
- en: 'The `: str` and `: float` from Listing 3.1 are called *type annotations*. They''re
    used to specify the data type of a field. Type annotations are not strictly required,
    but it''s a good practice to include them, since (among other things) they make
    your code easier to understand and allow your code editor or IDE to catch and
    highlight errors early on.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '列表3.1中的`: str`和`: float`被称为*类型注解*。它们用于指定字段的类型。类型注解不是强制性的，但这是一个好习惯，因为（在其他方面）它们使你的代码更容易理解，并允许你的代码编辑器或IDE在早期捕获并突出显示错误。'
- en: You may have noticed that we haven't included a `name` field in the `Unit` class.
    We'll discuss why when we get to the configuration file.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们没有在`Unit`类中包含一个`name`字段。当我们到达配置文件时，我们将讨论为什么。
- en: Let's also define a `Quantity` class in a new file, `quantity.py`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也在一个新文件`quantity.py`中定义一个`Quantity`类。
- en: Listing 3.2 quantity.py
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.2 quantity.py
- en: '[PRE4]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 3.2 shows the `Quantity` class. It contains two fields: `units` and
    `std_unit`.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2显示了`Quantity`类。它包含两个字段：`units`和`std_unit`。
- en: '`std_unit` here is the name of the standard unit for that quantity.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`std_unit`在这里是该量的标准单位名称。'
- en: Notice the more complex type annotation we're using for the `units` field. `Dict[str,
    Unit]` means that `units` is a dictionary where each key is a string (the name
    of the unit) and the corresponding value is an object of the `Unit` class. Annotations
    for some of the more advanced types need to be imported from the `typing` module.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们为`units`字段使用的更复杂的类型注解。`Dict[str, Unit]`表示`units`是一个字典，其中每个键是一个字符串（单位的名称），相应的值是`Unit`类的对象。对于一些更高级的类型，需要从`typing`模块导入注解。
- en: With that out of the way, we can now create our final configuration file (see
    Listing 3.3).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些之后，我们现在可以创建我们的最终配置文件（见列表3.3）。
- en: Listing 3.3 unit_config.py
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.3 unit_config.py
- en: '[PRE5]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our configuration is still in the form of a dictionary, but each dictionary
    value is now an object of the `Quantity` class. Our file includes three quantities:
    mass, length, and time.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置仍然是字典的形式，但现在每个字典值现在是一个`Quantity`类的对象。我们的文件包括三个量：质量、长度和时间。
- en: 'Let''s inspect one of these:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查其中一个：
- en: '[PRE6]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, this is quite readable. We're configuring a quantity named "Mass"
    as a `Quantity` object with a standard unit of "Kilograms.” The `units` dictionary
    has four entries, one for each unit, where the value is a `Unit` object with an
    abbreviation and conversion factor.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是相当易读的。我们正在配置一个名为“质量”的量，作为一个具有标准单位“千克”的`Quantity`对象。`units`字典有四个条目，每个单位一个，其中值是一个具有缩写和转换系数的`Unit`对象。
- en: Since "Kilograms" is the standard unit, its `value_in_std_units` is 1.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“千克”是标准单位，其`value_in_std_units`值为1。
- en: You may now also realize why neither of the `Unit` and `Quantity` classes have
    a `name` field. Since the unit and quantity names are already incorporated into
    the dictionary keys in `unit_config.py`, also having it in the class is unnecessary
    and would make the configuration file longer and less readable.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能也意识到了为什么`Unit`和`Quantity`类都没有`name`字段。因为单位和数量名称已经包含在`unit_config.py`中的字典键中，所以在类中再包含它是不必要的，这会使配置文件更长且更难以阅读。
- en: Adding more units is easy; you would just add new entries to the `units` dictionary
    within the `Quantity`. Similarly, adding new quantities simply requires appending
    to the `unit_config` dictionary, following the format of the previous entries.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 添加更多单位很容易；你只需在`Quantity`中的`units`字典中添加新的条目。同样，添加新的量只需在`unit_config`字典中追加，遵循前一条目的格式。
- en: 3.6.2 Implementing the API
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.2 实现API
- en: 'Earlier in the chapter (section 3.5.4), we enumerated the actions we want the
    backend to be able to take:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期（3.5.4节），我们列举了后端能够执行的操作：
- en: List-quantities
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表-量
- en: List-units
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表-单位
- en: Convert-value
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换值
- en: Let's now actually implement these.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实际实现这些。
- en: We want each of the above actions to be a function in the backend. For each,
    we'll come up with the function signature first, and then implement it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望上述每个动作都是后端的一个函数。对于每个动作，我们首先将给出函数签名，然后实现它。
- en: '**List-quantities** is pretty simple; it asks the backend to list all the quantities
    it knows. There are no arguments required, and the output would probably be a
    list of strings. Thus:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表-量**非常简单；它要求后端列出它所知道的所有量。不需要任何参数，输出可能是一个字符串列表。因此：'
- en: '[PRE7]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'How do we implement this? Well, the quantities we need are the keys of our
    configuration object from `unit_config.py` (in listing 3.3). So we can simply
    write:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何实现这个？嗯，我们需要的是`unit_config.py`（列表3.3）中配置对象的键。因此，我们可以简单地写出：
- en: '[PRE8]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**List-units** *does* take an argument (the quantity to list the units of),
    and it would again return a list of strings. So we get:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表-单位**确实需要一个参数（要列出单位的量），它将再次返回一个字符串列表。因此我们得到：'
- en: '[PRE9]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Implementing this is also fairly straightforward. The list we need is composed
    of the keys of the `units` dictionary from the `Quantity` object corresponding
    to the `quantity_name` key in `unit_config`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点也很直接。我们需要列表是由`Quantity`对象中`unit_config`的`quantity_name`键对应的`units`字典的键组成的。
- en: '[PRE10]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You might realize that we're not handling the scenario where the provided `quantity_name`
    doesn't exist in `unit_config`. In the real world, we should absolutely do that,
    but for this chapter, I've excluded error handling to keep the code relatively
    concise. We'll tackle error handling in future chapters.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会意识到我们没有处理提供的`quantity_name`在`unit_config`中不存在的情况。在现实世界中，我们绝对应该这样做，但在这个章节中，我排除了错误处理以保持代码相对简洁。我们将在未来的章节中处理错误处理。
- en: '**Convert-value** takes four arguments: a quantity name, the from- and to-
    units, and a value to convert. We want to include the quantity name here due to
    the possibility that different quantities may have a unit that''s called the same
    (though our example configuration doesn''t have this).'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**转换值**需要四个参数：量名、源单位和目标单位，以及要转换的值。我们在这里包含量名是因为不同的量可能有相同的单位名称（尽管我们的示例配置没有这种情况）。'
- en: As for the return type, we *could* simply return the converted value, which
    would be a floating point number, and nothing else.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 至于返回类型，我们**可以**简单地返回转换后的值，这将是一个浮点数，不再需要其他内容。
- en: Recall, however, that our configuration also has abbreviations for each unit.
    It would be nice if, on conversion, we were also able to give the frontend the
    appropriate abbreviations so it can display something like "15 ft = 5 yd."
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，记住我们的配置也为每个单位提供了缩写。如果在转换时，我们也能给前端提供适当的缩写，以便它可以显示类似“15 ft = 5 yd”的内容，那就太好了。
- en: On the other hand, we don't want to be prescriptive about how the frontend *actually*
    displays the results; that's the frontend's business—remember *separation of concerns*?
    If the frontend wants to just show the converted number with no abbreviation,
    that's totally fine too.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们不想对前端如何实际显示结果做出规定；这是前端的事务——记得*关注点分离*？如果前端只想显示转换后的数字而不带缩写，那也是完全可以的。
- en: One approach would be to wrap any metadata the frontend might need in a dedicated
    `Result` class and let the frontend figure out what to do with it.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是将前端可能需要的任何元数据包装在一个专门的`Result`类中，并让前端决定如何处理它。
- en: Let's define the `Result` class in a new file called `result.py` (listing 3.4).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个名为`result.py`的新文件中定义`Result`类（列表3.4）。
- en: Listing 3.4 result.py
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.4 result.py
- en: '[PRE11]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that rather than placing just the abbreviation for each unit in the result,
    we're including the entire `Unit`. If we decide to modify the `Unit` class later
    and add more properties to it, this code won't need to change.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不是只将每个单位的缩写放在结果中，而是包括整个`Unit`。如果我们决定稍后修改`Unit`类并添加更多属性，这段代码就不需要更改。
- en: 'With that, we''re ready to define the signature for **Convert-value**:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就准备好定义**Convert-value**的签名：
- en: '[PRE12]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We''ve already discussed how to implement the conversion, but here it is in
    code form:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何实现转换，但这里以代码形式呈现：
- en: '[PRE13]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice the two-step conversion we discussed earlier. `value * from_unit.value_in_std_units`
    gives the value in standard units, and the `/ to_unit.value_in_std_units` converts
    it to the to-unit.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们之前讨论的两个步骤转换。`value * from_unit.value_in_std_units`给出了标准单位中的值，而`/ to_unit.value_in_std_units`将其转换为目标单位。
- en: Listing 3.5 puts this all together in a single `backend.py` file.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5将所有这些内容整合到一个单独的`backend.py`文件中。
- en: Listing 3.5 backend.py
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.5 backend.py
- en: '[PRE14]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 3.6.3 Implementing the frontend
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.3 实现前端
- en: We're finally in the portion of this chapter where you'll actually be using
    Streamlit!
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于到了本章的这部分，你将实际使用Streamlit！
- en: First we'll explore each of the features of Streamlit we'll be using, referring
    to our UI design from earlier (shown in figure 3.12), and then we'll use them
    to create our frontend.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探索我们将要使用的Streamlit的每个功能，参考我们之前的UI设计（如图3.12所示），然后我们将使用它们来创建我们的前端。
- en: '![image](../Images/03__image007.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/03__image007.png)'
- en: Figure 3.12 The UI visualization for our unit converter app for reference
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.12 我们单位转换应用程序的UI可视化，供参考
- en: We're going to be building our UI incrementally. To start, create a new Python
    file called `frontend.py` and add the imports we need (i.e., Streamlit itself,
    and the backend API functions we defined).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步构建我们的用户界面。首先，创建一个名为`frontend.py`的新Python文件，并添加我们需要的导入（即Streamlit本身和定义的后端API函数）。
- en: '[PRE15]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Save your file and run the following in the terminal:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的文件，并在终端中运行以下命令：
- en: '[PRE16]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: or `streamlit run <path to frontend.py>` if your working directory is not the
    same one that contains `frontend.py.`
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 或者如果你的工作目录不包含`frontend.py`，可以使用`streamlit run <path to frontend.py>`。
- en: This will open a browser window with your app (currently just a blank screen).
    Each time you make a change, switch back to the browser window and click "Rerun"
    or "Always rerun" to see the results.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个浏览器窗口，显示你的应用程序（目前只是一个空白屏幕）。每次你进行更改时，切换回浏览器窗口并点击“重新运行”或“始终重新运行”以查看结果。
- en: st.radio
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: st.radio
- en: The first component of the UI we'll focus on is the quantity selector, which
    is a bunch of radio buttons set in a panel on the left.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将关注的UI的第一个组件是数量选择器，它是一组设置在左侧面板中的单选按钮。
- en: Radio buttons are a UI element that lets a user pick a single item out of a
    given list of items.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 单选按钮是一个UI元素，允许用户从给定列表中选择一个项目。
- en: 'For example, if you append the following to the `frontend.py` file you just
    created:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你将以下内容添加到刚刚创建的`frontend.py`文件中：
- en: '[PRE17]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Streamlit will display the question "Select a quantity" and a list of radio
    buttons with "Mass," "Force," and "Pressure" as options. Once the user has selected
    one, the variable `quantity` will contain the option that the user picked (i.e.,
    the string "Mass," "Force," or "Pressure").
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit将显示问题“选择一个量”以及一个带有“质量”、“力”和“压力”选项的单选按钮列表。一旦用户选择了一个选项，变量`quantity`将包含用户选择的选项（即字符串“质量”、“力”或“压力”）。
- en: 'In our case, our list of options will come from the backend where you''ll recall
    that we have a function called `list_quantities` (listing 3.5). So we would instead
    write:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们的选项列表将来自后端，回想一下我们有一个名为`list_quantities`（列表3.5）的函数。因此，我们将会写：
- en: '[PRE18]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This gives us the output shown in figure 3.13\. We now get "Mass," "Length,"
    and "Time" as options because `list_quantities` fetches the keys of `unit_config`
    (from our configuration file) and returns them as a list that forms the second
    argument to `st.radio`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们展示了图3.13中的输出。现在我们得到了“质量”、“长度”和“时间”作为选项，因为`list_quantities`获取`unit_config`（来自我们的配置文件）的键，并将它们作为列表返回，这个列表是`st.radio`的第二个参数。
- en: '![image](../Images/03__image012.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/03__image012.png)'
- en: Figure 3.13 An example output for st.radio
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.13 st.radio的一个示例输出
- en: The `quantity` variable will contain the item currently selected by the user
    (e.g., "Mass" in figure 3.8).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`quantity`变量将包含用户当前选择的项（例如，图3.8中的“质量”）。'
- en: Streamlit offers plenty of customization for `st.radio`. You can set the options
    horizontally instead of vertically, add a caption to each option, disable them
    altogether, and so on.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit为`st.radio`提供了大量的自定义选项。你可以设置水平选项而不是垂直选项，为每个选项添加标题，完全禁用它们，等等。
- en: You can find a complete list of customization possibilities in the Streamlit
    docs at [https://docs.streamlit.io/develop/api-reference/widgets/st.radio](https://docs.streamlit.io/develop/api-reference/widgets/st.radio).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Streamlit 文档的[https://docs.streamlit.io/develop/api-reference/widgets/st.radio](https://docs.streamlit.io/develop/api-reference/widgets/st.radio)中找到完整的自定义选项列表。
- en: st.sidebar
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: st.sidebar
- en: We've created our radio buttons, but we now need them in a panel to the left
    as shown in figure 3.12.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了单选按钮，但现在我们需要将它们放在如图3.12所示的左侧面板中。
- en: This kind of panel, in Streamlit terminology, is a *sidebar*. Sidebars are extremely
    useful when you want to create a bunch of links that lead to different pages in
    the app, provide some meta-information about your app, etc.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在Streamlit术语中，这种面板被称为*侧边栏*。当您想要创建一组链接，这些链接可以引导到应用中的不同页面，提供一些关于您应用的元信息等时，侧边栏非常有用。
- en: 'To use `st.sidebar`, you need to put something within it. There are two ways
    to do this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `st.sidebar`，您需要在其中放置一些内容。有两种方法可以做到这一点：
- en: 'You can use a context manager (i.e., Python `with` statement) like this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用上下文管理器（即Python `with` 语句）如下所示：
- en: '[PRE19]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Any Streamlit element you place inside the `with` statement will be displayed
    in the sidebar.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将任何 Streamlit 元素放置在 `with` 语句内部，它将在侧边栏中显示。
- en: 'You can also use a dot notation and refer to an element you want to place inside
    the sidebar as a member of the sidebar, like so:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用点符号并引用您想要放置在侧边栏中的元素，将其作为侧边栏的成员，如下所示：
- en: '[PRE20]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Appending either of the above to `frontend.py` produces the output shown in
    figure 3.14.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述任何一个添加到 `frontend.py` 中都会产生如图3.14所示的输出。
- en: '![image](../Images/03__image013.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/03__image013.png)'
- en: Figure 3.14 st.sidebar in action with a set of radio buttons inside
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.14 st.sidebar 在使用一组单选按钮时的效果
- en: A sidebar is displayed with an 'X' icon that collapses it or a '>' icon that
    expands a collapsed sidebar.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 侧边栏显示一个“X”图标，用于折叠它，或者一个“>”图标，用于展开折叠的侧边栏。
- en: st.title
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: st.title
- en: 'With the sidebar in place, let''s turn our attention to the main area of the
    app. Users need to know what the app is and what it does, so we''ll add a title:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好侧边栏后，让我们将注意力转向应用的主要区域。用户需要了解应用是什么以及它做什么，因此我们将添加一个标题：
- en: '[PRE21]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This should be pretty self-explanatory, but just to state it explicitly, `st.title`
    writes any string passed to it as a title, i.e., in large bold font.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该相当直观，但为了明确说明，`st.title` 将传递给它的任何字符串作为标题写入，即以大号粗体字体。
- en: st.text_input
  id: totrans-320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: st.text_input
- en: Next, we need the user to enter the value they want to convert. Let's use a
    text input for this.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要用户输入他们想要转换的值。让我们为此使用文本输入框。
- en: '`st.text_input` is Streamlit''s way of letting users enter single-line values.
    We can write:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.text_input` 是 Streamlit 允许用户输入单行值的方式。我们可以这样写：'
- en: '[PRE22]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: to display a text input with the caption "Value to convert" and an initial value
    of "0.” Note that `st.text_input` returns a string, so `input_num` has the string
    "0.”
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 显示一个带有标题“要转换的值”和初始值“0.”的文本输入框。请注意，`st.text_input` 返回一个字符串，因此 `input_num` 有字符串“0.”。
- en: 'We want to maintain this as a number, so we''ll also cast the value to float:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将其保持为数字，因此我们还将值转换为浮点数：
- en: '[PRE23]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With the title and text input, our app should look like figure 3.15.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加标题和文本输入框后，我们的应用应该看起来像图3.15。
- en: '![image](../Images/03__image014.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/03__image014.png)'
- en: Figure 3.15 Unit Converter app after adding a title and text input
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.15 添加标题和文本输入框后的单位转换器应用
- en: '`st.text_input` has lots of customization options, such as placeholder text
    that''s displayed when there''s no entered value, an optional tooltip, and the
    ability to enter passwords (we encountered this in our password checker app in
    Chapter 2).'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.text_input` 有许多自定义选项，例如在未输入值时显示的占位文本，可选的工具提示，以及输入密码的能力（我们在第2章的密码检查器应用中遇到过这种情况）。'
- en: Again, docs.streamlit.io has more detail on what's available.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，docs.streamlit.io 上有更多关于可用功能的详细信息。
- en: st.selectbox
  id: totrans-332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: st.selectbox
- en: We need dropdowns for the user to pick the from- and to- units, so let's create
    those next.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要下拉菜单，让用户选择从和到单位，因此让我们创建这些下拉菜单。
- en: '`st.selectbox` is what we''re looking for here. It displays a basic select
    widget with a label and a set of options.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.selectbox` 是我们在这里要找的。它显示一个带有标签和一组选项的基本选择小部件。'
- en: 'The arguments are similar to what you would pass to `st.radio`. For example,
    we could write:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 参数类似于您传递给 `st.radio` 的参数。例如，我们可以这样写：
- en: '[PRE24]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: to display a country dropdown with the variable `country` containing the selected
    option. When the dropdown first renders, the first option ("United States" in
    this case) is selected by default.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 显示一个包含变量 `country` 的国家下拉菜单，其中包含所选选项。当下拉菜单首次渲染时，默认选中第一个选项（在本例中为“美国”）。
- en: 'For our use case, we need to first collect the list of options to display.
    We can call `list_units` from our backend to fetch the units available for the
    quantity the user has selected:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的用例，我们首先需要收集要显示的选项列表。我们可以从后端调用`list_units`来获取用户所选数量的可用单位：
- en: '[PRE25]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can then use this list to populate the options in our from- and to- unit
    dropdowns:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个列表来填充我们的“从”和“到”单位下拉菜单中的选项：
- en: '[PRE26]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `index` parameter we've included in the second dropdown is used to set the
    default selected option. A value of '1' means the second option will be selected
    on the first render.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第二个下拉菜单中包含的`index`参数用于设置默认选中的选项。值为'1'表示在第一次渲染时将选中第二个选项。
- en: We do this because we don't want both the from- and to- dropdowns to have the
    same default selected value, since that would almost never be useful (users wouldn't
    want to convert from kilograms to kilograms).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为我们不希望“从”和“到”下拉菜单有相同的默认选中值，因为这几乎永远不会有用（用户不会想从千克转换成千克）。
- en: At this point, our app looks like figure 3.16.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的应用看起来像图3.16。
- en: '![image](../Images/03__image015.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/03__image015.png)'
- en: Figure 3.16 Unit Converter app after adding from- and to- unit dropdowns
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加“从”和“到”单位下拉菜单后的3.16单位转换器应用
- en: This is *fine*, but our design had the from- and to- dropdowns side by side,
    which seems more natural.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这*是好的*，但我们的设计是将“从”和“到”下拉菜单并排放置，这似乎更自然。
- en: st.columns
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: st.columns
- en: By default, Streamlit displays the UI elements from top-to-bottom in the same
    order that it encounters them in your code.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Streamlit按代码中遇到的顺序从上到下显示UI元素。
- en: Naturally, you don't always want this; sometimes you want things laid out side
    by side. We saw how to do this with `st.sidebar`, but an app can only have one
    sidebar, and it appears to the left of the overall UI; it can't be inline.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，你并不总是想要这样；有时你想要东西并排排列。我们看到了如何使用`st.sidebar`来做这件事，但一个应用只能有一个侧边栏，它出现在整体UI的左侧；它不能是内联的。
- en: '`st.columns` is the answer here. To use it, you would first create a list of
    columns, specifying the number of columns you want:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.columns`就是答案。要使用它，你首先需要创建一个列的列表，指定你想要的列数：'
- en: '[PRE27]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, the call to `st.columns(2)` returns a list of two columns. The syntax
    we're using here is called *list unpacking*, and it assigns the individual items
    of a list to different variables. As you might imagine, here `from_unit_col` will
    contain the first column and `to_unit_col` will contain the second.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，调用`st.columns(2)`返回一个包含两个列的列表。我们在这里使用的语法称为*列表解包*，它将列表的各个项分配给不同的变量。正如你可能想象的那样，在这里`from_unit_col`将包含第一个列，而`to_unit_col`将包含第二个。
- en: 'As in the case of `st.sidebar`, there are two ways to put something in a column:
    using the `with` context manager or the dot notation. So we could write:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在`st.sidebar`的情况下，有两种方法可以将某物放入列中：使用`with`上下文管理器或点符号表示法。因此，我们可以写：
- en: '[PRE28]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: or more concisely,
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更简洁地，
- en: '[PRE29]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Generally speaking, the `with` context manager makes more sense when you have
    multiple elements to display within a container (whether it's a sidebar, a column,
    or something else), while the dot notation works better when you only have a single
    item or when you want to display elements out of order. We'll see plenty of examples
    of these cases throughout this book.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，当你需要在容器（无论是侧边栏、列还是其他东西）内显示多个元素时，`with`上下文管理器更有意义，而当您只有一个项目或想要显示顺序不规则的元素时，点符号表示法效果更好。在整个书中，我们将看到许多这些情况的示例。
- en: 'Figure 3.17 shows our app by this point:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17展示了此时我们的应用：
- en: '![image](../Images/03__image016.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/03__image016.png)'
- en: Figure 3.17 Unit Converter app with side-by-side from- and to- unit dropdowns
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.17带有并排“从”和“到”单位下拉菜单的单位转换器应用
- en: st.button
  id: totrans-362
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: st.button
- en: With all the inputs captured, we're ready to add our "Convert" button.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在捕获所有输入后，我们准备添加我们的“转换”按钮。
- en: I hope you remember `st.button` from Chapter 2, Streamlit's ol' faithful make-something-happen
    element.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能记得第二章中的`st.button`，Streamlit的老忠实元素，用于让某事发生。
- en: 'To add our button, we would write:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加我们的按钮，我们会写：
- en: '[PRE30]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This should be easy enough to understand. It says, "display a button that says
    'Convert' and if/when the user clicks it, execute some statements.”
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该很容易理解。它说，“显示一个写着'转换'的按钮，如果/当用户点击它时，执行一些语句。”
- en: Once we've written out what we want the button to do, this will render a barebones
    Streamlit red-on-white button with the functionality we've defined.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们写出了我们想要按钮执行的操作，这将渲染一个带有我们定义的功能的裸骨Streamlit红白按钮。
- en: 'So what do we actually want our button to do? Our backend has a `convert_value`
    function that performs the unit conversion, so let''s start by calling that:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们实际上希望我们的按钮做什么呢？我们的后端有一个`convert_value`函数，它执行单位转换，所以让我们先调用它：
- en: '[PRE31]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we're passing `convert_value` the user-selected quantity, the from- and
    to- units, and the value to convert. Recall that `convert_value` returns an object
    of the class `Result` (defined in `result.py`)
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在将用户选择的数量、源单位和要转换的值传递给`convert_value`。回想一下，`convert_value`返回一个`Result`类的对象（在`result.py`中定义）
- en: The variable `result` thus has the result of our conversion, complete with the
    from- and to- values and abbreviations. All that remains is to display it on the
    screen. Enter…
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，变量`result`包含了我们的转换结果，包括源值、目标值和缩写。剩下要做的就是将其显示在屏幕上。进入…
- en: st.metric
  id: totrans-373
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: st.metric
- en: We could have displayed our result as plain old paragraph text, but this is
    the big outcome of our app we're talking about, the grand finale. We want something
    that packs more *punch*.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以将结果显示为普通的段落文本，但这是我们应用的大结局，是我们谈论的重点。我们想要一些更有力的东西。
- en: '`st.metric` is a widget that''s commonly used in dashboards to show important
    numbers—like the revenue of a company—and how they''re trending as compared to
    a prior period.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.metric`是一个在仪表板上常用的小部件，用于显示重要的数字——比如公司的收入——以及它们与前期相比的趋势。'
- en: 'A single `st.metric` element is meant to represent a measure the user interested
    in, and it consists of three parts: a text label, the number itself displayed
    in large font, and a "delta indicator,” which is a value that shows how much the
    number has increased or decreased from a prior period.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单独的`st.metric`元素旨在表示用户感兴趣的度量，它由三个部分组成：一个文本标签，以大字体显示的数字本身，以及一个“增量指示器”，它显示数字与前期相比增加了多少或减少了多少。
- en: 'We''re going to use `st.metric` to display the from- and to- values along with
    the abbreviations of the units, so let''s first prepare these:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`st.metric`来显示源值和目标值以及单位的缩写，所以让我们首先准备这些：
- en: '[PRE32]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Since result is an `Result` object, we form the display text by concatenating
    its `from_value` or `to_value` field and grabbing the abbreviation from `from_unit`
    or `to_unit`, which is itself an instance of `Unit`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 由于结果是一个`Result`对象，我们通过连接其`from_value`或`to_value`字段并从`from_unit`或`to_unit`获取缩写来形成显示文本，`from_unit`或`to_unit`本身是一个`Unit`实例。
- en: 'To actually use `st.metric`, we write:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际使用`st.metric`，我们编写：
- en: '[PRE33]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The delta indicator in `st.metric` doesn't make sense for us, so we set it to
    `None` to hide it.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.metric`中的增量指示器对我们来说没有意义，所以我们将其设置为`None`以隐藏它。'
- en: 'The above will display the from- and to- results vertically, but we need them
    side-by-side, so let''s use `st.columns` again:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容将垂直显示源值和目标值，但我们需要它们并排显示，所以让我们再次使用`st.columns`：
- en: '[PRE34]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Figure 3.18 shows our completed app.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18显示了我们的完成的应用程序。
- en: '![image](../Images/03__image017.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/03__image017.png)'
- en: Figure 3.18 Our completed unit converter app
  id: totrans-387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.18我们的完成的单位转换应用程序
- en: Listing 3.6 shows the `frontend.py` file you should have ended up with if you've
    been following along.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6显示了如果你一直跟随着，你应该结束的`frontend.py`文件。
- en: Listing 3.6 frontend.py
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.6 frontend.py
- en: '[PRE35]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 3.7 Iterating on our app
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7 对我们的应用程序进行迭代
- en: Whew! We did it! We now have a fully functional app on our hands. In the real
    world, this would just be the *start* of your journey and you would now launch
    your app and show it to users.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 呼呼！我们做到了！我们现在手里有一个完全功能的应用程序。在现实世界中，这仅仅是你的旅程的开始，你现在将启动你的应用程序并向用户展示。
- en: Users will often have very opinionated feedback about the experience you've
    built for them and can help you uncover usability issues and blind spots you may
    not have encountered in your testing.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 用户经常会对你为他们构建的体验提出非常主观的反馈，这可以帮助你发现你在测试中可能没有遇到的可用性问题盲点。
- en: In this section, we'll simulate this process by using the app ourselves and
    identifying potential improvements we can make.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过使用应用程序本身来模拟此过程，并确定我们可以做出的潜在改进。
- en: 3.7.1 Rounding our conversion results
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7.1 四舍五入我们的转换结果
- en: Let's take our completed app for a spin. Figure 3.18 shows the example results
    of converting kilograms to grams.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试驾我们的完成的应用程序。图3.18显示了将千克转换为克的示例结果。
- en: That looks mostly fine, but let's try a metric-to-imperial conversion now. Say
    we want to convert 4000 kilograms to pounds. We fire up our app, choose "Mass,"
    enter our inputs and hit "Convert" to see figure 3.19.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来大部分都很好，但现在让我们尝试一个公制到英制的转换。比如说，我们想把4000千克转换成磅。我们启动我们的应用程序，选择“质量”，输入我们的输入并点击“转换”来查看图3.19。
- en: '![image](../Images/03__image018.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/03__image018.png)'
- en: Figure 3.19 A metric-to-imperial conversion that shows why we should be rounding
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.19 一个公制到英制的转换，展示了为什么我们应该进行四舍五入
- en: The answer we got seems right, but that's an awful lot of decimal places. Most
    people probably don't need that level of precision; in fact it probably detracts
    from their experience as it takes them a second to figure out why the displayed
    number is so long.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的答案似乎是正确的，但十进制位数却非常多。大多数人可能不需要这种程度的精度；事实上，它可能减少了他们的体验，因为他们需要一秒钟的时间来弄清楚为什么显示的数字这么长。
- en: It would be nice if users had the option of rounding the result to the precision
    they really need. And come to think of it, for larger numbers we should ideally
    separate the thousands by commas.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户可以选择将结果四舍五入到他们真正需要的精度，那将很理想。而且，如果我们考虑到更大的数字，理想情况下应该用逗号分隔千位。
- en: To implement this, let's first create a function called `format_value` that
    will format a number the way we want it, i.e., with commas separating the thousands,
    and optionally rounded to a certain number of decimal points.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，让我们首先创建一个名为 `format_value` 的函数，该函数将以我们想要的方式格式化数字，即用逗号分隔千位，并且可选地四舍五入到一定的小数位数。
- en: '`format_value` takes three arguments: the value to format, the abbreviation,
    and an optional number of `decimal_places` to round the value to. If we don''t
    pass the latter (i.e., `is_rounded` is false`)`, the function won''t do any rounding.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`format_value` 函数接受三个参数：要格式化的值、缩写，以及一个可选的 `decimal_places` 数量，用于将值四舍五入到。如果我们不传递后者（即
    `is_rounded` 为假），则函数不会进行任何四舍五入。'
- en: '[PRE36]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We use the `round` function to perform the actual rounding if we need to and
    Python's built-in `format` function to add the commas, using "," as the *format
    spec*.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要，我们可以使用 `round` 函数进行实际的四舍五入，并使用 Python 内置的 `format` 函数添加逗号，使用 "," 作为 *格式说明符*。
- en: We could just hardcode the number of decimal places to round to, but ideally
    we should let the user decide, which means adding a new input widget.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接硬编码要四舍五入到的十进制位数，但理想情况下我们应该让用户来决定，这意味着添加一个新的输入小部件。
- en: st.number_input
  id: totrans-407
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: st.number_input
- en: '`st.number_input` is Streamlit''s numeric input widget. It''s quite similar
    to `st.text_input`, but it has some additional functionality, such as the ability
    to specify a minimum and maximum value, and a step button that lets you increase
    or decrease the entered value by clicking.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.number_input` 是 Streamlit 的数字输入小部件。它与 `st.text_input` 非常相似，但它有一些额外的功能，例如可以指定最小和最大值，以及一个步进按钮，允许您通过点击来增加或减少输入的值。'
- en: 'We can use it to collect the user''s preferred number of decimal places by
    adding this line to `frontend.py` right after the from- and to- unit dropdowns:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 `frontend.py` 中添加以下行来使用它来收集用户首选的十进制位数，就在从单位和到单位下拉菜单之后：
- en: '[PRE37]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We specify a default value of 2, and a minimum value of 0 since we can't have
    a negative number of decimal places (trying to enter a lower value shows an error.
    `places` will hold the entered number.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定默认值为2，最小值为0，因为我们不能有负数的十进制位数（尝试输入更小的值会显示错误。`places` 将保留输入的数字。
- en: This should give us the widget shown in figure 3.20.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给我们展示在图3.20中的小部件。
- en: '![image](../Images/03__image019.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/03__image019.png)'
- en: Figure 3.20 st.number_input
  id: totrans-414
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.20 st.number_input
- en: Notice the '-' and '+' buttons that let you increase or decrease the value by
    1\. You can adjust the step-interval to something else by specifying the `step`
    parameter in `st.number_input`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 '-' 和 '+' 按钮，它们允许您通过点击增加或减少值1。您可以通过在 `st.number_input` 中指定 `step` 参数来调整步进间隔。
- en: You may be wondering why we bothered to use `st.text_input` to collect the value-to-convert
    and cast to float when `st.number_input` was available. This is because at the
    time of writing, there doesn't seem to be an easy way to get rid of the '-' and
    '+ buttons in `st.number_input`. These make sense when we're collecting the number
    of decimal places, which is an integer in a very tight range, but the value-to-convert
    is virtually unbounded and there's no predefined step-interval that makes sense.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么我们费心使用 `st.text_input` 来收集要转换的值并将其转换为浮点数，当 `st.number_input` 可用时。这是因为在我们写作的时候，似乎没有简单的方法来去除
    `st.number_input` 中的 '-' 和 '+' 按钮。当我们收集十进制位数时，这些按钮是有意义的，因为十进制位数是一个非常紧密范围内的整数，但要转换的值几乎是无限的，并且没有预定义的步进间隔是有意义的。
- en: 'Okay, now that we''ve collected the decimal places, we''re ready to apply our
    formatting when we display the results. We can do this by changing the `from_display`
    and `to_display` variables so that they use the `format_value` function we defined
    earlier:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经收集了小数位数，我们准备在显示结果时应用我们的格式化。我们可以通过更改`from_display`和`to_display`变量，使它们使用我们之前定义的`format_value`函数来实现：
- en: '[PRE38]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We pass `places` (which we collect from the user) to round the `to_display`
    variable. We could have done this for `from_display` as well, but it's likely
    the user entered the precision they want to see in the from-value, so we don't
    want to mess with that.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递`places`（我们从用户那里收集）来四舍五入`to_display`变量。我们也可以为`from_display`做同样的事情，但用户可能已经输入了他们想要在源值中看到的精度，所以我们不想去修改它。
- en: This gives us figure 3.21.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们图3.21。
- en: '![image](../Images/03__image020.png)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03__image020.png)'
- en: Figure 3.21 Unit converter app with a decimal places input
  id: totrans-422
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.21 单位转换器应用，带有小数位数输入
- en: Note
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This won't pad to-values with extra trailing zeroes. For instance, if the to-value
    is a whole number, say 600, it will be displayed as "600.0" with just the one
    trailing zero.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会在目标值后面填充额外的尾随零。例如，如果目标值是一个整数，比如说600，它将显示为“600.0”，只有一个尾随零。
- en: The formatted result looks much nicer, but we've also added an extra numeric
    input that increases the user's cognitive load a little. Maybe we should only
    introduce the decimal-places input if the user asks for it.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化后的结果看起来更美观，但我们还增加了一个额外的数字输入，这稍微增加了用户的认知负荷。也许我们只应该在用户要求时引入小数位数输入。
- en: st.checkbox
  id: totrans-426
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: st.checkbox
- en: '`st.checkbox` is a Streamlit checkbox, i.e., a box that you can, well, check.
    Please try to contain your shock, we have an app to ship.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.checkbox`是Streamlit复选框，即你可以勾选的框。请尽量控制你的惊讶，我们有一个可以发布的应用。'
- en: Like `st.button`, `st.checkbox` is a *conditional* element; you can use an if
    statement to branch your logic based on whether it's checked or not.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如同`st.button`，`st.checkbox`是一个*条件*元素；你可以使用if语句根据它是否被勾选来分支你的逻辑。
- en: 'Our use case is to let the user decide if they want to round the conversion
    result, which we can do by modifying how we obtain the value of the `places` variable:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用例是让用户决定他们是否想要四舍五入转换结果，我们可以通过修改获取`places`变量值的方式来实现：
- en: '[PRE39]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The checkbox is unchecked by default since we're passing False to the value
    argument.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 复选框默认未勾选，因为我们向值参数传递了False。
- en: Notice that we've included the line `places = None` above the `st.checkbox`
    code. This is because, down below, we're referring to `places` outside of the
    scope of the `if st.checkbox` block, so we need to pass an initial value to it
    in case the user leaves the box unchecked.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在`st.checkbox`代码上方包含了`places = None`这一行。这是因为，在下面，我们正在引用`places`，它超出了`if
    st.checkbox`块的作用域，所以我们需要传递一个初始值给它，以防用户未勾选该框。
- en: Our app should now look like figure 3.22.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用应该看起来像图3.22。
- en: '![image](../Images/03__image021.png)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03__image021.png)'
- en: Figure 3.22 Unit converter app with rounding enabled
  id: totrans-435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.22 单位转换器应用，启用四舍五入
- en: Or if the user leaves "Round result?" unchecked, we get the full-precision treatment
    in figure 3.23.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果用户未勾选“四舍五入结果？”，我们将得到图3.23中的全精度处理。
- en: '![image](../Images/03__image022.png)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03__image022.png)'
- en: Figure 3.23 Unit converter app with rounding disabled
  id: totrans-438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.23 单位转换器应用，禁用四舍五入
- en: 3.7.2 Getting rid of the button
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7.2 移除按钮
- en: Our app works great now; it displays rounded output, but only if we want it
    to. We've added a click and a numeric input to enable this, however.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用现在工作得很好；它显示四舍五入的输出，但只有在我们想要的时候。我们添加了一个点击和一个数字输入来启用这个功能，然而。
- en: Is there perhaps a way to simplify this experience? Let's turn our attention
    to the "Convert" button. Do we really even need it?
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 也许有办法简化这个体验？让我们把注意力转向“转换”按钮。我们真的需要它吗？
- en: All it does is trigger the conversion. But we don't really need an explicit
    trigger. Why not have the app *always* show the result based on the entered inputs?
    So if the user changes the value, they would immediately see the conversion result
    rather than having to click the button again.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 它所做的只是触发转换。但我们真的不需要一个明确的触发器。为什么不让应用始终根据输入显示结果呢？所以如果用户更改了值，他们会立即看到转换结果，而无需再次点击按钮。
- en: That definitely seems like a more intuitive experience, so let's make it happen.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实看起来是一个更直观的体验，让我们来实现它。
- en: As it turns out, this is easy to do. Simply remove the line if `st.button("Convert"):`
    and move everything in that block outside.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这很容易做到。只需删除`if st.button("Convert"):`这一行，并将该块中的所有内容移动到外面。
- en: Listing 3.7 shows the final version of frontend.py.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7展示了`frontend.py`的最终版本。
- en: Listing 3.7 Final version of frontend.py
  id: totrans-446
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.7 `frontend.py`的最终版本
- en: '[PRE40]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: And figure 3.24 shows a final screenshot of our app.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.24展示了我们应用程序的最终截图。
- en: '![image](../Images/03__image023.png)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03__image023.png)'
- en: Figure 3.24 Unit converter app with the "Convert" button removed
  id: totrans-450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.24 移除了“转换”按钮的单位转换器应用程序
- en: You'll find that removing the button makes the app *flow* a lot better. For
    instance, if you change the decimal places or the value, you see the results instantly.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现移除按钮会使应用程序的*流程*变得更好。例如，如果你更改小数位数或值，你会立即看到结果。
- en: I hope this chapter has been a lot of fun! We started with a mere concept, broke
    it down into concrete requirements, designed a UI, thought deeply about the implementation,
    wrote code to turn our ideas into a working app, and refined it for a better user
    experience.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这一章对你来说非常有趣！我们从一个简单的概念开始，将其分解为具体的需求，设计了用户界面，深入思考了实施方法，编写代码将我们的想法转化为一个可工作的应用程序，并对其进行了优化以获得更好的用户体验。
- en: The point of this chapter was to give you a sense of what it's like to develop
    Streamlit apps in the real world while working with real stakeholders. As you've
    hopefully learned, there's a lot more to the process than writing code; things
    like nailing the requirements and designing (and refining) the user experience
    are equally important.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是让你对在现实世界中与真实利益相关者一起开发Streamlit应用程序的感觉有一个了解。正如你可能已经学到的，这个过程远不止编写代码；像确定需求以及设计（和优化）用户体验这样的事情同样重要。
- en: 3.8 Summary
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.8 摘要
- en: Building an app from a concept is about a lot more than writing code.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个概念构建应用程序远不止编写代码。
- en: 'The six steps involved in creating a Streamlit app in the real world are: state
    the concept, define the requirements, visualize the user experience, brainstorm
    implementation, write code, and iterate.'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现实世界中创建Streamlit应用程序涉及以下六个步骤：阐述概念、定义需求、可视化用户体验、头脑风暴实施、编写代码和迭代。
- en: Requirements can come from your users or from non-user stakeholders.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需求可能来自你的用户或非用户利益相关者。
- en: It's a good idea to visualize the user experience at the start by sketching
    mocks so you have something to work towards.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始时通过绘制原型来可视化用户体验是个好主意，这样你就有了一个努力的方向。
- en: Brainstorming the implementation involves analyzing tradeoffs and mapping the
    flow of logic.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施头脑风暴涉及分析权衡并绘制逻辑流程图。
- en: Separating your frontend and backend code and defining an API for the two to
    interact is a great way to organize your app.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的前端和后端代码分离，并为两者定义一个API以进行交互是组织应用程序的绝佳方式。
- en: '`st.text_input` and `st.number_input` allow users to input text and numeric
    values.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`st.text_input`和`st.number_input`允许用户输入文本和数值。'
- en: '`st.radio` and `st.selectbox` let users select a value from a list.'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`st.radio`和`st.selectbox`允许用户从列表中选择一个值。'
- en: '`st.sidebar` and `st.columns` are layout elements that let you break the natural
    top-to-bottom way that Streamlit renders UI elements.'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`st.sidebar`和`st.columns`是布局元素，允许你打破Streamlit渲染UI元素的自然从上到下的方式。'
- en: '`st.button` and `st.checkbox` are both conditional elements.'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`st.button`和`st.checkbox`都是条件元素。'
