- en: 3 Taking an app from concept to code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Defining the scope of an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing the code for an app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streamlit's workhorse input widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In my beginning days as a software engineer, I was often surprised by how much
    of my time was spent on activities other than writing code. I'd spend multiple
    days or even weeks simply understanding the problem I was trying to solve and
    even more time in design, all before typing a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: At the time, I felt anxious because I didn't feel *productive*. Scribbled meeting
    notes and design docs didn't *do* anything. With time, I realized that those days
    and weeks weren't actually wasted; they made the end-product better because of
    how deeply I'd thought about what I was trying to do.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, this book is not *just* about teaching you to write Streamlit code.
    It's about helping you learn to develop apps in the real world. Planning and design
    are inescapable parts of this process.
  prefs: []
  type: TYPE_NORMAL
- en: Though we don't have weeks to spend on these topics, this chapter will give
    you a taste of the end-to-end experience of developing an app.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with the concept for an app and convert it into a set of requirements.
    We'll then come up with a design that meets those requirements, working backwards
    from the user experience, and also think about code organization.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll walk through our code and logic, introducing some of Streamlit's
    most common widgets as we go. That's a lot to get done, so let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: '3.1 Concept to code: A six-step process'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing a piece of software can be an overwhelming task once you get past the
    initial spark of inspiration. There are so many things to consider! Where do you
    start? What features are you going to develop and how long will it take? How will
    users interact with your app? Should you start coding right away and figure it
    out as you go?
  prefs: []
  type: TYPE_NORMAL
- en: 'To quote Desmond Tutu: "There is only one way to eat an elephant: a bite at
    a time.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'In creating Streamlit apps, as in consuming large land mammals, the optimal
    approach is to break it down into smaller chunks. Figure 3.1 displays a simple,
    logical six-step process you can follow while developing an app, or really just
    about any piece of software:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/03__image001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 The six-stage app development flow
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**State the concept:** To solve a problem—or to describe it to others—you first
    need to be able to state it succinctly at a high level.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Define the requirements:** This is where you refine your concept and break
    it down into cold, hard requirements. Part of this is to define the scope of what
    your app will and—perhaps more importantly—*won''t* do.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Visualize the user experience:** Draw diagrams and mocks of what your envisioned
    user''s experience will be when they use your app.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Brainstorm implementation:** What components will your solution have, how
    will they integrate with each other, and what tradeoffs do you face?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Write code:** Actually implement your app.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Iterate:** Inspect your output and refine steps 1 through 5 as necessary.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This may sound like a lot, and you may find yourself thinking: "Is this all
    really necessary? I''m not building enterprise software in a large team, I''m
    making a fairly small app for a handful of users."'
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of the above steps is that you can adjust them to what makes sense
    for your project. If you're working on a large project, each of the above steps
    may take a long time since there's probably a lot of people that need to agree
    on the overall approach.
  prefs: []
  type: TYPE_NORMAL
- en: But if you're building something small, you can scale each step down to something
    more reasonable. For instance, you can define the requirements in a quick bullet-point
    list that takes maybe five minutes to generate, and your visualization of the
    user experience can be a simple sketch.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of this chapter, we'll go through each of these steps in the context
    of an example app.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For much of this chapter, our attention is going to be on the end-to-end app
    development process; we''ll only cover various Streamlit elements towards the
    end when we discuss the implementation of the frontend. This is by design, to
    reflect the real world, where your primary focus in developing a graphical app
    will be the app itself, not Streamlit. That actually explains the success of Streamlit:
    it *gets out of your way* so you can develop your app without worrying too much
    about how you''re going to implement the UI.'
  prefs: []
  type: TYPE_NORMAL
- en: So even though you won't see a lot of discussion about Streamlit itself in the
    beginning parts of this chapter, hang in there! We'll get to it organically where
    it fits best!
  prefs: []
  type: TYPE_NORMAL
- en: '3.2 Stating our concept: A unit converter'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whether it's while studying physics, cooking a meal based on a recipe, or traveling
    internationally, I'm sure you've been in situations where you've had to convert
    between different units of measurement like cups to ounces, yards to meters, and
    so on. You may have had to look up the conversion factor online and then use a
    calculator to do the actual conversion.
  prefs: []
  type: TYPE_NORMAL
- en: The app we'll be working on in this chapter will make this task easier and more
    streamlined.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in the last section, the first step in the development process
    is to "state the concept,” i.e., to express the problem we're trying to solve
    succinctly, preferably in a single sentence or line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our concept:'
  prefs: []
  type: TYPE_NORMAL
- en: Concept
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A Streamlit app that allows users to effortlessly convert between different
    units of measurement like distance, mass, and time.
  prefs: []
  type: TYPE_NORMAL
- en: Stating the concept uncovers the core of what you're trying to do and focuses
    your thinking, preventing it from wandering off in a dozen directions.
  prefs: []
  type: TYPE_NORMAL
- en: As you're developing the app, you may hit upon various new possibilities and
    potential features to incorporate. The stated concept is there as a reference
    point to ensure that whatever changes you're considering still satisfy the core
    idea laid out in it.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, you might think, "Maybe I should make a unit overview page where
    I explain the history of the unit and what it was named after.” If you compare
    it to our one-line concept, you'll realize that such a page doesn't really help
    with our goal of having users convert between units effortlessly, so it's probably
    wise to drop it.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this doesn't mean that the concept you've stated is set in stone.
    If you encounter an idea that significantly enriches the experience you could
    provide the user but it doesn't fit well with the concept, feel free to re-state
    the concept.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, stating the concept also has the benefit of giving you a one-line description
    that you can share with other people to help them understand your work. This can
    be especially valuable in helping you gain users or find collaborators to partner
    with.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 Defining the requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your concept works great as a sort of mission statement for your app, but it's
    somewhat hand-wavy about the details. The next step then is to break the concept
    down into concrete *requirements* you can build towards.
  prefs: []
  type: TYPE_NORMAL
- en: Think of these as the specific list of things your *stakeholders* (your users,
    teams that you work with, etc.,) would want the app to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Requirements should:'
  prefs: []
  type: TYPE_NORMAL
- en: express a capability the app should have
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: be free of "implementation" language, e.g., it should not refer to any technology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For an app you're building in real life, coming up with the list of requirements
    might involve interviewing people to understand their needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purposes of our example, here''s the list of requirements we want to
    center our app around:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Requirements:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The user should be able to enter a numeric quantity and the unit the quantity
    is in (the "from-unit").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user should be able to select a unit to convert to (the "to-unit"), which
    must measure the same type of thing as the from-unit. No converting from pounds
    to yards, for instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The app should display the converted value as output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The app should be able to handle conversions within the imperial or metric systems
    (e.g., feet to inches or meters to centimeters), and across metric systems (e.g.,
    feet to meters).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding new units or quantities to the app should be straightforward.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice how the above points are a lot more concrete than our initial concept.
    Also note how requirements don't just come from the user; they can also come from
    other people.
  prefs: []
  type: TYPE_NORMAL
- en: To elaborate, the first four requirements listed above are things that the *user*
    wants, while the last one is something that makes life easier for the *developer*
    or *maintainer* as you'd want to minimize the time you spend in responding to
    common requests like adding another unit of measurement to the app.
  prefs: []
  type: TYPE_NORMAL
- en: In an organizational setting, you can also imagine requirements from other stakeholders,
    such as the analytics team ("we should be able to monitor and track usage of the
    app") or the monetization tram ("the app should allow the user to subscribe for
    a monthly fee").
  prefs: []
  type: TYPE_NORMAL
- en: You may have realized that the requirements don't mention anything about the
    *technology* used to accomplish them. For example, they don't say "the app should
    display a Streamlit button the user can click to perform the conversion.”
  prefs: []
  type: TYPE_NORMAL
- en: This is intentional; requirements are about what stakeholders actually need.
    How you fulfill them is up to you, the developer.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.1 Defining what the app won't do
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While listing the requirements is an important step that provides clear goals
    to accomplish, it can sometimes feel like you're spelling out the obvious. In
    practice, there's value in doing it even if that's the case because what's obvious
    to you may not be obvious to your users or your collaborators. It's quite common
    for people to form a picture in their head about what you're promising that bears
    no resemblance to reality.
  prefs: []
  type: TYPE_NORMAL
- en: For that reason, it's vital—and possibly more enlightening—to also define what's
    *not* in your app's scope.
  prefs: []
  type: TYPE_NORMAL
- en: For the unit conversion app in this chapter, we want to keep things as simple
    as possible because we don't want to spend too much time on it; we're mainly building
    it to get familiar with Streamlit.
  prefs: []
  type: TYPE_NORMAL
- en: Any sort of auxiliary functionality that doesn't directly relate to the goal
    of unit conversion is then immediately out. We don't want to build any usage logging
    or fancy visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: We should also try to keep our conversion logic simple. Converting from pounds
    to kilograms is easy enough since you can bake the conversion factor into your
    app, but how about, say, currencies?
  prefs: []
  type: TYPE_NORMAL
- en: Converting from dollars to euros is hard because the exchange rate changes from
    day to day, or even from hour to hour. To incorporate that, you'd need to read
    the exchange rates from somewhere, like an online API. We'll read from an API
    in later projects in this book, but for now, it's probably best to avoid the additional
    complexity. So currencies are out.
  prefs: []
  type: TYPE_NORMAL
- en: 'To state it formally:'
  prefs: []
  type: TYPE_NORMAL
- en: What's out of scope
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Usage tracking, logging, visualizations etc., that do not directly relate to
    unit conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversions between units that don't share a simple, constant conversion factor,
    such as those between currencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This can be a useful tool for prioritization and phasing. Even if you're placing
    something out of scope at the moment, you may want to build it later on.
  prefs: []
  type: TYPE_NORMAL
- en: Articulating the requirements and scope lets you express what features you consider
    to be priority and which ones you might want to push to a future version.
  prefs: []
  type: TYPE_NORMAL
- en: If you have additional stakeholders, having these written down is a good way
    to elicit feedback and start a conversation about prioritization.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4 Visualizing the user experience
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we've spent a fair amount of time thinking about the problem we want
    to solve; we've conceptualized what we'll be building, refined our understanding
    of what our app needs to do, and even articulated what it *won't* do.
  prefs: []
  type: TYPE_NORMAL
- en: What we haven't done yet is to start designing a solution. That's what we'll
    do in this next step.
  prefs: []
  type: TYPE_NORMAL
- en: When you start the process of actually developing an app, you may find yourself
    wondering what to do first. Do you simply start coding your Python app from top
    to bottom, figuring out your design as you go? Do you try to figure out what the
    basic components of your app are and how they'll fit together? Or maybe you work
    on what you think will be the hardest part of the problem to get it out of the
    way?
  prefs: []
  type: TYPE_NORMAL
- en: Those are all valid approaches and there are arguments to be made in favor of
    each of them. One approach I've always found valuable, and the one we'll follow
    in this chapter, is to *work backwards from the user experience*.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning from the user experience is a good way of ensuring the quality of
    the end product, because it puts the user front and center, directly addressing
    their needs and preferences. It also helps identify and solve potential usability
    issues early on in the process.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.1 Creating a mock
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So what experience do we want the users of our app to have? To answer that,
    let's create a mock or sketch of what the UI might look like.
  prefs: []
  type: TYPE_NORMAL
- en: Looking back at the requirements we enumerated in section 3.3, at its core,
    the app needs to provide a way for users to input a numeric quantity and the units
    to convert from and to.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 shows a quick initial sketch.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/03__image002.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 An initial mock of the unit conversion app
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Figure 3.2 shows a first attempt at a UI design. It''s quite simple: there''s
    a box where you can type in the value to convert, and you can choose the from-
    and to- units from a select box. Once you''re done you click a "Convert" button
    and the answer appears below.'
  prefs: []
  type: TYPE_NORMAL
- en: You can make a diagram like this with a pen and paper, a marker and whiteboard,
    or any graphics program you prefer. It doesn't really have to be elaborate or
    even particularly neat. The important thing is that it should show the end outcome
    you're trying to create, forcing you to think about your app from the user's perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.2 Getting the user experience right
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's take a closer look at our mock. There are select boxes to pick a from-
    unit and a to- unit, but what if the units aren't compatible? What if the user
    chooses "Pounds" (a unit of mass) as the from-unit and "Feet" (which measures
    length) as the to-unit and tries to convert between them (see figure 3.3)?
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/03__image003.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 Our initial UI makes it possible for users to select incompatible
    units, like "Pounds" to "Feet"
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You could display an error message, of course. That would work, but it wouldn't
    be a great experience for the user. Users generally like their experience to be
    as frictionless as possible, and they *hate* getting errors. A better UI would
    render it impossible to make the mistake in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: For example, perhaps when the user selects "Pounds,” we could narrow the options
    in the to-unit dropdown to only units that are compatible with pounds (see figure
    3.4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/03__image004.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 We could update the to-unit dropdown to only show units compatible
    with the selected from-unit
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: That solves the incompatible-units problem, but may introduce another issue.
    What if the user wants to select the *to-unit* first? We could potentially apply
    the reverse logic and update the from-unit list to only contain units compatible
    with the selected to-unit. Essentially, whatever unit is selected first, the other
    dropdown is restricted to units compatible with that one, as seen in figure 3.5.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/03__image005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5 Two-way restriction: When a unit is selected, the other dropdown
    updates to only show compatible units'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: But what if the user *now* wants to do a conversion between units of a different
    quantity altogether, say a length conversion from feet to inches?
  prefs: []
  type: TYPE_NORMAL
- en: When they try to select "Feet" in the from-unit list, they find it's not in
    the list any more, because the from-unit is artificially restricted to only units
    of mass by the selection in the to-unit dropdown, which says "Kilograms" (see
    figure 3.6).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/03__image006.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 Prior selections create a confusing experience because the user can't
    now select units from other quantities
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are multiple ways to fix this.
  prefs: []
  type: TYPE_NORMAL
- en: We could enforce a rule that the user has to select a from-unit first. This
    feels like a somewhat artificial restriction though, and not one that's inherent
    to the business problem.
  prefs: []
  type: TYPE_NORMAL
- en: We could instead introduce a reset button for the user to click whenever they
    want to start a new conversion, resetting both dropdowns. This works and isn't
    *terrible* but it seems like a lot of work for the user.
  prefs: []
  type: TYPE_NORMAL
- en: The most intuitive way to handle this would be to simply add another input for
    the type of quantity the user wants to convert. If the user selects "Mass" in
    this new dropdown, for example, the from- and to- units would only have units
    of mass as seen in figure 3.7\. Thus, instead of restricting the dropdowns based
    on each other, we restrict them based on a third external selection.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/03__image007.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 Adding a quantity-type selector makes the app more intuitive
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This solves the issue much more elegantly while being quite intuitive to the
    user. It''s obvious what the user needs to do here: pick a quantity, enter a value,
    pick the from- and to- units and click "Convert.”'
  prefs: []
  type: TYPE_NORMAL
- en: Note that while figure 3.7 shows radio buttons for the quantity type, we could
    have gone with a dropdown too. The radio button switches things up a bit and involves
    one less click than a dropdown, but the experience with a dropdown isn't significantly
    worse. In any case, when you actually get to the implementation using Streamlit,
    you may identify entirely new possibilities for how to present inputs.
  prefs: []
  type: TYPE_NORMAL
- en: I hope this gives you an understanding of how to start designing a UI and some
    of the tradeoffs involved. There will, of course, always be more factors we *could*
    concern ourselves with—for example, does our user care about imperial vs metric
    system units and should our UI differentiate between them in some way?—but this
    is already a solid foundation we can feel comfortable with.
  prefs: []
  type: TYPE_NORMAL
- en: We've done a fair amount of refinement to our UI, but you still shouldn't feel
    that it's necessarily final. As we dive deeper into implementation, you may find
    more optimizations you'd like to make. In fact, we'll encounter some of these
    in the following sections and iterate upon our design.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Since you'll be implementing your UI design using Streamlit, a natural question
    that might arise while visualizing the user experience is whether you should keep
    in mind the various elements available in Streamlit so you don't design something
    you can't actually build.
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, that's putting the cart before the horse. In the ideal world,
    you want to figure out the best experience for your users, and then *implement*
    it using Streamlit. You don't want to let Streamlit limit your thinking about
    what the ideal user experience looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this carries some risk; you may, on rare occasions, find that Streamlit
    doesn't have the exact elements that you were hoping for in your design, and need
    to adjust your implementation. But that will actually enrich your learning journey
    by making Streamlit's deficiencies clearer. It will also ensure your user experience
    won't be constrained by your preconceptions of Streamlit's feature set, which
    is expanding all the time.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5 Brainstorming the implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now know roughly what the end-user experience in our app will be like. Let's
    turn our attention to making that experience happen.
  prefs: []
  type: TYPE_NORMAL
- en: In this step of the process, we'll enumerate the various parts of our solution,
    discuss how they fit together, and map out the flow of logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two big parts to pretty much any application: a frontend and a backend.
    The frontend handles how the user interacts with your app, i.e., how we collect
    inputs and display outputs. The backend is the app''s "brain" that takes inputs
    from the frontend, processes them, and hands the output to the frontend to display
    to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: Based on the last section, we already have a fair idea of what the frontend
    of our app looks like; we just need to translate the UI to the corresponding elements
    available in Streamlit, which we'll do in our code walkthrough.
  prefs: []
  type: TYPE_NORMAL
- en: We'll therefore turn our attention to the backend, starting with the actual
    unit conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5.1 Performing the actual unit conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's say we want to convert 5 pounds (lbs) to ounces (oz). From an online search
    (I grew up with the metric system), 1 pound equals 16 oz.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, to convert 5 lb to oz, we would multiply 16 by 5 to get 80 oz.
  prefs: []
  type: TYPE_NORMAL
- en: We'll refer to the number 16 here as the *lb-to-oz conversion factor.*
  prefs: []
  type: TYPE_NORMAL
- en: Every pair of units has a similar conversion factor. For instance, 1 yard equals
    3 feet, so the yard-to-foot conversion factor is 3\. To take an imperial-to-metric
    example, 1 mile equals 1.609344 km, so the mile-to-km conversion factor is 1.609344.
  prefs: []
  type: TYPE_NORMAL
- en: To state this generally, given any pair of units X and Y, to convert a given
    value expressed in X to Y,
  prefs: []
  type: TYPE_NORMAL
- en: Value in unit Y = Value in unit X * X-to-Y conversion factor
  prefs: []
  type: TYPE_NORMAL
- en: To do the reverse conversions (e.g., ounces to pounds), you can use a conversion
    factor calculated as 1 divided by the original conversion factor.
  prefs: []
  type: TYPE_NORMAL
- en: So,
  prefs: []
  type: TYPE_NORMAL
- en: 1 yard = 3 feet; 1 foot = ⅓ yards; foot-to-yard conversion factor = ⅓1 mile
    = 1.609344 km; 1 km = 1/1.609344 = 0.621372 miles; km-to-mile conversion factor
    = 0.621372
  prefs: []
  type: TYPE_NORMAL
- en: With this information, it seems like all we need to do is to collect the conversion
    factor for every pair of possible units within a quantity type, and apply the
    formula given above.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there''s a problem: we could end up with a lot of conversion factors to
    keep track of.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we want users to be able to convert between 3 units: pounds,
    kilograms, and ounces'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are 3 x (3-1) = 3 x 2 = 6 possible types of conversions that can be done:
    pounds to kilograms, kilograms to pounds, pounds to ounces, ounces to pounds,
    ounces to kilograms, and kilograms to ounces.'
  prefs: []
  type: TYPE_NORMAL
- en: This means we need to keep track of 6 conversion factors. From our discussion
    above, we've seen that if we know the X-to-Y conversion factor, then the Y-to-X
    conversion factor is simply 1 divided by the X-to-Y conversion factor. Using this,
    we can whittle down the number of conversion factors we need to keep track of
    from 6 to 6 / 2 = 3.
  prefs: []
  type: TYPE_NORMAL
- en: In general, if you have n units, to be able to convert between any pair of them,
    we would need n (n-1) / 2 conversion factors.
  prefs: []
  type: TYPE_NORMAL
- en: Our example above didn't seem too bad. But what if we have a lot more than 3
    units of a particular quantity type? What if we have 20?
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, we would need to keep track of 20 * (20-1) / 2 = 20 * 19 /
    2 = 190 conversion factors. Whew! That's a *lot* of numbers to track in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'But isn''t 20 units for a single quantity type a little extreme? Not really.
    Take distance or length. If you count the metric system''s prefixes that signify
    magnitude and include units used in astronomy or navigation, you''ll come up with
    something like the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: kilometers, meters, decimeters, centimeters, millimeters, micrometers, nanometers,
    angstroms, inches, feet, yards, miles, furlongs, astronomical units, parsecs,
    light years, nautical miles, fathoms, leagues, cubits, picometers, decameters,
    hectometers… you get the picture.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, keeping track of conversion factors for every single pair of units
    is not sustainable.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, what we want to do is to designate one unit from each quantity as the
    *standard unit* for that quantity and only keep track of conversion factors to
    that unit from all the others.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if we make meters the standard unit for distance, we would only
    keep track of the conversion factor from each unit to meters, i.e. "what is the
    value 1 in this unit in meters?"
  prefs: []
  type: TYPE_NORMAL
- en: Then, to convert from unit X to unit Y, we could convert from unit X to meters
    and then from meters to unit Y.
  prefs: []
  type: TYPE_NORMAL
- en: 'So if we want to convert 5 yards to centimeters:'
  prefs: []
  type: TYPE_NORMAL
- en: Yard-to-meter conversion factor = 0.9144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Centimeter-to-meter conversion factor = 0.01
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can then follow a two-step conversion process (see figure 3.8):'
  prefs: []
  type: TYPE_NORMAL
- en: 5 yards = 5 x 0.9144 meters = 4.572 meters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4.572 meters = 4.572 x 1 / 0.01 centimeters = 457.2 centimeters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../Images/03__image008.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 Converting from yards to centimeters using meters as a standard intermediate
    unit
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Notice that since we always store the conversion factor of a unit *to* meters,
    in step 2, we had to divide 1 by the factor to get the reverse conversion factor,
    i.e., meter-to-centimeter.
  prefs: []
  type: TYPE_NORMAL
- en: Putting this more generally, given a pair of units X and Y and a standard unit
    S, to convert a value expressed in X to Y,
  prefs: []
  type: TYPE_NORMAL
- en: Value in unit S = Value in unit X * X-to-S conversion factorValue in unit Y
    = Value in unit S * 1 / Y-to-S conversion factor
  prefs: []
  type: TYPE_NORMAL
- en: 'We now end up with a much more manageable number of conversion factors: since
    we only care about how many standard units a given unit is, we can get away with
    storing just one factor per unit.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.5.2 Tracking units and conversion factors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall that one of our original requirements is that adding new units to the
    app must be straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: When we speak of "adding new units" here, we're referring to us updating the
    app to include more conversion units to convert between, not the user being able
    to dynamically add units themselves.
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of a *non-user requirement*. Our user presumably does not
    care about how easy it is for us to add new units; they care that the units are
    available for them to convert between. So who *does* care? The developer does.
    *We* do.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, you're usually never done with a piece of software once you've
    launched it. If your app is used by enough people, you can count on a consistent
    stream of feedback, reported bugs, and requested features coming your way and
    eating up the time that you were planning to spend on other projects. Or worse,
    someone *else* will be tasked with maintaining your code, and they'll have no
    idea how it works.
  prefs: []
  type: TYPE_NORMAL
- en: In this situation, if you haven't designed your app's implementation for ease
    of maintenance, someone will have to spend a significant amount of time digging
    through your code to figure out the right place to make a change and make sure
    there are no side-effects. Even if you're not feeling particularly charitable
    towards other developers, there's always the likelihood that the *someone* will
    be you. Speaking from personal experience, you'd be surprised at how little you'll
    remember about the code you wrote as recently as a month ago.
  prefs: []
  type: TYPE_NORMAL
- en: Coming back to our unit converter, one of the most common maintenance tasks
    you might need to perform is to add new units, and we want to make that as simple
    as possible. Ideally, there should be exactly one place in the code where you'd
    need to add the unit and its conversion factor, and it should be the most obvious
    place.
  prefs: []
  type: TYPE_NORMAL
- en: A good way to achieve this is to keep a master list of all quantities, units
    and conversion factors in a single configuration file. The file should have an
    obvious format, and adding a new unit should be as easy as appending a few lines
    in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Critically, this configuration file should be the *only* file that refers to
    any specific quantities. That means that no other places in the app should refer
    to specific quantities or units, like meters or pounds. That's because if they
    did, adding a new quantity or unit would require updating that part of the code
    too, which breaks our requirement of it being straightforward to update the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This has an interesting implication: we can''t hard-code quantities or units
    into our UI code at any point. Everything related to specific quantities or units
    needs to be pulled from the configuration file. The rest of our code needs to
    be independent of them.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll see how to do this in our code walkthrough later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5.3 Mapping the flow of logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now have a good understanding of all of the individual pieces of our app:
    the frontend, the conversion logic, and the configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we code them up, it's useful to have a mental model of how they fit together.
    Figure 3.9 shows the overall design of our app.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/03__image009.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 Overall design and logic flow for our unit conversion app
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The configuration file that we discussed in the previous section powers the
    quantity selector radio buttons from the UI we visualized earlier (figure 3.10).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/03__image010.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 Quantity selector radio buttons from our mocks
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once the user has selected a quantity, the from- and to- unit dropdowns update
    based on the selected quantity (again powered by the configuration file).
  prefs: []
  type: TYPE_NORMAL
- en: When the user has selected the from- and to- units and clicked the "Convert"
    button, all entries are sent to the backend where the conversion factors from
    the configuration are used to perform the two-step conversion outlined in section
    3.5.1.
  prefs: []
  type: TYPE_NORMAL
- en: The converted value is then returned to the frontend where the user can see
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5.4 The backend API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There's a key concept in software development called *separation of concerns*.
    In essence, this means that each building block in a piece of software should
    focus on one aspect of the overall system's functionality, and should be independent
    of the other building blocks. Where a block interacts with another, it should
    do so in strictly controlled ways as defined by a *contract*.
  prefs: []
  type: TYPE_NORMAL
- en: To understand this better, consider how a drive-in fast food restaurant might
    operate. There's a person at the front taking orders from customers and a kitchen
    that prepares the food based on a menu. The order-taker doesn't care what ingredients
    the kitchen uses as long as it can make the items on the menu, and the kitchen
    doesn't care what language the order-taker speaks to the customer in, as long
    as the items ordered are from the menu.
  prefs: []
  type: TYPE_NORMAL
- en: If the kitchen wants to hire new cooks or use different ingredients, it can
    do so without informing the order-taker, as long as the dishes prepared match
    the menu. If we want to replace the in-person order taker with someone on the
    phone, we can do that too, without affecting the kitchen.
  prefs: []
  type: TYPE_NORMAL
- en: The thing that makes this possible is the menu, which is a common shared *contract*
    through which the order-taker and kitchen interact.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, it's a good idea while developing an app to separate its components
    and have them interact exclusively through a contract called an *Application Programming
    Interface* (API for short). In the context of our app, we should maintain this
    separation between the frontend and the backend.
  prefs: []
  type: TYPE_NORMAL
- en: This means that our frontend should only interact with the backend to ask it
    to perform any of a certain list of actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'What exactly are these actions? Let''s revisit our logic flow diagram in figure
    3.11\. There are four arrows between the frontend and the backend:'
  prefs: []
  type: TYPE_NORMAL
- en: one where the frontend pulls in the quantities to show the user,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: one where it pulls in the units corresponding to the quantity selected by the
    user,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: one where the frontend provides the values to be converted, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: one where the backend returns the conversion value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](../Images/03__image011.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 Flow diagram for our app with the API actions highlighted
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'These can be boiled down into three interactions (the last two arrows are really
    two parts of the same interaction) that the frontend has with the backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '**List-quantities:** The frontend asks the backend to provide the list of quantities
    it supports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**List-units:** The frontend gives the backend a quantity and asks it to list
    the units it knows how to convert between in that quantity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Convert-value:** The frontend gives the backend the value to convert and
    the units selected by the user, and asks it to do the conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The above actions form the menu or API of our backend. As in our fast food example,
    as long as the backend can fulfill these responsibilities, it's free to implement
    them however it wants. Perhaps at some point, we'll find a more efficient way
    to perform conversions. Or maybe want to hook up the backend to an external service
    to perform the conversion. In either case, we can change the backend implementation
    without touching the frontend code.
  prefs: []
  type: TYPE_NORMAL
- en: Or maybe at some point we'll want to enable a command-line interface to our
    conversion app in addition to our graphical UI. In that instance, we can simply
    add it with no changes required to our existing frontend code.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, separating concerns between the frontend and the backend gives
    us a lot of flexibility. Our app is simple enough that the benefits may not be
    obvious, but this is a good habit to develop as it'll help you in the real world
    when you develop more complex apps and need to switch out components easily.
  prefs: []
  type: TYPE_NORMAL
- en: We'll see how to actually implement this API approach very soon.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6 Writing code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we've spent enough time thinking about the design of our app
    that we're ready to write some code.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll walk through the code for our app, starting with our
    configuration file, which plays a central role in our design. We'll define a *contract*
    or *API* between our frontend and backend, then make our backend fulfill that
    contract.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll write our frontend, learning about the Streamlit elements that
    make our UI possible as we do so, and have it issue calls to the backend through
    our defined contract to close the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6.1 Creating the configuration file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our configuration file is what holds information about the quantities and units
    our app understands.
  prefs: []
  type: TYPE_NORMAL
- en: From our design, we know that the app needs to look up the units for a given
    quantity. Furthermore, given a unit, it needs to be able to look up its conversion
    factor with respect to the standard unit for that quantity.
  prefs: []
  type: TYPE_NORMAL
- en: A Python dictionary sounds like it would be ideal for this task. Each key in
    this dictionary would be a quantity, and the associated values would be a list
    of units, or better yet, *another* dictionary where the keys are units and values
    are the corresponding conversion factors.
  prefs: []
  type: TYPE_NORMAL
- en: 'One possible way to write this might be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This certainly works, but it would be nice if we could also display the abbreviation
    for a unit (e.g., 'oz' for ounces or 'kg' for kilograms), and maybe we should
    store the standard unit for a quantity as well.
  prefs: []
  type: TYPE_NORMAL
- en: We're getting to the point where units and quantities are well-defined "things"
    with their own attributes (a unit has an abbreviation and a conversion factor,
    a quantity has a bunch of units and one unit that's designated as the standard
    one). We *could* represent this complexity by expanding our dictionary to have
    more "layers,” but it would be better practice to define *classes* for units and
    quantities.
  prefs: []
  type: TYPE_NORMAL
- en: So spin up your code editor and create a file called `unit.py` (see listing
    3.1) to define the Unit class. We're going to use a *dataclass* here, which is
    a special type of class in Python, enabled through the `dataclasses` module, which
    is part of Python's standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.1 unit.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A dataclass is an easy way to create a class with some standard basic functionality.
    For instance, with dataclasses, you don''t need to specify a `__init__` method
    as you would do with a normal class, and once you have an object of the dataclass,
    you can access its attributes with the dot-notation, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To achieve the same functionality with a regular class, you would have had
    to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With dataclasses, you can use the much more concise syntax from Listing 3.1
    by including the `@dataclass` decorator above your class definition.
  prefs: []
  type: TYPE_NORMAL
- en: Turning to the contents of the class, you can see that they're pretty simple;
    there's an `abbrev` string field that holds the abbreviation for the unit, and
    a `value_in_std_units`, a floating point number which represents the conversion
    factor we discussed in Section 3.5.1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `: str` and `: float` from Listing 3.1 are called *type annotations*. They''re
    used to specify the data type of a field. Type annotations are not strictly required,
    but it''s a good practice to include them, since (among other things) they make
    your code easier to understand and allow your code editor or IDE to catch and
    highlight errors early on.'
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we haven't included a `name` field in the `Unit` class.
    We'll discuss why when we get to the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Let's also define a `Quantity` class in a new file, `quantity.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.2 quantity.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3.2 shows the `Quantity` class. It contains two fields: `units` and
    `std_unit`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`std_unit` here is the name of the standard unit for that quantity.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the more complex type annotation we're using for the `units` field. `Dict[str,
    Unit]` means that `units` is a dictionary where each key is a string (the name
    of the unit) and the corresponding value is an object of the `Unit` class. Annotations
    for some of the more advanced types need to be imported from the `typing` module.
  prefs: []
  type: TYPE_NORMAL
- en: With that out of the way, we can now create our final configuration file (see
    Listing 3.3).
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.3 unit_config.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our configuration is still in the form of a dictionary, but each dictionary
    value is now an object of the `Quantity` class. Our file includes three quantities:
    mass, length, and time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s inspect one of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is quite readable. We're configuring a quantity named "Mass"
    as a `Quantity` object with a standard unit of "Kilograms.” The `units` dictionary
    has four entries, one for each unit, where the value is a `Unit` object with an
    abbreviation and conversion factor.
  prefs: []
  type: TYPE_NORMAL
- en: Since "Kilograms" is the standard unit, its `value_in_std_units` is 1.
  prefs: []
  type: TYPE_NORMAL
- en: You may now also realize why neither of the `Unit` and `Quantity` classes have
    a `name` field. Since the unit and quantity names are already incorporated into
    the dictionary keys in `unit_config.py`, also having it in the class is unnecessary
    and would make the configuration file longer and less readable.
  prefs: []
  type: TYPE_NORMAL
- en: Adding more units is easy; you would just add new entries to the `units` dictionary
    within the `Quantity`. Similarly, adding new quantities simply requires appending
    to the `unit_config` dictionary, following the format of the previous entries.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6.2 Implementing the API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Earlier in the chapter (section 3.5.4), we enumerated the actions we want the
    backend to be able to take:'
  prefs: []
  type: TYPE_NORMAL
- en: List-quantities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List-units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert-value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now actually implement these.
  prefs: []
  type: TYPE_NORMAL
- en: We want each of the above actions to be a function in the backend. For each,
    we'll come up with the function signature first, and then implement it.
  prefs: []
  type: TYPE_NORMAL
- en: '**List-quantities** is pretty simple; it asks the backend to list all the quantities
    it knows. There are no arguments required, and the output would probably be a
    list of strings. Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'How do we implement this? Well, the quantities we need are the keys of our
    configuration object from `unit_config.py` (in listing 3.3). So we can simply
    write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**List-units** *does* take an argument (the quantity to list the units of),
    and it would again return a list of strings. So we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Implementing this is also fairly straightforward. The list we need is composed
    of the keys of the `units` dictionary from the `Quantity` object corresponding
    to the `quantity_name` key in `unit_config`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You might realize that we're not handling the scenario where the provided `quantity_name`
    doesn't exist in `unit_config`. In the real world, we should absolutely do that,
    but for this chapter, I've excluded error handling to keep the code relatively
    concise. We'll tackle error handling in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Convert-value** takes four arguments: a quantity name, the from- and to-
    units, and a value to convert. We want to include the quantity name here due to
    the possibility that different quantities may have a unit that''s called the same
    (though our example configuration doesn''t have this).'
  prefs: []
  type: TYPE_NORMAL
- en: As for the return type, we *could* simply return the converted value, which
    would be a floating point number, and nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: Recall, however, that our configuration also has abbreviations for each unit.
    It would be nice if, on conversion, we were also able to give the frontend the
    appropriate abbreviations so it can display something like "15 ft = 5 yd."
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we don't want to be prescriptive about how the frontend *actually*
    displays the results; that's the frontend's business—remember *separation of concerns*?
    If the frontend wants to just show the converted number with no abbreviation,
    that's totally fine too.
  prefs: []
  type: TYPE_NORMAL
- en: One approach would be to wrap any metadata the frontend might need in a dedicated
    `Result` class and let the frontend figure out what to do with it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's define the `Result` class in a new file called `result.py` (listing 3.4).
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.4 result.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that rather than placing just the abbreviation for each unit in the result,
    we're including the entire `Unit`. If we decide to modify the `Unit` class later
    and add more properties to it, this code won't need to change.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we''re ready to define the signature for **Convert-value**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve already discussed how to implement the conversion, but here it is in
    code form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice the two-step conversion we discussed earlier. `value * from_unit.value_in_std_units`
    gives the value in standard units, and the `/ to_unit.value_in_std_units` converts
    it to the to-unit.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.5 puts this all together in a single `backend.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.5 backend.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 3.6.3 Implementing the frontend
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We're finally in the portion of this chapter where you'll actually be using
    Streamlit!
  prefs: []
  type: TYPE_NORMAL
- en: First we'll explore each of the features of Streamlit we'll be using, referring
    to our UI design from earlier (shown in figure 3.12), and then we'll use them
    to create our frontend.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/03__image007.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 The UI visualization for our unit converter app for reference
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We're going to be building our UI incrementally. To start, create a new Python
    file called `frontend.py` and add the imports we need (i.e., Streamlit itself,
    and the backend API functions we defined).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Save your file and run the following in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: or `streamlit run <path to frontend.py>` if your working directory is not the
    same one that contains `frontend.py.`
  prefs: []
  type: TYPE_NORMAL
- en: This will open a browser window with your app (currently just a blank screen).
    Each time you make a change, switch back to the browser window and click "Rerun"
    or "Always rerun" to see the results.
  prefs: []
  type: TYPE_NORMAL
- en: st.radio
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first component of the UI we'll focus on is the quantity selector, which
    is a bunch of radio buttons set in a panel on the left.
  prefs: []
  type: TYPE_NORMAL
- en: Radio buttons are a UI element that lets a user pick a single item out of a
    given list of items.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you append the following to the `frontend.py` file you just
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Streamlit will display the question "Select a quantity" and a list of radio
    buttons with "Mass," "Force," and "Pressure" as options. Once the user has selected
    one, the variable `quantity` will contain the option that the user picked (i.e.,
    the string "Mass," "Force," or "Pressure").
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, our list of options will come from the backend where you''ll recall
    that we have a function called `list_quantities` (listing 3.5). So we would instead
    write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This gives us the output shown in figure 3.13\. We now get "Mass," "Length,"
    and "Time" as options because `list_quantities` fetches the keys of `unit_config`
    (from our configuration file) and returns them as a list that forms the second
    argument to `st.radio`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/03__image012.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 An example output for st.radio
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `quantity` variable will contain the item currently selected by the user
    (e.g., "Mass" in figure 3.8).
  prefs: []
  type: TYPE_NORMAL
- en: Streamlit offers plenty of customization for `st.radio`. You can set the options
    horizontally instead of vertically, add a caption to each option, disable them
    altogether, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a complete list of customization possibilities in the Streamlit
    docs at [https://docs.streamlit.io/develop/api-reference/widgets/st.radio](https://docs.streamlit.io/develop/api-reference/widgets/st.radio).
  prefs: []
  type: TYPE_NORMAL
- en: st.sidebar
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We've created our radio buttons, but we now need them in a panel to the left
    as shown in figure 3.12.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of panel, in Streamlit terminology, is a *sidebar*. Sidebars are extremely
    useful when you want to create a bunch of links that lead to different pages in
    the app, provide some meta-information about your app, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `st.sidebar`, you need to put something within it. There are two ways
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a context manager (i.e., Python `with` statement) like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Any Streamlit element you place inside the `with` statement will be displayed
    in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use a dot notation and refer to an element you want to place inside
    the sidebar as a member of the sidebar, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Appending either of the above to `frontend.py` produces the output shown in
    figure 3.14.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/03__image013.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 st.sidebar in action with a set of radio buttons inside
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A sidebar is displayed with an 'X' icon that collapses it or a '>' icon that
    expands a collapsed sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: st.title
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With the sidebar in place, let''s turn our attention to the main area of the
    app. Users need to know what the app is and what it does, so we''ll add a title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This should be pretty self-explanatory, but just to state it explicitly, `st.title`
    writes any string passed to it as a title, i.e., in large bold font.
  prefs: []
  type: TYPE_NORMAL
- en: st.text_input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we need the user to enter the value they want to convert. Let's use a
    text input for this.
  prefs: []
  type: TYPE_NORMAL
- en: '`st.text_input` is Streamlit''s way of letting users enter single-line values.
    We can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: to display a text input with the caption "Value to convert" and an initial value
    of "0.” Note that `st.text_input` returns a string, so `input_num` has the string
    "0.”
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to maintain this as a number, so we''ll also cast the value to float:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With the title and text input, our app should look like figure 3.15.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/03__image014.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 Unit Converter app after adding a title and text input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`st.text_input` has lots of customization options, such as placeholder text
    that''s displayed when there''s no entered value, an optional tooltip, and the
    ability to enter passwords (we encountered this in our password checker app in
    Chapter 2).'
  prefs: []
  type: TYPE_NORMAL
- en: Again, docs.streamlit.io has more detail on what's available.
  prefs: []
  type: TYPE_NORMAL
- en: st.selectbox
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We need dropdowns for the user to pick the from- and to- units, so let's create
    those next.
  prefs: []
  type: TYPE_NORMAL
- en: '`st.selectbox` is what we''re looking for here. It displays a basic select
    widget with a label and a set of options.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The arguments are similar to what you would pass to `st.radio`. For example,
    we could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: to display a country dropdown with the variable `country` containing the selected
    option. When the dropdown first renders, the first option ("United States" in
    this case) is selected by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our use case, we need to first collect the list of options to display.
    We can call `list_units` from our backend to fetch the units available for the
    quantity the user has selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use this list to populate the options in our from- and to- unit
    dropdowns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `index` parameter we've included in the second dropdown is used to set the
    default selected option. A value of '1' means the second option will be selected
    on the first render.
  prefs: []
  type: TYPE_NORMAL
- en: We do this because we don't want both the from- and to- dropdowns to have the
    same default selected value, since that would almost never be useful (users wouldn't
    want to convert from kilograms to kilograms).
  prefs: []
  type: TYPE_NORMAL
- en: At this point, our app looks like figure 3.16.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/03__image015.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 Unit Converter app after adding from- and to- unit dropdowns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is *fine*, but our design had the from- and to- dropdowns side by side,
    which seems more natural.
  prefs: []
  type: TYPE_NORMAL
- en: st.columns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By default, Streamlit displays the UI elements from top-to-bottom in the same
    order that it encounters them in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, you don't always want this; sometimes you want things laid out side
    by side. We saw how to do this with `st.sidebar`, but an app can only have one
    sidebar, and it appears to the left of the overall UI; it can't be inline.
  prefs: []
  type: TYPE_NORMAL
- en: '`st.columns` is the answer here. To use it, you would first create a list of
    columns, specifying the number of columns you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, the call to `st.columns(2)` returns a list of two columns. The syntax
    we're using here is called *list unpacking*, and it assigns the individual items
    of a list to different variables. As you might imagine, here `from_unit_col` will
    contain the first column and `to_unit_col` will contain the second.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the case of `st.sidebar`, there are two ways to put something in a column:
    using the `with` context manager or the dot notation. So we could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: or more concisely,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Generally speaking, the `with` context manager makes more sense when you have
    multiple elements to display within a container (whether it's a sidebar, a column,
    or something else), while the dot notation works better when you only have a single
    item or when you want to display elements out of order. We'll see plenty of examples
    of these cases throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.17 shows our app by this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/03__image016.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 Unit Converter app with side-by-side from- and to- unit dropdowns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: st.button
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With all the inputs captured, we're ready to add our "Convert" button.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you remember `st.button` from Chapter 2, Streamlit's ol' faithful make-something-happen
    element.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add our button, we would write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This should be easy enough to understand. It says, "display a button that says
    'Convert' and if/when the user clicks it, execute some statements.”
  prefs: []
  type: TYPE_NORMAL
- en: Once we've written out what we want the button to do, this will render a barebones
    Streamlit red-on-white button with the functionality we've defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what do we actually want our button to do? Our backend has a `convert_value`
    function that performs the unit conversion, so let''s start by calling that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're passing `convert_value` the user-selected quantity, the from- and
    to- units, and the value to convert. Recall that `convert_value` returns an object
    of the class `Result` (defined in `result.py`)
  prefs: []
  type: TYPE_NORMAL
- en: The variable `result` thus has the result of our conversion, complete with the
    from- and to- values and abbreviations. All that remains is to display it on the
    screen. Enter…
  prefs: []
  type: TYPE_NORMAL
- en: st.metric
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We could have displayed our result as plain old paragraph text, but this is
    the big outcome of our app we're talking about, the grand finale. We want something
    that packs more *punch*.
  prefs: []
  type: TYPE_NORMAL
- en: '`st.metric` is a widget that''s commonly used in dashboards to show important
    numbers—like the revenue of a company—and how they''re trending as compared to
    a prior period.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A single `st.metric` element is meant to represent a measure the user interested
    in, and it consists of three parts: a text label, the number itself displayed
    in large font, and a "delta indicator,” which is a value that shows how much the
    number has increased or decreased from a prior period.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to use `st.metric` to display the from- and to- values along with
    the abbreviations of the units, so let''s first prepare these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Since result is an `Result` object, we form the display text by concatenating
    its `from_value` or `to_value` field and grabbing the abbreviation from `from_unit`
    or `to_unit`, which is itself an instance of `Unit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually use `st.metric`, we write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The delta indicator in `st.metric` doesn't make sense for us, so we set it to
    `None` to hide it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The above will display the from- and to- results vertically, but we need them
    side-by-side, so let''s use `st.columns` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Figure 3.18 shows our completed app.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/03__image017.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 Our completed unit converter app
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Listing 3.6 shows the `frontend.py` file you should have ended up with if you've
    been following along.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.6 frontend.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 3.7 Iterating on our app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whew! We did it! We now have a fully functional app on our hands. In the real
    world, this would just be the *start* of your journey and you would now launch
    your app and show it to users.
  prefs: []
  type: TYPE_NORMAL
- en: Users will often have very opinionated feedback about the experience you've
    built for them and can help you uncover usability issues and blind spots you may
    not have encountered in your testing.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll simulate this process by using the app ourselves and
    identifying potential improvements we can make.
  prefs: []
  type: TYPE_NORMAL
- en: 3.7.1 Rounding our conversion results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's take our completed app for a spin. Figure 3.18 shows the example results
    of converting kilograms to grams.
  prefs: []
  type: TYPE_NORMAL
- en: That looks mostly fine, but let's try a metric-to-imperial conversion now. Say
    we want to convert 4000 kilograms to pounds. We fire up our app, choose "Mass,"
    enter our inputs and hit "Convert" to see figure 3.19.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/03__image018.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.19 A metric-to-imperial conversion that shows why we should be rounding
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The answer we got seems right, but that's an awful lot of decimal places. Most
    people probably don't need that level of precision; in fact it probably detracts
    from their experience as it takes them a second to figure out why the displayed
    number is so long.
  prefs: []
  type: TYPE_NORMAL
- en: It would be nice if users had the option of rounding the result to the precision
    they really need. And come to think of it, for larger numbers we should ideally
    separate the thousands by commas.
  prefs: []
  type: TYPE_NORMAL
- en: To implement this, let's first create a function called `format_value` that
    will format a number the way we want it, i.e., with commas separating the thousands,
    and optionally rounded to a certain number of decimal points.
  prefs: []
  type: TYPE_NORMAL
- en: '`format_value` takes three arguments: the value to format, the abbreviation,
    and an optional number of `decimal_places` to round the value to. If we don''t
    pass the latter (i.e., `is_rounded` is false`)`, the function won''t do any rounding.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We use the `round` function to perform the actual rounding if we need to and
    Python's built-in `format` function to add the commas, using "," as the *format
    spec*.
  prefs: []
  type: TYPE_NORMAL
- en: We could just hardcode the number of decimal places to round to, but ideally
    we should let the user decide, which means adding a new input widget.
  prefs: []
  type: TYPE_NORMAL
- en: st.number_input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`st.number_input` is Streamlit''s numeric input widget. It''s quite similar
    to `st.text_input`, but it has some additional functionality, such as the ability
    to specify a minimum and maximum value, and a step button that lets you increase
    or decrease the entered value by clicking.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use it to collect the user''s preferred number of decimal places by
    adding this line to `frontend.py` right after the from- and to- unit dropdowns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We specify a default value of 2, and a minimum value of 0 since we can't have
    a negative number of decimal places (trying to enter a lower value shows an error.
    `places` will hold the entered number.
  prefs: []
  type: TYPE_NORMAL
- en: This should give us the widget shown in figure 3.20.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/03__image019.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.20 st.number_input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Notice the '-' and '+' buttons that let you increase or decrease the value by
    1\. You can adjust the step-interval to something else by specifying the `step`
    parameter in `st.number_input`.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we bothered to use `st.text_input` to collect the value-to-convert
    and cast to float when `st.number_input` was available. This is because at the
    time of writing, there doesn't seem to be an easy way to get rid of the '-' and
    '+ buttons in `st.number_input`. These make sense when we're collecting the number
    of decimal places, which is an integer in a very tight range, but the value-to-convert
    is virtually unbounded and there's no predefined step-interval that makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, now that we''ve collected the decimal places, we''re ready to apply our
    formatting when we display the results. We can do this by changing the `from_display`
    and `to_display` variables so that they use the `format_value` function we defined
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We pass `places` (which we collect from the user) to round the `to_display`
    variable. We could have done this for `from_display` as well, but it's likely
    the user entered the precision they want to see in the from-value, so we don't
    want to mess with that.
  prefs: []
  type: TYPE_NORMAL
- en: This gives us figure 3.21.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/03__image020.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.21 Unit converter app with a decimal places input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This won't pad to-values with extra trailing zeroes. For instance, if the to-value
    is a whole number, say 600, it will be displayed as "600.0" with just the one
    trailing zero.
  prefs: []
  type: TYPE_NORMAL
- en: The formatted result looks much nicer, but we've also added an extra numeric
    input that increases the user's cognitive load a little. Maybe we should only
    introduce the decimal-places input if the user asks for it.
  prefs: []
  type: TYPE_NORMAL
- en: st.checkbox
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`st.checkbox` is a Streamlit checkbox, i.e., a box that you can, well, check.
    Please try to contain your shock, we have an app to ship.'
  prefs: []
  type: TYPE_NORMAL
- en: Like `st.button`, `st.checkbox` is a *conditional* element; you can use an if
    statement to branch your logic based on whether it's checked or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our use case is to let the user decide if they want to round the conversion
    result, which we can do by modifying how we obtain the value of the `places` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The checkbox is unchecked by default since we're passing False to the value
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we've included the line `places = None` above the `st.checkbox`
    code. This is because, down below, we're referring to `places` outside of the
    scope of the `if st.checkbox` block, so we need to pass an initial value to it
    in case the user leaves the box unchecked.
  prefs: []
  type: TYPE_NORMAL
- en: Our app should now look like figure 3.22.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/03__image021.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.22 Unit converter app with rounding enabled
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Or if the user leaves "Round result?" unchecked, we get the full-precision treatment
    in figure 3.23.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/03__image022.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.23 Unit converter app with rounding disabled
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 3.7.2 Getting rid of the button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app works great now; it displays rounded output, but only if we want it
    to. We've added a click and a numeric input to enable this, however.
  prefs: []
  type: TYPE_NORMAL
- en: Is there perhaps a way to simplify this experience? Let's turn our attention
    to the "Convert" button. Do we really even need it?
  prefs: []
  type: TYPE_NORMAL
- en: All it does is trigger the conversion. But we don't really need an explicit
    trigger. Why not have the app *always* show the result based on the entered inputs?
    So if the user changes the value, they would immediately see the conversion result
    rather than having to click the button again.
  prefs: []
  type: TYPE_NORMAL
- en: That definitely seems like a more intuitive experience, so let's make it happen.
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, this is easy to do. Simply remove the line if `st.button("Convert"):`
    and move everything in that block outside.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.7 shows the final version of frontend.py.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.7 Final version of frontend.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: And figure 3.24 shows a final screenshot of our app.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/03__image023.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.24 Unit converter app with the "Convert" button removed
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You'll find that removing the button makes the app *flow* a lot better. For
    instance, if you change the decimal places or the value, you see the results instantly.
  prefs: []
  type: TYPE_NORMAL
- en: I hope this chapter has been a lot of fun! We started with a mere concept, broke
    it down into concrete requirements, designed a UI, thought deeply about the implementation,
    wrote code to turn our ideas into a working app, and refined it for a better user
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: The point of this chapter was to give you a sense of what it's like to develop
    Streamlit apps in the real world while working with real stakeholders. As you've
    hopefully learned, there's a lot more to the process than writing code; things
    like nailing the requirements and designing (and refining) the user experience
    are equally important.
  prefs: []
  type: TYPE_NORMAL
- en: 3.8 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building an app from a concept is about a lot more than writing code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The six steps involved in creating a Streamlit app in the real world are: state
    the concept, define the requirements, visualize the user experience, brainstorm
    implementation, write code, and iterate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements can come from your users or from non-user stakeholders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's a good idea to visualize the user experience at the start by sketching
    mocks so you have something to work towards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brainstorming the implementation involves analyzing tradeoffs and mapping the
    flow of logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating your frontend and backend code and defining an API for the two to
    interact is a great way to organize your app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`st.text_input` and `st.number_input` allow users to input text and numeric
    values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`st.radio` and `st.selectbox` let users select a value from a list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`st.sidebar` and `st.columns` are layout elements that let you break the natural
    top-to-bottom way that Streamlit renders UI elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`st.button` and `st.checkbox` are both conditional elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
