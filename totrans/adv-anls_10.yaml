- en: Chapter 8\. Data Manipulation and Visualization in R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'American statistician Ronald Thisted once quipped: “Raw data, like raw potatoes,
    usually require cleaning before use.” Data manipulation takes time, and you’ve
    felt the pain if you’ve ever done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select, drop, or create calculated columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sort or filter rows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group by and summarize categories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join multiple datasets by a common field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chances are, you’ve done all of these in Excel…*a lot*, and you’ve probably
    dug into celebrated features like `VLOOKUP()` and PivotTables to accomplish them.
    In this chapter, you’ll learn the R equivalents of these techniques, particularly
    with the help of `dplyr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data manipulation often goes hand in hand with visualization: as mentioned,
    humans are remarkably adept at visually processing information, so it’s a great
    way to size up a dataset. You’ll learn how to visualize data using the gorgeous
    `ggplot2` package, which like `dplyr` is part of the `tidyverse`. This will put
    you on solid footing to explore and test relationships in data using R, which
    will be covered in [Chapter 9](ch09.html#r-capstone). Let’s get started by calling
    in the relevant packages. We’ll also be using the *star* dataset from the book’s
    [companion repository](https://oreil.ly/lmZb7) in this chapter, so we can import
    it now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Data Manipulation with dplyr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`dplyr` is a popular package built to manipulate tabular data structures. Its
    many functions, or *verbs*, work similarly and can be easily used together. [Table 8-1](#dplyr-grammar)
    lists some common `dplyr` functions and their uses; this chapter covers each of
    these.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-1\. Frequently used verbs of `dplyr`
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | What it does |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `select()` | Selects given columns |'
  prefs: []
  type: TYPE_TB
- en: '| `mutate()` | Creates new columns based on existing columns |'
  prefs: []
  type: TYPE_TB
- en: '| `rename()` | Renames given columns |'
  prefs: []
  type: TYPE_TB
- en: '| `arrange()` | Reorders rows given criteria |'
  prefs: []
  type: TYPE_TB
- en: '| `filter()` | Selects rows given criteria |'
  prefs: []
  type: TYPE_TB
- en: '| `group_by()` | Groups rows by given columns |'
  prefs: []
  type: TYPE_TB
- en: '| `summarize()` | Aggregates values for each group |'
  prefs: []
  type: TYPE_TB
- en: '| `left_join()` | Joins matching records from Table B to Table A; result is
    `NA` if no match found in Table B |'
  prefs: []
  type: TYPE_TB
- en: For the sake of brevity, I won’t cover all of the functions of `dplyr` or even
    all the ways to use the functions that we do cover. To learn more about the package,
    check out [*R for Data Science*](https://oreil.ly/KGoCV) by Hadley Wickham and
    Garrett Grolemund (O’Reilly). You can also access a helpful cheat sheet summarizing
    how the many functions of `dplyr` work together by navigating in RStudio to Help
    → Cheatsheets → Data Transformation with `dplyr`.
  prefs: []
  type: TYPE_NORMAL
- en: Column-Wise Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Selecting and dropping columns in Excel often requires hiding or deleting them.
    This can be difficult to audit or reproduce, because hidden columns are easily
    overlooked, and deleted columns aren’t easily recovered. The `select()` function
    can be used to choose given columns from a data frame in R. For `select()`, as
    with each of these functions, the first argument will be which data frame to work
    with. Additional arguments are then provided to manipulate the data in that data
    frame. For example, we can select *tmathssk*, *treadssk*, and *schidkin* from
    `star` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the `-` operator with `select()` to *drop* given columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A more elegant alternative here is to pass all unwanted columns into a vector,
    *then* drop it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep in mind that in the previous examples, we’ve just been calling functions:
    we didn’t actually assign the output to an object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One more bit of shorthand for `select()` is to use the `:` operator to select
    everything between two columns, inclusive. This time, I will assign the results
    of selecting everything from *tmathssk* to *totexpk* back to `star`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ve likely created calculated columns in Excel; `mutate()` will do the same
    in R. Let’s create a column *new_column* of combined reading and math scores.
    With `mutate()`, we’ll provide the name of the new column *first*, then an equal
    sign, and finally the calculation to use. We can refer to other columns as part
    of the formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`mutate()` makes it easy to derive relatively more complex calculated columns
    such as logarithmic transformations or lagged variables; check out the help documentation
    for more.'
  prefs: []
  type: TYPE_NORMAL
- en: '*new_column* isn’t a particularly helpful name for total score. Fortunately,
    the `rename()` function does what it sounds like it would. We’ll specify what
    to name the new column in place of the old:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Row-Wise Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thus far we’ve been operating on *columns*. Now let’s focus on *rows*; specifically
    sorting and filtering. In Excel, we can sort by multiple columns with the Custom
    Sort menu. Say for example we wanted to sort this data frame by *classk*, then
    *treadssk*, both ascending. Our menu in Excel to do this would look like [Figure 8-1](#custom-sort-excel).
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom sort menu in Excel](assets/aina_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. The Custom Sort menu in Excel
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can replicate this in `dplyr` by using the `arrange()` function, including
    each column in the order in which we want the data frame sorted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can pass the `desc()` function to a column if we’d like that column to be
    sorted descendingly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Excel tables include helpful drop-down menus to filter any column by given
    conditions. To filter a data frame in R, we’ll use the aptly named `filter()`
    function. Let’s filter `star` to keep only the records where `classk` is equal
    to `small.class`. Remember that because we are checking for equality rather than
    assigning an object, we’ll have to use `==` and not `=` here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see from the tibble output that our `filter()` operation *only* affected
    the number of rows, *not* the columns. Now we’ll find the records where `treadssk`
    is at least `500`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s possible to filter by multiple conditions using the `&` operator for “and”
    along with the `|` operator for “or.” Let’s combine our two criteria from before
    with `&`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Aggregating and Joining Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I like to call PivotTables “the WD-40 of Excel” because they allow us to get
    our data “spinning” in different directions for easy analysis. For example, let’s
    recreate the PivotTable in [Figure 8-2](#excel-pivot-table) showing the average
    math score by class size from the *star* dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How Excel PivotTables work](assets/aina_0802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2\. How Excel PivotTables work
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As [Figure 8-2](#excel-pivot-table) calls out, there are two elements to this
    PivotTable. First, I aggregated our data by the variable *classk*. Then, I summarized
    it by taking an average of *tmathssk*. In R, these are discrete steps, using different
    `dplyr` functions. First, we’ll aggregate the data using `group_by()`. Our output
    includes a line, `# Groups: classk [3]`, indicating that `star_grouped` is split
    into three groups with the `classk` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We’ve *grouped* our data by one variable; now let’s *summarize* it by another
    with the `summarize()` function (`summarise()` also works). Here we’ll specify
    what to name the resulting column, and how to calculate it. [Table 8-2](#dplyr-agg-types)
    lists some common aggregation functions.
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-2\. Helpful aggregation functions for `dplyr`
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Aggregation type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `sum()` | Sum |'
  prefs: []
  type: TYPE_TB
- en: '| `n()` | Count values |'
  prefs: []
  type: TYPE_TB
- en: '| `mean()` | Average |'
  prefs: []
  type: TYPE_TB
- en: '| `max()` | Highest value |'
  prefs: []
  type: TYPE_TB
- en: '| `min()` | Lowest value |'
  prefs: []
  type: TYPE_TB
- en: '| `sd()` | Standard deviation |'
  prefs: []
  type: TYPE_TB
- en: 'We can get the average math score by class size by running `summarize()` on
    our grouped data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `` `summarise()` ungrouping output `` error is a warning that you’ve ungrouped
    the grouped tibble by aggregating it. Minus some formatting differences, we have
    the same results as [Figure 8-2](#excel-pivot-table).
  prefs: []
  type: TYPE_NORMAL
- en: 'If PivotTables are the WD-40 of Excel, then `VLOOKUP()` is the duct tape, allowing
    us to easily combine data from multiple sources. In our original *star* dataset,
    *schidkin* is a school district indicator. We dropped this column earlier in this
    chapter, so let’s read it in again. But what if in addition to the indicator number
    we actually wanted to know the *names* of these districts? Fortunately, *districts.csv*
    in the book repository has this information, so let’s read both in and come up
    with a strategy for combining them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It appears that what’s needed is like a `VLOOKUP()`: we want to “read in” the
    *school_name* (and possibly the *county*) variables from *districts* into *star*,
    given the shared *schidkn* variable. To do this in R, we’ll use the methodology
    of *joins*, which comes from relational databases, a topic that was touched on
    in [Chapter 5](ch05.html#data-analytics-stack). Closest to a `VLOOKUP()` is the
    left outer join, which can be done in `dplyr` with the `left_join()` function.
    We’ll provide the “base” table first (*star*) and then the “lookup” table (*districts*).
    The function will look for and return a match in *districts* for every record
    in *star*, or return `NA` if no match is found. I will keep only some columns
    from *star* for less overwhelming console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`left_join()` is pretty smart: it knew to join on `schidkn`, and it “looked
    up” not just *school_name* but also *county*. To learn more about joining data,
    check out the help documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: In R, missing observations are represented as the special value `NA`. For example,
    it appears that no match was found for the name of district 5\. In a `VLOOKUP()`,
    this would result in an `#N/A` error. An `NA` does *not* mean that an observation
    is equal to zero, only that its value is missing. You may see other special values
    such as `NaN` or `NULL` while programming R; to learn more about them, launch
    the help documentation.
  prefs: []
  type: TYPE_NORMAL
- en: dplyr and the Power of the Pipe (%>%)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you’re beginning to see, `dplyr` functions are powerful and rather intuitive
    to anyone who’s worked with data, including in Excel. And as anyone who’s worked
    with data knows, it’s rare to prepare the data as needed in just one step. Take,
    for example, a typical data analysis task that you might want to do with *star*:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the average reading score by class type, sorted high to low.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Knowing what we do about working with data, we can break this into three distinct
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Group our data by class type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the average reading score for each group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort these results from high to low.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We could carry this out in `dplyr` doing something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This gets us to an answer, but it took quite a few steps, and it can be hard
    to follow along with the various functions and object names. The alternative is
    to link these functions together with the `%>%`, or pipe, operator. This allows
    us to pass the output of one function directly into the input of another, so we’re
    able to avoid continuously renaming our inputs and outputs. The default keyboard
    shortcut for this operator is Ctrl+Shift+M for Windows, Cmd-Shift-M for Mac.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s re-create the previous steps, this time with the pipe operator. We’ll
    place each function on its own line, combining them with `%>%`. While it’s not
    necessary to place each step on its own line, it’s often preferred for legibility.
    When using the pipe operator, it’s also not necessary to highlight the entire
    code block to run it; simply place your cursor anywhere in the following selection
    and execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be pretty disorienting at first to no longer be explicitly including
    the data source as an argument in each function. But compare the last code block
    to the one before and you can see how much more efficient this approach can be.
    What’s more, the pipe operator can be used with non-`dplyr` functions. For example,
    let’s just assign the first few rows of the resulting operation by including `head()`
    at the end of the pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Reshaping Data with tidyr
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although it’s true that `group_by()` along with `summarize()` serve as a PivotTable
    equivalent in R, these functions can’t do everything that an Excel PivotTable
    can do. What if, instead of just aggregating the data, you wanted to *reshape*
    it, or change how rows and columns are set up? For example, our *star* data frame
    has two separate columns for math and reading scores, *tmathssk* and *treadssk*,
    respectively. I would like to combine these into one column called *score*, with
    another called *test_type* indicating whether each observation is for math or
    reading. I’d also like to keep the school indicator, *schidkn*, as part of the
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-3](#excel-reshape) shows what this might look like in Excel; note
    that I relabeled the Values fields from *tmathssk* and *treadssk* to *math* and
    *reading*, respectively. If you would like to inspect this PivotTable further,
    it is available in the [book repository as *ch-8.xlsx*](https://oreil.ly/Kq93s).
    Here I am again making use of an index column; otherwise, the PivotTable would
    attempt to “roll up” all values by *schidkn*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reshaping Excel](assets/aina_0803.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3\. Reshaping *star* in Excel
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can use `tidyr`, a core `tidyverse` package, to reshape *star*. Adding an
    index column will also be helpful when reshaping in R, as it was in Excel. We
    can make one with the `row_number()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To reshape the data frame, we’ll use `pivot_longer()` and `pivot_wider()`,
    both from `tidyr`. Consider in your mind’s eye and in [Figure 8-3](#excel-reshape)
    what would happen to our dataset if we consolidated scores from *tmathssk* and
    *treadssk* into one column. Would the dataset get longer or wider? We’re adding
    rows here, so our dataset will get longer. To use `pivot_longer()`, we’ll specify
    with the `cols` argument what columns to lengthen by, and use `values_to` to name
    the resulting column. We’ll also use `names_to` to name the column indicating
    whether each score is math or reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Great work. But is there a way to rename *tmathssk* and *treadssk* to *math*
    and *reading*, respectively? There is, with `recode()`, yet another helpful `dplyr`
    function that can be used with `mutate()`. `recode()` works a little differently
    than other functions in the package because we include the name of the “old” values
    *before* the equals sign, then the new. The `distinct()` function from `dplyr`
    will confirm that all rows have been named either *math* or *reading*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our data frame is lengthened, we can widen it back with `pivot_wider()`.
    This time, I’ll specify which column has values in its rows that should be columns
    with `values_from`, and what the resulting columns should be named with `names_from`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Reshaping data is a relatively trickier operation in R, so when in doubt, ask
    yourself: *am I making this data wider or longer? How would I do it in a PivotTable?*
    If you can logically walk through what needs to happen to achieve the desired
    end state, coding it will be that much easier.'
  prefs: []
  type: TYPE_NORMAL
- en: Data Visualization with ggplot2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There’s so much more that `dplyr` can do to help us manipulate data, but for
    now let’s turn our attention to data visualization. Specifically, we’ll focus
    on another `tidyverse` package, `ggplot2`. Named and modeled after the “grammar
    of graphics” devised by computer scientist Leland Wilkinson, `ggplot2` provides
    an ordered approach for constructing plots. This structure is patterned after
    how elements of speech come together to make a sentence, hence the “grammar” of
    graphics.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll cover some of the basic elements and plot types of `ggplot2` here. For
    more about the package, check out *ggplot2: Elegant Graphics for Data Analysis*
    by the package’s original author, Hadley Wickham (Springer). You can also access
    a helpful cheat sheet for working with the package by navigating in RStudio to
    Help → Cheatsheets → Data Visualization with ggplot2\. Some essential elements
    of `ggplot2` are found in [Table 8-3](#elements-of-ggplot2). Other elements are
    available; for more information, check out the resources mentioned earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-3\. The foundational elements of `ggplot2`
  prefs: []
  type: TYPE_NORMAL
- en: '| Element | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `data` | The source data |'
  prefs: []
  type: TYPE_TB
- en: '| `aes` | The aesthetic mappings from data to visual properties (x- and y-axes,
    color, size, and so forth) |'
  prefs: []
  type: TYPE_TB
- en: '| `geom` | The type of geometric object observed in the plot (lines, bars,
    dots, and so forth) |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s get started by visualizing the number of observations for each level
    of *classk* as a barplot. We’ll start with the `ggplot()` function and specify
    the three elements from [Table 8-3](#elements-of-ggplot2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_data_manipulation_and_visualization_in_r_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The data source is specified with the `data` argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_data_manipulation_and_visualization_in_r_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The aesthetic mappings from the data to the visualization are specified with
    the `aes()` function. Here we are calling for *classk* to be mapped to the x-axis
    of the eventual plot.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_data_manipulation_and_visualization_in_r_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We plot a geometric object based on our specified data and aesthetic mappings
    with the `geom_bar()` function. The results are shown in [Figure 8-4](#barplot-ggplot2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Countplot](assets/aina_0804.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-4\. A barplot in `ggplot2`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Similar to the pipe operator, it’s not necessary to place each layer of the
    plot on its own line, but it’s often preferred for legibility. It’s also possible
    to execute the entire plot by placing the cursor anywhere inside the code block
    and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of its modular approach, it’s easy to iterate on visualizations with
    `ggplot2`. For example, we can switch our plot to a histogram of *treadssk* by
    changing our `x` mapping and plotting the results with `geom_histogram()`. This
    results in the histogram shown in [Figure 8-5](#histogram-ggplot2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![Histogram](assets/aina_0805.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-5\. A histogram in `ggplot2`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There are also many ways to customize `ggplot2` plots. You may have noticed,
    for example, that the output message for the previous plot indicated that 30 bins
    were used in the histogram. Let’s change that number to 25 and use a pink fill
    with a couple of additional arguments in `geom_histogram()`. This results in the
    histogram shown in [Figure 8-6](#custom-histogram-ggplot2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![Custom Histogram](assets/aina_0806.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-6\. A customized histogram in `ggplot2`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Use `geom_boxplot()` to create a boxplot, as shown in [Figure 8-7](#boxplot-ggplot2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![Boxplot](assets/aina_0807.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-7\. A boxplot
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In any of the cases thus far, we could have “flipped” the plot by including
    the variable of interest in the `y` mapping instead of the `x`. Let’s try it with
    our boxplot. [Figure 8-8](#reverse-boxplot-ggplot2) shows the result of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![Flipped boxplot](assets/aina_0808.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-8\. A “flipped” boxplot
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now let’s make a boxplot for each level of class size by mapping *classk* to
    the x-axis and *treadssk* to the y, resulting in the boxplot shown in [Figure 8-9](#grouped-boxplot-ggplot2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can use `geom_point()` to plot the relationship of *tmathssk*
    and *treadssk* on the x- and y-axes, respectively, as a scatterplot. This results
    in [Figure 8-10](#scatterplot-ggplot2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![Grouped boxplot](assets/aina_0809.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-9\. A boxplot by group
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Scatterplot](assets/aina_0810.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-10\. A scatterplot
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can use some additional `ggplot2` functions to layer labels onto the x-
    and y-axes, along with a plot title. [Figure 8-11](#labeled-plot-ggplot2) shows
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![Scatterplot with custom labels and title](assets/aina_0811.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-11\. A scatterplot with custom axis labels and title
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There’s so much more that `dplyr` and `ggplot2` can do, but this is enough
    to get you started with the true task at hand: to explore and test relationships
    in data. That will be the focus of [Chapter 9](ch09.html#r-capstone).'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The [book repository](https://oreil.ly/kBk3e) has two files in the *census*
    subfolder of *datasets*, *census.csv* and *census-divisions.csv*. Read these into
    R and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Sort the data by region ascending, division ascending, and population descending.
    (You will need to combine datasets to do this.) Write the results to an Excel
    worksheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drop the postal code field from your merged dataset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new column *density* that is a calculation of population divided by
    land area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visualize the relationship between land area and population for all observations
    in 2015.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the total population for each region in 2015.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a table containing state names and populations, with the population for
    each year 2010–2015 kept in an individual column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
