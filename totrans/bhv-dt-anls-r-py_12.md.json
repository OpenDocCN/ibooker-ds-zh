["```py\n## R\nlibrary(pwr) # For traditional power analysis\n```", "```py\n## Python\nimport statsmodels.stats.proportion as ssprop # For the standardized effect size\nimport statsmodels.stats.power as ssp # For traditional power analysis\n```", "```py\n## R\n> K <- 2\n> assgnt = runif(1,0,1)\n> group = ifelse(assgnt <= 1/K, “control”, “treatment”)\n```", "```py\n## Python\nK = 2\nassgnt = np.random.uniform(0,1,1)\ngroup = \"control\" if assgnt <= 1/K else \"treatment\"\n```", "```py\n## R\n> effect_size <- ES.h(0.1925,0.1825)\n> pwr.2p.test(h = effect_size, n = NULL, sig.level = 0.05, power = 0.8,\n                      alternative = \"greater\")\n\n     Difference of proportion power calculation for binomial distribution\n                      (arcsine transformation) \n\n              h = 0.02562255\n              n = 18834.47\n      sig.level = 0.05\n          power = 0.8\n    alternative = greater\n\nNOTE: same sample sizes\n```", "```py\n## Python\neffect_size = ssprop.proportion_effectsize(0.194, 0.184)\nssp.tt_ind_solve_power(effect_size = effect_size, \n                       alpha = 0.05, \n                       nobs1 = None, \n                       alternative = 'larger', \n                       power=0.8)\nOut[1]: 18950.818821558503\n```", "```py\n## R (output not shown)\nexp_null_data <- hist_data %>%\n  slice_sample(n=20000) %>%\n  mutate(oneclick = ifelse(runif(20000)>0.5,1,0)) %>%\n  mutate(oneclick = factor(oneclick, levels=c(0,1)))\nsummary(glm(booked ~ oneclick + age + gender, \n                     data = exp_null_data, family = binomial(link = \"logit\")))\n```", "```py\n## Python \nexp_null_data_df = hist_data_df.copy().sample(2000)\nexp_null_data_df['oneclick'] = np.where(np.random.uniform(0,1,2000)>0.5, 1, 0)\nmod = smf.logit('booked ~ oneclick + age + gender', data = exp_null_data_df)\nmod.fit(disp=0).summary()\n...\n               coef     std err    z      P>|z| [0.025    0.975]\nIntercept      9.5764    0.621   15.412    0.000    8.359   10.794\ngender[T.male] 0.1589    0.136    1.167    0.243    -0.108   0.426\noneclick       0.0496    0.136    0.365    0.715    -0.217   0.316\nage           -0.3017    0.017  -17.434    0.000    -0.336  -0.268\n...\n```", "```py\n## R\n#Metric function\nlog_reg_fun <- function(dat){\n  #Running logistic regression\n  log_mod_exp <- glm(booked ~ oneclick + age + gender, \n                     data = dat, family = binomial(link = \"logit\"))\n  summ <- summary(log_mod_exp)\n  metric <- summ$coefficients['oneclick1', 'Estimate']\n  return(metric)}\n```", "```py\n## Python\ndef log_reg_fun(dat_df):\n    model = smf.logit('booked ~ oneclick + age + gender', data = dat_df)\n    res = model.fit(disp=0)\n    coeff = res.params['oneclick']\n    return coeff\n```", "```py\n## R\nboot_CI_fun <- function(dat, metric_fun){\n  # Setting the number of bootstrap samples\n  B <- 100\n\n  boot_metric_fun <- function(dat, J){\n    boot_dat <- dat[J,]\n    return(metric_fun(boot_dat))}\n  boot.out <- boot(data=dat, statistic=boot_metric_fun, R=B)\n  confint <- boot.ci(boot.out, conf = 0.90, type = c('perc'))\n  CI <- confint$percent[c(4,5)]\n  return(CI)}\n```", "```py\n## Python\ndef boot_CI_fun(dat_df, metric_fun, B = 100, conf_level = 0.9):\n  #Setting sample size\n  N = len(dat_df)\n  conf_level = conf_level\n  coeffs = []\n\n  for i in range(B):\n      sim_data_df = dat_df.sample(n=N, replace = True)\n      coeff = metric_fun(sim_data_df)\n      coeffs.append(coeff)\n\n  coeffs.sort()\n  start_idx = round(B * (1 - conf_level) / 2)\n  end_idx = - round(B * (1 - conf_level) / 2)\n  confint = [coeffs[start_idx], coeffs[end_idx]]  \n  return(confint)\n```", "```py\n## R\ndecision_fun <- function(dat){\n  boot_CI <- boot_CI_fun(dat, metric_fun)\n  decision <- ifelse(boot_CI[1]>0,1,0)\n  return(decision)}\n```", "```py\n## Python\ndef decision_fun(dat_df, metric_fun, B = 100, conf_level = 0.9):\n    boot_CI = boot_CI_fun(dat_df, metric_fun, B = B, conf_level = conf_level)\n    decision = 1 if boot_CI[0] > 0  else 0\n    return decision\n```", "```py\n## R\n> single_sim_fun <- function(dat, metric_fun, Nexp, eff_size, B = 100, \n                             conf.level = 0.9){\n\n    #Adding predicted probability of booking ![1](Images/1.png)\n    hist_mod <- glm(booked ~ age + gender + period, \n                    family = binomial(link = \"logit\"), data = dat)\n    sim_data <- dat %>%\n      mutate(pred_prob_bkg = hist_mod$fitted.values) %>%\n      #Filtering down to desired sample size ![2](Images/2.png)\n      slice_sample(n = Nexp) %>%\n      #Random assignment of experimental groups ![3](Images/3.png)         \n      mutate(oneclick = ifelse(runif(Nexp,0,1) <= 1/2, 0, 1)) %>%\n      mutate(oneclick = factor(oneclick, levels=c(0,1))) %>%\n      # Adding effect to treatment group ![4](Images/4.png)     \n      mutate(pred_prob_bkg = ifelse(oneclick == 1, \n                                    pred_prob_bkg + eff_size, \n                                    pred_prob_bkg)) %>%\n      mutate(booked = ifelse(pred_prob_bkg >= runif(Nexp,0,1),1, 0))\n\n    #Calculate the decision (we want it to be 1) ![5](Images/5.png) \n    decision <- decision_fun(sim_data, metric_fun, B = B, \n                           conf.level = conf.level)\nreturn(decision)}\n```", "```py\n## Python \ndef single_sim_fun(Nexp, dat_df, metric_fun, eff_size, B = 100,\n                   conf_level = 0.9):\n\n    #Adding predicted probability of booking      \n    hist_model = smf.logit('booked ~ age + gender + period', data = dat_df)\n    res = hist_model.fit(disp=0)\n    sim_data_df = dat_df.copy()\n    sim_data_df['pred_prob_bkg'] = res.predict()\n    #Filtering down to desired sample size   \n    sim_data_df = sim_data_df.sample(Nexp)\n    #Random assignment of experimental groups             \n    sim_data_df['oneclick'] = np.where(np.random.uniform(size=Nexp) <= 0.5, 0, 1)\n    # Adding effect to treatment group                      \n    sim_data_df['pred_prob_bkg'] = np.where(sim_data_df.oneclick == 1, \n                                            sim_data_df.pred_prob_bkg + eff_size, \n                                            sim_data_df.pred_prob_bkg)\n    sim_data_df['booked'] = np.where(sim_data_df.pred_prob_bkg >= \\\n                                     np.random.uniform(size=Nexp), 1, 0)\n\n    #Calculate the decision (we want it to be 1)                    \n    decision = decision_fun(sim_data_df, metric_fun = metric_fun, B = B, \n                            conf_level = conf_level)\n    return decision\n```", "```py\n## R\npower_sim_fun <- function(dat, metric_fun, Nexp, eff_size, Nsim, \n                          B = 100, conf.level = 0.9){\n  power_list <- vector(mode = \"list\", length = Nsim)\n  for(i in 1:Nsim){\n    power_list[[i]] <- single_sim_fun(dat, metric_fun, Nexp, eff_size, \n                                      B = B, conf.level = conf.level)}\n  power <- mean(unlist(power_list))\n  return(power)}\n```", "```py\n## Python\ndef power_sim_fun(dat_df, metric_fun, Nexp, eff_size, Nsim, B = 100, \n                  conf_level = 0.9):\n    power_lst = []\n    for i in range(Nsim):\n        print(\"starting simulation number\", i, \"\\n\")\n        power_lst.append(single_sim_fun(Nexp = Nexp, dat_df = dat_df, \n                                        metric_fun = metric_fun, \n                                        eff_size = eff_size, B = B, \n                                        conf_level = conf_level))\n    power = np.mean(power_lst)\n    return(power)\n```", "```py\n## Python (output not shown)\npower_sim_fun(dat_df=hist_data_df, metric_fun = log_reg_fun, Nexp = int(4e4), \n              eff_size=0.01, Nsim=20)\n```", "```py\n## R\n> set.seed(1234)\n> power_sim_fun(dat=hist_data, effect_size=0.01, Nexp=4e4, Nsim=20)\n[1] 0.9\n```", "```py\n## Python code (output not shown)\nimport statsmodels.formula.api as smf\nmodel = smf.logit('booked ~ age + gender + oneclick', data = exp_data_df)\nres = model.fit()\nres.summary()\n```", "```py\n## R\n> log_mod_exp <- glm(booked ~ oneclick + age + gender, \n                     data = exp_data, family = binomial(link = \"logit\"))\n> summary(log_mod_exp)\n\n...\nCoefficients:\n             Estimate Std. Error z value    Pr(>|z|)    \n(Intercept)  11.94701    0.22601  52.861     < 2e-16 ***\noneclick1     0.15784    0.04702   3.357    0.000789 ***\nage          -0.39406    0.00643 -61.282     < 2e-16 ***\ngenderfemale -0.25420    0.04905  -5.182 0.000000219 ***\n...\n```", "```py\n## R (output not shown)\n> diff_prob_fun <- function(dat, reg_model = log_mod_exp){\n    no_button <- dat %>% ![1](Images/1.png)                                  \n      mutate(oneclick = 0) %>%                                                      \n      mutate(oneclick = factor(oneclick, levels=c(0, 1))) %>%\n      select(age, gender, oneclick)\n    button <- dat %>% ![2](Images/2.png)                                        \n      mutate(oneclick = 1) %>% \n      mutate(oneclick = factor(oneclick, levels=c(0, 1))) %>%\n      select(age, gender, oneclick)\n    #Adding the predictions of the model \n    no_button <- no_button %>% ![3](Images/3.png)                           \n      mutate(pred_mod = predict(object=reg_model, newdata = no_button, \n                                type=\"response\"))\n    button <- button %>%\n      mutate(pred_mod = predict(object=reg_model, newdata = button, \n                                type=\"response\"))\n    #Calculating average difference in probabilities\n    diff <- button$pred_mod - no_button$pred_mod ![4](Images/4.png)   \n    return(mean(diff))}\n> diff_prob_fun(exp_data, reg_model = log_mod_exp)\n```", "```py\n## Python\ndef diff_prob_fun(dat_df, reg_model = log_mod_exp):\n\n    #Creating new copies of data\n    no_button_df = dat_df.loc[:, 'age':'gender'] \n    no_button_df.loc[:, 'oneclick'] = 0\n    button_df = dat_df.loc[:,'age':'gender']                        \n    button_df.loc[:, 'oneclick'] = 1\n\n    #Adding the predictions of the model \n    no_button_df.loc[:, 'pred_bkg_rate'] = res.predict(no_button_df) \n    button_df.loc[:, 'pred_bkg_rate'] = res.predict(button_df)\n\n    diff = button_df.loc[:,'pred_bkg_rate'] \\    \n    - no_button_df.loc[:,'pred_bkg_rate']\n    return diff.mean()\ndiff_prob_fun(exp_data_df, reg_model = log_mod_exp)\n0.007129714313551981\n```"]