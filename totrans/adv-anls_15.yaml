- en: Chapter 12\. Data Manipulation and Visualization in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 8](ch08.html#r-data-manipulation-visualization) you learned how
    to manipulate and visualize data, with heavy help from the `tidyverse` suite of
    packages. Here we’ll demonstrate similar techniques on the same *star* dataset,
    this time in Python. In particular, we’ll use `pandas` and `seaborn` to manipulate
    and visualize data, respectively. This isn’t a comprehensive guide to what these
    modules, or Python, can do with data analysis. Instead, it’s enough to get you
    exploring on your own.
  prefs: []
  type: TYPE_NORMAL
- en: As much as possible, I’ll mirror the steps and perform the same operations that
    we did in [Chapter 8](ch08.html#r-data-manipulation-visualization). Because of
    this familiarity, I’ll focus less on the whys of manipulating and visualizing
    data than I will on hows of doing it in Python. Let’s load the necessary modules
    and get started with *star*. The third module, `matplotlib`, is new for you and
    will be used to complement our work in `seaborn`. It comes installed with Anaconda.
    Specifically, we’ll be using the `pyplot` submodule, aliasing it as `plt`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Column-Wise Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 11](ch11.html#data-structures-in-python) you learned that `pandas`
    will attempt to convert one-dimensional data structures into Series. This seemingly
    trivial point will be quite important when selecting columns. Let’s take a look
    at an example: say we *just* wanted to keep the *tmathssk* column from our DataFrame.
    We could do so using the familiar single-bracket notation, but this technically
    results in a Series, not a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s probably better to keep this as a DataFrame if we aren’t positive that
    we want *math_scores* to stay as a one-dimensional structure. To do so, we can
    use two sets of brackets instead of one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Following this pattern, we can keep only the desired columns in *star*. I’ll
    use the `columns` attribute to confirm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To drop specific columns, use the `drop()` method. `drop()` can be used to drop
    columns *or* rows, so we’ll need to specify which by using the `axis` argument.
    In `pandas`, rows are axis `0` and columns axis `1`, as [Figure 12-1](#pandas-axes)
    demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '![Axes of star dataset](assets/aina_1201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-1\. Axes of a `pandas` DataFrame
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Here’s how to drop the *schidkn* column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now look at deriving new columns of a DataFrame. We can do that using
    bracket notation—this time, I *do* want the result to be a Series, as each column
    of a DataFrame is actually a Series (just as each column of an R data frame is
    actually a vector). Here I’ll calculate combined math and reading scores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, *new_column* isn’t a terribly descriptive variable name. Let’s fix that
    with the `rename()` function. We’ll use the `columns` argument and pass data to
    it in a format you’re likely unfamiliar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The curly bracket notation used in the last example is a Python *dictionary*.
    Dictionaries are collections of *key-value* pairs, with the key and value of each
    element separated by a colon. This is a core Python data structure and one to
    check out as you continue learning the language.
  prefs: []
  type: TYPE_NORMAL
- en: Row-Wise Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let’s move to common operations by row. We’ll start with sorting, which
    can be done in `pandas` with the `sort_values()` method. We’ll pass a list of
    columns we want to sort by in their respective order to the `by` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: By default, all columns are sorted ascendingly. To modify that, we can include
    another argument, `ascending`, which will contain a list of `True`/`False` flags.
    Let’s sort *star* by class size (*classk*) ascending and math score (*treadssk*)
    descending. Because we’re not assigning this output back to *star*, this sorting
    is not permanent to the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To filter a DataFrame, we’ll first use conditional logic to create a Series
    of `True`/`False` flags indicating whether each row meets some criteria. We’ll
    then keep only the rows in the DataFrame where records in the Series are flagged
    as `True`. For example, let’s keep only the records where `classk` is equal to
    `small.class`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now filter by this resulting Series by using brackets. We can confirm
    the number of rows and columns in our new DataFrame with the `shape` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`star_filtered` will contain fewer rows than *star*, but the same number of
    columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try one more: we’ll find the records where `treadssk` is at least `500`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s also possible to filter by multiple conditions using and/or statements.
    Just like in R, `&` and `|` indicate “and” and “or” in Python, respectively. Let’s
    pass both of the previous criteria into one statement by placing each in parentheses,
    connecting them with `&`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Aggregating and Joining Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To group observations in a DataFrame, we’ll use the `groupby()` method. If
    we print `star_grouped`, you’ll see it’s a `DataFrameGroupBy` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can now choose other fields to aggregate this grouped DataFrame by. [Table 12-1](#pandas-agg-types)
    lists some common aggregation methods.
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-1\. Helpful aggregation functions in `pandas`
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Aggregation type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `sum()` | Sum |'
  prefs: []
  type: TYPE_TB
- en: '| `count()` | Count values |'
  prefs: []
  type: TYPE_TB
- en: '| `mean()` | Average |'
  prefs: []
  type: TYPE_TB
- en: '| `max()` | Highest value |'
  prefs: []
  type: TYPE_TB
- en: '| `min()` | Lowest value |'
  prefs: []
  type: TYPE_TB
- en: '| `std()` | Standard deviation |'
  prefs: []
  type: TYPE_TB
- en: 'The following gives us the average math score for each class size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’ll find the highest total score for each year of teacher experience.
    Because this would return quite a few rows, I will include the `head()` method
    to get just a few. This practice of adding multiple methods to the same command
    is called method *chaining*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[Chapter 8](ch08.html#r-data-manipulation-visualization) reviewed the similarities
    and differences between Excel’s `VLOOKUP()` and a left outer join. I’ll read in
    a fresh copy of *star* as well as *districts*; let’s use `pandas` to join these
    datasets. We’ll use the `merge()` method to “look up” data from *school-districts*
    into *star*. By setting the `how` argument to `left`, we’ll specify a left outer
    join, which again is the join type most similar to `VLOOKUP()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Python, like R, is quite intuitive about joining data: it knew by default to
    merge on *schidkn* and brought in both *school_name* and *county*.'
  prefs: []
  type: TYPE_NORMAL
- en: Reshaping Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s take a look at widening and lengthening a dataset in Python, again using
    `pandas`. To start, we can use the `melt()` function to combine *tmathssk* and
    *treadssk* into one column. To do this, I’ll specify the DataFrame to manipulate
    with the `frame` argument, which variable to use as a unique identifier with `id_vars`,
    and which variables to melt into a single column with `value_vars`. I’ll also
    specify what to name the resulting value and label variables with `value_name`
    and `var_name`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'How about renaming *tmathssk* and *treadssk* as *math* and *reading*, respectively?
    To do this, I’ll use a Python dictionary to set up an object called `mapping`,
    which serves as something like a “lookup table” to recode the values. I’ll pass
    this into the `map()` method which will recode *test_type*. I’ll also use the
    `unique()` method to confirm that only *math* and *reading* are now found in *test_type*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To widen *star_pivot* back into separate *math* and *reading* columns, I’ll
    use the `pivot_table()` method. First I’ll specify what variable to index by with
    the `index` argument, then which variables contain the labels and values to pivot
    from with the `columns` and `values` arguments, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible in `pandas` to set unique index columns; by default, `pivot_table()`
    will set whatever variables you’ve included in the `index` argument there. To
    override this, I’ll use the `reset_index()` method. To learn more about custom
    indexing in `pandas`, along with countless other data manipulation and analysis
    techniques we couldn’t cover here, check out [*Python for Data Analysis*](https://oreil.ly/CrP7B),
    2nd edition by Wes McKinney (O’Reilly).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Data Visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s now briefly touch on data visualization in Python, specifically using
    the `seaborn` package. `seaborn` works especially well for statistical analysis
    and with `pandas` DataFrames, so it’s a great choice here. Similarly to how `pandas`
    is built on top of `numpy`, `seaborn` leverages features of another popular Python
    plotting package, `matplotlib`.
  prefs: []
  type: TYPE_NORMAL
- en: '`seaborn` includes many functions to build different plot types. We’ll modify
    the arguments within these functions to specify which dataset to plot, which variables
    go along the x- and y-axes, which colors to use, and so on. Let’s get started
    by visualizing the count of observations for each level of *classk*, which we
    can do with the `countplot()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our dataset is *star*, which we’ll specify with the `data` argument. To place
    our levels of *classk* along the x-axis we’ll use the `x` argument. This results
    in the countplot shown in [Figure 12-2](#seaborn-countplot):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![Countplot](assets/aina_1202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-2\. Countplot
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now for a histogram of *treadssk*, we’ll use the `displot()` function. Again,
    we’ll specify `x` and `data`. [Figure 12-3](#seaborn-histogram) shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![Histogram](assets/aina_1203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-3\. Histogram
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`seaborn` functions include many optional arguments to customize a plot’s appearance.
    For example, let’s change the number of bins to 25 and the plot color to pink.
    This results in [Figure 12-4](#seaborn-custom-histogram):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![Custom histogram](assets/aina_1204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-4\. Custom histogram
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To make a boxplot, use the `boxplot()` function as in [Figure 12-5](#seaborn-boxplot):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In any of these cases so far, we could’ve “flipped” the plot by instead including
    the variable of interest in the `y` argument. Let’s try it with our boxplot, and
    we’ll get what’s shown in [Figure 12-6](#seaborn-flipped-boxplot) as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![Boxplot](assets/aina_1205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-5\. Boxplot
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Boxplot](assets/aina_1206.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-6\. “Flipped” boxplot
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To make a boxplot for each level of class size, we’ll include an additional
    argument to plot *classk* along the x-axis, giving us the boxplot by group depicted
    in [Figure 12-7](#seaborn-grouped-boxplot):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![Grouped boxplot](assets/aina_1207.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-7\. Boxplot by group
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now let’s use the `scatterplot()` function to plot the relationship of *tmathssk*
    on the x-axis and *treadssk* on the y. [Figure 12-8](#seaborn-scatterplot) is
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![Scatterplot](assets/aina_1208.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-8\. Scatterplot
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s say we wanted to share this plot with an outside audience, who may not
    be familiar with what *treadssk* and *tmathssk* are. We can add more helpful labels
    to this chart by borrowing features from `matplotlib.pyplot`. We’ll run the same
    `scatterplot()` function as before, but this time we’ll also call in functions
    from `pyplot` to add custom x- and y-axis labels, as well as a chart title. This
    results in [Figure 12-9](#seaborn-labeled-scatterplot):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![Scatterplot with custom labels and title](assets/aina_1209.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-9\. Scatterplot with custom axis labels and title
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`seaborn` includes many more features for building visually appealing data
    visualizations. To learn more, check out [the official documentation](https://oreil.ly/2joMU).'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There’s so much more that `pandas` and `seaborn` can do, but this is enough
    to get you started with the true task at hand: to explore and test relationships
    in data. That will be the focus of [Chapter 13](ch13.html#python-for-data-analysis-capstone).'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The [book repository](https://oreil.ly/hFEOG) has two files in the *census*
    subfolder of *datasets*, *census.csv* and *census-divisions.csv*. Read these into
    Python and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Sort the data by region ascending, division ascending and population descending.
    (You will need to combine datasets to do this.) Write the results to an Excel
    worksheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drop the postal code field from your merged dataset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new column, *density*, that is a calculation of population divided
    by land area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visualize the relationship between land area and population for all observations
    in 2015.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the total population for each region in 2015.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a table containing state names and populations, with the population for
    each year 2010–2015 kept in an individual column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
