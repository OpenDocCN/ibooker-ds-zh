- en: Chapter 10\. Operations Research
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 运筹学
- en: '*Many scientists owe their greatness not to their skill in solving problems
    but to their wisdom in choosing them*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*许多科学家之所以伟大，不是因为他们解决问题的技能，而是因为他们选择问题的智慧*'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: E. Bright Wilson (1908–1992), American chemist
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: E.布赖特·威尔逊（1908-1992），美国化学家
- en: In this chapter, we explore the integration of AI into the field of operations
    research, leveraging the best of both worlds for more efficient and more informed
    decision making. Although this introductory statement sounds like an ad, it is
    precisely what operations research is all about. Advances in machine learning
    can only help move the field forward.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了将人工智能整合到运筹学领域中，利用两者的优势进行更高效和更明智的决策。尽管这个介绍性陈述听起来像是一则广告，但这正是运筹学的全部意义。机器学习的进步只能帮助推动该领域的发展。
- en: 'Operations research is one of the most attractive and stimulating areas of
    applied mathematics. It is the science of balancing different needs and available
    resources in the most time and cost efficient ways. Many problems in operations
    research reduce to searching for an optimal point, the holy grail, at which everything
    functions smoothly and efficiently: No backups, no interruptions to timely services,
    no waste, balanced costs, and good revenues for everyone involved. A lot of applications
    never find the holy grail, but many operations reasearch methods allow us to come
    very close, at least for the simplified models of the complex reality. Constrained
    mathematical optimization penetrates every industry, every network, and every
    aspect of our lives. Done properly, we enjoy its benefits; done improperly, we
    suffer its impact: Global and local economies are still experiencing the ramifications
    of covid19, the war on Ukraine, and the eventual interruptions to the supply chain.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 运筹学是应用数学中最具吸引力和刺激性的领域之一。它是在最节约时间和成本的方式中平衡不同需求和可用资源的科学。运筹学中的许多问题都归结为寻找最佳点，即一切运行顺畅和高效的圣杯：没有备份，没有中断及时服务，没有浪费，平衡成本，对所有参与者都有良好的收入。许多应用永远找不到圣杯，但许多运筹学方法使我们能够至少接近，至少对于复杂现实的简化模型来说是如此。受限的数学优化渗透到每个行业、每个网络和我们生活的方方面面。做得正确，我们享受其好处；做得不当，我们承受其影响：全球和地方经济仍在经历covid19、乌克兰战争以及对供应链的最终中断的后果。
- en: 'Before exploring how machine learning is starting to make its way into operations
    research, we highlight few ideas that an interested person must internalize if
    they want to get involved in the field. Since we only have one chapter to spend
    on this beautiful topic, we must distill it into its essence:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨机器学习如何开始进入运筹学之前，我们强调了一些有兴趣的人必须内化的想法，如果他们想参与这个领域。由于我们只有一个章节来探讨这个美妙的主题，我们必须将其提炼到其本质：
- en: 'The *no free lunch* theorem: This makes us shift our attention into devising
    and analyzing methods that work best for the special case scenario at hand, as
    opposed to looking for the most general and most widely applicable methods, like
    many mathematicians are naturally inclined to do. It essentially asks all these
    mathematicians to pretty much *chill*, and be satisfied with specialized solutions
    for specific types of problems.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*没有免费午餐*定理：这使我们将注意力转向设计和分析最适合特定情况的方法，而不是寻找最通用和最广泛适用的方法，就像许多数学家天生倾向于做的那样。它基本上要求所有这些数学家基本上*放松*，并对特定类型问题的专业解决方案感到满意。'
- en: '*Complexity analysis of problems and asymptotic analysis of algorithms*: *Asymptotic
    analysis* tells us that even if the algorithm is ultra innovative and genius,
    it is useless if its computational requirements skyrocket with the size the of
    the problem. Operations research solutions need to scale to big scenarios with
    many variables. *Complexity analysis*, on the other hand, addresses the *level
    of difficulty* of the problems themselves rather than the algorithms devised to
    tackle them. Combinatorial problems, which are <math alttext="upper O left-parenthesis
    n factorial right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <mi>n</mi> <mo>!</mo>
    <mo>)</mo></mrow></math> are ultra bad: <math alttext="n factorial"><mrow><mi>n</mi>
    <mo>!</mo></mrow></math> is bigger than <math alttext="k Superscript n"><msup><mi>k</mi>
    <mi>n</mi></msup></math> for n large enough, but an exponential <math alttext="k
    Superscript n"><msup><mi>k</mi> <mi>n</mi></msup></math> complexity would already
    be very bad!'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*问题的复杂性分析和算法的渐近分析*：*渐近分析*告诉我们，即使算法非常创新和高明，如果其计算需求随问题规模的增大而急剧增加，那么它就是无用的。运筹学解决方案需要适应具有许多变量的大型场景。另一方面，*复杂性分析*则处理问题本身的*难度级别*，而不是为解决它们而设计的算法。组合问题，即<math
    alttext="上标 O 左括号 n 阶乘 右括号"><mrow><mi>O</mi> <mo>(</mo> <mi>n</mi> <mo>!</mo>
    <mo>)</mo></mrow></math>，是极其糟糕的：<math alttext="n 阶乘"><mrow><mi>n</mi> <mo>!</mo></mrow></math>对于足够大的
    n 来说比<math alttext="k 的 n 次方"><msup><mi>k</mi> <mi>n</mi></msup></math>要大，但指数<math
    alttext="k 的 n 次方"><msup><mi>k</mi> <mi>n</mi></msup></math>的复杂度已经非常糟糕！'
- en: '*Important topics and applications in operations research*: These we can find
    in any good book on operations research. We always need to keep one at hand. Moving
    from a specific application and business objectives to a mathematical formulation
    is the skill that cannot be stressed enough in order to thrive this field.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运筹学中的重要主题和应用*：这些内容可以在任何一本好的运筹学书籍中找到。我们总是需要随身携带一本。从特定应用和业务目标到数学公式的转化是必须强调的技能，以便在这个领域取得成功。'
- en: '*Various types of optimization methods and algorithms*: This is the workhorse
    of operations research solutions and software packages.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*各种类型的优化方法和算法*：这是运筹学解决方案和软件包的工作马。 '
- en: '*Software packages*: The wide availability of these, along with the limited
    number of pages, are my excuse not to elaborate on anything algorithmic or computational
    in this chapter.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*软件包*：这些软件包的广泛可用性，以及有限的页面数量，是我不详细讨论本章中任何算法或计算内容的借口。'
- en: 'To sum operations research in six words: *Mathematical formulation, optimization,
    algorithms, software, and decisions*.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 用六个词总结运筹学：*数学建模、优化、算法、软件和决策*。
- en: 'When reading through this chapter, it is helpful to think of the concepts in
    the context of how the companies that we interact with in our daily lives manage
    their operations. Consider for example Amazon’s logistics. Amazon is the largest
    e-commerce company in the world. Its share of the US e-commerce market in 2022
    is 45%, selling and delivering millions of units of merchandise everyday, around
    $5000 in sales every second. How do they succeed at doing this? How do they manage
    their inventory, warehouses, transportation, and extremely efficient delivery
    system? How do they formulate their sub-problems and how do they integrate them
    into one big successful operation? Same with transportation logistics, such as
    Uber: Everyday Uber provides up to 15 million shared rides worldwide, matching
    available drivers with nearby riders, routing and timing pickups and drop offs,
    pricing trips, predicting driver revenues, supply and demand patterns, and performing
    countless analytics.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章时，有助于将概念置于我们日常生活中与之互动的公司如何管理其运营的背景中。例如考虑亚马逊的物流。亚马逊是世界上最大的电子商务公司。2022年，其在美国电子商务市场的份额为45％，每天销售和交付数百万件商品，每秒约5000美元的销售额。他们是如何成功做到这一点的？他们如何管理他们的库存、仓库、运输和极其高效的交付系统？他们如何制定子问题，以及如何将它们整合成一个成功的大型运营？交通物流也是如此，比如Uber：每天，Uber在全球提供多达1500万次共享乘车服务，将可用司机与附近乘客匹配，安排和计时接送和送达，定价行程，预测司机收入、供需模式，并进行无数分析。
- en: The complex and highly interconnected optimization problems that allow such
    massive systems to run relatively smoothly are typical to operations research.
    Moreover, a lot of the involved problems are NP-hard (in computational complexity,
    this means they have nondeterministic polynomial time level of hardness- in English
    words, *very expensive to compute*). Add on top of that their stochastic nature,
    and we have interesting math problems that need to be solved.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 允许这些庞大系统相对顺利运行的复杂且高度相互关联的优化问题是运筹学的典型特征。此外，许多涉及的问题都是NP难题（在计算复杂性中，这意味着它们具有非确定性多项式时间级别的难度-用英语来说，*计算成本非常高*）。再加上它们的随机性质，我们有一些有趣的数学问题需要解决。
- en: 'Overall, the mathematical methods and algorithms of operations research save
    the world billions of dollars annually. A survey of the largest 500 companies
    in the United States showed that 85% of them use linear programming (which is
    another name for linear optimization, a massive part of operations research, and
    a reason we spend some descent time on the simplex method and duality in this
    chapter). Coupled with tools from the AI industry, now is the perfect time to
    get into the field. The rewards will be on many levels: Intellectual, financial,
    and meaningful contribution to the greater good of humanity. So in no way should
    the few selected topics for this chapter dim the significance of other equally
    important topics in the field.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，运筹学的数学方法和算法每年为世界节省数十亿美元。对美国最大的500家公司进行的一项调查显示，其中85％使用线性规划（这是线性优化的另一个名称，是运筹学的一个重要部分，也是我们在本章中花费一些时间讨论单纯形法和对偶性的原因）。现在结合AI行业的工具，是进入这个领域的绝佳时机。回报将在多个层面上体现：智力、财务和对人类共同利益的有意义贡献。因此，本章中选择的少数主题绝不应减弱该领域中其他同等重要主题的重要性。
- en: 'To dive deeper into operations research (after reading this chapter, of course),
    the best way is to learn from the best:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 深入研究运筹学（当然，在阅读本章之后），最好的方法是向最优秀的人学习：
- en: Browse through the winner and finalist projects of the [Franz Edelman Award
    for Achievement in Advanced Analytics, Operations Research, and Management Science](https://www.informs.org/Recognizing-Excellence/INFORMS-Prizes/Franz-Edelman-Award).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览[弗兰兹·埃德尔曼高级分析、运筹学和管理科学成就奖](https://www.informs.org/Recognizing-Excellence/INFORMS-Prizes/Franz-Edelman-Award)的获奖和入围项目。
- en: Keep the book *Introduction To Operations Research, by Hillier and Lieberman,
    McGraw Hill (2021)* close to your heart.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 把《运筹学导论，希利尔和利伯曼，麦格劳希尔（2021）》放在心中。
- en: No Free Lunch
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有免费午餐
- en: 'The *no free lunch theorems for optimization* states that there is no one particular
    optimization algorithm that works best for every problem. All algorithms that
    look for an optimizer of an objective function (cost function, loss function,
    utility function, likelihood function) have similar performance when averaged
    over all possible objective functions. So if some algorithm performs better than
    another on some class of objective functions, there are other objective functions
    where the other algorithm performs better. There is no superior algorithm that
    works for all kinds of problems. Therefore, picking an algorithm should be problem
    (or domain) dependent. Depending on our application area, there is plenty of information
    on which algorithms practitioners use, their justifications for why these are
    their chosen ones, their comparisons with others on both high dimensional and
    reasonable-dimension problems, and their constant attempts for better performace,
    which means two things: Faster (computationally less expensive), and more accurate.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*优化的无免费午餐定理*表明，没有一种特定的优化算法适用于每个问题。寻找目标函数（成本函数、损失函数、效用函数、似然函数）的优化器的所有算法在所有可能的目标函数上平均时具有类似的性能。因此，如果某个算法在某类目标函数上表现优于另一个算法，则在其他目标函数上，另一个算法表现更好。没有一种适用于所有问题类型的优越算法。因此，选择算法应该依赖于问题（或领域）。根据我们的应用领域，有大量关于从业者使用的算法、他们选择这些算法的理由、与其他算法在高维和合理维度问题上的比较以及他们不断努力实现更好性能的信息，这意味着两件事：更快（计算成本更低）和更准确。'
- en: Complexity Analysis And O() Notation
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂性分析和O()符号
- en: 'Many times, the problem of *efficiently allocating limited resources* under
    *various constraints* boils down to devising efficient algorithms for *discrete*
    optimization. Linear programming, integer programming, combinatorial optimization,
    and optimization on graph structures (networks), are all interwined (sometimes
    these are nothing more than two different names for the same thing) and deal with
    one objective: Finding an optimizer from a *discrete and finite set* of valid
    options, the *feasible set*. If the feasible set is not discrete to start with,
    sometimes we can reduce it to a discrete set if we are to take advantage of the
    wealth of tools developed for this field. Here is the main issue: Exhaustive search
    is usually not tractable. This means that if we list all the available options
    in the feasible set and evaluate the objective function at each of them, we would
    spend an ungodly amount of time to find the point(s) that give the optimal answer.
    No one said that a finite feasible means that it is not enormous. We need specialized
    algorithms that efficiently rule out large swaths of the search space. Some algorithms
    pinpoint the exact solution for some poroblems and others can only find approximate
    solutions, which we have no option but to settle for.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，*在各种约束条件下有效地分配有限资源*的问题归结为为*离散*优化设计高效算法。线性规划、整数规划、组合优化以及图结构（网络）上的优化，都是相互交织的（有时这些只是同一事物的两个不同名称），并且都涉及一个目标：从*离散且有限的有效选项集*中找到一个优化器，即*可行集*。如果初始的可行集不是离散的，有时我们可以将其减少为一个离散集，以便利用为该领域开发的丰富工具。这里的主要问题是：穷举��索通常是不可行的。这意味着如果我们列出可行集中的所有可用选项，并在每个选项上评估目标函数，我们将花费大量时间来找到给出最佳答案的点。没有人说有限的可行意味着它不是巨大的。我们需要专门的算法来有效地排除搜索空间的大片区域。一些算法可以精确定位某些问题的确切解决方案，而其他算法只能找到近似解决方案，我们别无选择，只能接受。
- en: 'Let’s now make the following distiction upfront, since this confuses a lot
    of people:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在提前做出以下区分，因为这会让很多人感到困惑：
- en: '**Complexity analysis is for the problems that we want solve** (routing, traveling
    saleman, knapsack, *etc.*). The intrinsic complexity of a problem is independent
    of the algorithms used to tackle it. In fact, it sometimes tells us that we cannot
    hope for a more efficient algorithm for such kind of problem, or whether we can
    do better in other cases. In any case, complexity analysis for problems is a rich
    science on its own, and the field of operations research provides a wealth of
    *complex* problems to ponder on. This is where the following terms appear: Polynomial
    problem, non-deterministic polynomial problem, non-deterministic polynomial complete
    problem, non-deterministic polynomial time hard problem, complement nondeterministic
    polynomial problem, and complement nondeterministic polynomial complete problem.
    The above terms are so confusing and someone seriously needs to reconsider their
    nomenclature. We will not define each here (mainly because the theory is not yet
    set on the boundaries between these classes of problems), but we will make the
    following divide: Problems that can be solved in polynomial time or less, and
    problems for which we cannot find an exact solution in polynomial time, no matter
    what algorithm is used, in which case, we have to settle for approximation algorithms
    (for example, the traveling salesman problem). Note that sometimes polynomial
    time problems might not be such a great thing, because for example <math alttext="upper
    O left-parenthesis n squared 000 right-parenthesis"><mrow><mi>O</mi> <mo>(</mo>
    <msup><mi>n</mi> <mn>2</mn></msup> <mn>000</mn> <mo>)</mo></mrow></math> is not
    so fast afterall.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性分析是为了我们想要解决的问题**（路由、旅行推销员、背包问题等）。问题的固有复杂性与用于解决它的算法无关。事实上，有时它告诉我们对于这种类型的问题，我们不能指望有更有效的算法，或者在其他情况下我们是否能做得更好。无论如何，对于问题的复杂性分析本身就是一个丰富的科学领域，运筹学领域提供了大量复杂问题供我们思考。这就是以下术语出现的地方：多项式问题、非确定性多项式问题、非确定性多项式完全问题、非确定性多项式时间困难问题、补充非确定性多项式问题以及补充非确定性多项式完全问题。上述术语非常令人困惑，有人需要认真重新考虑它们的命名。我们不会在这里定义每一个（主要是因为理论尚未确定这些问题类别之间的界限），但我们会做出以下划分：可以在多项式时间内或更短时间内解决的问题，以及我们无法在多项式时间内找到精确解决方案的问题，无论使用什么算法，这种情况下，我们必须接受近似算法（例如旅行推销员问题）。请注意，有时多项式时间问题可能并不是一件好事，因为例如
    <math alttext="upper O left-parenthesis n squared 000 right-parenthesis"><mrow><mi>O</mi>
    <mo>(</mo> <msup><mi>n</mi> <mn>2</mn></msup> <mn>000</mn> <mo>)</mo></mrow></math>
    终究不是那么快。'
- en: '**Asymptotic analysis is for the algorithms that we design to solve these problems**.
    This is where we attempt to estimate the number of operations that the algorithm
    requires and quantify it relative to the size of the problem. We usually use the
    big *O* notation, which means the following:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渐近分析是为了我们设计的解决这些问题的算法**。这是我们试图估计算法所需操作次数并将其与问题规模相对比的地方。我们通常使用大O符号，意思是：'
- en: Big O() notation
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大O()符号
- en: A function *g(n)* is *O(f(n))* when <math alttext="g left-parenthesis n right-parenthesis
    less-than-or-equal-to c f left-parenthesis n right-parenthesis"><mrow><mi>g</mi>
    <mo>(</mo> <mi>n</mi> <mo>)</mo> <mo>≤</mo> <mi>c</mi> <mi>f</mi> <mo>(</mo> <mi>n</mi>
    <mo>)</mo></mrow></math> for some constant *c*, and for all <math alttext="n greater-than-or-equal-to
    n 0"><mrow><mi>n</mi> <mo>≥</mo> <msub><mi>n</mi> <mn>0</mn></msub></mrow></math>
    .
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在某个常数*c*，对于所有<math alttext="n greater-than-or-equal-to n 0"><mrow><mi>n</mi>
    <mo>≥</mo> <msub><mi>n</mi> <mn>0</mn></msub></mrow></math>，函数*g(n)*是*O(f(n))*时，<math
    alttext="g left-parenthesis n right-parenthesis less-than-or-equal-to c f left-parenthesis
    n right-parenthesis"><mrow><mi>g</mi> <mo>(</mo> <mi>n</mi> <mo>)</mo> <mo>≤</mo>
    <mi>c</mi> <mi>f</mi> <mo>(</mo> <mi>n</mi> <mo>)</mo></mrow></math>。
- en: For example, *2n+1* is *O(n)*, <math alttext="5 n cubed minus 7 n squared plus
    1"><mrow><mn>5</mn> <msup><mi>n</mi> <mn>3</mn></msup> <mo>-</mo> <mn>7</mn> <msup><mi>n</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>1</mn></mrow></math> is <math alttext="upper
    O left-parenthesis n cubed right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>n</mi>
    <mn>3</mn></msup> <mo>)</mo></mrow></math> , <math alttext="n squared 2 Superscript
    n minus 55 n Superscript 1 Baseline 00"><mrow><msup><mi>n</mi> <mn>2</mn></msup>
    <msup><mn>2</mn> <mi>n</mi></msup> <mo>-</mo> <mn>55</mn> <msup><mi>n</mi> <mn>1</mn></msup>
    <mn>00</mn></mrow></math> is <math alttext="upper O left-parenthesis n squared
    2 Superscript n Baseline right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>n</mi>
    <mn>2</mn></msup> <msup><mn>2</mn> <mi>n</mi></msup> <mo>)</mo></mrow></math>
    , <math alttext="15 n l o g left-parenthesis n right-parenthesis minus 5 n"><mrow><mn>15</mn>
    <mi>n</mi> <mi>l</mi> <mi>o</mi> <mi>g</mi> <mo>(</mo> <mi>n</mi> <mo>)</mo> <mo>-</mo>
    <mn>5</mn> <mi>n</mi></mrow></math> is <math alttext="upper O left-parenthesis
    n l o g left-parenthesis n right-parenthesis right-parenthesis"><mrow><mi>O</mi>
    <mo>(</mo> <mi>n</mi> <mi>l</mi> <mi>o</mi> <mi>g</mi> <mo>(</mo> <mi>n</mi> <mo>)</mo>
    <mo>)</mo></mrow></math> .
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*2n+1*是*O(n)*，<math alttext="5 n cubed minus 7 n squared plus 1"><mrow><mn>5</mn>
    <msup><mi>n</mi> <mn>3</mn></msup> <mo>-</mo> <mn>7</mn> <msup><mi>n</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>1</mn></mrow></math>是<math alttext="upper O left-parenthesis n
    cubed right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>n</mi> <mn>3</mn></msup>
    <mo>)</mo></mrow></math>，<math alttext="n squared 2 Superscript n minus 55 n Superscript
    1 Baseline 00"><mrow><msup><mi>n</mi> <mn>2</mn></msup> <msup><mn>2</mn> <mi>n</mi></msup>
    <mo>-</mo> <mn>55</mn> <msup><mi>n</mi> <mn>1</mn></msup> <mn>00</mn></mrow></math>是<math
    alttext="upper O left-parenthesis n squared 2 Superscript n Baseline right-parenthesis"><mrow><mi>O</mi>
    <mo>(</mo> <msup><mi>n</mi> <mn>2</mn></msup> <msup><mn>2</mn> <mi>n</mi></msup>
    <mo>)</mo></mrow></math>，<math alttext="15 n l o g left-parenthesis n right-parenthesis
    minus 5 n"><mrow><mn>15</mn> <mi>n</mi> <mi>l</mi> <mi>o</mi> <mi>g</mi> <mo>(</mo>
    <mi>n</mi> <mo>)</mo> <mo>-</mo> <mn>5</mn> <mi>n</mi></mrow></math>是<math alttext="upper
    O left-parenthesis n l o g left-parenthesis n right-parenthesis right-parenthesis"><mrow><mi>O</mi>
    <mo>(</mo> <mi>n</mi> <mi>l</mi> <mi>o</mi> <mi>g</mi> <mo>(</mo> <mi>n</mi> <mo>)</mo>
    <mo>)</mo></mrow></math>。
- en: Do not forget the constant asymptotics case *O(1)*, where the operation count
    of an algorithm is independent of the size of the problem (awesome thing, because
    this means that it scale without any worries to enormous problems).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记常数渐近情况*O(1)*，其中算法的操作计数与问题的大小无关（这是一个很棒的事情，因为这意味着它可以轻松地扩展到巨大的问题而不必担心）。
- en: For some algorithms, we can count the exact number of operations, for example,
    to compute the scalar product (dot product) of two vectors of length *n*, a simple
    algorithm uses exactly 2n-1 multiplications and additions, which makes it *O(n)*.
    For multiplying two matrices each of size <math alttext="n times n"><mrow><mi>n</mi>
    <mo>×</mo> <mi>n</mi></mrow></math> , a simple algorithm computing the dot product
    of each row from the first matrix with each column from the second matrix requires
    exactly <math alttext="left-parenthesis 2 n minus 1 right-parenthesis n squared"><mrow><mrow><mo>(</mo>
    <mn>2</mn> <mi>n</mi> <mo>-</mo> <mn>1</mn> <mo>)</mo></mrow> <msup><mi>n</mi>
    <mn>2</mn></msup></mrow></math> operations, so this will be <math alttext="upper
    O left-parenthesis n cubed right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>n</mi>
    <mn>3</mn></msup> <mo>)</mo></mrow></math> . Matrix inversion is also usually
    <math alttext="upper O left-parenthesis n cubed right-parenthesis"><mrow><mi>O</mi>
    <mo>(</mo> <msup><mi>n</mi> <mn>3</mn></msup> <mo>)</mo></mrow></math> .
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些算法，我们可以计算出确切的操作次数，例如，为了计算长度为*n*的两个向量的标量积（点积），一个简单的算法需要精确地进行2n-1次乘法和加法，这使得它是*O(n)*。对于乘法两个大小为<math
    alttext="n times n"><mrow><mi>n</mi> <mo>×</mo> <mi>n</mi></mrow></math>的矩阵，一个简单的算法计算第一个矩阵的每一行与第二个矩阵的每一列的点积需要精确地<math
    alttext="left-parenthesis 2 n minus 1 right-parenthesis n squared"><mrow><mrow><mo>(</mo>
    <mn>2</mn> <mi>n</mi> <mo>-</mo> <mn>1</mn> <mo>)</mo></mrow> <msup><mi>n</mi>
    <mn>2</mn></msup></mrow></math>次操作，因此这将是<math alttext="upper O left-parenthesis
    n cubed right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>n</mi> <mn>3</mn></msup>
    <mo>)</mo></mrow></math>。矩阵求逆通常也是<math alttext="upper O left-parenthesis n cubed
    right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>n</mi> <mn>3</mn></msup>
    <mo>)</mo></mrow></math>。
- en: For anyone interested in asymptotic analysis for algorithms, it quickly becomes
    obvious that it is slightly more involved than operation counts, because sometimes
    we have to make estimates or averages on the size of input (what does *n* stand
    for?), how to count the operations in an algorithm (by each line of code?), and
    we cannot ignore the fact that doing computations on large numbers is more consuming
    in time and memory than doing operations on smaller numbers. Finally, we prefer
    algorithms that run in polynomial time or less and not in exponential time or
    more. Let’s demonstrate with a very simple example.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对算法渐近分析感兴趣的人来说，很快就会意识到它比操作计数稍微复杂一些，因为有时我们必须对输入的大小进行估计或平均值（*n*代表什么？），如何计算算法中的操作（按代码的每一行？），我们不能忽视在大数字上进行计算比在小数字上进行操作更耗时和内存。最后，我们更喜欢运行时间为多项式时间或更少的算法，而不是指数时间或更多的算法。让我们用一个非常简单的例子来演示。
- en: Polynomial algorithm <math alttext="upper O left-parenthesis n Superscript k
    Baseline right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>n</mi> <mi>k</mi></msup>
    <mo>)</mo></mrow></math> vs exponential algorithm <math alttext="upper O left-parenthesis
    k Superscript n Baseline right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>k</mi>
    <mi>n</mi></msup> <mo>)</mo></mrow></math>
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多项式算法<math alttext="upper O left-parenthesis n Superscript k Baseline right-parenthesis"><mrow><mi>O</mi>
    <mo>(</mo> <msup><mi>n</mi> <mi>k</mi></msup> <mo>)</mo></mrow></math>与指数算法<math
    alttext="upper O left-parenthesis k Superscript n Baseline right-parenthesis"><mrow><mi>O</mi>
    <mo>(</mo> <msup><mi>k</mi> <mi>n</mi></msup> <mo>)</mo></mrow></math>。
- en: Suppose we are working on a machine that is able to execute <math alttext="10
    Superscript 7"><msup><mn>10</mn> <mn>7</mn></msup></math> operations per second
    (10 million). Let’s run it for 1000 seconds which is around 16 minutes on two
    different algorithms, one exponential in the size of the problem, say, <math alttext="upper
    O left-parenthesis 2 Superscript n Baseline right-parenthesis"><mrow><mi>O</mi>
    <mo>(</mo> <msup><mn>2</mn> <mi>n</mi></msup> <mo>)</mo></mrow></math> and the
    other polynomial <math alttext="upper O left-parenthesis n cubed right-parenthesis"><mrow><mi>O</mi>
    <mo>(</mo> <msup><mi>n</mi> <mn>3</mn></msup> <mo>)</mo></mrow></math> . The size
    of the problem is *n* in this case, and refers to a measure of the dimensionality
    of the input, for example the number of nodes of a graph, the number of entries
    of a matrix, the number of features of a data set or the number of instances.
    What is the largest size problem that each algorithm can handle for 16 minutes
    on this machine?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在使用一台每秒能执行<math alttext="10 Superscript 7"><msup><mn>10</mn> <mn>7</mn></msup></math>次操作（1000万）的机器。让我们在两种不同的算法上运行它1000秒，大约相当于16分钟，一个是问题规模指数级增长的算法，比如<math
    alttext="upper O left-parenthesis 2 Superscript n Baseline right-parenthesis"><mrow><mi>O</mi>
    <mo>(</mo> <msup><mn>2</mn> <mi>n</mi></msup> <mo>)</mo></mrow></math>，另一个是多项式<math
    alttext="upper O left-parenthesis n cubed right-parenthesis"><mrow><mi>O</mi>
    <mo>(</mo> <msup><mi>n</mi> <mn>3</mn></msup> <mo>)</mo></mrow></math>。在这种情况下，问题的规模是*n*，指的是输入的维度，例如图的节点数、矩阵的条目数、数据集的特征数或实例数。每种算法在这台机器上运行16分钟最大能处理多大规模的问题？
- en: For the exponential time algorithm, the number of operations it requires is
    at most (worst case scenario) <math alttext="c 2 Superscript n Baseline equals
    10 Superscript 7 Baseline asterisk 1000"><mrow><mi>c</mi> <msup><mn>2</mn> <mi>n</mi></msup>
    <mo>=</mo> <msup><mn>10</mn> <mn>7</mn></msup> <mo>*</mo> <mn>1000</mn></mrow></math>
    for some preferably small *c*. Thus, the size of the problem it can run for a
    1000 seconds with 10 million operations per second is <math alttext="n equals
    10 log Subscript 2 Baseline left-parenthesis 10 right-parenthesis minus log Subscript
    2 Baseline left-parenthesis c right-parenthesis almost-equals 33"><mrow><mi>n</mi>
    <mo>=</mo> <mn>10</mn> <msub><mo form="prefix">log</mo> <mn>2</mn></msub> <mrow><mo>(</mo>
    <mn>10</mn> <mo>)</mo></mrow> <mo>-</mo> <msub><mo form="prefix">log</mo> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>c</mi> <mo>)</mo></mrow> <mo>≈</mo> <mn>33</mn></mrow></math>
    .
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于指数时间算法，它所需的操作次数最多（最坏情况）为<math alttext="c 2 Superscript n Baseline equals 10
    Superscript 7 Baseline asterisk 1000"><mrow><mi>c</mi> <msup><mn>2</mn> <mi>n</mi></msup>
    <mo>=</mo> <msup><mn>10</mn> <mn>7</mn></msup> <mo>*</mo> <mn>1000</mn></mrow></math>，其中*c*最好是一个较小的值。因此，它可以在每秒1000万次操作的情况下运行1000秒的问题规模为<math
    alttext="n equals 10 log Subscript 2 Baseline left-parenthesis 10 right-parenthesis
    minus log Subscript 2 Baseline left-parenthesis c right-parenthesis almost-equals
    33"><mrow><mi>n</mi> <mo>=</mo> <mn>10</mn> <msub><mo form="prefix">log</mo> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mn>10</mn> <mo>)</mo></mrow> <mo>-</mo> <msub><mo form="prefix">log</mo>
    <mn>2</mn></msub> <mrow><mo>(</mo> <mi>c</mi> <mo>)</mo></mrow> <mo>≈</mo> <mn>33</mn></mrow></math>。
- en: Now contrast this with the polynomial time algorithm, whose worst case is <math
    alttext="c n cubed equals 10 Superscript 7 Baseline asterisk 1000"><mrow><mi>c</mi>
    <msup><mi>n</mi> <mn>3</mn></msup> <mo>=</mo> <msup><mn>10</mn> <mn>7</mn></msup>
    <mo>*</mo> <mn>1000</mn></mrow></math> , so <math alttext="n equals StartFraction
    1 Over cubed StartRoot c EndRoot EndFraction cubed StartRoot 10 Superscript 10
    Baseline EndRoot almost-equals 2100"><mrow><mi>n</mi> <mo>=</mo> <msup><mfrac><mn>1</mn>
    <mrow><msup><mn>3</mn></msup> <msqrt><mi>c</mi></msqrt></mrow></mfrac> <mn>3</mn></msup>
    <msqrt><msup><mn>10</mn> <mn>10</mn></msup></msqrt> <mo>≈</mo> <mn>2100</mn></mrow></math>
    . This is almost two orders of magnitude larger than exponential time algorithm.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将这与多项式时间算法进行对比，其最坏情况是<math alttext="c n cubed equals 10 Superscript 7 Baseline
    asterisk 1000"><mrow><mi>c</mi> <msup><mi>n</mi> <mn>3</mn></msup> <mo>=</mo>
    <msup><mn>10</mn> <mn>7</mn></msup> <mo>*</mo> <mn>1000</mn></mrow></math>，因此<math
    alttext="n equals StartFraction 1 Over cubed StartRoot c EndRoot EndFraction cubed
    StartRoot 10 Superscript 10 Baseline EndRoot almost-equals 2100"><mrow><mi>n</mi>
    <mo>=</mo> <msup><mfrac><mn>1</mn> <mrow><msup><mn>3</mn></msup> <msqrt><mi>c</mi></msqrt></mrow></mfrac>
    <mn>3</mn></msup> <msqrt><msup><mn>10</mn> <mn>10</mn></msup></msqrt> <mo>≈</mo>
    <mn>2100</mn></mrow></math>。这几乎比指数时间算法大两个数量级。
- en: The conclusion is that given the same hardware and amount of time, polynomial
    time algorithms <math alttext="upper O left-parenthesis n Superscript k Baseline
    right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>n</mi> <mi>k</mi></msup>
    <mo>)</mo></mrow></math> allow us to solve much larger problems than exponential
    time algorithms <math alttext="upper O left-parenthesis k Superscript n Baseline
    right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>k</mi> <mi>n</mi></msup>
    <mo>)</mo></mrow></math> . Combinatorial time algorithms <math alttext="upper
    O left-parenthesis n factorial right-parenthesis"><mrow><mi>O</mi> <mo>(</mo>
    <mi>n</mi> <mo>!</mo> <mo>)</mo></mrow></math> are hopeless. Moreover, we *always*
    want *k* to be small. The smaller the better.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，在相同的硬件和时间条件下，多项式时间算法<math alttext="upper O left-parenthesis n Superscript
    k Baseline right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>n</mi> <mi>k</mi></msup>
    <mo>)</mo></mrow></math>可以解决比指数时间算法<math alttext="upper O left-parenthesis k Superscript
    n Baseline right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>k</mi> <mi>n</mi></msup>
    <mo>)</mo></mrow></math>更大的问题。组合时间算法<math alttext="upper O left-parenthesis n
    factorial right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <mi>n</mi> <mo>!</mo>
    <mo>)</mo></mrow></math>是无望的。此外，我们*总是*希望*k*越小越好。
- en: 'A person who is used to operating in *exact* realms and not in *approximate*
    or *asymptotic* realms might be troubled by the above discussion, because sometimes,
    some higher order algorithms are better for smaller size problems than lower order
    ones. For example: Suppose the exact operation count of an *O(n)* algorithm is
    20n-99, and that of an <math alttext="upper O left-parenthesis n squared right-parenthesis"><mrow><mi>O</mi>
    <mo>(</mo> <msup><mi>n</mi> <mn>2</mn></msup> <mo>)</mo></mrow></math> is <math
    alttext="n squared plus 1"><mrow><msup><mi>n</mi> <mn>2</mn></msup> <mo>+</mo>
    <mn>1</mn></mrow></math> , then it is true that asymptotically (or for large enough
    *n*), the *O(n)* algorithm is better than the <math alttext="upper O left-parenthesis
    n squared right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>n</mi> <mn>2</mn></msup>
    <mo>)</mo></mrow></math> , but that is not the case if *n* is smaller than 10,
    because in this case, <math alttext="n squared plus 1 less-than 20 n minus 99"><mrow><msup><mi>n</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>1</mn> <mo><</mo> <mn>20</mn> <mi>n</mi> <mo>-</mo>
    <mn>99</mn></mrow></math> . This is okay for small enough problems, but never
    for larger problems.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个习惯于在*精确*领域而不是*近似*或*渐近*领域操作的人可能会对上面的讨论感到困扰，因为有时，一些高阶算法对于较小规模的问题比低阶算法更好。例如：假设一个*O(n)*算法的精确操作次数为20n-99，而一个<math
    alttext="上O左括号n平方右括号"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>n</mi> <mn>2</mn></msup>
    <mo>)</mo></mrow></math>算法的操作次数为<math alttext="n平方加1"><mrow><msup><mi>n</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>1</mn></mrow></math>，那么从渐近的角度来看（或者对于足够大的*n*），*O(n)*算法比<math alttext="上O左括号n平方右括号"><mrow><mi>O</mi>
    <mo>(</mo> <msup><mi>n</mi> <mn>2</mn></msup> <mo>)</mo></mrow></math>算法更好，但如果*n*小于10，则情况并非如此，因为在这种情况下，<math
    alttext="n平方加1小于20n减99"><mrow><msup><mi>n</mi> <mn>2</mn></msup> <mo>+</mo> <mn>1</mn>
    <mo><</mo> <mn>20</mn> <mi>n</mi> <mo>-</mo> <mn>99</mn></mrow></math>。这对于足够小的问题是可以接受的，但对于更大的问题则不行。
- en: 'Two optimization methods that we will soon mention in this chapter are the
    simplex method and interior point method for linear optimization (optimization
    where both the objective function and the constraints are linear). The interior
    point method is polynomial time algorithm and the simplex method is exponential
    time, so you’d expect that everyone would use the cheaper interior point and abandon
    simplex, but this is not true. The simplex method (and the dual simplex) is still
    widely used for linear optimization instead of interior point because that exponential
    time is a worst case scenario and most applications are not worst cases. Moreover,
    there are usually tradeoffs between algorithms in terms of: Computational effort
    per iteration, number of iterations required, the effect of better starting points,
    does the algorithm converge or will it need *extra help* near the end, how much
    computation this extra help would require, and can the algorithm take advantage
    of parallel processing? For this reason, computer packages for linear optimization
    have efficient implementations of both the simplex and the interior point methods
    (and many other algorithms as well). Ultimately, we choose what works best for
    our use cases.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快将在本章中提到的两种优化方法是单纯形法和内点法，用于线性优化（目标函数和约束均为线性的优化）。内点法是多项式时间算法，而单纯形法是指数时间，因此你可能会期望每个人都使用更便宜的内点法并放弃单纯形法，但事实并非如此。单纯形法（以及对偶单纯形法）仍然广泛用于线性优化，而不是内点法，因为指数时间是最坏情况，而大多数应用并非最坏情况。此外，算法之间通常存在计算量每次迭代、所需迭代次数、更好起始点的影响、算法是否收敛或是否需要在最后阶段*额外帮助*、这种额外帮助需要多少计算以及算法是否能利用并行处理等方面的权衡。因此，用于线性优化的计算机软件包具有单纯形法和内点法的高效实现（以及许多其他算法）。最终，我们选择最适合我们用例的方法。
- en: 'Optimization: The Heart Of Operations Research'
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化：运筹学的核心
- en: 'We found our way back to optimization. In machine learning, optimization is
    about minimizing the loss function for models that learn deterministic functions
    or maximizing the likelihood function for models that learn probability distributions.
    We do not want a solution that matches the data exactly, since that would not
    generalize well to unseen data. Hence regularization methods, early stopping,
    and others. In machine learning, we use the available data to learn the model:
    The deterministic function or the probability distribution that are the source
    of the data (the data generating rule or process), then we use this learned function
    or distribution to make inference. Optimization is just one step along the way:
    Minimize the loss function, with or without regularization terms. The loss functions
    that appear in machine learning are usually differentiable and nonlinear, and
    the optimization is unconstrained. We can add constraints to *guide* the process
    into some desired realm, depending on the application.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们又回到了优化。在机器学习中，优化是关于最小化模型的损失函数，学习确定性函数或最大化学习概率分布的模型的似然函数。我们不希望得到完全匹配数据的解决方案，因为这样无法很好地泛化到未见数据。因此，正则化方法、提前停止等。在机器学习中，我们利用可用数据来学习模型：数据的来源（数据生成规则或过程）的确定性函数或概率分布，然后我们使用这个学习到的函数或分布进行推断。优化只是其中的一步：最小化损失函数，有���没有正则化项。出现在机器学习中的损失函数通常是可微的和非线性的，优化是无约束的。我们可以添加约束来*引导*过程进入某个期望的领域，具体取决于应用。
- en: 'Methods for optimization can either include computing derivatives of the objective
    function <math alttext="f left-parenthesis ModifyingAbove x With right-arrow right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow></math>
    , such as machine learning’s favorite gradient descent (stochastic gradient descent,
    ADAM, *etc.*), or not. There are optimization algorithms that are derivative free:
    These are very useful when the objective function is not differentiable (such
    as functions with corners) or when the formula of the objective function is not
    even available. Examples of derivative free optimization methods include Bayesian
    search, Cuckoo search, and genetic algorithms.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 优化方法可以包括计算目标函数的导数 <math alttext="f left-parenthesis ModifyingAbove x With right-arrow
    right-parenthesis"><mrow><mi>f</mi> <mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>)</mo></mrow></math> ，例如机器学习中喜欢的梯度下降（随机梯度下降、ADAM等），也可以不包括。有些优化算法是无导数的：当目标函数不可微（如具有角点的函数）或目标函数的公式甚至不可用时，这些方法非常有用。无导数优化方法的示例包括贝叶斯搜索、布谷鸟搜索和遗传算法。
- en: 'Optimization, *in particular linear optimization*, has been the heart of operations
    research since the Second World War, when methods for linear optimization such
    as the *simplex method* were developed to aid in military logistics and operations.
    The goal, as always, is to minimize an objective function (cost, distance, time,
    *etc.*) given certain constraints (budget, deadlines, capacity, *etc.*):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 优化，*特别是线性优化*，自二战以来一直是运筹研究的核心，当时为了协助军事后勤和作战而开发了线性优化方法，如*单纯形法*。目标始终是在给定一定约束条件（预算、截止日期、容量等）的情况下，最小化目标函数（成本、距离、时间等）：
- en: <math alttext="dollar-sign m i n Subscript c o n s t r a i n t s Baseline f
    left-parenthesis ModifyingAbove x With right-arrow right-parenthesis dollar-sign"><mrow><mi>m</mi>
    <mi>i</mi> <msub><mi>n</mi> <mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>s</mi></mrow></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow></mrow></math>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign m i n Subscript c o n s t r a i n t s Baseline f
    left-parenthesis ModifyingAbove x With right-arrow right-parenthesis dollar-sign"><mrow><mi>m</mi>
    <mi>i</mi> <msub><mi>n</mi> <mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>s</mi></mrow></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow></mrow></math>
- en: 'To learn optimization for operations research, a typical course usually spends
    a lot of time on linear optimization, integer optimization, and optimization on
    networks (graphs), since many real life logistics and resource allocation problems
    fit perfectly into these formulations. To become thriving operations researchers,
    we need to learn:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 学习运筹优化，一个典型的课程通常会花费大量时间在线性优化、整数优化和网络优化上，因为许多现实生活中的物流和资源分配问题完全符合这些表述。要成为成功的运筹研究者，我们需要学习：
- en: '**Linear optimization**, where both the objective function and the constraints
    are linear: Here we learn about the simplex method, duality, [Lagrangian relaxation](http://www.mi.fu-berlin.de/wiki/pub/Main/GunnarKlauP1winter0708/discMath_klau_script_lag_I.pdf),
    and sensitivity analysis. In linear problems, the boundaries of our world are
    flat, made of lines, planes and hyperplanes. This (hyper)polygonal geometry, or
    *polyhedron*, usually has corner points which are candidates for being optimizers,
    so we devise systematic ways to sift through these points and test them for optimality
    (this is what the simplex method and the dual simplex method do).'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线性优化**，其中目标函数和约束条件均为线性：在这里，我们学习了单纯形法、对偶性、[拉格朗日松弛](http://www.mi.fu-berlin.de/wiki/pub/Main/GunnarKlauP1winter0708/discMath_klau_script_lag_I.pdf)和灵敏度分析。在线性问题中，我们的世界边界是平坦的，由线、平面和超平面构成。这个（超）多边形几何，或*多面体*，通常有角点作为优化器的候选者，因此我们设计系统化的方法来筛选这些点并测试它们是否最优（这就是单纯形法和对偶单纯形法所做的）。'
- en: '**Interior point methods**: For large scale linear optimization problems which
    could be beyond the reach of the simplex method. In short, the simplex method
    goes around the *boundary* of the feasible search space (the edges of the polyhedron),
    checks each corner it arrives at for optimality, then moves to another corner
    at the boundary. The interior point method, on the other hand, goes *through the
    interior* of the feasible search space, arriving at an optimal corner form the
    inside of the feasible search space as opposed to from the boundary.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内点法**：用于大规模线性优化问题，可能超出单纯形法的范围。简而言之，单纯形法沿着可行搜索空间的*边界*（多面体的边缘）前进，检查到达的每个角落是否最优，然后移动到边界上的另一个角落。另一方面，内点法穿过可行搜索空间的*内部*，从内部到达最优角落，而不是从边界到达。'
- en: '**Integer programming**: Optimization where the entries of the optimizing vector
    must all be integers. Sometimes they can only be zero or one (send the truck to
    the warehouse in Ohio or not). The [knapsack problem](https://en.wikipedia.org/wiki/Knapsack_problem)
    is a very simple prototype example. Here we learn about the branch and bound method
    for large integer programming problems.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整数规划**：优化中，优化向量的条目必须全部为整数。有时它们只能是零或一（将卡车送往俄亥俄州的仓库或不送）。[背包问题](https://en.wikipedia.org/wiki/Knapsack_problem)是一个非常简单的原型示例。在这里，我们学习了用于大整数规划问题的分支定界方法。'
- en: '**Optimization on networks**: We can reformulate many network problems as linear
    optimization problems where the simplex methods and specialized versions of it
    work, but it is much better to exploit the network structure and tap into useful
    results from graph theory, such as the max flow min cut theorem, for more efficient
    algorithms. Many problems on networks boil down to optimizing for one of the following:
    Shortest path on the network (path from one node to another with minimum distance
    or minimum cost), minimum spanning tree of a network (this is great for optimizing
    *the design* of networks), maximum flow (from origin to destination or from source
    to sink), minimum cost flow; multicommodity flow; or traveling salesman: Finding
    the minimum cost (or distance or weight) cyclic route that passes through all
    the network’s nodes only once (Hamiltonian circuit).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络优化**：我们可以将许多网络问题重新表述为线性优化问题，其中单纯形法及其专门版本可以工作，但更好的方法是利用网络结构，并从图论中获取有用的结果，例如最大流最小割定理，以获得更高效的算法。许多网络问题归结为以下之一的优化：网络上的最短路径（从一个节点到另一个节点的最小距离或最小成本路径）、网络的最小生成树（这对于优化网络的*设计*非常有用）、最大流（从起点到终点或从源到汇的流）、最小成本流；多商品流；或旅行推销员问题：找到通过网络所有节点仅一次的最小成本（或距离或权重）循环路线（哈密顿回路）。'
- en: '**Nonlinear optimization**: The objective function and/or the constraints are
    nonlinear: One recurring example throughout this book is minimizing nonlinear
    loss functions for machine learning models. These are always nonlinear, and we
    commonly use gradient descent type algorithms. For smaller problems we can use
    Newton type algorithms (second derivatives). In operations research, nonlinearities
    in the objective function and/or constraints might appear because the cost of
    shipping goods from one location to another might not be fixed (for example depends
    on the distance or on the quantity), or a flow through a network might include
    losses or gains. A special type of nonlinear optimization that we know a lot about
    is *quadratic* optimization with linear constraints. This appears in applications
    such as network equations for electric circuits, and elasticity theory for structures
    where we consider displacements, stresses, strains, and balance of forces in a
    structure. Think of how easy it is to find the minimum of the quadratic function
    <math alttext="f left-parenthesis x right-parenthesis equals s x squared"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>s</mi> <msup><mi>x</mi>
    <mn>2</mn></msup></mrow></math> , where *s* is a positive constant. This ease
    translates nicely to higher dimensions, where our objective function looks like
    <math alttext="f left-parenthesis ModifyingAbove x With right-arrow right-parenthesis
    equals ModifyingAbove x With right-arrow Superscript t Baseline upper S ModifyingAbove
    x With right-arrow"><mrow><mi>f</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>)</mo></mrow> <mo>=</mo> <msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mi>t</mi></msup> <mi>S</mi> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover></mrow></math> where *S* is a positive semidefinite matrix,
    playing the same role for high dimensions as a positive constant for one dimension.
    Here we even have duality theory that we can take advantage of, similar to the
    linear optimization case. In optimization, when we lose linearity, we hope our
    functions are quadratic and our constraints are linear. When we lose that, we
    hope our functions and/or feasible set are convex. When we lose convexity, we
    are all on our own, hoping our methods don’t get stuck at local minima of high
    dimensional landscapes, and somehow find their way to optimal solutions.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非线性优化**：目标函数和/或约束是非线性的：本书中一个经常出现的例子是为机器学习模型最小化非线性损失函数。这些函数总是非线性的，我们通常使用梯度下降类型的算法。对于较小的问题，我们可以使用牛顿类型的算法（二阶导数）。在运筹学中，目标函数和/或约束中的非线性可能出现，因为从一个地点运输货物到另一个地点的成本可能不是固定的（例如取决于距离或数量），或者网络中的流量可能包括损失或增益。我们了解很多的一种特殊类型的非线性优化是带有线性约束的*二次*优化。这在应用中出现，比如电路网络方程和弹性理论中，我们考虑结构中的位移、应力、应变和力的平衡。想想找到二次函数的最小值有多容易，其中
    *s* 是一个正常数。这种简便性很好地转化到更高维度，其中我们的目标函数看起来像 <math alttext="f left-parenthesis ModifyingAbove
    x With right-arrow right-parenthesis equals ModifyingAbove x With right-arrow
    Superscript t Baseline upper S ModifyingAbove x With right-arrow"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mi>t</mi></msup>
    <mi>S</mi> <mover accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></math> 其中
    *S* 是一个正半定矩阵，在高维度中扮演着与一维中正常数相同的角色。在这里，我们甚至有对偶理论可以利用，类似于线性优化的情况。在优化中，当我们失去线性性时，我们希望我们的函数是二次的，我们的约束是线性的。当我们失去这一点时，我们希望我们的函数和/或可行集是凸的。当我们失去凸性时，我们就只能靠自己了，希望我们的方法不会陷入高维度景观的局部最小值，并以某种方式找到最优解。'
- en: '**Dynamic programming and Markov decision processes**: Dynamic programming
    has to do with projects with multiple stages, where decisions have to be made
    at each stage, and each decision generates some immediate cost. The decision at
    each stage has to do with the current state, together with a policy to transition
    to the next state (choose the next state via a minimization of a deterministic
    function or a probability). Dynamic programming is all about devising efficient
    ways, usually recursive methods, to finding the *optimal sequence of interrelated
    decisions* to fulfill a certain goal. The idea is to avoid having to list all
    the options for each stage of the decision process, then selecting the best combination
    of decisions. Such an exhaustive search is extremely expensive for problems with
    many decision stages each having many states. Now if the transition policy from
    one stage to the other is probabilistic rather than deterministic, and if the
    stages of the decision process continue to recur indefinitely, meaning if the
    project has an infinite number of stages, then we have a Markov decision process
    (or Markov chain) on our hands. This is a process that evolves over time in a
    probabilistic manner. A very special property of a Markov decision process is
    that the probabilities involving how the process evolves in the future is independent
    of past events, and depend only on the system’s *current state*. Both discrete
    time and continuous time Markov chains model important systems, such as [queueing
    systems](https://www.sciencedirect.com/topics/computer-science/queueing-system),
    dynamic traffic light control to minimize car waiting time, and flexible call
    center staffing. The important math objects are the transition matrix and people
    solve for the steady state probabilities. They end up having to compute the eigenspace
    of the transition matrix.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态规划和马尔可夫决策过程**：动态规划涉及到具有多个阶段的项目，每个阶段都需要做出决策，每个决策都会产生一些即时成本。每个阶段的决策与当前状态有关，以及一个策略来过渡到下一个状态（通过最小化确定性函数或概率选择下一个状态）。动态规划的核心是设计高效的方法，通常是递归方法，以找到*一系列相关决策的最佳顺序*以实现某个目标。这个想法是避免为决策过程的每个阶段列出所有选项，然后选择最佳的决策组合。对于具有许多决策阶段且每个阶段具有许多状态的问题，这种详尽搜索是非常昂贵的。现在，如果从一个阶段到另一个阶段的过渡策略是概率性的而不是确定性的，并且如果决策过程的阶段继续无限地重复，也就是说，如果项目具有无限数量的阶段，那么我们手头就有一个马尔可夫决策过程（或马尔可夫链）。这是一个以概率方式随时间演变的过程。马尔可夫决策过程的一个非常特殊的属性是，涉及到过程如何在未来演变的概率与过去事件无关，仅取决于系统的*当前状态*。离散时间和连续时间马尔可夫链模拟重要系统，例如[排队系统](https://www.sciencedirect.com/topics/computer-science/queueing-system)，动态交通灯控制以最小化汽车等待时间，以及灵活的呼叫中心人员配备。重要的数学对象是过渡矩阵，人们解出稳态概率。他们最终不得不计算过渡矩阵的特征空间。'
- en: '**Stochastic algorithms**: Dynamic programming with probabilistic transition
    policy and Markov chain are both examples of stochastic algorithms. So are stochastic
    gradient descent and random walks on graphs. Any algorithm that involves an element
    of randomness is stochastic. The mathematics transitions to the language of probabilities,
    expectations, stationary states, convergence, *etc.* Another example where stochastic
    algorithms and analysis of processes appear is *queueing theory*, such as queues
    at a hospital emergency room or at a ship maintainance yard. This builds on probability
    distributions of arrival times of customers and service times by the service facility.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机算法**：具有��率性过渡策略和马尔可夫链的动态规划都是随机算法的例子。随机梯度下降和图上的随机游走也是。任何涉及随机元素的算法都是随机的。数学转向概率、期望、稳态状态、收敛等语言。另一个出现随机算法和过程分析的例子是*排队论*，例如医院急诊室或船舶维修场的队列。这建立在顾客到达时间和服务设施的服务时间的概率分布之上。'
- en: '**Metaheuristics**: For many optimization problems, finding the optimal solution
    might be impractical, so people (who still need to make decisions) resort to *heuristic
    methods*, which find an *answer* (I will not call it a solution) which is not
    necessarily optimal, but is good enough for the problem at hand. Metaheuristics
    are general solution methods that provide strategy guidelines and general frameworks
    for developing heuristic methods to fit certain families of problems. We cannot
    guarantee the optimality of an answer from a heuristic method, but heuristics
    do speed up the process of finding satisfactory solutions where optimal solutions
    too expensive to compute or completely are out of reach. There is also the topic
    of *satisfiability*: Since problems in operations research are almost always constrained,
    the natural question is: Are the constraints satisfiable? Meaning is the feasible
    set nonempty? Some operations research problems get reformulated as satisfiability
    problems.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元启发式**：对于许多优化问题，找到最优解可能是不切实际的，因此人们（仍然需要做出决策）求助于*启发式方法*，这些方法找到一个*答案*（我不会称之为解决方案），这个答案不一定是最优的，但对于手头的问题足够好。元启发式是提供策略指导和通用框架的一般解决方法，用于开发适合某些问题族的启发式方法。我们无法保证从启发式方法得到的答案的最优性，但启发式方法加速了找到令人满意的解决方案的过程，其中最优解太昂贵或完全无法计算。还有*可满足性*的话题：由于运筹学中的问题几乎总是受限的，自然的问题是：约束是否可满足？意味着可行集是否非空？一些运筹学问题被重新制定为可满足性问题。'
- en: In real world problems, a big part of the work of operations research departments
    is formulating their specific use cases and objectives in a way that can fit into
    one of the above optimization frameworks. Here it is important to recognize special
    structures (such as sparsity in the involved matrices) or substructures that we
    can exploit for more efficient algorithms. This is crucial for complicated and
    large scale systems.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的问题中，运筹学部门的工作的一大部分是以一种适合上述优化框架之一的方式制定他们的具体用例和目标。在这里，重要的是要认识到特殊结构（例如涉及矩阵的稀疏性）或者我们可以利用更高效算法的子结构。这对于复杂和大规模系统至关重要。
- en: Thinking About Optimization
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考优化
- en: When we encounter an optimization problem in mathematics,
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在数学中遇到一个优化问题时，
- en: <math alttext="dollar-sign min Underscript ModifyingAbove x With right-arrow
    element-of some feasible set Endscripts f left-parenthesis ModifyingAbove x With
    right-arrow right-parenthesis comma dollar-sign"><mrow><msub><mo form="prefix"
    movablelimits="true">min</mo> <mrow><mover accent="true"><mi>x</mi> <mo>→</mo></mover><mo>∈</mo><mtext>some</mtext><mtext>feasible</mtext><mtext>set</mtext></mrow></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mo>,</mo></mrow></math>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript ModifyingAbove x With right-arrow
    element-of some feasible set Endscripts f left-parenthesis ModifyingAbove x With
    right-arrow right-parenthesis comma dollar-sign"><mrow><msub><mo form="prefix"
    movablelimits="true">min</mo> <mrow><mover accent="true"><mi>x</mi> <mo>→</mo></mover><mo>∈</mo><mtext>some</mtext><mtext>feasible</mtext><mtext>set</mtext></mrow></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mo>,</mo></mrow></math>
- en: 'where the feasible set is defined by some constraints that the vector <math
    alttext="ModifyingAbove x With right-arrow"><mover accent="true"><mi>x</mi> <mo>→</mo></mover></math>
    must satisfy (or it could be totally unconstrained), we usually pause and brainstorm
    a little:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在可行集由向量<math alttext="ModifyingAbove x With right-arrow"><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover></math>必须满足的一些约束定义的情况下（或者它可能完全没有约束），我们通常会停下来进行头脑风暴：
- en: Is <math alttext="f left-parenthesis ModifyingAbove x With right-arrow right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow></math>
    linear?
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis ModifyingAbove x With right-arrow right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow></math>
    是线性的吗？
- en: Is <math alttext="f left-parenthesis ModifyingAbove x With right-arrow right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow></math>
    convex? Bounded below?
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis ModifyingAbove x With right-arrow right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow></math>是凸的吗？下界有界吗？
- en: Is the minimum value finite, or does it <math alttext="negative normal infinity"><mrow><mo>→</mo>
    <mo>-</mo> <mi>∞</mi></mrow></math> ?
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小值是有限的，还是<math alttext="negative normal infinity"><mrow><mo>→</mo> <mo>-</mo>
    <mi>∞</mi></mrow></math>？
- en: Is the feasible set nonempty? Meaning are there <math alttext="ModifyingAbove
    x With right-arrow"><mover accent="true"><mi>x</mi> <mo>→</mo></mover></math>
    ’s that actually satisfy the constraints?
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可行集非空吗？意味着是否有<math alttext="ModifyingAbove x With right-arrow"><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover></math>实际满足约束？
- en: Is the feasible set convex?
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可行集是凸的吗？
- en: Does a minimizer exist?
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否存在最小化器？
- en: Is a minimizer unique, or are there others?
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化器是唯一的，还是还有其他的？
- en: How do we find the minimizer?
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何找到最小化器？
- en: What is the value of the minimum?
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小值是多少？
- en: How much does minimizer and the value of the minimum change if something changes
    in our constraints or in our objective function?
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们的约束或目标函数发生变化，最小化器和最小值会发生多大变化？
- en: Depending on the type of problem at hand, we might be able to answer the above
    questions independently, meaning sometimes we can answer only some of them and
    not others. This fine because any information about the optimizer and the value
    of the optimum is valuable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 根据手头问题的类型，我们可能能够独立回答上述问题，有时候我们只能回答其中一些而不能回答其他问题。这没关系，因为有关优化器和最优值的任何信息都是有价值的。
- en: 'Let’s explore common types of optimization problems:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨常见类型的优化问题：
- en: Optimization- Finite Dimensions- Unconstrained
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化-有限维-无约束
- en: 'This is similar to the optimization that we do in calculus classes, and the
    optimization we do when training a machine learning model, minimizing the loss
    function. The objective function <math alttext="f left-parenthesis ModifyingAbove
    x With right-arrow right-parenthesis"><mrow><mi>f</mi> <mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>)</mo></mrow></math> is differentiable:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于我们在微积分课程中进行的优化，以及我们在训练机器学习模型时进行的优化，即最小化损失函数。目标函数<math alttext="f left-parenthesis
    ModifyingAbove x With right-arrow right-parenthesis"><mrow><mi>f</mi> <mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow></math> 是可微的：
- en: <math alttext="dollar-sign min Underscript ModifyingAbove x With right-arrow
    element-of double-struck upper R Superscript d Baseline Endscripts f left-parenthesis
    ModifyingAbove x With right-arrow right-parenthesis period dollar-sign"><mrow><msub><mo
    form="prefix" movablelimits="true">min</mo> <mrow><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover><mo>∈</mo><msup><mi>ℝ</mi> <mi>d</mi></msup></mrow></msub> <mi>f</mi>
    <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow>
    <mo>.</mo></mrow></math>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript ModifyingAbove x With right-arrow
    element-of double-struck upper R Superscript d Baseline Endscripts f left-parenthesis
    ModifyingAbove x With right-arrow right-parenthesis period dollar-sign"><mrow><msub><mo
    form="prefix" movablelimits="true">min</mo> <mrow><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover><mo>∈</mo><msup><mi>ℝ</mi> <mi>d</mi></msup></mrow></msub> <mi>f</mi>
    <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow>
    <mo>.</mo></mrow></math>
- en: In unconstrained and differentiable optimization, the minimizer <math alttext="ModifyingAbove
    x With right-arrow Superscript asterisk"><msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>*</mo></msup></math> satisfies <math alttext="normal nabla
    f left-parenthesis ModifyingAbove x With right-arrow right-parenthesis equals
    0"><mrow><mi>∇</mi> <mi>f</mi> <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>)</mo> <mo>=</mo> <mn>0</mn></mrow></math> . Moreover, the Hessian (matrix
    of second derivatives) is positive semidefinite at <math alttext="ModifyingAbove
    x With right-arrow Superscript asterisk"><msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>*</mo></msup></math> . When discussing optimization for
    machine learning we settled on stochastic gradient descent and its variants for
    very high dimensional problems. For smaller problems Newton type (working with
    second derivatives not only first ones) methods work as well. For very few problems
    such a the mean squared error loss function for linear regression, we can get
    analytical solutions. Examples where we can get analytical solutions are usually
    carefully constructed (such as all the examples in our calculus books), and very
    low dimensional.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在无约束和可微的优化中，最小化器<math alttext="ModifyingAbove x With right-arrow Superscript
    asterisk"><msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup></math>
    满足<math alttext="normal nabla f left-parenthesis ModifyingAbove x With right-arrow
    right-parenthesis equals 0"><mrow><mi>∇</mi> <mi>f</mi> <mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>)</mo> <mo>=</mo> <mn>0</mn></mrow></math>。此外，在<math alttext="ModifyingAbove
    x With right-arrow Superscript asterisk"><msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>*</mo></msup></math>处，Hessian（二阶导数矩阵）是半正定的。在讨论机器学习的优化时，我们选择了随机梯度下降及其变体来解决非常高维的问题。对于较小的问题，牛顿类型（使用二阶导数而不仅仅是一阶导数）的方法也有效。对于很少的问题，比如线性回归的均方误差损失函数，我们可以得到解析解。通常可以得到解析解的示例通常是精心构造的（例如我们微积分书中的所有示例），并且维度非常低。
- en: Optimization- Finite Dimensions- Constrained- Lagrange Multipliers
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化-有限维-约束-拉格朗日乘数
- en: 'Let’s think of the case where we only have one constraint <math alttext="g
    left-parenthesis ModifyingAbove x With right-arrow right-parenthesis equals b"><mrow><mi>g</mi>
    <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo> <mo>=</mo>
    <mi>b</mi></mrow></math> . This explains what we need rather well. The minimization
    problem looks like:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑只有一个约束<math alttext="g left-parenthesis ModifyingAbove x With right-arrow
    right-parenthesis equals b"><mrow><mi>g</mi> <mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>)</mo> <mo>=</mo> <mi>b</mi></mrow></math>的情况。这相当好地解释了我们需要什么。最小化问题看起来像：
- en: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column g left-parenthesis ModifyingAbove x With right-arrow right-parenthesis
    equals b 2nd Row 1st Column Blank 2nd Column x element-of double-struck upper
    R Superscript d Baseline EndLayout Endscripts f left-parenthesis ModifyingAbove
    x With right-arrow right-parenthesis period dollar-sign"><mrow><msub><mo form="prefix"
    movablelimits="true">min</mo> <mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mi>g</mi><mo>(</mo><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>)</mo><mo>=</mo><mi>b</mi></mrow></mtd></mtr><mtr><mtd
    columnalign="left"><mrow><mi>x</mi><mo>∈</mo><msup><mi>ℝ</mi> <mi>d</mi></msup></mrow></mtd></mtr></mtable></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mo>.</mo></mrow></math>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column g left-parenthesis ModifyingAbove x With right-arrow right-parenthesis
    equals b 2nd Row 1st Column Blank 2nd Column x element-of double-struck upper
    R Superscript d Baseline EndLayout Endscripts f left-parenthesis ModifyingAbove
    x With right-arrow right-parenthesis period dollar-sign"><mrow><msub><mo form="prefix"
    movablelimits="true">min</mo> <mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mi>g</mi><mo>(</mo><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>)</mo><mo>=</mo><mi>b</mi></mrow></mtd></mtr><mtr><mtd
    columnalign="left"><mrow><mi>x</mi><mo>∈</mo><msup><mi>ℝ</mi> <mi>d</mi></msup></mrow></mtd></mtr></mtable></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mo>.</mo></mrow></math>
- en: 'If <math alttext="f left-parenthesis ModifyingAbove x With right-arrow right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow></math>
    and <math alttext="g left-parenthesis ModifyingAbove x With right-arrow right-parenthesis"><mrow><mi>g</mi>
    <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow></math>
    are differentiable functions from <math alttext="double-struck upper R Superscript
    d Baseline right-arrow double-struck upper R"><mrow><msup><mi>ℝ</mi> <mi>d</mi></msup>
    <mo>→</mo> <mi>ℝ</mi></mrow></math> , we can introduce Lagrange multipliers (a
    method from 1797) to change our problem into an *unconstrained* one, but in higher
    dimensions (corresponding to the new Lagrange multipliers that we introduce to
    the optimization problem). Nothing is free. In this case, we add a multiple of
    our constraint to the objective function, then minimize, which means look for
    the points where the gradient is zero. The new objective function for the unconstrained
    problem is called the Lagrangian, and it is a function of both the decision vector
    <math alttext="ModifyingAbove x With right-arrow"><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover></math> and the new variable <math alttext="lamda"><mi>λ</mi></math>
    which we multiplied by our constraint, called the *Lagrange multiplier*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果<math alttext="f left-parenthesis ModifyingAbove x With right-arrow right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow></math>和<math
    alttext="g left-parenthesis ModifyingAbove x With right-arrow right-parenthesis"><mrow><mi>g</mi>
    <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow></math>是从<math
    alttext="double-struck upper R Superscript d Baseline right-arrow double-struck
    upper R"><mrow><msup><mi>ℝ</mi> <mi>d</mi></msup> <mo>→</mo> <mi>ℝ</mi></mrow></math>的可微函数，我们可以引入拉格朗日乘子（一种来自1797年的方法）将我们的问题转化为一个*无约束*问题，但在更高的维度（对应于我们引入到优化问题中的新拉格朗日乘子）。没有免费的午餐。在这种情况下，我们将约束的倍数添加到目标函数中，然后最小化，这意味着寻找梯度为零的点。无约束问题的新目标函数称为拉格朗日函数，它是决策向量<math
    alttext="ModifyingAbove x With right-arrow"><mover accent="true"><mi>x</mi> <mo>→</mo></mover></math>和我们乘以约束的新变量<math
    alttext="lamda"><mi>λ</mi></math>的函数，称为*拉格朗日乘子*：
- en: <math alttext="dollar-sign script upper L left-parenthesis ModifyingAbove x
    With right-arrow semicolon lamda right-parenthesis equals f left-parenthesis ModifyingAbove
    x With right-arrow right-parenthesis plus lamda left-parenthesis b minus g left-parenthesis
    ModifyingAbove x With right-arrow right-parenthesis right-parenthesis period dollar-sign"><mrow><mi>ℒ</mi>
    <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>;</mo>
    <mi>λ</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>)</mo></mrow> <mo>+</mo> <mi>λ</mi> <mrow><mo>(</mo> <mi>b</mi>
    <mo>-</mo> <mi>g</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>.</mo></mrow></math>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign script upper L left-parenthesis ModifyingAbove x
    With right-arrow semicolon lamda right-parenthesis equals f left-parenthesis ModifyingAbove
    x With right-arrow right-parenthesis plus lamda left-parenthesis b minus g left-parenthesis
    ModifyingAbove x With right-arrow right-parenthesis right-parenthesis period dollar-sign"><mrow><mi>ℒ</mi>
    <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>;</mo>
    <mi>λ</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>)</mo></mrow> <mo>+</mo> <mi>λ</mi> <mrow><mo>(</mo> <mi>b</mi>
    <mo>-</mo> <mi>g</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>.</mo></mrow></math>
- en: If we have more than one constraint, say five constraints, then we introduce
    a Lagrange multiplier for each, ending up with adding five extra dimensions to
    our optimization problem, inorder to move it from the constrained regime to the
    unconstrained one.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有多于一个约束条件，比如五个约束条件，那么我们为每个约束引入一个拉格朗日乘子，最终在我们的优化问题中添加五个额外的维度，以将其从受限制的状态移动到无约束状态。
- en: 'The optimizer <math alttext="left-parenthesis ModifyingAbove x With right-arrow
    Superscript asterisk Baseline comma lamda Superscript asterisk Baseline right-parenthesis"><mrow><mo>(</mo>
    <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mo>,</mo>
    <msup><mi>λ</mi> <mo>*</mo></msup> <mo>)</mo></mrow></math> of the unconstrained
    problem must satisfy: <math alttext="normal nabla script upper L left-parenthesis
    ModifyingAbove x With right-arrow semicolon lamda right-parenthesis equals 0"><mrow><mi>∇</mi>
    <mi>ℒ</mi> <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>;</mo>
    <mi>λ</mi> <mo>)</mo> <mo>=</mo> <mn>0</mn></mrow></math> . We go about finding
    it the same way we go about general unconstrained problems (see the previous case).
    The <math alttext="ModifyingAbove x With right-arrow Superscript asterisk"><msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup></math> from <math
    alttext="left-parenthesis ModifyingAbove x With right-arrow Superscript asterisk
    Baseline comma lamda Superscript asterisk Baseline right-parenthesis"><mrow><mo>(</mo>
    <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mo>,</mo>
    <msup><mi>λ</mi> <mo>*</mo></msup> <mo>)</mo></mrow></math> *is the solution of
    the constrained problem* that we were originally searching for. This means that
    it is the point on the hypersurface defined by the constraint <math alttext="g
    left-parenthesis ModifyingAbove x With right-arrow Superscript asterisk Baseline
    right-parenthesis equals b"><mrow><mi>g</mi> <mo>(</mo> <msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mo>)</mo> <mo>=</mo> <mi>b</mi></mrow></math>
    where the value of *f* is smallest.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 无约束问题的优化器<math alttext="left-parenthesis ModifyingAbove x With right-arrow Superscript
    asterisk Baseline comma lamda Superscript asterisk Baseline right-parenthesis"><mrow><mo>(</mo>
    <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mo>,</mo>
    <msup><mi>λ</mi> <mo>*</mo></msup> <mo>)</mo></mrow></math>必须满足：<math alttext="normal
    nabla script upper L left-parenthesis ModifyingAbove x With right-arrow semicolon
    lamda right-parenthesis equals 0"><mrow><mi>∇</mi> <mi>ℒ</mi> <mo>(</mo> <mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>;</mo> <mi>λ</mi> <mo>)</mo> <mo>=</mo>
    <mn>0</mn></mrow></math>。我们寻找它的方式与我们处理一般无约束问题的方式相同（参见前面的情况）。从<math alttext="left-parenthesis
    ModifyingAbove x With right-arrow Superscript asterisk Baseline comma lamda Superscript
    asterisk Baseline right-parenthesis"><mrow><mo>(</mo> <msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mo>,</mo> <msup><mi>λ</mi> <mo>*</mo></msup>
    <mo>)</mo></mrow></math>中的<math alttext="ModifyingAbove x With right-arrow Superscript
    asterisk"><msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup></math>
    *是我们最初寻找的受限制问题的解*。这意味着它是由约束<math alttext="g left-parenthesis ModifyingAbove x
    With right-arrow Superscript asterisk Baseline right-parenthesis equals b"><mrow><mi>g</mi>
    <mo>(</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup>
    <mo>)</mo> <mo>=</mo> <mi>b</mi></mrow></math>定义的超曲面上的点，其中*f*的值最小。
- en: If the problem has a special structure that we can exploit, such as if *f* is
    quadratic and the constraint *g* is linear, or if both *f* and *g* are linear,
    then we have more convenient methods to go about this constrained optimization,
    both if we decide to use Lagrange multipliers (which introduces duality) and without
    using Lagrange multipliers. Luckily optimization problems with simple structures
    are very well studied, not only because they make the mathematics and computations
    easier, but also because they appear all the time in science and in real life
    applications, which gives some credibility to my theory that nature is simpler
    than mathematicians think it is. We will revisit Lagrange multipliers for constrained
    problems in the section on duality, where we focus solely on fully linear problems
    or on quadratic problems with linear constraints.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题具有我们可以利用的特殊结构，比如*f*是二次的，约束*g*是线性的，或者*f*和*g*都是线性的，那么我们有更方便的方法来进行这种受限优化，无论我们决定使用拉格朗日乘子（引入对偶）还是不使用拉格朗日乘子。幸运的是，具有简单结构的优化问题已经被广泛研究，不仅因为它们使数学和计算更容易，而且因为它们在科学和现实生活应用中经常出现，这证实了我的理论，即自然比数学家认为的要简单。我们将在对偶部分重新讨论受限问题的拉格朗日乘子，在那里我们专注于完全线性问题或具有线性约束的二次问题。
- en: 'The nice thing that we should make a permanent mental note of is that the Lagrange
    multiplier <math alttext="lamda"><mi>λ</mi></math> is not some worthless auxiliary
    scalar that helped us change a constrained problem into an unconstrained one.
    It has a meaning that is very helpful for sensitivity analysis, for finance and
    operations research applications, and for duality theory (which are all related
    to each other). Mathematically, by observing the formula of the Lagrangian <math
    alttext="script upper L left-parenthesis ModifyingAbove x With right-arrow semicolon
    lamda right-parenthesis equals f left-parenthesis ModifyingAbove x With right-arrow
    right-parenthesis plus lamda left-parenthesis b minus g left-parenthesis ModifyingAbove
    x With right-arrow right-parenthesis right-parenthesis"><mrow><mi>ℒ</mi> <mrow><mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>;</mo> <mi>λ</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mo>+</mo> <mi>λ</mi> <mrow><mo>(</mo> <mi>b</mi> <mo>-</mo>
    <mi>g</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math> , <math alttext="lamda"><mi>λ</mi></math>
    is the rate of change of the Lagrangian as a function of *b*, if we were allowed
    to vary *b* (the value of the constraint; in applications we care about the effect
    of pushing or relaxing the constraints). That is:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该永久地记住的好事是，拉格朗日乘子λ不是一种毫无价值的辅助标量，它帮助我们将一个受限问题转变为一个无约束问题。它具有非常有用的含义，对于灵敏度分析、金融和运营研究应用以及对偶理论都非常有帮助（它们彼此相关）。从数学上讲，通过观察拉格朗日函数的公式，λ是拉格朗日函数作为*b*的函数的变化率，如果我们被允许改变*b*（约束的值；在应用中，我们关心推动或放松约束的影响）。也就是说：
- en: <math alttext="dollar-sign StartFraction normal partial-differential script
    upper L left-parenthesis left-parenthesis ModifyingAbove x With right-arrow semicolon
    lamda comma b right-parenthesis right-parenthesis Over normal partial-differential
    b EndFraction equals StartFraction normal partial-differential f left-parenthesis
    ModifyingAbove x With right-arrow right-parenthesis plus lamda left-parenthesis
    b minus g left-parenthesis ModifyingAbove x With right-arrow right-parenthesis
    right-parenthesis Over normal partial-differential b EndFraction equals StartFraction
    normal partial-differential f left-parenthesis ModifyingAbove x With right-arrow
    right-parenthesis Over normal partial-differential b EndFraction plus StartFraction
    lamda left-parenthesis b minus g left-parenthesis ModifyingAbove x With right-arrow
    right-parenthesis right-parenthesis Over normal partial-differential b EndFraction
    equals 0 plus lamda equals lamda period dollar-sign"><mrow><mfrac><mrow><mi>∂</mi><mi>ℒ</mi><mo>(</mo><mrow><mo>(</mo><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>;</mo><mi>λ</mi><mo>,</mo><mi>b</mi><mo>)</mo></mrow><mo>)</mo></mrow>
    <mrow><mi>∂</mi><mi>b</mi></mrow></mfrac> <mo>=</mo> <mfrac><mrow><mi>∂</mi><mi>f</mi><mrow><mo>(</mo><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>)</mo></mrow><mo>+</mo><mi>λ</mi><mrow><mo>(</mo><mi>b</mi><mo>-</mo><mi>g</mi><mrow><mo>(</mo><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>)</mo></mrow><mo>)</mo></mrow></mrow>
    <mrow><mi>∂</mi><mi>b</mi></mrow></mfrac> <mo>=</mo> <mfrac><mrow><mi>∂</mi><mi>f</mi><mo>(</mo><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>)</mo></mrow> <mrow><mi>∂</mi><mi>b</mi></mrow></mfrac>
    <mo>+</mo> <mfrac><mrow><mi>λ</mi><mo>(</mo><mi>b</mi><mo>-</mo><mi>g</mi><mrow><mo>(</mo><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>)</mo></mrow><mo>)</mo></mrow>
    <mrow><mi>∂</mi><mi>b</mi></mrow></mfrac> <mo>=</mo> <mn>0</mn> <mo>+</mo> <mi>λ</mi>
    <mo>=</mo> <mi>λ</mi> <mo>.</mo></mrow></math>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartFraction normal partial-differential script
    upper L left-parenthesis left-parenthesis ModifyingAbove x With right-arrow semicolon
    lamda comma b right-parenthesis right-parenthesis Over normal partial-differential
    b EndFraction equals StartFraction normal partial-differential f left-parenthesis
    ModifyingAbove x With right-arrow right-parenthesis plus lamda left-parenthesis
    b minus g left-parenthesis ModifyingAbove x With right-arrow right-parenthesis
    right-parenthesis Over normal partial-differential b EndFraction equals StartFraction
    normal partial-differential f left-parenthesis ModifyingAbove x With right-arrow
    right-parenthesis Over normal partial-differential b EndFraction plus StartFraction
    lamda left-parenthesis b minus g left-parenthesis ModifyingAbove x With right-arrow
    right-parenthesis right-parenthesis Over normal partial-differential b EndFraction
    equals 0 plus lamda equals lamda period dollar-sign"><mrow><mfrac><mrow><mi>∂</mi><mi>ℒ</mi><mo>(</mo><mrow><mo>(</mo><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>;</mo><mi>λ</mi><mo>,</mo><mi>b</mi><mo>)</mo></mrow><mo>)</mo></mrow>
    <mrow><mi>∂</mi><mi>b</mi></mrow></mfrac> <mo>=</mo> <mfrac><mrow><mi>∂</mi><mi>f</mi><mrow><mo>(</mo><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>)</mo></mrow><mo>+</mo><mi>λ</mi><mrow><mo>(</mo><mi>b</mi><mo>-</mo><mi>g</mi><mrow><mo>(</mo><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>)</mo></mrow><mo>)</mo></mrow></mrow>
    <mrow><mi>∂</mi><mi>b</mi></mrow></mfrac> <mo>=</mo> <mfrac><mrow><mi>∂</mi><mi>f</mi><mo>(</mo><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>)</mo></mrow> <mrow><mi>∂</mi><mi>b</mi></mrow></mfrac>
    <mo>+</mo> <mfrac><mrow><mi>λ</mi><mo>(</mo><mi>b</mi><mo>-</mo><mi>g</mi><mrow><mo>(</mo><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>)</mo></mrow><mo>)</mo></mrow>
    <mrow><mi>∂</mi><mi>b</mi></mrow></mfrac> <mo>=</mo> <mn>0</mn> <mo>+</mo> <mi>λ</mi>
    <mo>=</mo> <mi>λ</mi> <mo>.</mo></mrow></math>
- en: 'Moreover, we can interpret the optimal value <math alttext="lamda Superscript
    asterisk"><msup><mi>λ</mi> <mo>*</mo></msup></math> corresponding to the optimizer
    <math alttext="ModifyingAbove x With right-arrow Superscript asterisk"><msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup></math> as *the marginal
    effect of b* on the optimal attainable value of the objective function <math alttext="f
    left-parenthesis ModifyingAbove x With right-arrow Superscript asterisk Baseline
    right-parenthesis"><mrow><mi>f</mi> <mo>(</mo> <msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mo>)</mo></mrow></math> . Hence, if <math
    alttext="lamda Superscript asterisk Baseline equals 2.1"><mrow><msup><mi>λ</mi>
    <mo>*</mo></msup> <mo>=</mo> <mn>2</mn> <mo>.</mo> <mn>1</mn></mrow></math> ,
    then increasing *b* by one unit (pushing the constraint by one unit) will increase
    the optimal value of *f* by *2.1* units. This is very valuable information for
    applications in finance and operations research. Let’s see why this is the case.
    We want to prove that:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以将对应于最优化器的最优值λ*解释为*b*对目标函数f的最优可达值的边际效应。因此，如果λ* = 2.1，则将*b*增加一单位（将约束推动一单位）将使*f*的最优值增加2.1单位。这对金融和运营研究中的应用非常有价值。让我们看看为什么会这样。我们想要证明：
- en: <math alttext="dollar-sign StartFraction d f left-parenthesis ModifyingAbove
    x With right-arrow Superscript asterisk Baseline left-parenthesis b right-parenthesis
    right-parenthesis Over d b EndFraction equals lamda Superscript asterisk Baseline
    period dollar-sign"><mrow><mfrac><mrow><mi>d</mi><mi>f</mi><mo>(</mo><msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo><mi>b</mi><mo>)</mo></mrow><mo>)</mo></mrow>
    <mrow><mi>d</mi><mi>b</mi></mrow></mfrac> <mo>=</mo> <msup><mi>λ</mi> <mo>*</mo></msup>
    <mo>.</mo></mrow></math>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartFraction d f left-parenthesis ModifyingAbove
    x With right-arrow Superscript asterisk Baseline left-parenthesis b right-parenthesis
    right-parenthesis Over d b EndFraction equals lamda Superscript asterisk Baseline
    period dollar-sign"><mrow><mfrac><mrow><mi>d</mi><mi>f</mi><mo>(</mo><msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo><mi>b</mi><mo>)</mo></mrow><mo>)</mo></mrow>
    <mrow><mi>d</mi><mi>b</mi></mrow></mfrac> <mo>=</mo> <msup><mi>λ</mi> <mo>*</mo></msup>
    <mo>.</mo></mrow></math>
- en: 'Note that two things happen at the optimizer <math alttext="ModifyingAbove
    x With right-arrow Superscript asterisk Baseline left-parenthesis b right-parenthesis"><mrow><msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo>
    <mi>b</mi> <mo>)</mo></mrow></mrow></math> , which we get when we set the gradient
    of the Lagrangian to zero: <math alttext="normal nabla f left-parenthesis ModifyingAbove
    x With right-arrow Superscript asterisk Baseline left-parenthesis b right-parenthesis
    right-parenthesis equals lamda Superscript asterisk Baseline normal nabla g left-parenthesis
    ModifyingAbove x With right-arrow Superscript asterisk Baseline left-parenthesis
    b right-parenthesis right-parenthesis"><mrow><mi>∇</mi> <mi>f</mi> <mrow><mo>(</mo>
    <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo>
    <mi>b</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>λ</mi> <mo>*</mo></msup>
    <mi>∇</mi> <mi>g</mi> <mrow><mo>(</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>*</mo></msup> <mrow><mo>(</mo> <mi>b</mi> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
    , and <math alttext="g left-parenthesis ModifyingAbove x With right-arrow Superscript
    asterisk Baseline left-parenthesis b right-parenthesis right-parenthesis equals
    b"><mrow><mi>g</mi> <mo>(</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>*</mo></msup> <mrow><mo>(</mo> <mi>b</mi> <mo>)</mo></mrow> <mo>)</mo> <mo>=</mo>
    <mi>b</mi></mrow></math> . Using this information and the chain rule for derivatives
    (go back to your calculus book and master the chain rule, we use it all the time),
    we now have:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在优化器<math alttext="ModifyingAbove x With right-arrow Superscript asterisk
    Baseline left-parenthesis b right-parenthesis"><mrow><msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo> <mi>b</mi> <mo>)</mo></mrow></mrow></math>处发生两件事，当我们将拉格朗日函数的梯度设为零时，我们得到：
    <math alttext="normal nabla f left-parenthesis ModifyingAbove x With right-arrow
    Superscript asterisk Baseline left-parenthesis b right-parenthesis right-parenthesis
    equals lamda Superscript asterisk Baseline normal nabla g left-parenthesis ModifyingAbove
    x With right-arrow Superscript asterisk Baseline left-parenthesis b right-parenthesis
    right-parenthesis"><mrow><mi>∇</mi> <mi>f</mi> <mrow><mo>(</mo> <msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo> <mi>b</mi> <mo>)</mo></mrow>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mi>λ</mi> <mo>*</mo></msup> <mi>∇</mi> <mi>g</mi>
    <mrow><mo>(</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup>
    <mrow><mo>(</mo> <mi>b</mi> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>，和<math
    alttext="g left-parenthesis ModifyingAbove x With right-arrow Superscript asterisk
    Baseline left-parenthesis b right-parenthesis right-parenthesis equals b"><mrow><mi>g</mi>
    <mo>(</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup>
    <mrow><mo>(</mo> <mi>b</mi> <mo>)</mo></mrow> <mo>)</mo> <mo>=</mo> <mi>b</mi></mrow></math>。利用这些信息和导数的链式法则（回到您的微积分书中，掌握链式法则，我们经常使用它），我们现在有：
- en: <math alttext="dollar-sign StartFraction d f left-parenthesis ModifyingAbove
    x With right-arrow Superscript asterisk Baseline left-parenthesis b right-parenthesis
    right-parenthesis Over d b EndFraction equals normal nabla f left-parenthesis
    ModifyingAbove x With right-arrow Superscript asterisk Baseline left-parenthesis
    b right-parenthesis right-parenthesis period StartFraction d ModifyingAbove x
    With right-arrow Superscript asterisk Baseline left-parenthesis b right-parenthesis
    Over d b EndFraction equals lamda Superscript asterisk Baseline normal nabla g
    left-parenthesis ModifyingAbove x With right-arrow Superscript asterisk Baseline
    left-parenthesis b right-parenthesis right-parenthesis StartFraction d ModifyingAbove
    x With right-arrow Superscript asterisk Baseline left-parenthesis b right-parenthesis
    Over d b EndFraction equals lamda Superscript asterisk Baseline StartFraction
    d g left-parenthesis ModifyingAbove x With right-arrow Superscript asterisk Baseline
    left-parenthesis b right-parenthesis right-parenthesis Over d b EndFraction equals
    lamda Superscript asterisk Baseline StartFraction d b Over d b EndFraction equals
    lamda Superscript asterisk Baseline times 1 equals lamda Superscript asterisk
    Baseline period dollar-sign"><mrow><mfrac><mrow><mi>d</mi><mi>f</mi><mo>(</mo><msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo><mi>b</mi><mo>)</mo></mrow><mo>)</mo></mrow>
    <mrow><mi>d</mi><mi>b</mi></mrow></mfrac> <mo>=</mo> <mi>∇</mi> <mi>f</mi> <mrow><mo>(</mo>
    <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo>
    <mi>b</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>.</mo> <mfrac><mrow><mi>d</mi><msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo><mi>b</mi><mo>)</mo></mrow></mrow>
    <mrow><mi>d</mi><mi>b</mi></mrow></mfrac> <mo>=</mo> <msup><mi>λ</mi> <mo>*</mo></msup>
    <mi>∇</mi> <mi>g</mi> <mrow><mo>(</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>*</mo></msup> <mrow><mo>(</mo> <mi>b</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mfrac><mrow><mi>d</mi><msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>*</mo></msup> <mrow><mo>(</mo><mi>b</mi><mo>)</mo></mrow></mrow> <mrow><mi>d</mi><mi>b</mi></mrow></mfrac>
    <mo>=</mo> <msup><mi>λ</mi> <mo>*</mo></msup> <mfrac><mrow><mi>d</mi><mi>g</mi><mo>(</mo><msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo><mi>b</mi><mo>)</mo></mrow><mo>)</mo></mrow>
    <mrow><mi>d</mi><mi>b</mi></mrow></mfrac> <mo>=</mo> <msup><mi>λ</mi> <mo>*</mo></msup>
    <mfrac><mrow><mi>d</mi><mi>b</mi></mrow> <mrow><mi>d</mi><mi>b</mi></mrow></mfrac>
    <mo>=</mo> <msup><mi>λ</mi> <mo>*</mo></msup> <mo>×</mo> <mn>1</mn> <mo>=</mo>
    <msup><mi>λ</mi> <mo>*</mo></msup> <mo>.</mo></mrow></math>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartFraction d f left-parenthesis ModifyingAbove
    x With right-arrow Superscript asterisk Baseline left-parenthesis b right-parenthesis
    right-parenthesis Over d b EndFraction equals normal nabla f left-parenthesis
    ModifyingAbove x With right-arrow Superscript asterisk Baseline left-parenthesis
    b right-parenthesis right-parenthesis period StartFraction d ModifyingAbove x
    With right-arrow Superscript asterisk Baseline left-parenthesis b right-parenthesis
    Over d b EndFraction equals lamda Superscript asterisk Baseline normal nabla g
    left-parenthesis ModifyingAbove x With right-arrow Superscript asterisk Baseline
    left-parenthesis b right-parenthesis right-parenthesis StartFraction d ModifyingAbove
    x With right-arrow Superscript asterisk Baseline left-parenthesis b right-parenthesis
    Over d b EndFraction equals lamda Superscript asterisk Baseline StartFraction
    d g left-parenthesis ModifyingAbove x With right-arrow Superscript asterisk Baseline
    left-parenthesis b right-parenthesis right-parenthesis Over d b EndFraction equals
    lamda Superscript asterisk Baseline StartFraction d b Over d b EndFraction equals
    lamda Superscript asterisk Baseline times 1 equals lamda Superscript asterisk
    Baseline period dollar-sign"><mrow><mfrac><mrow><mi>d</mi><mi>f</mi><mo>(</mo><msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo><mi>b</mi><mo>)</mo></mrow><mo>)</mo></mrow>
    <mrow><mi>d</mi><mi>b</mi></mrow></mfrac> <mo>=</mo> <mi>∇</mi> <mi>f</mi> <mrow><mo>(</mo>
    <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo>
    <mi>b</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>.</mo> <mfrac><mrow><mi>d</mi><msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo><mi>b</mi><mo>)</mo></mrow></mrow>
    <mrow><mi>d</mi><mi>b</mi></mrow></mfrac> <mo>=</mo> <msup><mi>λ</mi> <mo>*</mo></msup>
    <mi>∇</mi> <mi>g</mi> <mrow><mo>(</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>*</mo></msup> <mrow><mo>(</mo> <mi>b</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mfrac><mrow><mi>d</mi><msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>*</mo></msup> <mrow><mo>(</mo><mi>b</mi><mo>)</mo></mrow></mrow> <mrow><mi>d</mi><mi>b</mi></mrow></mfrac>
    <mo>=</mo> <msup><mi>λ</mi> <mo>*</mo></msup> <mfrac><mrow><mi>d</mi><mi>g</mi><mo>(</mo><msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo><mi>b</mi><mo>)</mo></mrow><mo>)</mo></mrow>
    <mrow><mi>d</mi><mi>b</mi></mrow></mfrac> <mo>=</mo> <msup><mi>λ</mi> <mo>*</mo></msup>
    <mfrac><mrow><mi>d</mi><mi>b</mi></mrow> <mrow><mi>d</mi><mi>b</mi></mrow></mfrac>
    <mo>=</mo> <msup><mi>λ</mi> <mo>*</mo></msup> <mo>×</mo> <mn>1</mn> <mo>=</mo>
    <msup><mi>λ</mi> <mo>*</mo></msup> <mo>.</mo></mrow></math>
- en: In other words, the Lagrange multiplier <math alttext="lamda Superscript asterisk"><msup><mi>λ</mi>
    <mo>*</mo></msup></math> is the rate of change of the optimal cost (value of the
    objective function) due to the relaxation of the corresponding constraint. In
    economics, <math alttext="lamda Superscript asterisk"><msup><mi>λ</mi> <mo>*</mo></msup></math>
    is called the *marginal cost* with respect to the constraint, or the *shadow price*.
    When we discuss duality later in this chapter, we use the letters *p* for the
    decision variables of the dual problem for this *price* reason.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，拉格朗日乘子<math alttext="lamda Superscript asterisk"><msup><mi>λ</mi> <mo>*</mo></msup></math>是最优成本（目标函数的值）由于相应约束的放松而发生变化的速率。在经济学中，<math
    alttext="lamda Superscript asterisk"><msup><mi>λ</mi> <mo>*</mo></msup></math>被称为与约束相关的*边际成本*，或者*影子价格*。当我们在本章后面讨论对偶性时，我们使用字母*p*表示对偶问题的决策变量，出于*价格*的原因。
- en: Optimization- Infinite dimensions- Calculus of Variations
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化-无限维度-变分法
- en: The field of calculus of variations is an optimization field, but instead of
    searching for optimizing points in finite dimensional spaces, we are searching
    for optimizing *functions* in infinite dimensional spaces.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 变分法领域是一个优化领域，但我们不是在有限维空间中寻找优化点，而是在无限维空间中寻找优化*函数*。
- en: In finite dimensions, the *optimizing point* (or points) satisfies an equation
    based on setting the gradient of the *objective function* equal to zero.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在有限维度中，*优化点*（或点）满足一个基于将*目标函数*的梯度设为零的方程。
- en: In infinite dimensions, the *optimizing function* satisfies a *differential
    equation* based on setting the gradient of the *objective functional* (a functional
    is a function whose input is a function and whose output is a real number, for
    example the integral of a continuous function on the interval [0,1] is a functional)
    equal to zero, that is, if we manage to define the gradient of a *functional*.
    To find the optimizer, we either have to solve the differential equation, or follow
    some optimization scheme. Everything in math ties neatly together.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在无限维度中，*优化函数*满足一个基于将*目标泛函*的梯度（泛函是一个函数，其输入是一个函数，输出是一个实数，例如在区间[0,1]上的连续函数的积分是一个泛函）设为零的*微分方程*，也就是说，如果我们设法定义一个*泛函*的梯度。要找到优化器，我们要么解微分方程，要么遵循一些优化方案。数学中的一切都紧密地联系在一起。
- en: The minimizing *function* satisfies a differential equation called the *Euler
    Lagrange equation*. You can skip the rest of this section if you are not interested
    in PDEs, as it is not essential to operations research.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化的*函数*满足一个称为*欧拉-拉格朗日方程*的微分方程。如果您对偏微分方程不感兴趣，可以跳过本节的其余部分，因为这对运筹学并不重要。
- en: Example 1
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1
- en: 'If you have some familiarity with partial differential equations, this is a
    nice way to think about a harmonic function as the minimizer of an energy functional:
    The minimizer of the Dirichlet energy <math alttext="upper E left-parenthesis
    u left-parenthesis x right-parenthesis right-parenthesis equals integral Underscript
    upper D Endscripts one-half StartAbsoluteValue normal nabla u left-parenthesis
    x right-parenthesis EndAbsoluteValue squared d x"><mrow><mi>E</mi> <mrow><mo>(</mo>
    <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mo>∫</mo> <mi>D</mi></msub> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <msup><mrow><mo>|</mo><mi>∇</mi><mi>u</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>|</mo></mrow>
    <mn>2</mn></msup> <mi>d</mi> <mi>x</mi></mrow></math> where *u(x)* belongs to
    an appropriate function space, and *u(x)=h(x)* on the boundary <math alttext="normal
    partial-differential upper D"><mrow><mi>∂</mi> <mi>D</mi></mrow></math> satisfies
    the Euler Lagrange equation <math alttext="normal upper Delta u equals 0"><mrow><mi>Δ</mi>
    <mi>u</mi> <mo>=</mo> <mn>0</mn></mrow></math> , *u=h(x)* on <math alttext="normal
    partial-differential upper D"><mrow><mi>∂</mi> <mi>D</mi></mrow></math> (so the
    minimizer must be a harmonic function satisfying the given boundary condition).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对偏微分方程有一些了解，这是将谐函数视为能量泛函的最小化器的好方法：狄利克雷能量的最小化器<math alttext="上E左括号u左括号x右括号右括号等于积分下标上D上标一半StartAbsoluteValue正常nabla
    u左括号x右括号EndAbsoluteValue平方d x"><mrow><mi>E</mi> <mrow><mo>(</mo> <mi>u</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mo>∫</mo> <mi>D</mi></msub>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac> <msup><mrow><mo>|</mo><mi>∇</mi><mi>u</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mo>|</mo></mrow>
    <mn>2</mn></msup> <mi>d</mi> <mi>x</mi></mrow></math>，其中*u(x)*属于适当的函数空间，且*u(x)=h(x)*在边界<math
    alttext="正常偏微分上D"><mrow><mi>∂</mi> <mi>D</mi></mrow></math>上满足欧拉-拉格朗日方程<math alttext="正常上三角形u等于0"><mrow><mi>Δ</mi>
    <mi>u</mi> <mo>=</mo> <mn>0</mn></mrow></math>，*u=h(x)*在<math alttext="正常偏微分上D"><mrow><mi>∂</mi>
    <mi>D</mi></mrow></math>上（因此最小化器必须是满足给定边界条件的谐函数）。
- en: 'Moreover, the heat equation <math alttext="u Subscript t Baseline equals normal
    upper Delta u"><mrow><msub><mi>u</mi> <mi>t</mi></msub> <mo>=</mo> <mi>Δ</mi>
    <mi>u</mi></mrow></math> with *u(x,t)=0* on <math alttext="normal partial-differential
    upper D"><mrow><mi>∂</mi> <mi>D</mi></mrow></math> and some initial condition
    *u(x,0)=g(x)* does <math alttext="upper L squared"><msup><mi>L</mi> <mn>2</mn></msup></math>
    -steepest descent of the Dirichlet energy: This means that starting initially
    at <math alttext="u left-parenthesis x comma 0 right-parenthesis equals g left-parenthesis
    x right-parenthesis"><mrow><mi>u</mi> <mo>(</mo> <mi>x</mi> <mo>,</mo> <mn>0</mn>
    <mo>)</mo> <mo>=</mo> <mi>g</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></math>
    , the fastest way to arrive to the minimizer on the Dirichlet energy landscape,
    is through solving the heat equation. Therefore, the heat equation gives an idea
    for a minimizing scheme for the minimization problem:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，热方程<math alttext="u下标t基线等于正常上三角形u"><mrow><msub><mi>u</mi> <mi>t</mi></msub>
    <mo>=</mo> <mi>Δ</mi> <mi>u</mi></mrow></math>，其中*u(x,t)=0*在<math alttext="正常偏微分上D"><mrow><mi>∂</mi>
    <mi>D</mi></mrow></math>上，一些初始条件*u(x,0)=g(x)*进行<math alttext="上L平方"><msup><mi>L</mi>
    <mn>2</mn></msup></math> -最陡下降的狄利克雷能量：这意味着最初从<math alttext="u左括号x逗号0右括号等于g左括号x右括号"><mrow><mi>u</mi>
    <mo>(</mo> <mi>x</mi> <mo>,</mo> <mn>0</mn> <mo>)</mo> <mo>=</mo> <mi>g</mi> <mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow></math>开始，到达狄利克雷能量景观上的最小化器的最快方式是通过解决热方程。因此，热方程为最小化问题提供了一个最小化方案的想法：
- en: <math alttext="dollar-sign min Underscript u equals 0 on normal partial-differential
    upper D Endscripts one-half integral Underscript upper D Endscripts StartAbsoluteValue
    normal nabla u left-parenthesis x comma t right-parenthesis EndAbsoluteValue squared
    d x period dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo>
    <mrow><mi>u</mi><mo>=</mo><mn>0</mn><mtext>on</mtext><mi>∂</mi><mi>D</mi></mrow></msub>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac> <msub><mo>∫</mo> <mi>D</mi></msub> <msup><mrow><mo>|</mo><mi>∇</mi><mi>u</mi><mrow><mo>(</mo><mi>x</mi><mo>,</mo><mi>t</mi><mo>)</mo></mrow><mo>|</mo></mrow>
    <mn>2</mn></msup> <mi>d</mi> <mi>x</mi> <mo>.</mo></mrow></math>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript u equals 0 on normal partial-differential
    upper D Endscripts one-half integral Underscript upper D Endscripts StartAbsoluteValue
    normal nabla u left-parenthesis x comma t right-parenthesis EndAbsoluteValue squared
    d x period dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo>
    <mrow><mi>u</mi><mo>=</mo><mn>0</mn><mtext>on</mtext><mi>∂</mi><mi>D</mi></mrow></msub>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac> <msub><mo>∫</mo> <mi>D</mi></msub> <msup><mrow><mo>|</mo><mi>∇</mi><mi>u</mi><mrow><mo>(</mo><mi>x</mi><mo>,</mo><mi>t</mi><mo>)</mo></mrow><mo>|</mo></mrow>
    <mn>2</mn></msup> <mi>d</mi> <mi>x</mi> <mo>.</mo></mrow></math>
- en: Example 2
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例2
- en: The shortest path between two points in <math alttext="double-struck upper R
    squared"><msup><mi>ℝ</mi> <mn>2</mn></msup></math> is a straight line. To do this,
    we minimize the arc length of the curve connecting two points <math alttext="left-parenthesis
    x 1 comma y 1 right-parenthesis"><mrow><mo>(</mo> <msub><mi>x</mi> <mn>1</mn></msub>
    <mo>,</mo> <msub><mi>y</mi> <mn>1</mn></msub> <mo>)</mo></mrow></math> and <math
    alttext="left-parenthesis x 2 comma y 2 right-parenthesis"><mrow><mo>(</mo> <msub><mi>x</mi>
    <mn>2</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>2</mn></msub> <mo>)</mo></mrow></math>
    , namely,
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在<math alttext="双击上R平方"><msup><mi>ℝ</mi> <mn>2</mn></msup></math>中两点之间的最短路径是一条直线。为了做到这一点，我们最小化连接两点<math
    alttext="左括号x 1逗号y 1右括号"><mrow><mo>(</mo> <msub><mi>x</mi> <mn>1</mn></msub> <mo>,</mo>
    <msub><mi>y</mi> <mn>1</mn></msub> <mo>)</mo></mrow></math>和<math alttext="左括号x
    2逗号y 2右括号"><mrow><mo>(</mo> <msub><mi>x</mi> <mn>2</mn></msub> <mo>,</mo> <msub><mi>y</mi>
    <mn>2</mn></msub> <mo>)</mo></mrow></math>的曲线的弧长，即，
- en: <math alttext="dollar-sign min Underscript y left-parenthesis x 1 right-parenthesis
    equals y 1 and y left-parenthesis x 2 right-parenthesis equals y 2 Endscripts
    integral Subscript x 1 Superscript x 2 Baseline StartRoot 1 plus y prime left-parenthesis
    x right-parenthesis squared EndRoot d x period dollar-sign"><mrow><msub><mo form="prefix"
    movablelimits="true">min</mo> <mrow><mi>y</mi><mrow><mo>(</mo><msub><mi>x</mi>
    <mn>1</mn></msub> <mo>)</mo></mrow><mo>=</mo><msub><mi>y</mi> <mn>1</mn></msub>
    <mtext>and</mtext><mi>y</mi><mrow><mo>(</mo><msub><mi>x</mi> <mn>2</mn></msub>
    <mo>)</mo></mrow><mo>=</mo><msub><mi>y</mi> <mn>2</mn></msub></mrow></msub> <msubsup><mo>∫</mo>
    <mrow><msub><mi>x</mi> <mn>1</mn></msub></mrow> <msub><mi>x</mi> <mn>2</mn></msub></msubsup>
    <msqrt><mrow><mn>1</mn> <mo>+</mo> <msup><mi>y</mi> <mo>'</mo></msup> <msup><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mn>2</mn></msup></mrow></msqrt> <mi>d</mi> <mi>x</mi> <mo>.</mo></mrow></math>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript y left-parenthesis x 1 right-parenthesis
    equals y 1 and y left-parenthesis x 2 right-parenthesis equals y 2 Endscripts
    integral Subscript x 1 Superscript x 2 Baseline StartRoot 1 plus y prime left-parenthesis
    x right-parenthesis squared EndRoot d x period dollar-sign"><mrow><msub><mo form="prefix"
    movablelimits="true">min</mo> <mrow><mi>y</mi><mrow><mo>(</mo><msub><mi>x</mi>
    <mn>1</mn></msub> <mo>)</mo></mrow><mo>=</mo><msub><mi>y</mi> <mn>1</mn></msub>
    <mtext>and</mtext><mi>y</mi><mrow><mo>(</mo><msub><mi>x</mi> <mn>2</mn></msub>
    <mo>)</mo></mrow><mo>=</mo><msub><mi>y</mi> <mn>2</mn></msub></mrow></msub> <msubsup><mo>∫</mo>
    <mrow><msub><mi>x</mi> <mn>1</mn></msub></mrow> <msub><mi>x</mi> <mn>2</mn></msub></msubsup>
    <msqrt><mrow><mn>1</mn> <mo>+</mo> <msup><mi>y</mi> <mo>'</mo></msup> <msup><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
    <mn>2</mn></msup></mrow></msqrt> <mi>d</mi> <mi>x</mi> <mo>.</mo></mrow></math>
- en: We then write the Euler-Lagrange equation, leading to the minimizing funtion
    *y(x)=mx+b*, where *m* and *b* are respectively the slope and the *y*-intercept
    of the straight line connecting the two given points.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们写出欧拉-拉格朗日方程，导致最小化函数*y(x)=mx+b*，其中*m*和*b*分别是连接两个给定点的直线的斜率和*y*-截距。
- en: Other introductory examples to calculus of variations
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 变分微积分的其他入门示例
- en: The minimal surface problem and the isoperimetric problems are other examples
    which we can solve using an appropriate variational principle.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最小曲面问题和等周问题是我们可以使用适当的变分原理解决的其他示例。
- en: Optimization On Networks
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络上的优化
- en: I wanted to start with optimization on networks *before* the simplex method
    for linear optimization because more people are used to thinking in terms of algebraic
    forms (equations and functions) than in terms of graph or network structures,
    despite the abundance of network structures in nature and operations rersearch
    applications. We need to become very comfortable with graph models. Optimization
    problems on network structures tend to be combinatorial in nature <math alttext="upper
    O left-parenthesis n factorial right-parenthesis"><mrow><mi>O</mi> <mo>(</mo>
    <mi>n</mi> <mo>!</mo> <mo>)</mo></mrow></math> , which is *no bueno*, so we need
    algorithms that somehow circumvent this and efficiently sift through the search
    space (remember the order of a problem is usually a worst case scenario, and in
    worst cases we suffice ourselves with approximate solutions).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在线性优化的单纯形法之前从网络优化开始，因为更多的人习惯于以代数形式（方程和函数）思考，而不是以图形或网络结构的形式，尽管自然界和运营研究应用中有大量的网络结构。我们需要对图模型非常熟悉。网络结构上的优化问题往往是组合性质的<math
    alttext="上O左括号n阶乘右括号"><mrow><mi>O</mi> <mo>(</mo> <mi>n</mi> <mo>!</mo> <mo>)</mo></mrow></math>
    ，这是*不好的*，因此我们需要一些算法来规避这一点，并有效地筛选搜索空间（请记住问题的顺序通常是最坏情况，而在最坏情况下，我们满足于近似解决方案）。
- en: We discuss typical network problems, which happen to capture a wide variety
    of real life applications. The traveling salesman problem is one of the oldest
    and most famous so we start there. We live in an age where we have open source
    software packages and cloud computing resources that include powerful algorithms
    for solving all the problems mentioned in this chapter, so in this section we
    focus on understanding the type of the network problem and its applications instead
    of the algorithms devised to solve them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论典型的网络问题，这些问题恰好涵盖了各种各样的现实生活应用。旅行推销员问题是最古老和最著名的问题之一，因此我们从那里开始。我们生活在一个有开源软件包和云计算资源的时代，其中包括用于解决本章中提到的所有问题的强大算法，因此在本节中，我们专注于理解网络问题的类型及其应用，而不是为解决这些问题而设计的算法。
- en: Traveling Salesman Problem
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旅行推销员问题
- en: 'This is one famous problem in operations research that fits into many real
    world situations: A salesman is required to visit a number of cities during a
    trip. Given the distances between the cities, in what order should he travel so
    as to visit every city precisely once and return home, with the objective of keeping
    the distance traveled at a minimum ([Figure 10-1](#Fig_traveling_salesman))?'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运筹学中的一个著名问题，适用于许多现实世界的情况：一个推销员在旅途中需要访问多个城市。给定城市之间的距离，他应该以什么顺序旅行，以便精确地访问每个城市一次并返回家中，目标是保持旅行距离最小（[图10-1](#Fig_traveling_salesman)）？
- en: '![280](assets/emai_1001.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![280](assets/emai_1001.png)'
- en: Figure 10-1\. Traveling salesman problem ([*image source*](https://xkcd.com/399/))
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-1。旅行推销员问题（[*图片来源*](https://xkcd.com/399/))
- en: 'Applications are numerous: A delivery truck leaving a warehouse and must deliver
    packages to every address, in the least costly way (measured by time or distance);
    finding the most efficient hole sequence to drill on a printed ciruit board during
    manufacturing electronic chips.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 应用非常广泛：一辆离开仓库的送货卡车必须以最经济的方式（以时间或距离衡量）将包裹送到每个地址；在制造电子芯片时找到最有效的孔序列来钻孔印刷电路板。
- en: 'We represent the traveling saleman problem as an optimization problem on a
    graph: The cities are the nodes, there are edges between each pair of cities (making
    the graph complete), and each edge has a weight (or attribute or feature) representing
    the distance between the two cities. This graph has many paths passing through
    all the cities only once and returning to the one we started with (a *Hamiltonian
    circuit*), but we want the one with the smallest sum of distances.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将旅行推销员问题表示为图上的优化问题：城市是节点，每对城市之间有边（使图完全），每条边都有一个权重（或属性或特征），表示两个城市之间的距离。这个图有许多路径通过所有城市仅一次并返回到我们开始的那个城市（一个*哈密顿回路*），但我们希望找到总距离最小的路径。
- en: 'Let’s think of the complexity of this problem: The total number of different
    Hamiltonian circuits in a complete graph of n nodes is (n−1)!/2: Starting at any
    node we have n-1 edges to choose from to pick the next city to visit, then n−2
    options from the second city, n−3 from the third city, and so on. These choices
    are independent, so we have a total of (n−1)! choices. We must divide by 2 to
    account for symmetry, in the sense that we can traverse the same Hamiltonian circuit
    forward or backward and still get the exact same total distance traveled. This
    counting problem is a circular permutation with symmetry. An exhaustive solution
    of the traveling salesman would list all (n−1)!/2 Hamiltonian circuits, adding
    up the distance traveled in each, then choosing the one with the shortest distance.
    Even for a reasonable value of n, it is too expensive: To visit all 50 US state
    capitals (say we want to minimize total trip cost), we would need to try <math
    alttext="left-parenthesis 50 minus 1 right-parenthesis factorial slash 2 equals
    3.04 times 10 Superscript 6 Baseline 2"><mrow><mrow><mo>(</mo> <mn>50</mn> <mo>-</mo>
    <mn>1</mn> <mo>)</mo></mrow> <mo>!</mo> <mo>/</mo> <mn>2</mn> <mo>=</mo> <mn>3</mn>
    <mo>.</mo> <mn>04</mn> <mo>×</mo> <msup><mn>10</mn> <mn>6</mn></msup> <mn>2</mn></mrow></math>
    options! We do not have an efficient algorithm for problems of arbitrary size.
    Heuristic methods are able to provide excellent approximate solutions. Moreover,
    great algorithms based on an approach called *branch and cut* have solved this
    problem to optimality for very large number of cities.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来思考这个问题的复杂性：在一个完全图中，n个节点有(n−1)!/2个不同的哈密顿回路：从任何一个节点开始，我们有n-1条边可供选择，选择下一个要访问的城市，然后从第二个城市有n−2个选项，第三个城市有n−3个选项，依此类推。这些选择是独立的，所以我们总共有(n−1)!种选择。我们必须除以2来考虑对称性，也就是说我们可以沿着相同的哈密顿回路前进或后退，仍然得到完全相同的总行程。这个计数问题是一个具有对称性的循环排列。旅行推销员的详尽解决方案将列出所有(n−1)!/2个哈密顿回路，计算每个回路中的行程总距离，然后选择最短距离的那个。即使对于一个合理的n值，这也是太昂贵的：要访问所有50个美国州首府（假设我们想要最小化总旅行成本），我们需要尝试<math
    alttext="left-parenthesis 50 minus 1 right-parenthesis factorial slash 2 equals
    3.04 times 10 Superscript 6 Baseline 2"><mrow><mrow><mo>(</mo> <mn>50</mn> <mo>-</mo>
    <mn>1</mn> <mo>)</mo></mrow> <mo>!</mo> <mo>/</mo> <mn>2</mn> <mo>=</mo> <mn>3</mn>
    <mo>.</mo> <mn>04</mn> <mo>×</mo> <msup><mn>10</mn> <mn>6</mn></msup> <mn>2</mn></mrow></math>
    个选项！我们没有一个有效的算法来解决任意规模的问题。启发式方法能够提供出色的近似解。此外，基于一种称为*分支和剪枝*的方法的优秀算法已经为非常大数量的城市解决了这个问题。
- en: Minimum Spanning Tree
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小生成树
- en: I put the minimum spanning tree problem right after the traveling salesman because
    sometimes people confuse the two. This is a good place to clear the confusion.
    Here, we have a fully connected network with positive weights associated with
    each edge, which again can represent distance, time, capacity, or cost of connecting
    infrastrcuture such as water, electric, or phone lines. Similar to the traveling
    salesman, we want to find the set of edges that includes all the nodes of the
    graph and minimizes the total weight. The requirement here that is different than
    the traveling salesman is that we want to make sure we choose the set of edges
    in a way provides a path between any two pairs of nodes, meaning we can reach
    any node in the graph from any other node. In the traveling salesman, we need
    to visit every city only once then return to the starting city, which means that
    each node cannot get more than two edges (no such requirement for a spanning tree).
    The fact that we return to the last city in the traveling salesman means that
    we have an extra circuit closing edge in traveling salesman that we do not need
    for spanning trees. If we remove that last edge of a traveling salesman solution,
    then we definitely get a spanning tree, however there is no guarantee that it
    is the one with minimal cost. [Figure 10-2](#Fig_TS_MS) shows Minimum spanning
    tree and traveling salesman solutions of the same graph.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我将最小生成树问题放在旅行推销员问题之后，因为有时人们会混淆这两个问题。这是一个澄清混淆的好地方。在这里，我们有一个完全连接的网络，每条边上都有正权重，这些权重可以代表距离、时间、容量或连接基础设施（如水、电或电话线）的成本。与旅行推销员类似，我们希望找到包含图中所有节点并最小化总权重的边的集合。这里与旅行推销员不同的要求是，我们希望确保以一种方式选择边的集合，使得任意两个节点之间都有路径，也就是说我们可以从图中的任何一个节点到达任何其他节点。在旅行推销员中，我们只需要访问每个城市一次然后返回到起始城市，这意味着每个节点不能有超过两条边（对于生成树没有这样的要求）。在旅行推销员中返回到最后一个城市的事实意味着我们有一个额外的闭合边，这在生成树中是不需要的。如果我们移除旅行推销员解决方案的最后一条边，那么我们肯定会得到一个生成树，但不能保证它是成本最小的。[图10-2](#Fig_TS_MS)展示了相同图的最小生成树和旅行推销员解决方案。
- en: '![280](assets/emai_1002.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![280](assets/emai_1002.png)'
- en: Figure 10-2\. Minimum spanning tree and traveling salesman solutions of the
    same graph
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-2. 相同图的最小生成树和旅行推销员解决方案
- en: Note that for any network, if we have n nodes then we only need n-1 edges so
    that we have a path between every two nodes, so we should never use more than
    n-1 edges for a minimal spanning tree because that would increase our cost. We
    need to choose the set of edges that minimizes the cost.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于任何网络，如果我们有n个节点，那么我们只需要n-1条边，这样我们就可以在每两个节点之间有一条路径，因此我们不应该使用超过n-1条边来构建最小生成树，因为那会增加我们的成本。我们需要选择最小化成本的边的集合。
- en: We have already mentioned some applications, such as designing telecommunication
    networks, routing and transportation networks, electric networks, and infrastructure
    networks (pipelines). These networks are so expensive to develop and designing
    them optimally saves millions of dollars.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了一些应用，比如设计电信网络、路由和运输网络、电网和基础设施网络（管道）。这些网络的开发非常昂贵，通过最佳设计可以节省数百万美元。
- en: Shortest Path
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最短路径
- en: The simplest version of the shortest path problem is that we have two nodes
    on a graph and we want to connect them with a set of edges so that the total sum
    of the edge weights (distance, time) is minimal. This is different than the traveling
    salesman and the minimal spanning tree problems because we don’t care about covering
    all the nodes of the graph. All we care for is getting ourselves from the origin
    to the destination in the least costly way.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的最短路径问题版本是，我们在图上有两个节点，我们想要用一组边连接它们，使得边权重（距离、时间）的总和最小。这与旅行推销员和最小生成树问题不同，因为我们不关心覆盖图的所有节点。我们只关心以最经济的方式将自己从起点送到终点。
- en: One obvious application is travel from one destination to another with minimal
    distance, cost, time, *etc.*. Other applications which are not immediately obvious
    but nevertheless are ultra important are activity networks. Instead of an origin
    and a destination we might have a beginning of a project and an end. Each node
    represents an activity and each edge weight represents the cost or the time incurred
    if activity i is adjacent to activity j (if we have a directed graph, then it
    would be the cost or time incurred if activity i happens after activity j). The
    goal is to choose the sequence of activities that minimize the total cost.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的应用是以最小距离、成本、时间等从一个目的地到另一个目的地旅行。其他应用虽然不是立即显而易见，但却非常重要的是活动网络。我们可能没有起点和终点，而是有一个项目的开始和结束。每个节点代表一个活动，每个边的权重代表如果活动i邻接活动j时所产生的成本或时间（如果我们有一个有向图，那么它将是活动i在活动j之后发生时所产生的成本或时间）。目标是选择最小化总成本的活动顺序。
- en: 'Othe versions of the shortest path problem include: Find the shortest path
    from an origin to *all other nodes*. Others include finding the shortest paths
    between *all pairs of nodes*.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最短路径问题的其他版本包括：找到从起点到*所有其他节点*的最短路径。其他包括找到*所有节点对*之间的最短路径。
- en: Many vehicle routing algorithms and network design algorithms include shortest
    path algorithms as subroutines.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 许多车辆路径规划算法和网络设计算法包括最短路径算法作为子程序。
- en: We can also formulate the shortest path problem as a linear optimization problem
    and use the methods available for linear optimization.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将最短路径问题重新表述为线性优化问题，并使用线性优化的方法。
- en: Max Flow Min Cut
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最大流最小割
- en: Here we also have an origin and a destination, each *directed* edge has a capacity
    of some sort (max number of vehicles allowed on a route, max number of commodities
    shipped on a route, max amount of material or natural resource such as oil or
    water that a pipeline can handle) and we want to find the set the edges that maximizes
    the *flow* from the origin to the destination. Note that all edges point away
    from the origin and point towards the destination.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还有一个起点和一个终点，每个*有向*边都有某种容量（路线上允许的车辆最大数量，路线上运输的商品最大数量，管道可以处理的最大材料或自然资源量，如石油或水），我们希望找到一组边，使得从起点到终点的*流*最大化。请注意，所有边都指向远离起点的方向，并指向终点。
- en: 'A very important theorem from graph theory plays a crucial role in determining
    the optimality (max flow) of a set of edges connecting the origin to the destination:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图论中一个非常重要的定理在确定连接起点和终点的一组边的最优性（最大流）中起着关键作用：
- en: '**Max flow min cut theorem**: This theorem says the maximum flow from the origin
    to the destination through the directed network is equal to the minimal sum of
    weights of the edges required to cut any communication between the origin and
    the destination. That is, we can cut through the network to prevent communication
    between the origin and the destination in more than one way. The set of edges
    that cuts communication *and* has the least weight is the minimal cut set. The
    value of this minimal cut set is equal to the value of the maximum flow possible
    in the network. This result is pretty intuitive: What’s the most that we can send
    through the edges of the network? This is bounded from above by the capacities
    of the edges crucial for connecting the origin to the destination.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大流最小割定理**：该定理指出，通过有向网络从起点到终点的最大流量等于所需的最小边权重之和，以切断起点和终点之间任何通信。也就是说，我们可以通过网络切断通信，以防止起点和终点之间的通信，有多种方式。切断通信*并且*具有最小权重的边集是最小割集。这个最小割集的值等于网络中可能的最大流量的值。这个结果非常直观：我们可以通过网络的边发送的最大量是多少？这受到连接起点和终点的关键边的容量的上限约束。'
- en: We can reformulate the max flow problem as a linear optimization problem, and
    of course, the min cut problem will be its dual, so of course they have the same
    solution! We will see this soon in this chapter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将最大流问题重新表述为线性优化问题，当然，最小割问题将是其对偶问题，因此它们当然有相同的解！我们将在本章很快看到这一点。
- en: Finally, suppose we have more than one origin and more than one destination,
    similar to a distribution network, then we can still maximize the flow through
    the network by solving the exact same problem, except now we add a fictional *super
    origin* pointing to all the real origins, and another fictional *super destination*
    that all the real destinations point towards, with infinite capacities, then do
    business as usual, solving for the max flow on this new graph with two new fictional
    *super nodes*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，假设我们有多个起点和多个终点，类似于一个分布网络，那么我们仍然可以通过解决完全相同的问题来最大化网络中的流量，只是现在我们添加一个虚构的*超级起点*指向所有真实起点，另一个虚构的*超级终点*，所有真实终点指向它，具有无限容量，然后像往常一样进行业务，解决这个新图上的最大流问题，其中有两个新虚构的*超级节点*。
- en: Max Flow Min Cost
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最大流最小成本
- en: 'This is similar to the max flow problem, except that now we have a cost associated
    with sending a flow through each edge proportional to the number of units of flow.
    The goal is obviously to minimize the cost while satisfying the supply from all
    the origins to all the destinations. We can formulate this problem as a linear
    optimization problem and solve it using a simplex method optimized for networks.
    Applications are ubiquous and so important: All kinds of distribution networks,
    with supply nodes, transshipment nodes, and demand nodes, supply chains (of goods,
    blood, nuclear materials, food), solid waste management networks, coordinating
    the types of products to produce or to spend resources inorder to satisfy the
    market, cash flow management, assignment problems, such as assigning employees
    to tasks, time slots to tasks, or job applicants to available jobs.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于最大流问题，不同之处在于现在我们将每条边发送流量的成本与流量单位数成比例地关联起来。目标显然是在满足所有起点到所有终点的供给的同时最小化成本。我们可以将这个问题表述为一个线性优化问题，并使用针对网络优化的单纯形法来解决它。应用广泛且非常重要：各种分配网络，包括供给节点、中转节点和需求节点，供应链（货物、血液、核材料、食品），固体废物管理网络，协调生产产品的类型或花费资源以满足市场需求，现金流管理，分配问题，如将员工分配到任务、时间段分配到任务或将求职者分配到可用工作岗位。
- en: The assignment problem
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配问题
- en: The assignment problem is also called the matching problem. The number of assignees
    should be the same as the number of tasks and each can be assigned only one tasks,
    and each task can be performed by only one assignee. There is a cost to assigning
    task i to assignee j. The objective is to choose the matching between tasks and
    assignees that minimizes the total cost. The graph of such a problem is a special
    type of graph called bipartite graph. Such a graph can be divided into two parts,
    where all the edges go from one node in the first part to one node in the second
    part. An assignment problem where all the weights are the same is a max flow problem
    on a bipartite graph. All we have to do is assign a fictional super origin and
    another fictional super destination and solve the problem the same way we solve
    the max flow problem in the upcoming section on linear optimization and duality.
    There are many efficient algorithms for these problems.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 分配问题也称为匹配问题。受让人的数量应与任务数量相同，每个受让人只能分配一个任务，每个任务只能由一个受让人执行。将任务i分配给受让人j会产生成本。目标是选择任务和受让人之间的匹配，以最小化总成本。这种问题的图是一种特殊类型的图，称为二部图。这样的图可以分为两部分，所有边都从第一部分的一个节点指向第二部分的一个节点。在所有权重相同的分配问题中，这是一个二部图上的最大流问题。我们所要做的就是分配一个虚拟的超级起点和另一个虚拟的超级终点，并以解决最大流问题的方式解决这个问题，即在即将介绍的线性优化和对偶性部分中解决最大流问题。对于这些问题有许多高效的算法。
- en: The Critical Path Method (CPM) for Project Design
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目设计的关键路径法（CPM）
- en: 'The critical path method is an optimization method on a network representing
    all the involved activities in a project, the total budget, the total time constraint,
    which ones need to happen before others, how much time and cost each activity
    incurs, and which activities can happen simultaneously. Think for example of a
    house construction project, from start to finish. The critical path method for
    time and cost tradeoffs is a great tool to aid in designing a project that incorporates
    tradeoffs between time and cost, makes sure the project meets its deadlines at
    a minimal total cost. Similar to the critical path method is the Program Evaluation
    Review Technique (PERT) which is a project management planning tool which computes
    the amount of time it will take to complete a project. The methods provides three
    timelines: A shortest possible timeline, a longest possible timeline, and a most
    probable timeline.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 关键路径法是一种优化方法，用于表示项目中涉及的所有活动、总预算、总时间限制，哪些活动需要在其他活动之前发生，每个活动需要多少时间和成本，以及哪些活动可以同时进行的网络。例如，考虑一个从开始到结束的房屋建设项目。关键路径法用于时间和成本的权衡是一个很好的工具，有助于设计一个项目，其中包含时间和成本之间的权衡，确保项目以最小总成本满足其截止日期。类似于关键路径法的是项目评估审查技术（PERT），它是一种项目管理规划工具，用于计算完成项目所需的时间。该方法提供三个时间表：最短可能的时间表、最长可能的时间表和最有可能的时间表。
- en: The n-Queens Problem
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: n皇后问题
- en: 'Before moving on to linear optimization, the simplex method, and duality, we
    make a tiny detour and mention an interesting combinatorial problem that has puzzled
    mathematicians for 150 years, mainly because its utter lack of structure: The
    n-queens problem, such as the one in [Figure 10-3](#Fig_n_queens). Michael Simkin
    [has finally (July 2021) answered the 150-year-old chess-based n-queens problem](https://www.quantamagazine.org/mathematician-answers-chess-problem-about-attacking-queens-20210921/).
    Here is an edited part of the abstract of his solution paper titled [*The Number
    of n-Queens Configurations*](https://arxiv.org/abs/2107.13460): *The n-queens
    problem is to determine the number of ways to place n mutually nonthreatening
    queens on an <math alttext="n times n"><mrow><mi>n</mi> <mo>×</mo> <mi>n</mi></mrow></math>
    [chess] board. We show that there exists a constant <math alttext="alpha equals
    1.942 plus-or-minus 3 times 10 Superscript negative 3"><mrow><mi>α</mi> <mo>=</mo>
    <mn>1</mn> <mo>.</mo> <mn>942</mn> <mo>±</mo> <mn>3</mn> <mo>×</mo> <msup><mn>10</mn>
    <mrow><mo>-</mo><mn>3</mn></mrow></msup></mrow></math> such that [the number of
    ways to place the mutually nonthreatening queens on the board is] <math alttext="left-parenthesis
    1 plus-or-minus o left-parenthesis 1 right-parenthesis n e Superscript negative
    alpha Baseline right-parenthesis Superscript n Baseline left-parenthesis left-parenthesis
    1 plus-or-minus o left-parenthesis 1 right-parenthesis right-parenthesis n e Superscript
    negative alpha Baseline right-parenthesis Superscript n"><mrow><msup><mrow><mo>(</mo><mn>1</mn><mo>±</mo><mi>o</mi><mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow><mi>n</mi><msup><mi>e</mi>
    <mrow><mo>-</mo><mi>α</mi></mrow></msup> <mo>)</mo></mrow> <mi>n</mi></msup> <msup><mrow><mo>(</mo><mrow><mo>(</mo><mn>1</mn><mo>±</mo><mi>o</mi><mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow><mo>)</mo></mrow><mi>n</mi><msup><mi>e</mi>
    <mrow><mo>-</mo><mi>α</mi></mrow></msup> <mo>)</mo></mrow> <mi>n</mi></msup></mrow></math>
    . The constant α is characterized as the solution to a convex optimization problem
    in P([−1/2,1/2] <math alttext="squared right-parenthesis"><mrow><msup><mn>2</mn></msup>
    <mrow><mo>)</mo></mrow></mrow></math> , the space of Borel probability measures
    on the square.*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续线性优化、单纯形法和对偶之前，我们先稍微绕个弯，提到一个有趣的组合问题，这个问题困扰数学家已经150年了，主要是因为它完全没有结构：n皇后问题，比如[图10-3](#Fig_n_queens)中的那个。迈克尔·西姆金[终于（2021年7月）回答了这个有关攻击皇后的150年历史的国际象棋问题](https://www.quantamagazine.org/mathematician-answers-chess-problem-about-attacking-queens-20210921/)。以下是他解决方案论文的摘要的编辑部分，标题为[*n-皇后配置的数量*](https://arxiv.org/abs/2107.13460)：*n皇后问题是确定如何在一个n×n的[国际象棋]棋盘上放置n个互不威胁的皇后的方式的数量。我们证明存在一个常数α=1.942±3×10^-3，使得[在棋盘上放置互不威胁的皇后的方式的数量为]（1±o(1)n
    e^-αn）n（（1±o(1)n e^-αn）n）。常数α被描述为P（[-1/2,1/2]的Borel概率测度空间中一个凸优化问题的解。*
- en: '![300](assets/emai_1003.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![300](assets/emai_1003.png)'
- en: Figure 10-3\. 8 queens in mutually nonthreatening positions on an 8 by 8 chess
    board.
  id: totrans-141
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-3。8个皇后在一个8×8的国际象棋棋盘上互不威胁的位置。
- en: The following [page](https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/)
    has an easy *backtracking* algorithm for solving the n-queens problem. Note that
    the solution by Simkin quantifies the total number of viable queen configurations,
    while algorithms only find one or some of these configurations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下[页面](https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/)有一个简单的*回溯*算法来解决n皇后问题。请注意，西姆金的解决方案量化了可行皇后配置的总数，而算法只能找到其中一个或一些配置。
- en: Linear Optimization
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性优化
- en: 'Any optimization problem in finite dimensions, whether linear or nonlinear,
    looks like:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有限维度中的任何优化问题，无论是线性还是非线性，看起来都像：
- en: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column g 1 left-parenthesis ModifyingAbove x With right-arrow right-parenthesis
    less-than-or-equal-to 0 2nd Row 1st Column Blank 2nd Column g 2 left-parenthesis
    ModifyingAbove x With right-arrow right-parenthesis less-than-or-equal-to 0 3rd
    Row 1st Column Blank 2nd Column  ellipsis 4th Row 1st Column Blank 2nd Column
    g Subscript m Baseline left-parenthesis ModifyingAbove x With right-arrow right-parenthesis
    less-than-or-equal-to 0 EndLayout Endscripts f left-parenthesis ModifyingAbove
    x With right-arrow right-parenthesis period dollar-sign"><mrow><msub><mo form="prefix"
    movablelimits="true">min</mo> <mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><msub><mi>g</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo><mover accent="true"><mi>x</mi> <mo>→</mo></mover><mo>)</mo></mrow><mo>≤</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd
    columnalign="left"><mrow><msub><mi>g</mi> <mn>2</mn></msub> <mrow><mo>(</mo><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>)</mo></mrow><mo>≤</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd
    columnalign="left"><mo>⋯</mo></mtd></mtr><mtr><mtd columnalign="left"><mrow><msub><mi>g</mi>
    <mi>m</mi></msub> <mrow><mo>(</mo><mover accent="true"><mi>x</mi> <mo>→</mo></mover><mo>)</mo></mrow><mo>≤</mo><mn>0</mn></mrow></mtd></mtr></mtable></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mo>.</mo></mrow></math>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column g 1 left-parenthesis ModifyingAbove x With right-arrow right-parenthesis
    less-than-or-equal-to 0 2nd Row 1st Column Blank 2nd Column g 2 left-parenthesis
    ModifyingAbove x With right-arrow right-parenthesis less-than-or-equal-to 0 3rd
    Row 1st Column Blank 2nd Column  ellipsis 4th Row 1st Column Blank 2nd Column
    g Subscript m Baseline left-parenthesis ModifyingAbove x With right-arrow right-parenthesis
    less-than-or-equal-to 0 EndLayout Endscripts f left-parenthesis ModifyingAbove
    x With right-arrow right-parenthesis period dollar-sign"><mrow><msub><mo form="prefix"
    movablelimits="true">min</mo> <mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><msub><mi>g</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo><mover accent="true"><mi>x</mi> <mo>→</mo></mover><mo>)</mo></mrow><mo>≤</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd
    columnalign="left"><mrow><msub><mi>g</mi> <mn>2</mn></msub> <mrow><mo>(</mo><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>)</mo></mrow><mo>≤</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd
    columnalign="left"><mo>⋯</mo></mtd></mtr><mtr><mtd columnalign="left"><mrow><msub><mi>g</mi>
    <mi>m</mi></msub> <mrow><mo>(</mo><mover accent="true"><mi>x</mi> <mo>→</mo></mover><mo>)</mo></mrow><mo>≤</mo><mn>0</mn></mrow></mtd></mtr></mtable></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mo>.</mo></mrow></math>
- en: 'We have the following cases:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下情况：
- en: 'There exists a unique optimal solution: Think that the basin has one lowest
    point.'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在一个唯一的最优解：认为盆地有一个最低点。
- en: 'There exist multiple optimal solutions: In this case the set of optimal solutions
    can be bounded or unbounded.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在多个最优解：在这种情况下，最优解集可以是有界的或无界的。
- en: 'The optimal cost goes to <math alttext="negative normal infinity"><mrow><mo>-</mo>
    <mi>∞</mi></mrow></math> , and no feasible solution is optimal: The landscape
    of the objective function goes downhill indefinitely.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最优成本趋于负无穷大，没有可行解是最优的：目标函数的景观无限下降。
- en: 'The feasible set is empty and the minimization problem has no solution: No
    one cares about the objective function and its low values here, since there are
    no points that satisfy all the constraints at the same time!'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可行集为空，最小化问题没有解：这里没有人关心目标函数及其低值，因为没有同时满足所有约束的点！
- en: 'The optimal cost is finite but not attained: there is no optimizer even when
    the feasible set is nonempty. For example <math alttext="inf Underscript x greater-than-or-equal-to
    0 Endscripts StartFraction 1 Over x EndFraction"><mrow><msub><mo form="prefix"
    movablelimits="true">inf</mo> <mrow><mi>x</mi><mo>≥</mo><mn>0</mn></mrow></msub>
    <mfrac><mn>1</mn> <mi>x</mi></mfrac></mrow></math> is equal to zero but there
    is no finite *x* such that 1/*x*=0\. This never happens for linear problems.'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最优成本是有限的但不可达到：即使可行集非空，也没有优化器。例如inf x≥0 1/x等于零，但没有有限的x使得1/x=0。这种情况在线性问题中永远不会发生。
- en: For an optimization problem to be linear, the objective function *f* and all
    the constraints *g* must be linear functions. Linear optimization gets a lion’s
    share in operations research, since we can model many operations research problems
    as a minimization of a linear function with linear constraints, that could be
    equalities or inequalities.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要使优化问题是线性的，目标函数*f*和所有约束*g*必须是线性函数。线性优化在运筹学中占据很大比重，因为我们可以将许多运筹学问题建模为线性约束下线性函数的最小化，这些约束可以是相等关系或不等式。
- en: 'Linearity is such a great thing. We can express any linear optimization problem
    using linear algebra language (vectors and matrices), and there are two forms
    that people usually work with:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 线性是一件很好的事情。我们可以用线性代数语言（向量和矩阵）来表达任何线性优化问题，人们通常使用两种形式：
- en: '*The general form*: This is convenient for developing the theory of linear
    programming. There is no restriction on the signs of the entries of the vector
    <math alttext="ModifyingAbove x With right-arrow"><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover></math> , the decision variables:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*一般形式*：这对于发展线性规划理论很方便。向量<math alttext="ModifyingAbove x With right-arrow"><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover></math>的条目的符号没有限制，决策变量：'
- en: <math alttext="dollar-sign min Underscript upper A ModifyingAbove x With right-arrow
    greater-than-or-equal-to ModifyingAbove b With right-arrow Endscripts ModifyingAbove
    c With right-arrow period ModifyingAbove x With right-arrow dollar-sign"><mrow><msub><mo
    form="prefix" movablelimits="true">min</mo> <mrow><mi>A</mi><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover><mo>≥</mo><mover accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></msub>
    <mover accent="true"><mi>c</mi> <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover></mrow></math>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript upper A ModifyingAbove x With right-arrow
    greater-than-or-equal-to ModifyingAbove b With right-arrow Endscripts ModifyingAbove
    c With right-arrow period ModifyingAbove x With right-arrow dollar-sign"><mrow><msub><mo
    form="prefix" movablelimits="true">min</mo> <mrow><mi>A</mi><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover><mo>≥</mo><mover accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></msub>
    <mover accent="true"><mi>c</mi> <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover></mrow></math>
- en: The feasible set <math alttext="upper A ModifyingAbove x With right-arrow greater-than-or-equal-to
    ModifyingAbove b With right-arrow"><mrow><mi>A</mi> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>≥</mo> <mover accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></math>
    is a polyhedron (add a picture of a polyhedron), which we can think of as the
    intersection of a finite number of half spaces. This polyhedron could be bounded
    or unbounded (add a picture).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 可行集<math alttext="upper A ModifyingAbove x With right-arrow greater-than-or-equal-to
    ModifyingAbove b With right-arrow"><mrow><mi>A</mi> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>≥</mo> <mover accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></math>是一个多面体（添加一个多面体的图片），我们可以将其看作是有限数量半空间的交集。这个多面体可以是有界的或无界的（添加一个图片）。
- en: '*The standard form*: This is convenient for computations and developing algorithms,
    like the simplex and interior point methods. The decision variables must be nonnegative,
    so we are only searching in the *first hypeoctant*, the high dimensional analogue
    of the first quadrant, where all the coordinates are non-negative. Moreover, the
    constraints must always be equalities, not inequalities, so we must be on the
    boundary of the half space, not on the interior. This is how a linear optimization
    problem in standard form looks like:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*标准形式*：这对于计算和开发算法很方便，比如单纯形和内点方法。决策变量必须是非负的，所以我们只在*第一象限*中搜索，这是第一象限的高维类比，其中所有坐标都是非负的。此外，约束必须始终是相等关系，而不是不等式，因此我们必须在半空间的边界上，而不是在内部。这就是标准形式的线性优化问题的样子：'
- en: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column upper A ModifyingAbove x With right-arrow equals ModifyingAbove b With
    right-arrow comma 2nd Row 1st Column Blank 2nd Column ModifyingAbove x With right-arrow
    greater-than-or-equal-to ModifyingAbove 0 With right-arrow EndLayout Endscripts
    ModifyingAbove c With right-arrow period ModifyingAbove x With right-arrow dollar-sign"><mrow><msub><mo
    form="prefix" movablelimits="true">min</mo> <mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mi>A</mi><mover accent="true"><mi>x</mi> <mo>→</mo></mover><mo>=</mo><mover
    accent="true"><mi>b</mi> <mo>→</mo></mover><mo>,</mo></mrow></mtd></mtr><mtr><mtd
    columnalign="left"><mrow><mover accent="true"><mi>x</mi> <mo>→</mo></mover><mo>≥</mo><mover
    accent="true"><mn>0</mn> <mo>→</mo></mover></mrow></mtd></mtr></mtable></msub>
    <mover accent="true"><mi>c</mi> <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover></mrow></math>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column upper A ModifyingAbove x With right-arrow equals ModifyingAbove b With
    right-arrow comma 2nd Row 1st Column Blank 2nd Column ModifyingAbove x With right-arrow
    greater-than-or-equal-to ModifyingAbove 0 With right-arrow EndLayout Endscripts
    ModifyingAbove c With right-arrow period ModifyingAbove x With right-arrow dollar-sign"><mrow><msub><mo
    form="prefix" movablelimits="true">min</mo> <mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mi>A</mi><mover accent="true"><mi>x</mi> <mo>→</mo></mover><mo>=</mo><mover
    accent="true"><mi>b</mi> <mo>→</mo></mover><mo>,</mo></mrow></mtd></mtr><mtr><mtd
    columnalign="left"><mrow><mover accent="true"><mi>x</mi> <mo>→</mo></mover><mo>≥</mo><mover
    accent="true"><mn>0</mn> <mo>→</mo></mover></mrow></mtd></mtr></mtable></msub>
    <mover accent="true"><mi>c</mi> <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover></mrow></math>
- en: 'The linear problem in standard form has an easy way for us to internalize:
    Synthesize the vector <math alttext="ModifyingAbove b With right-arrow"><mover
    accent="true"><mi>b</mi> <mo>→</mo></mover></math> from the columns of *A* in
    such a way that minimizes the cost <math alttext="ModifyingAbove c With right-arrow
    period ModifyingAbove x With right-arrow"><mrow><mover accent="true"><mi>c</mi>
    <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></math>
    .'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 标准形式的线性问题有一个简单的内化方法：以最小化成本<math alttext="ModifyingAbove c With right-arrow period
    ModifyingAbove x With right-arrow"><mrow><mover accent="true"><mi>c</mi> <mo>→</mo></mover>
    <mo>.</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></math> 的方式从*A*的列中合成向量<math
    alttext="ModifyingAbove b With right-arrow"><mover accent="true"><mi>b</mi> <mo>→</mo></mover></math>。
- en: 'We can go back and forth between the standard form and general form of a linear
    optimization problem easily (for example, by introducing surplus and slack variables
    to covert general linear optimization problem to standard form), but note that
    we end up solving the same problem in different dimensions: If we introduce a
    variable so change an inequality into an equality, such as introducing <math alttext="s
    1"><msub><mi>s</mi> <mn>1</mn></msub></math> to convert the inequality <math alttext="x
    1 minus 3 x 2 greater-than-or-equal-to 4"><mrow><msub><mi>x</mi> <mn>1</mn></msub>
    <mo>-</mo> <mn>3</mn> <msub><mi>x</mi> <mn>2</mn></msub> <mo>≥</mo> <mn>4</mn></mrow></math>
    to the equality <math alttext="x 1 minus 3 x 2 minus s 1 equals 4"><mrow><msub><mi>x</mi>
    <mn>1</mn></msub> <mo>-</mo> <mn>3</mn> <msub><mi>x</mi> <mn>2</mn></msub> <mo>-</mo>
    <msub><mi>s</mi> <mn>1</mn></msub> <mo>=</mo> <mn>4</mn></mrow></math> , then
    we increase the dimension (in this example from two to three). That is fine. It
    is actually one of the nice things about math that we can model unlimited amount
    of dimensions even though we only live in a three dimensional world.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地在标准形式和一般形式之间来回转换线性优化问题（例如，通过引入剩余和松弛变量将一般线性优化问题转换为标准形式），但请注意，我们最终解决的是不同维度的相同问题：如果我们引入一个变量来将不等式转换为等式，例如引入<math
    alttext="s 1"><msub><mi>s</mi> <mn>1</mn></msub></math>将不等式<math alttext="x 1
    minus 3 x 2 greater-than-or-equal-to 4"><mrow><msub><mi>x</mi> <mn>1</mn></msub>
    <mo>-</mo> <mn>3</mn> <msub><mi>x</mi> <mn>2</mn></msub> <mo>≥</mo> <mn>4</mn></mrow></math>转换为等式<math
    alttext="x 1 minus 3 x 2 minus s 1 equals 4"><mrow><msub><mi>x</mi> <mn>1</mn></msub>
    <mo>-</mo> <mn>3</mn> <msub><mi>x</mi> <mn>2</mn></msub> <mo>-</mo> <msub><mi>s</mi>
    <mn>1</mn></msub> <mo>=</mo> <mn>4</mn></mrow></math>，那么我们会增加维度（在这个例子中从二维到三维）。这没问题。这实际上是数学的一个好处，我们可以模拟无限维度，即使我们只生活在一个三维世界中。
- en: 'Example: Graphical representation of a linear optimization problem in two dimensions'
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 例子：二维线性优化问题的图形表示
- en: '[Figure 10-4](#Fig_simplex) shows a graphical representation of the linear
    optimization problem:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-4](#Fig_simplex)显示了线性优化问题的图形表示。'
- en: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column x plus 2 y less-than-or-equal-to 3 2nd Row 1st Column Blank 2nd Column
    2 x plus y less-than-or-equal-to 3 3rd Row 1st Column Blank 2nd Column x greater-than-or-equal-to
    0 4th Row 1st Column Blank 2nd Column y greater-than-or-equal-to 0 EndLayout Endscripts
    minus x minus y period dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo>
    <mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mi>x</mi><mo>+</mo><mn>2</mn><mi>y</mi><mo>≤</mo><mn>3</mn></mrow></mtd></mtr><mtr><mtd
    columnalign="left"><mrow><mn>2</mn><mi>x</mi><mo>+</mo><mi>y</mi><mo>≤</mo><mn>3</mn></mrow></mtd></mtr><mtr><mtd
    columnalign="left"><mrow><mi>x</mi><mo>≥</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd
    columnalign="left"><mrow><mi>y</mi><mo>≥</mo><mn>0</mn></mrow></mtd></mtr></mtable></msub>
    <mo>-</mo> <mi>x</mi> <mo>-</mo> <mi>y</mi> <mo>.</mo></mrow></math>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column x plus 2 y less-than-or-equal-to 3 2nd Row 1st Column Blank 2nd Column
    2 x plus y less-than-or-equal-to 3 3rd Row 1st Column Blank 2nd Column x greater-than-or-equal-to
    0 4th Row 1st Column Blank 2nd Column y greater-than-or-equal-to 0 EndLayout Endscripts
    minus x minus y period dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo>
    <mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mi>x</mi><mo>+</mo><mn>2</mn><mi>y</mi><mo>≤</mo><mn>3</mn></mrow></mtd></mtr><mtr><mtd
    columnalign="left"><mrow><mn>2</mn><mi>x</mi><mo>+</mo><mi>y</mi><mo>≤</mo><mn>3</mn></mrow></mtd></mtr><mtr><mtd
    columnalign="left"><mrow><mi>x</mi><mo>≥</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd
    columnalign="left"><mrow><mi>y</mi><mo>≥</mo><mn>0</mn></mrow></mtd></mtr></mtable></msub>
    <mo>-</mo> <mi>x</mi> <mo>-</mo> <mi>y</mi> <mo>.</mo></mrow></math>
- en: This problem is two dimensional (and neither in general form nor in stardard
    form, but we can easily convert to either).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题是二维的（既不是一般形式也不是标准形式，但我们可以轻松转换为任何一个）。
- en: Note that the optimal value of -x-y is -2 attained at the point (1,1), which
    is one of the corners of the feasible set. If this was an unconstrained problem,
    then the infimum would be <math alttext="negative normal infinity"><mrow><mo>-</mo>
    <mi>∞</mi></mrow></math> . Constraints make a huge difference. The fact that the
    optimal value is at one of the corners of the polygon (two dimensional polyhedron)
    is not a coincidence. If we draw the straight line -x-y=c for some c that places
    part of the line inside the feasible set, then move in the direction of the negative
    of the gradient vector (recall that this is the direction of fastest descent),
    the line would move in the direction of the vector <math alttext="minus normal
    nabla left-parenthesis negative x minus y right-parenthesis equals minus left-parenthesis
    negative 1 comma negative 1 right-parenthesis equals left-parenthesis 1 comma
    1 right-parenthesis"><mrow><mo>-</mo> <mi>∇</mi> <mo>(</mo> <mo>-</mo> <mi>x</mi>
    <mo>-</mo> <mi>y</mi> <mo>)</mo> <mo>=</mo> <mo>-</mo> <mo>(</mo> <mo>-</mo> <mn>1</mn>
    <mo>,</mo> <mo>-</mo> <mn>1</mn> <mo>)</mo> <mo>=</mo> <mo>(</mo> <mn>1</mn> <mo>,</mo>
    <mn>1</mn> <mo>)</mo></mrow></math> (it is a coincidence here that the gradient
    vector has the same coordinates as the optimizing point these two are completely
    unrelated). As long as the line has parts of it inside the feasible set we can
    *keep pushing* and making *c* smaller, until we can’t push anymore, because if
    we do we’d exit the feasible set, become infeasible, and lose all our pushing
    work. This happens exactly when the whole line is outside the feasible set and
    barely hanging at the point (1,1), which is still in the feasible set. We found
    our optimizer, the point which makes the value of -x-y smallest. We will get back
    to moving through the corners of feasible sets of linear problems soon, because
    that’s where the optimizers are.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，-x-y的最优值为-2，取得于点（1,1），这是可行集的一个角点。如果这是一个无约束问题，那么下确界将是<math alttext="负无穷"><mrow><mo>-</mo>
    <mi>∞</mi></mrow></math>。约束会产生巨大的影响。最优值在多边形（二维多面体）的一个角点上并非偶然。如果我们画一条直线-x-y=c，其中c使得直线的一部分在可行集内，然后沿着负梯度向量的方向移动（回想一下这是最快下降的方向），直线将沿着向量<math
    alttext="负斜率左括号负x减y右括号等于负左括号负1，负1右括号等于左括号1，1右括号"><mrow><mo>-</mo> <mi>∇</mi> <mo>(</mo>
    <mo>-</mo> <mi>x</mi> <mo>-</mo> <mi>y</mi> <mo>)</mo> <mo>=</mo> <mo>-</mo> <mo>(</mo>
    <mo>-</mo> <mn>1</mn> <mo>,</mo> <mo>-</mo> <mn>1</mn> <mo>)</mo> <mo>=</mo> <mo>(</mo>
    <mn>1</mn> <mo>,</mo> <mn>1</mn> <mo>)</mo></mrow></math>的方向移动（这里梯度向量与优化点具有相同的坐标是巧合，这两者完全无关）。只要直线的部分在可行集内，我们就可以*继续推进*并使*c*变小，直到无法再推进，因为如果这样做，我们将离开可行集，变得不可行，并且失去所有推进的工作。这正好发生在整条直线都在可行集外部并且勉强悬挂在点（1,1）时，而这个点仍然在可行集内。我们找到了我们的优化器，使得-x-y的值最小的点。很快我们将回到线性问题的可行集的角落中，因为那里是优化器所在的地方。
- en: '![280](assets/emai_1004.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![280](assets/emai_1004.png)'
- en: Figure 10-4\. Feasible set and the optimal value of -x-y is -2 attained at the
    corner point (1,1).
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-4\. 可行集和-x-y的最优值为-2，取得于角点（1,1）。
- en: Convex to Linear
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 凸到线性
- en: Even if the objective function is nonlinear, in many cases we can reformulate
    the problem as a linear problem and use linear optimization techniques to either
    obtain an exact solution or an approximation to the exact solution. We can approximate
    a convex (and differentiable) function by a piecewise linear convex function [Figure 10-5](#Fig_approx_convex_linear).
    We can turn an optimization problem with piecwise linear objective function into
    one with a linear objective function. This however makes us lose differentiability
    (the function stops being smooth). Nothing is free. In optimization problems,
    after linearity, convexity is the next desirable thing, because we wouldn’t worry
    about getting stuck at local minima. A local minimum for a convex is a global
    minimum.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 即使目标函数是非线性的，在许多情况下我们可以将问题重新表述为一个线性问题，并使用线性优化技术来获得精确解或接近精确解的近似解。我们可以通过分段线性凸函数来近似凸（且可微）函数[图10-5](#Fig_approx_convex_linear)。我们可以将具有分段线性目标函数的优化问题转化为具有线性目标函数的问题。然而，这会使我们失去可微性（函数不再平滑）。没有免费的午餐。在优化问题中，线性之后，凸性是下一个理想的特性，因为我们不会担心陷入局部最小值。对于凸函数来说，局部最小值就是全局最小值。
- en: '![280](assets/emai_1005.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![280](assets/emai_1005.png)'
- en: Figure 10-5\. Approximating a convex function by piecewise linear functions
  id: totrans-171
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-5\. 通过分段线性函数逼近凸函数
- en: A *convex optimization* problem has a convex objective function and a convex
    feasible set. Convex optimization is a whole field of its own.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*凸优化*问题具有凸目标函数和凸可行集。凸优化是一个完整的领域。
- en: Convex function
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 凸函数
- en: A function <math alttext="f colon double-struck upper R Superscript n Baseline
    right-arrow double-struck upper R"><mrow><mi>f</mi> <mo>:</mo> <msup><mi>ℝ</mi>
    <mi>n</mi></msup> <mo>→</mo> <mi>ℝ</mi></mrow></math> is convex if and only if
    <math alttext="f left-parenthesis lamda x plus left-parenthesis 1 minus lamda
    right-parenthesis y right-parenthesis less-than-or-equal-to lamda f left-parenthesis
    x right-parenthesis plus left-parenthesis 1 minus lamda right-parenthesis f left-parenthesis
    y right-parenthesis"><mrow><mi>f</mi> <mo>(</mo> <mi>λ</mi> <mi>x</mi> <mo>+</mo>
    <mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>λ</mi> <mo>)</mo> <mi>y</mi> <mo>)</mo> <mo>≤</mo>
    <mi>λ</mi> <mi>f</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>1</mn>
    <mo>-</mo> <mi>λ</mi> <mo>)</mo> <mi>f</mi> <mo>(</mo> <mi>y</mi> <mo>)</mo></mrow></math>
    , for all <math alttext="x comma y element-of double-struck upper R Superscript
    n"><mrow><mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>∈</mo> <msup><mi>ℝ</mi> <mi>n</mi></msup></mrow></math>
    and <math alttext="0 less-than-or-equal-to lamda less-than-or-equal-to 1"><mrow><mn>0</mn>
    <mo>≤</mo> <mi>λ</mi> <mo>≤</mo> <mn>1</mn></mrow></math> . This means that the
    segment connecting any two points on the graph of *f* lies above the graph of
    *f* (draw a picture).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数 <math alttext="f colon double-struck upper R Superscript n Baseline right-arrow
    double-struck upper R"><mrow><mi>f</mi> <mo>:</mo> <msup><mi>ℝ</mi> <mi>n</mi></sup>
    <mo>→</mo> <mi>ℝ</mi></mrow></math> 是凸函数当且仅当 <math alttext="f left-parenthesis
    lamda x plus left-parenthesis 1 minus lamda right-parenthesis y right-parenthesis
    less-than-or-equal-to lamda f left-parenthesis x right-parenthesis plus left-parenthesis
    1 minus lamda right-parenthesis f left-parenthesis y right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mi>λ</mi> <mi>x</mi> <mo>+</mo> <mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>λ</mi>
    <mo>)</mo> <mi>y</mi> <mo>)</mo> <mo>≤</mo> <mi>λ</mi> <mi>f</mi> <mo>(</mo> <mi>x</mi>
    <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>λ</mi> <mo>)</mo> <mi>f</mi>
    <mo>(</mo> <mi>y</mi> <mo>)</mo></mrow></math> ，对于所有 <math alttext="x comma y
    element-of double-struck upper R Superscript n"><mrow><mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>∈</mo> <msup><mi>ℝ</mi> <mi>n</mi></sup></mrow></math> 和 <math alttext="0
    less-than-or-equal-to lamda less-than-or-equal-to 1"><mrow><mn>0</mn> <mo>≤</mo>
    <mi>λ</mi> <mo>≤</mo> <mn>1</mn></mrow></math> 。这意味着连接*f*图上任意两点的线段位于*f*的图形之上（画个图）。
- en: 'Helpful facts about convex functions:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 关于凸函数的一些有用事实：
- en: A convex function cannot have a local minimum that fails to be global minimum.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凸函数不可能有一个局部最小值，而不是全局最小值。
- en: If the functions <math alttext="f 1 comma f 2 comma ellipsis comma f Subscript
    m Baseline colon double-struck upper R Superscript n Baseline right-arrow double-struck
    upper R"><mrow><msub><mi>f</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>f</mi>
    <mn>2</mn></msub> <mo>,</mo> <mo>...</mo> <mo>,</mo> <msub><mi>f</mi> <mi>m</mi></msub>
    <mo>:</mo> <msup><mi>ℝ</mi> <mi>n</mi></msup> <mo>→</mo> <mi>ℝ</mi></mrow></math>
    are convex functions, then the function <math alttext="f left-parenthesis x right-parenthesis
    equals max Underscript i Endscripts f Subscript i Baseline left-parenthesis x
    right-parenthesis"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mo form="prefix" movablelimits="true">max</mo> <mi>i</mi></msub>
    <msub><mi>f</mi> <mi>i</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    is also convex. *f* may lose smoothness in this case so optimization methods wouldn’t
    be able to use derivatives.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数 <math alttext="f 1 comma f 2 comma ellipsis comma f Subscript m Baseline
    colon double-struck upper R Superscript n Baseline right-arrow double-struck upper
    R"><mrow><msub><mi>f</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>f</mi> <mn>2</mn></msub>
    <mo>,</mo> <mo>...</mo> <mo>,</mo> <msub><mi>f</mi> <mi>m</mi></msub> <mo>:</mo>
    <msup><mi>ℝ</mi> <mi>n</mi></msup> <mo>→</mo> <mi>ℝ</mi></mrow></math> 是凸函数，那么函数
    <math alttext="f left-parenthesis x right-parenthesis equals max Underscript i
    Endscripts f Subscript i Baseline left-parenthesis x right-parenthesis"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo form="prefix"
    movablelimits="true">max</mo> <mi>i</mi></msub> <msub><mi>f</mi> <mi>i</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> 也是凸函数。在这种情况下，*f* 可能会失去平滑性，因此优化方法无法使用导数。
- en: The function <math alttext="f left-parenthesis x right-parenthesis equals max
    left-brace m 1 x plus d 1 comma m 2 x plus d 2 comma ellipsis comma m Subscript
    n Baseline x plus d Subscript n Baseline right-brace"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mo form="prefix" movablelimits="true">max</mo>
    <mrow><mo>{</mo> <msub><mi>m</mi> <mn>1</mn></msub> <mi>x</mi> <mo>+</mo> <msub><mi>d</mi>
    <mn>1</mn></msub> <mo>,</mo> <msub><mi>m</mi> <mn>2</mn></msub> <mi>x</mi> <mo>+</mo>
    <msub><mi>d</mi> <mn>2</mn></msub> <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <msub><mi>m</mi>
    <mi>n</mi></msub> <mi>x</mi> <mo>+</mo> <msub><mi>d</mi> <mi>n</mi></msub> <mo>}</mo></mrow></mrow></math>
    or more compactly <math alttext="f left-parenthesis x right-parenthesis equals
    max Underscript i equals 1 comma 2 ellipsis comma n Endscripts left-brace m Subscript
    i Baseline x plus d Subscript i Baseline right-brace"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo form="prefix" movablelimits="true">max</mo>
    <mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>⋯</mo><mo>,</mo><mi>n</mi></mrow></msub>
    <mrow><mo>{</mo> <msub><mi>m</mi> <mi>i</mi></msub> <mi>x</mi> <mo>+</mo> <msub><mi>d</mi>
    <mi>i</mi></msub> <mo>}</mo></mrow></mrow></math> is piecewise linear [Figure 10-6](#Fig_max_piecewise_linear).
    This is a convex function since each <math alttext="m Subscript i Baseline x plus
    d Subscript i"><mrow><msub><mi>m</mi> <mi>i</mi></msub> <mi>x</mi> <mo>+</mo>
    <msub><mi>d</mi> <mi>i</mi></msub></mrow></math> is convex (linear functions are
    convex and concave at the same time), and maximum of convex functions is also
    convex.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数<math alttext="f left-parenthesis x right-parenthesis equals max left-brace
    m 1 x plus d 1 comma m 2 x plus d 2 comma ellipsis comma m Subscript n Baseline
    x plus d Subscript n Baseline right-brace"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mo form="prefix" movablelimits="true">max</mo> <mrow><mo>{</mo>
    <msub><mi>m</mi> <mn>1</mn></msub> <mi>x</mi> <mo>+</mo> <msub><mi>d</mi> <mn>1</mn></msub>
    <mo>,</mo> <msub><mi>m</mi> <mn>2</mn></msub> <mi>x</mi> <mo>+</mo> <msub><mi>d</mi>
    <mn>2</mn></msub> <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <msub><mi>m</mi> <mi>n</mi></msub>
    <mi>x</mi> <mo>+</mo> <msub><mi>d</mi> <mi>n</mi></msub> <mo>}</mo></mrow></mrow></math>或更简洁地<math
    alttext="f left-parenthesis x right-parenthesis equals max Underscript i equals
    1 comma 2 ellipsis comma n Endscripts left-brace m Subscript i Baseline x plus
    d Subscript i Baseline right-brace"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msub><mo form="prefix" movablelimits="true">max</mo>
    <mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>⋯</mo><mo>,</mo><mi>n</mi></mrow></msub>
    <mrow><mo>{</mo> <msub><mi>m</mi> <mi>i</mi></msub> <mi>x</mi> <mo>+</mo> <msub><mi>d</mi>
    <mi>i</mi></msub> <mo>}</mo></mrow></mrow></math>是分段线性的[图10-6](#Fig_max_piecewise_linear)。这是一个凸函数，因为每个<math
    alttext="m Subscript i Baseline x plus d Subscript i"><mrow><msub><mi>m</mi> <mi>i</mi></msub>
    <mi>x</mi> <mo>+</mo> <msub><mi>d</mi> <mi>i</mi></msub></mrow></math>是凸的（线性函数同时是凸和凹的），凸函数的最大值也是凸的。
- en: '![280](assets/emai_1006.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![280](assets/emai_1006.png)'
- en: Figure 10-6\. The maximum of linear functions is piecewise linear and convex
  id: totrans-180
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-6。线性函数的最大值是分段线性和凸的
- en: For example, the absolute value function f(x)=|x|=max{x,-x} is piecewise linear
    and convex (draw a picture).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，绝对值函数f(x)=|x|=max{x,-x}是分段线性和凸的（画个图）。
- en: 'We can reformulate optimization problems with piecewise linear convex objective
    functions as linear optimization problems:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将具有分段线性凸目标函数的优化问题重新表述为线性优化问题：
- en: <math alttext="dollar-sign min Underscript upper A x greater-than-or-equal-to
    b Endscripts max Underscript i Endscripts m Subscript i Baseline period x plus
    d Subscript i Baseline left-right-arrow min Underscript StartLayout 1st Row 1st
    Column Blank 2nd Column z greater-than-or-equal-to m Subscript i Baseline period
    x plus d Subscript i Baseline 2nd Row 1st Column Blank 2nd Column upper A x greater-than-or-equal-to
    b EndLayout Endscripts z dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo>
    <mrow><mi>A</mi><mi>x</mi><mo>≥</mo><mi>b</mi></mrow></msub> <msub><mo form="prefix"
    movablelimits="true">max</mo> <mi>i</mi></msub> <msub><mi>m</mi> <mi>i</mi></msub>
    <mo>.</mo> <mi>x</mi> <mo>+</mo> <msub><mi>d</mi> <mi>i</mi></msub> <mo>↔</mo>
    <msub><mo form="prefix" movablelimits="true">min</mo> <mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mi>z</mi><mo>≥</mo><msub><mi>m</mi> <mi>i</mi></msub>
    <mo>.</mo><mi>x</mi><mo>+</mo><msub><mi>d</mi> <mi>i</mi></msub></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>A</mi><mi>x</mi><mo>≥</mo><mi>b</mi></mrow></mtd></mtr></mtable></msub>
    <mi>z</mi></mrow></math>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript upper A x greater-than-or-equal-to
    b Endscripts max Underscript i Endscripts m Subscript i Baseline period x plus
    d Subscript i Baseline left-right-arrow min Underscript StartLayout 1st Row 1st
    Column Blank 2nd Column z greater-than-or-equal-to m Subscript i Baseline period
    x plus d Subscript i Baseline 2nd Row 1st Column Blank 2nd Column upper A x greater-than-or-equal-to
    b EndLayout Endscripts z dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo>
    <mrow><mi>A</mi><mi>x</mi><mo>≥</mo><mi>b</mi></mrow></msub> <msub><mo form="prefix"
    movablelimits="true">max</mo> <mi>i</mi></msub> <msub><mi>m</mi> <mi>i</mi></msub>
    <mo>.</mo> <mi>x</mi> <mo>+</mo> <msub><mi>d</mi> <mi>i</mi></msub> <mo>↔</mo>
    <msub><mo form="prefix" movablelimits="true">min</mo> <mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mi>z</mi><mo>≥</mo><msub><mi>m</mi> <mi>i</mi></msub>
    <mo>.</mo><mi>x</mi><mo>+</mo><msub><mi>d</mi> <mi>i</mi></msub></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>A</mi><mi>x</mi><mo>≥</mo><mi>b</mi></mrow></mtd></mtr></mtable></msub>
    <mi>z</mi></mrow></math>
- en: 'In particular, an optimization problem where the objective function has absolute
    values of the decision variables can be reformulated as a linear optimization
    problem in two ways (here the <math alttext="c Subscript i"><msub><mi>c</mi> <mi>i</mi></msub></math>
    in the objective function are nonnegative, otherwise the objective function might
    be nonconvex):'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特别是，一个优化问题，其中目标函数具有决策变量的绝对值，可以通过两种方式重新表述为线性优化问题（这里目标函数中的<math alttext="c Subscript
    i"><msub><mi>c</mi> <mi>i</mi></msub></math>是非负的，否则目标函数可能是非凸的）：
- en: <math alttext="dollar-sign min Underscript upper A x greater-than-or-equal-to
    b Endscripts sigma-summation Underscript i equals 1 Overscript n Endscripts c
    Subscript i Baseline StartAbsoluteValue x Subscript i Baseline EndAbsoluteValue
    left-right-arrow min Underscript StartLayout 1st Row 1st Column upper A x 2nd
    Column b 2nd Row 1st Column x Subscript i Baseline 2nd Column z Subscript i Baseline
    3rd Row 1st Column minus x Subscript i Baseline 2nd Column z Subscript i Baseline
    EndLayout Endscripts sigma-summation Underscript i equals 1 Overscript n Endscripts
    c Subscript i Baseline z Subscript i Baseline left-right-arrow min Underscript
    StartLayout 1st Row 1st Column Blank 2nd Column upper A x Superscript plus Baseline
    minus upper A x Superscript minus Baseline greater-than-or-equal-to b 2nd Row
    1st Column Blank 2nd Column x Superscript plus Baseline comma x Superscript minus
    Baseline greater-than-or-equal-to 0 EndLayout Endscripts sigma-summation Underscript
    i equals 1 Overscript n Endscripts c Subscript i Baseline left-parenthesis x Subscript
    i Superscript plus Baseline plus x Subscript i Superscript minus Baseline right-parenthesis
    dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo> <mrow><mi>A</mi><mi>x</mi><mo>≥</mo><mi>b</mi></mrow></msub>
    <msubsup><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup>
    <msub><mi>c</mi> <mi>i</mi></msub> <mrow><mo>|</mo> <msub><mi>x</mi> <mi>i</mi></msub>
    <mo>|</mo></mrow> <mo>↔</mo> <msub><mo form="prefix" movablelimits="true">min</mo>
    <mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>A</mi><mi>x</mi></mrow></mtd><mtd
    columnalign="left"><mrow><mo>≥</mo><mi>b</mi></mrow></mtd></mtr><mtr><mtd columnalign="right"><msub><mi>x</mi>
    <mi>i</mi></msub></mtd> <mtd columnalign="left"><mrow><mo>≤</mo><msub><mi>z</mi>
    <mi>i</mi></msub></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><mo>-</mo><msub><mi>x</mi>
    <mi>i</mi></msub></mrow></mtd> <mtd columnalign="left"><mrow><mo>≤</mo><msub><mi>z</mi>
    <mi>i</mi></msub></mrow></mtd></mtr></mtable></msub> <msubsup><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>n</mi></msubsup> <msub><mi>c</mi> <mi>i</mi></msub> <msub><mi>z</mi> <mi>i</mi></msub>
    <mo>↔</mo> <msub><mo form="prefix" movablelimits="true">min</mo> <mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mi>A</mi><msup><mi>x</mi> <mo>+</mo></msup> <mo>-</mo><mi>A</mi><msup><mi>x</mi>
    <mo>-</mo></msup> <mo>≥</mo><mi>b</mi></mrow></mtd></mtr><mtr><mtd columnalign="left"><mrow><msup><mi>x</mi>
    <mo>+</mo></msup> <mo>,</mo><msup><mi>x</mi> <mo>-</mo></msup> <mo>≥</mo><mn>0</mn></mrow></mtd></mtr></mtable></msub>
    <msubsup><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup>
    <msub><mi>c</mi> <mi>i</mi></msub> <mrow><mo>(</mo> <msubsup><mi>x</mi> <mi>i</mi>
    <mo>+</mo></msubsup> <mo>+</mo> <msubsup><mi>x</mi> <mi>i</mi> <mo>-</mo></msubsup>
    <mo>)</mo></mrow></mrow></math>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript upper A x greater-than-or-equal-to
    b Endscripts sigma-summation Underscript i equals 1 Overscript n Endscripts c
    Subscript i Baseline StartAbsoluteValue x Subscript i Baseline EndAbsoluteValue
    left-right-arrow min Underscript StartLayout 1st Row 1st Column upper A x 2nd
    Column b 2nd Row 1st Column x Subscript i Baseline 2nd Column z Subscript i Baseline
    3rd Row 1st Column minus x Subscript i Baseline 2nd Column z Subscript i Baseline
    EndLayout Endscripts sigma-summation Underscript i equals 1 Overscript n Endscripts
    c Subscript i Baseline z Subscript i Baseline left-right-arrow min Underscript
    StartLayout 1st Row 1st Column Blank 2nd Column upper A x Superscript plus Baseline
    minus upper A x Superscript minus Baseline greater-than-or-equal-to b 2nd Row
    1st Column Blank 2nd Column x Superscript plus Baseline comma x Superscript minus
    Baseline greater-than-or-equal-to 0 EndLayout Endscripts sigma-summation Underscript
    i equals 1 Overscript n Endscripts c Subscript i Baseline left-parenthesis x Subscript
    i Superscript plus Baseline plus x Subscript i Superscript minus Baseline right-parenthesis
    dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo> <mrow><mi>A</mi><mi>x</mi><mo>≥</mo><mi>b</mi></mrow></msub>
    <msubsup><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup>
    <msub><mi>c</mi> <mi>i</mi></msub> <mrow><mo>|</mo> <msub><mi>x</mi> <mi>i</mi></msub>
    <mo>|</mo></mrow> <mo>↔</mo> <msub><mo form="prefix" movablelimits="true">min</mo>
    <mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>A</mi><mi>x</mi></mrow></mtd><mtd
    columnalign="left"><mrow><mo>≥</mo><mi>b</mi></mrow></mtd></mtr><mtr><mtd columnalign="right"><msub><mi>x</mi>
    <mi>i</mi></msub></mtd> <mtd columnalign="left"><mrow><mo>≤</mo><msub><mi>z</mi>
    <mi>i</mi></msub></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><mo>-</mo><msub><mi>x</mi>
    <mi>i</mi></msub></mrow></mtd> <mtd columnalign="left"><mrow><mo>≤</mo><msub><mi>z</mi>
    <mi>i</mi></msub></mrow></mtd></mtr></mtable></msub> <msubsup><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>n</mi></msubsup> <msub><mi>c</mi> <mi>i</mi></msub> <msub><mi>z</mi> <mi>i</mi></msub>
    <mo>↔</mo> <msub><mo form="prefix" movablelimits="true">min</mo> <mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mi>A</mi><msup><mi>x</mi> <mo>+</mo></msup> <mo>-</mo><mi>A</mi><msup><mi>x</mi>
    <mo>-</mo></msup> <mo>≥</mo><mi>b</mi></mrow></mtd></mtr><mtr><mtd columnalign="left"><mrow><msup><mi>x</mi>
    <mo>+</mo></msup> <mo>,</mo><msup><mi>x</mi> <mo>-</mo></msup> <mo>≥</mo><mn>0</mn></mrow></mtd></mtr></mtable></msub>
    <msubsup><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup>
    <msub><mi>c</mi> <mi>i</mi></msub> <mrow><mo>(</mo> <msubsup><mi>x</mi> <mi>i</mi>
    <mo>+</mo></msubsup> <mo>+</mo> <msubsup><mi>x</mi> <mi>i</mi> <mo>-</mo></msubsup>
    <mo>)</mo></mrow></mrow></math>
- en: The Geometry of Linear Optimization
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性优化的几何形态
- en: 'Let’s think of the geometry of a linear optimization problem in standard form.
    Without loss of generality, we assume that the rows of *A* are linearly independent.
    In other words, there are no redundant constraints. This guarantees the existence
    of at least one set of *m* linearly independent columns of *A* (or *rank(A)=m*):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来思考标准形式线性优化问题的几何形态。不失一般性，我们假设*A*的行是线性无关的。换句话说，没有冗余约束。这保证了至少存在一个*A*的线性无关列集（或*rank(A)=m*）：
- en: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column upper A ModifyingAbove x With right-arrow equals ModifyingAbove b With
    right-arrow 2nd Row 1st Column Blank 2nd Column ModifyingAbove x With right-arrow
    greater-than-or-equal-to ModifyingAbove 0 With right-arrow EndLayout Endscripts
    ModifyingAbove c With right-arrow period ModifyingAbove x With right-arrow dollar-sign"><mrow><msub><mo
    form="prefix" movablelimits="true">min</mo> <mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mi>A</mi><mover accent="true"><mi>x</mi> <mo>→</mo></mover><mo>=</mo><mover
    accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></mtd></mtr><mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>≥</mo><mover accent="true"><mn>0</mn>
    <mo>→</mo></mover></mrow></mtd></mtr></mtable></msub> <mover accent="true"><mi>c</mi>
    <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></math>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column upper A ModifyingAbove x With right-arrow equals ModifyingAbove b With
    right-arrow 2nd Row 1st Column Blank 2nd Column ModifyingAbove x With right-arrow
    greater-than-or-equal-to ModifyingAbove 0 With right-arrow EndLayout Endscripts
    ModifyingAbove c With right-arrow period ModifyingAbove x With right-arrow dollar-sign"><mrow><msub><mo
    form="prefix" movablelimits="true">min</mo> <mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mi>A</mi><mover accent="true"><mi>x</mi> <mo>→</mo></mover><mo>=</mo><mover
    accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></mtd></mtr><mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>≥</mo><mover accent="true"><mn>0</mn>
    <mo>→</mo></mover></mrow></mtd></mtr></mtable></msub> <mover accent="true"><mi>c</mi>
    <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></math>
- en: 'As we mentioned before, if we change from general form to standard form, then
    we jump up in dimension. Therefore, even if a polyhedron has no corners in general
    form, it will always have corners in its higher dimensional standard form: Due
    to the positivity condition of the coordinates in standard form, the polyhedron
    becomes situated in the first hyperoctant, hence cannot possibly have full lines.
    Now we have theorems guaranteeing that for a linear optimization problem, either
    the optimal cost is <math alttext="negative normal infinity"><mrow><mo>-</mo>
    <mi>∞</mi></mrow></math> , or there exists a finite optimal cost happening at
    a corner of the polyhedron (at a basic feasible solution).'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，如果我们从一般形式转换为标准形式，那么我们会在维度上跳跃。因此，即使一个多面体在一般形式中没有角，它在更高维度的标准形式中总会有角：由于标准形式中坐标的正性条件，多面体位于第一超八面体中，因此不可能有完整的线。现在我们有定理保证，对于线性优化问题，要么最优成本是<math
    alttext="负无穷大"><mrow><mo>-</mo> <mi>∞</mi></mrow></math>，要么存在一个有限的最优成本发生在多面体的一个角（在一个基本可行解处）。
- en: The Simplex Algorithm
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单纯形算法
- en: 'Our goal is to construct an algorithm that finds an optimal solution for the
    linear optimization problem in standard form:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是构建一个算法，找到标准形式线性优化问题的最优解：
- en: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column upper A ModifyingAbove x With right-arrow equals ModifyingAbove b With
    right-arrow 2nd Row 1st Column Blank 2nd Column ModifyingAbove x With right-arrow
    greater-than-or-equal-to ModifyingAbove 0 With right-arrow EndLayout Endscripts
    ModifyingAbove c With right-arrow period ModifyingAbove x With right-arrow dollar-sign"><mrow><msub><mo
    form="prefix" movablelimits="true">min</mo> <mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mi>A</mi><mover accent="true"><mi>x</mi> <mo>→</mo></mover><mo>=</mo><mover
    accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></mtd></mtr><mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>≥</mo><mover accent="true"><mn>0</mn>
    <mo>→</mo></mover></mrow></mtd></mtr></mtable></msub> <mover accent="true"><mi>c</mi>
    <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></math>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column upper A ModifyingAbove x With right-arrow equals ModifyingAbove b With
    right-arrow 2nd Row 1st Column Blank 2nd Column ModifyingAbove x With right-arrow
    greater-than-or-equal-to ModifyingAbove 0 With right-arrow EndLayout Endscripts
    ModifyingAbove c With right-arrow period ModifyingAbove x With right-arrow dollar-sign"><mrow><msub><mo
    form="prefix" movablelimits="true">min</mo> <mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mi>A</mi><mover accent="true"><mi>x</mi> <mo>→</mo></mover><mo>=</mo><mover
    accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></mtd></mtr><mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>≥</mo><mover accent="true"><mn>0</mn>
    <mo>→</mo></mover></mrow></mtd></mtr></mtable></msub> <mover accent="true"><mi>c</mi>
    <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></math>
- en: '*A* is <math alttext="m times n"><mrow><mi>m</mi> <mo>×</mo> <mi>n</mi></mrow></math>
    with *m* linearly independent rows (so <math alttext="m less-than-or-equal-to
    n"><mrow><mi>m</mi> <mo>≤</mo> <mi>n</mi></mrow></math> ), <math alttext="ModifyingAbove
    b With right-arrow"><mover accent="true"><mi>b</mi> <mo>→</mo></mover></math>
    is <math alttext="m times 1"><mrow><mi>m</mi> <mo>×</mo> <mn>1</mn></mrow></math>
    , <math alttext="ModifyingAbove c With right-arrow"><mover accent="true"><mi>c</mi>
    <mo>→</mo></mover></math> and <math alttext="ModifyingAbove x With right-arrow"><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover></math> are <math alttext="n times
    1"><mrow><mi>n</mi> <mo>×</mo> <mn>1</mn></mrow></math> .'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*A* 是 <math alttext="m times n"><mrow><mi>m</mi> <mo>×</mo> <mi>n</mi></mrow></math>，其中
    *m* 个线性无关的行（因此 <math alttext="m less-than-or-equal-to n"><mrow><mi>m</mi> <mo>≤</mo>
    <mi>n</mi></mrow></math>），<math alttext="ModifyingAbove b With right-arrow"><mover
    accent="true"><mi>b</mi> <mo>→</mo></mover></math> 是 <math alttext="m times 1"><mrow><mi>m</mi>
    <mo>×</mo> <mn>1</mn></mrow></math>，<math alttext="ModifyingAbove c With right-arrow"><mover
    accent="true"><mi>c</mi> <mo>→</mo></mover></math> 和 <math alttext="ModifyingAbove
    x With right-arrow"><mover accent="true"><mi>x</mi> <mo>→</mo></mover></math>
    是 <math alttext="n times 1"><mrow><mi>n</mi> <mo>×</mo> <mn>1</mn></mrow></math>。'
- en: The main idea of the simplex method
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单纯形法的主要思想
- en: Start at a vertex of the polyhedron (a corner, also called a basic feasible
    solution), move to another vertex in a direction that is guaranteed to reduce
    the objective function, or the cost (reduced costs <math alttext="c overbar"><mover
    accent="true"><mi>c</mi> <mo>¯</mo></mover></math> ), until you either reach an
    optimal solution, or discover that the problem is unbounded, and the optimal cost
    is <math alttext="negative normal infinity"><mrow><mo>-</mo> <mi>∞</mi></mrow></math>
    (these you know using the optimality conditions, and become the termination criteria
    for your algorithm). There is a chance of cycling in the case for degenerate problems,
    but that can be avoided by making smart choices (systematic way of choosing) when
    there are ties in the process.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从多面体的一个顶点（一个角，也称为基本可行解）开始，沿着保证减少目标函数或成本（减少成本 <math alttext="c overbar"><mover
    accent="true"><mi>c</mi> <mo>¯</mo></mover></math>）的方向移动到另一个顶点，直到达到最优解，或发现问题是无界的，并且最优成本是
    <math alttext="negative normal infinity"><mrow><mo>-</mo> <mi>∞</mi></mrow></math>（这些您可以使用最优性条件知道，并成为算法的终止标准）。在退化问题的情况下可能会出现循环的机会，但可以通过在过程中出现平局时做出明智选择（选择的系统化方式）来避免这种情况。
- en: 'Example: Tracing the path taken by the simplex method on the graph of the polyhedron'
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：跟踪单纯形法在多面体图形上所采取的路径
- en: '[Figure 10-7](#Fig_polyhedron) shows the polyhedron of the following linear
    optimization problem in three dimensions. We start at a basic feasible solution
    then trace the path followed by simplex method, moving from one vertex of the
    polyhedron to the next, reducing the cost (the value of the objective function)
    at each step until it arrives at the vertex with the minimal cost.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-7](#Fig_polyhedron) 显示了三维线性优化问题的多面体。我们从一个基本可行解开始，然后跟踪单纯形法所经过的路径，从多面体的一个顶点移动到下一个顶点，在每一步中减少成本（目标函数的值），直到到达具有最小成本的顶点。'
- en: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column x
    1 plus x 2 plus x 3 2nd Column 4 2nd Row 1st Column x 1 2nd Column 2 3rd Row 1st
    Column x 3 2nd Column 3 4th Row 1st Column 3 x 2 plus x 3 2nd Column 6 5th Row
    1st Column x 1 comma x 2 comma x 3 2nd Column 0 EndLayout Endscripts minus x 1
    plus 5 x 2 minus x 3 dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo>
    <mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo><msub><mi>x</mi> <mn>2</mn></msub> <mo>+</mo><msub><mi>x</mi>
    <mn>3</mn></msub></mrow></mtd> <mtd columnalign="left"><mrow><mo>≤</mo><mn>4</mn></mrow></mtd></mtr><mtr><mtd
    columnalign="right"><msub><mi>x</mi> <mn>1</mn></msub></mtd> <mtd columnalign="left"><mrow><mo>≤</mo><mn>2</mn></mrow></mtd></mtr><mtr><mtd
    columnalign="right"><msub><mi>x</mi> <mn>3</mn></msub></mtd> <mtd columnalign="left"><mrow><mo>≤</mo><mn>3</mn></mrow></mtd></mtr><mtr><mtd
    columnalign="right"><mrow><mn>3</mn><msub><mi>x</mi> <mn>2</mn></msub> <mo>+</mo><msub><mi>x</mi>
    <mn>3</mn></msub></mrow></mtd> <mtd columnalign="left"><mrow><mo>≤</mo><mn>6</mn></mrow></mtd></mtr><mtr><mtd
    columnalign="right"><mrow><msub><mi>x</mi> <mn>1</mn></msub> <mo>,</mo><msub><mi>x</mi>
    <mn>2</mn></msub> <mo>,</mo><msub><mi>x</mi> <mn>3</mn></msub></mrow></mtd> <mtd
    columnalign="left"><mrow><mo>≥</mo><mn>0</mn></mrow></mtd></mtr></mtable></msub>
    <mo>-</mo> <msub><mi>x</mi> <mn>1</mn></msub> <mo>+</mo> <mn>5</mn> <msub><mi>x</mi>
    <mn>2</mn></msub> <mo>-</mo> <msub><mi>x</mi> <mn>3</mn></msub></mrow></math>![250](assets/emai_1007.png)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column x
    1 plus x 2 plus x 3 2nd Column 4 2nd Row 1st Column x 1 2nd Column 2 3rd Row 1st
    Column x 3 2nd Column 3 4th Row 1st Column 3 x 2 plus x 3 2nd Column 6 5th Row
    1st Column x 1 comma x 2 comma x 3 2nd Column 0 EndLayout Endscripts minus x 1
    plus 5 x 2 minus x 3 dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo>
    <mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo><msub><mi>x</mi> <mn>2</mn></msub> <mo>+</mo><msub><mi>x</mi>
    <mn>3</mn></msub></mrow></mtd> <mtd columnalign="left"><mrow><mo>≤</mo><mn>4</mn></mrow></mtd></mtr><mtr><mtd
    columnalign="right"><msub><mi>x</mi> <mn>1</mn></msub></mtd> <mtd columnalign="left"><mrow><mo>≤</mo><mn>2</mn></mrow></mtd></mtr><mtr><mtd
    columnalign="right"><msub><mi>x</mi> <mn>3</mn></msub></mtd> <mtd columnalign="left"><mrow><mo>≤</mo><mn>3</mn></mrow></mtd></mtr><mtr><mtd
    columnalign="right"><mrow><mn>3</mn><msub><mi>x</mi> <mn>2</mn></msub> <mo>+</mo><msub><mi>x</mi>
    <mn>3</mn></msub></mrow></mtd> <mtd columnalign="left"><mrow><mo>≤</mo><mn>6</mn></mrow></mtd></mtr><mtr><mtd
    columnalign="right"><mrow><msub><mi>x</mi> <mn>1</mn></msub> <mo>,</mo><msub><mi>x</mi>
    <mn>2</mn></msub> <mo>,</mo><msub><mi>x</mi> <mn>3</mn></msub></mrow></mtd> <mtd
    columnalign="left"><mrow><mo>≥</mo><mn>0</mn></mrow></mtd></mtr></mtable></msub>
    <mo>-</mo> <msub><mi>x</mi> <mn>1</mn></msub> <mo>+</mo> <mn>5</mn> <msub><mi>x</mi>
    <mn>2</mn></msub> <mo>-</mo> <msub><mi>x</mi> <mn>3</mn></msub></mrow></math>![250](assets/emai_1007.png)
- en: Figure 10-7\. The simplex method moves from one vertex of the polyhedron to
    the next until it finds an optimizing vertex.
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-7。单纯形法从多面体的一个顶点移动到下一个顶点，直到找到一个优化的顶点。
- en: You can skip the rest of this subsection and go straight to the examples on
    transportation and assignment problems, unless you are interested in the details
    of the simplex method and its different implementations.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以跳过本小节的其余部分，直接查看有关运输和分配问题的示例，除非您对单纯形法及其不同实现的细节感兴趣。
- en: 'Start at a vertex of the polyhedron (basic feasible solution *x*: zero non-basic
    coordinates and <math alttext="x Subscript upper B Baseline equals upper B Superscript
    negative 1 Baseline b"><mrow><msub><mi>x</mi> <mi>B</mi></msub> <mo>=</mo> <msup><mi>B</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>b</mi></mrow></math> ). This requires
    a basis matrix *B* made up of *m* linearly independent columns of *A*;'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从多面体的一个顶点开始（基本可行解 *x*：零个非基本坐标和 <math alttext="x Subscript upper B Baseline equals
    upper B Superscript negative 1 Baseline b"><mrow><msub><mi>x</mi> <mi>B</mi></msub>
    <mo>=</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>b</mi></mrow></math>
    ）。这需要一个由 *A* 的 *m* 个线性无关列组成的基础矩阵 *B*；
- en: For example, if <math alttext="upper A equals Start 4 By 7 Matrix 1st Row 1st
    Column 1 2nd Column 1 3rd Column 2 4th Column 1 5th Column 0 6th Column 0 7th
    Column 0 2nd Row 1st Column 0 2nd Column 1 3rd Column 6 4th Column 0 5th Column
    1 6th Column 0 7th Column 0 3rd Row 1st Column 1 2nd Column 0 3rd Column 0 4th
    Column 0 5th Column 0 6th Column 1 7th Column 0 4th Row 1st Column 0 2nd Column
    1 3rd Column 0 4th Column 0 5th Column 0 6th Column 0 7th Column 1 EndMatrix"><mrow><mi>A</mi>
    <mo>=</mo> <mfenced close=")" open="("><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>6</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
    , and <math alttext="b equals Start 4 By 1 Matrix 1st Row  8 2nd Row  12 3rd Row  4
    4th Row  6 EndMatrix"><mrow><mi>b</mi> <mo>=</mo> <mfenced close=")" open="("><mtable><mtr><mtd><mn>8</mn></mtd></mtr>
    <mtr><mtd><mn>12</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>6</mn></mtd></mtr></mtable></mfenced></mrow></math>
    , then we can choose <math alttext="a 4 comma a 5 comma a 6 comma a 7"><mrow><msub><mi>a</mi>
    <mn>4</mn></msub> <mo>,</mo> <msub><mi>a</mi> <mn>5</mn></msub> <mo>,</mo> <msub><mi>a</mi>
    <mn>6</mn></msub> <mo>,</mo> <msub><mi>a</mi> <mn>7</mn></msub></mrow></math>
    as a set of basic columns, giving x=(0,0,0,8,12,4,6) as a basic feasible solution
    (coordinates of one vertex of the polyhedron). We can alternatively choose <math
    alttext="a 3 comma a 5 comma a 6 comma a 7"><mrow><msub><mi>a</mi> <mn>3</mn></msub>
    <mo>,</mo> <msub><mi>a</mi> <mn>5</mn></msub> <mo>,</mo> <msub><mi>a</mi> <mn>6</mn></msub>
    <mo>,</mo> <msub><mi>a</mi> <mn>7</mn></msub></mrow></math> as another set of
    basic columns, giving x=(0,0,4,0,-12,4,6) as basic solution but *not* basic feasible,
    because it has a negative coordinate.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果 <math alttext="upper A equals Start 4 By 7 Matrix 1st Row 1st Column 1
    2nd Column 1 3rd Column 2 4th Column 1 5th Column 0 6th Column 0 7th Column 0
    2nd Row 1st Column 0 2nd Column 1 3rd Column 6 4th Column 0 5th Column 1 6th Column
    0 7th Column 0 3rd Row 1st Column 1 2nd Column 0 3rd Column 0 4th Column 0 5th
    Column 0 6th Column 1 7th Column 0 4th Row 1st Column 0 2nd Column 1 3rd Column
    0 4th Column 0 5th Column 0 6th Column 0 7th Column 1 EndMatrix"><mrow><mi>A</mi>
    <mo>=</mo> <mfenced close=")" open="("><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>6</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
    ，以及 <math alttext="b equals Start 4 By 1 Matrix 1st Row  8 2nd Row  12 3rd Row  4
    4th Row  6 EndMatrix"><mrow><mi>b</mi> <mo>=</mo> <mfenced close=")" open="("><mtable><mtr><mtd><mn>8</mn></mtd></mtr>
    <mtr><mtd><mn>12</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>6</mn></mtd></mtr></mtable></mfenced></mrow></math>
    ，那么我们可以选择 <math alttext="a 4 comma a 5 comma a 6 comma a 7"><mrow><msub><mi>a</mi>
    <mn>4</mn></msub> <mo>,</mo> <msub><mi>a</mi> <mn>5</mn></msub> <mo>,</mo> <msub><mi>a</mi>
    <mn>6</mn></msub> <mo>,</mo> <msub><mi>a</mi> <mn>7</mn></msub></mrow></math>
    作为一组基本列，给出 x=(0,0,0,8,12,4,6) 作为基本可行解（多面体的一个顶点的坐标）。我们也可以选择 <math alttext="a 3
    comma a 5 comma a 6 comma a 7"><mrow><msub><mi>a</mi> <mn>3</mn></msub> <mo>,</mo>
    <msub><mi>a</mi> <mn>5</mn></msub> <mo>,</mo> <msub><mi>a</mi> <mn>6</mn></msub>
    <mo>,</mo> <msub><mi>a</mi> <mn>7</mn></msub></mrow></math> 作为另一组基本列，给出 x=(0,0,4,0,-12,4,6)
    作为基本解但*不是*基本可行解，因为它有一个负坐标。
- en: 'Move to another vertex <math alttext="y equals x plus theta Superscript asterisk
    Baseline d"><mrow><mi>y</mi> <mo>=</mo> <mi>x</mi> <mo>+</mo> <msup><mi>θ</mi>
    <mo>*</mo></msup> <mi>d</mi></mrow></math> in a feasible direction *d* that increases
    only one non-basic variable <math alttext="x Subscript j"><msub><mi>x</mi> <mi>j</mi></msub></math>
    and keeps the other non-basic variables at zero level (coordinates of *d*: <math
    alttext="d Subscript j Baseline equals 1"><mrow><msub><mi>d</mi> <mi>j</mi></msub>
    <mo>=</mo> <mn>1</mn></mrow></math> , <math alttext="d Subscript i Baseline equals
    0"><mrow><msub><mi>d</mi> <mi>i</mi></msub> <mo>=</mo> <mn>0</mn></mrow></math>
    if <math alttext="i not-equals j"><mrow><mi>i</mi> <mo>≠</mo> <mi>j</mi></mrow></math>
    or *i* non-basic, and <math alttext="d Subscript upper B Baseline equals minus
    upper B Superscript negative 1 Baseline upper A Subscript j"><mrow><msub><mi>d</mi>
    <mi>B</mi></msub> <mo>=</mo> <mo>-</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msub><mi>A</mi> <mi>j</mi></msub></mrow></math> ) that is guaranteed to reduce
    the cost (reduced cost associated with introducing <math alttext="x Subscript
    j"><msub><mi>x</mi> <mi>j</mi></msub></math> is <math alttext="c overbar Subscript
    j Baseline equals c Subscript j Baseline minus c Subscript upper B Baseline period
    upper B Superscript negative 1 Baseline upper A Subscript j Baseline"><mrow><msub><mover
    accent="true"><mi>c</mi> <mo>¯</mo></mover> <mi>j</mi></msub> <mo>=</mo> <msub><mi>c</mi>
    <mi>j</mi></msub> <mo>-</mo> <msub><mi>c</mi> <mi>B</mi></msub> <mo>.</mo> <msup><mi>B</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msub><mi>A</mi> <mi>j</mi></msub></mrow></math>
    , so choose a *j* for which this quantity is negative). Value of <math alttext="theta
    Superscript asterisk"><msup><mi>θ</mi> <mo>*</mo></msup></math>'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到另一个顶点<math alttext="y equals x plus theta Superscript asterisk Baseline d"><mrow><mi>y</mi>
    <mo>=</mo> <mi>x</mi> <mo>+</mo> <msup><mi>θ</mi> <mo>*</mo></msup> <mi>d</mi></mrow></math>，在一个可行方向*d*中，只增加一个非基本变量<math
    alttext="x Subscript j"><msub><mi>x</mi> <mi>j</mi></msub></math>，并将其他非基本变量保持在零水平（*d*的坐标：<math
    alttext="d Subscript j Baseline equals 1"><mrow><msub><mi>d</mi> <mi>j</mi></msub>
    <mo>=</mo> <mn>1</mn></mrow></math>，<math alttext="d Subscript i Baseline equals
    0"><mrow><msub><mi>d</mi> <mi>i</mi></msub> <mo>=</mo> <mn>0</mn></mrow></math>如果<math
    alttext="i 不等于 j"><mrow><mi>i</mi> <mo>≠</mo> <mi>j</mi></mrow></math>或*i*非基本，并且<math
    alttext="d Subscript upper B Baseline equals minus upper B Superscript negative
    1 Baseline upper A Subscript j"><mrow><msub><mi>d</mi> <mi>B</mi></msub> <mo>=</mo>
    <mo>-</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msub><mi>A</mi>
    <mi>j</mi></msub></mrow></math>），这是保证会降低成本的（引入<math alttext="x Subscript j"><msub><mi>x</mi>
    <mi>j</mi></msub></math>相关的减少成本为<math alttext="c overbar Subscript j Baseline
    equals c Subscript j Baseline minus c Subscript upper B Baseline period upper
    B Superscript negative 1 Baseline upper A Subscript j Baseline"><mrow><msub><mover
    accent="true"><mi>c</mi> <mo>¯</mo></mover> <mi>j</mi></msub> <mo>=</mo> <msub><mi>c</mi>
    <mi>j</mi></msub> <mo>-</mo> <msub><mi>c</mi> <mi>B</mi></msub> <mo>.</mo> <msup><mi>B</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msub><mi>A</mi> <mi>j</mi></msub></mrow></math>，因此选择一个*j*，使得这个数量为负）。<math
    alttext="theta Superscript asterisk"><msup><mi>θ</mi> <mo>*</mo></msup></math>的值
- en: <math alttext="dollar-sign theta Superscript asterisk Baseline equals min Underscript
    all basic indices for which d Subscript upper B left-parenthesis i right-parenthesis
    Baseline less-than 0 Endscripts left-brace minus StartFraction x Subscript upper
    B left-parenthesis i right-parenthesis Baseline Over d Subscript upper B left-parenthesis
    i right-parenthesis Baseline EndFraction right-brace colon equals minus StartFraction
    x Subscript upper B left-parenthesis l right-parenthesis Baseline Over d Subscript
    upper B left-parenthesis l right-parenthesis Baseline EndFraction semicolon dollar-sign"><mrow><msup><mi>θ</mi>
    <mo>*</mo></msup> <mo>=</mo> <msub><mo form="prefix" movablelimits="true">min</mo>
    <mrow><mtext>all</mtext><mtext>basic</mtext><mtext>indices</mtext><mtext>for</mtext><mtext>which</mtext><msub><mi>d</mi>
    <mrow><mi>B</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msub> <mo><</mo><mn>0</mn></mrow></msub>
    <mfenced close="}" open="{" separators=""><mo>-</mo> <mfrac><msub><mi>x</mi> <mrow><mi>B</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msub>
    <msub><mi>d</mi> <mrow><mi>B</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msub></mfrac></mfenced>
    <mo>:</mo> <mo>=</mo> <mo>-</mo> <mfrac><msub><mi>x</mi> <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub>
    <msub><mi>d</mi> <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub></mfrac>
    <mo>;</mo></mrow></math>
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign theta Superscript asterisk Baseline equals min Underscript
    all basic indices for which d Subscript upper B left-parenthesis i right-parenthesis
    Baseline less-than 0 Endscripts left-brace minus StartFraction x Subscript upper
    B left-parenthesis i right-parenthesis Baseline Over d Subscript upper B left-parenthesis
    i right-parenthesis Baseline EndFraction right-brace colon equals minus StartFraction
    x Subscript upper B left-parenthesis l right-parenthesis Baseline Over d Subscript
    upper B left-parenthesis l right-parenthesis Baseline EndFraction semicolon dollar-sign"><mrow><msup><mi>θ</mi>
    <mo>*</mo></msup> <mo>=</mo> <msub><mo form="prefix" movablelimits="true">min</mo>
    <mrow><mtext>all</mtext><mtext>basic</mtext><mtext>indices</mtext><mtext>for</mtext><mtext>which</mtext><msub><mi>d</mi>
    <mrow><mi>B</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msub> <mo><</mo><mn>0</mn></mrow></msub>
    <mfenced close="}" open="{" separators=""><mo>-</mo> <mfrac><msub><mi>x</mi> <mrow><mi>B</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msub>
    <msub><mi>d</mi> <mrow><mi>B</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msub></mfrac></mfenced>
    <mo>:</mo> <mo>=</mo> <mo>-</mo> <mfrac><msub><mi>x</mi> <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub>
    <msub><mi>d</mi> <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub></mfrac>
    <mo>;</mo></mrow></math>
- en: <math alttext="upper A Subscript upper B left-parenthesis l right-parenthesis"><msub><mi>A</mi>
    <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub></math> exits the
    basis *B* and <math alttext="upper A Subscript j"><msub><mi>A</mi> <mi>j</mi></msub></math>
    replaces it.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="upper A Subscript upper B left-parenthesis l right-parenthesis"><msub><mi>A</mi>
    <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub></math>退出基础*B*，并替换为<math
    alttext="upper A Subscript j"><msub><mi>A</mi> <mi>j</mi></msub></math>。
- en: Repeat until we either reach a finite optimal solution (when no <math alttext="upper
    A Subscript j"><msub><mi>A</mi> <mi>j</mi></msub></math> from all the available
    columns of *A* gives us a negative <math alttext="c Subscript j"><msub><mi>c</mi>
    <mi>j</mi></msub></math> ), or discover that the problem is unbounded and the
    optimal cost is <math alttext="negative normal infinity"><mrow><mo>-</mo> <mi>∞</mi></mrow></math>
    (this happens when we have <math alttext="d greater-than-or-equal-to 0"><mrow><mi>d</mi>
    <mo>≥</mo> <mn>0</mn></mrow></math> , so <math alttext="y equals x plus theta
    d greater-than-or-equal-to 0"><mrow><mi>y</mi> <mo>=</mo> <mi>x</mi> <mo>+</mo>
    <mi>θ</mi> <mi>d</mi> <mo>≥</mo> <mn>0</mn></mrow></math> making it feasible no
    matter how large <math alttext="theta"><mi>θ</mi></math> gets, thus pushing <math
    alttext="theta"><mi>θ</mi></math> to <math alttext="normal infinity"><mi>∞</mi></math>
    will keep reducing the cost <math alttext="c period y equals c period x plus theta
    left-parenthesis c Subscript j Baseline minus c Subscript upper B Baseline period
    upper B Superscript negative 1 Baseline upper A Subscript j Baseline right-parenthesis"><mrow><mi>c</mi>
    <mo>.</mo> <mi>y</mi> <mo>=</mo> <mi>c</mi> <mo>.</mo> <mi>x</mi> <mo>+</mo> <mi>θ</mi>
    <mo>(</mo> <msub><mi>c</mi> <mi>j</mi></msub> <mo>-</mo> <msub><mi>c</mi> <mi>B</mi></msub>
    <mo>.</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msub><mi>A</mi>
    <mi>j</mi></msub> <mo>)</mo></mrow></math> all the way to <math alttext="negative
    normal infinity"><mrow><mo>-</mo> <mi>∞</mi></mrow></math> ).
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复直到我们要么达到有限的最优解（当所有可用列的*A*中没有一个<math alttext="upper A Subscript j"><msub><mi>A</mi>
    <mi>j</mi></msub></math>给出负<c Subscript j><msub><mi>c</mi> <mi>j</mi></msub></math>），要么发现问题是无界的，最优成本是负无穷大（当我们有<math
    alttext="d 大于或等于 0"><mrow><mi>d</mi> <mo>≥</mo> <mn>0</mn></mrow></math>，所以<math
    alttext="y 等于 x 加 theta d 大于或等于 0"><mrow><mi>y</mi> <mo>=</mo> <mi>x</mi> <mo>+</mo>
    <mi>θ</mi> <mi>d</mi> <mo>≥</mo> <mn>0</mn></mrow></math>，无论θ取多大，这都是可行的，因此将θ推到<math
    alttext="normal infinity"><mi>∞</mi></math>将不断降低成本<math alttext="c period y equals
    c period x plus theta left-parenthesis c Subscript j Baseline minus c Subscript
    upper B Baseline period upper B Superscript negative 1 Baseline upper A Subscript
    j Baseline right-parenthesis"><mrow><mi>c</mi> <mo>.</mo> <mi>y</mi> <mo>=</mo>
    <mi>c</mi> <mo>.</mo> <mi>x</mi> <mo>+</mo> <mi>θ</mi> <mo>(</mo> <msub><mi>c</mi>
    <mi>j</mi></msub> <mo>-</mo> <msub><mi>c</mi> <mi>B</mi></msub> <mo>.</mo> <msup><mi>B</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msub><mi>A</mi> <mi>j</mi></msub> <mo>)</mo></mrow></math>一直到<math
    alttext="negative normal infinity"><mrow><mo>-</mo> <mi>∞</mi></mrow></math>）。
- en: Notes on the simplex method described above
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上述单纯形法的注记
- en: 'The last item above gives the two termination criteria for the simplex algorithm:
    No negative reduced cost <math alttext="c overbar Subscript j"><msub><mover accent="true"><mi>c</mi>
    <mo>¯</mo></mover> <mi>j</mi></msub></math> or all the coordinates of a feasible
    reducing cost direction *d* are nonnegative.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述最后一项给出了单纯形算法的两个终止标准：没有负的降低成本<math alttext="c overbar Subscript j"><msub><mover
    accent="true"><mi>c</mi> <mo>¯</mo></mover> <mi>j</mi></msub></math>或所有可行降低成本方向*d*的坐标都是非负的。
- en: If the feasible set is non-empty and every basic feasible solution is non-degenerate,
    then the simplex method is guaranteed to terminate after finitely many iterations,
    with either a finite optimal solution or a <math alttext="negative normal infinity"><mrow><mo>-</mo>
    <mi>∞</mi></mrow></math> optimal cost.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可行集非空且每个基本可行解都是非退化的，则单纯形法在有限次迭代后保证终止，要么得到有限最优解，要么得到一个有限的最优成本为负无穷的解。
- en: 'Suppose some of the basic feasible solutions are degenerate (some of the *basic*
    variables are also zero) and we end up at one of them. In this case, there is
    a chance that when we change the basis by introducing <math alttext="upper A Subscript
    j"><msub><mi>A</mi> <mi>j</mi></msub></math> and making <math alttext="upper A
    Subscript upper B left-parenthesis l right-parenthesis"><msub><mi>A</mi> <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub></math>
    exit, we stay at the same point *y=x+0d* (this happens when <math alttext="x Subscript
    upper B left-parenthesis l right-parenthesis Baseline equals 0"><mrow><msub><mi>x</mi>
    <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub> <mo>=</mo> <mn>0</mn></mrow></math>
    so <math alttext="theta Superscript asterisk Baseline equals minus StartFraction
    x Subscript upper B left-parenthesis l right-parenthesis Baseline Over d Subscript
    upper B left-parenthesis l right-parenthesis Baseline EndFraction equals 0"><mrow><msup><mi>θ</mi>
    <mo>*</mo></msup> <mo>=</mo> <mo>-</mo> <mfrac><msub><mi>x</mi> <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub>
    <msub><mi>d</mi> <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub></mfrac>
    <mo>=</mo> <mn>0</mn></mrow></math> )! In this case, choose a new <math alttext="upper
    A Subscript j"><msub><mi>A</mi> <mi>j</mi></msub></math> until you actually move
    from *x* to <math alttext="y equals x plus theta Superscript asterisk Baseline
    d"><mrow><mi>y</mi> <mo>=</mo> <mi>x</mi> <mo>+</mo> <msup><mi>θ</mi> <mo>*</mo></msup>
    <mi>d</mi></mrow></math> , <math alttext="theta Superscript asterisk Baseline
    greater-than 0"><mrow><msup><mi>θ</mi> <mo>*</mo></msup> <mo>></mo> <mn>0</mn></mrow></math>
    . One really bad thing that could happen here: After we stop at *x* and keep changing
    basis (stalling for a little while at *x*) until we find one that actually moves
    us away from *x* to <math alttext="y equals x plus theta Superscript asterisk
    Baseline d"><mrow><mi>y</mi> <mo>=</mo> <mi>x</mi> <mo>+</mo> <msup><mi>θ</mi>
    <mo>*</mo></msup> <mi>d</mi></mrow></math> in a cost reducing direction, we might
    end up with the same basis we started the algorithm with! This will lead to cycling
    and the algorithm may loop indefinitely. Cycling can be avoided by making smart
    choices on which columns of *A* will enter and exit the basis: Systematic way
    of choosing <math alttext="upper A Subscript j"><msub><mi>A</mi> <mi>j</mi></msub></math>
    and later *B(l)* in <math alttext="theta Superscript asterisk"><msup><mi>θ</mi>
    <mo>*</mo></msup></math> when there are ties in the process.'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设一些基本可行解是退化的（一些*基本*变量也为零），我们最终停留在其中一个。在这种情况下，当我们通过引入<math alttext="upper A
    Subscript j"><msub><mi>A</mi> <mi>j</mi></msub></math>并使<math alttext="upper A
    Subscript upper B left-parenthesis l right-parenthesis"><msub><mi>A</mi> <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub></math>退出来改变基础时，有可能停留在同一点*y=x+0d*（当<math
    alttext="x Subscript upper B left-parenthesis l right-parenthesis Baseline equals
    0"><mrow><msub><mi>x</mi> <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub>
    <mo>=</mo> <mn>0</mn></row></math>时，<math alttext="theta Superscript asterisk
    Baseline equals minus StartFraction x Subscript upper B left-parenthesis l right-parenthesis
    Baseline Over d Subscript upper B left-parenthesis l right-parenthesis Baseline
    EndFraction equals 0"><mrow><msup><mi>θ</mi> <mo>*</mo></msup> <mo>=</mo> <mo>-</mo>
    <mfrac><msub><mi>x</mi> <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub>
    <msub><mi>d</mi> <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub></mfrac>
    <mo>=</mo> <mn>0</mn></mrow></math>）！在这种情况下，选择一个新的<math alttext="upper A Subscript
    j"><msub><mi>A</mi> <mi>j</mi></msub></math>，直到实际从*x*移动到<math alttext="y equals
    x plus theta Superscript asterisk Baseline d"><mrow><mi>y</mi> <mo>=</mo> <mi>x</mi>
    <mo>+</mo> <msup><mi>θ</mi> <mo>*</mo></msup> <mi>d</mi></mrow></math>，<math alttext="theta
    Superscript asterisk Baseline greater-than 0"><mrow><msup><mi>θ</mi> <mo>*</mo></msup>
    <mo>></mo> <mn>0</mn></mrow></math>。这里可能发生的一个非常糟糕的事情是：在我们停在*x*并不断改变基础（在*x*处稍作停顿）直到找到一个实际将我们从*x*移开到<math
    alttext="y equals x plus theta Superscript asterisk Baseline d"><mrow><mi>y</mi>
    <mo>=</mo> <mi>x</mi> <mo>+</mo> <msup><mi>θ</mi> <mo>*</mo></msup> <mi>d</mi></mrow></math>的成本降低方向时，我们可能最终得到与算法开始时相同的基础！这将导致循环，并且算法可能无限循环。通过在*A*的哪些列将进入和退出基础上做出明智选择，可以避免循环：在过程中选择<math
    alttext="upper A Subscript j"><msub><mi>A</mi> <mi>j</mi></msub></math>和后来的*B(l)*的系统方法<math
    alttext="theta Superscript asterisk"><msup><mi>θ</mi> <mo>*</mo></msup></math>，当在过程中存在并列时。
- en: When there are ties in the process (we have more than one reducing cost option
    <math alttext="upper A Subscript j"><msub><mi>A</mi> <mi>j</mi></msub></math>
    that gives <math alttext="c overbar Subscript j Baseline less-than 0"><mrow><msub><mover
    accent="true"><mi>c</mi> <mo>¯</mo></mover> <mi>j</mi></msub> <mo><</mo> <mn>0</mn></mrow></math>
    , and/or more than one minimizing index *B(l)* for <math alttext="theta Superscript
    asterisk"><msup><mi>θ</mi> <mo>*</mo></msup></math> ) we can devise rules to choose
    entering <math alttext="upper A Subscript j"><msub><mi>A</mi> <mi>j</mi></msub></math>
    and/or exiting <math alttext="upper A Subscript upper B left-parenthesis l right-parenthesis"><msub><mi>A</mi>
    <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub></math> at a step
    with such tie. The choosing rules we decide to follow when there are such ties
    are called *pivoting* rules.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在过程中出现平局时（我们有多个减少成本选项 <math alttext="upper A Subscript j"><msub><mi>A</mi> <mi>j</mi></msub></math>，使得
    <math alttext="c overbar Subscript j Baseline less-than 0"><mrow><msub><mover
    accent="true"><mi>c</mi> <mo>¯</mo></mover> <mi>j</mi></msub> <mo><</mo> <mn>0</mn></mrow></math>，和/或有多个最小化索引
    *B(l)* 为 <math alttext="theta Superscript asterisk"><msup><mi>θ</mi> <mo>*</mo></msup></math>
    ），我们可以制定规则来选择在这种平局步骤中进入 <math alttext="upper A Subscript j"><msub><mi>A</mi> <mi>j</msub></math>
    和/或退出 <math alttext="upper A Subscript upper B left-parenthesis l right-parenthesis"><msub><mi>A</mi>
    <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub></math>。当出现这种平局时，我们决定遵循的选择规则称为*枢轴*规则。
- en: 'A very simple and computationally inexpensive pivoting rule is *Bland’s rule*:
    choose <math alttext="upper A Subscript j"><msub><mi>A</mi> <mi>j</mi></msub></math>
    with smallest index *j* for which <math alttext="c overbar Subscript j Baseline
    less-than 0"><mrow><msub><mover accent="true"><mi>c</mi> <mo>¯</mo></mover> <mi>j</mi></msub>
    <mo><</mo> <mn>0</mn></mrow></math> to enter the basis, and choose <math alttext="upper
    A Subscript upper B left-parenthesis l right-parenthesis"><msub><mi>A</mi> <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub></math>
    with smallest eligible index *B(l)* to exit the basis. This smallest subscript
    pivoting rule helps us avoid cycling. Another pivoting rule is *Lexicography*:
    see book page 108.'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布兰德规则是一种非常简单且计算成本低廉的枢轴规则：选择索引最小的 <math alttext="upper A Subscript j"><msub><mi>A</mi>
    <mi>j</mi></msub></math>，其中 <math alttext="c overbar Subscript j Baseline less-than
    0"><mrow><msub><mover accent="true"><mi>c</mi> <mo>¯</mo></mover> <mi>j</mi></msub>
    <mo><</mo> <mn>0</mn></mrow></math>，以进入基础，并选择具有最小合格索引 *B(l)* 的 <math alttext="upper
    A Subscript upper B left-parenthesis l right-parenthesis"><msub><mi>A</mi> <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub></math>
    以退出基础。这种最小下标枢轴规则有助于避免循环。另一种枢轴规则是*词典排序*：见书页108。
- en: If *n-m=2* (so *A* has only *2* more column than rows), then the simplex method
    will not cycle no matter which pivoting rule is used.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 *n-m=2*（因此 *A* 的列数比行数多 *2* 列），那么无论使用哪种枢轴规则，单纯形法都不会循环。
- en: '*Choosing an initial basis to start the simplex method*: For problems that
    did not originate from a general form problem, especially those with a large number
    of variables, it might not always be obvious how to choose the initial basis *B*
    and associated basic feasible solution *x* (because it wouldn’t be clear which
    *m* columns of *A* are linearly independent. In this case, we introduce *artificial
    variables* and solve an *auxiliary linear programming problem* in order to: determine
    whether the original problem is *infeasible* and hence their is no solution; or,
    if the problem is feasible, drive the artificial variables out of the basis and
    obtain an initial basis and associated basic feasible solution for our original
    problem. This process is called *Phase I* of the simplex method.'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*选择初始基础以开始单纯形法*：对于没有起源于一般形式问题的问题，特别是那些具有大量变量的问题，可能并不总是明显如何选择初始基础 *B* 和相关的基本可行解
    *x*（因为不清楚 *A* 的 *m* 列是线性独立的哪些列）。在这种情况下，我们引入*人工变量*并解决*辅助线性规划问题*，以确定原始问题是否*不可行*，因此没有解决方案；或者，如果问题是可行的，将人工变量驱使出基础，并为我们的原始问题获得初始基础和相关的基本可行解。这个过程称为单纯形法的*第一阶段*。'
- en: There is a method that combines Phase I and Phase II of the simplex method called
    *The big-M Method*. Here we use the simplex method to solve
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一种结合了单纯形法的第一阶段和第二阶段的方法称为*大M法*。在这里我们使用单纯形法来解决
- en: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column upper A x plus b equals 0 2nd Row 1st Column Blank 2nd Column x greater-than-or-equal-to
    0 comma y greater-than-or-equal-to 0 EndLayout Endscripts c period x plus upper
    M left-parenthesis y 1 plus y 2 plus period period period plus y Subscript m Baseline
    right-parenthesis dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo>
    <mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mi>A</mi><mi>x</mi><mo>+</mo><mi>b</mi><mo>=</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd
    columnalign="left"><mrow><mi>x</mi><mo>≥</mo><mn>0</mn><mo>,</mo><mi>y</mi><mo>≥</mo><mn>0</mn></mrow></mtd></mtr></mtable></msub>
    <mi>c</mi> <mo>.</mo> <mi>x</mi> <mo>+</mo> <mi>M</mi> <mrow><mo>(</mo> <msub><mi>y</mi>
    <mn>1</mn></msub> <mo>+</mo> <msub><mi>y</mi> <mn>2</mn></msub> <mo>+</mo> <mo>.</mo>
    <mo>.</mo> <mo>.</mo> <mo>+</mo> <msub><mi>y</mi> <mi>m</mi></msub> <mo>)</mo></mrow></mrow></math>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column upper A x plus b equals 0 2nd Row 1st Column Blank 2nd Column x greater-than-or-equal-to
    0 comma y greater-than-or-equal-to 0 EndLayout Endscripts c period x plus upper
    M left-parenthesis y 1 plus y 2 plus period period period plus y Subscript m Baseline
    right-parenthesis dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo>
    <mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mi>A</mi><mi>x</mi><mo>+</mo><mi>b</mi><mo>=</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd
    columnalign="left"><mrow><mi>x</mi><mo>≥</mo><mn>0</mn><mo>,</mo><mi>y</mi><mo>≥</mo><mn>0</mn></mrow></mtd></mtr></mtable></msub>
    <mi>c</mi> <mo>.</mo> <mi>x</mi> <mo>+</mo> <mi>M</mi> <mrow><mo>(</mo> <msub><mi>y</mi>
    <mn>1</mn></msub> <mo>+</mo> <msub><mi>y</mi> <mn>2</mn></msub> <mo>+</mo> <mo>.</mo>
    <mo>.</mo> <mo>.</mo> <mo>+</mo> <msub><mi>y</mi> <mi>m</mi></msub> <mo>)</mo></mrow></mrow></math>
- en: For sufficiently large choice of *M*, if the original problem is feasible and
    its optimal cost is finite, all of the artificial variables <math alttext="y 1
    comma y 2 comma ellipsis comma y Subscript m Baseline"><mrow><msub><mi>y</mi>
    <mn>1</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>2</mn></msub> <mo>,</mo> <mo>⋯</mo>
    <mo>,</mo> <msub><mi>y</mi> <mi>m</mi></msub></mrow></math> are eventually driven
    to zero which takes us back to our original problem. *M* can be treated as an
    undetermined parameter and let the reduced costs be functions of *M*, and treat
    *M* as a very large number when determining whether a reduced cost is negative.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于足够大的 *M* 选择，如果原始问题是可行的且其最优成本是有限的，所有人工变量 <math alttext="y 1 comma y 2 comma
    ellipsis comma y Subscript m Baseline"><mrow><msub><mi>y</mi> <mn>1</mn></msub>
    <mo>,</mo> <msub><mi>y</mi> <mn>2</mn></msub> <mo>,</mo> <mo>⋯</mo> <mo>,</mo>
    <msub><mi>y</mi> <mi>m</mi></msub></mrow></math> 最终会被驱使为零，这将使我们回到原始问题。*M* 可以被视为一个未确定的参数，并让减少的成本成为
    *M* 的函数，并在确定减少的成本是否为负时将 *M* 视为一个非常大的数。
- en: The Revised Simplex Method
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修订的单纯形法
- en: 'The revised simplex method is a computationally less expensive implementation.
    It provides a cheaper way to compute <math alttext="upper B overbar Superscript
    negative 1"><msup><mover accent="true"><mi>B</mi> <mo>¯</mo></mover> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    by exploiting the relationship between the old basis *B* and the new basis <math
    alttext="upper B overbar"><mover accent="true"><mi>B</mi> <mo>¯</mo></mover></math>
    : They only have one different column (the two vertices involved are adjacent).
    So we can obtain the new <math alttext="upper B overbar Superscript negative 1"><msup><mover
    accent="true"><mi>B</mi> <mo>¯</mo></mover> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    from the previous <math alttext="upper B Superscript negative 1"><msup><mi>B</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></math> .'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 修订后的单纯形法是一种计算成本较低的实现。它提供了一种更便宜的计算方法来计算<math alttext="upper B overbar Superscript
    negative 1"><msup><mover accent="true"><mi>B</mi> <mo>¯</mo></mover> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>，通过利用旧基础*B*和新基础<math
    alttext="upper B overbar"><mover accent="true"><mi>B</mi> <mo>¯</mo></mover></math>之间的关系：它们只有一个不同的列（涉及的两个顶点是相邻的）。因此，我们可以从先前的<math
    alttext="upper B Superscript negative 1"><msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>获得新的<math
    alttext="upper B overbar Superscript negative 1"><msup><mover accent="true"><mi>B</mi>
    <mo>¯</mo></mover> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>。
- en: 'This is a typical iteration of the revised simplex algorithm:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是修订后单纯形算法的典型迭代：
- en: Start with a *B* consisting of *m* basic columns from *A* and the associated
    basic feasible solution *x* with <math alttext="x Subscript upper B Baseline equals
    upper B Superscript negative 1 Baseline b"><mrow><msub><mi>x</mi> <mi>B</mi></msub>
    <mo>=</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>b</mi></mrow></math>
    and <math alttext="x Subscript i Baseline equals 0"><mrow><msub><mi>x</mi> <mi>i</mi></msub>
    <mo>=</mo> <mn>0</mn></mrow></math> otherwise.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*A*中包含*m*个基本列的*B*和相关的基本可行解*x*开始，其中<math alttext="x Subscript upper B Baseline
    equals upper B Superscript negative 1 Baseline b"><mrow><msub><mi>x</mi> <mi>B</mi></msub>
    <mo>=</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>b</mi></mrow></math>，否则<math
    alttext="x Subscript i Baseline equals 0"><mrow><msub><mi>x</mi> <mi>i</mi></msub>
    <mo>=</mo> <mn>0</mn></mrow></math>。
- en: Compute <math alttext="upper B Superscript negative 1"><msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    (it is <math alttext="upper B Superscript negative 1"><msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    not *B* that appears in the simplex method computations).
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算<math alttext="upper B Superscript negative 1"><msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>（在单纯形法计算中出现的是<math
    alttext="upper B Superscript negative 1"><msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>而不是*B*）。
- en: For *j* nonbasic, compute the reduced costs <math alttext="c overbar Subscript
    j Baseline equals c Subscript j Baseline minus c Subscript upper B Baseline period
    upper B Superscript negative 1 Baseline upper A Subscript j Baseline"><mrow><msub><mover
    accent="true"><mi>c</mi> <mo>¯</mo></mover> <mi>j</mi></msub> <mo>=</mo> <msub><mi>c</mi>
    <mi>j</mi></msub> <mo>-</mo> <msub><mi>c</mi> <mi>B</mi></msub> <mo>.</mo> <msup><mi>B</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msub><mi>A</mi> <mi>j</mi></msub></mrow></math>
    (this will give you *n-m* reduced costs).
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于非基本的*j*，计算减少成本<math alttext="c overbar Subscript j Baseline equals c Subscript
    j Baseline minus c Subscript upper B Baseline period upper B Superscript negative
    1 Baseline upper A Subscript j Baseline"><mrow><msub><mover accent="true"><mi>c</mi>
    <mo>¯</mo></mover> <mi>j</mi></msub> <mo>=</mo> <msub><mi>c</mi> <mi>j</mi></msub>
    <mo>-</mo> <msub><mi>c</mi> <mi>B</mi></msub> <mo>.</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msub><mi>A</mi> <mi>j</mi></msub></mrow></math>（这将给出*n-m*个减少成本）。
- en: If all the <math alttext="c overbar Subscript j"><msub><mover accent="true"><mi>c</mi>
    <mo>¯</mo></mover> <mi>j</mi></msub></math> are nonnegative, the current basic
    feasible solution *x* is optimal and the algorithm terminates with *x* as the
    optimizer and *c.x* as the optimal cost (there is no <math alttext="upper A Subscript
    j"><msub><mi>A</mi> <mi>j</mi></msub></math> that could enter the basis and reduce
    the cost even more).
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所有的<math alttext="c overbar Subscript j"><msub><mover accent="true"><mi>c</mi>
    <mo>¯</mo></mover> <mi>j</mi></msub></math>都是非负的，则当前的基本可行解*x*是最优的，算法以*x*作为优化器和*c.x*作为最优成本终止（没有<math
    alttext="upper A Subscript j"><msub><mi>A</mi> <mi>j</mi></msub></math>可以进入基础并进一步降低成本）。
- en: '*else*, choose a *j* for which <math alttext="c overbar Subscript j Baseline
    less-than 0"><mrow><msub><mover accent="true"><mi>c</mi> <mo>¯</mo></mover> <mi>j</mi></msub>
    <mo><</mo> <mn>0</mn></mrow></math> (Bland’s pivoting rule tells us to choose
    the smallest such *j*). *Note*: This makes <math alttext="upper A Subscript j"><msub><mi>A</mi>
    <mi>j</mi></msub></math> enter the basis.'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*否则*，选择一个*j*，使得<math alttext="c overbar Subscript j Baseline less-than 0"><mrow><msub><mover
    accent="true"><mi>c</mi> <mo>¯</mo></mover> <mi>j</mi></msub> <mo><</mo> <mn>0</mn></mrow></math>（Bland的枢轴规则告诉我们选择最小的*j*）。*注意*：这会使<math
    alttext="upper A Subscript j"><msub><mi>A</mi> <mi>j</mi></msub></math>进入基础。'
- en: 'Compute feasible direction *d*: <math alttext="d Subscript j Baseline equals
    1"><mrow><msub><mi>d</mi> <mi>j</mi></msub> <mo>=</mo> <mn>1</mn></mrow></math>
    , <math alttext="d Subscript upper B Baseline equals minus upper B Superscript
    negative 1 Baseline upper A Subscript j"><mrow><msub><mi>d</mi> <mi>B</mi></msub>
    <mo>=</mo> <mo>-</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msub><mi>A</mi> <mi>j</mi></msub></mrow></math> and <math alttext="d Subscript
    i Baseline equals 0"><mrow><msub><mi>d</mi> <mi>i</mi></msub> <mo>=</mo> <mn>0</mn></mrow></math>
    otherwise.'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算可行方向*d*：<math alttext="d Subscript j Baseline equals 1"><mrow><msub><mi>d</mi>
    <mi>j</mi></msub> <mo>=</mo> <mn>1</mn></mrow></math>，<math alttext="d Subscript
    upper B Baseline equals minus upper B Superscript negative 1 Baseline upper A
    Subscript j"><mrow><msub><mi>d</mi> <mi>B</mi></msub> <mo>=</mo> <mo>-</mo> <msup><mi>B</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msub><mi>A</mi> <mi>j</mi></msub></mrow></math>，否则<math
    alttext="d Subscript i Baseline equals 0"><mrow><msub><mi>d</mi> <mi>i</mi></msub>
    <mo>=</mo> <mn>0</mn></mrow></math>。
- en: If all the components of <math alttext="d Subscript upper B"><msub><mi>d</mi>
    <mi>B</mi></msub></math> are non-negative, the algorithm terminates with optimal
    cost <math alttext="negative normal infinity"><mrow><mo>-</mo> <mi>∞</mi></mrow></math>
    and no optimizer.
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果<math alttext="d Subscript upper B"><msub><mi>d</mi> <mi>B</mi></msub></math>的所有分量都是非负的，则算法以最优成本<math
    alttext="negative normal infinity"><mrow><mo>-</mo> <mi>∞</mi></mrow></math>终止，没有优化器。
- en: '*else* (choose the components of <math alttext="d Subscript upper B"><msub><mi>d</mi>
    <mi>B</mi></msub></math> that are negative), let'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*否则*（选择 <math alttext="d Subscript upper B"><msub><mi>d</mi> <mi>B</mi></msub></math>
    中为负数的分量），让'
- en: <math alttext="dollar-sign theta Superscript asterisk Baseline equals min Underscript
    all basic indices for which d Subscript upper B left-parenthesis i right-parenthesis
    Baseline less-than 0 Endscripts left-brace minus StartFraction x Subscript upper
    B left-parenthesis i right-parenthesis Baseline Over d Subscript upper B left-parenthesis
    i right-parenthesis Baseline EndFraction right-brace colon equals minus StartFraction
    x Subscript upper B left-parenthesis l right-parenthesis Baseline Over d Subscript
    upper B left-parenthesis l right-parenthesis Baseline EndFraction dollar-sign"><mrow><msup><mi>θ</mi>
    <mo>*</mo></msup> <mo>=</mo> <msub><mo form="prefix" movablelimits="true">min</mo>
    <mrow><mtext>all</mtext><mtext>basic</mtext><mtext>indices</mtext><mtext>for</mtext><mtext>which</mtext><msub><mi>d</mi>
    <mrow><mi>B</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msub> <mo><</mo><mn>0</mn></mrow></msub>
    <mfenced close="}" open="{" separators=""><mo>-</mo> <mfrac><msub><mi>x</mi> <mrow><mi>B</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msub>
    <msub><mi>d</mi> <mrow><mi>B</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msub></mfrac></mfenced>
    <mo>:</mo> <mo>=</mo> <mo>-</mo> <mfrac><msub><mi>x</mi> <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub>
    <msub><mi>d</mi> <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub></mfrac></mrow></math>
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign theta Superscript asterisk Baseline equals min Underscript
    all basic indices for which d Subscript upper B left-parenthesis i right-parenthesis
    Baseline less-than 0 Endscripts left-brace minus StartFraction x Subscript upper
    B left-parenthesis i right-parenthesis Baseline Over d Subscript upper B left-parenthesis
    i right-parenthesis Baseline EndFraction right-brace colon equals minus StartFraction
    x Subscript upper B left-parenthesis l right-parenthesis Baseline Over d Subscript
    upper B left-parenthesis l right-parenthesis Baseline EndFraction dollar-sign"><mrow><msup><mi>θ</mi>
    <mo>*</mo></msup> <mo>=</mo> <msub><mo form="prefix" movablelimits="true">min</mo>
    <mrow><mtext>all</mtext><mtext>basic</mtext><mtext>indices</mtext><mtext>for</mtext><mtext>which</mtext><msub><mi>d</mi>
    <mrow><mi>B</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msub> <mo><</mo><mn>0</mn></mrow></msub>
    <mfenced close="}" open="{" separators=""><mo>-</mo> <mfrac><msub><mi>x</mi> <mrow><mi>B</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msub>
    <msub><mi>d</mi> <mrow><mi>B</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msub></mfrac></mfenced>
    <mo>:</mo> <mo>=</mo> <mo>-</mo> <mfrac><msub><mi>x</mi> <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub>
    <msub><mi>d</mi> <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub></mfrac></mrow></math>
- en: This step computes <math alttext="theta Superscript asterisk"><msup><mi>θ</mi>
    <mo>*</mo></msup></math> and assigns *B(l)* as the index of the exiting column.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步计算 <math alttext="theta Superscript asterisk"><msup><mi>θ</mi> <mo>*</mo></msup></math>
    并将 *B(l)* 分配为退出列的索引。
- en: Compute the new basic feasible solution <math alttext="y equals x plus theta
    Superscript asterisk Baseline d"><mrow><mi>y</mi> <mo>=</mo> <mi>x</mi> <mo>+</mo>
    <msup><mi>θ</mi> <mo>*</mo></msup> <mi>d</mi></mrow></math> (this new basic feasible
    solution corresponds to the new basis <math alttext="upper B overbar"><mover accent="true"><mi>B</mi>
    <mo>¯</mo></mover></math> which has <math alttext="upper A Subscript j"><msub><mi>A</mi>
    <mi>j</mi></msub></math> replace <math alttext="upper A Subscript upper B left-parenthesis
    l right-parenthesis"><msub><mi>A</mi> <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub></math>
    in *B*).
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算新的基本可行解 <math alttext="y equals x plus theta Superscript asterisk Baseline
    d"><mrow><mi>y</mi> <mo>=</mo> <mi>x</mi> <mo>+</mo> <msup><mi>θ</mi> <mo>*</mo></msup>
    <mi>d</mi></mrow></math>（这个新的基本可行解对应于具有 <math alttext="upper B overbar"><mover
    accent="true"><mi>B</mi> <mo>¯</mo></mover></math> 的新基 <math alttext="upper A
    Subscript j"><msub><mi>A</mi> <mi>j</mi></msub></math> 替换 *B* 中的 <math alttext="upper
    A Subscript upper B left-parenthesis l right-parenthesis"><msub><mi>A</mi> <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub></math>）。
- en: This step computes the new <math alttext="upper B overbar Superscript negative
    1"><msup><mover accent="true"><mi>B</mi> <mo>¯</mo></mover> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    for the next iteration without forming the new basis <math alttext="upper B overbar"><mover
    accent="true"><mi>B</mi> <mo>¯</mo></mover></math> then inverting it.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一步计算下一次迭代的新 <math alttext="upper B overbar Superscript negative 1"><msup><mover
    accent="true"><mi>B</mi> <mo>¯</mo></mover> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>，而不形成新的基
    <math alttext="upper B overbar"><mover accent="true"><mi>B</mi> <mo>¯</mo></mover></math>
    然后对其进行求逆。
- en: Form the <math alttext="m times m plus 1"><mrow><mi>m</mi> <mo>×</mo> <mi>m</mi>
    <mo>+</mo> <mn>1</mn></mrow></math> augmented matrix <math alttext="left-parenthesis
    upper B Superscript negative 1 Baseline vertical-bar upper B Superscript negative
    1 Baseline upper A Subscript j Baseline right-parenthesis"><mrow><mo>(</mo> <msup><mi>B</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>|</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msub><mi>A</mi> <mi>j</mi></msub> <mo>)</mo></mrow></math> . Perform row operations
    using the *l*‘th row (add to each row a multiple of the *l*‘th row) to make the
    last column the unit vector <math alttext="e Subscript l"><msub><mi>e</mi> <mi>l</mi></msub></math>
    which is zero everywhere except for *1* in the *l*‘th coordinate. The first *m*
    columns of the result is your new <math alttext="upper B overbar Superscript negative
    1"><msup><mover accent="true"><mi>B</mi> <mo>¯</mo></mover> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    .
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 形成 <math alttext="m times m plus 1"><mrow><mi>m</mi> <mo>×</mo> <mi>m</mi> <mo>+</mo>
    <mn>1</mn></mrow></math> 增广矩阵 <math alttext="left-parenthesis upper B Superscript
    negative 1 Baseline vertical-bar upper B Superscript negative 1 Baseline upper
    A Subscript j Baseline right-parenthesis"><mrow><mo>(</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>|</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msub><mi>A</mi>
    <mi>j</mi></msub> <mo>)</mo></mrow></math>。使用 *l* 行执行行操作（向每行添加 *l* 行的倍数），使最后一列成为单位向量
    <math alttext="e Subscript l"><msub><mi>e</mi> <mi>l</mi></msub></math>，除了 *l*
    坐标处为 *1* 外，其他地方都是零。结果的前 *m* 列是你的新 <math alttext="upper B overbar Superscript negative
    1"><msup><mover accent="true"><mi>B</mi> <mo>¯</mo></mover> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>。
- en: Justification
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理由
- en: 'Let <math alttext="u equals upper B Superscript negative 1 Baseline upper A
    Subscript j"><mrow><mi>u</mi> <mo>=</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msub><mi>A</mi> <mi>j</mi></msub></mrow></math> and note that <math alttext="upper
    B Superscript negative 1 Baseline upper B overbar equals left-parenthesis e 1
    e 2 ellipsis u ellipsis e Subscript m Baseline right-parenthesis"><mrow><msup><mi>B</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mover accent="true"><mi>B</mi> <mo>¯</mo></mover>
    <mo>=</mo> <mrow><mo>(</mo> <msub><mi>e</mi> <mn>1</mn></msub> <msub><mi>e</mi>
    <mn>2</mn></msub> <mo>⋯</mo> <mi>u</mi> <mo>⋯</mo> <msub><mi>e</mi> <mi>m</mi></msub>
    <mo>)</mo></mrow></mrow></math> where <math alttext="e Subscript i"><msub><mi>e</mi>
    <mi>i</mi></msub></math> is the unit column vector with *1* in the *i*‘th entry
    and zero everywhere else, and *u* is the *l*‘th column. The above matrix becomes
    the identity matrix if we perform row operations using the *l*‘th row and transformed
    *u* into <math alttext="e Subscript l"><msub><mi>e</mi> <mi>l</mi></msub></math>
    . All row operations can be bundled together in an invertible matrix *Q* applied
    from the left: <math alttext="upper Q upper B Superscript negative 1 Baseline
    upper B overbar equals upper I"><mrow><mi>Q</mi> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mover accent="true"><mi>B</mi> <mo>¯</mo></mover> <mo>=</mo> <mi>I</mi></mrow></math>
    . Now right multiply by <math alttext="upper B overbar Superscript negative 1"><msup><mover
    accent="true"><mi>B</mi> <mo>¯</mo></mover> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    , we get <math alttext="upper Q upper B Superscript negative 1 Baseline equals
    upper B overbar Superscript negative 1"><mrow><mi>Q</mi> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <msup><mover accent="true"><mi>B</mi> <mo>¯</mo></mover> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
    . This means that to obtain <math alttext="upper B overbar Superscript negative
    1"><msup><mover accent="true"><mi>B</mi> <mo>¯</mo></mover> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    , perform on <math alttext="upper B Superscript negative 1"><msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    the same row operations that will transform *u* to <math alttext="e Subscript
    l"><msub><mi>e</mi> <mi>l</mi></msub></math> .'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让<u>等于上B的逆乘以上A的第j列</u>，注意到<上B的逆乘以上B横线等于（e1 e2 ... u ... em）>，其中<ei>是单位列向量，第i个元素为1，其他位置为0，u是第l列。如果我们使用第l行进行行操作，并将u转换为<el>，上述矩阵将变为单位矩阵。所有行操作可以打包在一个可逆矩阵Q中，从左边应用：<Q上B的逆乘以上B横线等于上I>。现在右乘以<上B横线的逆>，我们得到<Q上B的逆等于上B横线的逆>。这意味着要获得<上B横线的逆>，在<上B的逆>上执行相同的行操作，将u转换为<el>。
- en: Calculating <math alttext="upper B overbar Superscript negative 1"><msup><mover
    accent="true"><mi>B</mi> <mo>¯</mo></mover> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    using <math alttext="upper B Superscript negative 1"><msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    in the revised simplex
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用修正单纯形法计算<上B横线的逆>使用<上B的逆>
- en: This method does not start from the original *m* columns of *A* and finds the
    inverse, instead, it does row operations on previously calculated <math alttext="upper
    B Superscript negative 1"><msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    , which could include roundoff errors. Doing this over many iterations will accumulate
    these errors, so it will be better to compute <math alttext="upper B overbar Superscript
    negative 1"><msup><mover accent="true"><mi>B</mi> <mo>¯</mo></mover> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    straight from the columns of *A* every now and then to avoid error accumulation.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不是从原始A的m列开始找逆，而是在先前计算的<上B的逆>上进行行操作，这可能包括舍入误差。在许多迭代中这样做会积累这些错误，因此最好偶尔直接从A的列计算<上B横线的逆>，以避免错误积累。
- en: The Full Tableuax Implementation of the Simplex Method
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单纯形法的完整表格实现
- en: 'The **full tableaux implementation of the simplex method** has the advantage
    of only storing and updating one matrix:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 单纯形法的完整表格实现具有只存储和更新一个矩阵的优势：
- en: 'Here, instead of maintaining and updating <math alttext="upper B Superscript
    negative 1"><msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math> ,
    maintain and update the <math alttext="m times n plus 1"><mrow><mi>m</mi> <mo>×</mo>
    <mi>n</mi> <mo>+</mo> <mn>1</mn></mrow></math> matrix <math alttext="x Subscript
    upper B Baseline vertical-bar upper B Superscript negative 1 Baseline upper A
    right-parenthesis equals left-parenthesis upper B Superscript negative 1 Baseline
    b vertical-bar upper B Superscript negative 1 Baseline upper A"><mrow><msub><mi>x</mi>
    <mi>B</mi></msub> <mrow><mo>|</mo></mrow> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mrow><mi>A</mi> <mo>)</mo> <mo>=</mo> <mo>(</mo></mrow> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mrow><mi>b</mi> <mo>|</mo></mrow> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>A</mi></mrow></math> . The column <math alttext="u equals upper B Superscript
    negative 1 Baseline upper A Subscript j"><mrow><mi>u</mi> <mo>=</mo> <msup><mi>B</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msub><mi>A</mi> <mi>j</mi></msub></mrow></math>
    corresponding to the variable entering the basis is called the *pivot column*.
    If the *l* th basic variable exits the basis, then the *l* th row is called the
    *pivot row*. The element belonging to both the pivot row and the pivot column
    is called the *pivot element*. Now add a *zeroth row* on top of your *tableau*
    that keeps track of negative of the current cost <math alttext="negative c period
    x equals minus c Subscript upper B Baseline period x Subscript upper B Baseline
    equals c Subscript upper B Baseline period upper B Superscript negative 1 Baseline
    b"><mrow><mo>-</mo> <mi>c</mi> <mo>.</mo> <mi>x</mi> <mo>=</mo> <mo>-</mo> <msub><mi>c</mi>
    <mi>B</mi></msub> <mo>.</mo> <msub><mi>x</mi> <mi>B</mi></msub> <mo>=</mo> <msub><mi>c</mi>
    <mi>B</mi></msub> <mo>.</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>b</mi></mrow></math> and the reduced costs <math alttext="c minus c Subscript
    upper B Baseline period upper B Superscript negative 1 Baseline upper A"><mrow><mi>c</mi>
    <mo>-</mo> <msub><mi>c</mi> <mi>B</mi></msub> <mo>.</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>A</mi></mrow></math> . So the tableau looks like:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，不再维护和更新<math alttext="upper B Superscript negative 1"><msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>，而是维护和更新<math
    alttext="m times n plus 1"><mrow><mi>m</mi> <mo>×</mo> <mi>n</mi> <mo>+</mo> <mn>1</mn></mrow></math>矩阵<math
    alttext="x Subscript upper B Baseline vertical-bar upper B Superscript negative
    1 Baseline upper A right-parenthesis equals left-parenthesis upper B Superscript
    negative 1 Baseline b vertical-bar upper B Superscript negative 1 Baseline upper
    A"><mrow><msub><mi>x</mi> <mi>B</mi></msub> <mrow><mo>|</mo></mrow> <msup><mi>B</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mrow><mi>A</mi> <mo>)</mo> <mo>=</mo>
    <mo>(</mo></mrow> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mrow><mi>b</mi>
    <mo>|</mo></mrow> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>A</mi></mrow></math>。与进入基础的变量对应的列<math
    alttext="u equals upper B Superscript negative 1 Baseline upper A Subscript j"><mrow><mi>u</mi>
    <mo>=</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msub><mi>A</mi>
    <mi>j</mi></msub></mrow></math>被称为*pivot column*。如果第*l*个基本变量退出基础，那么第*l*行被称为*pivot
    row*。属于pivot row和pivot column的元素被称为*pivot element*。现在在你的*tableau*顶部添加一个*zeroth
    row*，用于跟踪当前成本的负值<math alttext="negative c period x equals minus c Subscript upper
    B Baseline period x Subscript upper B Baseline equals c Subscript upper B Baseline
    period upper B Superscript negative 1 Baseline b"><mrow><mo>-</mo> <mi>c</mi>
    <mo>.</mo> <mi>x</mi> <mo>=</mo> <mo>-</mo> <msub><mi>c</mi> <mi>B</mi></msub>
    <mo>.</mo> <msub><mi>x</mi> <mi>B</mi></msub> <mo>=</mo> <msub><mi>c</mi> <mi>B</mi></msub>
    <mo>.</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>b</mi></mrow></math>和减少的成本<math
    alttext="c minus c Subscript upper B Baseline period upper B Superscript negative
    1 Baseline upper A"><mrow><mi>c</mi> <mo>-</mo> <msub><mi>c</mi> <mi>B</mi></msub>
    <mo>.</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>A</mi></mrow></math>。因此，tableau看起来像：
- en: <math alttext="dollar-sign Start 2 By 2 Matrix 1st Row 1st Column minus c Subscript
    upper B Baseline period upper B Superscript negative 1 Baseline b 2nd Column c
    minus c Subscript upper B Baseline period upper B Superscript negative 1 Baseline
    upper A 2nd Row 1st Column upper B Superscript negative 1 Baseline b 2nd Column
    upper B Superscript negative 1 Baseline upper A EndMatrix dollar-sign"><mfenced
    close=")" open="("><mtable><mtr><mtd><mrow><mo>-</mo> <msub><mi>c</mi> <mi>B</mi></msub>
    <mo>.</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>b</mi></mrow></mtd>
    <mtd><mrow><mi>c</mi> <mo>-</mo> <msub><mi>c</mi> <mi>B</mi></msub> <mo>.</mo>
    <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>A</mi></mrow></mtd></mtr>
    <mtr><mtd><mrow><msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>b</mi></mrow></mtd>
    <mtd><mrow><msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>A</mi></mrow></mtd></mtr></mtable></mfenced></math>
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign Start 2 By 2 Matrix 1st Row 1st Column minus c Subscript
    upper B Baseline period upper B Superscript negative 1 Baseline b 2nd Column c
    minus c Subscript upper B Baseline period upper B Superscript negative 1 Baseline
    upper A 2nd Row 1st Column upper B Superscript negative 1 Baseline b 2nd Column
    upper B Superscript negative 1 Baseline upper A EndMatrix dollar-sign"><mfenced
    close=")" open="("><mtable><mtr><mtd><mrow><mo>-</mo> <msub><mi>c</mi> <mi>B</mi></msub>
    <mo>.</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>b</mi></mrow></mtd>
    <mtd><mrow><mi>c</mi> <mo>-</mo> <msub><mi>c</mi> <mi>B</mi></msub> <mo>.</mo>
    <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>A</mi></mrow></mtd></mtr>
    <mtr><mtd><mrow><msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>b</mi></mrow></mtd>
    <mtd><mrow><msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>A</mi></mrow></mtd></mtr></mtable></mfenced></math>
- en: 'or more expanded:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更详细：
- en: <math alttext="dollar-sign Start 4 By 2 Matrix 1st Row 1st Column minus c Subscript
    upper B Baseline period x Subscript upper B Baseline 2nd Column c overbar Subscript
    1 Baseline ellipsis c overbar Subscript n 2nd Row 1st Column x Subscript upper
    B left-parenthesis 1 right-parenthesis 2nd Column StartAbsoluteValue ellipsis
    EndAbsoluteValue 3rd Row 1st Column  ellipsis 2nd Column upper B Superscript negative
    1 Baseline upper A 1 ellipsis upper B Superscript negative 1 Baseline upper A
    Subscript n 4th Row 1st Column x Subscript upper B left-parenthesis m right-parenthesis
    2nd Column StartAbsoluteValue ellipsis EndAbsoluteValue EndMatrix dollar-sign"><mfenced
    close=")" open="("><mtable><mtr><mtd><mrow><mo>-</mo> <msub><mi>c</mi> <mi>B</mi></msub>
    <mo>.</mo> <msub><mi>x</mi> <mi>B</mi></msub></mrow></mtd> <mtd><mrow><msub><mover
    accent="true"><mi>c</mi> <mo>¯</mo></mover> <mn>1</mn></msub> <mo>⋯</mo> <msub><mover
    accent="true"><mi>c</mi> <mo>¯</mo></mover> <mi>n</mi></msub></mrow></mtd></mtr>
    <mtr><mtd><msub><mi>x</mi> <mrow><mi>B</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow></msub></mtd>
    <mtd><mrow><mo>|</mo> <mo>⋯</mo> <mo>|</mo></mrow></mtd></mtr> <mtr><mtd><mo>⋮</mo></mtd>
    <mtd><mrow><msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msub><mi>A</mi>
    <mn>1</mn></msub> <mo>⋯</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msub><mi>A</mi> <mi>n</mi></msub></mrow></mtd></mtr> <mtr><mtd><msub><mi>x</mi>
    <mrow><mi>B</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow></msub></mtd> <mtd><mrow><mo>|</mo>
    <mo>⋯</mo> <mo>|</mo></mrow></mtd></mtr></mtable></mfenced></math>
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign Start 4 By 2 Matrix 1st Row 1st Column minus c Subscript
    upper B Baseline period x Subscript upper B Baseline 2nd Column c overbar Subscript
    1 Baseline ellipsis c overbar Subscript n 2nd Row 1st Column x Subscript upper
    B left-parenthesis 1 right-parenthesis 2nd Column StartAbsoluteValue ellipsis
    EndAbsoluteValue 3rd Row 1st Column  ellipsis 2nd Column upper B Superscript negative
    1 Baseline upper A 1 ellipsis upper B Superscript negative 1 Baseline upper A
    Subscript n 4th Row 1st Column x Subscript upper B left-parenthesis m right-parenthesis
    2nd Column StartAbsoluteValue ellipsis EndAbsoluteValue EndMatrix dollar-sign"><mfenced
    close=")" open="("><mtable><mtr><mtd><mrow><mo>-</mo> <msub><mi>c</mi> <mi>B</mi></msub>
    <mo>.</mo> <msub><mi>x</mi> <mi>B</mi></msub></mrow></mtd> <mtd><mrow><msub><mover
    accent="true"><mi>c</mi> <mo>¯</mo></mover> <mn>1</mn></msub> <mo>⋯</mo> <msub><mover
    accent="true"><mi>c</mi> <mo>¯</mo></mover> <mi>n</mi></msub></mrow></mtd></mtr>
    <mtr><mtd><msub><mi>x</mi> <mrow><mi>B</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow></msub></mtd>
    <mtd><mrow><mo>|</mo> <mo>⋯</mo> <mo>|</mo></mrow></mtd></mtr> <mtr><mtd><mo>⋮</mo></mtd>
    <mtd><mrow><msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msub><mi>A</mi>
    <mn>1</mn></msub> <mo>⋯</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msub><mi>A</mi> <mi>n</mi></msub></mrow></mtd></mtr> <mtr><mtd><msub><mi>x</mi>
    <mrow><mi>B</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow></msub></mtd> <mtd><mrow><mo>|</mo>
    <mo>⋯</mo> <mo>|</mo></mrow></mtd></mtr></mtable></mfenced></math>
- en: 'This is a typical iteration of the full tableau implementation:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整tableau实现的典型迭代：
- en: Start with a tableau associated with a basis matrix *B* and the corresponding
    basic feasible solution *x* (with <math alttext="x Subscript upper B Baseline
    equals upper B Superscript negative 1 Baseline b"><mrow><msub><mi>x</mi> <mi>B</mi></msub>
    <mo>=</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>b</mi></mrow></math>
    and rest of coordinates zero).
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从与基础矩阵*B*和相应的基本可行解*x*相关联的tableau开始（其中<math alttext="x Subscript upper B Baseline
    equals upper B Superscript negative 1 Baseline b"><mrow><msub><mi>x</mi> <mi>B</mi></msub>
    <mo>=</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>b</mi></mrow></math>和其余坐标为零）。
- en: Examine the reduced costs in the zeroth row of the tableau. If none of them
    is negative, then the current basic feasible solution *x* is optimal and the algorithm
    terminates. *Else*, choose some *j* for which <math alttext="c overbar Subscript
    j Baseline less-than 0"><mrow><msub><mover accent="true"><mi>c</mi> <mo>¯</mo></mover>
    <mi>j</mi></msub> <mo><</mo> <mn>0</mn></mrow></math> (this *j* tells you which
    <math alttext="upper A Subscript j"><msub><mi>A</mi> <mi>j</mi></msub></math>
    entered the basis and you have your pivot column <math alttext="u equals upper
    B Superscript negative 1 Baseline upper A Subscript j"><mrow><mi>u</mi> <mo>=</mo>
    <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msub><mi>A</mi> <mi>j</mi></msub></mrow></math>
    ).
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查tableau的零行中的减少成本。如果它们都不是负数，则当前的基本可行解*x*是最优的，算法终止。*否则*，选择一些*j*，使得<math alttext="c
    overbar Subscript j Baseline less-than 0"><mrow><msub><mover accent="true"><mi>c</mi>
    <mo>¯</mo></mover> <mi>j</mi></msub> <mo><</mo> <mn>0</mn></mrow></math>（这个*j*告诉您哪个<math
    alttext="upper A Subscript j"><msub><mi>A</mi> <mi>j</mi></msub></math>进入了基础，您有了pivot
    column<math alttext="u equals upper B Superscript negative 1 Baseline upper A
    Subscript j"><mrow><mi>u</mi> <mo>=</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msub><mi>A</mi> <mi>j</mi></msub></mrow></math>）。
- en: Examine the pivot column <math alttext="u equals upper B Superscript negative
    1 Baseline upper A Subscript j"><mrow><mi>u</mi> <mo>=</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msub><mi>A</mi> <mi>j</mi></msub></mrow></math> . If all the components of *u*
    are negative, the optimal cost is <math alttext="negative normal infinity"><mrow><mo>-</mo>
    <mi>∞</mi></mrow></math> and the algorithm terminates. *Else*, for each positive
    component <math alttext="u Subscript i"><msub><mi>u</mi> <mi>i</mi></msub></math>
    , compute <math alttext="StartFraction x Subscript upper B left-parenthesis i
    right-parenthesis Baseline Over u Subscript i Baseline EndFraction"><mfrac><msub><mi>x</mi>
    <mrow><mi>B</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msub> <msub><mi>u</mi>
    <mi>i</mi></msub></mfrac></math> , choose the smallest ratio and let *l* be the
    index of the row that corresponds to the smallest ratio. This is your pivot row.
    (So what’s happening now is <math alttext="upper A Subscript upper B left-parenthesis
    l right-parenthesis"><msub><mi>A</mi> <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub></math>
    is exiting the basis and <math alttext="upper A Subscript j"><msub><mi>A</mi>
    <mi>j</mi></msub></math> is entering the basis, but none of this is explicitly
    shown here, since the columns of the tableau stay in the same place at all steps,
    it’s only a mental note.)
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查主列 <math alttext="u equals upper B Superscript negative 1 Baseline upper A
    Subscript j"><mrow><mi>u</mi> <mo>=</mo> <msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msub><mi>A</mi> <mi>j</mi></msub></mrow></math>。如果*u*的所有分量都是负数，则最优成本为 <math alttext="negative
    normal infinity"><mrow><mo>-</mo> <mi>∞</mi></mrow></math>，算法终止。*否则*，对于每个正分量 <math
    alttext="u Subscript i"><msub><mi>u</mi> <mi>i</mi></msub></math>，计算 <math alttext="StartFraction
    x Subscript upper B left-parenthesis i right-parenthesis Baseline Over u Subscript
    i Baseline EndFraction"><mfrac><msub><mi>x</mi> <mrow><mi>B</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msub>
    <msub><mi>u</mi> <mi>i</mi></msub></mfrac></math>，选择最小比率，让*l*成为对应最小比率的行的索引。这就是你的主行。（所以现在发生的是
    <math alttext="upper A Subscript upper B left-parenthesis l right-parenthesis"><msub><mi>A</mi>
    <mrow><mi>B</mi><mo>(</mo><mi>l</mi><mo>)</mo></mrow></msub></math> 离开基础，<math
    alttext="upper A Subscript j"><msub><mi>A</mi> <mi>j</mi></msub></math> 进入基础，但这里没有明确显示，因为表的列在所有步骤中保持不变，这只是一个心理提示。）
- en: Now use the pivot row to perform row operations in order to change the pivot
    column to <math alttext="e Subscript l"><msub><mi>e</mi> <mi>l</mi></msub></math>
    (the pivot element becomes one and all the other entries in the pivot column zero).
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用主行执行行操作，以将主列更改为 <math alttext="e Subscript l"><msub><mi>e</mi> <mi>l</mi></msub></math>（主元变为一，主列中的所有其他条目变为零）。
- en: Now you have a new tableau with new <math alttext="x Subscript upper B"><msub><mi>x</mi>
    <mi>B</mi></msub></math> at the zeroth column, new negative of optimal cost at
    the upper left corner, new basis <math alttext="upper B overbar"><mover accent="true"><mi>B</mi>
    <mo>¯</mo></mover></math> not explicitly written but instead given in terms of
    <math alttext="upper B overbar Superscript negative 1 Baseline upper A"><mrow><msup><mover
    accent="true"><mi>B</mi> <mo>¯</mo></mover> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>A</mi></mrow></math> in the body of the tableau. So go back to step (a) until
    the algorithm terminates.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你有一个新的表，新的 <math alttext="x Subscript upper B"><msub><mi>x</mi> <mi>B</mi></msub></math>
    在第零列，新的最优成本的负值在左上角，新的基础 <math alttext="upper B overbar"><mover accent="true"><mi>B</mi>
    <mo>¯</mo></mover></math> 没有明确写出，而是用 <math alttext="upper B overbar Superscript
    negative 1 Baseline upper A"><mrow><msup><mover accent="true"><mi>B</mi> <mo>¯</mo></mover>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>A</mi></mrow></math> 的形式给出在表的正文中。所以回到步骤(a)直到算法终止。
- en: Most efficient implementation is the revised simplex (memory usage is <math
    alttext="upper O left-parenthesis m squared right-parenthesis"><mrow><mi>O</mi>
    <mo>(</mo> <msup><mi>m</mi> <mn>2</mn></msup> <mo>)</mo></mrow></math> , worst
    case time for single iteration is <math alttext="upper O left-parenthesis m n
    right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <mi>m</mi> <mi>n</mi> <mo>)</mo></mrow></math>
    , best case time for single iteration is <math alttext="upper O left-parenthesis
    m squared right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>m</mi> <mn>2</mn></msup>
    <mo>)</mo></mrow></math> while all the above measures for the full tableau method
    are <math alttext="upper O left-parenthesis m n right-parenthesis"><mrow><mi>O</mi>
    <mo>(</mo> <mi>m</mi> <mi>n</mi> <mo>)</mo></mrow></math> ), but that also depends
    on how sparse the matrices are.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最有效的实现是修正单纯形法（内存使用为 <math alttext="upper O left-parenthesis m squared right-parenthesis"><mrow><mi>O</mi>
    <mo>(</mo> <msup><mi>m</mi> <mn>2</mn></msup> <mo>)</mo></mrow></math>，单次迭代的最坏情况时间为
    <math alttext="upper O left-parenthesis m n right-parenthesis"><mrow><mi>O</mi>
    <mo>(</mo> <mi>m</mi> <mi>n</mi> <mo>)</mo></mrow></math>，单次迭代的最佳情况时间为 <math alttext="upper
    O left-parenthesis m squared right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>m</mi>
    <mn>2</mn></msup> <mo>)</mo></mrow></math>，而全表法的上述所有度量都是 <math alttext="upper
    O left-parenthesis m n right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <mi>m</mi>
    <mi>n</mi> <mo>)</mo></mrow></math>），但这也取决于矩阵的稀疏程度。
- en: 'One helpful thing that is nice to master: Extracting <math alttext="upper B
    Superscript negative 1"><msup><mi>B</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    and *B* easily from a given simplex tableau (like in the movie: *The Matrix*).'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的技巧是很好掌握的：从给定的单纯形表中提取 <math alttext="upper B Superscript negative 1"><msup><mi>B</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></math> 和 *B*（就像在电影中：*黑客帝国*）。
- en: 'Examples: Transportation and assignment problems'
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：运输和分配问题
- en: We mentioned the transportation and assignment problems in the network section
    since they are linear optimization problems which we can formulate as min cost
    network flow problems.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络部分我们提到了运输和分配问题，因为它们是线性优化问题，可以将其制定为最小成本网络流问题。
- en: 'Transportation problem: Allocating products to warehouses, minimize costs.
    Assignment problem: Allocate assignees to tasks, number of assignees is equal
    to the number of tasks, and each assignee performs one task. There is a cost when
    assignee i performs task j. The objective is to select an assignment that minimizes
    the cost. One example is assigning Uber drivers to customers, or machines to tasks.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 运输问题：将产品分配给仓库，最小化成本。分配问题：将被分配者分配给任务，被分配者的数量等于任务的数量，并且每个被分配者执行一个任务。当被分配者i执行任务j时会产生成本。目标是选择一种分配方式以最小化成本。一个例子是将Uber司机分配给顾客，或将机器分配给任务。
- en: We exploit the fact that the involved matrices are sparse so we don’t have to
    do full implementation of the simplex algorithm, only a special *streamlined*
    version, which solves both the assignment and transportation problems. This is
    related to the *network simplex method* which solves any minimum cost flow problem,
    including both transportation and assignment problems. The transportation and
    assignment problems are special cases of the minimum flow problem. The Hungarian
    method is special for the assignment problem. Since it is specialized for it,
    it is more efficient. These special purpose algorithms are included in some linear
    programming software packages.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用所涉及的矩阵是稀疏的这一事实，因此我们不必完全实现单纯形算法，只需一个特殊的*简化*版本，可以同时解决分配和运输问题。这与*网络单纯形方法*有关，它解决任何最小成本流问题，包括运输和分配问题。运输和分配问题是最小流问题的特例。匈牙利方法是分配问题的特例。由于它专门为此而设计，因此更有效率。这些专用算法包含在一些线性规划软件包中。
- en: Duality, Langrange Relaxation, Shadow Prices, Max Mins, Min Maxs, And All That
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对偶性，拉格朗日松弛，影子价格，最大最小值，最小最大值，以及其他一切
- en: We hinted and danced around the idea of *duality* earlier in this chapter when
    discussing finite dimensional constrained optimization and relaxing the constraints
    using Lagrange multipliers. Duality is really helpful when our constrained problems
    are linear, or quadratic with linear constraints. It gives us the option to either
    solve the optimization problem at hand (the *primal*) or another related problem
    (its *dual*), whichever happens to be easier or less expensive, and get the same
    solution. Usually, having more decision variables (dimensions of the problem)
    is not as strenuous for an algorithm as having more constraints. Since the dual
    problem flips the roles of decision variables and constraints, then solving it
    instead of the primal problem makes more sense when we have too many constraints
    (another way here is using the dual simplex method to solve the primal problem
    which we will talk about soon). Another way the dual problem helps is that it
    sometimes provides shortcuts to the solution of the primal problem. A feasible
    vector <math alttext="ModifyingAbove x With right-arrow"><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover></math> to the primal problem will end up being the optimizer
    if there happens to be a feasible vector <math alttext="ModifyingAbove p With
    right-arrow"><mover accent="true"><mi>p</mi> <mo>→</mo></mover></math> to the
    dual problem such that <math alttext="ModifyingAbove c With right-arrow period
    ModifyingAbove x With right-arrow equals ModifyingAbove p With right-arrow period
    ModifyingAbove b With right-arrow"><mrow><mover accent="true"><mi>c</mi> <mo>→</mo></mover>
    <mo>.</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>=</mo> <mover
    accent="true"><mi>p</mi> <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>b</mi>
    <mo>→</mo></mover></mrow></math> .
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早些时候讨论有限维约束优化和使用拉格朗日乘数放松约束时，我们已经暗示并围绕*对偶性*的概念打转。当我们的约束问题是线性的，或者具有线性约束的二次型时，对偶性真的很有帮助。它给了我们两种选择：要么解决手头的优化问题（*原始*），要么解决另一个相关的问题（*对偶*），无论哪个更容易或更便宜，都会得到相同的解决方案。通常，对于算法来说，拥有更多的决策变量（问题的维度）不像拥有更多的约束那样费力。由于对偶问题颠倒了决策变量和约束的角色，所以当我们有太多约束时，解决对偶问题而不是原始问题更有意义（另一种方法是使用对偶单纯形方法来解决我们即将讨论的原始问题）。对偶问题有助于解决原始问题的另一种方式是，它有时提供了解决原始问题的捷径。如果原始问题存在一个可行向量<math
    alttext="ModifyingAbove x With right-arrow"><mover accent="true"><mi>x</mi> <mo>→</mo></mover></math>，那么如果对偶问题存在一个可行向量<math
    alttext="ModifyingAbove p With right-arrow"><mover accent="true"><mi>p</mi> <mo>→</mo></mover></math>，使得<math
    alttext="ModifyingAbove c With right-arrow period ModifyingAbove x With right-arrow
    equals ModifyingAbove p With right-arrow period ModifyingAbove b With right-arrow"><mrow><mover
    accent="true"><mi>c</mi> <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>=</mo> <mover accent="true"><mi>p</mi> <mo>→</mo></mover>
    <mo>.</mo> <mover accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></math>，那么这个向量将成为优化器。
- en: 'When learning about duality in the next few paragraphs, think of it in the
    same way you see [Figure 10-8](#Fig_duality): Something is happening in the primal
    realm, some form of related shadow or echo is happening in the dual realm (some
    alternate universe), and the two meet at the optimizer, like a gate that the two
    universes meet at.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几段中学习对偶性时，将其视为您在[图10-8](#Fig_duality)中看到的方式：在原始领域中发生了某种事情，在对偶领域中发生了某种相关的影子或回声（某种替代宇宙），两者在优化器处相遇，就像两个宇宙相遇的门。
- en: '![250](assets/emai_1008.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![250](assets/emai_1008.png)'
- en: Figure 10-8\. Duality, shadow problems, shadow prices (I want an uncopy righted
    graphic that looks like this one).
  id: totrans-260
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-8。对偶性，影子问题，影子价格（我想要一个看起来像这个的未受版权保护的图形）。
- en: So if we are maximizing in one universe, we are minimizing in the other, if
    we are doing something with the constraints in one universe, we do something to
    the decision variables in the other and vice versa.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们在一个宇宙中最大化，那么在另一个宇宙中我们在最小化，如果我们在一个宇宙中对约束进行某些操作，那么我们在另一个宇宙中对决策变量进行某些操作，反之亦然。
- en: Motivation For Duality- Lagrange Multipliers
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对偶性的动机-拉格朗日乘数
- en: For any optimization problem (linear or nonlinear)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何优化问题（线性或非线性）
- en: <math alttext="dollar-sign min Underscript ModifyingAbove x With right-arrow
    element-of feasible set Endscripts f left-parenthesis ModifyingAbove x With right-arrow
    right-parenthesis comma dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo>
    <mrow><mover accent="true"><mi>x</mi> <mo>→</mo></mover><mo>∈</mo><mtext>feasible</mtext><mtext>set</mtext></mrow></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mo>,</mo></mrow></math>
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript ModifyingAbove x With right-arrow
    element-of feasible set Endscripts f left-parenthesis ModifyingAbove x With right-arrow
    right-parenthesis comma dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo>
    <mrow><mover accent="true"><mi>x</mi> <mo>→</mo></mover><mo>∈</mo><mtext>feasible</mtext><mtext>set</mtext></mrow></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mo>,</mo></mrow></math>
- en: instead of finding the minimizer <math alttext="ModifyingAbove x With right-arrow
    Superscript asterisk"><msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>*</mo></msup></math> by setting the gradient equal to zero, look for an upper
    bound of <math alttext="f left-parenthesis ModifyingAbove x With right-arrow Superscript
    asterisk Baseline right-parenthesis"><mrow><mi>f</mi> <mo>(</mo> <msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mo>)</mo></mrow></math>
    (easy by plugging any element of the feasible set into <math alttext="f left-parenthesis
    ModifyingAbove x With right-arrow right-parenthesis"><mrow><mi>f</mi> <mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow></math> ),
    and for a lower bound of <math alttext="f left-parenthesis ModifyingAbove x With
    right-arrow Superscript asterisk Baseline right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup>
    <mo>)</mo></mrow></math> (this is a harder inequality and usually requires clever
    ideas). Now we would have *lower bound* <math alttext="f left-parenthesis ModifyingAbove
    x With right-arrow Superscript asterisk Baseline right-parenthesis less-than-or-equal-to"><mrow><mo>≤</mo>
    <mi>f</mi> <mo>(</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>*</mo></msup> <mo>)</mo> <mo>≤</mo></mrow></math> *upper bound*, so we *tighten*
    these bounds to get closer to the actual solution <math alttext="f left-parenthesis
    ModifyingAbove x With right-arrow Superscript asterisk Baseline right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup>
    <mo>)</mo></mrow></math> . We tighten the bounds by minimizing the upper bounds
    (this brings us back to the original minimization problem), and *maximizing the
    lower bounds* (this establishes the dual problem).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 不要通过将梯度设为零来找到最小化器<math alttext="ModifyingAbove x With right-arrow Superscript
    asterisk"><msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup></math>，而是寻找<math
    alttext="f left-parenthesis ModifyingAbove x With right-arrow Superscript asterisk
    Baseline right-parenthesis"><mrow><mi>f</mi> <mo>(</mo> <msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mo>)</mo></mrow></math>的上界（通过将可行集合的任意元素代入<math
    alttext="f left-parenthesis ModifyingAbove x With right-arrow right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow></math>很容易），以及<math
    alttext="f left-parenthesis ModifyingAbove x With right-arrow Superscript asterisk
    Baseline right-parenthesis"><mrow><mi>f</mi> <mo>(</mo> <msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mo>)</mo></mrow></math>的下界（这是一个更难的不等式，通常需要巧妙的想法）。现在我们会有*下界*<math
    alttext="f left-parenthesis ModifyingAbove x With right-arrow Superscript asterisk
    Baseline right-parenthesis less-than-or-equal-to"><mrow><mo>≤</mo> <mi>f</mi>
    <mo>(</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup>
    <mo>)</mo> <mo>≤</mo></mrow></math>*上界*，所以我们*收紧*这些界限以接近实际解<math alttext="f left-parenthesis
    ModifyingAbove x With right-arrow Superscript asterisk Baseline right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup>
    <mo>)</mo></mrow></math>。我们通过最小化上界（这将使我们回到原始的最小化问题）和*最大化下界*（这建立了对偶问题）来收紧界限。
- en: Now for a linear minimization problem in *any form* (standard form, general
    form, or neither),
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对于*任何形式*的线性最小化问题（标准形式、一般形式或其他形式），
- en: <math alttext="dollar-sign min Underscript linear constraints on ModifyingAbove
    x With right-arrow Endscripts ModifyingAbove c With right-arrow period ModifyingAbove
    x With right-arrow dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo>
    <mrow><mtext>linear</mtext><mtext>constraints</mtext><mtext>on</mtext><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover></mrow></msub> <mover accent="true"><mi>c</mi> <mo>→</mo></mover>
    <mo>.</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></math>
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript linear constraints on ModifyingAbove
    x With right-arrow Endscripts ModifyingAbove c With right-arrow period ModifyingAbove
    x With right-arrow dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo>
    <mrow><mtext>linear</mtext><mtext>constraints</mtext><mtext>on</mtext><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover></mrow></msub> <mover accent="true"><mi>c</mi> <mo>→</mo></mover>
    <mo>.</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></math>
- en: what is the clever idea that gives us lower bounds for <math alttext="f left-parenthesis
    ModifyingAbove x With right-arrow right-parenthesis equals ModifyingAbove c With
    right-arrow period ModifyingAbove x With right-arrow"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow> <mo>=</mo>
    <mover accent="true"><mi>c</mi> <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover></mrow></math> ? We look for lower bounds for <math alttext="f
    left-parenthesis ModifyingAbove x With right-arrow right-parenthesis equals ModifyingAbove
    c With right-arrow period ModifyingAbove x With right-arrow"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow>
    <mo>=</mo> <mover accent="true"><mi>c</mi> <mo>→</mo></mover> <mo>.</mo> <mover
    accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></math> made up of a *linear
    combination* of the problem constraints. So we multiply each of our constraints
    by multipliers <math alttext="p Subscript i"><msub><mi>p</mi> <mi>i</mi></msub></math>
    (Lagrange multipliers), choosing their signs in a way that the constraint inequality
    is in the <math alttext="greater-than-or-equal-to"><mo>≥</mo></math> direction.
    How so? Well, the linear constraints are linear combinations of the entries of
    <math alttext="ModifyingAbove x With right-arrow"><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover></math> , the objective function <math alttext="ModifyingAbove
    c With right-arrow period ModifyingAbove x With right-arrow"><mrow><mover accent="true"><mi>c</mi>
    <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></math>
    is also a linear combination of the entries of <math alttext="ModifyingAbove x
    With right-arrow"><mover accent="true"><mi>x</mi> <mo>→</mo></mover></math> ,
    a linear combination of a linear combination is still a linear combination, so
    we can totally pick a linear combination of the constraints that we can compare
    to <math alttext="ModifyingAbove c With right-arrow period ModifyingAbove x With
    right-arrow"><mrow><mover accent="true"><mi>c</mi> <mo>→</mo></mover> <mo>.</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></math> .
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 给我们 <math alttext="f left-parenthesis ModifyingAbove x With right-arrow right-parenthesis
    equals ModifyingAbove c With right-arrow period ModifyingAbove x With right-arrow"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow>
    <mo>=</mo> <mover accent="true"><mi>c</mi> <mo>→</mo></mover> <mo>.</mo> <mover
    accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></math> 的下界是什么聪明的想法？我们寻找由问题约束的
    *线性组合* 组成的 <math alttext="f left-parenthesis ModifyingAbove x With right-arrow
    right-parenthesis equals ModifyingAbove c With right-arrow period ModifyingAbove
    x With right-arrow"><mrow><mi>f</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>)</mo></mrow> <mo>=</mo> <mover accent="true"><mi>c</mi>
    <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></math>
    的下界。因此，我们通过乘以每个约束的乘数 <math alttext="p Subscript i"><msub><mi>p</mi> <mi>i</mi></msub></math>（拉格朗日乘数）来加强它们，选择它们的符号，使约束不等式朝着
    <math alttext="greater-than-or-equal-to"><mo>≥</mo></math> 方向。为什么？线性约束是 <math
    alttext="ModifyingAbove x With right-arrow"><mover accent="true"><mi>x</mi> <mo>→</mo></mover></math>
    的条目的线性组合，目标函数 <math alttext="ModifyingAbove c With right-arrow period ModifyingAbove
    x With right-arrow"><mrow><mover accent="true"><mi>c</mi> <mo>→</mo></mover> <mo>.</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></math> 也是 <math alttext="ModifyingAbove
    x With right-arrow"><mover accent="true"><mi>x</mi> <mo>→</mo></mover></math>
    的条目的线性组合，线性组合的线性组合仍然是线性组合，所以我们完全可以选择约束的线性组合，将其与 <math alttext="ModifyingAbove
    c With right-arrow period ModifyingAbove x With right-arrow"><mrow><mover accent="true"><mi>c</mi>
    <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></math>
    进行比较。
- en: Namely, if we have *m* linear constraints, we need
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果我们有 *m* 个线性约束，则我们需要
- en: <math alttext="dollar-sign p 1 b 1 plus p 2 b 2 plus ellipsis plus p Subscript
    m Baseline b Subscript m Baseline less-than-or-equal-to ModifyingAbove c With
    right-arrow period ModifyingAbove x With right-arrow dollar-sign"><mrow><msub><mi>p</mi>
    <mn>1</mn></msub> <msub><mi>b</mi> <mn>1</mn></msub> <mo>+</mo> <msub><mi>p</mi>
    <mn>2</mn></msub> <msub><mi>b</mi> <mn>2</mn></msub> <mo>+</mo> <mo>⋯</mo> <mo>+</mo>
    <msub><mi>p</mi> <mi>m</mi></msub> <msub><mi>b</mi> <mi>m</mi></msub> <mo>≤</mo>
    <mover accent="true"><mi>c</mi> <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover></mrow></math>
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign p 1 b 1 plus p 2 b 2 plus ellipsis plus p Subscript
    m Baseline b Subscript m Baseline less-than-or-equal-to ModifyingAbove c With
    right-arrow period ModifyingAbove x With right-arrow dollar-sign"><mrow><msub><mi>p</mi>
    <mn>1</mn></msub> <msub><mi>b</mi> <mn>1</mn></msub> <mo>+</mo> <msub><mi>p</mi>
    <mn>2</mn></msub> <msub><mi>b</mi> <mn>2</mn></msub> <mo>+</mo> <mo>⋯</mo> <mo>+</mo>
    <msub><mi>p</mi> <mi>m</mi></msub> <msub><mi>b</mi> <mi>m</mi></msub> <mo>≤</mo>
    <mover accent="true"><mi>c</mi> <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover></mrow></math>
- en: The sign of a multiplier <math alttext="p Subscript i"><msub><mi>p</mi> <mi>i</mi></msub></math>
    would be free if the constraint has an equality. Once we have these lower bounds,
    we tighten them by maximizing on <math alttext="p Subscript i"><msub><mi>p</mi>
    <mi>i</mi></msub></math> , which gives us the dual problem.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果约束条件是相等的，乘数 <math alttext="p Subscript i"><msub><mi>p</mi> <mi>i</mi></msub></math>
    的符号将是自由的。一旦我们有了这些下界，我们通过最大化 <math alttext="p Subscript i"><msub><mi>p</mi> <mi>i</mi></msub></math>
    来加强它们，这给我们了对偶问题。
- en: Finding the dual linear optimization problem from the primal linear optimization
    problem
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从原始线性优化问题中找到对偶线性优化问题
- en: 'It is important to get the sizes of the inputs to a linear optimization problem
    right. The inputs are: *A* which is <math alttext="m times n"><mrow><mi>m</mi>
    <mo>×</mo> <mi>n</mi></mrow></math> , <math alttext="ModifyingAbove c With right-arrow"><mover
    accent="true"><mi>c</mi> <mo>→</mo></mover></math> which is <math alttext="n times
    1"><mrow><mi>n</mi> <mo>×</mo> <mn>1</mn></mrow></math> , <math alttext="ModifyingAbove
    b With right-arrow"><mover accent="true"><mi>b</mi> <mo>→</mo></mover></math>
    which is <math alttext="m times 1"><mrow><mi>m</mi> <mo>×</mo> <mn>1</mn></mrow></math>
    . The decision variables in the primal problem are in the vector <math alttext="ModifyingAbove
    x With right-arrow"><mover accent="true"><mi>x</mi> <mo>→</mo></mover></math>
    which is <math alttext="n times 1"><mrow><mi>n</mi> <mo>×</mo> <mn>1</mn></mrow></math>
    . The decision variables in the dual problem are in the vector <math alttext="ModifyingAbove
    p With right-arrow"><mover accent="true"><mi>p</mi> <mo>→</mo></mover></math>
    which is <math alttext="m times 1"><mrow><mi>m</mi> <mo>×</mo> <mn>1</mn></mrow></math>
    .'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 将线性优化问题的输入大小设置正确是很重要的。输入包括：*A*，它是 <math alttext="m times n"><mrow><mi>m</mi>
    <mo>×</mo> <mi>n</mi></mrow></math>，<math alttext="ModifyingAbove c With right-arrow"><mover
    accent="true"><mi>c</mi> <mo>→</mo></mover></math>，它是 <math alttext="n times 1"><mrow><mi>n</mi>
    <mo>×</mo> <mn>1</mn></mrow></math>，<math alttext="ModifyingAbove b With right-arrow"><mover
    accent="true"><mi>b</mi> <mo>→</mo></mover></math>，它是 <math alttext="m times 1"><mrow><mi>m</mi>
    <mo>×</mo> <mn>1</mn></mrow></math>。原始问题中的决策变量在向量 <math alttext="ModifyingAbove
    x With right-arrow"><mover accent="true"><mi>x</mi> <mo>→</mo></mover></math>
    中，它是 <math alttext="n times 1"><mrow><mi>n</mi> <mo>×</mo> <mn>1</mn></mrow></math>。对偶问题中的决策变量在向量
    <math alttext="ModifyingAbove p With right-arrow"><mover accent="true"><mi>p</mi>
    <mo>→</mo></mover></math> 中，它是 <math alttext="m times 1"><mrow><mi>m</mi> <mo>×</mo>
    <mn>1</mn></mrow></math>。
- en: 'In general, if *A* appears in the primal problem then <math alttext="upper
    A Superscript t"><msup><mi>A</mi> <mi>t</mi></msup></math> appears in the dual
    problem. So in the primal problem we have the dot product of the *rows* of *A*
    and <math alttext="ModifyingAbove x With right-arrow"><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover></math> . In the dual problem we have the dot product of the
    *columns* of *A* and <math alttext="ModifyingAbove p With right-arrow"><mover
    accent="true"><mi>p</mi> <mo>→</mo></mover></math> . If the linear optimization
    problem is in *any form*, it’s easy to write its dual following this process:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果*A*出现在原始问题中，则<math alttext="上A上标t"><msup><mi>A</mi> <mi>t</mi></msup></math>出现在对偶问题中。因此，在原始问题中，我们有*A*和<math
    alttext="用右箭头修改上面的x"><mover accent="true"><mi>x</mi> <mo>→</mo></mover></math>的行的点积。在对偶问题中，我们有*A*和<math
    alttext="用右箭头修改上面的p"><mover accent="true"><mi>p</mi> <mo>→</mo></mover></math>的列的点积。如果线性优化问题以*任何形式*出现，按照这个过程很容易写出它的对偶问题：
- en: If the primal is a minimization then the dual is a maximization and vice-versa.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果原始问题是最小化，则对偶问题是最大化，反之亦然。
- en: The primal cost function is <math alttext="ModifyingAbove c With right-arrow
    period ModifyingAbove x With right-arrow"><mrow><mover accent="true"><mi>c</mi>
    <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></math>
    and the dual cost function is <math alttext="ModifyingAbove p With right-arrow
    period ModifyingAbove b With right-arrow"><mrow><mover accent="true"><mi>p</mi>
    <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></math>
    .
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始成本函数为<math alttext="用右箭头修改上面的c期用右箭头修改上面的x"><mrow><mover accent="true"><mi>c</mi>
    <mo>→</mo></mover> <mo>·</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></math>，对偶成本函数为<math
    alttext="用右箭头修改上面的p期用右箭头修改上面的b"><mrow><mover accent="true"><mi>p</mi> <mo>→</mo></mover>
    <mo>·</mo> <mover accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></math>。
- en: 'In a *minimization* primal problem, we separate the constraints into two types:'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*最小化*原始问题中，我们将约束分为两种类型：
- en: Type One
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型一
- en: 'Constraints telling us about the sign of the decision variable, for example:'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 约束告诉我们关于决策变量符号的信息，例如：
- en: <math alttext="x 3 greater-than-or-equal-to 0"><mrow><msub><mi>x</mi> <mn>3</mn></msub>
    <mo>≥</mo> <mn>0</mn></mrow></math> . Then in the dual this will correspond to
    <math alttext="upper A 3 period ModifyingAbove p With right-arrow less-than-or-equal-to
    c 3"><mrow><msub><mi>A</mi> <mn>3</mn></msub> <mo>.</mo> <mover accent="true"><mi>p</mi>
    <mo>→</mo></mover> <mo>≤</mo> <msub><mi>c</mi> <mn>3</mn></msub></mrow></math>
    where <math alttext="upper A 3"><msub><mi>A</mi> <mn>3</mn></msub></math> is the
    third column of *A* and <math alttext="c 3"><msub><mi>c</mi> <mn>3</mn></msub></math>
    is the third entry of <math alttext="ModifyingAbove c With right-arrow"><mover
    accent="true"><mi>c</mi> <mo>→</mo></mover></math> .
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="x 3大于或等于0"><mrow><msub><mi>x</mi> <mn>3</mn></msub> <mo>≥</mo>
    <mn>0</mn></mrow></math>。然后在对偶中，这将对应于<math alttext="上A 3期用右箭头修改上面的p小于或等于c 3"><mrow><msub><mi>A</mi>
    <mn>3</mn></msub> <mo>·</mo> <mover accent="true"><mi>p</mi> <mo>→</mo></mover>
    <mo>≤</mo> <msub><mi>c</mi> <mn>3</mn></msub></mrow></math>其中<math alttext="上A
    3"><msub><mi>A</mi> <mn>3</mn></msub></math>是*A*的第三列，<math alttext="c 3"><msub><mi>c</mi>
    <mn>3</mn></msub></math>是<math alttext="用右箭头修改上面的c"><mover accent="true"><mi>c</mi>
    <mo>→</mo></mover></math>的第三个条目。
- en: <math alttext="x 12 less-than-or-equal-to 0"><mrow><msub><mi>x</mi> <mn>12</mn></msub>
    <mo>≤</mo> <mn>0</mn></mrow></math> . Then in the dual this will correspond to
    <math alttext="upper A 12 period p greater-than-or-equal-to c 12"><mrow><msub><mi>A</mi>
    <mn>12</mn></msub> <mo>.</mo> <mi>p</mi> <mo>≥</mo> <msub><mi>c</mi> <mn>12</mn></msub></mrow></math>
    where <math alttext="upper A 12"><msub><mi>A</mi> <mn>12</mn></msub></math> is
    the twelveth column of *A* and <math alttext="c 12"><msub><mi>c</mi> <mn>12</mn></msub></math>
    is the twelveth entry of <math alttext="ModifyingAbove c With right-arrow"><mover
    accent="true"><mi>c</mi> <mo>→</mo></mover></math> .
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="x 12小于或等于0"><mrow><msub><mi>x</mi> <mn>12</mn></msub> <mo>≤</mo>
    <mn>0</mn></mrow></math>。然后在对偶中，这将对应于<math alttext="上A 12期p大于或等于c 12"><mrow><msub><mi>A</mi>
    <mn>12</mn></msub> <mo>·</mo> <mi>p</mi> <mo>≥</mo> <msub><mi>c</mi> <mn>12</mn></msub></mrow></math>其中<math
    alttext="上A 12"><msub><mi>A</mi> <mn>12</mn></msub></math>是*A*的第十二列，<math alttext="c
    12"><msub><mi>c</mi> <mn>12</mn></msub></math>是<math alttext="用右箭头修改上面的c"><mover
    accent="true"><mi>c</mi> <mo>→</mo></mover></math>的第十二个条目。
- en: <math alttext="x 5"><msub><mi>x</mi> <mn>5</mn></msub></math> is free meaning
    has no specified sign. Then in the dual this will correspond to <math alttext="upper
    A 5 period p equals c 5"><mrow><msub><mi>A</mi> <mn>5</mn></msub> <mo>.</mo> <mi>p</mi>
    <mo>=</mo> <msub><mi>c</mi> <mn>5</mn></msub></mrow></math> where <math alttext="upper
    A 5"><msub><mi>A</mi> <mn>5</mn></msub></math> is the fifth column of *A* and
    <math alttext="c 5"><msub><mi>c</mi> <mn>5</mn></msub></math> is the fifth entry
    of <math alttext="ModifyingAbove c With right-arrow"><mover accent="true"><mi>c</mi>
    <mo>→</mo></mover></math> .
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="x 5"><msub><mi>x</mi> <mn>5</mn></msub></math>是自由的，意味着没有指定的符号。然后在对偶中，这将对应于<math
    alttext="上A 5期p等于c 5"><mrow><msub><mi>A</mi> <mn>5</mn></msub> <mo>·</mo> <mi>p</mi>
    <mo>=</mo> <msub><mi>c</mi> <mn>5</mn></msub></mrow></math>其中<math alttext="上A
    5"><msub><mi>A</mi> <mn>5</mn></msub></math>是*A*的第五列，<math alttext="c 5"><msub><mi>c</mi>
    <mn>5</mn></msub></math>是<math alttext="用右箭头修改上面的c"><mover accent="true"><mi>c</mi>
    <mo>→</mo></mover></math>的第五个条目。
- en: Type Two
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型二
- en: 'Constraints of the form <math alttext="a Subscript i Baseline period x greater-than-or-equal-to
    less-than-or-equal-to equals b Subscript i Baseline"><mrow><msub><mi>a</mi> <mi>i</mi></msub>
    <mo>.</mo> <mi>x</mi> <mo>≥</mo> <mo>≤</mo> <mo>=</mo> <msub><mi>b</mi> <mi>i</mi></msub></mrow></math>
    where <math alttext="a Subscript i"><msub><mi>a</mi> <mi>i</mi></msub></math>
    is the _i_th row of A. In the dual these will correspond to constraints on the
    sign of <math alttext="p Subscript i"><msub><mi>p</mi> <mi>i</mi></msub></math>
    , for example:'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 形式约束为<math alttext="a下标i基线期x大于或等于小于或等于等于b下标i基线"><mrow><msub><mi>a</mi> <mi>i</mi></msub>
    <mo>·</mo> <mi>x</mi> <mo>≥</mo> <mo>≤</mo> <mo>=</mo> <msub><mi>b</mi> <mi>i</mi></msub></mrow></math>其中<math
    alttext="a下标i"><msub><mi>a</mi> <mi>i</mi></msub></math>是A的第i行。在对偶中，这些将对应于对<math
    alttext="p下标i"><msub><mi>p</mi> <mi>i</mi></msub></math>符号的约束，例如：
- en: <math alttext="a 2 period x greater-than-or-equal-to b 2"><mrow><msub><mi>a</mi>
    <mn>2</mn></msub> <mo>.</mo> <mi>x</mi> <mo>≥</mo> <msub><mi>b</mi> <mn>2</mn></msub></mrow></math>
    . Then in the dual this will correspond to <math alttext="p 2 greater-than-or-equal-to
    0"><mrow><msub><mi>p</mi> <mn>2</mn></msub> <mo>≥</mo> <mn>0</mn></mrow></math>
    .
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="a 2 period x greater-than-or-equal-to b 2"><mrow><msub><mi>a</mi>
    <mn>2</mn></msub> <mo>.</mo> <mi>x</mi> <mo>≥</mo> <msub><mi>b</mi> <mn>2</mn></msub></mrow></math>。那么在对偶中，这将对应于<math
    alttext="p 2 greater-than-or-equal-to 0"><mrow><msub><mi>p</mi> <mn>2</mn></msub>
    <mo>≥</mo> <mn>0</mn></mrow></math>。
- en: <math alttext="a 7 period x less-than-or-equal-to b 7"><mrow><msub><mi>a</mi>
    <mn>7</mn></msub> <mo>.</mo> <mi>x</mi> <mo>≤</mo> <msub><mi>b</mi> <mn>7</mn></msub></mrow></math>
    . Then in the dual this will correspond to <math alttext="p 5 less-than-or-equal-to
    0"><mrow><msub><mi>p</mi> <mn>5</mn></msub> <mo>≤</mo> <mn>0</mn></mrow></math>
    .
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="a 7 period x less-than-or-equal-to b 7"><mrow><msub><mi>a</mi>
    <mn>7</mn></msub> <mo>.</mo> <mi>x</mi> <mo>≤</mo> <msub><mi>b</mi> <mn>7</mn></msub></mrow></math>。那么在对偶中，这将对应于<math
    alttext="p 5 less-than-or-equal-to 0"><mrow><msub><mi>p</mi> <mn>5</mn></msub>
    <mo>≤</mo> <mn>0</mn></mrow></math>。
- en: <math alttext="a 8 period x equals b 8"><mrow><msub><mi>a</mi> <mn>8</mn></msub>
    <mo>.</mo> <mi>x</mi> <mo>=</mo> <msub><mi>b</mi> <mn>8</mn></msub></mrow></math>
    . Then the sign of <math alttext="p 8"><msub><mi>p</mi> <mn>8</mn></msub></math>
    is free.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="a 8 period x equals b 8"><mrow><msub><mi>a</mi> <mn>8</mn></msub>
    <mo>.</mo> <mi>x</mi> <mo>=</mo> <msub><mi>b</mi> <mn>8</mn></msub></mrow></math>。那么<math
    alttext="p 8"><msub><mi>p</mi> <mn>8</mn></msub></math>的符号是自由的。
- en: 'In particular if the linear optimization problem is in standard form:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是如果线性优化问题处于标准形式：
- en: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column upper A ModifyingAbove x With right-arrow equals ModifyingAbove b With
    right-arrow 2nd Row 1st Column Blank 2nd Column ModifyingAbove x With right-arrow
    greater-than-or-equal-to ModifyingAbove 0 With right-arrow EndLayout Endscripts
    ModifyingAbove c With right-arrow period ModifyingAbove x With right-arrow comma
    dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo> <mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><mi>A</mi><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover><mo>=</mo><mover accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></mtd></mtr><mtr><mtd
    columnalign="left"><mrow><mover accent="true"><mi>x</mi> <mo>→</mo></mover><mo>≥</mo><mover
    accent="true"><mn>0</mn> <mo>→</mo></mover></mrow></mtd></mtr></mtable></msub>
    <mover accent="true"><mi>c</mi> <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>,</mo></mrow></math>
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column upper A ModifyingAbove x With right-arrow equals ModifyingAbove b With
    right-arrow 2nd Row 1st Column Blank 2nd Column ModifyingAbove x With right-arrow
    greater-than-or-equal-to ModifyingAbove 0 With right-arrow EndLayout Endscripts
    ModifyingAbove c With right-arrow period ModifyingAbove x With right-arrow comma
    dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo> <mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><mi>A</mi><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover><mo>=</mo><mover accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></mtd></mtr><mtr><mtd
    columnalign="left"><mrow><mover accent="true"><mi>x</mi> <mo>→</mo></mover><mo>≥</mo><mover
    accent="true"><mn>0</mn> <mo>→</mo></mover></mrow></mtd></mtr></mtable></msub>
    <mover accent="true"><mi>c</mi> <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>,</mo></mrow></math>
- en: 'then its dual is:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它的对偶是：
- en: <math alttext="dollar-sign max Underscript StartLayout 1st Row 1st Column Blank
    2nd Column ModifyingAbove p With right-arrow is free 2nd Row 1st Column Blank
    2nd Column upper A Superscript upper T Baseline ModifyingAbove p With right-arrow
    less-than-or-equal-to ModifyingAbove c With right-arrow EndLayout Endscripts ModifyingAbove
    p With right-arrow period ModifyingAbove b With right-arrow period dollar-sign"><mrow><msub><mo
    form="prefix" movablelimits="true">max</mo> <mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mover accent="true"><mi>p</mi> <mo>→</mo></mover><mtext>is</mtext><mtext>free</mtext></mrow></mtd></mtr><mtr><mtd
    columnalign="left"><mrow><msup><mi>A</mi> <mi>T</mi></msup> <mover accent="true"><mi>p</mi>
    <mo>→</mo></mover><mo>≤</mo><mover accent="true"><mi>c</mi> <mo>→</mo></mover></mrow></mtd></mtr></mtable></msub>
    <mover accent="true"><mi>p</mi> <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>b</mi>
    <mo>→</mo></mover> <mo>.</mo></mrow></math>
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign max Underscript StartLayout 1st Row 1st Column Blank
    2nd Column ModifyingAbove p With right-arrow is free 2nd Row 1st Column Blank
    2nd Column upper A Superscript upper T Baseline ModifyingAbove p With right-arrow
    less-than-or-equal-to ModifyingAbove c With right-arrow EndLayout Endscripts ModifyingAbove
    p With right-arrow period ModifyingAbove b With right-arrow period dollar-sign"><mrow><msub><mo
    form="prefix" movablelimits="true">max</mo> <mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mover accent="true"><mi>p</mi> <mo>→</mo></mover><mtext>is</mtext><mtext>free</mtext></mrow></mtd></mtr><mtr><mtd
    columnalign="left"><mrow><msup><mi>A</mi> <mi>T</mi></msup> <mover accent="true"><mi>p</mi>
    <mo>→</mo></mover><mo>≤</mo><mover accent="true"><mi>c</mi> <mo>→</mo></mover></mrow></mtd></mtr></mtable></msub>
    <mover accent="true"><mi>p</mi> <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>b</mi>
    <mo>→</mo></mover> <mo>.</mo></mrow></math>
- en: 'If the linear optimization problem is in general form:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线性优化问题处于一般形式：
- en: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column upper A ModifyingAbove x With right-arrow greater-than-or-equal-to
    ModifyingAbove b With right-arrow 2nd Row 1st Column Blank 2nd Column ModifyingAbove
    x With right-arrow is free EndLayout Endscripts ModifyingAbove c With right-arrow
    period ModifyingAbove x With right-arrow dollar-sign"><mrow><msub><mo form="prefix"
    movablelimits="true">min</mo> <mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mi>A</mi><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>≥</mo><mover accent="true"><mi>b</mi>
    <mo>→</mo></mover></mrow></mtd></mtr><mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mtext>is</mtext><mtext>free</mtext></mrow></mtd></mtr></mtable></msub>
    <mover accent="true"><mi>c</mi> <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover></mrow></math>
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column upper A ModifyingAbove x With right-arrow greater-than-or-equal-to
    ModifyingAbove b With right-arrow 2nd Row 1st Column Blank 2nd Column ModifyingAbove
    x With right-arrow is free EndLayout Endscripts ModifyingAbove c With right-arrow
    period ModifyingAbove x With right-arrow dollar-sign"><mrow><msub><mo form="prefix"
    movablelimits="true">min</mo> <mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mi>A</mi><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>≥</mo><mover accent="true"><mi>b</mi>
    <mo>→</mo></mover></mrow></mtd></mtr><mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mtext>is</mtext><mtext>free</mtext></mrow></mtd></mtr></mtable></msub>
    <mover accent="true"><mi>c</mi> <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover></mrow></math>
- en: then its dual is
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它的对偶是
- en: <math alttext="dollar-sign max Underscript StartLayout 1st Row 1st Column Blank
    2nd Column ModifyingAbove p With right-arrow greater-than-or-equal-to ModifyingAbove
    0 With right-arrow 2nd Row 1st Column Blank 2nd Column upper A Superscript upper
    T Baseline ModifyingAbove p With right-arrow equals ModifyingAbove c With right-arrow
    EndLayout Endscripts ModifyingAbove p With right-arrow period ModifyingAbove b
    With right-arrow dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">max</mo>
    <mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mover accent="true"><mi>p</mi>
    <mo>→</mo></mover><mo>≥</mo><mover accent="true"><mn>0</mn> <mo>→</mo></mover></mrow></mtd></mtr><mtr><mtd
    columnalign="left"><mrow><msup><mi>A</mi> <mi>T</mi></msup> <mover accent="true"><mi>p</mi>
    <mo>→</mo></mover><mo>=</mo><mover accent="true"><mi>c</mi> <mo>→</mo></mover></mrow></mtd></mtr></mtable></msub>
    <mover accent="true"><mi>p</mi> <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>b</mi>
    <mo>→</mo></mover></mrow></math>
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign max Underscript StartLayout 1st Row 1st Column Blank
    2nd Column ModifyingAbove p With right-arrow greater-than-or-equal-to ModifyingAbove
    0 With right-arrow 2nd Row 1st Column Blank 2nd Column upper A Superscript upper
    T Baseline ModifyingAbove p With right-arrow equals ModifyingAbove c With right-arrow
    EndLayout Endscripts ModifyingAbove p With right-arrow period ModifyingAbove b
    With right-arrow dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">max</mo>
    <mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mover accent="true"><mi>p</mi>
    <mo>→</mo></mover><mo>≥</mo><mover accent="true"><mn>0</mn> <mo>→</mo></mover></mrow></mtd></mtr><mtr><mtd
    columnalign="left"><mrow><msup><mi>A</mi> <mi>T</mi></msup> <mover accent="true"><mi>p</mi>
    <mo>→</mo></mover><mo>=</mo><mover accent="true"><mi>c</mi> <mo>→</mo></mover></mrow></mtd></mtr></mtable></msub>
    <mover accent="true"><mi>p</mi> <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>b</mi>
    <mo>→</mo></mover></mrow></math>
- en: How to solve the dual problem? The simplex method solves the dual problem however
    now you move to basic feasible solutions that *increase* the cost rather than
    *decrease* the cost.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如何解决对偶问题？单纯形法解决对偶问题，但现在您移动到增加成本而不是减少成本的基本可行解。
- en: Derivation for the dual of a linear optimization problem in standard form
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准形式线性优化问题的对偶推导
- en: 'There is another way to think about deriving the dual problem, but for this
    one the linear problem has to be in its standard form. Here’s the idea of it:
    We relax the constraint <math alttext="upper A ModifyingAbove x With right-arrow
    equals ModifyingAbove b With right-arrow"><mrow><mi>A</mi> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>=</mo> <mover accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></math>
    but introduce Lagrange multipliers <math alttext="ModifyingAbove p With right-arrow"><mover
    accent="true"><mi>p</mi> <mo>→</mo></mover></math> (pay a penalty <math alttext="ModifyingAbove
    p With right-arrow"><mover accent="true"><mi>p</mi> <mo>→</mo></mover></math>
    when the constraint is violated). So'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 推导对偶问题的另一种思考方式，但是对于这种情况，线性问题必须处于标准形式。这是它的想法：我们放松约束<math alttext="upper A ModifyingAbove
    x With right-arrow equals ModifyingAbove b With right-arrow"><mrow><mi>A</mi>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>=</mo> <mover accent="true"><mi>b</mi>
    <mo>→</mo></mover></mrow></math>，但引入拉格朗日乘数<math alttext="ModifyingAbove p With
    right-arrow"><mover accent="true"><mi>p</mi> <mo>→</mo></mover></math>（当约束违反时支付惩罚<math
    alttext="ModifyingAbove p With right-arrow"><mover accent="true"><mi>p</mi> <mo>→</mo></mover></math>）。因此
- en: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column upper A ModifyingAbove x With right-arrow equals ModifyingAbove b With
    right-arrow 2nd Row 1st Column Blank 2nd Column ModifyingAbove x With right-arrow
    greater-than-or-equal-to ModifyingAbove 0 With right-arrow EndLayout Endscripts
    ModifyingAbove c With right-arrow period ModifyingAbove x With right-arrow dollar-sign"><mrow><msub><mo
    form="prefix" movablelimits="true">min</mo> <mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mi>A</mi><mover accent="true"><mi>x</mi> <mo>→</mo></mover><mo>=</mo><mover
    accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></mtd></mtr><mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>≥</mo><mover accent="true"><mn>0</mn>
    <mo>→</mo></mover></mrow></mtd></mtr></mtable></msub> <mover accent="true"><mi>c</mi>
    <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></math>
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column upper A ModifyingAbove x With right-arrow equals ModifyingAbove b With
    right-arrow 2nd Row 1st Column Blank 2nd Column ModifyingAbove x With right-arrow
    greater-than-or-equal-to ModifyingAbove 0 With right-arrow EndLayout Endscripts
    ModifyingAbove c With right-arrow period ModifyingAbove x With right-arrow dollar-sign"><mrow><msub><mo
    form="prefix" movablelimits="true">min</mo> <mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mi>A</mi><mover accent="true"><mi>x</mi> <mo>→</mo></mover><mo>=</mo><mover
    accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></mtd></mtr><mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>≥</mo><mover accent="true"><mn>0</mn>
    <mo>→</mo></mover></mrow></mtd></mtr></mtable></msub> <mover accent="true"><mi>c</mi>
    <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></math>
- en: becomes
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 变成
- en: <math alttext="dollar-sign min Underscript ModifyingAbove x With right-arrow
    greater-than-or-equal-to ModifyingAbove 0 With right-arrow Endscripts ModifyingAbove
    c With right-arrow period ModifyingAbove x With right-arrow plus ModifyingAbove
    p With right-arrow period left-parenthesis ModifyingAbove b With right-arrow minus
    upper A ModifyingAbove x With right-arrow right-parenthesis equals g left-parenthesis
    ModifyingAbove p With right-arrow right-parenthesis period dollar-sign"><mrow><msub><mo
    form="prefix" movablelimits="true">min</mo> <mrow><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover><mo>≥</mo><mover accent="true"><mn>0</mn> <mo>→</mo></mover></mrow></msub>
    <mover accent="true"><mi>c</mi> <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>+</mo> <mover accent="true"><mi>p</mi> <mo>→</mo></mover>
    <mo>.</mo> <mrow><mo>(</mo> <mover accent="true"><mi>b</mi> <mo>→</mo></mover>
    <mo>-</mo> <mi>A</mi> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow>
    <mo>=</mo> <mi>g</mi> <mrow><mo>(</mo> <mover accent="true"><mi>p</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mo>.</mo></mrow></math>
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript ModifyingAbove x With right-arrow
    greater-than-or-equal-to ModifyingAbove 0 With right-arrow Endscripts ModifyingAbove
    c With right-arrow period ModifyingAbove x With right-arrow plus ModifyingAbove
    p With right-arrow period left-parenthesis ModifyingAbove b With right-arrow minus
    upper A ModifyingAbove x With right-arrow right-parenthesis equals g left-parenthesis
    ModifyingAbove p With right-arrow right-parenthesis period dollar-sign"><mrow><msub><mo
    form="prefix" movablelimits="true">min</mo> <mrow><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover><mo>≥</mo><mover accent="true"><mn>0</mn> <mo>→</mo></mover></mrow></msub>
    <mover accent="true"><mi>c</mi> <mo>→</mo></mover> <mo>.</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>+</mo> <mover accent="true"><mi>p</mi> <mo>→</mo></mover>
    <mo>.</mo> <mrow><mo>(</mo> <mover accent="true"><mi>b</mi> <mo>→</mo></mover>
    <mo>-</mo> <mi>A</mi> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow>
    <mo>=</mo> <mi>g</mi> <mrow><mo>(</mo> <mover accent="true"><mi>p</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mo>.</mo></mrow></math>
- en: Now prove that <math alttext="g left-parenthesis ModifyingAbove p With right-arrow
    right-parenthesis"><mrow><mi>g</mi> <mo>(</mo> <mover accent="true"><mi>p</mi>
    <mo>→</mo></mover> <mo>)</mo></mrow></math> is a lower bound for the original
    <math alttext="ModifyingAbove c With right-arrow period ModifyingAbove x With
    right-arrow Superscript asterisk"><mrow><mover accent="true"><mi>c</mi> <mo>→</mo></mover>
    <mo>.</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup></mrow></math>
    (this is the weak duality theorem) then maximize over *p*. The dual problem appears
    in the process (my lecture notes on duality for full derivation).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在证明<math alttext="g left-parenthesis ModifyingAbove p With right-arrow right-parenthesis"><mrow><mi>g</mi>
    <mo>(</mo> <mover accent="true"><mi>p</mi> <mo>→</mo></mover> <mo>)</mo></mrow></math>是原始<math
    alttext="ModifyingAbove c With right-arrow period ModifyingAbove x With right-arrow
    Superscript asterisk"><mrow><mover accent="true"><mi>c</mi> <mo>→</mo></mover>
    <mo>.</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup></mrow></math>的下界（这是弱对偶定理），然后最大化*p*。对偶问题出现在这个过程中（我关于对偶的讲义中有完整的推导）。
- en: The *strong duality theorem* says that the <math alttext="min"><mo form="prefix"
    movablelimits="true">min</mo></math> of the primal problem and the <math alttext="max"><mo
    form="prefix" movablelimits="true">max</mo></math> of the dual problem are equal.
    Note that if the primal problem is unbounded then the dual problem is infeasible
    and if the dual problem is unbounded then the primal problem is infeasible.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*强对偶定理*表明原始问题的最小值和对偶问题的最大值相等。请注意，如果原始问题无界，则对偶问题不可行，如果对偶问题无界，则原始问题不可行。'
- en: '[Farkas lemma](https://en.wikipedia.org/wiki/Farkas%27_lemma) is at the core
    of duality theory and has many economical and financial applications.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '[Farkas引理](https://en.wikipedia.org/wiki/Farkas%27_lemma)是对偶理论的核心，具有许多经济和金融应用。'
- en: Dual Simplex Method
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对偶单纯形法
- en: 'The dual simplex method solves the primal problem (not the dual problem) using
    duality theory. The main difference between the simplex method and the dual simplex
    method is this: the regular simplex method starts with a basic feasible solution
    which is not optimal and it moves towards optimality, while the dual simplex method
    starts with an infeasible solution which is optimal and works towards feasibility.
    The dual simplex method is like a mirror image of the simplex method.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 对偶单纯形法解决原始问题（而不是对偶问题）使用对偶理论。单纯形法和对偶单纯形法的主要区别在于：常规单纯形法从不是最优的基本可行解开始，并朝向最优解，而对偶单纯形法从最优的不可行解开始，并朝向可行性。对偶单纯形法就像单纯形法的镜像。
- en: First, note that when we solve the primal problem using the simplex method,
    we obtain the optimal cost for the dual problem for free (equal to the primal
    optimal cost), but also, *we can read off the solution (optimizer) to the dual
    problem from the final tableaux for the primal problem*. An optimal dual variable
    is nonzero only if its associated constraint in the primal is binding. This should
    be intuitively clear, since the optimal dual variables are the shadow prices (Lagrange
    multipliers) associated with the constraints. We can interpret these shadow prices
    as values assigned to the scarce resources (binding constraints), so that the
    value of these resources equals the value of the primal objective function. The
    optimal dual variables satisfy the optimality conditions of the simplex method.
    In the final tableau of the simplex method, the reduced costs of the basic variables
    must be zero. The optimal dual variables must be the shadow prices associated
    with an optimal solution.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意当我们使用单纯形法解决原始问题时，我们可以免费获得对偶问题的最优成本（等于原始问题的最优成本），而且，*我们可以从原始问题的最终表中读取出对偶问题的解（优化器）*。一个最优对偶变量只有在其对应的原始约束是约束时才为非零。这应该直观地清楚，因为最优对偶变量是与约束相关的影子价格（拉格朗日乘数）。我们可以将这些影子价格解释为分配给稀缺资源（约束）的值，以便这些资源的价值等于原始目标函数的价值。最优对偶变量满足单纯形法的最优性条件。在单纯形法的最终表中，基本变量的降低成本必须为零。最优对偶变量必须是与最优解相关的影子价格。
- en: Another way is to think of the dual simplex method as a disguised simplex method
    solving the dual problem. However we do so without explicitly writing the dual
    problem and applying the simplex method to maximize.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是将对偶单纯形法视为解决对偶问题的伪装单纯形法。但是，我们这样做时没有明确地写出对偶问题，并应用单纯形法进行最大化。
- en: Morever, the simplex method produces a sequence of primal basic feasible solutions
    (corners of the polyhedron), as soon as it finds one which is also dual feasible,
    the method terminates. On the other hand, the dual simplex method produces a sequence
    of dual basic feasible solutions, as soon as it finds one which is also primal
    feasible, the method terminates.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，单纯形法产生一系列原始基本可行解（多面体的角点），一旦找到一个也是对偶可行的解，方法就终止。另一方面，对偶单纯形法产生一系列对偶基本可行解，一旦找到一个也是原始可行的解，方法就终止。
- en: 'Example: Networks, linear optimization and duality'
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 例子：网络、线性优化和对偶性
- en: 'Consider the network in [Figure 10-9](#Fig_max_flow). The numbers indicate
    the edge capacity, which is the maximum amount of flow that each edge can handle.
    The *max flow* problem is to send the maximum flow from the origin node to the
    destination node. Intuitively, the maximum flow through the network will be limited
    by the capacities that the edges can transmit. In fact, this observation underlies
    a dual problem that takes place: Maximizing the flow through the network is equivalent
    to minimizing the total capacities of the edges that if we cut then we cannot
    get from the origin to the destination. This is *max flow min cut theorem*.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[图10-9](#Fig_max_flow)中的网络。数字表示边的容量，即每条边可以处理的最大流量。*最大流*问题是将最大流从起始节点发送到目标节点。直观地说，网络中的最大流量将受到边缘可以传输的容量的限制。事实上，这一观察结果构成了一个对偶问题：通过网络的最大流量等同于最小化那些如果我们切断就无法从起点到终点的边的总容量。这就是*最大流最小割定理*。
- en: '![250](assets/emai_1009.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![250](assets/emai_1009.png)'
- en: 'Figure 10-9\. Duality: Maximum flow through the network is equal to the smallest
    cut capacity.'
  id: totrans-313
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-9. 对偶性：网络中的最大流量等于最小割容量。
- en: '[Figure 10-9](#Fig_max_flow) shows the values of all the cuts (the set of edges
    that if we cut together we will not be able to get from the origin to the destination)
    through the network, along with the cut of minimal total edge capacity, which
    is 16\. By the *max flow min cut* theorem, the max flow that we can send through
    the network would be 16: Send <math alttext="y 1 equals 12"><mrow><msub><mi>y</mi>
    <mn>1</mn></msub> <mo>=</mo> <mn>12</mn></mrow></math> units through the edge
    with capacity 19, and <math alttext="y 2 equals 4"><mrow><msub><mi>y</mi> <mn>2</mn></msub>
    <mo>=</mo> <mn>4</mn></mrow></math> units through the edge with capacity 4\. Of
    those, <math alttext="y 3 equals 1"><mrow><msub><mi>y</mi> <mn>3</mn></msub> <mo>=</mo>
    <mn>1</mn></mrow></math> unit will flow through the edge with capacity 1, <math
    alttext="y 4 equals 11"><mrow><msub><mi>y</mi> <mn>4</mn></msub> <mo>=</mo> <mn>11</mn></mrow></math>
    units will flow through the edge with capacity 11, and <math alttext="y 5 equals
    1 plus 4 equals 5"><mrow><msub><mi>y</mi> <mn>5</mn></msub> <mo>=</mo> <mn>1</mn>
    <mo>+</mo> <mn>4</mn> <mo>=</mo> <mn>5</mn></mrow></math> units will flow through
    the bottom edge with capacity 6\. All 12 units will make their way to the destination
    through the last two edges connected to it, with <math alttext="y 6 equals 0"><mrow><msub><mi>y</mi>
    <mn>6</mn></msub> <mo>=</mo> <mn>0</mn></mrow></math> (no units need to flow through
    the vertical edge with capacity 7), <math alttext="y 7 equals 11"><mrow><msub><mi>y</mi>
    <mn>7</mn></msub> <mo>=</mo> <mn>11</mn></mrow></math> units flow through the
    right most edge with capacity 12, and <math alttext="y 8 equals 5"><mrow><msub><mi>y</mi>
    <mn>8</mn></msub> <mo>=</mo> <mn>5</mn></mrow></math> units flow through right
    most edge with capacity 6\. The solution to the max flow problem is now <math
    alttext="left-parenthesis y 1 comma y 2 comma y 3 comma y 4 comma y 5 comma y
    6 comma y 7 comma y 8 right-parenthesis equals left-parenthesis 12 comma 4 comma
    1 comma 11 comma 5 comma 0 comma 11 comma 5 right-parenthesis"><mrow><mrow><mo>(</mo>
    <msub><mi>y</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>2</mn></msub>
    <mo>,</mo> <msub><mi>y</mi> <mn>3</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>4</mn></msub>
    <mo>,</mo> <msub><mi>y</mi> <mn>5</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>6</mn></msub>
    <mo>,</mo> <msub><mi>y</mi> <mn>7</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>8</mn></msub>
    <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <mn>12</mn> <mo>,</mo> <mn>4</mn>
    <mo>,</mo> <mn>1</mn> <mo>,</mo> <mn>11</mn> <mo>,</mo> <mn>5</mn> <mo>,</mo>
    <mn>0</mn> <mo>,</mo> <mn>11</mn> <mo>,</mo> <mn>5</mn> <mo>)</mo></mrow></mrow></math>
    .'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-9](#Fig_max_flow)显示了通过网络的所有割（如果我们一起切割，就无法从起点到达目的地的边的集合）的值，以及最小总边容量的割，为16。根据*最大流最小割*定理，我们可以通过网络发送的最大流量为16：通过容量为19的边发送<math
    alttext="y 1 等于12"><mrow><msub><mi>y</mi> <mn>1</mn></msub> <mo>=</mo> <mn>12</mn></mrow></math>单位，通过容量为4的边发送<math
    alttext="y 2 等于4"><mrow><msub><mi>y</mi> <mn>2</mn></msub> <mo>=</mo> <mn>4</mn></mrow></math>单位。其中，<math
    alttext="y 3 等于1"><mrow><msub><mi>y</mi> <mn>3</mn></msub> <mo>=</mo> <mn>1</mn></mrow></math>单位将通过容量为1的边流过，<math
    alttext="y 4 等于11"><mrow><msub><mi>y</mi> <mn>4</mn></msub> <mo>=</mo> <mn>11</mn></mrow></math>单位将通过容量为11的边流过，<math
    alttext="y 5 等于1加4等于5"><mrow><msub><mi>y</mi> <mn>5</mn></msub> <mo>=</mo> <mn>1</mn>
    <mo>+</mo> <mn>4</mn> <mo>=</mo> <mn>5</mn></mrow></math>单位将通过容量为6的底部边流过。所有12个单位将通过连接到它的最后两条边到达目的地，其中<math
    alttext="y 6 等于0"><mrow><msub><mi>y</mi> <mn>6</mn></msub> <mo>=</mo> <mn>0</mn></mrow></math>（不需要通过容量为7的垂直边流过），<math
    alttext="y 7 等于11"><mrow><msub><mi>y</mi> <mn>7</mn></msub> <mo>=</mo> <mn>11</mn></mrow></math>单位通过容量为12的最右边流过，<math
    alttext="y 8 等于5"><mrow><msub><mi>y</mi> <mn>8</mn></msub> <mo>=</mo> <mn>5</mn></mrow></math>单位通过容量为6的最右边流过。现在最大流问题的解为<math
    alttext="（y 1，y 2，y 3，y 4，y 5，y 6，y 7，y 8）等于（12，4，1，11，5，0，11，5）"><mrow><mrow><mo>(</mo>
    <msub><mi>y</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>2</mn></msub>
    <mo>,</mo> <msub><mi>y</mi> <mn>3</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>4</mn></msub>
    <mo>,</mo> <msub><mi>y</mi> <mn>5</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>6</mn></msub>
    <mo>,</mo> <msub><mi>y</mi> <mn>7</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>8</mn></msub>
    <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <mn>12</mn> <mo>,</mo> <mn>4</mn>
    <mo>,</mo> <mn>1</mn> <mo>,</mo> <mn>11</mn> <mo>,</mo> <mn>5</mn> <mo>,</mo>
    <mn>0</mn> <mo>,</mo> <mn>11</mn> <mo>,</mo> <mn>5</mn> <mo>)</mo></mrow></mrow></math>。'
- en: 'In order to formulate this network problem as a linear optimization problem
    (which we just solved graphically using our knowledge of the value of the minimal
    cut, which is the solution of the dual problem), we need to add one more fictional
    edge with flow value <math alttext="y 9"><msub><mi>y</mi> <mn>9</mn></msub></math>
    that connects the destination to the origin, and assume that the flow that gets
    to the destination fictionally finds its way back to the origin. In other words,
    we *close the circuit*, and apply *Kirchhoff’s current law* which says *the sum
    of currents in a network of conductors meeting at a point is zero*, or the flow
    into a node is equal to the flow out of it. The linear maximization problem now
    becomes:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个网络问题制定为线性优化问题（我们刚刚使用对偶问题的解来图形化解决了它，即最小割的值），我们需要添加一条流量值为<math alttext="y
    9"><msub><mi>y</mi> <mn>9</mn></msub></math>的虚构边，将目的地连接到起点，并假设到达目的地的流量虚拟地回到起点。换句话说，我们*闭合电路*，并应用*Kirchhoff电流定律*，即*在相遇于一点的导体网络中的电流之和为零*，或者节点的流入等于流出。线性最大化问题现在变为：
- en: <math alttext="dollar-sign max Underscript StartLayout 1st Row 1st Column Blank
    2nd Column upper A ModifyingAbove y With right-arrow equals ModifyingAbove 0 With
    right-arrow 2nd Row 1st Column Blank 2nd Column StartAbsoluteValue y Subscript
    i Baseline EndAbsoluteValue less-than-or-equal-to upper M Subscript i Baseline
    EndLayout Endscripts y 9 dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">max</mo>
    <mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mi>A</mi><mover
    accent="true"><mi>y</mi> <mo>→</mo></mover><mo>=</mo><mover accent="true"><mn>0</mn>
    <mo>→</mo></mover></mrow></mtd></mtr><mtr><mtd columnalign="left"><mrow><mrow><mo>|</mo></mrow><msub><mi>y</mi>
    <mi>i</mi></msub> <mrow><mo>|</mo><mo>≤</mo></mrow><msub><mi>M</mi> <mi>i</mi></msub></mrow></mtd></mtr></mtable></msub>
    <msub><mi>y</mi> <mn>9</mn></msub></mrow></math>
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign max Underscript StartLayout 1st Row 1st Column Blank
    2nd Column upper A ModifyingAbove y With right-arrow equals ModifyingAbove 0 With
    right-arrow 2nd Row 1st Column Blank 2nd Column StartAbsoluteValue y Subscript
    i Baseline EndAbsoluteValue less-than-or-equal-to upper M Subscript i Baseline
    EndLayout Endscripts y 9 dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">max</mo>
    <mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mi>A</mi><mover
    accent="true"><mi>y</mi> <mo>→</mo></mover><mo>=</mo><mover accent="true"><mn>0</mn>
    <mo>→</mo></mover></mrow></mtd></mtr><mtr><mtd columnalign="left"><mrow><mrow><mo>|</mo></mrow><msub><mi>y</mi>
    <mi>i</mi></msub> <mrow><mo>|</mo><mo>≤</mo></mrow><msub><mi>M</mi> <mi>i</mi></msub></mrow></mtd></mtr></mtable></msub>
    <msub><mi>y</mi> <mn>9</mn></msub></mrow></math>
- en: where *A* ([Figure 10-10](#Fig_incidence_matrix)) is the incidence matrix of
    our network, <math alttext="ModifyingAbove y With right-arrow equals left-parenthesis
    y 1 comma y 2 comma y 3 comma y 4 comma y 5 comma y 6 comma y 7 comma y 8 comma
    y 9 right-parenthesis Superscript t"><mrow><mover accent="true"><mi>y</mi> <mo>→</mo></mover>
    <mo>=</mo> <msup><mrow><mo>(</mo><msub><mi>y</mi> <mn>1</mn></msub> <mo>,</mo><msub><mi>y</mi>
    <mn>2</mn></msub> <mo>,</mo><msub><mi>y</mi> <mn>3</mn></msub> <mo>,</mo><msub><mi>y</mi>
    <mn>4</mn></msub> <mo>,</mo><msub><mi>y</mi> <mn>5</mn></msub> <mo>,</mo><msub><mi>y</mi>
    <mn>6</mn></msub> <mo>,</mo><msub><mi>y</mi> <mn>7</mn></msub> <mo>,</mo><msub><mi>y</mi>
    <mn>8</mn></msub> <mo>,</mo><msub><mi>y</mi> <mn>9</mn></msub> <mo>)</mo></mrow>
    <mi>t</mi></msup></mrow></math> is the vector of *signed* maximum flow (we allow
    the *y* values to be negative so that the flow in would cancel the flow out) that
    we can send through each edge and that we need to solve for (we just found its
    solution without the signs by inspection using the minimal cut intuition), <math
    alttext="upper M Subscript i"><msub><mi>M</mi> <mi>i</mi></msub></math> is the
    max capacity of each edge in the network, and the condition <math alttext="upper
    A ModifyingAbove y With right-arrow equals ModifyingAbove 0 With right-arrow"><mrow><mi>A</mi>
    <mover accent="true"><mi>y</mi> <mo>→</mo></mover> <mo>=</mo> <mover accent="true"><mn>0</mn>
    <mo>→</mo></mover></mrow></math> guarantees that the flow into a node is equal
    to the flow out of a node. Of course in this case the network will have directed
    edges showing in which direction the optimal flow will go through each edge.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*A*（[图10-10](#Fig_incidence_matrix)）是我们网络的关联矩阵，<math alttext="ModifyingAbove
    y With right-arrow equals left-parenthesis y 1 comma y 2 comma y 3 comma y 4 comma
    y 5 comma y 6 comma y 7 comma y 8 comma y 9 right-parenthesis Superscript t"><mrow><mover
    accent="true"><mi>y</mi> <mo>→</mo></mover> <mo>=</mo> <msup><mrow><mo>(</mo><msub><mi>y</mi>
    <mn>1</mn></msub> <mo>,</mo><msub><mi>y</mi> <mn>2</mn></msub> <mo>,</mo><msub><mi>y</mi>
    <mn>3</mn></msub> <mo>,</mo><msub><mi>y</mi> <mn>4</mn></msub> <mo>,</mo><msub><mi>y</mi>
    <mn>5</mn></msub> <mo>,</mo><msub><mi>y</mi> <mn>6</mn></msub> <mo>,</mo><msub><mi>y</mi>
    <mn>7</mn></msub> <mo>,</mo><msub><mi>y</mi> <mn>8</mn></msub> <mo>,</mo><msub><mi>y</mi>
    <mn>9</mn></msub> <mo>)</mo></mrow> <mi>t</mi></msup></mrow></math> 是*有符号*最大流向量（我们允许*y*值为负，以便流入的流量抵消流出的流量），我们需要解决这个问题（我们刚刚通过最小割直觉找到了它的解，不考虑符号），<math
    alttext="upper M Subscript i"><msub><mi>M</mi> <mi>i</mi></msub></math> 是网络中每条边的最大容量，条件<math
    alttext="upper A ModifyingAbove y With right-arrow equals ModifyingAbove 0 With
    right-arrow"><mrow><mi>A</mi> <mover accent="true"><mi>y</mi> <mo>→</mo></mover>
    <mo>=</mo> <mover accent="true"><mn>0</mn> <mo>→</mo></mover></mrow></math> 保证了流入节点的流量等于流出节点的流量。当然，在这种情况下，网络将具有显示最佳流通过每条边的方向的有向边。
- en: '![250](assets/emai_1010.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![250](assets/emai_1010.png)'
- en: Figure 10-10\. Incidence matrix of the network in [Figure 10-9](#Fig_max_flow).
  id: totrans-319
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-10。[图10-9](#Fig_max_flow)中网络的关联矩阵。
- en: Now that we have a linear formulation of the max flow problem, we can write
    its dual easily using the methods we learned in this chapter (the minimum cut
    problem), and solve either the primal or the dual. Note that all we need for this
    formulation is the incidence matrix of the network, the edge capacities, and the
    Kirchoff’s condition that the flow into a node is equal to the flow out of the
    node.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对最大流问题有了线性表述，我们可以使用本章学到的方法（最小割问题）轻松地编写其对偶，并解决原问题或对偶问题。请注意，这个表述所需的仅仅是网络的关联矩阵、边的容量和基尔霍夫条件，即流入节点的流量等于流出节点的流量。
- en: 'Example: Two person zero sum games, linear optimization and duality'
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：两人零和游戏、线性优化和对偶。
- en: 'Another relevant setting where duality and linear optimization are built in
    is the two person zero sum game from game theory. A gain to one player is a loss
    to the other (hint: duality). To articulate the problem mathematically, we need
    the *payoff matrix* for all the options in the game for each of <math alttext="p
    l a y e r 1"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi>
    <mn>1</mn></msub></mrow></math> and <math alttext="p l a y e r 2"><mrow><mi>p</mi>
    <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>2</mn></msub></mrow></math>
    . Each player wants to devise a strategy that maximizes their pay given their
    options (no one said that the payoff matrices for the games have to be fair).
    We need to solve for the optimal strategy for each player. If we set up the optimization
    problem for <math alttext="p l a y e r 1"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi>
    <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>1</mn></msub></mrow></math> , we do
    not to start from scratch to get the optimization problem for the strategy of
    <math alttext="p l a y e r 2"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi>
    <mi>e</mi> <msub><mi>r</mi> <mn>2</mn></msub></mrow></math> : We just write its
    dual. The sum expected payoff of the game will be the same for both players, assuming
    that both of them act rationally and follow their optimal strategies.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相关的设置是博弈论中的两人零和博弈，其中包含对偶性和线性优化。对一个玩家的收益就是另一个玩家的损失（提示：对偶性）。为了在数学上表达这个问题，我们需要为每个玩家<math
    alttext="p l a y e r 1"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi>
    <msub><mi>r</mi> <mn>1</mn></msub></mrow></math> 和<math alttext="p l a y e r 2"><mrow><mi>p</mi>
    <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>2</mn></msub></mrow></math>
    的游戏中的所有选项建立*收益矩阵*。每个玩家都希望制定一种策略，以最大化他们的收益（没有人说游戏的收益矩阵必须是公平的）。我们需要为每个玩家解决最佳策略。如果我们为<math
    alttext="p l a y e r 1"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi>
    <msub><mi>r</mi> <mn>1</mn></msub></mrow></math> 设置优化问题，我们不需要从头开始得到<math alttext="p
    l a y e r 2"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi>
    <mn>2</mn></msub></mrow></math> 的策略的优化问题：我们只需编写其对偶。假设两个玩家都理性行事并遵循他们的最佳策略，游戏的总预期收益对于两个玩家来说是相同的。
- en: 'Consider for example the payoff matrix in [Figure 10-11](#Fig_payoff_matrix).
    The game goes like this: <math alttext="p l a y e r 1"><mrow><mi>p</mi> <mi>l</mi>
    <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>1</mn></msub></mrow></math>
    chooses a row and <math alttext="p l a y e r 2"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi>
    <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>2</mn></msub></mrow></math> chooses
    a column at the same time. <math alttext="p l a y e r 1"><mrow><mi>p</mi> <mi>l</mi>
    <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>1</mn></msub></mrow></math>
    pays the number in the chosen row and column to <math alttext="p l a y e r 2"><mrow><mi>p</mi>
    <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>2</mn></msub></mrow></math>
    . Therefore, <math alttext="p l a y e r 1"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi>
    <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>1</mn></msub></mrow></math> wants to
    minimize and <math alttext="p l a y e r 2"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi>
    <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>2</mn></msub></mrow></math> wants to
    maximize. The players repeat the game many times.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑例如[图10-11](#Fig_payoff_matrix)中的收益矩阵。游戏进行如下：<math alttext="p l a y e r 1"><mrow><mi>p</mi>
    <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>1</mn></msub></mrow></math>选择一行，<math
    alttext="p l a y e r 2"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi>
    <msub><mi>r</mi> <mn>2</mn></msub></mrow></math>同时选择一列。<math alttext="p l a y
    e r 1"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi>
    <mn>1</mn></msub></mrow></math>支付所选行和列中的数字给<math alttext="p l a y e r 2"><mrow><mi>p</mi>
    <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>2</mn></msub></mrow></math>。因此，<math
    alttext="p l a y e r 1"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi>
    <msub><mi>r</mi> <mn>1</mn></msub></mrow></math>希望最小化，<math alttext="p l a y e
    r 2"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi>
    <mn>2</mn></msub></mrow></math>希望最大化。玩家重复游戏多次。
- en: What is the optimal strategy for each of <math alttext="p l a y e r 1"><mrow><mi>p</mi>
    <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>1</mn></msub></mrow></math>
    and <math alttext="p l a y e r 2"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi>
    <mi>e</mi> <msub><mi>r</mi> <mn>2</mn></msub></mrow></math> and what is the expected
    payoff of the game?
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个<math alttext="p l a y e r 1"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi>
    <mi>e</mi> <msub><mi>r</mi> <mn>1</mn></msub></mrow></math>和<math alttext="p l
    a y e r 2"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi>
    <mn>2</mn></msub></mrow></math>的最佳策略是什么，游戏的预期收益是多少？
- en: '![250](assets/emai_1011.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![250](assets/emai_1011.png)'
- en: Figure 10-11\. Payoff matrix.
  id: totrans-326
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-11. 收益矩阵。
- en: To find the optimal strategy, Suppose <math alttext="p l a y e r 1"><mrow><mi>p</mi>
    <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>1</mn></msub></mrow></math>
    chooses <math alttext="r o w 1"><mrow><mi>r</mi> <mi>o</mi> <msub><mi>w</mi> <mn>1</mn></msub></mrow></math>
    with probability <math alttext="x 1"><msub><mi>x</mi> <mn>1</mn></msub></math>
    and <math alttext="r o w 2"><mrow><mi>r</mi> <mi>o</mi> <msub><mi>w</mi> <mn>2</mn></msub></mrow></math>
    with probability <math alttext="x 2"><msub><mi>x</mi> <mn>2</mn></msub></math>
    . Then <math alttext="x 1 plus x 2 equals 1"><mrow><msub><mi>x</mi> <mn>1</mn></msub>
    <mo>+</mo> <msub><mi>x</mi> <mn>2</mn></msub> <mo>=</mo> <mn>1</mn></mrow></math>
    , <math alttext="0 less-than-or-equal-to x 1 less-than-or-equal-to 1"><mrow><mn>0</mn>
    <mo>≤</mo> <msub><mi>x</mi> <mn>1</mn></msub> <mo>≤</mo> <mn>1</mn></mrow></math>
    , and <math alttext="0 less-than-or-equal-to x 2 less-than-or-equal-to 1"><mrow><mn>0</mn>
    <mo>≤</mo> <msub><mi>x</mi> <mn>2</mn></msub> <mo>≤</mo> <mn>1</mn></mrow></math>
    . <math alttext="p l a y e r 1"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi>
    <mi>e</mi> <msub><mi>r</mi> <mn>1</mn></msub></mrow></math> rationalizes that
    if he uses an <math alttext="left-parenthesis x 1 comma x 2 right-parenthesis"><mrow><mo>(</mo>
    <msub><mi>x</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>x</mi> <mn>2</mn></msub>
    <mo>)</mo></mrow></math> mixed strategy, there would be another row in the payoff
    matrix corresponding to this new strategy (see [Figure 10-11](#Fig_payoff_matrix)).
    Now <math alttext="p l a y e r 1"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi>
    <mi>e</mi> <msub><mi>r</mi> <mn>1</mn></msub></mrow></math> knows that <math alttext="p
    l a y e r 2"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi>
    <mn>2</mn></msub></mrow></math> wants to choose the column that maximizes their
    payoff, so <math alttext="p l a y e r 1"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi>
    <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>1</mn></msub></mrow></math> must choose
    <math alttext="left-parenthesis x 1 comma x 2 right-parenthesis"><mrow><mo>(</mo>
    <msub><mi>x</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>x</mi> <mn>2</mn></msub>
    <mo>)</mo></mrow></math> that make the worst payoff (maximum of the third row)
    as small as possible. Therefore, <math alttext="p l a y e r 1"><mrow><mi>p</mi>
    <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>1</mn></msub></mrow></math>
    must solve the *min max* problem
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到最优策略，假设<math alttext="p l a y e r 1"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi>
    <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>1</mn></msub></mrow></math>选择<math
    alttext="r o w 1"><mrow><mi>r</mi> <mi>o</mi> <msub><mi>w</mi> <mn>1</mn></msub></mrow></math>的概率为<math
    alttext="x 1"><msub><mi>x</mi> <mn>1</mn></msub></math>，选择<math alttext="r o w
    2"><mrow><mi>r</mi> <mi>o</mi> <msub><mi>w</mi> <mn>2</mn></msub></mrow></math>的概率为<math
    alttext="x 2"><msub><mi>x</mi> <mn>2</mn></msub></math>。那么<math alttext="x 1 plus
    x 2 equals 1"><mrow><msub><mi>x</mi> <mn>1</mn></msub> <mo>+</mo> <msub><mi>x</mi>
    <mn>2</mn></msub> <mo>=</mo> <mn>1</mn></mrow></math>，<math alttext="0 less-than-or-equal-to
    x 1 less-than-or-equal-to 1"><mrow><mn>0</mn> <mo>≤</mo> <msub><mi>x</mi> <mn>1</mn></msub>
    <mo>≤</mo> <mn>1</mn></mrow></math>，以及<math alttext="0 less-than-or-equal-to x
    2 less-than-or-equal-to 1"><mrow><mn>0</mn> <mo>≤</mo> <msub><mi>x</mi> <mn>2</mn></msub>
    <mo>≤</mo> <mn>1</mn></mrow></math>。<math alttext="p l a y e r 1"><mrow><mi>p</mi>
    <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>1</mn></msub></mrow></math>推断，如果他使用一个<math
    alttext="left-parenthesis x 1 comma x 2 right-parenthesis"><mrow><mo>(</mo> <msub><mi>x</mi>
    <mn>1</mn></msub> <mo>,</mo> <msub><mi>x</mi> <mn>2</mn></msub> <mo>)</mo></mrow></math>混合策略，那么支付矩阵中会有另一行对应于这个新策略（见[图10-11](#Fig_payoff_matrix)）。现在<math
    alttext="p l a y e r 1"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi>
    <msub><mi>r</mi> <mn>1</mn></msub></mrow></math>知道<math alttext="p l a y e r 2"><mrow><mi>p</mi>
    <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>2</mn></msub></mrow></math>想要选择最大化他们的支付的列，所以<math
    alttext="p l a y e r 1"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi>
    <msub><mi>r</mi> <mn>1</mn></msub></mrow></math>必须选择使最差支付（第三行的最大值）尽可能小的<math alttext="left-parenthesis
    x 1 comma x 2 right-parenthesis"><mrow><mo>(</mo> <msub><mi>x</mi> <mn>1</mn></msub>
    <mo>,</mo> <msub><mi>x</mi> <mn>2</mn></msub> <mo>)</mo></mrow></math>。因此，<math
    alttext="p l a y e r 1"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi>
    <msub><mi>r</mi> <mn>1</mn></msub></mrow></math>必须解决*min max*问题
- en: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column 0 less-than-or-equal-to x 1 less-than-or-equal-to 1 2nd Row 1st Column
    Blank 2nd Column 0 less-than-or-equal-to x 2 less-than-or-equal-to 1 3rd Row 1st
    Column Blank 2nd Column x 1 plus x 2 equals 1 EndLayout Endscripts max x 1 plus
    3 x 2 comma minus x 2 comma 4 x 1 plus 2 x 2 dollar-sign"><mrow><msub><mo form="prefix"
    movablelimits="true">min</mo> <mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mn>0</mn><mo>≤</mo><msub><mi>x</mi>
    <mn>1</mn></msub> <mo>≤</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd columnalign="left"><mrow><mn>0</mn><mo>≤</mo><msub><mi>x</mi>
    <mn>2</mn></msub> <mo>≤</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd columnalign="left"><mrow><msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo><msub><mi>x</mi> <mn>2</mn></msub> <mo>=</mo><mn>1</mn></mrow></mtd></mtr></mtable></msub>
    <mo form="prefix" movablelimits="true">max</mo> <mrow><msub><mi>x</mi> <mn>1</mn></msub>
    <mo>+</mo> <mn>3</mn> <msub><mi>x</mi> <mn>2</mn></msub> <mo>,</mo> <mo>-</mo>
    <msub><mi>x</mi> <mn>2</mn></msub> <mo>,</mo> <mn>4</mn> <msub><mi>x</mi> <mn>1</mn></msub>
    <mo>+</mo> <mn>2</mn> <msub><mi>x</mi> <mn>2</mn></msub></mrow></mrow></math>
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column 0 less-than-or-equal-to x 1 less-than-or-equal-to 1 2nd Row 1st Column
    Blank 2nd Column 0 less-than-or-equal-to x 2 less-than-or-equal-to 1 3rd Row 1st
    Column Blank 2nd Column x 1 plus x 2 equals 1 EndLayout Endscripts max x 1 plus
    3 x 2 comma minus x 2 comma 4 x 1 plus 2 x 2 dollar-sign"><mrow><msub><mo form="prefix"
    movablelimits="true">min</mo> <mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mn>0</mn><mo>≤</mo><msub><mi>x</mi>
    <mn>1</mn></msub> <mo>≤</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd columnalign="left"><mrow><mn>0</mn><mo>≤</mo><msub><mi>x</mi>
    <mn>2</mn></msub> <mo>≤</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd columnalign="left"><mrow><msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo><msub><mi>x</mi> <mn>2</mn></msub> <mo>=</mo><mn>1</mn></mrow></mtd></mtr></mtable></msub>
    <mo form="prefix" movablelimits="true">max</mo> <mrow><msub><mi>x</mi> <mn>1</mn></msub>
    <mo>+</mo> <mn>3</mn> <msub><mi>x</mi> <mn>2</mn></msub> <mo>,</mo> <mo>-</mo>
    <msub><mi>x</mi> <mn>2</mn></msub> <mo>,</mo> <mn>4</mn> <msub><mi>x</mi> <mn>1</mn></msub>
    <mo>+</mo> <mn>2</mn> <msub><mi>x</mi> <mn>2</mn></msub></mrow></mrow></math>
- en: 'Recall that the maximum of linear functions is a convex piecewise linear function.
    We can easily change such a *min max(linear functions)* problem to a linear minimization
    problem:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，线性函数的最大值是一个凸分段线性函数。我们可以很容易地将这样一个*min max(线性函数)*问题转化为线性最小化问题：
- en: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column z greater-than-or-equal-to x 1 plus 3 x 2 2nd Row 1st Column Blank
    2nd Column z greater-than-or-equal-to minus x 2 3rd Row 1st Column Blank 2nd Column
    z greater-than-or-equal-to 4 x 1 plus 2 x 2 4th Row 1st Column Blank 2nd Column
    0 less-than-or-equal-to x 1 less-than-or-equal-to 1 5th Row 1st Column Blank 2nd
    Column 0 less-than-or-equal-to x 2 less-than-or-equal-to 1 6th Row 1st Column
    Blank 2nd Column x 1 plus x 2 equals 1 EndLayout Endscripts z dollar-sign"><mrow><msub><mo
    form="prefix" movablelimits="true">min</mo> <mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mi>z</mi><mo>≥</mo><msub><mi>x</mi> <mn>1</mn></msub>
    <mo>+</mo><mn>3</mn><msub><mi>x</mi> <mn>2</mn></msub></mrow></mtd></mtr> <mtr><mtd
    columnalign="left"><mrow><mi>z</mi><mo>≥</mo><mo>-</mo><msub><mi>x</mi> <mn>2</mn></msub></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>z</mi><mo>≥</mo><mn>4</mn><msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo><mn>2</mn><msub><mi>x</mi> <mn>2</mn></msub></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mn>0</mn><mo>≤</mo><msub><mi>x</mi> <mn>1</mn></msub>
    <mo>≤</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd columnalign="left"><mrow><mn>0</mn><mo>≤</mo><msub><mi>x</mi>
    <mn>2</mn></msub> <mo>≤</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd columnalign="left"><mrow><msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo><msub><mi>x</mi> <mn>2</mn></msub> <mo>=</mo><mn>1</mn></mrow></mtd></mtr></mtable></msub>
    <mi>z</mi></mrow></math>
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript StartLayout 1st Row 1st Column Blank
    2nd Column z greater-than-or-equal-to x 1 plus 3 x 2 2nd Row 1st Column Blank
    2nd Column z greater-than-or-equal-to minus x 2 3rd Row 1st Column Blank 2nd Column
    z greater-than-or-equal-to 4 x 1 plus 2 x 2 4th Row 1st Column Blank 2nd Column
    0 less-than-or-equal-to x 1 less-than-or-equal-to 1 5th Row 1st Column Blank 2nd
    Column 0 less-than-or-equal-to x 2 less-than-or-equal-to 1 6th Row 1st Column
    Blank 2nd Column x 1 plus x 2 equals 1 EndLayout Endscripts z dollar-sign"><mrow><msub><mo
    form="prefix" movablelimits="true">min</mo> <mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mi>z</mi><mo>≥</mo><msub><mi>x</mi> <mn>1</mn></msub>
    <mo>+</mo><mn>3</mn><msub><mi>x</mi> <mn>2</mn></msub></mrow></mtd></mtr> <mtr><mtd
    columnalign="left"><mrow><mi>z</mi><mo>≥</mo><mo>-</mo><msub><mi>x</mi> <mn>2</mn></msub></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>z</mi><mo>≥</mo><mn>4</mn><msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo><mn>2</mn><msub><mi>x</mi> <mn>2</mn></msub></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mn>0</mn><mo>≤</mo><msub><mi>x</mi> <mn>1</mn></msub>
    <mo>≤</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd columnalign="left"><mrow><mn>0</mn><mo>≤</mo><msub><mi>x</mi>
    <mn>2</mn></msub> <mo>≤</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd columnalign="left"><mrow><msub><mi>x</mi>
    <mn>1</mn></msub> <mo>+</mo><msub><mi>x</mi> <mn>2</mn></msub> <mo>=</mo><mn>1</mn></mrow></mtd></mtr></mtable></msub>
    <mi>z</mi></mrow></math>
- en: '[Figure 10-12](#Fig_write_dual) shows the formulation of the dual of the above
    problem, which [Figure 10-13](#Fig_same_problem) shows that this is exactly the
    problem that <math alttext="p l a y e r 2"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi>
    <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>2</mn></msub></mrow></math> is trying
    to solve.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-12](#Fig_write_dual)展示了上述问题的对偶形式，而[图10-13](#Fig_same_problem)则显示这正是<math
    alttext="p l a y e r 2"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi>
    <msub><mi>r</mi> <mn>2</mn></msub></mrow></math>试图解决的问题。'
- en: '![250](assets/emai_1012.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![250](assets/emai_1012.png)'
- en: Figure 10-12\. The dual of <math alttext="p l a y e r 1"><mrow><mi>p</mi> <mi>l</mi>
    <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>1</mn></msub></mrow></math>
    ’s problem.
  id: totrans-333
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-12\. <math alttext="p l a y e r 1"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi>
    <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>1</mn></msub></mrow></math> 的问题的对偶形式。
- en: '![250](assets/emai_1013.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![250](assets/emai_1013.png)'
- en: Figure 10-13\. The dual of <math alttext="p l a y e r 1"><mrow><mi>p</mi> <mi>l</mi>
    <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>1</mn></msub></mrow></math>
    ’s *min max* problem is the same as <math alttext="p l a y e r 2"><mrow><mi>p</mi>
    <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>2</mn></msub></mrow></math>
    ’s *max min* problem.
  id: totrans-335
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-13\. <math alttext="p l a y e r 1"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi>
    <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>1</mn></msub></mrow></math>的*min max*问题的对偶与<math
    alttext="p l a y e r 2"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi>
    <msub><mi>r</mi> <mn>2</mn></msub></mrow></math>的*max min*问题相同。
- en: Note that the constraints <math alttext="y 1 less-than-or-equal-to 1"><mrow><msub><mi>y</mi>
    <mn>1</mn></msub> <mo>≤</mo> <mn>1</mn></mrow></math> , <math alttext="y 2 less-than-or-equal-to
    1"><mrow><msub><mi>y</mi> <mn>2</mn></msub> <mo>≤</mo> <mn>1</mn></mrow></math>
    , and <math alttext="y 3 less-than-or-equal-to 1"><mrow><msub><mi>y</mi> <mn>3</mn></msub>
    <mo>≤</mo> <mn>1</mn></mrow></math> are redundant since we have that all the y’s
    are nonnegative and they add up to 1\. Similarly with the constraints <math alttext="x
    1 less-than-or-equal-to 1"><mrow><msub><mi>x</mi> <mn>1</mn></msub> <mo>≤</mo>
    <mn>1</mn></mrow></math> and <math alttext="x 2 less-than-or-equal-to 1"><mrow><msub><mi>x</mi>
    <mn>2</mn></msub> <mo>≤</mo> <mn>1</mn></mrow></math> . This happens a lot when
    formulating linear optimization problems.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，约束条件<math alttext="y 1 小于等于 1"><mrow><msub><mi>y</mi> <mn>1</mn></msub>
    <mo>≤</mo> <mn>1</mn></mrow></math>，<math alttext="y 2 小于等于 1"><mrow><msub><mi>y</mi>
    <mn>2</mn></msub> <mo>≤</mo> <mn>1</mn></mrow></math>和<math alttext="y 3 小于等于
    1"><mrow><msub><mi>y</mi> <mn>3</mn></msub> <mo>≤</mo> <mn>1</mn></mrow></math>是多余的，因为我们知道所有的y都是非负的且它们加起来等于1。同样，对于约束条件<math
    alttext="x 1 小于等于 1"><mrow><msub><mi>x</mi> <mn>1</mn></msub> <mo>≤</mo> <mn>1</mn></mrow></math>和<math
    alttext="x 2 小于等于 1"><mrow><msub><mi>x</mi> <mn>2</mn></msub> <mo>≤</mo> <mn>1</mn></mrow></math>也是如此。在制定线性优化问题时，这种情况经常发生。
- en: 'Solving either the primal or the dual problem, we find each player’s optimal
    strategy: <math alttext="p l a y e r 1"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi>
    <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>1</mn></msub></mrow></math> must go
    with the first row <math alttext="x 1 equals 0.25"><mrow><msub><mi>x</mi> <mn>1</mn></msub>
    <mo>=</mo> <mn>0</mn> <mo>.</mo> <mn>25</mn></mrow></math> of the time and with
    the second row <math alttext="x 2 equals 0.75"><mrow><msub><mi>x</mi> <mn>2</mn></msub>
    <mo>=</mo> <mn>0</mn> <mo>.</mo> <mn>75</mn></mrow></math> of the time, for an
    expected payoff of 2.5, which means <math alttext="p l a y e r 1"><mrow><mi>p</mi>
    <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>1</mn></msub></mrow></math>
    expects to lose no more than 2.5 with this strategy. <math alttext="p l a y e
    r 2"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi>
    <mn>2</mn></msub></mrow></math> must go with the first column <math alttext="y
    1 equals 0.5"><mrow><msub><mi>y</mi> <mn>1</mn></msub> <mo>=</mo> <mn>0</mn> <mo>.</mo>
    <mn>5</mn></mrow></math> of the time and with the third column <math alttext="y
    3 equals 0.5"><mrow><msub><mi>y</mi> <mn>3</mn></msub> <mo>=</mo> <mn>0</mn> <mo>.</mo>
    <mn>5</mn></mrow></math> of the time (never with the second column <math alttext="y
    2 equals 0"><mrow><msub><mi>y</mi> <mn>2</mn></msub> <mo>=</mo> <mn>0</mn></mrow></math>
    ), for an expected payoff of 2.5, which means <math alttext="p l a y e r 2"><mrow><mi>p</mi>
    <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>2</mn></msub></mrow></math>
    expects to gain no less than 2.5 with this strategy.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 解决原始问题或对偶问题，我们找到每个玩家的最佳策略：<math alttext="p l a y e r 1"><mrow><mi>p</mi> <mi>l</mi>
    <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi> <mn>1</mn></msub></mrow></math>必须选择第一行<math
    alttext="x 1 等于 0.25"><mrow><msub><mi>x</mi> <mn>1</mn></msub> <mo>=</mo> <mn>0</mn>
    <mo>.</mo> <mn>25</mn></mrow></math>的时间和第二行<math alttext="x 2 等于 0.75"><mrow><msub><mi>x</mi>
    <mn>2</mn></msub> <mo>=</mo> <mn>0</mn> <mo>.</mo> <mn>75</mn></mrow></math>的时间，预期收益为2.5，这意味着<math
    alttext="p l a y e r 1"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi>
    <msub><mi>r</mi> <mn>1</mn></msub></mrow></math>预计使用这种策略不会损失超过2.5。<math alttext="p
    l a y e r 2"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi>
    <mn>2</mn></msub></mrow></math>必须选择第一列<math alttext="y 1 等于 0.5"><mrow><msub><mi>y</mi>
    <mn>1</mn></msub> <mo>=</mo> <mn>0</mn> <mo>.</mo> <mn>5</mn></mrow></math>的时间和第三列<math
    alttext="y 3 等于 0.5"><mrow><msub><mi>y</mi> <mn>3</mn></msub> <mo>=</mo> <mn>0</mn>
    <mo>.</mo> <mn>5</mn></mrow></math>的时间（不会选择第二列<math alttext="y 2 等于 0"><mrow><msub><mi>y</mi>
    <mn>2</mn></msub> <mo>=</mo> <mn>0</mn></mrow></math>），预期收益为2.5，这意味着<math alttext="p
    l a y e r 2"><mrow><mi>p</mi> <mi>l</mi> <mi>a</mi> <mi>y</mi> <mi>e</mi> <msub><mi>r</mi>
    <mn>2</mn></msub></mrow></math>预计使用这种策略不会获得少于2.5。
- en: Quadratic optimization with linear constraints, Lagrangian, min max theorem,
    and duality
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有线性约束、拉格朗日、极小极大定理和对偶性的二次优化
- en: 'A *nonlinear* optimization problem that has a nice structure, appears in all
    kinds of applications, and has a lot to teach us on how things tie together, is
    a quadratic problem with linear constraints:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有良好结构的*非线性*优化问题，在各种应用中都会出现，并且可以教会我们很多关于事物如何联系在一起的知识，就是一个具有线性约束的二次问题：
- en: <math alttext="dollar-sign min Underscript upper A ModifyingAbove x With right-arrow
    equals ModifyingAbove b With right-arrow Endscripts one-half ModifyingAbove x
    With right-arrow Superscript t Baseline upper S ModifyingAbove x With right-arrow
    dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo> <mrow><mi>A</mi><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>=</mo><mover accent="true"><mi>b</mi>
    <mo>→</mo></mover></mrow></msub> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mi>t</mi></msup> <mi>S</mi> <mover
    accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></math>
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript upper A ModifyingAbove x With right-arrow
    equals ModifyingAbove b With right-arrow Endscripts one-half ModifyingAbove x
    With right-arrow Superscript t Baseline upper S ModifyingAbove x With right-arrow
    dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo> <mrow><mi>A</mi><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mo>=</mo><mover accent="true"><mi>b</mi>
    <mo>→</mo></mover></mrow></msub> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mi>t</mi></msup> <mi>S</mi> <mover
    accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></math>
- en: Here, *S* is a symmetric and positive semidefinite matrix, which means that
    its eigenvalues are nonnegative. For high dimensions, this plays the role of keeping
    the objective function convex and bounded below, or shaped like the bowl of the
    one dimensional function <math alttext="f left-parenthesis x right-parenthesis
    equals x squared"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math> .
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*S*是一个对称且半正定矩阵，这意味着它的特征值是非负的。对于高维空间，这起到了使目标函数凸且下界有界，或者形状像一维函数的碗状的作用。
- en: 'For example, this is a two dimensional quadratic optimization problem with
    one linear constraint:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个具有一个线性约束的二维二次优化问题：
- en: <math alttext="dollar-sign min Underscript a 1 x 1 plus a 2 x 2 equals b Endscripts
    one-half left-parenthesis s 1 x 1 squared plus s 2 x 2 squared right-parenthesis
    dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo> <mrow><msub><mi>a</mi>
    <mn>1</mn></msub> <msub><mi>x</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>a</mi>
    <mn>2</mn></msub> <msub><mi>x</mi> <mn>2</mn></msub> <mo>=</mo><mi>b</mi></mrow></msub>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mrow><mo>(</mo> <msub><mi>s</mi> <mn>1</mn></msub>
    <msubsup><mi>x</mi> <mn>1</mn> <mn>2</mn></msubsup> <mo>+</mo> <msub><mi>s</mi>
    <mn>2</mn></msub> <msubsup><mi>x</mi> <mn>2</mn> <mn>2</mn></msubsup> <mo>)</mo></mrow></mrow></math>
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript a 1 x 1 plus a 2 x 2 equals b Endscripts
    one-half left-parenthesis s 1 x 1 squared plus s 2 x 2 squared right-parenthesis
    dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo> <mrow><msub><mi>a</mi>
    <mn>1</mn></msub> <msub><mi>x</mi> <mn>1</mn></msub> <mo>+</mo><msub><mi>a</mi>
    <mn>2</mn></msub> <msub><mi>x</mi> <mn>2</mn></msub> <mo>=</mo><mi>b</mi></mrow></msub>
    <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mrow><mo>(</mo> <msub><mi>s</mi> <mn>1</mn></msub>
    <msubsup><mi>x</mi> <mn>1</mn> <mn>2</mn></msubsup> <mo>+</mo> <msub><mi>s</mi>
    <mn>2</mn></msub> <msubsup><mi>x</mi> <mn>2</mn> <mn>2</mn></msubsup> <mo>)</mo></mrow></mrow></math>
- en: 'Here, <math alttext="upper S equals Start 2 By 2 Matrix 1st Row 1st Column
    s 1 2nd Column 0 2nd Row 1st Column 0 2nd Column s 2 EndMatrix"><mrow><mi>S</mi>
    <mo>=</mo> <mfenced close=")" open="("><mtable><mtr><mtd><msub><mi>s</mi> <mn>1</mn></msub></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><msub><mi>s</mi> <mn>2</mn></msub></mtd></mtr></mtable></mfenced></mrow></math>
    where the *s* entries are nonnegative, and <math alttext="upper A equals Start
    1 By 2 Matrix 1st Row 1st Column a 1 2nd Column a 2 EndMatrix"><mrow><mi>A</mi>
    <mo>=</mo> <mfenced close=")" open="("><mtable><mtr><mtd><msub><mi>a</mi> <mn>1</mn></msub></mtd>
    <mtd><msub><mi>a</mi> <mn>2</mn></msub></mtd></mtr></mtable></mfenced></mrow></math>
    . Inspecting this problem, we are searching for the point <math alttext="left-parenthesis
    x 1 comma x 2 right-parenthesis"><mrow><mo>(</mo> <msub><mi>x</mi> <mn>1</mn></msub>
    <mo>,</mo> <msub><mi>x</mi> <mn>2</mn></msub> <mo>)</mo></mrow></math> on the
    straight line <math alttext="a 1 x 1 plus a 2 x 2 equals b"><mrow><msub><mi>a</mi>
    <mn>1</mn></msub> <msub><mi>x</mi> <mn>1</mn></msub> <mo>+</mo> <msub><mi>a</mi>
    <mn>2</mn></msub> <msub><mi>x</mi> <mn>2</mn></msub> <mo>=</mo> <mi>b</mi></mrow></math>
    that minimizes the quantity <math alttext="f left-parenthesis ModifyingAbove x
    With right-arrow right-parenthesis equals s 1 x 1 squared plus s 2 x 2 squared"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mi>s</mi> <mn>1</mn></msub> <msubsup><mi>x</mi> <mn>1</mn> <mn>2</mn></msubsup>
    <mo>+</mo> <msub><mi>s</mi> <mn>2</mn></msub> <msubsup><mi>x</mi> <mn>2</mn> <mn>2</mn></msubsup></mrow></math>
    . The level sets of the objective function <math alttext="s 1 x 1 squared plus
    s 2 x 2 squared equals k"><mrow><msub><mi>s</mi> <mn>1</mn></msub> <msubsup><mi>x</mi>
    <mn>1</mn> <mn>2</mn></msubsup> <mo>+</mo> <msub><mi>s</mi> <mn>2</mn></msub>
    <msubsup><mi>x</mi> <mn>2</mn> <mn>2</mn></msubsup> <mo>=</mo> <mi>k</mi></mrow></math>
    are concentric ellipses that cover the whole <math alttext="double-struck upper
    R squared"><msup><mi>ℝ</mi> <mn>2</mn></msup></math> plane. The winning ellipse
    (the one with smallest level set value) is the one that is tangent to straight
    line at the winning point ([Figure 10-14](#Fig_quadratic_optimization)). At this
    point, the gradient vector of the ellipse and the gradient vector of the constraint
    align, which is exactly what Lagrange multiplier formulation gives us: To formulate
    the Lagrangian, relax the constraint, but pay a penalty equal to the lagrange
    multiplier *p* times how much we relaxed it in the objective function, minimizing
    the uncontrained problem'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，<math alttext="upper S equals Start 2 By 2 Matrix 1st Row 1st Column s 1
    2nd Column 0 2nd Row 1st Column 0 2nd Column s 2 EndMatrix"><mrow><mi>S</mi> <mo>=</mo>
    <mfenced close=")" open="("><mtable><mtr><mtd><msub><mi>s</mi> <mn>1</mn></msub></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><msub><mi>s</mi> <mn>2</mn></msub></mtd></mtr></mtable></mfenced></mrow></math>，其中
    *s* 的条目是非负的，而 <math alttext="upper A equals Start 1 By 2 Matrix 1st Row 1st Column
    a 1 2nd Column a 2 EndMatrix"><mrow><mi>A</mi> <mo>=</mo> <mfenced close=")" open="("><mtable><mtr><mtd><msub><mi>a</mi>
    <mn>1</mn></msub></mtd> <mtd><msub><mi>a</mi> <mn>2</mn></msub></mtd></mtr></mtable></mfenced></mrow></math>。检查这个问题，我们正在寻找直线
    <math alttext="a 1 x 1 plus a 2 x 2 equals b"><mrow><msub><mi>a</mi> <mn>1</mn></msub>
    <msub><mi>x</mi> <mn>1</mn></msub> <mo>+</mo> <msub><mi>a</mi> <mn>2</mn></msub>
    <msub><mi>x</mi> <mn>2</mn></msub> <mo>=</mo> <mi>b</mi></mrow></math> 上使得量 <math
    alttext="f left-parenthesis ModifyingAbove x With right-arrow right-parenthesis
    equals s 1 x 1 squared plus s 2 x 2 squared"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mi>s</mi> <mn>1</mn></msub> <msubsup><mi>x</mi> <mn>1</mn> <mn>2</mn></msubsup>
    <mo>+</mo> <msub><mi>s</mi> <mn>2</mn></msub> <msubsup><mi>x</mi> <mn>2</mn> <mn>2</mn></msubsup></mrow></math>
    最小化的点 <math alttext="left-parenthesis x 1 comma x 2 right-parenthesis"><mrow><mo>(</mo>
    <msub><mi>x</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>x</mi> <mn>2</mn></msub>
    <mo>)</mo></mrow></math>，目标函数的等高线是同心椭圆，覆盖整个 <math alttext="double-struck upper
    R squared"><msup><mi>ℝ</mi> <mn>2</mn></msup></math> 平面。获胜的椭圆（具有最小等高线值的椭圆）是在获胜点处与直线相切的椭圆（[图10-14](#Fig_quadratic_optimization)）。在这一点上，椭圆的梯度向量和约束的梯度向量是对齐的，这正是拉格朗日乘数公式给我们的：制定拉格朗日函数，放宽约束，但在目标函数中支付一个等于拉格朗日乘数
    *p* 乘以我们在目标函数中放松的量的惩罚，从而最小化无约束问题。
- en: <math alttext="dollar-sign script upper L left-parenthesis ModifyingAbove x
    With right-arrow semicolon p right-parenthesis equals f left-parenthesis ModifyingAbove
    x With right-arrow right-parenthesis plus p left-parenthesis b minus g left-parenthesis
    ModifyingAbove x With right-arrow right-parenthesis right-parenthesis equals s
    1 x 1 squared plus s 2 x 2 squared plus p left-parenthesis b minus a 1 x 1 minus
    a 2 x 2 right-parenthesis dollar-sign"><mrow><mi>ℒ</mi> <mrow><mo>(</mo> <mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>;</mo> <mi>p</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mo>+</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>b</mi> <mo>-</mo>
    <mi>g</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>s</mi> <mn>1</mn></msub>
    <msubsup><mi>x</mi> <mn>1</mn> <mn>2</mn></msubsup> <mo>+</mo> <msub><mi>s</mi>
    <mn>2</mn></msub> <msubsup><mi>x</mi> <mn>2</mn> <mn>2</mn></msubsup> <mo>+</mo>
    <mi>p</mi> <mrow><mo>(</mo> <mi>b</mi> <mo>-</mo> <msub><mi>a</mi> <mn>1</mn></msub>
    <msub><mi>x</mi> <mn>1</mn></msub> <mo>-</mo> <msub><mi>a</mi> <mn>2</mn></msub>
    <msub><mi>x</mi> <mn>2</mn></msub> <mo>)</mo></mrow></mrow></math>
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign script upper L left-parenthesis ModifyingAbove x
    With right-arrow semicolon p right-parenthesis equals f left-parenthesis ModifyingAbove
    x With right-arrow right-parenthesis plus p left-parenthesis b minus g left-parenthesis
    ModifyingAbove x With right-arrow right-parenthesis right-parenthesis equals s
    1 x 1 squared plus s 2 x 2 squared plus p left-parenthesis b minus a 1 x 1 minus
    a 2 x 2 right-parenthesis dollar-sign"><mrow><mi>ℒ</mi> <mrow><mo>(</mo> <mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>;</mo> <mi>p</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mo>+</mo> <mi>p</mi> <mrow><mo>(</mo> <mi>b</mi> <mo>-</mo>
    <mi>g</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>s</mi> <mn>1</mn></msub>
    <msubsup><mi>x</mi> <mn>1</mn> <mn>2</mn></msubsup> <mo>+</mo> <msub><mi>s</mi>
    <mn>2</mn></msub> <msubsup><mi>x</mi> <mn>2</mn> <mn>2</mn></msubsup> <mo>+</mo>
    <mi>p</mi> <mrow><mo>(</mo> <mi>b</mi> <mo>-</mo> <msub><mi>a</mi> <mn>1</mn></msub>
    <msub><mi>x</mi> <mn>1</mn></msub> <mo>-</mo> <msub><mi>a</mi> <mn>2</mn></msub>
    <msub><mi>x</mi> <mn>2</mn></msub> <mo>)</mo></mrow></mrow></math>
- en: When we minimize the Lagrangian, we set its gradient equal to zero, and that
    leads to <math alttext="normal nabla f left-parenthesis ModifyingAbove x With
    right-arrow right-parenthesis equals p normal nabla g left-parenthesis ModifyingAbove
    x With right-arrow right-parenthesis"><mrow><mi>∇</mi> <mi>f</mi> <mrow><mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow> <mo>=</mo>
    <mi>p</mi> <mi>∇</mi> <mi>g</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>)</mo></mrow></mrow></math> . This says that the gradient
    vector of the objective function is parallel to the gradient vector of the constraint
    at the optimizing point(s). Since the gradient vector of any function is perpendicular
    to its level sets, this means that the constraint is in fact tangent to the level
    set of the objective function at the minimizing point(s). Therefore, to find the
    optimizing point(s), we look for the level sets of the objective function where
    it happens to be tangent to the constraint.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最小化拉格朗日函数时，我们将其梯度设为零，这导致 <math alttext="normal nabla f left-parenthesis ModifyingAbove
    x With right-arrow right-parenthesis equals p normal nabla g left-parenthesis
    ModifyingAbove x With right-arrow right-parenthesis"><mrow><mi>∇</mi> <mi>f</mi>
    <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow>
    <mo>=</mo> <mi>p</mi> <mi>∇</mi> <mi>g</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>)</mo></mrow></mrow></math>。这意味着目标函数的梯度向量与优化点处约束的梯度向量平行。由于任何函数的梯度向量垂直于其等高线，这意味着约束实际上与最小化点处的目标函数的等高线相切。因此，要找到优化点，我们寻找目标函数的等高线，看它何时恰好与约束相切。
- en: '![150](assets/emai_1014.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![150](assets/emai_1014.png)'
- en: Figure 10-14\. The level sets of the quadratic function <math alttext="x 1 squared
    plus 4 x squared"><mrow><msubsup><mi>x</mi> <mn>1</mn> <mn>2</mn></msubsup> <mo>+</mo>
    <mn>4</mn> <msup><mi>x</mi> <mn>2</mn></msup></mrow></math> are concentric ellipses,
    each of them has a constant value. When we impose the linear constraint <math
    alttext="x 1 plus x 2 equals 2.5"><mrow><msub><mi>x</mi> <mn>1</mn></msub> <mo>+</mo>
    <msub><mi>x</mi> <mn>2</mn></msub> <mo>=</mo> <mn>2</mn> <mo>.</mo> <mn>5</mn></mrow></math>
    , we get the optimizer (2,0.5) at exactly the point where one of the level sets
    is tangent to the constraint. The value of the optimal level set is <math alttext="x
    1 squared plus 4 x squared equals 5"><mrow><msubsup><mi>x</mi> <mn>1</mn> <mn>2</mn></msubsup>
    <mo>+</mo> <mn>4</mn> <msup><mi>x</mi> <mn>2</mn></msup> <mo>=</mo> <mn>5</mn></mrow></math>
    .
  id: totrans-348
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-14。二次函数的水平集是同心椭圆，每个椭圆都有一个恒定值。当我们施加线性约束<math alttext="x 1 plus x 2 equals
    2.5"><mrow><msub><mi>x</mi> <mn>1</mn></msub> <mo>+</mo> <msub><mi>x</mi> <mn>2</mn></msub>
    <mo>=</mo> <mn>2</mn> <mo>.</mo> <mn>5</mn></mrow></math>时，我们得到优化器(2,0.5)，恰好在一个水平集与约束相切的点。最优水平集的值为<math
    alttext="x 1 squared plus 4 x squared equals 5"><mrow><msubsup><mi>x</mi> <mn>1</mn>
    <mn>2</mn></msubsup> <mo>+</mo> <mn>4</mn> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>=</mo> <mn>5</mn></mrow></math>。
- en: 'Another example that helps us visualize Lagrangian and the upcoming *min max
    theorem* is a trivial one dimensional example:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个帮助我们可视化拉格朗日和即将到来的*极小极大定理*的例子是一个简单的一维例子：
- en: <math alttext="dollar-sign min Underscript x equals 1 Endscripts x squared dollar-sign"><mrow><msub><mo
    form="prefix" movablelimits="true">min</mo> <mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow></msub>
    <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript x equals 1 Endscripts x squared dollar-sign"><mrow><msub><mo
    form="prefix" movablelimits="true">min</mo> <mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow></msub>
    <msup><mi>x</mi> <mn>2</mn></msup></mrow></math>
- en: 'The Lagrangian is <math alttext="script upper L left-parenthesis x semicolon
    p right-parenthesis equals x squared minus p left-parenthesis 1 minus x right-parenthesis"><mrow><mi>ℒ</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>;</mo> <mi>p</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mi>p</mi> <mrow><mo>(</mo> <mn>1</mn>
    <mo>-</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math> . We use this toy example
    whose optimizer is obviously <math alttext="x equals 1"><mrow><mi>x</mi> <mo>=</mo>
    <mn>1</mn></mrow></math> with minimal value 1 so that we can visualize the Lagrangian.
    Recall that the Lagrange formulation makes the dimension jump up, in this case
    we have one constraint so the dimension increases from one to two, and in our
    limited three dimensional world we can only visualize functions of two variables
    (*x* and *p*). [Figure 10-15](#Fig_saddle_lagrange) shows the landscape of our
    trivial Lagrangian function which is now representative for Lagrangian formulations
    for quadratic optimization problems with linear constraints. The main thing to
    pay attention to in [Figure 10-15](#Fig_saddle_lagrange) is that the optimizers
    of these kinds of problems <math alttext="left-parenthesis x Superscript asterisk
    Baseline semicolon p Superscript asterisk Baseline right-parenthesis"><mrow><mo>(</mo>
    <msup><mi>x</mi> <mo>*</mo></msup> <mo>;</mo> <msup><mi>p</mi> <mo>*</mo></msup>
    <mo>)</mo></mrow></math> happen at *saddle points* of the Lagrangian: These are
    points where the *second derivative* is positive in one variable and negative
    in another, so the landscape of the Lagrangian function is convex in one variable
    (*x*) and concave in the other (*p*).'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 拉格朗日是<math alttext="script upper L left-parenthesis x semicolon p right-parenthesis
    equals x squared minus p left-parenthesis 1 minus x right-parenthesis"><mrow><mi>ℒ</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>;</mo> <mi>p</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mi>p</mi> <mrow><mo>(</mo> <mn>1</mn>
    <mo>-</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>。我们使用这个玩具例子，其优化器显然是<math
    alttext="x equals 1"><mrow><mi>x</mi> <mo>=</mo> <mn>1</mn></mrow></math>，最小值为1，以便我们可以可视化拉格朗日。回想一下，拉格朗日公式使维度跳跃，这种情况下我们有一个约束，所以维度从一维增加到二维，在我们有限的三维世界中，我们只能可视化两个变量（*x*和*p*）的函数。[图10-15](#Fig_saddle_lagrange)展示了我们简单拉格朗日函数的景观，现在代表了具有线性约束的二次优化问题的拉格朗日公式。在[图10-15](#Fig_saddle_lagrange)中需要注意的主要事项是这类问题的优化器<math
    alttext="left-parenthesis x Superscript asterisk Baseline semicolon p Superscript
    asterisk Baseline right-parenthesis"><mrow><mo>(</mo> <msup><mi>x</mi> <mo>*</mo></msup>
    <mo>;</mo> <msup><mi>p</mi> <mo>*</mo></msup> <mo>)</mo></mrow></math>发生在拉格朗日的*鞍点*处：这些点是拉格朗日函数在一个变量中是正的，而在另一个变量中是负的二阶导数，因此拉格朗日函数的景观在一个变量（*x*）中是凸的，在另一个变量（*p*）中是凹的。
- en: '![150](assets/emai_1015.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![150](assets/emai_1015.png)'
- en: Figure 10-15\. The optimizer of the constrained problem happens at the saddle
    point of the Lagrangian (note that the minimum of the Lagrangian itself is <math
    alttext="negative normal infinity"><mrow><mo>-</mo> <mi>∞</mi></mrow></math> ,
    but that is not what we care for, because we care about the optimizer of the quadratic
    function with linear constraints).
  id: totrans-353
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-15。约束问题的优化器发生在拉格朗日的鞍点（请注意，拉格朗日本身的最小值是<math alttext="negative normal infinity"><mrow><mo>-</mo>
    <mi>∞</mi></mrow></math>，但这不是我们关心的，因为我们关心的是具有线性约束的二次函数的优化器）。
- en: One way to locate the saddle points of the Lagrangian (which give us the optimizers
    of the corresponding constrained problems) is to solve <math alttext="normal nabla
    script upper L left-parenthesis x semicolon p right-parenthesis equals ModifyingAbove
    0 With right-arrow"><mrow><mi>∇</mi> <mi>ℒ</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>;</mo>
    <mi>p</mi> <mo>)</mo></mrow> <mo>=</mo> <mover accent="true"><mn>0</mn> <mo>→</mo></mover></mrow></math>
    for *x* and *p*, but that is the brute force way which works for simple problems
    (like the trivial one at hand) or for small size problems. Another way to find
    these saddle points is to minimize in *x* then maximize in *p* ([Figure 10-16](#Fig_maxmin)).
    Yet another way is to maximize in *p* then minimize in *x*. The *min max theorem*
    says that these two paths are the same.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 定位拉格朗日的鞍点（给出相应约束问题的优化器）的一种方法是解<math alttext="normal nabla script upper L left-parenthesis
    x semicolon p right-parenthesis equals ModifyingAbove 0 With right-arrow"><mrow><mi>∇</mi>
    <mi>ℒ</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>;</mo> <mi>p</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mover accent="true"><mn>0</mn> <mo>→</mo></mover></mrow></math>得到*x*和*p*，但这是对简单问题（如手头的简单问题）或小规模问题有效的蛮力方法。另一种找到这些鞍点的方法是先在*x*中最小化，然后在*p*中最大化（[图10-16](#Fig_maxmin)）。另一种方法是先在*p*中最大化，然后在*x*中最小化。*极小极大定理*表明这两条路径是相同的。
- en: '![150](assets/emai_1016.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![150](assets/emai_1016.png)'
- en: Figure 10-16\. Minimizing over x then maximizing over *p* gives <math alttext="max
    Underscript p Endscripts x Superscript asterisk Baseline left-parenthesis p right-parenthesis
    equals x Superscript asterisk Baseline left-parenthesis p Superscript asterisk
    Baseline right-parenthesis"><mrow><msub><mo form="prefix" movablelimits="true">max</mo>
    <mi>p</mi></msub> <msup><mi>x</mi> <mo>*</mo></msup> <mrow><mo>(</mo> <mi>p</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mo>*</mo></msup> <mrow><mo>(</mo>
    <msup><mi>p</mi> <mo>*</mo></msup> <mo>)</mo></mrow></mrow></math> =the saddle
    point. This will give the same answer as maximizng over *p* then minimizing over
    *x*.
  id: totrans-356
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-16。在x上最小化然后在p上最大化得到<math alttext="max Underscript p Endscripts x Superscript
    asterisk Baseline left-parenthesis p right-parenthesis equals x Superscript asterisk
    Baseline left-parenthesis p Superscript asterisk Baseline right-parenthesis"><mrow><msub><mo
    form="prefix" movablelimits="true">max</mo> <mi>p</mi></msub> <msup><mi>x</mi>
    <mo>*</mo></msup> <mrow><mo>(</mo> <mi>p</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi>
    <mo>*</mo></msup> <mrow><mo>(</mo> <msup><mi>p</mi> <mo>*</mo></msup> <mo>)</mo></mrow></mrow></math>
    =鞍点。这将得到与先在*p*上最大化然后在*x*上最小化相同的答案。
- en: Therefore, at the saddle point <math alttext="left-parenthesis x Superscript
    asterisk Baseline comma p Superscript asterisk Baseline right-parenthesis"><mrow><mo>(</mo>
    <msup><mi>x</mi> <mo>*</mo></msup> <mo>,</mo> <msup><mi>p</mi> <mo>*</mo></msup>
    <mo>)</mo></mrow></math> , we have <math alttext="normal nabla script upper L
    left-parenthesis x semicolon p right-parenthesis equals 0"><mrow><mi>∇</mi> <mi>ℒ</mi>
    <mo>(</mo> <mi>x</mi> <mo>;</mo> <mi>p</mi> <mo>)</mo> <mo>=</mo> <mn>0</mn></mrow></math>
    (which is the same as <math alttext="StartFraction normal partial-differential
    script upper L left-parenthesis x semicolon p right-parenthesis Over normal partial-differential
    x EndFraction equals 0"><mrow><mfrac><mrow><mi>∂</mi><mi>ℒ</mi><mo>(</mo><mi>x</mi><mo>;</mo><mi>p</mi><mo>)</mo></mrow>
    <mrow><mi>∂</mi><mi>x</mi></mrow></mfrac> <mo>=</mo> <mn>0</mn></mrow></math>
    and <math alttext="StartFraction normal partial-differential script upper L left-parenthesis
    x semicolon p right-parenthesis Over normal partial-differential p EndFraction
    equals 0"><mrow><mfrac><mrow><mi>∂</mi><mi>ℒ</mi><mo>(</mo><mi>x</mi><mo>;</mo><mi>p</mi><mo>)</mo></mrow>
    <mrow><mi>∂</mi><mi>p</mi></mrow></mfrac> <mo>=</mo> <mn>0</mn></mrow></math>
    ), *and*
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在鞍点<math alttext="left-parenthesis x Superscript asterisk Baseline comma
    p Superscript asterisk Baseline right-parenthesis"><mrow><mo>(</mo> <msup><mi>x</mi>
    <mo>*</mo></msup> <mo>,</mo> <msup><mi>p</mi> <mo>*</mo></msup> <mo>)</mo></mrow></math>处，我们有<math
    alttext="normal nabla script upper L left-parenthesis x semicolon p right-parenthesis
    equals 0"><mrow><mi>∇</mi> <mi>ℒ</mi> <mo>(</mo> <mi>x</mi> <mo>;</mo> <mi>p</mi>
    <mo>)</mo> <mo>=</mo> <mn>0</mn></mrow></math>（与<math alttext="StartFraction normal
    partial-differential script upper L left-parenthesis x semicolon p right-parenthesis
    Over normal partial-differential x EndFraction equals 0"><mrow><mfrac><mrow><mi>∂</mi><mi>ℒ</mi><mo>(</mo><mi>x</mi><mo>;</mo><mi>p</mi><mo>)</mo></mrow>
    <mrow><mi>∂</mi><mi>x</mi></mrow></mfrac> <mo>=</mo> <mn>0</mn></mrow></math>和<math
    alttext="StartFraction normal partial-differential script upper L left-parenthesis
    x semicolon p right-parenthesis Over normal partial-differential p EndFraction
    equals 0"><mrow><mfrac><mrow><mi>∂</mi><mi>ℒ</mi><mo>(</mo><mi>x</mi><mo>;</mo><mi>p</mi><mo>)</mo></mrow>
    <mrow><mi>∂</mi><mi>p</mi></mrow></mfrac> <mo>=</mo> <mn>0</mn></mrow></math>），*以及*
- en: <math alttext="dollar-sign min Underscript x Endscripts max Underscript p comma
    hold x fixed Endscripts script upper L left-parenthesis x semicolon p right-parenthesis
    equals max Underscript p Endscripts min Underscript x comma hold p fixed Endscripts
    script upper L left-parenthesis x semicolon p right-parenthesis dollar-sign"><mrow><msub><mo
    form="prefix" movablelimits="true">min</mo> <mi>x</mi></msub> <msub><mo form="prefix"
    movablelimits="true">max</mo> <mrow><mi>p</mi><mo>,</mo><mtext>hold</mtext><mtext>x</mtext><mtext>fixed</mtext></mrow></msub>
    <mi>ℒ</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>;</mo> <mi>p</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mo form="prefix" movablelimits="true">max</mo> <mi>p</mi></msub>
    <msub><mo form="prefix" movablelimits="true">min</mo> <mrow><mi>x</mi><mo>,</mo><mtext>hold</mtext><mtext>p</mtext><mtext>fixed</mtext></mrow></msub>
    <mi>ℒ</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>;</mo> <mi>p</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript x Endscripts max Underscript p comma
    hold x fixed Endscripts script upper L left-parenthesis x semicolon p right-parenthesis
    equals max Underscript p Endscripts min Underscript x comma hold p fixed Endscripts
    script upper L left-parenthesis x semicolon p right-parenthesis dollar-sign"><mrow><msub><mo
    form="prefix" movablelimits="true">min</mo> <mi>x</mi></msub> <msub><mo form="prefix"
    movablelimits="true">max</mo> <mrow><mi>p</mi><mo>,</mo><mtext>hold</mtext><mtext>x</mtext><mtext>fixed</mtext></mrow></msub>
    <mi>ℒ</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>;</mo> <mi>p</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mo form="prefix" movablelimits="true">max</mo> <mi>p</mi></msub>
    <msub><mo form="prefix" movablelimits="true">min</mo> <mrow><mi>x</mi><mo>,</mo><mtext>hold</mtext><mtext>p</mtext><mtext>fixed</mtext></mrow></msub>
    <mi>ℒ</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>;</mo> <mi>p</mi> <mo>)</mo></mrow></mrow></math>
- en: We have gone a full circle to yet again demonstrate that accompanying in a constrained
    minimization problem in *x* we have another constrained maximization problem in
    the Lagrange multipliers *p*. The interplay between Lagrange multipliers, duality,
    and constrained optimization is at full display.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完整地展示了，在*x*中的受约束最小化问题中，我们有另一个在Lagrange乘子*p*中的受约束最大化问题。Lagrange乘子、对偶性和受约束优化之间的相互作用得到了充分展示。
- en: 'Now that we went through the important ideas, let’s go back and put them in
    the context of the higher dimensional quadratic problem with linear constraints
    that we started this subsection with:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了重要的思想，让我们回过头来将它们放在我们开始这个小节的具有线性约束的高维二次问题的背景中：
- en: <math alttext="dollar-sign min Underscript upper A ModifyingAbove x With right-arrow
    equals ModifyingAbove b With right-arrow Endscripts one-half ModifyingAbove x
    With right-arrow Superscript t Baseline upper S ModifyingAbove x With right-arrow
    comma dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo>
    <mrow><mi>A</mi><mover accent="true"><mi>x</mi> <mo>→</mo></mover><mo>=</mo><mover
    accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></msub> <mfrac><mn>1</mn> <mn>2</mn></mfrac>
    <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mi>t</mi></msup> <mi>S</mi>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>,</mo></mrow></math>
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min Underscript upper A ModifyingAbove x With right-arrow
    equals ModifyingAbove b With right-arrow Endscripts one-half ModifyingAbove x
    With right-arrow Superscript t Baseline upper S ModifyingAbove x With right-arrow
    comma dollar-sign"><mrow><msub><mo form="prefix" movablelimits="true">min</mo>
    <mrow><mi>A</mi><mover accent="true"><mi>x</mi> <mo>→</mo></mover><mo>=</mo><mover
    accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></msub> <mfrac><mn>1</mn> <mn>2</mn></mfrac>
    <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mi>t</mi></msup> <mi>S</mi>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>,</mo></mrow></math>
- en: 'where *S* is a symmetric and positive definite matrix. The Lagrange formulation
    with *relaxed* constraints is:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*S*是对称且正定的矩阵。带有*放松*约束的Lagrange公式是：
- en: <math alttext="dollar-sign min script upper L left-parenthesis ModifyingAbove
    x With right-arrow semicolon ModifyingAbove p With right-arrow right-parenthesis
    equals min one-half ModifyingAbove x With right-arrow Superscript t Baseline upper
    S ModifyingAbove x With right-arrow plus ModifyingAbove p With right-arrow period
    left-parenthesis ModifyingAbove b With right-arrow minus upper A ModifyingAbove
    x With right-arrow right-parenthesis period dollar-sign"><mrow><mo form="prefix"
    movablelimits="true">min</mo> <mi>ℒ</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>;</mo> <mover accent="true"><mi>p</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mo>=</mo> <mo form="prefix" movablelimits="true">min</mo> <mfrac><mn>1</mn>
    <mn>2</mn></mfrac> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mi>t</mi></msup>
    <mi>S</mi> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>+</mo> <mover
    accent="true"><mi>p</mi> <mo>→</mo></mover> <mo>.</mo> <mrow><mo>(</mo> <mover
    accent="true"><mi>b</mi> <mo>→</mo></mover> <mo>-</mo> <mi>A</mi> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>)</mo></mrow> <mo>.</mo></mrow></math>
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign min script upper L left-parenthesis ModifyingAbove
    x With right-arrow semicolon ModifyingAbove p With right-arrow right-parenthesis
    equals min one-half ModifyingAbove x With right-arrow Superscript t Baseline upper
    S ModifyingAbove x With right-arrow plus ModifyingAbove p With right-arrow period
    left-parenthesis ModifyingAbove b With right-arrow minus upper A ModifyingAbove
    x With right-arrow right-parenthesis period dollar-sign"><mrow><mo form="prefix"
    movablelimits="true">min</mo> <mi>ℒ</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>;</mo> <mover accent="true"><mi>p</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mo>=</mo> <mo form="prefix" movablelimits="true">min</mo> <mfrac><mn>1</mn>
    <mn>2</mn></mfrac> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mi>t</mi></msup>
    <mi>S</mi> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>+</mo> <mover
    accent="true"><mi>p</mi> <mo>→</mo></mover> <mo>.</mo> <mrow><mo>(</mo> <mover
    accent="true"><mi>b</mi> <mo>→</mo></mover> <mo>-</mo> <mi>A</mi> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>)</mo></mrow> <mo>.</mo></mrow></math>
- en: 'Solving this unconstrained problem, whether by setting <math alttext="normal
    nabla script upper L left-parenthesis ModifyingAbove x With right-arrow semicolon
    ModifyingAbove p With right-arrow right-parenthesis equals ModifyingAbove 0 With
    right-arrow"><mrow><mi>∇</mi> <mi>ℒ</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>;</mo> <mover accent="true"><mi>p</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mo>=</mo> <mover accent="true"><mn>0</mn> <mo>→</mo></mover></mrow></math>
    , or by minimizing over <math alttext="ModifyingAbove x With right-arrow"><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover></math> then maximizing over <math
    alttext="ModifyingAbove p With right-arrow"><mover accent="true"><mi>p</mi> <mo>→</mo></mover></math>
    , or by maximizing over <math alttext="ModifyingAbove p With right-arrow"><mover
    accent="true"><mi>p</mi> <mo>→</mo></mover></math> then minimizing over <math
    alttext="ModifyingAbove x With right-arrow"><mover accent="true"><mi>x</mi> <mo>→</mo></mover></math>
    , we get the same solution <math alttext="left-parenthesis ModifyingAbove x With
    right-arrow Superscript asterisk Baseline semicolon ModifyingAbove p Superscript
    asterisk Baseline With right-arrow right-parenthesis"><mrow><mo>(</mo> <msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mo>;</mo> <mover
    accent="true"><msup><mi>p</mi> <mo>*</mo></msup> <mo>→</mo></mover> <mo>)</mo></mrow></math>
    , which happens at the *saddle point* of our high dimensional Lagrangian, and
    gives the optimal value of the objective function (the advantage of this problem
    with simple structure is that we can solve it by hand):'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个无约束问题，无论是通过设置 <math alttext="normal nabla script upper L left-parenthesis
    ModifyingAbove x With right-arrow semicolon ModifyingAbove p With right-arrow
    right-parenthesis equals ModifyingAbove 0 With right-arrow"><mrow><mi>∇</mi> <mi>ℒ</mi>
    <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>;</mo>
    <mover accent="true"><mi>p</mi> <mo>→</mo></mover> <mo>)</mo></mrow> <mo>=</mo>
    <mover accent="true"><mn>0</mn> <mo>→</mo></mover></mrow></math>，或者通过在 <math alttext="ModifyingAbove
    x With right-arrow"><mover accent="true"><mi>x</mi> <mo>→</mo></mover></math>
    上最小化然后在 <math alttext="ModifyingAbove p With right-arrow"><mover accent="true"><mi>p</mi>
    <mo>→</mo></mover></math> 上最大化，或者通过在 <math alttext="ModifyingAbove p With right-arrow"><mover
    accent="true"><mi>p</mi> <mo>→</mo></mover></math> 上最大化然后在 <math alttext="ModifyingAbove
    x With right-arrow"><mover accent="true"><mi>x</mi> <mo>→</mo></mover></math>
    上最小化，我们得到相同的解 <math alttext="left-parenthesis ModifyingAbove x With right-arrow
    Superscript asterisk Baseline semicolon ModifyingAbove p Superscript asterisk
    Baseline With right-arrow right-parenthesis"><mrow><mo>(</mo> <msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mo>;</mo> <mover accent="true"><msup><mi>p</mi>
    <mo>*</mo></msup> <mo>→</mo></mover> <mo>)</mo></mrow></math>，这发生在我们高维拉格朗日函数的*鞍点*处，并给出了目标函数的最优值（这个问题的简单结构的优势是我们可以手动解决）：
- en: <math alttext="dollar-sign minimum cost f equals one-half ModifyingAbove b With
    right-arrow period left-parenthesis upper A upper S Superscript negative 1 Baseline
    upper A Superscript t Baseline right-parenthesis Superscript negative 1 Baseline
    ModifyingAbove b With right-arrow dollar-sign"><mrow><mtext>minimum</mtext> <mtext>cost</mtext>
    <mtext>f</mtext> <mo>=</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mover accent="true"><mi>b</mi>
    <mo>→</mo></mover> <mo>.</mo> <msup><mrow><mo>(</mo><mi>A</mi><msup><mi>S</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msup><mi>A</mi> <mi>t</mi></msup> <mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mover accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></math>
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign minimum cost f equals one-half ModifyingAbove b With
    right-arrow period left-parenthesis upper A upper S Superscript negative 1 Baseline
    upper A Superscript t Baseline right-parenthesis Superscript negative 1 Baseline
    ModifyingAbove b With right-arrow dollar-sign"><mrow><mtext>minimum</mtext> <mtext>cost</mtext>
    <mtext>f</mtext> <mo>=</mo> <mfrac><mn>1</mn> <mn>2</mn></mfrac> <mover accent="true"><mi>b</mi>
    <mo>→</mo></mover> <mo>.</mo> <msup><mrow><mo>(</mo><mi>A</mi><msup><mi>S</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msup><mi>A</mi> <mi>t</mi></msup> <mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mover accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></math>
- en: 'Moreover, the optimal *shadow prices* are: <math alttext="ModifyingAbove p
    With right-arrow Superscript asterisk Baseline equals StartFraction d f Over d
    ModifyingAbove b With right-arrow EndFraction equals left-parenthesis upper A
    upper S Superscript negative 1 Baseline upper A Superscript t Baseline right-parenthesis
    Superscript negative 1 Baseline ModifyingAbove b With right-arrow"><mrow><msup><mover
    accent="true"><mi>p</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mo>=</mo> <mfrac><mrow><mi>d</mi><mi>f</mi></mrow>
    <mrow><mi>d</mi><mover accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></mfrac>
    <mo>=</mo> <msup><mrow><mo>(</mo><mi>A</mi><msup><mi>S</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi>A</mi> <mi>t</mi></msup> <mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mover accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></math> .'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，最优的*影子价格*是：<math alttext="ModifyingAbove p With right-arrow Superscript asterisk
    Baseline equals StartFraction d f Over d ModifyingAbove b With right-arrow EndFraction
    equals left-parenthesis upper A upper S Superscript negative 1 Baseline upper
    A Superscript t Baseline right-parenthesis Superscript negative 1 Baseline ModifyingAbove
    b With right-arrow"><mrow><msup><mover accent="true"><mi>p</mi> <mo>→</mo></mover>
    <mo>*</mo></msup> <mo>=</mo> <mfrac><mrow><mi>d</mi><mi>f</mi></mrow> <mrow><mi>d</mi><mover
    accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></mfrac> <mo>=</mo> <msup><mrow><mo>(</mo><mi>A</mi><msup><mi>S</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msup><mi>A</mi> <mi>t</mi></msup> <mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mover accent="true"><mi>b</mi> <mo>→</mo></mover></mrow></math>。
- en: 'The last thing we need to learn here is the characterization of saddle points
    in higher dimensions. For the one dimensional constrained problem, the hallmark
    was having the second derivative of the Lagrangian (which was a function of *x*
    and *p*) negative in one variable and positive in the other. The high dimensional
    analogue is this: The eigenvalues of the Hessian matrix (matrix of second derivatives)
    is negative in one set of variables and positive in the other set of variables,
    so it is concave in one set of variable and convex in the other. Our discussion
    applies to optimizing any higher dimensional objective function that is convex
    in one set of variables and concave in the other. This is the hallmark that the
    landscape has saddle points. For the Lagrangian function, the saddle point is
    exactly where the constrained problem attains its minimum.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在这里学习的最后一件事是在更高维度中对鞍点的表征。对于一维约束问题，标志是拉格朗日函数的二阶导数（这是一个关于*x*和*p*的函数）在一个变量中为负，在另一个变量中为正。高维度的类比是：Hessian矩阵（二阶导数矩阵）的特征值在一组变量中为负，在另一组变量中为正，因此在一组变量中是凹的，在另一组变量中是凸的。我们的讨论适用于优化任何高维目标函数，该函数在一组变量中是凸的，在另一组变量中是凹的。这是表明景观具有鞍点的标志。对于拉格朗日函数，鞍点恰好是约束问题达到最小值的地方。
- en: Does this apply to linear optimization problems with linear constraints, which
    are everywhere in operations research? Yes, as long as we have the correct signs
    for all the coefficients in the problem, such as the max flow min cut and the
    two person zero sum game examples we saw in the previous subsections.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否适用于线性约束的线性优化问题，在运筹学中随处可见？是的，只要我们在问题中所有系数的符号正确，例如我们在前面子节中看到的最大流最小割和两人零和博弈的例子。
- en: Sensitivity
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敏感性
- en: 'Here we care for the sensitivity of the optimization problem and its solution
    with respect to changes in its input data. That is, what happens to the optimal
    solution <math alttext="ModifyingAbove x With right-arrow Superscript asterisk"><msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup></math> and the optimal
    cost <math alttext="ModifyingAbove c With right-arrow period ModifyingAbove x
    With right-arrow Superscript asterisk"><mrow><mover accent="true"><mi>c</mi> <mo>→</mo></mover>
    <mo>.</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup></mrow></math>
    if we slightly change <math alttext="ModifyingAbove c With right-arrow"><mover
    accent="true"><mi>c</mi> <mo>→</mo></mover></math> , or *A*, or <math alttext="ModifyingAbove
    b With right-arrow"><mover accent="true"><mi>b</mi> <mo>→</mo></mover></math>
    ? Can we obtain the new optimal solution from the old one? Under what conditions
    can we do that? These are some important cases that sensitivity analysis addresses:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们关心优化问题及其解决方案对其输入数据变化的敏感性。也就是说，如果我们稍微改变<math alttext="ModifyingAbove c
    With right-arrow"><mover accent="true"><mi>c</mi> <mo>→</mo></mover></math>、或*A*、或<math
    alttext="ModifyingAbove b With right-arrow"><mover accent="true"><mi>b</mi> <mo>→</mo></mover></math>，那么最优解<math
    alttext="ModifyingAbove x With right-arrow Superscript asterisk"><msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup></math>和最优成本<math
    alttext="ModifyingAbove c With right-arrow period ModifyingAbove x With right-arrow
    Superscript asterisk"><mrow><mover accent="true"><mi>c</mi> <mo>→</mo></mover>
    <mo>.</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup></mrow></math>会发生什么？我们能否从旧解中获得新的最优解？在什么条件下我们可以这样做？这些是敏感性分析所涉及的一些重要情况：
- en: 'We have already interpreted the optimal <math alttext="ModifyingAbove p With
    right-arrow"><mover accent="true"><mi>p</mi> <mo>→</mo></mover></math> in the
    dual problem as the vector of marginal prices. This is related to sensitivity
    analysis: The rate of change of the optimal cost with respect to the constraint
    value.'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经将对偶问题中的最优<math alttext="ModifyingAbove p With right-arrow"><mover accent="true"><mi>p</mi>
    <mo>→</mo></mover></math>解释为边际价格的向量。这与敏感性分析有关：最优成本相对于约束值的变化率。
- en: If we add a new decision variable, we check its reduced cost, and if it is negative,
    we add a new column to the tableau and proceed from there.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们添加一个新的决策变量，我们会检查它的降低成本，如果是负的，我们会向表中添加一个新列并从那里继续。
- en: If an entry of <math alttext="ModifyingAbove b With right-arrow"><mover accent="true"><mi>b</mi>
    <mo>→</mo></mover></math> or <math alttext="ModifyingAbove c With right-arrow"><mover
    accent="true"><mi>c</mi> <mo>→</mo></mover></math> is changed by <math alttext="delta"><mi>δ</mi></math>
    , we obtain an interval of values of <math alttext="delta"><mi>δ</mi></math> for
    which the same basis remains optimal.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果<math alttext="ModifyingAbove b With right-arrow"><mover accent="true"><mi>b</mi>
    <mo>→</mo></mover></math>或<math alttext="ModifyingAbove c With right-arrow"><mover
    accent="true"><mi>c</mi> <mo>→</mo></mover></math>的一个元素改变了<math alttext="delta"><mi>δ</mi></math>，我们会得到一个<math
    alttext="delta"><mi>δ</mi></math>值的区间，使得相同的基础仍然是最优的。
- en: If an entry of *A* is changed by <math alttext="delta"><mi>δ</mi></math> , a
    similar analysis is possible. However, this case is somewhat complicated if the
    change affects an entry of a basic column.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*A*的一个元素改变了<math alttext="delta"><mi>δ</mi></math>，类似的分析是可能的。然而，如果这种改变影响了基本列的一个元素，情况就有些复杂了。
- en: In general, if we have a function and we want its sensitivity to variations
    with respect to one of its inputs, then that is similar to asking about its first
    derivative with respect to that input (at a certain state), or a discrete first
    derivative (finite difference) at that state. What makes sensitivity questions
    more interesting here is the fact that we are dealing with *constrained* problems
    and checking the effect of small variations in all kinds of inputs to the problem.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果我们有一个函数，我们想要了解它对其中一个输入的变化的敏感性，那就类似于询问关于该输入的一阶导数（在某个状态下），或者在该状态下的离散一阶导数（有限差分）。这里使得敏感性问题更有趣的是，我们正在处理*受限*问题，并检查问题的各种输入的小变化的影响。
- en: Game Theory And Multiagents
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 博弈论和多智能体
- en: Game theory is so important for economics, politics, military operations, multi-agent
    AI, and basically for modeling any environment where there are adversaries or
    competitors, and we have to make decisions or strategize in these conditions.
    Our optimal strategies are heavily influenced by our adversaries’ strategies,
    whether we know them or are only speculating about them.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 博弈论对经济学、政治、军事行动、多智能体人工智能以及基本上对建模任何存在对手或竞争者的环境都非常重要，我们必须在这些条件下做出决策或制定策略。我们的最优策略受到我们对手策略的严重影响，无论我们是否了解它们或只是在猜测。
- en: The easiest and most well understood game theoretic setting is that of *two
    person zero sum games*, which we saw when discussing duality. Here, there are
    two competing entities, where the loss of one entity is the win of the other,
    for example, two political campaigns or two competing firms. Extending the theory
    to more complex real life situations with many competitors with varying advantages
    and disadvantages over each other, varying degrees of cooperation, along with
    many interrelated strategies, has been a challenge. There is still a gap between
    the situations that the theory can accurately portray and analyze, and real life
    situations. Progress is happening and many researchers are on this case, due to
    the incredible benefits such a complete theory would bring to the world. Imagine
    being able to view the whole network of adversaries from above, with their movements,
    connections, possible strategies and their consequences.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单和最容易理解的博弈论设置是*两人零和博弈*，我们在讨论对偶性时看到了这一点。在这里，有两个竞争实体，其中一个实体的损失是另一个实体的获胜，例如，两个政治竞选活动或两个竞争公司。将理论扩展到更复杂的现实生活情况，有许多竞争对手相互之间具有不同的优势和劣势，合作程度不同，以及许多相互关联的策略，一直是一个挑战。理论能够准确描绘和分析的情况与现实生活情况之间仍然存在差距。进展正在发生，许多研究人员正在研究这个问题，因为这样一个完整的理论将给世界带来难以置信的好处。想象一下能够从上方查看对手的整个网络，了解他们的动向、联系、可能的策略及其后果。
- en: For multiagent environments, game theory models the rational behavior or decision
    making process for each involved agent (player, firm, country, military, polictical
    campaign, etc.). In this sense game theory for multiagents is similar to decision
    theory for a single agent.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多智体环境，博弈论模型了每个涉及智体（玩家、公司、国家、军队、政治活动等）的理性行为或决策过程。在这个意义上，多智体的博弈论类似于单一智体的决策理论。
- en: 'The most important concept for non-cooperative game theory (where the agents
    make their decisions independently) is that of *Nash equilibrium*: A strategy
    outline for the game where each agent has no incentive to deviate from the outline’s
    prescribed strategy. That is, the agent will be worse off if they deviate from
    the strategy, of course, assuming everyone is acting rationally.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非合作博弈论（智体独立做出决策）最重要的概念是*Nash均衡*：游戏的策略大纲，其中每个智体没有动机偏离大纲规定的策略。也就是说，如果他们偏离策略，智体将变得更糟，当然，假设每个人都是理性行事。
- en: As we saw in the section on duality, for two person zero sum games, we can model
    them as a min max problem, and use *min max theorem*. We can also model them as
    a linear optimization problem, where one player is solving the primal problem,
    and the other one is solving the dual problem. This means that we can either set
    up the optimization problem for the first player, or for the second player. Both
    problems will end up with the same solution. Here we are given the payoff chart
    for all strageties in the game for both players, and the objective is to find
    the strategy combination that maximizes the pay (or minimize the loss) for each
    player. Intuitively, we can see why duality is built into this problem. The two
    players are pushing against each other and the optimal strategy for each player
    solves both the primal and the dual problems.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在对偶性部分看到的那样，对于两人零和博弈，我们可以将其建模为一个极小极大问题，并使用*极小极大定理*。我们也可以将其建模为一个线性优化问题，其中一个玩家解决原始问题，另一个解决对偶问题。这意味着我们可以为第一个玩家或第二个玩家设置优化问题。这两个问题最终会得到相同的解决方案。在这里，我们为两个玩家的游戏中所有策略的收益表提供了，目标是找到最大化每个玩家的收益（或最小化损失）的策略组合。直观地说，我们可以看到为什么对偶性内置在这个问题中。两个玩家互相推动，每个玩家的最佳策略解决了原始问题和对偶问题。
- en: We can also use graphs and results from graph theory to analyze two person games.
    This is similar to how we can formulate the max flow through a network as a linear
    optimization problem. Ultimately, many things in math connect neatly together,
    and one of the most satisfying feelings is when we understand these connections.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用图和图论的结果来分析两人博弈。这类似于我们如何将网络中的最大流量问题制定为线性优化问题。最终，数学中的许多事物都能很好地连接在一起，其中最令人满意的感觉之一就是当我们理解这些联系时。
- en: 'For multiagents, there are certain techniques available for decision making,
    which include: Voting procedures, auctions for allocating scarce resources, bargaining
    for reaching agreements, and contract net protocol for task sharing. In terms
    of mathematical modeling for multiagent games, we will discuss in [Chapter 13](ch13.xhtml#ch13)
    (AI and Partial Differential Equations) the *Hamilton Jacobi Bellman* partial
    differential equation. Here, to find the optimal strategy for each player, we
    have to solve a high dimensional Hamilton Jacobi Bellman type partial differential
    equation for the game’s value function. Before deep learning, these types of high
    dimensional partial differential equations have been intractable, and one had
    to make many approximations, or not consider all the participating entities. Recently
    (2018), a [deep learning technique](https://www.pnas.org/doi/10.1073/pnas.1718942115)
    has been applied to solve these high dimensional partial differential equations,
    once reformulated as a backward stochastic differential equation with terminal
    conditions (don’t worry if you do not know what this means. It is not important
    for this chapter).'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多智体，有一些可用于决策的技术，包括：投票程序、用于分配稀缺资源的拍卖、用于达成协议的讨价还价，以及用于任务共享的合同网络协议。在数学建模多智体博弈方面，我们将在[第13章](ch13.xhtml#ch13)（人工智能和偏微分方程）中讨论*哈密尔顿-雅可比-贝尔曼*偏微分方程。在这里，为了找到每个玩家的最佳策略，我们必须解决一个高维的哈密尔顿-雅可比-贝尔曼类型的偏微分方程，用于游戏的价值函数。在深度学习之前，这些类型的高维偏微分方程是难以处理的，人们不得不进行许多近似，或者不考虑所有参与实体。最近（2018年），一种[深度学习技术](https://www.pnas.org/doi/10.1073/pnas.1718942115)已被应用于解决这些高维偏微分方程，一旦重新制定为带有终端条件的反向随机微分方程（如果您不知道这意味着什么，不用担心。这对本章不重要）。
- en: We encountered another two person adversarial game theoric setting earlier in
    this book, when discussing generative adversarial networks in [Chapter 8](ch08.xhtml#ch08),
    on probabilistic generative models.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中早些时候遇到了另一个两人对抗性博弈理论设置，当时讨论生成对抗网络时，在[第8章](ch08.xhtml#ch08)中，关于概率生成模型。
- en: Queuing
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排队。
- en: 'Queues are everywhere: Computing jobs for machines, service queues at a shipyard,
    queues at the emergency room, airport check in queues, and queues at the local
    Starbucks shop. Well designed queue systems would save different facilities and
    our entire economy an invaluable amount of time, energy, and money. They will
    enhance our overall well-being.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 队列无处不在：为机器计算作业、船厂的服务队列、急诊室的队列、机场办理登机手续的队列，以及当地星巴克店的队列。设计良好的队列系统将为不同的设施和整个经济节省大量的时间、精力和金钱。它们将提高我们整体的幸福感。
- en: Mathematical modeling of queues has the objective of determining the appropriate
    level of service in order to minimize waiting times. The model might include a
    priority discipline, which means that there are priority groups and the order
    in which the members get serviced depends on their priority groups. It might also
    include different type of services that happen sequentially or in parallel, or
    some in sequence and others in parallel (for example, in a ship maintainance facility).
    Some models include multiple service facilities, a queuing network.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 队列的数学建模的目标是确定适当的服务水平，以最小化等待时间。该模型可能包括优先级规则，这意味着有优先级组，成员接受服务的顺序取决于其优先级组。它可能还包括按顺序或并行发生的不同类型的服务，或者一些按顺序进行，另一些并行进行（例如，在船舶维护设施中）。一些模型包括多个服务设施，一个排队网络。
- en: 'There are thousands of papers on queuing theory. It is important to recognize
    the basic ingredients of a queueing mathematical model:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 关于排队理论有成千上万篇论文。重要的是要认识到排队数学模型的基本要素：
- en: The members of the queue (customers, ships, jobs, patients) arrive at certain
    interarrival times. If the arrival process is random, then the math model must
    decide on a probability distribution that this interarrival time adheres to, either
    from the data, or from mathematical distributions know to model such times. Some
    models assume constant arrival times. Others assume the exponential distribution
    (a Markovian process) as it facilitates the mathematical analysis and mimics the
    real life process better. Others assume the *Erlang* distribution which allows
    different exponential distributions for different time intervals. Others assume
    even more general distributions. The more general the distribution, the less easy
    the mathematical analysis. Numerical simulations are our best friend forever.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列的成员（顾客、船只、工作、患者）以一定的到达时间到达。如果到达过程是随机的，那么数学模型必须决定这种到达时间遵循的概率分布，要么来自数据，要么来自已知用于建模此类时间的数学分布。一些模型假设到达时间恒定。其他模型假设指数分布（马尔可夫过程），因为它便于数学分析并更好地模拟实际过程。其他模型假设*Erlang*分布，允许不同时间间隔的不同指数分布。其他模型假设更一般的分布。分布越一般，数学分析就越困难。数值模拟是我们永远的好朋友。
- en: 'The number of servers (parallel and sequential) available: An integer.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的服务器数量（并行和顺序）：一个整数。
- en: The service times also follow a certain probability distribution that we must
    decide on. Common distributions are similar to those used for interarrival times.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务时间也遵循某种概率分布，我们必须决定。常见的分布类似于用于到达时间的分布。
- en: 'In addition, the mathematical model must also keep track of the following:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，数学模型还必须跟踪以下内容：
- en: The initial number of members in the full queueing system (those waiting and
    those being currently serviced).
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整排队系统中初始成员的数量（等待和当前正在接受服务的成员）。
- en: The probability of having *n* members in the full queueing system at a given
    later time.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在给定的后续时间点，完整排队系统中有*n*个成员的概率。
- en: 'Finally, the model wants to compute the *steady state of the queuing system*:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该模型希望计算排队系统的*稳态*。
- en: The probability of having *n* members in the full queuing system.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在完整排队系统中有*n*个成员的概率。
- en: The expected number of new members arriving per unit time.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每单位时间到达的新成员的预期数量。
- en: The expected number of members completing their service per unit time.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每单位时间完成服务的成员的预期数量。
- en: The expected waiting time for each member in the system.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统中每个成员的预期等待时间。
- en: Members enter the queue at a certain mean rate, wait to get serviced, get serviced
    at a certain mean rate, then leave the facility. The mathematical model must quantify
    these and balance them.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 成员以一定的平均速率进入队列，等待接受服务，以一定的平均速率接受服务，然后离开设施。数学模型必须量化这些并平衡它们。
- en: Inventory
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库存
- en: With the current shortages in the supply chain, the symptoms are empty shelves
    at the grocery stores, shortages of car repair parts, new cars, materials for
    home renovation, and many others, there is obviously a gap between supply and
    demand. The times between replenishing the supplies at stores have increased in
    a way that is causing backlogs, low productivity, and an overall slowed economy.
    Mathematical models for inventory management quantify the supply (stochastically
    or deterministically), the demand, and devise an optimal inventory policy for
    timing replenishing and deciding on the quantity required at each replenish. Ideally,
    the model must have access to an information processing system that gathers data
    on current inventory levels and signals when and by how much to replenish them.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 随着供应链中目前的短缺，超市货架上空空如也，汽车维修零件短缺，新车、家庭装修材料等物资短缺，显然供需之间存在差距。商店补充货物之间的时间间隔增加，导致积压、低生产率和整体经济放缓。库存管理的数学模型量化了供应（随机或确定性）、需求，并制定了一个最佳的库存策略，用于确定何时补充和决定每次补充所需的数量。理想情况下，该模型必须能够访问一个信息处理系统，收集有关当前库存水平的数据，并在何时以及以多少数量补充它们时发出信号。
- en: Machine Learning For Operations Research
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运营研究的机器学习
- en: For starters, what is extremely exciting nowadays in operations research, as
    opposed to ten years ago, is the ability to solve massive operations research
    problems, sometimes involving tens of millions of constraints and decision variables.
    We have to thank the computational power explosion and the contuining improvement
    of computer implementations of operations research algorithms for this.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，与十年前相比，当今运营研究中非常令人兴奋的是，能够解决庞大的运营研究问题，有时涉及数千万个约束和决策变量。我们要感谢计算能力的爆炸和运营研究算法的计算机实现的持续改进。
- en: Moreover, machine learning can help predict the values of many parameters that
    enter into operations research models using volumes of available data. If these
    parameters were hard to measure, modelers had to either remove them from the model
    or make assumptions about their values. This doesn’t have to be the case anymore
    because of more accurate machine learning models that are able to take thousands
    of variables into account.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，机器学习可以帮助预测进入运筹学模型的许多参数的值，利用大量可用数据。如果这些参数难以测量，建模者必须将它们从模型中移除或对其值进行假设。由于更准确的机器学习模型能够考虑成千上万的变量，这种情况不再存在。
- en: Finally, machine learning can help speed up searching through combinatorially
    large search spaces by *learning* which parts of the space to focus on or which
    subproblems to prioritize. This is exactly what the article [*Learning to Delegate
    for Large-scale Vehicle Routing (2021)*](https://arxiv.org/abs/2107.04139) does,
    speeding up vehicle routing 10 to 100 more times than the state of the art available
    routing algorithms.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，机器学习可以通过*学习*哪些空间部分值得关注或哪些子问题应优先考虑，加快在组合性大的搜索空间中搜索的速度。这正是文章《学习委派大规模车辆路径规划（2021）》所做的，比现有的路径规划算法提高了10到100倍的车辆路径规划速度。
- en: 'Similar research at the intersection of machine learning and operations research
    is booming with great progress and scalable solutions. The following list of abstracts
    from the conference [Operations Research Meets Machine Learning](https://www.euro-online.org/websites/or-in-practice/wp-content/uploads/sites/8/2019/04/OR_meets_ML_abstract_booklet_final.pdf)
    offers a great variety of relevant projects, such as real time data sysnthesis
    and treatment from sensors in waste bins (tracking the volume) for more efficient
    waste collection operation (since this relies on real time data the team relies
    on dynamic routing. Another great example is a bike sharing system, where the
    objective is to predict the number of bikes needed at each location and allocating
    teams to distribute the required number of bikes efficiently. Here is the abstract:
    *Operators in a bike sharing system control room are constantly re-allocating
    bikes where they are most likely to be needed, this requires an insight on the
    optimum number of bikes needed in each station, and the most efficient way to
    distribute teams to move the bikes around. Forecasting engines and Decision Optimization
    is used to calculate the optimal number of bikes for each station at any given
    time, and plan efficient routes to help the redistribution of bikes accordingly.
    A solution delivered by DecisionBrain and IBM for the bike sharing system in London
    is the first application of its kind that uses both optimization and machine learning
    to solve cycle hire inventory, distribution and maintenance problems, and could
    easily be re-deployed for other cycle sharing systems around the world.* In fact
    [DecisionBrain](https://decisionbrain.com)’s projects are worth browsing and thinking
    through.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习和运筹学交叉领域的类似研究正在取得巨大进展和可扩展解决方案。来自会议《运筹学遇见机器学习》的摘要列表提供了许多相关项目，例如实时数据综合和处理，从废物箱传感器中获取数据（跟踪容量）以实现更高效的废物收集操作（由于这依赖于实时数据，团队依赖于动态路由）。另一个很好的例子是自行车共享系统，其目标是预测每个位置所需的自行车数量，并分配团队以有效地分配所需数量的自行车。以下是摘要：*自行车共享系统控制室的运营商不断重新分配自行车到最有可能需要的地方，这需要对每个站点所需自行车数量的最佳洞察，并计划有效的路线以帮助相应地重新分配自行车。预测引擎和决策优化被用来计算每个站点在任何给定时间所需的最佳自行车数量，并计划有效的路线以帮助相应地重新分配自行车。DecisionBrain和IBM为伦敦的自行车共享系统提供的解决方案是第一个利用优化和机器学习来解决自行车租赁库存、分配和维护问题的应用，可以轻松地重新部署到世界各地的其他自行车共享系统中。*实际上，DecisionBrain的项目值得浏览和深思。
- en: 'Currently, my team and I are working on a problem with the Department of Public
    Transporation in my city. This is a perfect setting where machine learning meets
    operations research: Using historical ridership data, in particular daily boardings
    and alightings at each bus stop in the city, along with population density, demographics,
    vulerability, and city zoning data, car ownership, university enrollment and parking
    data, we use neural networks to predict supply and demand patterns at each stop,
    then we use this data and optimal network design from operations research to re-design
    the bus routes so that the bus stops, in particular those in the most socially
    vulnerable areas in the city, are adequately and efficiently serviced.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我的团队和我正在解决我所在城市公共交通部门的一个问题。这是一个完美的场景，机器学习与运筹学相遇：利用历史乘客数据，特别是城市每个公交车站的日常上下车人数，以及人口密度、人口统计数据、脆弱性、城市分区数据、汽车拥有量、大学入学率和停车数据，我们使用神经网络来预测每个站点的供需模式，然后我们利用这些数据和运筹学中的最佳网络设计来重新设计公交路线，以便公交车站，特别是城市中最社会脆弱地区的车站，得到充分和高效的服务。
- en: Hamilton–Jacobi–Bellman Equation
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈密尔顿-雅各比-贝尔曼方程
- en: The fields of operations research, game theory, and partial differential equations
    intersect through dynamic programming and the *Hamilton Jacobi Bellman* partial
    differential equation. It is Richard Bellman (mathematician, 1920-1984) who first
    coined the term *curse of dimensionality*, in the context of dynamic programming.
    Now the curse of dimensionality has rendered real life applications of this very
    useful equation limited and unable to incorporate all the players of a game (or
    competing markers, countries, militaries), and solve for their optimal strategies,
    or the thousands of variables that can be involved in operations research problems
    such as for optimal resource allocation problems. The tides have turned with deep
    learning. The paper [*Solving high-dimensional partial differential equations
    using deep learning (2018)*](https://www.pnas.org/doi/10.1073/pnas.1718942115)
    presents a method to solve this equation and others for very high dimensions.
    We will discuss the idea of how the authors do it in [Chapter 13](ch13.xhtml#ch13)
    on AI and partial differential equations.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 运筹学、博弈论和偏微分方程领域通过动态规划和*哈密尔顿-雅可比-贝尔曼*偏微分方程相交。首次在动态规划的背景下提出*维度诅咒*这个术语的是理查德·贝尔曼（数学家，1920-1984年）。现在，维度诅咒使得这个非常有用的方程在现实生活中的应用受到限制，无法涵盖游戏中的所有参与者（或竞争对手、国家、军队），并解决他们的最佳策略，或者在运筹学问题中涉及的数千个变量，比如最佳资源分配问题。随着深度学习的发展，情况已经发生了变化。论文[*使用深度学习解决高维偏微分方程（2018）*](https://www.pnas.org/doi/10.1073/pnas.1718942115)提出了一种解决这个方程和其他高维问题的方法。我们将在[第13章](ch13.xhtml#ch13)中讨论作者是如何做到的，关于人工智能和偏微分方程。
- en: Operations Research For AI
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能的运筹学
- en: Operations research is the science of decision making based on optimal solutions.
    Humans are always trying to make decisions based on the available circumstances.
    Artificial intelligence aims to replicate all aspects of human intelligence, including
    decision making. In this sense, the decision making methods that operations research
    employs automatically fit into AI. The ideas in dynamic programming, Markov chains,
    optimal control and Hamilton Jacobi Bellman equation, advances in game theory
    and multiagent games, network optimization, and others, have evolved along with
    AI throughout the decades. In fact, many startups market themselves as AI companies
    while in reality they are doing good old (and awesome) operations research.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 运筹学是基于最优解的决策科学。人类总是试图根据可用情况做出决策。人工智能旨在复制人类智能的所有方面，包括决策制定。在这个意义上，运筹学采用的决策制定方法自然地适用于人工智能。动态规划、马尔可夫链、最优控制和哈密尔顿-雅可比-贝尔曼方程、博弈论和多智能体游戏、网络优化等思想，随着几十年来人工智能的发展而不断进步。事实上，许多初创公司将自己打造成人工智能公司，而实际上他们在做的是古老的（而且很棒的）运筹学。
- en: Summary And Looking Ahead
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结和展望
- en: Operations research is the field of making the best decisions given the current
    knowledge and circumstances. It always comes down to finding clever ways to search
    for optimizers in very high dimensional spaces.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 运筹学是在当前知识和情况下做出最佳决策的领域。它总是要找到在非常高维空间中搜索优化器的巧妙方法。
- en: 'One theme throughout this book is the curse of dimensionality, and all the
    effort researchers do to find ways around it. In no field this curse shows up
    as broadly as operations research. Here, the search spaces grow combinatorially
    with the number of players in a particular problem: Number of cities on a route,
    number of competing entities, number of people, number of commodities, *etc.*
    There are very powerful exact methods and heuristic methods, but there is much
    room for improvement in terms of speed and scale.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 本书贯穿始终的一个主题是维度诅咒，以及研究人员为找到绕过它的方法所做的所有努力。在没有哪个领域像运筹学那样广泛地出现这种诅咒。在这里，随着特定问题中参与者数量的增加，搜索空间与组合增长：路线上的城市数量、竞争实体数量、人数、商品数量等。有非常强大的精确方法和启发式方法，但在速度和规模方面还有很大的改进空间。
- en: 'Machine learning, in particular deep learning, provides a way to learn from
    previously solved problems, from labeled data, or from simulated data. This speeds
    up optimization searches if we identify the bottlenecks and are able to articulate
    the source of the bottle neck as a machine learning problem. For example, a bottle
    neck can be: *We have too many subproblems to solve but we do not know which ones
    to prioritize in order to quickly get us closer to the optimum*. To use machine
    learning to address this, we need a data set of already solved problems and subproblems
    and have a machine learning model learn which subproblems should be prioritized.
    Once the models learns this we can use it to speed up new problems.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习，特别是深度学习，提供了一种从先前解决的问题、标记数据或模拟数据中学习的方法。如果我们能够确定瓶颈并能够将瓶颈的来源表述为一个机器学习问题，那么这将加快优化搜索的速度。例如，一个瓶颈可能是：*我们有太多子问题需要解决，但我们不知道应该优先解决哪些问题以便快速接近最优解*。为了使用机器学习来解决这个问题，我们需要一个已解决问题和子问题的数据集，并让机器学习模型学习哪些子问题应该优先解决。一旦模型学会了这一点，我们就可以用它来加速解决新问题。
- en: 'Other uses of machine learning in operations research include *business as
    usual* type of machine learning: Predict demand from available data, either real
    time or historical data, then use operations research to optimize resource allocation.
    Here machine learning helps make better predictions for demand and hence increases
    efficiency and reduces waste.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 运筹学中机器学习的其他用途包括*业务常规*类型的机器学习：从可用数据（实时或历史数据）中预测需求，然后使用运筹学来优化资源分配。在这里，机器学习有助于更好地预测需求，从而提高效率并减少浪费。
- en: In this chapter, we gave a broad overview of the field of operations research
    and its most important types of problems. We especially emphasized linear optimization,
    networks, and duality. Powerful software packages are available for many useful
    problems. We hope that these packages keep integrating the latest progeresses
    in the field.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们对运筹学领域及其最重要的问题类型进行了广泛概述。我们特别强调了线性优化、网络和对偶性。针对许多有用问题都有强大的软件包可用。我们希望这些软件包能不断整合该领域的最新进展。
- en: Two topics are that usually not taught in an introductory operations research
    class are the Hamilton Jacobi Bellman partial differential equation for optimal
    control and strategies of multiplayer games, and optimizing *functionals* using
    calculus of variations. These are usually considered advanced topics in partial
    differential equations. We discussed them here because they both tie naturally
    into optimization and operations research. Moreover, viewing them in this context
    demystifies their corresponding fields.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在初级运筹学课程中通常不教授的两个主题是用于最优控制的Hamilton Jacobi Bellman偏微分方程和多人游戏的策略，以及使用变分法来优化*泛函*。这些通常被认为是偏微分方程中的高级主题。我们在这里讨论它们是因为它们都自然地与优化和运筹学联系在一起。此外，在这种背景下观察它们可以揭开它们对应领域的神秘面纱。
- en: When doing operations research and optimizing for cost reduction, revenue increase,
    time efficiency, *etc.*, it is important that our optimization models do not ignore
    the human factor. If the output of a scheduling model messes up low wage workers’
    lives through erratic schedules to keep a certain *on time* company performance,
    then that is not a good model and the quality of lives and livelihoods of the
    workers that a company relies on need to be quantified then factored into the
    model. Yes, *the quality of life* needs to be quantified, since everything else
    is being factored in, and we cannot leave this out. Companies with hundreds of
    thousands of low wage workers like Amazon, Starbucks, McDonalds, and other have
    a responsibility that their operations research algorithms do not end up trapping
    their workers into poverty.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行运筹学和优化以降低成本、增加收入、提高时间效率等方面时，重要的是我们的优化模型不要忽视人为因素。如果一个调度模型的输出通过不稳定的时间表来保持某个公司的准时表现而扰乱低工资工人的生活，那么这就不是一个好模型，公司依赖的工人的生活质量和生计需要被量化然后纳入模型中。是的，*生活质量*需要被量化，因为其他一切都被纳入考虑，我们不能忽略这一点。像亚马逊、星巴克、麦当劳等拥有数十万低工资工人的公司有责任确保他们的运筹学算法不会让他们的工人陷入贫困。
- en: 'We leave this chapter with this excerpt from a paper authored by [Charled Hitch](https://www.informs.org/Explore/History-of-O.R.-Excellence/Biographical-Profiles/Hitch-Charles-J)
    on [Uncertainties In Operations Research](https://www.rand.org/pubs/papers/P1959.xhtml)
    from 1960\. Reading this (the brackets are my edits), one cannot help but ponder
    on how far the operations research field has come since 1960:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以这段摘自1960年[查尔斯·希奇](https://www.informs.org/Explore/History-of-O.R.-Excellence/Biographical-Profiles/Hitch-Charles-J)撰写的关于[运筹学中的不确定性](https://www.rand.org/pubs/papers/P1959.xhtml)的论文结束这一章。阅读这篇论文（括号内为我的编辑），人们不禁会思考自1960年以来运筹学领域取得了多大进步：
- en: '*No other characteristic of decision making is as pervasive as uncertainty.
    When, as operationis researchers, to si.mplify a first cut at an analysis, we
    assume that the situation can be described by certainty equivalents, we may be
    doing violence to the facts and indeed the violence may be so grievous as to falsify
    the problem and give us a nonsense solution. How, for example, can we help the
    military make development decisions—decisions about which aircraft or missiles
    to develop when the essence of the problem is that no one can predict with accuracy
    how long it will take to develop any of the competing equipments, or to get them
    operational, how much they will cost, what their performance will be, or what
    the world will be like at whatever uncertain future date turns out to be relevant
    (if indeed, the world still exists then)? When I say “cannot predict with accuracy”
    I am not exaggerating. We find that typically, for example, the production costs
    of new equipment are underestimated in the early stages of development by factors
    of two to twenty (not 2 to 20 per cent, but factors of two to twenty). Why they
    are always underestimated, never overestimated, I leave to your fertile imaginations.
    […] Another thing that [an operations researcher] can frequently do, especially
    in problems involving research and developmnent, is to ascertain the critical
    uncertainties and recommend strategies to reduce them—to buy information. If you
    do not know which of two dissimilar techniques for missile guidance will turn
    out to be better, your best recommendation is very likely to be: keep them both
    in development a while longer and choose between them when more and better information
    is available. Never mind the people who call you indecisive. You can prove that
    this kind of indecisiveness can save both money and time. Of course you can ‘t
    afford to try everything. There isn’t enough budget. There aren’t enough resources.
    You remember when we used to say “If you gave the military services everything
    they asked for they’d try to fortify the moon!” (We’ll have to change that figure
    of speech.) Actually, it is because of limitations on resources that operations
    research. and operations researchers are important. There’d be no problems for
    us if there were no constraints on resources. It is our job and opportunity to
    find, or invent, within the constraints, some better pattern of adjusting to an
    uncertain world than our betters would find if we weren’t here; or some better
    way, taking costs and pay-offs into account, to buy information to reduce the
    uncertainty.*'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 决策过程中没有比不确定性更普遍的特征了。作为运营研究者，当我们试图简化分析时，假设情况可以用确定性等价物来描述，我们可能会歪曲事实，甚至可能造成如此严重的错误，以至于使问题虚假，并给出一个荒谬的解决方案。例如，我们如何帮助军方做出发展决策——比如决定开发哪种飞机或导弹，当问题的本质是没有人能准确预测开发任何竞争装备需要多长时间，或者使其投入运营，它们将花费多少，性能如何，或者在未来的某个不确定日期，世界会是什么样子（如果世界确实还存在的话）？当我说“无法准确预测”时，我并没有夸大。我们通常发现，例如，新设备的生产成本在开发的早期阶段被低估了两到二十倍（不是2到20％，而是两到二十倍）。为什么它们总是被低估，而不是高估，我留给你们丰富的想象力。[...]
    另一件[运营研究者]经常可以做的事情，特别是涉及研究和开发的问题，是确定关键的不确定性并推荐减少它们的策略——购买信息。如果你不知道两种不同的导弹制导技术中哪一种会更好，你最好的建议很可能是：让它们都继续开发一段时间，当有更多更好的信息可用时再在它们之间做出选择。不要在意那些称你优柔寡断的人。你可以证明这种优柔寡断可以节省金钱和时间。当然，你不能尝试所有的事情。没有足够的预算。没有足够的资源。你还记得我们曾经说过“如果你给军事部门他们要求的一切，他们会试图加固月球！”（我们将不得不改变这种比喻。）实际上，正是由于资源的限制，运营研究和运营研究者才显得重要。如果没有资源的限制，我们就没有问题。我们的工作和机会是在限制条件下找到或发明一种更好的适应不确定世界的模式，比我们的上级在没有我们的情况下会找到的更好的方式；或者考虑成本和回报，购买信息以减少不确定性。
