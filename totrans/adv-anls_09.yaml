- en: Chapter 7\. Data Structures in R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Toward the end of [Chapter 6](ch06.html#first-steps-r) you learned how to work
    with packages in R. It’s common to load any necessary packages at the beginning
    of a script so that there are no surprises about required downloads later on.
    In that spirit, we’ll call in any packages needed for this chapter now. You may
    need to install some of these; if you need a refresher on doing that, look back
    to [Chapter 6](ch06.html#first-steps-r). I’ll further explain these packages as
    we get to them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 6](ch06.html#first-steps-r) you also learned about calling functions
    on data of different modes, and assigning data to objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Chances are, you generally work with more than one piece of data at a time,
    so assigning each to its own object probably doesn’t sound too useful. In Excel,
    you can place data into contiguous cells, called a *range*, and easily operate
    on that data. [Figure 7-1](#excel-ranges) depicts some simple examples of operating
    on ranges of both numbers and text in Excel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Typical ranges in Excel](assets/aina_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. Operating on ranges in Excel
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Earlier I likened the *mode* of an object to a particular type of shoe in a
    shoebox. The *structure* of an object is the shape, size, and architecture of
    the shoebox itself. In fact, you’ve already been finding the structure of an R
    object with the `str()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'R contains several object structures: we can store and operate on a bit of
    data by placing it in a particular structure called a *vector*. Vectors are collections
    of one or more elements of data of the same type. Turns out we’ve already been
    using vectors, which we can confirm with the `is.vector()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Though `my_number` is a vector, it only contains one element—sort of like a
    single cell in Excel. In R, we would say this vector has a length of 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make a vector out of multiple elements, akin to an Excel range, with
    the `c()` function. This function is so called because it serves to *combine*
    multiple elements into a single vector. Let’s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This object is indeed a vector, its data is numeric, and it has a length of
    4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see what happens when we call a function on `my_numbers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Now* we’re getting somewhere. We could similarly operate on a character vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'By combining elements of data into vectors with the `c()` function, we were
    able to easily reproduce in R what was shown in Excel in [Figure 7-1](#excel-ranges).
    What happens if elements of different types are assigned to the same vector? Let’s
    give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: R will *coerce* all elements to be of the same type so that they can be combined
    into a vector; for example, the numeric element `2` in the previous example was
    coerced into a character.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing and Subsetting Vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Excel, the `INDEX()` function serves to find the position of an element
    in a range. For example, I will use `INDEX()` in [Figure 7-2](#vector-index-excel)
    to extract the element in the third position of the named range `roster_names`
    (cells `A1:A5`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Indexing in Excel](assets/aina_0702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. The `INDEX()` function on an Excel range
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can similarly index a vector in R by affixing the desired index position
    inside brackets to the object name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this same notation, it’s possible to select multiple elements by their
    index number, which we’ll call *subsetting*. Let’s again use the `:` operator
    to pull all elements between position 1 and 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s possible to use functions here, too. Remember `length()`? We can use it
    to get everything through the last element in a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We could even use the `c()` function to index by a vector of nonconsecutive
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: From Excel Tables to R Data Frames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: “This is all well and good,” you may be thinking, “but I don’t just work with
    small ranges like these. What about whole data *tables*?” After all, in [Chapter 1](ch01.html#foundations-of-eda)
    you learned all about the importance of arranging data into variables and observations,
    such as the *star* data shown in [Figure 7-3](#two-dimensional-data-structure-excel).
    This is an example of a *two-dimensional* data structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![A two-dimensional data structure in Excel](assets/aina_0703.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-3\. A two-dimensional data structure in Excel
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Whereas R’s vector is one-dimensional, the *data frame* allows for storing data
    in both rows *and* columns. This makes the data frame the R equivalent of an Excel
    table. Put formally, a data frame is a two-dimensional data structure where records
    in each column are of the same mode and all columns are of the same length. In
    R, like Excel, it’s typical to assign each column a label or name.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make a data frame from scratch with the `data.frame()` function. Let’s
    build and then print a data frame called `roster`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve used the `c()` function before to combine elements into a vector. And
    indeed, a data frame can be thought of as a *collection of vectors* of equal length.
    At three variables and five observations, `roster` is a pretty miniscule data
    frame. Fortunately, a data frame doesn’t always have to be built from scratch
    like this. For instance, R comes installed with many datasets. You can view a
    listing of them with this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A menu labeled “R data sets” will appear as a new window in your scripts pane.
    Many, but not all, of these datasets are structured as data frames. For example,
    you may have encountered the famous *iris* dataset before; this is available out
    of the box in R.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like with any object, it’s possible to print *iris*; however, this will
    quickly overwhelm your console with 150 rows of data. (Imagine the problem compounded
    to thousands or millions of rows.) It’s more common instead to print just the
    first few rows with the `head()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can confirm that `iris` is indeed a data frame with `is.data.frame()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to get to know our new dataset besides printing it is with the
    `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output returns the size of the data frame and some information about its
    columns. You’ll see that four of them are numeric. The last, *Species*, is a *factor*.
    Factors are a special way to store variables that take on a limited number of
    values. They are especially helpful for storing *categorical* variables: in fact,
    you’ll see that *Species* is described as having three *levels*, which is a term
    we’ve used statistically in describing categorical variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Though outside the scope of this book, factors carry many benefits for working
    with categorical variables, such as offering more memory-efficient storage. To
    learn more about factors, check out R’s help documentation for the `factor()`
    function. (This can be done with the `?` operator.) The `tidyverse` also includes
    `forcats` as a core package to assist in working with factors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the datasets that are preloaded with R, many packages include
    their own data. You can also find out about them with the `data()` function. Let’s
    see if the `psych` package includes any datasets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The “R data sets” menu will again launch in a new window; this time, an additional
    section called “Data sets in package `psych`" will appear. One of these datasets
    is called `sat.act`. To make this dataset available to our R session, we can again
    use the `data()` function. It’s now an assigned R object that you can find in
    your Environment menu and use like any other object; let’s confirm it’s a data
    frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Importing Data in R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working in Excel, it’s common to store, analyze, and present data all within
    the same workbook. By contrast, it’s uncommon to store data from inside an R script.
    Generally, data will be imported from external sources, ranging from text files
    and databases to web pages and application programming interfaces (APIs) to images
    and audio, and only then analyzed in R. Results of the analysis are then frequently
    exported to still different sources. Let’s start this process by reading data
    from, not surprisingly, Excel workbooks (file extension *.xlsx*), and comma-separated
    value files (file extension *.csv*).
  prefs: []
  type: TYPE_NORMAL
- en: 'To import data in R, it’s important to understand how file paths and directories
    work. Each time you use the program, you’re working from a “home base” on your
    computer, or a *working directory*. Any files you refer to from R, such as when
    you import a dataset, are assumed to be located relative to that working directory.
    The `getwd()` function prints the working directory’s file path. If you are on
    Windows, you will see a result similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For Mac, it will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: R has a global default working directory, which is the same at each session
    startup. I’m assuming that you are running files from a downloaded or cloned copy
    of the book’s companion repository, and that you are also working from an R script
    in that same folder. In that case, you’re best off setting the working directory
    to this folder, which can be done with the `setwd()` function. If you’re not used
    to working with file paths, it can be tricky to fill this out correctly; fortunately,
    RStudio includes a menu-driven approach for doing it.
  prefs: []
  type: TYPE_NORMAL
- en: To change your working directory to the same folder as your current R script,
    go to Session → Set Working Directory → To Source File Location. You should see
    the results of the `setwd()` function appear in the console. Try running `getwd()`
    again; you’ll see that you are now in a different working directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve established the working directory, let’s practice interacting
    with files relative to that directory. I have placed a *test-file.csv* file in
    the main folder of the book repository. We can use the `file.exists()` function
    to check whether we can successfully locate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'I have also placed a copy of this file in the *test-folder* subfolder of the
    repository. This time, we’ll need to specify which subfolder to look in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens if we need to go *up* a folder? Try placing a copy of *test-file*
    in whatever folder is one above your current directory. We can use `..` to tell
    R to look one folder up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have the hang of locating files in R, let’s actually read some
    in. The book repository contains a [*datasets* folder](https://oreil.ly/wtneb),
    under which is a *star* subfolder. This contains, among other things, two files:
    *districts.csv* and *star.xlsx*.'
  prefs: []
  type: TYPE_NORMAL
- en: To read in *.csv* files, we can use the `read_csv()` function from `readr`.
    This package is part of the `tidyverse` collection, so we don’t need to install
    or load anything new. We will pass the location of the file into the function.
    (Do you see now why understanding working directories and file paths was helpful?)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This results in a fair amount of output. First, our columns are specified, and
    we’re told which functions were used to parse the data into R. Next, the first
    few rows of the data are listed, as a *tibble*. This is a modernized take on the
    data frame. It’s still a data frame, and behaves mostly like a data frame, with
    some modifications to make it easier to work with, especially within the `tidyverse`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we were able to read our data into R, we won’t be able to do much
    with it unless we assign it to an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Among its many benefits, one nice thing about the tibble is we can print it
    without having to worry about overwhelming the console output; the first 10 rows
    only are printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`readr` does not include a way to import Excel workbooks; we will instead use
    the `readxl` package. While it is part of the `tidyverse`, this package does not
    load with the core suite of packages like `readr` does, which is why we imported
    it separately at the beginning of the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use the `read_xlsx()` function to similarly import *star.xlsx* as a tibble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There’s more you can do with `readxl`, such as reading in *.xls* or *.xlsm*
    files and reading in specific worksheets or ranges of a workbook. To learn more,
    check out the package’s [documentation](https://oreil.ly/kuZPE).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a Data Frame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier you learned about `head()` and `str()` to size up a data frame. Here
    are a few more helpful functions. First, `View()` is a function from RStudio whose
    output will be very welcome to you as an Excel user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: After calling this function, a spreadsheet-like viewer will appear in a new
    window in your Scripts pane. You can sort, filter, and explore your dataset much
    like you would in Excel. However, as the function implies, it’s for viewing *only*.
    You cannot make changes to the data frame from this window.
  prefs: []
  type: TYPE_NORMAL
- en: The `glimpse()` function is another way to print several records of the data
    frame, along with its column names and types. This function comes from `dplyr`,
    which is part of the `tidyverse`. We will lean heavily on `dplyr` in later chapters
    to manipulate data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s also the `summary()` function from base R, which produces summaries
    of various R objects. When a data frame is passed into `summary()`, some basic
    descriptive statistics are provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Many other packages include their own version of descriptive statistics; one
    of my favorite is the `describe()` function from `psych`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re not familiar with all of these descriptive statistics, you know what
    to do: *check the function’s documentation*.'
  prefs: []
  type: TYPE_NORMAL
- en: Indexing and Subsetting Data Frames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this section we created a small data frame `roster` containing the
    names and heights of four individuals. Let’s demonstrate some basic data frame
    manipulation techniques with this object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Excel, you can use the `INDEX()` function to refer to both the row and column
    positions of a table, as shown in [Figure 7-4](#data-frame-index-excel):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Indexing in Excel](assets/aina_0704.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-4\. The `INDEX()` function on an Excel table
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This will work similarly in R. We’ll use the same bracket notation as we to
    with index vectors, but this time we’ll refer to both the row and column position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we can use the `:` operator to retrieve all elements within a given
    range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s also possible to select an entire row or column by leaving its index blank,
    or to use the `c()` function to subset nonconsecutive elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If we just want to access one column of the data frame, we can use the `$`
    operator. Interestingly, this results in a *vector*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This confirms that a data frame is indeed a list of vectors of equal length.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Data Frames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, it’s typical to read data into R, operate on it, and
    then export the results elsewhere. To write a data frame to a *.csv* file, you
    can use the `write_csv()` function from `readr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If you have the working directory set to the book’s companion repository, you
    should find this file waiting for you in the *output* folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the `readxl` package does not include a function to write data
    to an Excel workbook. We can, however, use `writexl` and its `write_xlsx()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you progressed from single-element objects, to larger vectors,
    and finally to data frames. While we’ll be working with data frames for the remainder
    of the book, it’s helpful to keep in mind that they are collections of vectors
    and behave largely in the same way. Coming up, you will learn how to analyze,
    visualize, and ultimately test relationships in R data frames.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do the following exercises to test your knowledge of data structures in R:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a character vector of five elements, and then access the first and fourth
    elements of this vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two vectors `x` and `y` of length 4, one containing numeric and the other
    logical values. Multiply them and pass the result to `z`. What is the result?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the `nycflights13` package from CRAN. How many datasets are included
    with this package?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One of these datasets is called `airports`. Print the first few rows of this
    data frame as well as the descriptive statistics.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Another is called `weather`. Find the 10th through 12th rows and the 4th through
    7th columns of this data frame. Write the results to a *.csv* file and an Excel
    workbook.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
