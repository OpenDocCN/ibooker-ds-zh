<html><head></head><body>
<div id="sbo-rt-content"><div class="readable-text" id="p1">
<h1 class="readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">3</span></span> <span class="chapter-title-text">Data modeling</span></h1>
</div>
<div class="introduction-summary">
<h3 class="introduction-header sigil_not_in_toc">This chapter covers</h3>
<ul>
<li class="readable-text" id="p2">Modeling data as a fundamental analytical activity</li>
<li class="readable-text" id="p3">How to define business entities from raw data</li>
<li class="readable-text" id="p4">How to structure a data model to best suit the analytical question </li>
</ul>
</div>
<div class="readable-text" id="p5">
<p>As an analyst, you will find yourself applying the same logic to raw data over and over again. For example, every time you calculate revenue, you might need to remember to remove internal money transfers between departments. Or when you look at customer spending, you might need to exclude a certain customer because they operate differently. Whenever these business rules need to be applied constantly to ensure data is accurate, it is a good opportunity to build a <em>data model</em>.</p>
</div>
<div class="readable-text intended-text" id="p6">
<p>A data model is a dataset created from raw data that has been cleaned, with specific business rules built into it. Creating reusable data models will save you time and maintenance headaches in the future. Data modeling also forces you to think deeply about your or your stakeholder’s question, which leads to a more valuable answer.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p7">
<h5 class="callout-container-h5 readable-text-h5 sigil_not_in_toc">Real business case: Customer deduplication</h5>
</div>
<div class="readable-text" id="p8">
<p>Once, when working in industry, I spent months on a customer deduplication project. We wanted to track the number of customers over time, but our customers were spread across multiple databases. Deduplicating them was not a trivial task, especially because, in some databases, customers appeared as company names, such as “South West Motors,” and in others, they were recorded as individuals, such as “John Smith,” with no information about the company they worked for.</p>
</div>
<div class="readable-text" id="p9">
<p>In the end, our solution involved text similarity algorithms to find instances where “South West Motors” from one database existed as “South West Motors Limited” in another. We also used graph theory to link customers together across our company network. These are advanced algorithms for the seemingly simple task of counting customers. Entity resolution problems are everywhere, which is why this chapter explores the topic and lets you practice on a real problem.</p>
</div>
</div>
<div class="readable-text" id="p10">
<p>In this chapter, we will review the fundamentals and importance of data modeling and practice converting raw data into a reusable data model using a real-world project.</p>
</div>
<div class="readable-text" id="p11">
<h2 class="readable-text-h2" id="sigil_toc_id_24"><span class="num-string">3.1</span> The importance of data modeling</h2>
</div>
<div class="readable-text" id="p12">
<p>Data modeling is a foundational step in the analytical workflow. It is the process of taking raw data, mapping it to business-specific entities, and creating new data models. We can think of it as converting data in its raw state to a more useful form, which we can call information. Data analysis is then the process of converting this information into insight. The intermediate step is required because, in its raw form, data is often not ready for analysis. Figure 3.1 shows where data modeling fits into both the abstract and concrete versions of a data science workflow.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p13">
<img alt="figure" height="304" src="../Images/3-1.png" width="902"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.1</span> Data modeling and analysis as mapped to the data science process</h5>
</div>
<div class="readable-text" id="p14">
<p>Your data models should encode any business logic required to transform the raw data to be suitable for analysis. If you always need to remember to filter out certain rows from your raw data, you should have an intermediate data model where that filter has already been applied. What does a “lapsed customer” mean for your business? Is it someone who hasn’t purchased anything for a certain time? Or perhaps someone who hasn’t even logged in to your platform for a while? Whatever that definition, it should be encoded in a data model.</p>
</div>
<div class="readable-text intended-text" id="p15">
<p>Creating data models increases transparency because there is a single place to look for how a customer, a vehicle, or a purchase event is defined. All other analyses should be done using these intermediate models, not the raw data. Another benefit is that this kind of cleaner data model could be exposed to data-savvy stakeholders to work with directly, thus enabling self-service. Business intelligence tools such as Tableau and Power BI allow power users to create their own reports. If that is done using centralized data models, analytical mistakes are less likely.</p>
</div>
<div class="readable-text intended-text" id="p16">
<p>As analysts, we should be looking out for opportunities to standardize business logic by encoding it in data models. These don’t have to be technically complex since they can simply be additional tables in our database. Let’s look at some tasks involved in data modeling, which we will then practice in the project.</p>
</div>
<div class="readable-text" id="p17">
<h3 class="readable-text-h3" id="sigil_toc_id_25"><span class="num-string">3.1.1</span> Common data modeling tasks</h3>
</div>
<div class="readable-text" id="p18">
<p>Data modeling usually involves some combination of</p>
</div>
<ul>
<li class="readable-text" id="p19"> Repetitive data cleaning tasks, such as fixing date formats or converting text columns into their numeric equivalents. </li>
<li class="readable-text" id="p20"> Defining business entities, concepts, and activities. </li>
<li class="readable-text" id="p21"> Deduplicating the source data. </li>
<li class="readable-text" id="p22"> Restructuring the raw data to be in a format more useful to the analytical questions it is designed to answer. This might involve making a choice between wide or long data, which we will discuss later in this section. </li>
<li class="readable-text" id="p23"> Zooming in or out, altering the level of granularity for different analytical questions. </li>
</ul>
<div class="readable-text" id="p24">
<p>These are all tasks you do not want to perform every time you need to do some analysis. They should be done once, and the output should be captured in an appropriate data model.</p>
</div>
<div class="readable-text" id="p25">
<h4 class="readable-text-h4 sigil_not_in_toc">Agreeing on terminology</h4>
</div>
<div class="readable-text" id="p26">
<p>As a junior analyst, you might end up in an industry that you are unfamiliar with. It is important to ask questions to clarify the terminology because even everyday terms like “customer” might have ambiguous meanings. Does a customer mean a single person or an organization? What if your business deals with both? Part of the data modeling process is defining these terms so that they can be encoded in a data table.</p>
</div>
<div class="readable-text print-book-callout" id="p27">
<p><span class="print-book-callout-head">Note</span>  When it comes to definitions, you cannot work in a vacuum; decisions about what concepts mean concretely need to be made in collaboration with your stakeholders.</p>
</div>
<div class="readable-text" id="p28">
<h4 class="readable-text-h4 sigil_not_in_toc">Handling duplication</h4>
</div>
<div class="readable-text" id="p29">
<p>The data you will work with will inevitably contain some duplication, which might be in the form of duplicated rows of data or duplicate records across multiple systems. If you worked in the automotive industry, you could spend a nontrivial amount of time figuring out whether “John Smith Motors” in one database is the same customer as “JS Motors” in another. Time invested in reconciling this at the data modeling stage is time well spent.</p>
</div>
<div class="readable-text intended-text" id="p30">
<p>Another important data modeling task is deciding the structure of your data, such as whether the data should be stored in a wide or a long format.</p>
</div>
<div class="readable-text" id="p31">
<h4 class="readable-text-h4 sigil_not_in_toc">Wide vs. long data</h4>
</div>
<div class="readable-text" id="p32">
<p>In many cases, your data will consist of one row per entity, such as a customer. Each row represents a customer, and each column represents a property or attribute of that customer, such as their name, age, department, and so forth. This is called a <em>wide</em> format because as the number of measurements grows, the data gains additional columns.</p>
</div>
<div class="readable-text intended-text" id="p33">
<p>In contrast, <em>long</em> data is when one row represents a single measurement of an entity. This means an entity, such as a customer, will require multiple rows. When a new measurement about the entities is added, the data gains additional rows.</p>
</div>
<div class="readable-text intended-text" id="p34">
<p>Let’s take a concrete example. Suppose you are working for a sports analytics company and want to analyze the factors that go into sports teams that win major competitions. Table 3.1 shows the dataset of football results that you have.</p>
</div>
<div class="browsable-container browsable-table-container framemaker-table-container" id="p35">
<h5 class="browsable-container-h5 sigil_not_in_toc"><span class="num-string">Table 3.1</span> Football results in a wide format</h5>
<table>
<thead>
<tr>
<th>
<div>
         Match ID 
       </div></th>
<th>
<div>
         Date 
       </div></th>
<th>
<div>
         Competition 
       </div></th>
<th>
<div>
         Round 
       </div></th>
<th>
<div>
         Home team 
       </div></th>
<th>
<div>
         Away team 
       </div></th>
<th>
<div>
         Home goals 
       </div></th>
<th>
<div>
         Away goals 
       </div></th>
</tr>
</thead>
<tbody>
<tr>
<td>  1 <br/></td>
<td>  2014-07-04 <br/></td>
<td>  World Cup 2014 <br/></td>
<td>  Quarter-final <br/></td>
<td>  France <br/></td>
<td>  Germany <br/></td>
<td>  0 <br/></td>
<td>  1 <br/></td>
</tr>
<tr>
<td>  2 <br/></td>
<td>  2014-07-04 <br/></td>
<td>  World Cup 2014 <br/></td>
<td>  Quarter-final <br/></td>
<td>  Brazil <br/></td>
<td>  Colombia <br/></td>
<td>  2 <br/></td>
<td>  1 <br/></td>
</tr>
<tr>
<td>  3 <br/></td>
<td>  2014-07-05 <br/></td>
<td>  World Cup 2014 <br/></td>
<td>  Quarter-final <br/></td>
<td>  Argentina <br/></td>
<td>  Belgium <br/></td>
<td>  1 <br/></td>
<td>  0 <br/></td>
</tr>
</tbody>
</table>
</div>
<div class="readable-text" id="p36">
<p>This is wide data because each row represents an entity, in this case, a match. With some enhancement (for instance, adding a “Winner” column), this dataset would allow easy analysis of questions such as “Which country has won the most games at a World Cup?”</p>
</div>
<div class="readable-text intended-text" id="p37">
<p>However, what if someone asked, “Which country participated in the most World Cup games?” This is trickier because the level of granularity of each row is one row per match, so we would have to consider both the “Home team” and “Away team” columns. What we would need to answer this second question more easily is one row per <em>participant</em>. We could consider creating a long-format version of the data that would look more like table 3.2.</p>
</div>
<div class="browsable-container browsable-table-container framemaker-table-container" id="p38">
<h5 class="browsable-container-h5 sigil_not_in_toc"><span class="num-string">Table 3.2</span> The same football results in a long format, one row per match participant</h5>
<table>
<thead>
<tr>
<th>
<div>
         Match ID 
       </div></th>
<th>
<div>
         Date 
       </div></th>
<th>
<div>
         Competition 
       </div></th>
<th>
<div>
         Round 
       </div></th>
<th>
<div>
         Team 
       </div></th>
<th>
<div>
         Home or away? 
       </div></th>
<th>
<div>
         Goals scored 
       </div></th>
</tr>
</thead>
<tbody>
<tr>
<td>  1 <br/></td>
<td>  2014-07-04 <br/></td>
<td>  World Cup 2014 <br/></td>
<td>  Quarter-final <br/></td>
<td>  France <br/></td>
<td>  Home <br/></td>
<td>  0 <br/></td>
</tr>
<tr>
<td>  1 <br/></td>
<td>  2014-07-04 <br/></td>
<td>  World Cup 2014 <br/></td>
<td>  Quarter-final <br/></td>
<td>  Germany <br/></td>
<td>  Away <br/></td>
<td>  1 <br/></td>
</tr>
<tr>
<td>  2 <br/></td>
<td>  2014-07-04 <br/></td>
<td>  World Cup 2014 <br/></td>
<td>  Quarter-final <br/></td>
<td>  Brazil <br/></td>
<td>  Home <br/></td>
<td>  2 <br/></td>
</tr>
<tr>
<td>  2 <br/></td>
<td>  2014-07-04 <br/></td>
<td>  World Cup 2014 <br/></td>
<td>  Quarter-final <br/></td>
<td>  Colombia <br/></td>
<td>  Away <br/></td>
<td>  1 <br/></td>
</tr>
<tr>
<td>  3 <br/></td>
<td>  2014-07-05 <br/></td>
<td>  World Cup 2014 <br/></td>
<td>  Quarter-final <br/></td>
<td>  Argentina <br/></td>
<td>  Home <br/></td>
<td>  1 <br/></td>
</tr>
<tr>
<td>  3 <br/></td>
<td>  2014-07-05 <br/></td>
<td>  World Cup 2014 <br/></td>
<td>  Quarter-final <br/></td>
<td>  Belgium <br/></td>
<td>  Away <br/></td>
<td>  0 <br/></td>
</tr>
</tbody>
</table>
</div>
<div class="readable-text" id="p39">
<p>This is now long data because rows don’t represent unique entities. The table encodes the same information, but each match is duplicated on purpose. From this table, it is easier to focus only on the “Team” column to find the team with the most World Cup matches. The downside of this format is that we cannot simply count the number of rows to find statistics such as the number of games played at a World Cup because we would be double counting.</p>
</div>
<div class="readable-text intended-text" id="p40">
<p>Neither a wide nor a long format is better than the other; the choice between them depends on the question you are trying to answer using the data. Assessing what format is best suited to your analytical question is the essence of data modeling.</p>
</div>
<div class="readable-text" id="p41">
<h4 class="readable-text-h4 sigil_not_in_toc">Identifying the right level of granularity</h4>
</div>
<div class="readable-text" id="p42">
<p>Just like the football example, you will encounter datasets that have the wrong level of granularity for your analysis. US election result data might be at an individual county level, but you might have analytical questions about individual candidates. Having a candidate-level data model would help answer candidate-specific questions much faster. The information is the same; it is just stored in a format that is more appropriate for your analytical questions.</p>
</div>
<div class="readable-text intended-text" id="p43">
<p>When beginning this project, start by asking, “What should the structure of the final data model be?” Working toward that goal (in a results-focused way!) will guide the concrete steps you will need to take.</p>
</div>
<div class="readable-text" id="p44">
<h2 class="readable-text-h2" id="sigil_toc_id_26"><span class="num-string">3.2</span> Project 2: Who are your customers?</h2>
</div>
<div class="readable-text" id="p45">
<p>Let’s look at our project, in which we will extract a customer database from a series of retail transactions. We will look at the problem statement, which is what our stakeholders want to achieve in their own words. I provide an overview of the available data and discuss some of the technical specifics of the example solution. Reading section 3.2 is sufficient to get started, but you may find section 3.3 helpful to see how the results-driven approach would be applied in this scenario.</p>
</div>
<div class="readable-text intended-text" id="p46">
<p>The data is available at <a href="https://davidasboth.com/book-code">https://davidasboth.com/book-code</a>. You will find the datasets with which you can attempt the project, as well as the example solution in the form of a Jupyter notebook.</p>
</div>
<div class="readable-text" id="p47">
<h3 class="readable-text-h3" id="sigil_toc_id_27"><span class="num-string">3.2.1</span> Problem statement</h3>
</div>
<div class="readable-text" id="p48">
<p>In this example, you have been hired by Ebuy Emporium, a new e-commerce startup. They have been up and running for a month and have had unexpected success. They are starting to have an active interest in their customer base. Who are their customers? What do they buy? What drives their purchasing behavior? However, before they do any serious analysis, they need to be able to count their customers, which happens to be more difficult than anticipated. One problem is there are multiple sources of customer data, which are</p>
</div>
<ul>
<li class="readable-text" id="p49"> The e-commerce platform’s customer database, where customer details are recorded when they sign up for an account online. This is where most of the customer details should be found. </li>
<li class="readable-text" id="p50"> The in-house CRM (customer relationship management) system, where customer details are recorded when they make a purchase over the phone or are otherwise onboarded as customers (except because of purchasing online with a registered account). </li>
<li class="readable-text" id="p51"> The raw transaction data, which we will hereafter refer to as “purchases” or “sales,” and which also contains purchases made “as a guest,” meaning customer records are not explicitly created at the time of purchase. </li>
</ul>
<div class="readable-text print-book-callout" id="p52">
<p><span class="print-book-callout-head">NOTE</span>  Original transaction data courtesy of REES46 (<a href="https://mng.bz/6eZo">https://mng.bz/6eZo</a>), enhanced with fictitious customer data from a European Union Collaboration in Research and Methodology (CROS) training program on record linkage (<a href="https://mng.bz/oKad">https://mng.bz/oKad</a>). Thank you to the dataset owners for providing permission to repurpose the original source data.</p>
</div>
<div class="readable-text" id="p53">
<p>Another problem is that the existing data sources may not be mutually exclusive—there might be overlaps across them all. There is almost certainly some duplication, either because the same customer had their details entered into multiple systems or because they have made purchases both as a guest and with a registered account. Duplicate accounts may not contain exactly the same information; there may be typos or misspellings. These complications are why the startup needs the help of an analyst to answer their question: “Who are our customers?”</p>
</div>
<div class="readable-text" id="p54">
<h3 class="readable-text-h3" id="sigil_toc_id_28"><span class="num-string">3.2.2</span> Data dictionary</h3>
</div>
<div class="readable-text" id="p55">
<p>Tables 3.3 and 3.4 show the data dictionaries for the three data sources, and figures 3.2 and 3.3 show sample data.</p>
</div>
<div class="browsable-container browsable-table-container framemaker-table-container" id="p56">
<h5 class="browsable-container-h5 sigil_not_in_toc"><span class="num-string">Table 3.3</span> Data dictionary for the “purchases” dataset</h5>
<table>
<thead>
<tr>
<th>
<div>
         Column 
       </div></th>
<th>
<div>
         Definition 
       </div></th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>event_time</code> <br/></td>
<td>  The exact date and time the purchase occurred. <br/></td>
</tr>
<tr>
<td> <code>product_id</code> <br/></td>
<td>  The unique identifier of the purchased product. <br/></td>
</tr>
<tr>
<td> <code>category_id</code> <br/></td>
<td>  The unique identifier of the purchased product’s specific category. <br/></td>
</tr>
<tr>
<td> <code>category_code</code> <br/></td>
<td>  A broad category for the purchased product. In a hierarchy, category codes contain multiple category IDs, and one <code>category_id</code> should only be linked to one <code>category_code</code>. <br/></td>
</tr>
<tr>
<td> <code>brand</code> <br/></td>
<td>  The purchased item’s brand (if applicable). <br/></td>
</tr>
<tr>
<td> <code>price</code> <br/></td>
<td>  The price the item was bought for (in USD). <br/></td>
</tr>
<tr>
<td> <code>session_id</code> <br/></td>
<td>  A unique identifier for a purchase session. If multiple items are purchased in a transaction, each item will have a row in the table, and the rows will share a <code>session_id</code>. <br/></td>
</tr>
<tr>
<td> <code>customer_id</code> <br/></td>
<td>  The unique identifier of the customer if they purchased using a registered account. For guest purchases, this value will be missing. <br/></td>
</tr>
<tr>
<td> <code>guest_first_name</code> <br/></td>
<td>  The first name that was supplied if a purchase was made as a guest. For purchases made using registered accounts, this value will be missing. <br/></td>
</tr>
<tr>
<td> <code>guest_surname</code> <br/></td>
<td>  The surname that was supplied if a purchase was made as a guest. For purchases made using registered accounts, this value will be missing. <br/></td>
</tr>
<tr>
<td> <code>guest_postcode</code> <br/></td>
<td>  The postcode that was supplied if a purchase was made as a guest. For purchases made using registered accounts, this value will be missing. <br/></td>
</tr>
</tbody>
</table>
</div>
<div class="browsable-container figure-container" id="p57">
<img alt="figure" height="521" src="../Images/3-2.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.2</span> A snapshot of the purchases dataset</h5>
</div>
<div class="browsable-container browsable-table-container framemaker-table-container" id="p58">
<h5 class="browsable-container-h5 sigil_not_in_toc"><span class="num-string">Table 3.4</span> Data dictionary for the CRM and customers datasets, which share an identical structure</h5>
<table>
<thead>
<tr>
<th>
<div>
         Column 
       </div></th>
<th>
<div>
         Definition 
       </div></th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>customer_id</code> <br/></td>
<td>  The unique identifier of the customer in this system <br/></td>
</tr>
<tr>
<td> <code>first_name</code> <br/></td>
<td>  The customer’s first name <br/></td>
</tr>
<tr>
<td> <code>surname</code> <br/></td>
<td>  The customer’s surname <br/></td>
</tr>
<tr>
<td> <code>postcode</code> <br/></td>
<td>  The customer’s postal code <br/></td>
</tr>
<tr>
<td> <code>age</code> <br/></td>
<td>  The customer’s age, in years <br/></td>
</tr>
</tbody>
</table>
</div>
<div class="browsable-container figure-container" id="p59">
<img alt="figure" height="266" src="../Images/3-3.png" width="608"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.3</span> A snapshot of the customer data</h5>
</div>
<div class="readable-text print-book-callout" id="p60">
<p><span class="print-book-callout-head">NOTE</span>  It is important to remember that the data dictionary refers to the assumptions about what data is present in each column. It is good practice to verify some of these assumptions as part of the exploratory data analysis phase. For example, do the customer IDs provided in the purchase data always match a record in one of the customer databases?</p>
</div>
<div class="readable-text" id="p61">
<p>In this case, the data dictionaries are self-explanatory, but the first step in working with a new dataset should always be making sure we’ve read any relevant documentation.</p>
</div>
<div class="readable-text" id="p62">
<h3 class="readable-text-h3" id="sigil_toc_id_29"><span class="num-string">3.2.3</span> Desired outcomes</h3>
</div>
<div class="readable-text" id="p63">
<p>The output of this project should be a single dataset representing your customer data model—your best estimate of the entire customer base the startup currently has. Data will come from the three sources provided, and you will need to consolidate and deduplicate accordingly. You will need to decide on the structure of the data model based on the columns available in the datasets. This data model should be structured so that all the logic to define customers is already in place, and answering the question “How many customers do we have?” should be done as simply as counting the rows.</p>
</div>
<div class="readable-text intended-text" id="p64">
<p>There is no single right solution you’re aiming for and no ground truth to check your answers against. This is partly because analysis contains so much ambiguity that different analysts will make different assumptions and arrive at different conclusions, and partly because tasks like this never have answers to check against in the real world. Part of being a good analyst is embracing constant uncertainty and ambiguity and being comfortable with an answer that may never be a complete one. The important thing is being able to provide an answer your stakeholders can use.</p>
</div>
<div class="readable-text" id="p65">
<h3 class="readable-text-h3" id="sigil_toc_id_30"><span class="num-string">3.2.4</span> Required tools</h3>
</div>
<div class="readable-text" id="p66">
<p>Although the projects are technology agnostic, for this example solution, I use the Python library <code>pandas</code> to manipulate the datasets and <code>numpy</code> for numerical functions. I also introduce the <code>recordlinkage</code> library used for entity resolution. I keep the code snippets to a minimum and focus on the conceptual solution, but the full solution is presented as a Jupyter notebook. This is a tool for presenting code, data, and text in a single document, making it easy to share your findings, as well as the underlying methods. You can attempt this exercise with any number of tools as long as they satisfy the following criteria, that is, they are able to</p>
</div>
<ul>
<li class="readable-text" id="p67"> Load a dataset of tens of thousands of rows from a CSV file </li>
<li class="readable-text" id="p68"> Create new columns and manipulate existing ones </li>
<li class="readable-text" id="p69"> Join datasets together </li>
<li class="readable-text" id="p70"> Perform basic analysis tasks such as sorting, grouping, and reshaping data </li>
</ul>
<div class="readable-text" id="p71">
<h2 class="readable-text-h2" id="sigil_toc_id_31"><span class="num-string">3.3</span> Planning our approach to customer data modeling</h2>
</div>
<div class="readable-text" id="p72">
<p>Let’s use the results-driven approach to break the problem down into its logical components. This will give us a deeper understanding of our problem before we start working on it. We will also explicitly decide what not to do, that is, we will figure out which features of the problem are not essential to a first iteration.</p>
</div>
<div class="readable-text" id="p73">
<h3 class="readable-text-h3" id="sigil_toc_id_32"><span class="num-string">3.3.1</span> Applying the results-driven process to data modeling</h3>
</div>
<div class="browsable-container figure-container" id="p74">
<img alt="figure" height="175" src="../Images/3-unnumb-1.png" width="529"/>
</div>
<div class="readable-text" id="p75">
<p><em><span class="aframe-location"/></em>First, we need to understand the question. In this case, the question is vaguely “Who are our customers?” which would normally require some pushback for clarification. In this instance, whatever the actual analytical question about customers is, the data modeling step is fundamental to answering it. We must first consolidate the customer data from the three data sources.</p>
</div>
<div class="readable-text print-book-callout" id="p76">
<p><span class="print-book-callout-head">TIP</span>  We could think about what additional data to augment it with to better fit the needs of the analytical questions. We know we want to end up with one row per customer, but we don’t yet know if a summary of the customer’s purchase history would be a useful addition. In this case, we don’t want to spend time preemptively adding information to our data model because we think someone might ask for it down the line.<em/></p>
</div>
<div class="browsable-container figure-container" id="p77">
<img alt="figure" height="175" src="../Images/3-unnumb-2.png" width="529"/>
</div>
<div class="readable-text" id="p78">
<p><em><span class="aframe-location"/></em>Our end product is quite well defined, but, specifically, starting from the end here means having an idea of the structure of the final data model, the existence of which will allow us to count customers to produce our minimum viable answer. We know that one of its most important properties should be that it contains one row per customer. That’s the level of granularity we’re aiming for. Any purchase data we augment it with would, therefore, need to be aggregated to the customer level; we couldn’t include individual products purchased by a customer but could include their total spending, the date they first signed up, the number of unique purchases they made, and so forth.</p>
</div>
<div class="readable-text intended-text" id="p79">
<p>Another aspect of looking ahead at our end result is to identify the schema of our final data model. What columns are common across our datasets? Are there columns we will have to drop before we combine the data sources, or are they important enough that we will accept some missing data in our final solution? In data modeling, these are all important aspects to think about up front, so we can keep them in mind while in the weeds of coding our solution, and we don’t spend time manipulating data that we cannot use in the final data model.</p>
</div>
<div class="browsable-container figure-container" id="p80">
<img alt="figure" height="175" src="../Images/3-unnumb-3.png" width="1075"/>
</div>
<div class="readable-text" id="p81">
<p><em><span class="aframe-location"/></em>The datasets have been identified and provided for us in this case, so our “Identify” and “Obtain” steps have been done for us. However, in a real-world scenario, it would be prudent to think about any additional sources of customer data that might exist within our organization. This often includes spreadsheets kept by various sales managers on their computer desktops!</p>
</div>
<div class="browsable-container figure-container" id="p82">
<img alt="figure" height="175" src="../Images/3-unnumb-4.png" width="529"/>
</div>
<div class="readable-text" id="p83">
<p><em><span class="aframe-location"/></em>To actually do the data modeling task, here are some key steps to consider:</p>
</div>
<ol>
<li class="readable-text" id="p84"> We would start by exploring all three datasets. We want to ascertain whether the columns contain what the data dictionaries have said. For example, are guest details always complete when we don’t have a customer ID? We also want to see whether the values make sense. We’re concentrating on customer data but might also want to see if the <code>price</code> column contains any unrealistic values. Are the date and time values all within the same period? Is there anything amiss with any of the postcode values? This is an iterative process, so we may not exhaust all our exploration at the beginning; some of these questions may only present themselves later on. We also don’t want to spend too much time exploring columns we won’t use. </li>
<li class="readable-text" id="p85"> Once we have verified some key assumptions about the data, one idea would be to deduplicate each dataset to just unique customers before merging them. This is especially true for purchases, where any time a customer buys multiple items, their details are repeated. We would also make some of the key decisions about differences in schema. If there is data that is only present in some of the sources, what do we do with it? </li>
<li class="readable-text" id="p86"> The next step is to combine these separate datasets; we want a dataset that contains all possible customer records. The combined dataset may contain duplicates. We can get rid of some obvious duplication by removing exact duplicates, which may arise if a customer record existed in both the customer database and the CRM data, and the records were otherwise identical. If the information in two customer records is identical, but the unique identifier differs, we would need to be careful. Casually removing a duplicate would result in the loss of what we might refer to as “data lineage,” that is, the traceability of where our data originally came from. If we have a customer record for Jane Smith, it’s good practice to keep all possible identifiers for that customer that we’ve encountered across datasets. Perhaps she is customer 8834 in one dataset and 931 in another, and we would want to know that somehow in our final data model. This not only makes it easier to trace her accounts back to their sources, but also increases trust in our final solution. Anyone using our data model knows the assumptions we’ve made about which customer accounts make up the customer “entity” for Jane Smith. </li>
<li class="readable-text" id="p87"> Next, we could look at deduplicating our combined customer data beyond simply identifying exact duplicates. Fuzzy string matching might be a good approach here; in this case, we compare two strings and judge them as identical if they almost are. When using fuzzy matching, typos are taken into account, and “London” and “Lodnon” are seen as the same string. Research in the field of record linkage and entity resolution may be helpful to read up on. These are entire topics dedicated to figuring out whether two slightly different versions of an entity are, in fact, the same. We would need to make a judgment call on whether this additional work has tangible benefits and is a good investment of our time. It might even be a task we leave for a second draft, as we may prefer to show our stakeholders our first findings before committing to this more complex step. </li>
<li class="readable-text" id="p88"> Finally, we would clean up the data model so that it has the schema we want, ensuring the column names are meaningful. Depending on how we choose to handle duplicate accounts, we may need to decide on a main account for each customer entity, for example. </li>
</ol>
<div class="browsable-container figure-container" id="p89">
<img alt="figure" height="104" src="../Images/3-unnumb-5.png" width="317"/>
</div>
<div class="readable-text" id="p90">
<p><em><span class="aframe-location"/></em>The way to present a data model is by focusing on the implications of our work. Creating a small presentation outlining what we’ve done, how many customers we’ve found, and what assumptions our work is founded on would get more attention than giving access to the data model in the database. It is unlikely our stakeholders would ever use our data model to analyze data directly, anyway; the main benefit of the work is improved accuracy and more opportunities in customer analytics later on.</p>
</div>
<div class="readable-text intended-text" id="p91">
<p>Presenting our findings also creates an opportunity to work with our stakeholders to make some of the analytical decisions together. Sometimes, we don’t have the right intuition to choose between two seemingly similar options. A problem I have faced myself is when customers exist as companies in one database and individuals in another. I, as the analyst, shouldn’t be the one that has the final say over whether “Jane Smith” is the same customer as her company “JS Motors”; that’s a decision that needs wider business input, especially if the business is going to measure and track customer numbers over time. You can use the first iteration of your data model to present some of these key questions for your stakeholders to think about.</p>
</div>
<div class="browsable-container figure-container" id="p92">
<img alt="figure" height="175" src="../Images/3-unnumb-6.png" width="529"/>
</div>
<div class="readable-text" id="p93">
<p><em><span class="aframe-location"/></em>After getting feedback on your initial findings, it is usually apparent what the next iteration of your solution needs. In the context of the project, since we lack direct feedback from a stakeholder, iteration might mean you create a minimum viable data model quickly, perhaps stopping before doing any meaningful deduplication. Beyond allowing you to get feedback on your work quicker, getting to a minimum viable solution soon can give you the confidence that you’re on the right track. You’ll also have a solution in place that is easier to iteratively improve, rather than spending a long time on a more complex one, having nothing tangible to show for it until the end of a longer process. Alternatively, this might be the point at which it is apparent that there is no tangible business value in improving your solution further, so rather than iterating further, the project is considered complete.</p>
</div>
<div class="readable-text" id="p94">
<h3 class="readable-text-h3" id="sigil_toc_id_33"><span class="num-string">3.3.2</span> Questions to consider</h3>
</div>
<div class="readable-text" id="p95">
<p>As you work through this project, here are some key questions to consider:</p>
</div>
<ul>
<li class="readable-text" id="p96"> What are the possible ways in which customers can be represented across these datasets? It may be helpful to list all scenarios (customers in CRM, customers who made a purchase, guest checkouts, etc.) to hone in on exactly what you will need to code. </li>
<li class="readable-text" id="p97"> When you consider duplicates, how will linked accounts (i.e., a main account versus linked accounts) be represented? </li>
<li class="readable-text" id="p98"> When deduplicating records, what fields do you want to use for deduplication? Are two people with the same name living at the same postcode necessarily the same person? How much do two customers’ details need to differ before we consider them different people? </li>
</ul>
<div class="readable-text" id="p99">
<h2 class="readable-text-h2" id="sigil_toc_id_34"><span class="num-string">3.4</span> An example solution: Identifying customers from transactional data</h2>
</div>
<div class="readable-text" id="p100">
<p>Let’s dive into the details of an actual example solution. I strongly recommend attempting the project yourself before reviewing the example solution. As with every project, the data files, as described in section 3.2, are in the supplementary materials. I also recommend reading this section even if you’ve got a solution you’re happy with, not because the example solution is the only solution but because we can learn a lot from seeing how others approach the same problem. </p>
</div>
<div class="readable-text" id="p101">
<h3 class="readable-text-h3" id="sigil_toc_id_35"><span class="num-string">3.4.1</span> Developing an action plan</h3>
</div>
<div class="readable-text" id="p102">
<p>We will first explore the data to see if our assumptions about it hold, whether any data is missing, and so on. Then, we will decide on a common schema for our datasets and trim them all down to this common schema, meaning we will have three smaller customer datasets—one from purchases, one from the customer database, and one from the CRM data—which are all structured the same way and can be easily combined. After combining the datasets, we will deduplicate our records to arrive at the best guess of our customer base. </p>
</div>
<div class="readable-text" id="p103">
<h3 class="readable-text-h3" id="sigil_toc_id_36"><span class="num-string">3.4.2</span> Exploring, extracting, and combining multiple sources of data</h3>
</div>
<div class="readable-text" id="p104">
<p>We will explore each of the three datasets, extract common customer information from them, and combine them into one “master” view of customers. We will then look at deduplicating that combined dataset. Let’s start with the raw purchases.</p>
</div>
<div class="readable-text" id="p105">
<h4 class="readable-text-h4 sigil_not_in_toc">Exploring a new dataset</h4>
</div>
<div class="readable-text" id="p106">
<p>We start by importing the necessary libraries and reading in the sales data:</p>
</div>
<div class="browsable-container listing-container" id="p107">
<div class="code-area-container">
<pre class="code-area">import pandas as pd
import numpy as np       <span class="aframe-location"/> #1

sales = pd.read_csv("./data/purchases.csv")     <span class="aframe-location"/> #2
print(sales.shape)           <span class="aframe-location"/> #3</pre>
<div class="code-annotations-overlay-container">
     #1 Imports necessary libraries
     <br/>#2 Reads in our purchases CSV file as a pandas DataFrame
     <br/>#3 Inspects the size of the DataFrame
     <br/>
</div>
</div>
</div>
<div class="readable-text" id="p108">
<p>The output of this code is <code>(71519,</code> <code>11)</code>, meaning just over 71,000 rows of data and 11 columns, so there are over 71,000 transactions in the purchases table. We know from the problem statement that guest checkouts will not make up all our transactions, so checking for missing data should at least reveal some missing guest information. The following code produces the output in figure 3.4, showing the count of missing values per column:</p>
</div>
<div class="browsable-container listing-container" id="p109">
<div class="code-area-container">
<pre class="code-area">sales.isnull().sum()    <span class="aframe-location"/> #1</pre>
<div class="code-annotations-overlay-container">
     #1 A pandas trick to “add up” rows with missing values
     <br/>
</div>
</div>
</div>
<div class="browsable-container figure-container" id="p110">
<img alt="figure" height="323" src="../Images/3-4.png" width="306"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.4</span> Missing values in our purchases data</h5>
</div>
<div class="readable-text" id="p111">
<p>There are 18,448 missing customer IDs, which should relate to guest checkouts, and 53,071 missing guest values. Adding those up gives us 71,519, which is the total number of records, meaning that guest checkouts and registered user checkouts make up our entire dataset. There are seemingly no rows with either all this information missing or both being present, but we should verify this. First, let’s create a new column to track guest checkouts, which happen when a customer ID is not provided:</p>
</div>
<div class="browsable-container listing-container" id="p112">
<div class="code-area-container">
<pre class="code-area">sales["is_guest"] = sales["customer_id"].isnull()</pre>
</div>
</div>
<div class="readable-text" id="p113">
<p>Now, our <code>is_guest</code> column takes the Boolean value of <code>True</code> if the customer ID is missing. We can use this column to verify our assumption about the guest checkouts and the customer IDs being mutually exclusive. The first line of this code checks for cases where the transaction was a guest checkout, but we also had a customer ID, and the second returns cases where we had neither:</p>
</div>
<div class="browsable-container listing-container" id="p114">
<div class="code-area-container">
<pre class="code-area">sales[sales["is_guest"] &amp; sales["customer_id"].notnull()]
sales[(sales["is_guest"] == False) &amp; sales["customer_id"].isnull()]</pre>
</div>
</div>
<div class="readable-text" id="p115">
<p>The output for both lines is presented in figure 3.5.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p116">
<img alt="figure" height="77" src="../Images/3-5.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.5</span> The output of our code to check whether guest and registered user checkouts overlap</h5>
</div>
<div class="readable-text" id="p117">
<p>This is Python’s way of telling us that there are no records for our criteria, meaning we can be sure that all rows are either a guest checkout or a purchase made by a registered customer. Next on our data quality agenda is checking what percentage of records are guest checkouts. This is not just for informational purposes, but also for us to get a sense of how many customer records we will have to infer. As guest checkouts are our weakest signal for a customer record, any guests we add to our customer database are assumed customers. They are inferred rather than concrete customer accounts.</p>
</div>
<div class="readable-text intended-text" id="p118">
<p>For example, if someone entered John Smith as their guest checkout name, it could be because Mr. Smith was buying something on behalf of someone else, perhaps as a gift. Is John Smith the customer in this case? Or maybe it was someone using Mr. Smith’s credit card, maybe one of his children. In this case, is the customer John Smith or the child? Either way, we have no more information to go on than the guest name, John Smith, and that is what we would need to put in the customer database. Counting the number of guest accounts is useful to determine what percentage of our customer data will be “assumed” cases like this. Using the <code>is_guest</code> column we created earlier, we can calculate its distribution:</p>
</div>
<div class="browsable-container listing-container" id="p119">
<div class="code-area-container">
<pre class="code-area">sales["is_guest"].value_counts(normalize=True)</pre>
</div>
</div>
<div class="readable-text" id="p120">
<p>The output is shown in figure 3.6.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p121">
<img alt="figure" height="80" src="../Images/3-6.png" width="360"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.6</span> The proportion of guest vs. registered user purchases</h5>
</div>
<div class="readable-text" id="p122">
<p>This tells us that 25% of the rows are guest checkouts, but we need to remember that one row represents a purchased <em>item</em>, not a customer record, so the proportion of customers who checked out as guests is not necessarily 25%. We can calculate this actual proportion:</p>
</div>
<div class="browsable-container listing-container" id="p123">
<div class="code-area-container code-area-with-html">
<pre class="code-area">guest_columns = ["guest_first_name", "guest_surname",
<span class="">↪</span> "guest_postcode"]
unique_guests = sales[guest_columns].drop_duplicates()   <span class="aframe-location"/> #1
print(len(unique_guests))
unique_customers = sales["customer_id"].unique()          <span class="aframe-location"/> #2
cust_total = len(unique_customers) + len(unique_guests)
print(len(unique_guests) / (cust_total-1))                <span class="aframe-location"/> #3</pre>
<div class="code-annotations-overlay-container">
     #1 Gets a unique combination of guest columns
     <br/>#2 Gets all unique customer IDs
     <br/>#3 Subtracts 1 from the unique customer count because NULL is also counted
     <br/>
</div>
</div>
</div>
<div class="readable-text" id="p124">
<p>This prints a value of <code>8301</code> and another just under <code>0.25</code>, meaning we have 8,301 unique combinations of guest columns, and once we extract unique customers, it turns out a quarter are indeed not registered and checked out as guests instead. This number won’t be exact because there could be typos. We are assuming every combination of name and postcode is a unique customer, but a single customer making a typo during one of their checkouts would result in us double-counting them here. This, of course, assumes they are allowed to make a typo during the checkout process. We would need to know more about the actual e-commerce system to understand whether these guest columns relate to billing or credit card information, for example, where typos might cause the purchase to be rejected. Knowing the data-generating process is vital.</p>
</div>
<div class="readable-text intended-text" id="p125">
<p>Let’s summarize what we have so far. Figure 3.7 shows the progress we’ve made exploring the purchases dataset.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p126">
<img alt="figure" height="449" src="../Images/3-7.png" width="929"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.7</span> Progress in exploring the purchases dataset</h5>
</div>
<div class="readable-text" id="p127">
<h4 class="readable-text-h4 sigil_not_in_toc">Identifying a common structure between datasets</h4>
</div>
<div class="readable-text" id="p128">
<p>There are around 25,000 unique customer IDs, which represent registered customers, and another roughly 8,000 unique inferred guests, so from purchases alone, we estimate the upper bound of the number of customers to be around 33,000. I say upper bound because we will have to investigate duplicate accounts later, and this number may decrease if we find any. We also know that we have a first name, surname, and postcode available for guest checkouts. We will need to bear this in mind when we look at the other customer databases.</p>
</div>
<div class="readable-text intended-text" id="p129">
<p>However, before we export our first intermediate dataset, we need to decide on a schema for our data model. We know our guest customers have names and postcodes, and if we look at the data dictionary, we can see the customer and CRM datasets also have customer age. We don’t really want to drop that column just because it is missing for guest accounts, so our final schema will include it.</p>
</div>
<div class="readable-text intended-text" id="p130">
<p>It is generally a good idea to also keep track of where our records came from once they are combined into a single table. We could do this by adding a <code>source</code> column, which could have values of <code>purchases</code>, <code>customer</code> <code>database</code>, or <code>CRM</code>, but this structure would assume a record can only come from one place. We may encounter duplication, so a better choice is an indicator column for each data source, that is, a column to mark whether the record is present in the purchase data, another to indicate whether it’s present in the customer database, and so on. These are mostly for data lineage purposes, so the source of the information is more transparent. We can also decide to explicitly track whether a record came from a guest checkout because this may be important later if a stakeholder wants to know what percentage of customers don’t register when buying. Table 3.5 shows the final schema, which is what each of the three datasets needs to be transformed into.</p>
</div>
<div class="browsable-container browsable-table-container framemaker-table-container" id="p131">
<h5 class="browsable-container-h5 sigil_not_in_toc"><span class="num-string">Table 3.5</span> The data model schema that all data sources need to be transformed into</h5>
<table>
<thead>
<tr>
<th>
<div>
         Column 
       </div></th>
<th>
<div>
         Description 
       </div></th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>customer_id</code> <br/></td>
<td>  The unique ID of the customer record, or NULL for guests. <br/></td>
</tr>
<tr>
<td> <code>first_name</code> <br/></td>
<td>  Either from the customer or CRM tables or the guest information. <br/></td>
</tr>
<tr>
<td> <code>surname</code> <br/></td>
<td>  Either from the customer or CRM tables or the guest information. <br/></td>
</tr>
<tr>
<td> <code>postcode</code> <br/></td>
<td>  Either from the customer or CRM tables or the guest information. <br/></td>
</tr>
<tr>
<td> <code>age</code> <br/></td>
<td>  From the customer or CRM tables, unavailable for guests. <br/></td>
</tr>
<tr>
<td> <code>is_guest</code> <br/></td>
<td> <code>True</code> if the data comes from a guest checkout. <br/></td>
</tr>
<tr>
<td> <code>in_purchase_data</code> <br/></td>
<td> <code>True</code> if this customer record appears in the purchase table. It is not exclusive since the customer could also appear in the customer or CRM datasets. <br/></td>
</tr>
<tr>
<td> <code>in_crm_data</code> <br/></td>
<td> <code>True</code> if the customer record exists in the CRM database. <br/></td>
</tr>
<tr>
<td> <code>in_customer_data</code> <br/></td>
<td> <code>True</code> if the customer record exists in the customer database. <br/></td>
</tr>
</tbody>
</table>
</div>
<div class="readable-text" id="p132">
<p>Let’s go ahead and transform our first raw dataset, sales, into this desired structure.</p>
</div>
<div class="readable-text" id="p133">
<h4 class="readable-text-h4 sigil_not_in_toc">Restructuring a dataset to the common structure</h4>
</div>
<div class="readable-text" id="p134">
<p>The easiest way to export our customers from the purchase data is to extract the guests and non-guests separately and then combine them. These two subsets will not have the same structure because we have three columns for guests (first name, surname, and postcode) and for registered customers, we only have their IDs. We could join data from the customer and CRM tables to find the relevant names and postcodes for these IDs, or we could do that when we get around to exploring and manipulating the customer datasets. This choice is more personal preference than anything else. I’ve chosen to leave the joining until later, so for now, we will export incomplete data.</p>
</div>
<div class="readable-text intended-text" id="p135">
<p>To export only the guests, we can filter using our <code>is_guest</code> column and export only the relevant columns:</p>
</div>
<div class="browsable-container listing-container" id="p136">
<div class="code-area-container code-area-with-html">
<pre class="code-area">guest_columns = ["guest_first_name", "guest_surname",
<span class="">↪</span> "guest_postcode", "is_guest"]
guests = sales.loc[sales["is_guest"], guest_columns]
guests = guests.drop_duplicates()    <span class="aframe-location"/> #1
guests.head()</pre>
<div class="code-annotations-overlay-container">
     #1 We drop duplicates to ensure we only have unique guest information.
     <br/>
</div>
</div>
</div>
<div class="readable-text" id="p137">
<p>The output is as presented in figure 3.8.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p138">
<img alt="figure" height="286" src="../Images/3-8.png" width="781"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.8</span> Guest data from the purchases table ready to be combined with customer data</h5>
</div>
<div class="readable-text" id="p139">
<p>For non-guest checkouts, we won’t have these columns; we will have only a customer ID:</p>
</div>
<div class="browsable-container listing-container" id="p140">
<div class="code-area-container">
<pre class="code-area">non_guests = (
  pd.DataFrame(           <span class="aframe-location"/> #1
    sales.loc[sales["customer_id"].notnull(), "customer_id"]
      .unique()                   <span class="aframe-location"/> #2
      .astype(int),
    columns=["customer_id"]
  )
)
non_guests.head()</pre>
<div class="code-annotations-overlay-container">
     #1 Customer ID is a single column, so we need to explicitly make it a DataFrame.
     <br/>#2 We extract unique customer IDs from non-guest rows.
     <br/>
</div>
</div>
</div>
<div class="readable-text" id="p141">
<p>The output is shown in figure 3.9.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p142">
<img alt="figure" height="301" src="../Images/3-9.png" width="208"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.9</span> Non-guest data from purchases, which is just a column of customer IDs</h5>
</div>
<div class="readable-text" id="p143">
<p>The data shown in figures 3.8 and 3.9 are of a different structure. However, when we combine them, we will have all the columns from both datasets and missing data where a column did not exist in one of the datasets:</p>
</div>
<div class="browsable-container listing-container" id="p144">
<div class="code-area-container">
<pre class="code-area">sales_customers = pd.concat([non_guests,guests], axis=0, ignore_index=True)</pre>
</div>
</div>
<div class="readable-text" id="p145">
<p>First, we concatenate (or “union” if you are used to SQL terminology) our two datasets. Then, we rename our columns and remove the guest prefix:</p>
</div>
<div class="browsable-container listing-container" id="p146">
<div class="code-area-container code-area-with-html">
<pre class="code-area">new_col_names = ["customer_id", "first_name", "surname",
<span class="">↪</span> "postcode", "is_guest"]
sales_customers = sales_customers.set_axis(new_col_names, axis=1)</pre>
</div>
</div>
<div class="readable-text" id="p147">
<p>We also want to make sure we don’t have missing data, so we fill in the missing values for the <code>is_guest</code> column. Technically, we could leave it blank to indicate that someone isn’t a guest, but explicitly using <code>True</code>/<code>False</code> values is clearer:</p>
</div>
<div class="browsable-container listing-container" id="p148">
<div class="code-area-container">
<pre class="code-area">sales_customers["is_guest"] = sales_customers["is_guest"].fillna(False)</pre>
</div>
</div>
<div class="readable-text" id="p149">
<p>Now we add the <code>in_purchase_data</code> column we decided on for our schema:</p>
</div>
<div class="browsable-container listing-container" id="p150">
<div class="code-area-container">
<pre class="code-area">sales_customers["in_purchase_data"] = True</pre>
</div>
</div>
<div class="readable-text" id="p151">
<p>Since we’re working with text data, another important step is to ensure there is no trailing whitespace and that the names all use the same capitalization. This is so that customer names are treated as being the same even if one is lowercase and the other uppercase. We can use the <code>pandas</code> built-in <code>.str</code> accessor class, which lets us manipulate entire string columns:</p>
</div>
<div class="browsable-container listing-container" id="p152">
<div class="code-area-container">
<pre class="code-area">for col in ["first_name", "surname"]:
    sales_customers[col] = sales_customers[col].str.lower().str.strip()

sales_customers["postcode"] = sales_customers["postcode"].str.strip()</pre>
</div>
</div>
<div class="readable-text" id="p153">
<p>Now, the customer data extracted from our purchases looks like figure 3.10.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p154">
<img alt="figure" height="675" src="../Images/3-10.png" width="1014"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.10</span> A preview of our customer data extracted from purchases</h5>
</div>
<div class="readable-text" id="p155">
<p>The first rows show the non-guest checkouts and the registered customers. For now, we have no names or postcodes for them because we decided to join those afterward. The last few rows in the preview show our guests, hence the missing customer ID.</p>
</div>
<div class="readable-text intended-text" id="p156">
<p>Before we move on, let’s summarize what we have done so far. Figure 3.11 shows the steps we took when exploring and reshaping the purchases dataset. Text that appears without shapes represents steps and decisions from previous sections.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p157">
<img alt="figure" height="713" src="../Images/3-11.png" width="604"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.11</span> The steps we took on the purchases dataset</h5>
</div>
<div class="readable-text intended-text" id="p158">
<p>We are now ready to move on and explore the customer datasets and merge them with the customer data we have just exported from our raw purchases.</p>
</div>
<div class="readable-text" id="p159">
<h4 class="readable-text-h4 sigil_not_in_toc">Exploring a second dataset</h4>
</div>
<div class="readable-text" id="p160">
<p>We know from the data dictionary that both customer datasets have the same schema. What we’re looking for in both datasets is whether there is any missing data, whether the customer IDs are all filled in, and whether there are any duplicate records. Since customer ID is a unique identifier, we don’t anticipate any duplicates, but you cannot assume anything. We start with the CRM data:</p>
</div>
<div class="browsable-container listing-container" id="p161">
<div class="code-area-container">
<pre class="code-area">crm = pd.read_csv("./data/crm_export.csv")
print(crm.shape)
crm.head()</pre>
</div>
</div>
<div class="readable-text" id="p162">
<p>The shape of the dataset is <code>(7825,</code> <code>5)</code>, meaning 7,825 rows and 5 columns. Figure 3.12 shows a preview of the CRM dataset.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p163">
<img alt="figure" height="287" src="../Images/3-12.png" width="649"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.12</span> The first few rows of the raw CRM data</h5>
</div>
<div class="readable-text" id="p164">
<p>We check for missing data with the following code, the output of which is shown in figure 3.13:</p>
</div>
<div class="browsable-container listing-container" id="p165">
<div class="code-area-container">
<pre class="code-area">crm.isnull().sum()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p166">
<img alt="figure" height="154" src="../Images/3-13.png" width="192"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.13</span> No missing data in the CRM table</h5>
</div>
<div class="readable-text" id="p167">
<p>The next bit of sanity checking is ensuring that customer IDs are unique. One way to do this is to group by the customer ID and find instances where there are multiple rows in a group. If customer IDs are unique, no records should be returned. Let’s verify this:</p>
</div>
<div class="browsable-container listing-container" id="p168">
<div class="code-area-container">
<pre class="code-area">crm.groupby("customer_id").size().loc[lambda x: x &gt; 1]</pre>
</div>
</div>
<div class="readable-text" id="p169">
<p>Here we use <code>groupby</code> and <code>size</code> to count how many records we have per customer ID and use <code>loc</code> to filter instances where there is more than one. The Python output is <code>Series([],</code> <code>dtype:</code> <code>int64),</code> which indicates no records were found, as the empty square brackets represent an empty collection in Python. This means customer IDs are indeed unique.</p>
</div>
<div class="readable-text intended-text" id="p170">
<p>However, this does not mean that customer <em>details</em> are unique in the table. If we look at how many unique combinations of name, postcode, and age we have, we can see this:</p>
</div>
<div class="browsable-container listing-container" id="p171">
<div class="code-area-container">
<pre class="code-area">print(len(crm))
print(len(crm.drop(columns="customer_id").drop_duplicates()))</pre>
</div>
</div>
<div class="readable-text" id="p172">
<p>The output is 7,825 and 7,419, respectively, meaning that while there are 7,825 rows in the CRM data, there are only 7,419 unique combinations of columns once we drop the customer ID, which indicates we have about 400 duplicate customer details where the same information is spread across multiple IDs. This might not mean 400 duplicate customers because we could also have multiple people with very common names living at the same postcode, but because we have also factored age into it, it is more likely these are all redundant duplicates. Incorrect duplicates, if there are any, are likely to be a very small percentage when we consider the size of the dataset, so it makes sense not to dwell on this, and for now, say that every unique combination of name, postcode, and age is a unique customer. The nature of data modeling work is that there will always be a margin of error.</p>
</div>
<div class="readable-text intended-text" id="p173">
<p>Figure 3.14 summarizes what we have done so far with the CRM data.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p174">
<img alt="figure" height="819" src="../Images/3-14.png" width="632"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.14</span> First steps in processing the CRM data</h5>
</div>
<div class="readable-text" id="p175">
<h4 class="readable-text-h4 sigil_not_in_toc">Joining datasets to enhance one with information from another</h4>
</div>
<div class="readable-text" id="p176">
<p>The next step is to transform the CRM data to the same schema as the customers from the purchase table, and we also need to enhance the registered customers in the purchase history with details from the CRM data. So far, we only have IDs for those customers, but we need their names, postcodes, and ages. Not all of them will be found in the CRM data, but we can join the two and populate as many rows as we can. We will use a left join for this as that will ensure we keep all the rows in the original data regardless of whether we find a match in the other. The code for this is as follows, and the result is shown in figure 3.15:</p>
</div>
<div class="browsable-container listing-container" id="p177">
<div class="code-area-container code-area-with-html">
<pre class="code-area">sales_and_crm_customers = sales_customers.merge(crm,
<span class="">↪</span> on="customer_id", how="left", suffixes=("_sales", "_crm"))
print(len(sales_and_crm_customers))
sales_and_crm_customers.isnull().sum()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p178">
<img alt="figure" height="291" src="../Images/3-15.png" width="285"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.15</span> Checking for missing values after merging the sales and CRM data</h5>
</div>
<div class="readable-text" id="p179">
<p>One <code>pandas</code>-specific peculiarity is that columns that appear in both tables get an <code>_x</code> and <code>_y</code> suffix by default. We overrode this here to be more descriptive, so the ones with <code>_sales</code> are from the source data—the purchases—and the <code>_crm</code> suffix is given to the merged data, in this case, the CRM data.</p>
</div>
<div class="readable-text intended-text" id="p180">
<p>Given that there were around 33,000 rows in the sales data and 26,000 rows missing from the newly added CRM customer columns, we can see we matched around 7,000 rows on customer ID. That is, customers in 7,000 purchases had their records stored in the CRM table. What we have now is a dataset where 7,000 customer records are in columns ending in <code>_crm</code>, which we should merge into the ones marked <code>_sales</code>, which contain customer data from guest checkouts. First, we define a filter to select only rows with a customer ID, thus excluding guests and rows with customer information in the <code>crm</code>-suffixed columns:</p>
</div>
<div class="browsable-container listing-container" id="p181">
<div class="code-area-container">
<pre class="code-area">merged_customers_filter = (
  (sales_and_crm_customers["customer_id"].notnull())
    &amp; ((sales_and_crm_customers["first_name_crm"].notnull())
      | (sales_and_crm_customers["surname_crm"].notnull()))
)</pre>
</div>
</div>
<div class="readable-text" id="p182">
<p>This filter can then be applied to identify these rows as having been found in the CRM data:</p>
</div>
<div class="browsable-container listing-container" id="p183">
<div class="code-area-container">
<pre class="code-area">sales_and_crm_customers.loc[merged_customers_filter, "in_crm_data"] = True
sales_and_crm_customers.loc[~merged_customers_filter, "in_crm_data"] = False
sales_and_crm_customers["in_crm_data"].value_counts()</pre>
</div>
</div>
<div class="readable-text" id="p184">
<p>The output is shown in figure 3.16.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p185">
<img alt="figure" height="80" src="../Images/3-16.png" width="388"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.16</span> Number of rows with customer information coming from the CRM data, after merging</h5>
</div>
<div class="readable-text" id="p186">
<p>This 7,114 number tallies with what we observed earlier, that around 7,000 rows have now had their customer information updated. Time to copy over data from <code>crm</code>-suffixed columns to our <code>_sales</code> suffixed ones and only keep the latter to get back to our original schema:</p>
</div>
<div class="browsable-container listing-container" id="p187">
<div class="code-area-container code-area-with-html">
<pre class="code-area">sales_and_crm_customers.loc[merged_customers_filter, ["first_name_sales",
<span class="">↪</span> "surname_sales", "postcode_sales"]] = (
    sales_and_crm_customers.loc[merged_customers_filter, ["first_name_crm",
<span class="">↪</span> "surname_crm", "postcode_crm"]]
    .values
)</pre>
</div>
</div>
<div class="readable-text" id="p188">
<p>Here, we simply copied over the first name, surname, and postcode to overwrite the missing values in <code>sales</code>-suffixed columns with CRM customer data in the <code>crm</code>-suffixed ones. Now we’re ready to remove the latter:</p>
</div>
<div class="browsable-container listing-container" id="p189">
<div class="code-area-container">
<pre class="code-area">sales_and_crm_customers = (
    sales_and_crm_customers
    .drop(columns=["first_name_crm", "surname_crm", "postcode_crm"])
    .rename(columns={
        "first_name_sales": "first_name",
        "surname_sales": "surname",
        "postcode_sales": "postcode"
    })
)
sales_and_crm_customers.head()</pre>
</div>
</div>
<div class="readable-text" id="p190">
<p>The output is shown in figure 3.17 and is what we’d expect. The schema is now the same as before, apart from a new <code>in_crm_data</code> flag, and the customer data from purchases has been enhanced with CRM data where possible.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p191">
<img alt="figure" height="254" src="../Images/3-17.png" width="1016"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.17</span> Combined purchase and CRM customer data</h5>
</div>
<div class="readable-text" id="p192">
<p>Immediately in the second row, we notice an example of a customer who purchased with a registered account, so they are not guests, but their details have been filled in via the CRM dataset. What remains is to check for and add customer details that exist in our CRM system but do not appear in our purchases. There may be reasons for this; perhaps those customers bought something on the phone, and those sales do not get recorded in the same place. Whatever the reason, it is a possibility that we need to account for to ensure full coverage.</p>
</div>
<div class="readable-text" id="p193">
<h4 class="readable-text-h4 sigil_not_in_toc">Using sets to cross-reference two datasets</h4>
</div>
<div class="readable-text" id="p194">
<p>To find these records, we employ a Python trick to subtract one set of customer IDs from another, leaving us with the difference:</p>
</div>
<div class="browsable-container listing-container" id="p195">
<div class="code-area-container code-area-with-html">
<pre class="code-area">crm_ids_to_add = list(set(crm["customer_id"].unique())
<span class="">↪</span> - set(sales_and_crm_customers["customer_id"].unique()))
print(len(crm_ids_to_add))</pre>
</div>
</div>
<div class="readable-text" id="p196">
<p>Here, “set” refers to the rigorous mathematical definition of a unique collection of items, and “difference” means the subtraction of one set from another, leaving us with only customer IDs that appear in the CRM data but not in purchases. The output tells us there are 711 such customers whose details need to be added to our growing customer dataset. We simply concatenate/union the data with the customers corresponding to the IDs we have just selected:</p>
</div>
<div class="browsable-container listing-container" id="p197">
<div class="code-area-container code-area-with-html">
<pre class="code-area">sales_and_crm_customers = (
    pd.concat([sales_and_crm_customers,
<span class="">↪</span> crm[crm["customer_id"].isin(crm_ids_to_add)]],
              axis=0,
             ignore_index=True)
)</pre>
</div>
</div>
<div class="readable-text" id="p198">
<p>One final aspect of this data to clean up is that for these new customers, we don’t have data for our source flags, so we fill them in with default values. Customers added from the CRM data will have their <code>in_crm_data</code> flag set to <code>True</code>, <code>in_purchase_data</code> as <code>False</code>, and since they weren’t guests, <code>is_guest</code> as <code>False</code>. The output of the following code is shown in figure 3.18:</p>
</div>
<div class="browsable-container listing-container" id="p199">
<div class="code-area-container code-area-with-html">
<pre class="code-area">sales_and_crm_customers["is_guest"]
<span class="">↪</span> = sales_and_crm_customers["is_guest"].fillna(False)
sales_and_crm_customers["in_purchase_data"]
<span class="">↪</span> = sales_and_crm_customers["in_purchase_data"].fillna(False)
sales_and_crm_customers["in_crm_data"]
<span class="">↪</span> = sales_and_crm_customers["in_crm_data"].fillna(True)

sales_and_crm_customers.isnull().sum()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p200">
<img alt="figure" height="242" src="../Images/3-18.png" width="310"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.18</span> After merging the CRM data and cleaning it, there are no missing values for our source flags.</h5>
</div>
<div class="readable-text" id="p201">
<p>Let’s review what we have done with the CRM data before moving on. Figure 3.19 shows all the steps we have taken.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p202">
<img alt="figure" height="816" src="../Images/3-19.png" width="362"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.19</span> The steps we took to explore the CRM data and export customer information</h5>
</div>
<div class="readable-text intended-text" id="p203">
<p>To summarize, we now have a customer dataset of all customers who made a purchase, including guest checkouts, as well as data from our CRM system, including customers who exist only in the CRM data and have no recorded purchases. We now need to repeat this process with data in the customer database, which is structurally similar to the CRM data.</p>
</div>
<div class="readable-text" id="p204">
<h4 class="readable-text-h4 sigil_not_in_toc">Exploring a third dataset</h4>
</div>
<div class="readable-text" id="p205">
<p>Time to look at our customer database. The code will be similar to the one used to manipulate the CRM data but is included for completeness:</p>
</div>
<div class="browsable-container listing-container" id="p206">
<div class="code-area-container">
<pre class="code-area">customers = pd.read_csv("./data/customer_database.csv")
print(customers.shape)
customers.head()</pre>
</div>
</div>
<div class="readable-text" id="p207">
<p>The output is <code>(23476,</code> <code>5)</code>, meaning we have over 23,000 customer records, which is significantly more than in our CRM data. A preview of what this data looks like is shown in figure 3.20.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p208">
<img alt="figure" height="286" src="../Images/3-20.png" width="629"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.20</span> The first few rows of the customer data</h5>
</div>
<div class="readable-text intended-text" id="p209">
<p>The following code checks for missing data and produces the output shown in figure 3.21:</p>
</div>
<div class="browsable-container listing-container" id="p210">
<div class="code-area-container">
<pre class="code-area">customers.isnull().sum()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p211">
<img alt="figure" height="151" src="../Images/3-21.png" width="187"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.21</span> No missing data in the customer database</h5>
</div>
<div class="readable-text" id="p212">
<p>We sanitize our columns like we did for the CRM data:</p>
</div>
<div class="browsable-container listing-container" id="p213">
<div class="code-area-container">
<pre class="code-area">for col in ["first_name", "surname"]:
    customers[col] = customers[col].str.lower().str.strip()

customers["postcode"] = customers["postcode"].str.strip()</pre>
</div>
</div>
<div class="readable-text" id="p214">
<p>Now, we can check whether customer ID is unique and how many unique combinations of customer information we have:</p>
</div>
<div class="browsable-container listing-container" id="p215">
<div class="code-area-container">
<pre class="code-area">customers.groupby("customer_id").size().loc[lambda x: x&gt;1]</pre>
</div>
</div>
<div class="readable-text" id="p216">
<p>This code yields the same output as in the CRM data, namely an empty Python collection, meaning there are no instances of the same customer ID appearing twice:</p>
</div>
<div class="browsable-container listing-container" id="p217">
<div class="code-area-container">
<pre class="code-area">print("{} rows".format(len(customers)))
unique_customers = customers.drop(columns="customer_id").drop_duplicates()
print("{} unique combinations of customers".format(len(unique_customers)))</pre>
</div>
</div>
<div class="readable-text" id="p218">
<p>The output of the previous code tells us that 23,476 rows represent 19,889 unique combinations of customer details, so we potentially have around 3,500 duplicate records to handle. We will do this once all the customer data has been merged into a single table.</p>
</div>
<div class="readable-text" id="p219">
<h4 class="readable-text-h4 sigil_not_in_toc">Merging all our data sources</h4>
</div>
<div class="readable-text" id="p220">
<p>The next step is to merge the customer information into the growing customer data by joining them. Again, we give the duplicate column names meaningful suffixes to show which table they came from:</p>
</div>
<div class="browsable-container listing-container" id="p221">
<div class="code-area-container code-area-with-html">
<pre class="code-area">all_customers = sales_and_crm_customers.merge(customers,
<span class="">↪</span> on="customer_id", how="left", suffixes=("_sales", "_customers"))
all_customers.head()</pre>
</div>
</div>
<div class="readable-text" id="p222">
<p>The output of this merge is shown in figure 3.22.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p223">
<img alt="figure" height="602" src="../Images/3-22.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.22</span> The first few rows of the sales and CRM customers merged with the customer database</h5>
</div>
<div class="readable-text" id="p224">
<p>As with the CRM data, we have duplicates of the customer detail columns. We will now identify which rows were successfully merged with the customer database, mark them with a final flag <code>in_customer_data</code>, and copy those details over to the <code>_sales</code>-suffixed columns before finally removing the redundant columns and arriving at our final schema. The output for the following code is shown in figure 3.23:</p>
</div>
<div class="browsable-container listing-container" id="p225">
<div class="code-area-container">
<pre class="code-area">merged_customers_filter = (
    (all_customers["customer_id"].notnull())
    &amp; ((all_customers["first_name_customers"].notnull())
       | (all_customers["surname_customers"].notnull()))
)
all_customers.loc[merged_customers_filter, "in_customer_data"] = True
all_customers.loc[~merged_customers_filter, "in_customer_data"] = False
all_customers["in_customer_data"].value_counts()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p226">
<img alt="figure" height="80" src="../Images/3-23.png" width="449"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.23</span> The distribution of the new flag, showing whether a customer’s details appear in the customer database</h5>
</div>
<div class="readable-text" id="p227">
<p>Almost two-thirds of purchases relate to customers whose details are stored in the customer database. We can now update the original customer details, those with a <code>_sales</code> suffix, with details from the customer database:</p>
</div>
<div class="browsable-container listing-container" id="p228">
<div class="code-area-container code-area-with-html">
<pre class="code-area">update_filter = (                             <span class="aframe-location"/> #1
    (all_customers["in_customer_data"])
    &amp; (all_customers["first_name_sales"].isnull())
    &amp; (all_customers["surname_sales"].isnull())
)

all_customers.loc[update_filter, ["first_name_sales",
<span class="">↪</span> "surname_sales", "postcode_sales", "age_sales"]] = (
    all_customers.loc[update_filter, ["first_name_customers",
<span class="">↪</span> "surname_customers", "postcode_customers", "age_customers"]].values
)                                                           <span class="aframe-location"/> #2

all_customers = (                                             <span class="aframe-location"/> #3
    all_customers
    .drop(columns=["first_name_customers", "surname_customers", "age_customers", "postcode_customers"])
    .rename(columns={
        "first_name_sales": "first_name",
        "surname_sales": "surname",
        "age_sales": "age",
        "postcode_sales": "postcode"
    })
)</pre>
<div class="code-annotations-overlay-container">
     #1 A filter to mark customers whose details we copy over
     <br/>#2 We then overwrite those customers’ details.
     <br/>#3 Finally, we merge the columns into the final schema.
     <br/>
</div>
</div>
</div>
<div class="readable-text" id="p229">
<p>We also need to add any customers present in the customer database who do not appear in the purchases table:</p>
</div>
<div class="browsable-container listing-container" id="p230">
<div class="code-area-container code-area-with-html">
<pre class="code-area">customer_ids_to_add = list(set(customers["customer_id"].unique())
<span class="">↪</span> - set(all_customers["customer_id"].unique()))
print(len(customer_ids_to_add))</pre>
</div>
</div>
<div class="readable-text" id="p231">
<p>This returns 1,423 additional customers to add:</p>
</div>
<div class="browsable-container listing-container" id="p232">
<div class="code-area-container code-area-with-html">
<pre class="code-area">all_customers = (
    pd.concat([all_customers,
<span class="">↪</span> customers[customers["customer_id"].isin(customer_ids_to_add)]],
              axis=0,
              ignore_index=True)
)</pre>
</div>
</div>
<div class="readable-text" id="p233">
<p>Finally, we update the source flags to reflect their correct defaults if they are missing. Any newly added customers are not guests, didn’t come from purchases or the CRM data, but are present in the customer database:</p>
</div>
<div class="browsable-container listing-container" id="p234">
<div class="code-area-container code-area-with-html">
<pre class="code-area">all_customers["is_guest"] = all_customers["is_guest"].fillna(False)
all_customers["in_purchase_data"]
<span class="">↪</span> = all_customers["in_purchase_data"].fillna(False)
all_customers["in_crm_data"]
<span class="">↪</span> = all_customers["in_crm_data"].fillna(False)
all_customers["in_customer_data"] 
<span class="">↪</span> = all_customers["in_customer_data"].fillna(True)</pre>
</div>
</div>
<div class="readable-text" id="p235">
<p>We can now inspect the final schema of our combined customer data model, shown in figure 3.24:</p>
</div>
<div class="browsable-container listing-container" id="p236">
<div class="code-area-container">
<pre class="code-area">all_customers.head()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p237">
<img alt="figure" height="236" src="../Images/3-24.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.24</span> A preview of the customer data merged from all three sources</h5>
</div>
<div class="readable-text" id="p238">
<p>From figure 3.24, we can already understand the combinations of where customer data comes from. The third row shows us another edge case we had to be prepared for—a purchase from a registered customer whose details we do not have in either the CRM data or the customer database. We know very little about this customer, but they were given an ID, so their details may be in another system. As analysts, we would reach out internally to the business and find an explanation. Until then, we should keep these rows as they are potentially legitimate customer entities and should thus be counted in our data model.</p>
</div>
<div class="readable-text intended-text" id="p239">
<p>Let’s summarize all our steps so far. We explored three different sources of customer data, transformed them into the same schema, and finally merged them into a single table of customer information. Figure 3.25 shows all our steps so far.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p240">
<img alt="figure" height="844" src="../Images/3-25.png" width="747"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.25</span> Steps to process three sources of customer data and finally merge them</h5>
</div>
<div class="readable-text intended-text" id="p241">
<p>Taking stock of what we have so far, we have merged our three sources of customer data, taking care to cover all eventualities, totaling 35,395 records. One step we will take before moving on to deduplication is to get a sense of the size of our various customer record types. There are four ways we could have added customers to our data model:</p>
</div>
<ul>
<li class="readable-text" id="p242"> <em>Identified customers</em>—Customers who made a purchase and their details are present in either the CRM data or the customer database </li>
<li class="readable-text" id="p243"> <em>Guest checkouts</em>—Customers whose details come from what they entered as a guest </li>
<li class="readable-text" id="p244"> <em>Unidentified customer IDs</em>—Customers with a valid ID but with no corresponding record in either customer dataset </li>
<li class="readable-text" id="p245"> <em>Customers with no purchases</em>—Customers who are present in either customer dataset but do not appear in the purchases data </li>
</ul>
<div class="readable-text" id="p246">
<p>These customer types are mutually exclusive, and their numbers should add up to the entire data model. We can verify this:</p>
</div>
<div class="browsable-container listing-container" id="p247">
<div class="code-area-container">
<pre class="code-area">identified_customers = (
    all_customers[(all_customers["customer_id"].notnull())
                  &amp; (all_customers["in_purchase_data"])
                  &amp; ((all_customers["in_crm_data"])
                     | (all_customers["in_customer_data"]))]
)

guests = all_customers[all_customers["is_guest"]]

customer_ids_not_found = (
    all_customers[(all_customers["customer_id"].notnull())
                  &amp; (all_customers["first_name"].isnull())
                  &amp; (all_customers["surname"].isnull())]
)
customer_data_only = (
    all_customers[((all_customers["in_crm_data"])
                   | (all_customers["in_customer_data"])
                  )
                  &amp; (all_customers["in_purchase_data"] == False)]
)

print(len(all_customers), len(identified_customers))
print(len(guests), len(customer_ids_not_found), len(customer_data_only))</pre>
</div>
</div>
<div class="readable-text" id="p248">
<p>The output is the following: 35,395 records in the entire data model, 23,713 of which are identified customers, 8,300 guests, 1,248 unidentified customer IDs, and 2,134 customers with no purchases. The first number is the sum of the others, so we can be confident we did not miss any of our eventualities, and they don’t overlap. At this stage, we know there might be some duplication, so we move on to the final part of modeling our customer data—entity resolution.</p>
</div>
<div class="readable-text" id="p249">
<h3 class="readable-text-h3" id="sigil_toc_id_37"><span class="num-string">3.4.3</span> Applying entity resolution to deduplicate records</h3>
</div>
<div class="readable-text" id="p250">
<p>One possible kind of duplication we might have is the same customer’s details appearing in both the CRM data and the customer database. In this case, we might have rows in our data model that are exact duplicates, which are easy to drop:</p>
</div>
<div class="browsable-container listing-container" id="p251">
<div class="code-area-container">
<pre class="code-area">print(len(all_customers))                   <span class="aframe-location"/> #1
all_customers = all_customers.drop_duplicates()
print(len(all_customers))          <span class="aframe-location"/> #2</pre>
<div class="code-annotations-overlay-container">
     #1 Checks the count of rows before deduplicating
     <br/>#2 Checks the row count again to see any impact
     <br/>
</div>
</div>
</div>
<div class="readable-text" id="p252">
<p>The output for both statements is the same—35,395 records—meaning there are no exact duplicates. In this case, this is because we updated our flags along the way. That is, customers present in multiple data sources simply have multiple source flags set to <code>True</code>, so there were no exact duplicates to drop.</p>
</div>
<div class="readable-text intended-text" id="p253">
<p>One consideration at this point is that guest checkout customers are missing the <code>age</code> column. There is a choice to make here: Do we drop this column because our final data model would contain missing data, or do we include it but avoid using it for deduplication? If you’re going to drop data, it’s better to do it as late as possible, so it makes sense to keep that column. When we deduplicate the records, we can decide whether two customers with otherwise identical information, but one has their age filled in and the other doesn’t, are the same customer.</p>
</div>
<div class="readable-text" id="p254">
<h4 class="readable-text-h4 sigil_not_in_toc">Filling in missing data with unique identifiers</h4>
</div>
<div class="readable-text" id="p255">
<p>Another decision we can make is whether to give guest accounts fake customer IDs rather than leaving them as missing data. When we get to the deduplication step, it is a good idea to link accounts together, that is, identify customer IDs that relate to the same underlying customer entity. With guest accounts, we cannot do this unless they also have unique identifiers, so it makes sense to give them their own IDs. One idea is to allocate a range of integers only for guest accounts. We can look at the existing IDs to see the current range:</p>
</div>
<div class="browsable-container listing-container" id="p256">
<div class="code-area-container">
<pre class="code-area">all_customers["customer_id"].agg(["min", "max"])</pre>
</div>
</div>
<div class="readable-text" id="p257">
<p>The output tells us the current IDs range from the number 1 all the way to 9-digit integers, so a safe range would need to be well outside this. One option is to use negative numbers instead to identify each unique guest (i.e., each combination of guest customer data points). Negative IDs are unusual for unique identifiers, but the alternative approach of allocating an ID range for guests, say, in the 12-digit range, feels just as artificial. Another option could be to create alphanumeric identifiers, like a number preceded by a “G” for “guest,” but since customer IDs are otherwise all integers, it’s a personal choice not to branch out into the alphanumeric:</p>
</div>
<div class="browsable-container listing-container" id="p258">
<div class="code-area-container">
<pre class="code-area">all_guests = all_customers[all_customers["is_guest"]].copy()
new_ids = np.arange(-1, -(len(all_guests) + 1), -1)                   <span class="aframe-location"/> #1
all_customers.loc[all_customers["is_guest"], "customer_id"] = new_ids</pre>
<div class="code-annotations-overlay-container">
     #1 We create an automatic range of values starting from –1 and decreasing.
     <br/>
</div>
</div>
</div>
<div class="readable-text" id="p259">
<p>Now, our guest customers have IDs ranging from –1 to –8300. At this stage, we should have no duplicate records for customers that appeared in multiple datasets. However, we could still have duplicate records for the same customer if they somehow received two different customer IDs in different systems. Customer John Smith, with an ID of 123, might still be the same customer as John Smith, with an ID of 456.</p>
</div>
<div class="readable-text intended-text" id="p260">
<p>Now, we are at the final deduplication phase; we might not be talking about a large percentage of duplicate records. As I mentioned when discussing iteration, in the first pass, we might even choose to ignore the duplication, in which case we already have our first customer data model. However, this is a task where we want to be as accurate as possible and would ideally reduce duplication to zero.</p>
</div>
<div class="readable-text" id="p261">
<h4 class="readable-text-h4 sigil_not_in_toc">Finding and linking duplicate records</h4>
</div>
<div class="readable-text" id="p262">
<p>The most straightforward initial deduplication approach is to say that if two customers have the same values for first name, surname, postcode, and age, they are the same customer. However, this might be a problem if we have a guest account who is the same customer as one already in the CRM system, which we wouldn’t know if we included age in the comparison, as it would be missing for the guest record. Using only first name, surname, and postcode may be a combination good enough to start with. We can write some code now to find all customer IDs whose first name, last name, and postcode match exactly.</p>
</div>
<div class="readable-text intended-text" id="p263">
<p>First, we create an object, <code>duplicates</code>, which is a list of all customer records that are identical to one another in the columns we specified. The <code>keep=False</code> parameter ensures we keep all relevant records, not just the duplicate ones. Having the <code>keep</code> parameter as anything else would drop the first instance and only keep the other rows, the duplicates:</p>
</div>
<div class="browsable-container listing-container" id="p264">
<div class="code-area-container code-area-with-html">
<pre class="code-area">columns_to_consider = ["first_name", "surname", "postcode"]

duplicates = all_customers[all_customers.duplicated(
<span class="">↪</span> subset=columns_to_consider, keep=False)]</pre>
</div>
</div>
<div class="readable-text" id="p265">
<p>We can now create a lookup dictionary where each customer ID is linked to all the other records, which are its duplicates. A sample of this dictionary is shown in figure 3.26:</p>
</div>
<div class="browsable-container listing-container" id="p266">
<div class="code-area-container code-area-with-html">
<pre class="code-area">duplicate_dict = duplicates.groupby(columns_to_consider)['customer_id']
<span class="">↪</span> .apply(list).to_dict()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p267">
<img alt="figure" height="114" src="../Images/3-26.png" width="620"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.26</span> A sample of the duplicate lookup dictionary</h5>
</div>
<div class="readable-text" id="p268">
<p>This dictionary tells us that, for example, there are two customer IDs for Aaliyah Harvey at postcode SO760SX: 22648 and 27397. We can use this dictionary to create a new column, <code>other_customer_ids</code>, where we store this list for accounts that have duplicates. A sample of the resulting data is shown in figure 3.27:</p>
</div>
<div class="browsable-container listing-container" id="p269">
<div class="code-area-container code-area-with-html">
<pre class="code-area">all_customers['other_customer_ids'] = all_customers.apply(
<span class="">↪</span> lambda x: duplicate_dict.get((x['first_name'],
<span class="">↪</span> x['surname'], x['postcode'])), axis=1)<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p270">
<img alt="figure" height="645" src="../Images/3-27.png" width="950"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.27</span> A sample of rows with the new <code>other_customer_ids</code> column</h5>
</div>
<div class="readable-text" id="p271">
<p>Figure 3.27 shows that, for example, Harley Palmer at postcode HR250EJ has two customer records: IDs 31266 and 5411. Strictly speaking, our <code>other_customer_ids</code> column should not be self-referential, so we should remove a customer’s own ID from it. We can create a small function to do that and apply it to the rows with duplicates. Figure 3.28 shows the data after we run the following code. From this, we can notice an instance where a guest account for Max Moore, at postcode M902XX, is linked to a registered customer ID as a duplicate:</p>
</div>
<div class="browsable-container listing-container" id="p272">
<div class="code-area-container code-area-with-html">
<pre class="code-area">def remove_own_record(row):
    ids = list(row["other_customer_ids"])
    ids.remove(row["customer_id"])
    return ids

all_customers.loc[all_customers["other_customer_ids"].notnull(),
<span class="">↪</span> "duplicate_customer_ids"] = ( all_customers[all_customers["other_customer_ids"].notnull()]
<span class="">↪</span> .apply(remove_own_record, axis=1)
)<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p273">
<img alt="figure" height="651" src="../Images/3-28.png" width="950"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.28</span> The new <code>duplicate_customer_ids</code> column</h5>
</div>
<div class="readable-text" id="p274">
<p>As a reminder, what we want our database to contain is one row per customer, and each customer who has duplicate records has this fact marked somehow. The data, as it stands, has multiple rows for the same customer entity, one from the point of view of each, an example of which is shown in figure 3.29. Customers 31266 and 5411 are likely the same entity, and their duplication is recorded from both points of view.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p275">
<img alt="figure" height="351" src="../Images/3-29.png" width="1000"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.29</span> The same customer entity represented as two rows</h5>
</div>
<div class="readable-text" id="p276">
<p>There are two ways to tackle this problem. One is to delete one of the duplicate records entirely, thus reducing the data down to one row per entity. The <code>duplicate_customer_ ids</code> column would still record the fact that this customer entity is referred to by multiple customer IDs, but the rest of the customer data for the duplicate ID would no longer be there. Ideally, each row would be a deduplicated customer record, but another option is to create an <code>is</code>_<code>main</code> flag against rows to identify them this way. The advantage is that all data lineage is preserved, and the downside is that you can’t simply count the rows anymore; you would need to remember to filter on <code>is</code>_<code>main</code> each time. Choosing which representation is better for your data model will again depend on the context in which the data model will be used. Technically, if customers 1480 and 1481 are the same customer, they’re the same customer <em>entity</em> but two distinct <em>records,</em> and my personal preference is to delete as little data as possible, so in the example solution, I’ve used the <code>is_main</code> flag approach.</p>
</div>
<div class="readable-text intended-text" id="p277">
<p>Whichever representation you choose, you still need to decide which customer record is the main one. One method is to simply use the first one you encounter. It is unlikely to make a big difference, but a more principled way would be to use a better metric, like number of transactions, total spending, and so forth, to decide which customer record deserves “main” status.</p>
</div>
<div class="readable-text intended-text" id="p278">
<p>The technical trick to create the flag is to generate a column that gives each duplicate a rank and a row number in the order they are encountered. Anything with a <code>rank</code> of 1 simply becomes a main account. This approach will work for duplicates and unique records, as the first instance of a combination of customer details will always have a <code>rank</code> of 1:</p>
</div>
<div class="browsable-container listing-container" id="p279">
<div class="code-area-container code-area-with-html">
<pre class="code-area">all_customers["rank"]
<span class="">↪</span> = all_customers.groupby(columns_to_consider).cumcount()+1</pre>
</div>
</div>
<div class="readable-text" id="p280">
<p>Figure 3.30 shows the same duplicate pair as in figure 3.24, with the new <code>rank</code> column added.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p281">
<img alt="figure" height="330" src="../Images/3-30.png" width="1000"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.30</span> Our data with a new <code>rank</code> column</h5>
</div>
<div class="readable-text" id="p282">
<p>Now, we have one row per customer record, but to count distinct customer entities, we can create our <code>is_main</code> flag to make the data model more obvious. Once we’ve done this, we no longer need our <code>rank</code> column:</p>
</div>
<div class="browsable-container listing-container" id="p283">
<div class="code-area-container">
<pre class="code-area">all_customers.loc[all_customers["rank"] == 1, "is_main"] = True
all_customers["is_main"] = all_customers["is_main"].fillna(False)
all_customers = all_customers.drop(columns="rank")</pre>
</div>
</div>
<div class="readable-text" id="p284">
<p>Finally, we can count the records:</p>
</div>
<div class="browsable-container listing-container" id="p285">
<div class="code-area-container code-area-with-html">
<pre class="code-area">print(f"Total customers in DB: {len(all_customers)}")
print(f"Of which {len(all_customers[all_customers['is_main']])}
<span class="">↪</span> are unique/main records")</pre>
</div>
</div>
<div class="readable-text" id="p286">
<p>The output shows that out of 35,395 records, 27,394 are unique/main records. This assumes that two customers with the same name and postcode are the same customer and that there are only <em>exact</em> duplicates. To ensure our solution is as accurate as possible, given the data, we can try to match records that are <em>almost</em> identical.</p>
</div>
<div class="readable-text" id="p287">
<h4 class="readable-text-h4 sigil_not_in_toc">Using entity resolution tools to improve deduplication</h4>
</div>
<div class="readable-text" id="p288">
<p>Once our dataset is deduplicated, around the 27,000 mark, we may wish to apply more advanced ideas in future iterations. One is fuzzy string matching to link accounts that differ by a simple typo. Another idea is to investigate whether you could use purchasing patterns to identify identical customers. In the case where two customers match on most columns but, say, differ in their age, you could use additional information like their purchases to decide whether they refer to the same customer. For this example, we’ll identify accounts that are almost identical and see if that makes a difference. When it comes to more complex topics, such as record linkage, there is often a Python package we can use rather than implement any algorithms ourselves. In this case, we will use the Python Record Linkage Toolkit, which implements multiple algorithms for record deduplication and linking efficiently. An important aspect of being an analyst today is identifying when to use the work of others. We don’t always need a deep understanding of the underlying algorithms and implementations before we use external libraries as long as we know what to expect from the output and can investigate problems when they occur.</p>
</div>
<div class="readable-text intended-text" id="p289">
<p>Let’s feed our data into this toolkit, a module called <code>recordlinkage</code>:</p>
</div>
<div class="browsable-container listing-container" id="p290">
<div class="code-area-container">
<pre class="code-area">import recordlinkage</pre>
</div>
</div>
<div class="readable-text" id="p291">
<p>We can effectively follow the basic tutorial from the toolkit’s data deduplication page (<a href="https://mng.bz/nRYa">https://mng.bz/nRYa</a>) and modify it to our needs. First, we index our dataset so that we don’t try to compare every pair of records to each other but tell the code that two records at the same postcode should be tested for duplication. This assumes there are no typos in the postcode, which may not be the case, but it will make our code run much faster as there are fewer comparisons to make. Sometimes, we need to trade off accuracy and performance:</p>
</div>
<div class="browsable-container listing-container" id="p292">
<div class="code-area-container code-area-with-html">
<pre class="code-area">indexer = recordlinkage.Index()    <span class="aframe-location"/> #1
indexer.block('postcode')               <span class="aframe-location"/> #2
candidate_links
<span class="">↪</span> = indexer.index(all_customers.set_index("customer_id"))     <span class="aframe-location"/> #3</pre>
<div class="code-annotations-overlay-container">
     #1 Creates an Index object
     <br/>#2 Marks postcode as a column to use for indexing 
     <br/>#3 Applies the indexing to the data
     <br/>
</div>
</div>
</div>
<div class="readable-text" id="p293">
<p>We set the index to be the <code>customer_id</code> column because that way, our final dataset of matches will retain this name, as we will see. Next, we set up the comparison rules: How should our records be compared against each other? Should matches be exact or allowed to be fuzzy? We can also choose the algorithm with which to make a fuzzy comparison between strings. Here, we use the Damerau–Levenshtein method, which is a measure of <em>edit distance</em>, that is, the number of individual character edits required to get from one string to another. The higher the distance, the less similar the two strings are. Here, you could experiment with different comparison methods and observe the results:</p>
</div>
<div class="browsable-container listing-container" id="p294">
<div class="code-area-container code-area-with-html">
<pre class="code-area">compare = recordlinkage.Compare()             <span class="aframe-location"/> #1
compare.string('first_name', 'first_name', method='damerau_levenshtein',
<span class="">↪</span> threshold=0.85, label="first_name")                               <span class="aframe-location"/> #2
compare.string('surname', 'surname', method='damerau_levenshtein',
<span class="">↪</span> threshold=0.85, label="surname")
compare.exact('postcode', 'postcode', label="postcode")    <span class="aframe-location"/> #3</pre>
<div class="code-annotations-overlay-container">
     #1 Creates a comparison object
     <br/>#2 Names should be fuzzy comparisons; anything over 85% similar is a match.
     <br/>#3 Postcodes should match exactly.
     <br/>
</div>
</div>
</div>
<div class="readable-text" id="p295">
<p>Now, we are ready to use our comparison rules to perform the pairwise comparisons. This creates a DataFrame containing all compared pairs and whether each of our comparison criteria was met. A sample of the output is shown in figure 3.31:</p>
</div>
<div class="browsable-container listing-container" id="p296">
<div class="code-area-container code-area-with-html">
<pre class="code-area">compare_vectors = compare.compute(candidate_links,
<span class="">↪</span> all_customers.set_index("customer_id"))<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p297">
<img alt="figure" height="339" src="../Images/3-31.png" width="730"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.31</span> A sample of the output of our record linkage attempt</h5>
</div>
<div class="readable-text" id="p298">
<p>This sample shows that, for example, customer IDs 7523 and 7466 match on postcode but not on name. We can reduce this data down to only the cases where all comparisons returned a match:</p>
</div>
<div class="browsable-container listing-container" id="p299">
<div class="code-area-container">
<pre class="code-area">matches = compare_vectors[compare_vectors.sum(axis=1) == 3]</pre>
</div>
</div>
<div class="readable-text" id="p300">
<p>The output is the same structure as figure 3.31 but with only perfect matches. Next, we should merge these customer IDs back to the original dataset and see if we’ve improved our record-linking attempts from before:</p>
</div>
<div class="browsable-container listing-container" id="p301">
<div class="code-area-container code-area-with-html">
<pre class="code-area">match_df = pd.DataFrame(           <span class="aframe-location"/> #1
    data=matches.index.tolist(),
    columns=["customer_id_1", "customer_id_2"]
)
matched = all_customers.merge(match_df, left_on="customer_id",
<span class="">↪</span> right_on="customer_id_1", how="left", suffixes=("_customers", "_matches"))<span class="aframe-location"/> #2
matched = matched.merge(match_df, left_on="customer_id",
<span class="">↪</span> right_on="customer_id_2", how="left", suffixes=("_customers", "_matches"))<span class="aframe-location"/> #3</pre>
<div class="code-annotations-overlay-container">
     #1 Creates a new DataFrame containing only the two columns of customer IDs
     <br/>#2 Joins customer data on the first customer ID
     <br/>#3 Joins customer data on the second customer ID
     <br/>
</div>
</div>
</div>
<div class="readable-text" id="p302">
<p>The <code>matches</code> dataset is already deduplicated in the sense that if customers 1 and 2 are duplicates, we do not have two records from each of their perspectives, so joining on both customer IDs means we ensure we have merged the main customer with all the duplicates found by <code>recordlinkage</code>. Figure 3.32 shows the relevant columns of our current merged data. There is an instance where both the <code>duplicate_customer_ids</code> column, created by looking for exact matches, and the new <code>customer_id</code> columns, created by the latest fuzzy matching attempt, agree with each other on records 5411 and 31226.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p303">
<img alt="figure" height="563" src="../Images/3-32.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.32</span> New columns added by merging the linked records back to our customer data model</h5>
</div>
<div class="readable-text" id="p304">
<p>One problem we need to resolve with this new merged data is that records with multiple duplicates are now repeated (e.g., customer ID 30730), as shown in figure 3.33.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p305">
<img alt="figure" height="372" src="../Images/3-33.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.33</span> Three duplicates means three rows of data, which we need to merge into one</h5>
</div>
<div class="readable-text" id="p306">
<p>To merge these rows into a single row, as we have in the <code>duplicate_customer_ids</code> column, we can write a small function to collect all linked customer IDs for a given customer ID. We joined our linked pairs twice, so both the <code>customer_id_1_customers</code> and <code>customer_id_2_matches</code> columns could refer to our customer, and the <code>customer_id_2_ customers</code> and <code>customer_id_1_matches</code> columns could refer to the duplicate ID:</p>
</div>
<div class="browsable-container listing-container" id="p307">
<div class="code-area-container">
<pre class="code-area">def merge_duplicates(group):
    duplicate_list = []
    if np.isnan(group["customer_id_1_matches"].values[0]) == False:
        duplicate_list.extend(group["customer_id_1_matches"].tolist())
    if np.isnan(group["customer_id_2_customers"].values[0]) == False:
        duplicate_list.extend(group["customer_id_2_customers"].tolist())
    if len(duplicate_list) &gt; 0:
        return sorted(list(set([int(x) for x in duplicate_list])))
    return np.nan

linkages = (
    matched
    .groupby("customer_id")
    .apply(merge_duplicates)
    .reset_index(name="linked_duplicates")
)</pre>
</div>
</div>
<div class="readable-text" id="p308">
<p>Our function collects the necessary values from multiple rows into a single list, and we apply this function to each customer ID, in turn, to reduce the dataset down to one row per customer ID again. The output is shown in figure 3.34.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p309">
<img alt="figure" height="311" src="../Images/3-34.png" width="434"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.34</span> A preview of our customer IDs linked to their duplicates</h5>
</div>
<div class="readable-text" id="p310">
<p>We can use the <code>customer_id</code> column to merge this data back to our data model, so we have two sets of duplicates to compare side by side—the one that only uses exact matches and the latest one, which also uses fuzzy string matching:</p>
</div>
<div class="browsable-container listing-container" id="p311">
<div class="code-area-container">
<pre class="code-area">all_customers = all_customers.merge(linkages, on="customer_id", how="left")</pre>
</div>
</div>
<div class="readable-text" id="p312">
<p>Our data now looks like that in figure 3.35.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p313">
<img alt="figure" height="598" src="../Images/3-35.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.35</span> Customer data containing results of two different deduplication methods</h5>
</div>
<div class="readable-text intended-text" id="p314">
<p>Now, we can compare instances where the two columns <code>duplicate_customer_ids</code> and <code>linked_duplicates</code> do not agree. Figure 3.36 shows some of the rows as the output of the following code:</p>
</div>
<div class="browsable-container listing-container" id="p315">
<div class="code-area-container code-area-with-html">
<pre class="code-area">(
    all_customers[(all_customers["duplicate_customer_ids"].notnull())
               &amp; (all_customers["linked_duplicates"].notnull())
               &amp; (all_customers["duplicate_customer_ids"]
<span class="">↪</span> != all_customers["linked_duplicates"])]
)<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p316">
<img alt="figure" height="561" src="../Images/3-36.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.36</span> Instances where the two deduplication methods disagree</h5>
</div>
<div class="readable-text" id="p317">
<p>Let’s inspect one of these cases, shown in figure 3.37. We observe that, for Scarlett Jackson, two additional duplicate records were found by <code>recordlinkage</code>, one of them referring to a Sgarlett Jagkson and another to a Scariett Jackson. All of these are likely to be the same customer, so it makes sense to use the fuzzy method to find all possible duplicates.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p318">
<img alt="figure" height="473" src="../Images/3-37.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.37</span> An instance where the two deduplication methods found different results</h5>
</div>
<div class="readable-text" id="p319">
<p>Ultimately, there are just 13 cases where the two methods disagree, so it seems using <code>recordlinkage</code> only gave us a marginal improvement. However, we now have code for the future that can deduplicate our customer data more intelligently, and the accuracy of our results has improved.</p>
</div>
<div class="readable-text intended-text" id="p320">
<p>Before we move on to the conclusions and recommendations, let’s review the entire analysis process shown in figure 3.38. As with all analyses, your specific path may have diverged from the ones I chose.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p321">
<img alt="figure" height="1261" src="../Images/3-38.png" width="1009"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 3.38</span> The entire analytical process diagram for this project</h5>
</div>
<div class="readable-text intended-text" id="p322">
<p>Now that we have done the work and documented our analysis, let’s move on to the conclusions and recommendations.</p>
</div>
<div class="readable-text" id="p323">
<h3 class="readable-text-h3" id="sigil_toc_id_38"><span class="num-string">3.4.4</span> Conclusions and recommendations</h3>
</div>
<div class="readable-text" id="p324">
<p>Our initial problem statement asked for help counting customers. Our final data model has 35,395 rows corresponding to 27,394 unique customers, which fits our original estimate of “at most 33,000 customers.” However, it is a more precise and therefore more useful number as it is a result of all the analysis we have done so far. This number may be different if you decide to use the results of the <code>recordlinkage</code> library to create a deduplicated data model.</p>
</div>
<div class="readable-text" id="p325">
<p>How do we assess the quality of the final solution? This is hard to quantify as there is no ground truth to check against, but it’s a good idea to get a sense of the different amounts of completeness that exist in the data model.</p>
</div>
<div class="readable-text intended-text" id="p326">
<p>For example, we have around 26,000 customer IDs in the purchase data that have no corresponding records in either customer dataset. This means we have 26,000 customers who have signed up to make a purchase online, but we don’t have their details, and because they weren’t using a guest checkout, we have nothing but a customer ID for them in our final data model. We could choose to drop them as incomplete records, but we would skew our measurement of the size of the customer base. It is better to understand that our data model varies in completeness and is suitable for some tasks—like counting customers—but is not wholly suitable for other tasks, such as customer segmentation.</p>
</div>
<div class="readable-text intended-text" id="p327">
<p>This is a conclusion we should share with our stakeholders when presenting an analysis based on our data models. It is also the kind of uncertainty and ambiguity we need to learn to embrace and communicate.</p>
</div>
<div class="readable-text intended-text" id="p328">
<p>Whatever methods you use, entity resolution is hard to automate 100%. There will always be edge cases that make the data model less than 100% accurate. The value in this task lies in the fact that once you have a “best guess” customer data model, you can be sure that all subsequent analyses, while not perfectly accurate, will be the best you can do given the data that you have. Also, each analysis does not have to start with defining what we mean by a customer since that work has already been done in the data model.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p329">
<h5 class="callout-container-h5 readable-text-h5 sigil_not_in_toc">Activity: Further project ideas with this data</h5>
</div>
<div class="readable-text" id="p330">
<p>E-commerce data is rich with patterns and trends waiting to be discovered. Think about some other research questions that can be answered with this data. Here are some ideas to get you thinking:</p>
</div>
<ul>
<li class="readable-text" id="p331"> Is there a way to deduplicate customers with the same name based on their purchase history? If there are two John Smiths at the same postcode but different customer IDs and different purchasing profiles, does that make it less likely they’re the same person? </li>
<li class="readable-text" id="p332"> Does the data contain any information about households? Perhaps people with the same surname at the same postcode? </li>
<li class="readable-text" id="p333"> Do purchasing behaviors differ between registered customers and people who checked out as guests? </li>
</ul>
</div>
<div class="readable-text" id="p334">
<h2 class="readable-text-h2" id="sigil_toc_id_39"><span class="num-string">3.5</span> Closing thoughts on data modeling</h2>
</div>
<div class="readable-text" id="p335">
<p>In this chapter, you attempted a data modeling task, perhaps without formal data modeling training. If you are interested in this topic more deeply, one place to start is the canonical <em>The Data Warehouse Toolkit </em>by Ralph Kimball and Margy Ross (Wiley, 2013). There are key data modeling concepts such as “star schemas” and “fact tables” to explore to get a deeper understanding of data modeling best practices. A less technical, more business-oriented approach would be to study the Business Event Analysis &amp; Modeling (BEAM) technique. The idea behind it is that the core business entity to focus on is events that happen in the business lifecycle. Your data models would take the form of “customer buys product,” where one record is one instance of a customer buying the product, complete with details about the customer, the product, and the purchasing event. Thinking in terms of events forces you to think about how the business actually works and, ultimately, the process that generated your raw data. A relevant text to explore would be <em>Agile Data Warehouse Design</em> (DecisionOne Press, 2011) by Lawrence Corr and Jim Stagnitto.</p>
</div>
<div class="readable-text intended-text" id="p336">
<p>What is most important is that you consider the purpose, and therefore the necessary details, of your data and get into the habit of creating data models, which abstract away the complexities of the raw data into a more business-relevant form. This skill will come up in most of your analytical projects.</p>
</div>
<div class="readable-text" id="p337">
<h3 class="readable-text-h3" id="sigil_toc_id_40"><span class="num-string">3.5.1</span> Data modeling skills for any project</h3>
</div>
<div class="readable-text" id="p338">
<p>In this chapter, we focused on the creation of new datasets, which we called data models. The specific skills learned for data modeling, which can be used for any problem, include</p>
</div>
<ul>
<li class="readable-text" id="p339"> Exploring multiple datasets to identify a common structure </li>
<li class="readable-text" id="p340"> Reshaping a dataset to adhere to this common structure </li>
<li class="readable-text" id="p341"> Identifying what form a data model should be stored in (e.g., wide or long) </li>
<li class="readable-text" id="p342"> Joining multiple datasets to enhance one with information from another </li>
<li class="readable-text" id="p343"> Cross-referencing two datasets (i.e., finding rows that appear in one but not the other) </li>
<li class="readable-text" id="p344"> Combining smaller data models into a master data model </li>
<li class="readable-text" id="p345"> Using simple methods to deduplicate records </li>
<li class="readable-text" id="p346"> Using advanced methods, such as entity resolution tools, to deduplicate records </li>
</ul>
<div class="readable-text" id="p347">
<h2 class="readable-text-h2" id="sigil_toc_id_41">Summary</h2>
</div>
<ul>
<li class="readable-text" id="p348"> Thinking about the purpose of a dataset helps identify the right structure for your data model. </li>
<li class="readable-text" id="p349"> Data modeling is a crucial analyst skill that should be applied to create clean, defined, deduplicated, restructured, and usable data from raw datasets. </li>
<li class="readable-text" id="p350"> Even basic analytical tasks such as counting are easier when the data is modeled correctly. </li>
<li class="readable-text" id="p351"> Proper data modeling provides easy reuse of the same data to answer additional analytical questions by adjusting the level of granularity or providing wide or long looks at the data. </li>
</ul>
</div></body></html>