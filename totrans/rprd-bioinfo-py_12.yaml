- en: 'Chapter 11\. Finding a Protein Motif: Fetching Data and Using Regular Expressions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve spent quite a bit of time now looking for sequence motifs. As described
    in [the Rosalind MPRT challenge](https://oreil.ly/EAp3i), shared or conserved
    sequences in proteins imply shared functions. In this exercise, I need to identify
    protein sequences that contain the N-glycosylation motif. The input to the program
    is a list of protein IDs that will be used to download the sequences from [the
    UniProt website](https://www.uniprot.org). After demonstrating how to manually
    and programmatically download the data, I’ll show how to find the motif using
    a regular expression and by writing a manual solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to programmatically fetch data from the internet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write a regular expression to find the N-glycosylation motif
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to manually find the N-glycosylation motif
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the code and tests for this program are located in the *11_mprt* directory.
    To begin, copy the first solution to the program `mprt.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspect the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The required positional argument is a file of protein IDs.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The optional download directory name defaults to *fasta*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The input file will list protein IDs, one per line. The protein IDs provided
    in the Rosalind example comprise the first test input file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program using this as the argument. The output of the program lists
    each protein ID containing the N-glycosylation motif and the locations where it
    can be found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After running the preceding command, you should see that the default *fasta*
    directory has been created. Inside you should find four FASTA files. All subsequent
    runs using these protein IDs will be faster as the cached data will be used unless
    you remove the download directory, for instance by running **`make clean`**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the first two lines of each file using the command **`head -2`**.
    The headers for some of the FASTA records are quite long so I’ve broken them here
    so they won’t wrap, but the actual headers must be on a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Run **`make test`** to see the kinds of tests your program should pass. When
    you’re ready, start the program from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should define a positional file argument and an optional download directory
    as the arguments to the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `file` will be a filehandle.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `download_dir` will be a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the `file` argument is a readable text file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `download_dir` is an optional string with a reasonable default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure your program can create the usage, then start by printing the protein
    IDs from the file. Each ID is terminated by a newline, so I’ll use the `str.rstrip()`
    (*right strip*) method to remove any whitespace from the right side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program and make sure you see the protein IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you run **`pytest`**, you should pass the first three tests and fail the
    fourth.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading Sequences Files on the Command Line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next order of business is fetching the protein sequences. The UniProt information
    for each protein is found by substituting the protein ID into the URL *http://www.uniprot.org/uniprot/{uniprot_id}*.
    I’ll change the program to print this string instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Paste the first URL into your web browser and inspect the page. There is a wealth
    of data, all in a human-readable format. Scroll down to the sequence, and you
    should see 203 amino acids. It would be awful to have to parse this page to extract
    the sequence. Luckily, I can append *.fasta* to the URL and get a FASTA file of
    the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before I show you how to download the sequences using Python, I think you should
    know how to do this using command-line tools. From the command line, you can use
    `curl` (which you may need to install) to download the sequence. By default, this
    will print the contents of the file to `STDOUT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You could either redirect this to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'or use the `-o|--output` option to name the output file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `wget` (*web get*, which may also need to be installed) to
    download the sequence file like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Whichever tool you use, you should now have a file called *A2Z669.fasta* with
    the sequence data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: I know this is a book on Python, but it’s worth learning how to write a basic
    `bash` program. Just as some stories can be told in a haiku and others are sprawling
    novels, some tasks are easily expressed using a few shell commands and others
    require thousands of lines of code in a more complex language. Sometimes I can
    write 10 lines of `bash` to do what I need. When I hit about 30 lines of `bash`,
    I generally move to Python or Rust.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how I could automate downloading the proteins with a `bash` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The shebang (`#!`) should use the `env` (environment) to find `bash`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Check that the number of arguments (`$#`) is `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Print a usage statement using the program basename (`$0`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Exit with a nonzero value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Define the output directory to be *fasta*. Note that in `bash` you can have
    no spaces around the `=` for variable assignment.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Create the output directory if it does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Read each line from the file into the `PROT_ID` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the current protein ID so the user knows something is happening.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Construct the URL by using variable interpolation inside double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](assets/10.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-10)'
  prefs: []
  type: TYPE_NORMAL
- en: Construct the output filename by combining the output directory and the protein
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: '[![11](assets/11.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-11)'
  prefs: []
  type: TYPE_NORMAL
- en: Call `wget` with the `-q` (quiet) flag to fetch the URL into the output file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![12](assets/12.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-12)'
  prefs: []
  type: TYPE_NORMAL
- en: This reads each line from the first positional argument (`$1`), which is the
    input filename.
  prefs: []
  type: TYPE_NORMAL
- en: '[![13](assets/13.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-13)'
  prefs: []
  type: TYPE_NORMAL
- en: Let the user know the program has finished and where to find the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can run this like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now there should be a *fasta* directory containing the four FASTA files. One
    way to write the `mprt.py` program would be to fetch all the input files first
    using something like this and then provide the FASTA files as arguments. This
    is a very common pattern in bioinformatics, and writing a shell script like this
    is a great way to document exactly how you retrieved the data for your analysis.
    Be sure you always commit programs like this to your source repository, and consider
    adding a *Makefile* target with a name like *fasta* that is flush-left followed
    by a colon and the command on the next line indented with a single tab character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now you should be able to run **`make fasta`** to automate the process of getting
    your data. By writing the program to accept the input file as an argument rather
    than hard-coding it, I can use this program and multiple *Makefile* targets to
    automate the process of downloading many different datasets. Reproducibility for
    the win.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading Sequences Files with Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I’ll translate the `bash` utility to Python now. As you can see from the preceding
    program, there are several steps involved to fetch each sequence file. I don’t
    want this to be a part of `main()` as it will clutter the program, so I’ll write
    a function for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The function will accept a filehandle for the protein IDs and a download directory
    name, and will return a list of the files that were downloaded or were already
    present. Be sure to add `typing.List` to your imports.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: For now, return an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: 'I want to call it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your program and ensure it compiles and prints nothing. Now add the following
    Python code to fetch the sequences. You’ll need to import `os`, `sys`, and [`requests`](https://oreil.ly/nYSUM),
    a library for making web requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create the output directory if it does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create the directory and any needed parent directories.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the return list of filenames.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Read each protein ID from the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Construct the output filename by combining the output directory plus the protein
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Check if the file already exists.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Construct the URL to the FASTA file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Make a *GET* request for the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-9)'
  prefs: []
  type: TYPE_NORMAL
- en: A response code of 200 indicates success.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](assets/10.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-10)'
  prefs: []
  type: TYPE_NORMAL
- en: Write the text of the response to the output file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![11](assets/11.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-11)'
  prefs: []
  type: TYPE_NORMAL
- en: Print a warning to `STDERR` that the file could not be fetched.
  prefs: []
  type: TYPE_NORMAL
- en: '[![12](assets/12.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-12)'
  prefs: []
  type: TYPE_NORMAL
- en: Skip to the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '[![13](assets/13.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-13)'
  prefs: []
  type: TYPE_NORMAL
- en: Append the file to the return list.
  prefs: []
  type: TYPE_NORMAL
- en: '[![14](assets/14.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-14)'
  prefs: []
  type: TYPE_NORMAL
- en: Return the files that now exist locally.
  prefs: []
  type: TYPE_NORMAL
- en: '`os.makedirs()` is an example of a function that will throw an exception if
    it fails. This might happen due to the user having insufficient permissions to
    create a directory, or because of a disk error. What would be the point in my
    catching and handling such an error? If my program is unable to fix a problem,
    I feel it’s better to let it crash loudly, producing an error code and a stacktrace
    of what went wrong. A human would have to fix the underlying problems before the
    program could work. Catching and mishandling the exception would be far worse
    than letting the program crash.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That logic almost exactly mirrors that of the `bash` program. If you run your
    program again, there should be a *fasta* directory with the four files, and the
    program should print the names of the downloaded files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Writing a Regular Expression to Find the Motif
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Rosalind page notes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow for the presence of its varying forms, a protein motif is represented
    by a shorthand as follows: `[XY]` means *either X or Y* and `{X}` means *any amino
    acid except X*. For example, the N-glycosylation motif is written as `N{P}[ST]{P}`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The [Prosite website](https://oreil.ly/aFwWe) is a database of protein domains,
    families, and functional sites. The [details for the N-glycosylation motif](https://oreil.ly/VrQLl)
    show a similar convention for the *consensus pattern* of `N-{P}-[ST]-{P}`. Both
    patterns are extremely close to the regular expression shown in [Figure 11-1](#fig_11.1).
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1101](assets/mpfb_1101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-1\. A regular expression for the N-glycosylation protein motif
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this regex, the `N` indicates the literal character *N*. The `[ST]` is a
    character class representing either the character *S* or *T*. It’s the same as
    the regex `[GC]` I wrote in [Chapter 5](ch05.html#ch05) to find either *G* or
    *C*. The `[^P]` is a *negated* character class, which means it will match any
    character that is *not P*.
  prefs: []
  type: TYPE_NORMAL
- en: Some people (OK, mostly me) like to represent regexes using the notation of
    finite state machines (FSMs), such as the one shown in [Figure 11-2](#fig_11.2).
    Imagine the pattern entering on the left. It first needs to find the letter *N*
    to proceed to the next step. Next can be any character that is not the letter
    *P*. After that, the graph has two alternate paths through the letters *S* or
    *T*, which must be followed again by a not-*P* character. If the pattern makes
    it to the double circle, the match was successful.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1102](assets/mpfb_1102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-2\. Graphical depiction of an FSM to identify the N-glycosylation
    motif
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In [Chapter 8](ch08.html#ch08), I pointed out a problem when using regular
    expressions to find overlapping text. There are no instances of this in the first
    test file, but another of the datasets I used to solve the problem did have two
    overlapping motifs. Let me demonstrate in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: I’m using the `re.compile()` function here to force the regex engine to parse
    the pattern and create the necessary internal code to do the matching. This is
    similar to how compiled languages like C use source code that humans can edit
    and read into machine code that computers can directly execute. This transformation
    happens once when you use `re.compile()`, whereas functions like `re.search()`
    must recompile the regex on each call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the relevant portion of the protein sequence for *P07204_TRBM_HUMAN*
    that has the pattern starting at both the first and second positions (see [Figure 11-3](#fig_11.3)).
    The `re.findall()` function shows that only the pattern starting at the first
    position is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![mpfb 1103](assets/mpfb_1103.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-3\. This sequence contains two copies of the motif that overlap
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As in [Chapter 8](ch08.html#ch08), the solution is to wrap the regex in a look-ahead
    assertion using `?=(<*pattern*>`), which itself will need to be wrapped in capturing
    parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'I need to know the positions of the matches, which I can get from `re.finditer()`.
    This will return a list of `re.Match` objects, each of which has a `match.start()`
    function that will return the zero-offset index of the match’s starting position.
    I need to add 1 to report the position using 1-based counting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This should be enough for you to solve the rest of the problem. Keep hacking
    until you pass all the tests. Be sure to download a dataset from the Rosalind
    site and verify that your solution gives an answer that passes the test with that,
    too. See if you can also write a version that doesn’t use regular expressions.
    Go back and study the FSM model and think about how you can implement those ideas
    in Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I will present two variations to solve this problem. Both use the same `get_args()`
    and `fetch_fasta()` functions shown previously. The first uses a regular expression
    to find the motif, and the second imagines how to solve the problem in a horrible,
    desolate intellectual wasteland where regular expressions don’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 1: Using a Regular Expression'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is my final solution using a regular expression. Be sure to import
    `re` and `Bio.SeqIO` for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Fetch the sequence files for the protein IDs in the given file. Put the files
    into the indicated download directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Compile the regex for the N-glycosylation motif.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through the files.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the protein ID from the basename of the file minus the file extension.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a lazy iterator to fetch the FASTA sequences from the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Attempt to retrieve the first sequence record from the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Coerce the sequence to a `str`, then try to find all the matches for the motif.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the protein ID.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Print all the matches, correcting to 1-based counting.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this solution, I used the `os.path.basename()` and `os.path.splitext()`
    functions. I often use these, so I want to make sure you understand exactly what
    they do. I first introduced the `os.path.basename()` in [Chapter 2](ch02.html#ch02).
    This function will return the filename from a path that might include directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `os.path.splitext()` function will break a filename into the part before
    the file extension and the extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: File extensions can provide useful metadata about a file. For instance, your
    operating system may know to use Microsoft Excel to open files ending in *.xls*
    or *.xlsx*. There are many conventions for FASTA extensions, including *.fasta*,
    *.fa*, *.fna* (for nucleotides), and *.faa* (for amino acids). You can put whatever
    extension you like on a FASTA file or none at all, but remember that a FASTA file
    is always plain text and needs no special application to view it. Also, just because
    a file has a FASTA-like extension does not necessarily mean it’s a FASTA file.
    *Caveat emptor*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, I don’t need the extension, so I assign it to the variable
    `_` (underscore), which is a convention indicating that I don’t intend to use
    the value. I could also use a list slice to grab the first element from the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Solution 2: Writing a Manual Solution'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If I were writing a program like this for production use, I would use a regular
    expression to find the motif. In this context, though, I wanted to challenge myself
    to find a manual solution. As usual, I want to write a function to encapsulate
    this idea, so I stub it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The function will take some text and return a list of integers where the motif
    can be found in the text.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: For now, return the empty list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The biggest reason to have a function is to write a test where I encode examples
    I expect to match and fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the function does not do something silly like raise an exception when
    given the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This should fail because it has a *P* in the second position.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This should fail because it has a *P* in the fourth position.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This should find the motif at the beginning of the string.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This should find the motif not at the beginning of the string.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-6)'
  prefs: []
  type: TYPE_NORMAL
- en: This should find overlapping motifs at the beginning of the string.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-7)'
  prefs: []
  type: TYPE_NORMAL
- en: This should find overlapping motifs not at the beginning of the string.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-8)'
  prefs: []
  type: TYPE_NORMAL
- en: This is a slightly more complicated pattern containing four copies of the motif.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can add these functions to my `mprt.py` program and I can run `pytest` on
    that source code to ensure that the tests *do* fail as expected. Now I need to
    write the `find_motif()` code that will pass these tests. I decided I would again
    use k-mers, so I will bring in the `find_kmers()` function (and test it, of course,
    but I’ll omit that here) from Chapters [9](ch09.html#ch09) and [10](ch10.html#ch10):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the motif is four characters long, I can use this to find all the 4-mers
    in a sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'I will also need their positions. The `enumerate()` function I introduced in
    [Chapter 8](ch08.html#ch08) will provide both the indexes and values of the items
    in a sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'I can unpack each position and k-mer while iterating like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Take the first k-mer, *NNTS*. One way to test for this pattern is to manually
    check each index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'I know the first two k-mers should match, and this is borne out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'While effective, this is tedious. I would like to hide this code in a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a test I wrote for the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: If a function accepts a string parameter, I always test with an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The next two sequences should match.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This sequence is too long and should be rejected.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This sequence has a *P* in the second position and should be rejected.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This sequence has a *P* in the fourth position and should be rejected.
  prefs: []
  type: TYPE_NORMAL
- en: 'That makes the code much more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'I only want the k-mers that match. I could write this using an `if` expression
    with a guard, which I showed in Chapters [5](ch05.html#ch05) and [6](ch06.html#ch06):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Or using the `starfilter()` function I showed in [Chapter 9](ch09.html#ch09):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'I only want the first elements from each of the tuples, so I could use a `map()`
    to select those:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'For what it’s worth, Haskell uses tuples extensively and includes two handy
    functions in the prelude: `fst()` to get the first element from a 2-tuple, and
    `snd()` to get the second. Be sure to import `typing.Tuple` for this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'With these functions, I can eliminate the `starfilter()` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'But notice a very subtle bug if I try to use the `filter()`/`starmap()` technique
    I’ve shown a couple of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: It only returns the second match. Why is that? It’s due to using `None` as the
    predicate to `filter()`. According to `help(filter)`, “If [the] function is `None`,
    return the items that are true.” In [Chapter 1](ch01.html#ch01), I introduced
    the ideas of truthy and falsey values. The Boolean values `True` and `False` are
    represented by the integer values `1` and `0`, respectively; hence, the actual
    number zero (either `int` or `float`) is technically `False`, which means that
    any nonzero number is not-`False` or, if you will, truthy. Python will evaluate
    many data types in a Boolean context to decide if they are truthy or falsey.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, using `None` as the predicate for `filter()` causes it to remove
    the number `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: I came to Python from Perl and JavaScript, both of which also silently coerce
    values given different contexts, so I was not so surprised by this behavior. If
    you come from a language like Java, C, or Haskell that has stricter types, this
    is probably quite troubling. I often feel that Python is a very powerful language
    if you know exactly what you’re doing at all times. This is a high bar, so it’s
    extremely important when writing Python to use types and tests liberally.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, I felt the list comprehension was the easiest to read. Here’s how
    I wrote my function to manually identify the protein motif:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the positions and values of the 4-mers from the text.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Select those positions for the k-mers matching the motif.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this function is almost identical to how I used the regular expression,
    which is the point of hiding complexities behind functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Try to find any matches to the motif.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The matches are a list of 0-based indexes, so add 1 to each.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Convert the integer values to strings and join them on spaces to print.
  prefs: []
  type: TYPE_NORMAL
- en: Although this works and was fun (your mileage may vary) to write, I would not
    want to use or maintain this code. I hope it gives you a sense of how much work
    the regular expression is doing for us. Regexes allow me to describe *what* I
    want, not *how* to get it.
  prefs: []
  type: TYPE_NORMAL
- en: Going Further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[The Eukaryotic Linear Motifs database example](http://elm.eu.org/elms) provides
    regexes to find motifs that define functional sites in proteins. Write a program
    to search for any occurrence of any pattern in a given set of FASTA files.'
  prefs: []
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Key points from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use command-line utilities like `curl` and `wget` to fetch data from
    the internet. Sometimes it makes sense to write a shell script for such tasks,
    and sometimes it’s better to encode this using a language like Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A regular expression can find the N-glycosylation motif, but it’s necessary
    to wrap it in a look-ahead assertion and capturing parentheses to find overlapping
    matches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s possible to manually find the N-glycosylation motif, but it’s not easy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `os.path.splitext()` function is useful when you need to separate a filename
    from the extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File extensions are conventions and may be unreliable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
