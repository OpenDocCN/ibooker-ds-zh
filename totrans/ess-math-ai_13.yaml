- en: Chapter 13\. Artificial Intelligence and Partial Differential Equations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。人工智能和偏微分方程
- en: 'The first scene in Top Gun Maverick (2022 movie) shows Maverick (Tom Cruise)
    manning an experimental military aircraft and pushing it to 10 times the speed
    of sound (10 Mach) before losing its stability at around 10.2 Mach. The fastest
    nonfictional manned aircraft so far can reach 6.7 Mach ([Figure 13-1](#Fig_fastest_aircraft)).
    Real speed or unreal (yet), it is mesmerizing to watch physics, math, and engineering
    come together to put these planes in the air, especially with their spectacular
    midair manoeuvering. These are few of the partial differential equations (PDEs)
    that come to mind while watching Maverick’s awesome dogfight and 10 Mach scenes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 《壮志凌云2》（2022年电影）中的第一场景展示了Maverick（汤姆·克鲁斯）操纵一架实验军用飞机，并将其推向声速的10倍（10马赫），然后在大约10.2马赫时失去稳定性。到目前为止，最快的非虚构有人飞行器可以达到6.7马赫（[图13-1](#Fig_fastest_aircraft)）。无论是真实的速度还是虚拟的（尚未实现），看到物理学、数学和工程学共同将这些飞机放入空中，特别是它们壮观的空中机动，都是令人着迷的。在观看Maverick令人敬畏的空战和10马赫的场景时，会想起一些偏微分方程（PDEs）：
- en: '![250](assets/emai_1301.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![250](assets/emai_1301.png)'
- en: Figure 13-1\. Fastest manned aircrafts ever made ([*image source*](https://migflug.com/jetflights/the-10-fastest-aircraft-in-the-world/)
    or need an uncopy righted image similar to this one)
  id: totrans-3
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-1。有史以来最快的有人飞行器（[*图片来源*](https://migflug.com/jetflights/the-10-fastest-aircraft-in-the-world/)或需要类似于这个的无版权图片）
- en: '**The wave equation for wave propagation**: Think of the speed of sound, the
    propagation of a sound wave in the air, and the variations of the sound of speed
    at different altitudes due to the variations in the temperature and density of
    air.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**波动传播的波动方程**：想象声速、空气中声波的传播，以及由于空气温度和密度的变化而导致不同高度声速的变化。'
- en: '**Navier Stokes equations for fluid dynamics**: Think of the fluid flow, air
    tunnels, and turbulence.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**Navier Stokes方程用于流体动力学**：想象流体流动、气流隧道和湍流。'
- en: '**The G-equation for combustion**: Think of the combustion in the aircraft’s
    engine and the flames coming out of the aircraft’s exhausts.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**燃烧的G方程**：想象飞机发动机中的燃烧和飞机尾部喷出的火焰。'
- en: '**Material elasticity equations**: Think of the aircraft wing panel, the lift
    force, the buckling of the wing panel (the process of out-of-stress-plane movement
    which happens under compression [Figure 13-2](#Fig_buckling)) caused by loading,
    which in turn reduces the load carrying capabilities of the wing. When load carrying
    capabilities fall below the design limits, failure happens.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**材料弹性方程**：想象飞机机翼板、升力、机翼板的屈曲（在压缩下发生的应力平面外移动的过程[图13-2](#Fig_buckling)），由于负载引起，这反过来降低了机翼的承载能力。当承载能力低于设计极限时，故障就会发生。'
- en: '![250](assets/emai_1302.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![250](assets/emai_1302.png)'
- en: Figure 13-2\. Buckling in an aircraft ([*imagesource*](https://c1.staticflickr.com/8/7605/27273400154_3fa64e11bd_b.jpg)).
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-2。飞机的屈曲（[*图片来源*](https://c1.staticflickr.com/8/7605/27273400154_3fa64e11bd_b.jpg)）。
- en: 'PDE simulations also come to mind: Think of the flight path simulation and
    the crew chatting with Maverick as they watch his flight unfold in real time on
    their computer screens.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: PDE模拟也会让人想起：想象一下飞行路径模拟，机组人员在计算机屏幕上实时观看Maverick的飞行过程并与他交谈。
- en: The list goes on. Are we claiming here that we made aircrafts fly because we
    wrote down and solved PDEs? No. Aviation museums tell the story of the Wright
    Brothers, *their experiments*, and the evolution of aviation industry. Science
    and experimentation go hand in hand. What we want to claim instead is that we
    can invent, improve, and optimize all kinds of designs because of differential
    equations and math.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 清单还在继续。我们在这里声称我们之所以让飞机飞行是因为我们写下并解决了PDE吗？不是。航空博物馆讲述了莱特兄弟的故事、*他们的实验*以及航空工业的发展。科学和实验是相辅相成的。我们想要宣称的是，我们可以发明、改进和优化各种设计，因为有了微分方程和数学。
- en: What Is A Partial Differential Equation?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是偏微分方程？
- en: A PDE is an equation, which means a left hand side equals to a right hand side,
    that involves a function of several variables along with any of its partial derivatives.
    A partial derivative of a function with respect to a certain variable measures
    the rate of change of the function with respect to that variable. Ordinary differential
    equations (ODEs) are those that involve functions of only one variable, such as
    only time, only space, etc… (as opposed to several variables) and their derivatives.
    A dynamic system is a greatly important ODE, describing the evolution in time
    of the state of a system that we care for, such as a system of particles, or the
    state of a customer in a business setting. The ODE involves one derivative in
    time of the state of the system, and the dynamics are prescribed as a function
    of the system state, system physical parameters, and time. The ODE looks like
    <math alttext="StartFraction d ModifyingAbove x With right-arrow left-parenthesis
    t right-parenthesis Over d t EndFraction equals f left-parenthesis ModifyingAbove
    x With right-arrow left-parenthesis t right-parenthesis comma a left-parenthesis
    t right-parenthesis comma t right-parenthesis"><mrow><mfrac><mrow><mi>d</mi><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mrow><mo>(</mo><mi>t</mi><mo>)</mo></mrow></mrow>
    <mrow><mi>d</mi><mi>t</mi></mrow></mfrac> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math> . We will visit dynamic
    systems multiple times in this chapter. Most of the time, if we able to transform
    a PDE into a system of ODEs, or maybe into a dynamical system, it is more or less
    solved.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: PDE是一个等式，意味着左边等于右边，涉及到一个多变量函数以及它的任何偏导数。函数关于某个变量的偏导数衡量了函数相对于该变量的变化率。普通微分方程（ODEs）是那些只涉及一个变量的函数的方程，比如只有时间、只有空间等（与多个变量相反）及其导数。动态系统是一个非常重要的ODE，描述了我们关心的系统状态随时间的演变，比如一个粒子系统或商业环境中客户的状态。ODE涉及系统状态的时间导数，动态规定为系统状态、系统物理参数和时间的函数。ODE看起来像
    <math alttext="StartFraction d ModifyingAbove x With right-arrow left-parenthesis
    t right-parenthesis Over d t EndFraction equals f left-parenthesis ModifyingAbove
    x With right-arrow left-parenthesis t right-parenthesis comma a left-parenthesis
    t right-parenthesis comma t right-parenthesis"><mrow><mfrac><mrow><mi>d</mi><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mrow><mo>(</mo><mi>t</mi><mo>)</mo></mrow></mrow>
    <mrow><mi>d</mi><mi>t</mi></mrow></mfrac> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mrow>
    <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math> 。我们将在本章多次讨论动态系统。大多数情况下，如果我们能够将PDE转化为ODE系统，或者甚至转化为动力系统，那么问题基本上就解决了。
- en: Nature gave us neither the deterministic functions nor the joint probability
    distributions that it uses to produce the world that we observe around us and
    can accurately measure. Until now, it has kept those secret. It did, however,
    give us ways to measure, assess, or make laws about *how things change* relative
    to each other, which is exactly what partial differential equations represent.
    Because *how things change* are nothing but derivatives.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 自然没有给我们确定性函数，也没有给我们用来产生我们周围观察到的世界并能准确测量的联合概率分布。到目前为止，它一直保守这些秘密。然而，它确实给了我们一些方法来测量、评估或制定关于*事物如何相对于彼此变化*的法则，这正是偏微分方程所代表的。因为*事物如何变化*实际上就是导数。
- en: The goal of solving a PDE is to undo the differential operator so that we can
    recover the function without any derivatives. So we search for an exact or an
    approximate inverse (or pseudo inverse) of the differential operator that the
    PDE represents. Integrals undo derivatives so solution represenations of PDEs
    often involve the integrals of some kernel functions against the input data of
    a PDE (its parameters, initial and/or boundary conditions). We will elaborate
    on this as the chapter evolves.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 解决偏微分方程的目标是撤销微分算子，以便我们可以恢复函数而不带有任何导数。因此，我们寻找偏微分方程代表的微分算子的精确或近似逆（或伪逆）。积分可以撤销导数，因此偏微分方程的解表示通常涉及一些核函数对PDE的输入数据（其参数、初始和/或边界条件）的积分。随着本章的发展，我们将详细阐述这一点。
- en: People usually classify ODEs and PDEs into *types*. My take on this is that
    we should not confuse ourselves with *classifications* unless we happen to be
    personally working with these special ODEs or PDEs and the solutions of these
    happen to have a direct and immediate impact on the future of humanity. When in
    this chapter you encounter a certain type, such as nonlinear parabolic, or backward
    stochastic, accept the name then move directly to understanding the point that
    I am trying to make. Don’t even try to google these terms. It will be similar
    to when you google your symptoms and the internet tells you that you will die
    tomorrow. Consider yourself warned.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 人们通常将ODE和PDE分类为*类型*。我对此的看法是，除非我们恰好在个人工作中处理这些特殊的ODE或PDE，并且这些的解对人类的未来有直接和立即的影响，否则我们不应该让自己困惑于*分类*。当你在本章中遇到某种类型，比如非线性抛物线或反向随机，接受这个名称然后直接理解我试图表达的观点。甚至不要尝试谷歌这些术语。这就像你谷歌你的症状，互联网告诉你明天就会死一样。自己小心。
- en: Modeling With Differential Equations
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用微分方程建模
- en: 'Differential equations model countless phenomena in the real world, from air
    turbulence to the motions of galaxies to the behavior of materials at the nanoscale
    to pricing financial instruments to games with adversaries and multiple players
    to population mobility and growth. Typical courses on PDEs skip the modeling step,
    so the PDEs that we end up studying seem to come out of the blue, but that is
    not the case. Where PDEs come from is as important as trying to analyze them and
    solve them. Usually PDEs express some conservation laws, such as conservation
    of energy, mass, momentum, *etc.*, as they relate to our particular application.
    Many PDEs are an expression of a conservation statement that looks like:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 微分方程模拟了现实世界中无数的现象，从空气湍流到星系的运动，再到纳米尺度材料的行为，再到金融工具的定价，再到与对手和多个玩家的游戏，再到人口流动和增长。典型的偏微分方程课程跳过了建模步骤，因此我们最终研究的偏微分方程似乎是突如其来的，但事实并非如此。偏微分方程的来源和分析解决它们一样重要。通常，偏微分方程表达了一些守恒定律，比如能量、质量、动量等与我们特定应用相关的守恒定律。许多偏微分方程是守恒陈述的表达，看起来像：
- en: '*rate of change of a quantity in time= gains- losses*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*时间内数量的变化率=增益-损失*'
- en: Now when we have a bounded domain, the PDE works in the *interior* of the domain,
    but we need to accompany it with *boundary conditions* that tell us exactly what
    is happening at the boundary of the domain. If the domain is unbounded, then we
    need *far field conditions* that tell us what is happening as <math alttext="x
    right-arrow normal infinity"><mrow><mi>x</mi> <mo>→</mo> <mi>∞</mi></mrow></math>
    . We write these conditions using limits notation. If the PDE has derivatives
    in time then we need some initial time conditions, or end time conditions. How
    many of these conditions we need depends on the order of the PDE. Think of these
    as how many equations we need to solve for how many unknowns. The unknowns are
    the *integration constants* of the PDEs. When we solve a PDE, we seek information
    about the function given information about its derivatives. To get rid of these
    derivatives and recover the function, we must *integrate* the PDE, getting integration
    constants along the way. We need the boundary and/or far field conditions to solve
    for these constants.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们有一个有界域时，偏微分方程在域的*内部*起作用，但我们需要伴随*边界条件*，告诉我们域的边界发生了什么。如果域是无界的，那么我们需要*远场条件*，告诉我们当<math
    alttext="x right-arrow normal infinity"><mrow><mi>x</mi> <mo>→</mo> <mi>∞</mi></mrow></math>时发生了什么。我们使用极限符号来写这些条件。如果偏微分方程在时间上有导数，那么我们需要一些初始时间条件或结束时间条件。我们需要多少这些条件取决于偏微分方程的阶数。将这些视为我们需要解决多少方程以解决多少未知数。未知数是偏微分方程的*积分常数*。当我们解决偏微分方程时，我们寻求有关函数的信息，给出其导数的信息。为了消除这些导数并恢复函数，我们必须*积分*偏微分方程，沿途获得积分常数。我们需要边界和/或远场条件来解决这些常数。
- en: Models At Different Scales
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同尺度的模型
- en: Realistic models that mimic nature faithfully need to account for all the important
    variables along with their interactions, sometimes at varying scales of space
    and time. There is some work that goes into writing the equations for the mathematical
    models. Once formulated, they are elegant, condensing a whole wealth of information
    into few lines of equations. These equations involve functions, their derivatives,
    and the model’s parameters, and are usually harder to solve than to formulate.
    Moreover, if two models describe the same phenomenon at different scales, say
    one on the atomistic scale (rapidly wiggling molecules) and another at a bigger
    scale, say at the microscopic or at the macro scales (the one we observe), then
    the two models’ equations would look very different, and they may even be relying
    on physical laws from different fields of science. Think for example about describing
    the motion of gases at the molecular level (particle velocity, position, forces
    acting on it, *etc.*) and how to relate that to the thermodynamics of the gaseous
    system observed at the macroscopic scale. Or think of the ways atoms bond together
    to form crystalline structures, and how those structures translate into material
    properties such as conductivity, permeability, brittleness, *etc.*. The natural
    question is then, can we reconcile such models when each operates and is succesfull
    to some degree at a different scale? More precisely, if we take the limit of one
    model to the regime of the other, would we get the same thing? These are all the
    types of questions that analysts address. Reconciling different scale models validates
    them and unifies different areas of math and science.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 忠实模拟自然的现实模型需要考虑所有重要变量以及它们的相互作用，有时在不同尺度的空间和时间。编写数学模型的方程需要一些工作。一旦制定，它们就是优雅的，将大量信息压缩成几行方程。这些方程涉及函数、它们的导数和模型的参数，通常比制定方程更难解决。此外，如果两个模型描述不同尺度上相同的现象，比如一个在原子尺度上（快速摆动的分子）和另一个在更大尺度上，比如在微观或宏观尺度（我们观察到的尺度），那么这两个模型的方程看起来会非常不同，甚至可能依赖于不同科学领域的物理定律。例如，想象一下描述分子水平上气体运动（粒子速度、位置、作用于其上的力等）以及如何将其与在宏观尺度观察到的气态系统的热力学联系起来。或者想想原子如何结合形成晶体结构，以及这些结构如何转化为材料性质，比如导电性、渗透性、脆性等。自然的问题是，我们是否可以在不同尺度上成功地调和这样的模型？更准确地说，如果我们将一个模型的极限取到另一个模型的范围，我们会得到相同的结果吗？这些都是分析师要解决的问题类型。调和不同尺度模型验证了它们，并统一了数学和科学的不同领域。
- en: The Parameters of a PDE
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 偏微分方程的参数
- en: The PDEs that we write down for a model usually involve parameters. These parameters
    have to do with the properties of the physical system that we are modeling. For
    example, for the heat equation
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为一个模型写下的偏微分方程通常涉及参数。这些参数与我们建模的物理系统的属性有关。例如，对于热方程
- en: <math alttext="dollar-sign u Subscript t Baseline left-parenthesis ModifyingAbove
    x With right-arrow comma t right-parenthesis equals alpha normal upper Delta u
    left-parenthesis ModifyingAbove x With right-arrow comma t right-parenthesis comma
    dollar-sign"><mrow><msub><mi>u</mi> <mi>t</mi></msub> <mrow><mo>(</mo> <mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>α</mi> <mi>Δ</mi> <mi>u</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo></mrow></math>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign u Subscript t Baseline left-parenthesis ModifyingAbove
    x With right-arrow comma t right-parenthesis equals alpha normal upper Delta u
    left-parenthesis ModifyingAbove x With right-arrow comma t right-parenthesis comma
    dollar-sign"><mrow><msub><mi>u</mi> <mi>t</mi></msub> <mrow><mo>(</mo> <mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>α</mi> <mi>Δ</mi> <mi>u</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo></mrow></math>
- en: the parameter <math alttext="alpha"><mi>α</mi></math> is the *diffusion coefficient*,
    which is a physical constant depending on the properties the diffusing substance
    and the properties of the medium it is diffusing into. We usually get these from
    reference tables obtained from experiments. Their values are very important for
    engineering purposes. When our equations model reality, we must use parameter
    values that are derived from this real experimental or observational data. But
    experimental and observational data are usually noisy, have missing values, unexplained
    outliers, and all kinds of rough seas for mathematical models. Many times we don’t
    even have experimental values for the parameters that are in our equations. The
    experiments can be expensive (think Large Hadron Collider) or even impossible.
    So one must *learn* the parameter values using indirect ways, based on accessible
    combinations of experimental, observational, and computer simulated values of
    some other variables. Historically, many of these parameter values were *hand
    tuned* in order fit some desired outcome, which is not good! We should have clear
    justifications for the choices of the parameter values that go into simulations.
    We will see how machine learning helps PDEs here in learning parameter values
    from data.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 参数<math alttext="alpha"><mi>α</mi></math>是*扩散系数*，这是一个物理常数，取决于扩散物质的性质和其扩散到的介质的性质。我们通常从实验获得的参考表中获取这些值。它们对工程目的非常重要。当我们的方程模拟现实时，我们必须使用从这些真实实验或观测数据中导出的参数值。但实验和观测数据通常存在噪声，缺失值，未解释的异常值，以及各种数学模型的困难。很多时候，我们甚至没有我们方程中的参数的实验值。实验可能很昂贵（想想大型强子对撞机）甚至不可能。因此，我们必须使用间接方式*学习*参数值，基于实验、观测和计算机模拟值的可访问组合的一些其他变量。从历史上看，许多这些参数值是*手动调整*的，以适应某些期望的结果，这是不好的！我们应该对进入模拟的参数值的选择有明确的理由。我们将看到机器学习如何帮助PDEs在从数据中学习参数值。
- en: Changing One Thing in a PDE can be a Big Deal
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在PDE中改变一件事可能是一件大事
- en: 'If you had a partial differential equations (PDEs) class in college, think
    back to the simplest equation that you studied, perhaps the heat diffusion equation
    on a rod such as those in [Figure 13-3](#Fig_steel_rod). If you did not study
    PDEs, do not worry about its details. The formula of the heat equation is:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在大学里上过偏微分方程（PDEs）课程，请回想一下你学过的最简单的方程，也许是在一个类似[图13-3](#Fig_steel_rod)中的棒上的热扩散方程。如果你没有学过PDEs，不要担心它的细节。热方程的公式是：
- en: <math alttext="dollar-sign u Subscript t Baseline left-parenthesis x comma t
    right-parenthesis equals alpha normal upper Delta u left-parenthesis x comma t
    right-parenthesis period dollar-sign"><mrow><msub><mi>u</mi> <mi>t</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mi>α</mi> <mi>Δ</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>.</mo></mrow></math>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign u Subscript t Baseline left-parenthesis x comma t
    right-parenthesis equals alpha normal upper Delta u left-parenthesis x comma t
    right-parenthesis period dollar-sign"><mrow><msub><mi>u</mi> <mi>t</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mi>α</mi> <mi>Δ</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>.</mo></mrow></math>
- en: Here, <math alttext="u left-parenthesis x comma t right-parenthesis"><mrow><mi>u</mi>
    <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow></math> measures
    the temperature at the point *x* in the rod and at time *t*, and the operator
    <math alttext="normal upper Delta"><mi>Δ</mi></math> is the second derivative
    in *x* (so <math alttext="normal upper Delta u left-parenthesis x comma t right-parenthesis
    equals u Subscript x x Baseline left-parenthesis x comma t right-parenthesis"><mrow><mi>Δ</mi>
    <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mi>u</mi> <mrow><mi>x</mi><mi>x</mi></mrow></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math> ), since a rod
    is only one dimensional if we ignore its thickness. In higher dimensions, the
    operator <math alttext="normal upper Delta"><mi>Δ</mi></math> is the sum of second
    derivatives in each of the dimensions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，<math alttext="u left-parenthesis x comma t right-parenthesis"><mrow><mi>u</mi>
    <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow></math>表示棒上点*x*处和时间*t*处的温度，操作符<math
    alttext="normal upper Delta"><mi>Δ</mi></math>是*x*的二阶导数（所以<math alttext="normal
    upper Delta u left-parenthesis x comma t right-parenthesis equals u Subscript
    x x Baseline left-parenthesis x comma t right-parenthesis"><mrow><mi>Δ</mi> <mi>u</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mi>u</mi> <mrow><mi>x</mi><mi>x</mi></mrow></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>），因为棒只有一维，如果忽略其厚度。在更高维度中，操作符<math
    alttext="normal upper Delta"><mi>Δ</mi></math>是每个维度中二阶导数的总和。
- en: 'Now let’s change the domain from a rod to a weird shaped plate: Not a square
    or a circle or ellipse, but something irregular, for example, compare [Figure 13-3](#Fig_steel_rod)
    with [Figure 13-4](#Fig_irregular_plate). The formula for the true solution which
    we learn in an introductory PDE class, which works for the rod, does not work
    for the weird plate anymore. This gets even worse. We do not only lose access
    to the analytical solution by changing the domain: When we try to solve the differential
    equation with the new domain numerically, the new geometry suddenly complicates
    matters. Now we have to find a discrete mesh that accurately portrays the shape
    of the new domain with all its details, then we have to compute a numerical solution
    on top of that mesh that satisfies the equation in the interior of the domain,
    and satisfies the boundary conditions along the weird looking boundary.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将域从一个棒改变成一个奇怪形状的板：不是正方形、圆形或椭圆形，而是一些不规则的形状，例如，比较[图13-3](#Fig_steel_rod)和[图13-4](#Fig_irregular_plate)。我们在初级PDE课程中学到的适用于棒的真实解的公式，在奇怪的板上不再适用。情况变得更糟。我们不仅通过改变域失去了对解析解的访问：当我们尝试用新域数值解微分方程时，新的几何形状突然使事情复杂化。现在我们必须找到一个离散网格，准确地描绘出新域的形状及其所有细节，然后我们必须在该网格上计算一个数值解，使其满足域内的方程，并满足沿着看起来奇怪的边界的边界条件。
- en: '![A](assets/emai_1303.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![A](assets/emai_1303.png)'
- en: Figure 13-3\. Studying heat diffusion on a rod is easy (for people who studied
    PDEs) both analytically and numerically ([image source](https://commons.wikimedia.org/wiki/File:Steel-Dowel-Pins.jpg))
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-3。在棒上研究热扩散对于那些学过PDEs的人来说是容易的，无论是在分析上还是在数值上（[图片来源](https://commons.wikimedia.org/wiki/File:Steel-Dowel-Pins.jpg)）。
- en: '![B](assets/emai_1304.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![B](assets/emai_1304.png)'
- en: Figure 13-4\. Studying heat diffusion on an irregular geometry is not as easy
    ([image source](https://www.theapollobox.com/product/sku590002/irregular-shaped-ceramic-plate)).
  id: totrans-35
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-4。研究不规则几何形状上的热扩散并不容易（[图片来源](https://www.theapollobox.com/product/sku590002/irregular-shaped-ceramic-plate)）。
- en: 'This is normal in PDEs: Change one tiny thing and suddenly all the mathematical
    methods that we learned may not apply anymore. Such changes include:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这在PDE中很正常：改变一点微小的东西，突然我们学到的所有数学方法可能就不再适用了。这些变化包括：
- en: Change the shape of the domain,
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变域的形状，
- en: change the types of the boundary conditions,
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变边界条件的类型，
- en: introduce a space or time dependence in the coefficients (the parameters),
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在系数中引入空间或时间依赖性（参数），
- en: introduce nonlinearities,
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入非线性，
- en: introduce terms with more derivatives (higher order), *etc.*
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入更多导数项（高阶）,*等等*
- en: introduce more variables (higher dimension)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入更多变量（更高维度）
- en: This frustrating aspect turns off many students from specializing in PDEs (no
    one wants to be an expert at only one equation, which could be very removed from
    modeling reality to start with). We don’t want to be turned off. We want to see
    the big picture. Natural phenomena are wonderfully varied so we have to accept
    the variations in the PDEs and their solution methods as part of our quest to
    understand and predict nature. Moreover, PDEs is a large and old field. A lot
    of progress has been made on unifying methods for many families of both linear
    and non-linear partial differential equations, and a lot of powerful analysis
    has been discovered along the way. The status quo is that PDEs is a very useful
    field that does not have, and might never have, a unifying theory.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这令人沮丧的一面使许多学生不愿专攻PDE（没有人想成为只擅长一种方程的专家，这种方程可能与现实建模相去甚远）。我们不想被打消积极性。我们想看到全局图景。自然现象非常多样化，因此我们必须接受PDE及其解决方法的变化作为我们理解和预测自然的探索的一部分。此外，PDE是一个庞大而古老的领域。已经在统一许多线性和非线性偏微分方程家族的方法上取得了许多进展，并且在这一过程中发现了许多强大的分析。现状是PDE是一个非常有用的领域，它没有，也可能永远不会有，一个统一的理论。
- en: In general, nonlinear PDEs are more difficult than linear PDEs, higher order
    PDEs are more difficult than lower order ones, higher dimensional PDEs are more
    difficult than lower dimensional ones, systems of PDEs are more difficult than
    single PDEs, we cannot write explicit formulas for solutions for the majority
    of PDEs out there, and many PDEs are only satisfied in *weak* forms. Many PDEs
    have solutions that develop singularities as time evolves (think the wave equation
    and shock waves). Mathematicians who develop PDE theory spend their time proving
    *existence* of solutions of PDEs, and trying to understand the *regularity* of
    these solutions, which means how nice they are in terms of actually possessing
    the derivatives that are involved in the PDE. These use a lot of advanced calculus
    methods, looking for estimates on integrals (inequalities for upper and lower
    bounds).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，非线性PDE比线性PDE更困难，高阶PDE比低阶PDE更困难，高维PDE比低维PDE更困难，PDE系统比单个PDE更困难，我们无法为大多数PDE编写显式解的公式，许多PDE只在*弱*形式下满足。许多PDE的解随时间演变会产生奇点（想想波动方程和激波）。开发PDE理论的数学家花费时间证明PDE的解的*存在*，并试图理解这些解的*正则性*，即它们在实际拥有涉及PDE的导数方面有多好。这些使用了许多高级微积分方法，寻找积分的估计（上下界的不等式）。
- en: Can AI Step In?
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AI可以介入吗？
- en: Now wouldn’t it be great if we had methods that account for variations in the
    PDE, the geometry of the domain, the boundary conditions, and the parameter ranges,
    similar to the actual physical problems? Many sectors of the industry and areas
    of science have their eyes on AI and deep learning to address their long standing
    problems, or shed new lights on them. The past decade’s astronomical advancement
    in computing solutions of very high dimensional problems has the potential to
    transform many fields held down by the curse of dimensionality. Such a transformation
    would be a sea change for PDEs and in turn to humanity as a whole, because of
    the sheer amount of science that is unlocked by PDEs and their solutions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有方法可以考虑PDE的变化、域的几何形状、边界条件和参数范围的变化，类似于实际的物理问题，那不是很棒吗？许多行业和科学领域都将目光投向AI和深度学习，以解决长期存在的问题或为其带来新的启示。过去十年在计算非常高维问题的解决方案方面取得的巨大进步有潜力改变许多被维度诅咒束缚的领域。这样的转变将对PDE和整个人类产生深远影响，因为PDE及其解锁的大量科学。
- en: 'For the rest of this chapter, we highlight the hurdles that the differential
    equations community encounters with the traditional approaches to finding solutions
    to their PDEs, and with fitting real and noisy data into their models. We then
    illustrate how machine learning is stepping in to help bypass or alleviate these
    difficulties. We also distinguish two questions:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们强调微分方程社区在传统方法中遇到的障碍，以及如何将真实和嘈杂的数据拟合到他们的模型中。然后我们说明了机器学习如何帮助绕过或减轻这些困难。我们还区分了两个问题：
- en: What can AI do for PDEs?
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AI对PDE有什么作用？
- en: What can PDEs do for AI?
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PDEs对AI有什么作用？
- en: We need to make sure that the machine learning hallmarks of *training function,
    loss function, and optimization* settings are clear when serving PDEs, along with
    the labels or targets for supervised learning. Fitting the well established field
    of PDEs into a machine learning setting is not super straightforward. Ideally,
    we need to establish a map from a PDE to its solution. This requires some pausing
    and thinking.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在为PDE提供服务时，我们需要确保机器学习的标志性特征——*训练函数、损失函数和优化*设置清晰，以及监督学习的标签或目标。将PDE的成熟领域融入到机器学习环境中并不是非常直接。理想情况下，我们需要建立从PDE到其解决方案的映射。这需要一些暂停和思考。
- en: Numerical Solutions Are Very Valuable
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值解非常有价值
- en: Writing a mathematical model that describes a natural phenomenon, in the form
    of equations describing how the involved variables interact with each other, is
    only a first step. We need to solve these equations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 编写描述自然现象的数学模型，以方程描述涉及变量如何相互作用，只是第一步。我们需要解决这些方程。
- en: Analytical solutions are harder than numerical solutions, since the more the
    model mimics nature the more complex the equations tend to be. Even when analytical
    methods cannot provide formulas for the solutions, they still provide valuable
    insights into their important properties. Numerical solutions are easier than
    analytical solutions, because they involve discretizing the continuous equations,
    moving us to from the realm of continuous functions to the realm of discrete numbers,
    or from infinite dimensional function spaces to finite dimensional vector spaces
    (linear algebra), which our machines are built to compute. Numerical solutions
    provide invaluable insights into the true analytical solutions of the models,
    and are easy to test against experimental observations, when available. They are
    also easy to tune so they are great aids for experimental design.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 分析解比数值解更难，因为模型越接近自然，方程就越复杂。即使分析方法无法为解提供公式，它们仍然为解的重要属性提供了宝贵的见解。数值解比分析解更容易，因为它们涉及将连续方程离散化，将我们从连续函数的领域转移到离散数字的领域，或者从无限维函数空间转移到有限维向量空间（线性代数），这是我们的计算机建立的。数值解为模型的真实分析解提供了宝贵的见解，并且在可用时易于与实验观察进行测试。它们也易于调整，因此对实验设计是很好的辅助。
- en: We can devise numerical solutions at any scale, but the curse of dimensionality
    haunts us whe we try to implement and compute our numerical schemes. In many situations,
    for a numerical simulation to mimic even one second of the natural evolution of
    a system requires a tremendous amount of computational power, so a lot of dimension
    reductions and simplification assumptions must happen, which moves us even farther
    from having a good approximation of the true solutions. The sad part is that this
    is the norm rather than the exception.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何尺度上设计数值解，但当我们尝试实施和计算我们的数值方案时，维度的诅咒会困扰我们。在许多情况下，为了模拟系统自然演化的一秒钟，需要大量的计算能力，因此必须进行大量的维度降低和简化假设，这使我们离真实解的良好近似更远。令人沮丧的是，这已经成为常态而非例外。
- en: Continuous Functions vs Discrete Functions
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连续函数 vs 离散函数
- en: 'The function <math alttext="f left-parenthesis x right-parenthesis equals x
    squared minus 3"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mn>3</mn></mrow></math>
    is continuous over the whole real line <math alttext="left-parenthesis negative
    normal infinity comma normal infinity right-parenthesis"><mrow><mo>(</mo> <mo>-</mo>
    <mi>∞</mi> <mo>,</mo> <mi>∞</mi> <mo>)</mo></mrow></math> . When we discretize
    it for a numerical scheme for a machine to process, first, the domain cannot be
    the whole real line anymore, because machines cannot yet conceptulaze infinite
    domains. So our first approximation is slashing the domain dramatically to some
    finite [-N,N] where N is a large number. Our second approximation is discretizing
    this finite domain, drastically reducing it one more time, from a continuum [-N,N]
    to only a finite set of points. If we use many points then our mesh will be finer
    and our approximation better, on the expense of increased computation cost. Say
    we use 6 points only to discretize the interval [-5,5]: -5, -3, -1, 1, 3, 5, then
    our continuous function will be reduced to a vector with only six entries:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 函数<math alttext="f left-parenthesis x right-parenthesis equals x squared minus
    3"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi>
    <mn>2</mn></msup> <mo>-</mo> <mn>3</mn></mrow></math>在整个实数线上是连续的<math alttext="left-parenthesis
    negative normal infinity comma normal infinity right-parenthesis"><mrow><mo>(</mo>
    <mo>-</mo> <mi>∞</mi> <mo>,</mo> <mi>∞</mi> <mo>)</mo></mrow></math>。当我们为机器处理的数值方案离散化它时，首先，定义域不能再是整个实数线，因为机器尚不能概念化无限域。因此，我们的第一个近似是将定义域大幅缩减到某个有限区间[-N,N]，其中N是一个大数。我们的第二个近似是将这个有限区间离散化，再次大幅减少，从一个连续区间[-N,N]到仅有限的一组点。如果我们使用许多点，那么我们的网格将更加精细，我们的近似将更好，但计算成本会增加。假设我们只使用6个点来离散化区间[-5,5]：-5，-3，-1，1，3，5，那么我们的连续函数将被减少为一个只有六个条目的向量：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column f left-parenthesis
    x right-parenthesis 2nd Column equals x squared minus 3 is continuous on left-parenthesis
    negative normal infinity comma normal infinity right-parenthesis 2nd Row 1st Column
    ModifyingAbove discrete f With right-arrow 2nd Column Start 6 By 1 Matrix 1st
    Row  left-parenthesis negative 5 right-parenthesis squared minus 3 2nd Row  left-parenthesis
    negative 3 right-parenthesis squared minus 3 3rd Row  left-parenthesis negative
    1 right-parenthesis squared minus 3 4th Row  1 squared minus 3 5th Row  3 squared
    minus 3 6th Row  5 squared minus 3 EndMatrix equals Start 6 By 1 Matrix 1st Row  22
    2nd Row  6 3rd Row  negative 2 4th Row  negative 2 5th Row  6 6th Row  22 EndMatrix
    EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mn>3</mn> <mtext>is</mtext> <mtext>continuous</mtext>
    <mtext>on</mtext> <mrow><mo>(</mo> <mo>-</mo> <mi>∞</mi> <mo>,</mo> <mi>∞</mi>
    <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mover accent="true"><mrow><mtext>discrete</mtext><mtext>f</mtext></mrow>
    <mo>→</mo></mover></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mfenced close=")"
    open="("><mtable><mtr><mtd><mrow><msup><mrow><mo>(</mo><mo>-</mo><mn>5</mn><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>-</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mrow><msup><mrow><mo>(</mo><mo>-</mo><mn>3</mn><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>-</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mrow><msup><mrow><mo>(</mo><mo>-</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>-</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mrow><msup><mn>1</mn>
    <mn>2</mn></msup> <mo>-</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mrow><msup><mn>3</mn>
    <mn>2</mn></msup> <mo>-</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mrow><msup><mn>5</mn>
    <mn>2</mn></msup> <mo>-</mo> <mn>3</mn></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close=")" open="("><mtable><mtr><mtd><mn>22</mn></mtd></mtr>
    <mtr><mtd><mn>6</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd></mtr>
    <mtr><mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mn>6</mn></mtd></mtr>
    <mtr><mtd><mn>22</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column f left-parenthesis
    x right-parenthesis 2nd Column equals x squared minus 3 is continuous on left-parenthesis
    negative normal infinity comma normal infinity right-parenthesis 2nd Row 1st Column
    ModifyingAbove discrete f With right-arrow 2nd Column Start 6 By 1 Matrix 1st
    Row  left-parenthesis negative 5 right-parenthesis squared minus 3 2nd Row  left-parenthesis
    negative 3 right-parenthesis squared minus 3 3rd Row  left-parenthesis negative
    1 right-parenthesis squared minus 3 4th Row  1 squared minus 3 5th Row  3 squared
    minus 3 6th Row  5 squared minus 3 EndMatrix equals Start 6 By 1 Matrix 1st Row  22
    2nd Row  6 3rd Row  negative 2 4th Row  negative 2 5th Row  6 6th Row  22 EndMatrix
    EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mn>3</mn> <mtext>is</mtext> <mtext>continuous</mtext>
    <mtext>on</mtext> <mrow><mo>(</mo> <mo>-</mo> <mi>∞</mi> <mo>,</mo> <mi>∞</mi>
    <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mover accent="true"><mrow><mtext>discrete</mtext><mtext>f</mtext></mrow>
    <mo>→</mo></mover></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mfenced close=")"
    open="("><mtable><mtr><mtd><mrow><msup><mrow><mo>(</mo><mo>-</mo><mn>5</mn><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>-</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mrow><msup><mrow><mo>(</mo><mo>-</mo><mn>3</mn><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>-</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mrow><msup><mrow><mo>(</mo><mo>-</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>-</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mrow><msup><mn>1</mn>
    <mn>2</mn></msup> <mo>-</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mrow><msup><mn>3</mn>
    <mn>2</mn></msup> <mo>-</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mrow><msup><mn>5</mn>
    <mn>2</mn></msup> <mo>-</mo> <mn>3</mn></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close=")" open="("><mtable><mtr><mtd><mn>22</mn></mtd></mtr>
    <mtr><mtd><mn>6</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd></mtr>
    <mtr><mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mn>6</mn></mtd></mtr>
    <mtr><mtd><mn>22</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
- en: '[Figure 13-5](#Fig_discrete_f) shows the continuous function and its insanely
    under-representative six point approximation.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-5](#Fig_discrete_f)显示了连续函数及其仅有六个点的极不充分的近似。'
- en: '![250](assets/emai_1305.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![250](assets/emai_1305.png)'
- en: Figure 13-5\. Discretizing the continuous function into a vector with only six
    points. We lose all the continuous wealth of information in between the points.
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-5。将连续函数离散化为仅有六个点的向量。我们失去了点之间所有连续的丰富信息。
- en: We still need to discretize derivatives
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们仍然需要离散化导数
- en: We can discretize a function *f(x)* by selecting points in an interval, just
    like we did above. Differential equations contain *derivatives of functions* such
    as <math alttext="f Subscript x Baseline comma normal upper Delta f"><mrow><msub><mi>f</mi>
    <mi>x</mi></msub> <mo>,</mo> <mi>Δ</mi> <mi>f</mi></mrow></math> , not only functions.
    So we must discretize the derivatives, or find some other way to reduce a problem
    from functional spaces (such as continuous spaces) to vector spaces (so we can
    use linear algebra and compute using our machines). Finite differences and finite
    elements are two popular discretization methods for differential equations. We
    will go over them shortly, along with a probabilistic Monte Carlo method based
    on random walks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在一个区间中选择点来离散化一个函数*f(x)*，就像我们之前所做的那样。微分方程包含*函数的导数*，比如<math alttext="f Subscript
    x Baseline comma normal upper Delta f"><mrow><msub><mi>f</mi> <mi>x</mi></msub>
    <mo>,</mo> <mi>Δ</mi> <mi>f</mi></mrow></math>，而不仅仅是函数。因此，我们必须离散化导数，或者找到其他方法将问题从函数空间（如连续空间）降维到向量空间（这样我们就可以使用线性代数和计算机进行计算）。有限差分和有限元是两种流行的微分方程离散化方法。我们将很快介绍它们，以及基于随机漫步的概率蒙特卡洛方法。
- en: One tradeoff of the simplicity of numerical solutions is that when we discretize,
    we make an approximation, reducing an infinite continuum to a finite set of points,
    losing all the infinitely detailed information that is between the finite set
    of points. That is, we sacrifice of high resolution. For certain equations, there
    are analytical methods which help us quantify exactly how much information we
    lose by discretization, and help move us back to an accurate analytical solution
    by taking the limit as the size of the discrete mesh goes to zero.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 数值解的简单性之一是，当我们离散化时，我们进行了近似，将无限连续减少为有限的点集，失去了在有限点集之间的所有无限详细信息。也就是说，我们牺牲了高分辨率。对于某些方程，有分析方法可以帮助我们准确量化通过离散化失去了多少信息，并通过将离散网格的大小趋近于零的极限来帮助我们回到准确的分析解。
- en: 'Discretizing continuous functions and the equations that involve them has advantages:
    Easy access. We can teach high school students how to solve the heat equation
    describing the diffusion of heat in a rod numerically (soon in this chapter),
    but we can cannot teach them how to solve it analytically until they finish their
    college calculus sequence and linear algebra. This is why we must teach children
    how to model and compute numerical solutions of real life problems at a very young
    age. The simplicity of numerical solutions and the power of computation to aid
    in solving all kinds of human problems should make this a priority in our education
    system. I doubt that nature intended for us to build and unravel crazily complicated
    mathematical theories before *computing* how the world around us works. I also
    doubt that nature is as complicated as some mathematical theories happen to be
    (even though they are still interesting in their own right, if only as an exercise
    in how far the rules of logic and inference can lead us).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 离散连续函数及涉及它们的方程具有优势：易于访问。我们可以教高中生如何数值解描述杆中热量扩散的热方程（本章后面会讨论），但在他们完成大学微积分和线性代数课程之前，我们无法教他们如何解析解决它。这就是为什么我们必须在孩子很小的时候教他们如何对现实生活中的问题建模和计算数值解。数值解的简单性和计算的力量有助于解决各种人类问题，这应该成为我们教育体系的优先事项。我怀疑自然并不希望我们在计算周围世界如何运作之前建立和解开疯狂复杂的数学理论。我也怀疑自然并不像某些数学理论那样复杂（尽管它们仍然以自身的方式有趣，即使只是作为逻辑和推理规则能引导我们走多远的练习）。
- en: PDE Themes From My Ph.D. Thesis
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我的博士论文中的PDE主题
- en: The story of my Ph.D. thesis demonstrates the drastic difference between mathematical
    theory and numerical approaches. It is also a good prototype for some of the themes
    of this chapter. For my Ph.D., I worked on a mathematical model that describes
    the way atoms diffuse and hop between different levels of a stair like surface
    of a thin crystal. This is useful for the materials science community and for
    the engineers involved in designing the mini things that go into our electronic
    devices. As time evolves the crystal’s shape changes due to the movement of atoms
    on its surface. Eventually, the crystal relaxes into some stable shape.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我的博士论文故事展示了数学理论和数值方法之间的巨大差异。这也是本章某些主题的良好原型。在我的博士论文中，我研究了一个数学模型，描述了原子在薄晶体表面的阶梯状表面上不同级别之间扩散和跳跃的方式。这对材料科学界和设计我们电子设备中所需微型部件的工程师很有用。随着时间的推移，晶体的形状会因其表面上原子的移动而发生变化。最终，晶体会放松成某种稳定的形状。
- en: Discretize Right Away And Do A Computer Simulation
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 立即离散化并进行计算机模拟
- en: 'The moment I wrote down the equations, I was able to do a computer simulation
    that showed how the shape of the crystal evolves with time. This is one of the
    PDEs that I worked on (not that you should care for it or know what the function
    in it refer to):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我写下这些方程时，我能够进行计算机模拟，展示晶体形状随时间的演变。这是我研究过的偏微分方程之一（并不是你应该关心它或知道其中的函数指的是什么）：
- en: <math alttext="dollar-sign u Subscript t Baseline left-parenthesis h comma t
    right-parenthesis equals minus u squared left-parenthesis u cubed right-parenthesis
    Subscript h h h h Baseline where h element-of left-bracket 0 comma 1 right-bracket
    comma t element-of left-bracket 0 comma normal infinity right-parenthesis dollar-sign"><mrow><msub><mi>u</mi>
    <mi>t</mi></msub> <mrow><mo>(</mo> <mi>h</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mo>-</mo> <msup><mi>u</mi> <mn>2</mn></msup> <msub><mrow><mo>(</mo><msup><mi>u</mi>
    <mn>3</mn></msup> <mo>)</mo></mrow> <mrow><mi>h</mi><mi>h</mi><mi>h</mi><mi>h</mi></mrow></msub>
    <mtext>where</mtext> <mi>h</mi> <mo>∈</mo> <mrow><mo>[</mo> <mn>0</mn> <mo>,</mo>
    <mn>1</mn> <mo>]</mo></mrow> <mo>,</mo> <mi>t</mi> <mo>∈</mo> <mrow><mo>[</mo>
    <mn>0</mn> <mo>,</mo> <mi>∞</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign u Subscript t Baseline left-parenthesis h comma t
    right-parenthesis equals minus u squared left-parenthesis u cubed right-parenthesis
    Subscript h h h h Baseline where h element-of left-bracket 0 comma 1 right-bracket
    comma t element-of left-bracket 0 comma normal infinity right-parenthesis dollar-sign"><mrow><msub><mi>u</mi>
    <mi>t</mi></msub> <mrow><mo>(</mo> <mi>h</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mo>-</mo> <msup><mi>u</mi> <mn>2</mn></msup> <msub><mrow><mo>(</mo><msup><mi>u</mi>
    <mn>3</mn></msup> <mo>)</mo></mrow> <mrow><mi>h</mi><mi>h</mi><mi>h</mi><mi>h</mi></mrow></msub>
    <mtext>where</mtext> <mi>h</mi> <mo>∈</mo> <mrow><mo>[</mo> <mn>0</mn> <mo>,</mo>
    <mn>1</mn> <mo>]</mo></mrow> <mo>,</mo> <mi>t</mi> <mo>∈</mo> <mrow><mo>[</mo>
    <mn>0</mn> <mo>,</mo> <mi>∞</mi> <mo>)</mo></mrow></mrow></math>
- en: 'For the trained eye, this is a highly nonlinear fourth order equation: The
    unknown function *u* appears both squared and cubed. Its cube appears with four
    derivatives in space, which we can think of as four degrees removed from the function
    that we want to evaluate. [Figure 13-6](#Fig_discrete_continuum) shows my PDE’s
    discretization in space using finite differences (we will discuss finite differences
    shortly), and its boundary conditions (the function values at the points 0 and
    1).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于训练有素的人来说，这是一个高度非线性的四阶方程：未知函数*u*既平方又立方。它的立方体在空间中出现了四个导数，我们可以将其视为距我们想要评估的函数有四个度的距离。[图13-6](#Fig_discrete_continuum)展示了我在空间中使用有限差分（我们将很快讨论有限差分）对我的PDE进行离散化，以及其边界条件（在点0和1处的函数值）。
- en: '![250](assets/emai_1306.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![250](assets/emai_1306.png)'
- en: Figure 13-6\. Discrete differential equations and their continuum analogue.
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-6。离散微分方程及其连续模拟。
- en: Usually the more nonlinear an equation is the more stubborn it is in submitting
    to standard analytical techniques. I still needed to do the mathematical analysis
    and prove that the shape that the numerical simulation showed is indeed what the
    equations want the solution to do, meaning that it is *the* analytical solution,
    and it is what nature chooses among possible others. I had to spend the next two
    years of my life doing only that. What I came up with was a tiny proof in a tiny
    case for a physically unrealistic *one dimensional crystal*! I had to reduce my
    equations to only one dimension to be able to do any mathematical analysis with
    them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，方程非线性程度越高，它就越不愿意服从标准的分析技术。我仍然需要进行数学分析，并证明数值模拟显示的形状确实是方程要求解决方案采取的方式，也就是说，它是*分析解，也是自然在可能的其他解决方案中选择的方式。我不得不花费接下来的两年时间只做这件事。我得出的结论是，对于一个物理上不现实的*一维晶体*，我在一个微小的案例中得出了一个微小的证明！我必须将我的方程减少到只有一个维度，才能够对其进行任何数学分析。
- en: The Curse of Dimensionality
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 维度的诅咒
- en: 'One theme which is always present is the dimensionality of the problem: Even
    when I did the numerical simulation, which took less than one afternoon, I was
    only able to do it for the equation over the one dimensional domain. When I tried
    to do a simulation to model a realistic thin film laboratory crystal that lays
    on a flat surface, meaning when I had to discretize a two dimensional surface
    instead of a one dimensional segment, the number of dicrete points jumped from
    100 on the one dimensional segment to <math alttext="100 squared equals 100 comma
    000"><mrow><msup><mn>100</mn> <mn>2</mn></msup> <mo>=</mo> <mn>100</mn> <mo>,</mo>
    <mn>000</mn></mrow></math> on the two dimensional surface. My computer at the
    time could not numerically solve the exact same equation that took only few seconds
    in the one dimensional case. Granted, I was not sophisticated enough to compute
    on the university’s server or use parallel computing (I do not know if distributed
    cloud computing had even been invented back then). So is life with the curse of
    dimensionality. The computational expense rises exponentially with the number
    of dimensions. Now let’s think of the equations whose domains have high dimensions
    to start with (even before discretization), like Shrödinger equation for quantum
    particle systems, Black Scholes equation for pricing financial instruments, or
    the Hamilton–Jacobi–Bellman equation in dynamic programming which models multi-player
    games or resource allocation problems. Imagine then the magnitude of the curse
    of dimensionality.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个始终存在的主题是问题的维度性：即使我进行了少于一个下午的数值模拟，我也只能对一维域上的方程进行模拟。当我尝试进行模拟以建模放置在平面上的现实薄膜实验晶体时，也就是说，当我必须将二维表面离散化而不是一维段时，离散点的数量从一维段上的100个跳到了二维表面上的100,000个。当时我的电脑无法数值求解在一维情况下只需几秒钟的相同方程。诚然，我当时还不够复杂，无法在大学服务器上进行计算或使用并行计算（我不知道当时是否已经发明了分布式云计算）。这就是维度的诅咒。随着维度数量的增加，计算开销呈指数级增长。现在让我们想想那些在开始时就具有高维度域的方程，比如用于量子粒子系统的薛定谔方程，用于定价金融工具的Black
    Scholes方程，或者用于动态规划的Hamilton-Jacobi-Bellman方程，该方程模拟多人游戏或资源分配问题。那么想象一下维度的诅咒的程度。
- en: The Geometry of the Problem
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 问题的几何形状
- en: 'Another theme that we have mentioned earlier but is worth repeating: The shape
    of the domain matters, for both analysis and numerical computation. In my unrealistic
    one dimensional case, I used a segment as the domain for my equation. In the two
    dimensional case, I had much more choices: A rectangle (has the advantage of a
    regular grid), a circle (has the advantage of radial symmetry), or any other realistic
    unregular shape which doesn’t usually have a name. For analysis, the rectangle
    and the circle domains are the easiest (not for my particular equations but for
    other simpler equations like linear equations). For simulations, these are good
    too. But when the shape of the domain is not regular, which is the case for most
    realistic things, we need to place more discrete points in the parts where it
    is irregular if we want to capture the domain faithfully. The curse of dimensionality
    bears its unwelcome head again: More points means longer vectors and larger input
    matrices for computations.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过但值得重复的另一个主题是：域的形状很重要，无论是对于分析还是数值计算。在我不切实际的一维情况下，我使用了一个段作为方程的定义域。在二维情况下，我有更多选择：矩形（具有规则网格的优势），圆形（具有径向对称性的优势），或者任何其他通常没有名称的现实非规则形状。对于分析来说，矩形和圆形域是最容易的（对于我的特定方程来说不是，但对于其他更简单的方程如线性方程来说是）。对于模拟，这些也很好。但是当域的形状不规则时，这是大多数现实事物的情况，如果我们想忠实地捕捉域，我们需要在不规则部分放置更多的离散点。维度的诅咒再次显现：更多的点意味着更长的向量和更大的输入矩阵用于计算。
- en: Model Things That You Care For
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟你关心的事物
- en: To finish my Ph.D. story, I never saw a real thin film crystal like the one
    I was working on until ten years after I finished my degree, when my friend showed
    me a thin film crystal of gold in her lab. In retrospect, maybe I should’ve started
    there, by *seeing* exactly what it is in real life that I was trying to model.
    My priorities now are aligned differently, and I always start by asking whether
    I care for what it is I am trying to model, how closely the model I choose to
    work on mimics reality, and whether thinking about analytical solutions is even
    worth the time and the effort for this particular application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 结束我的博士故事，直到我完成学位后的十年，我才看到了一个真实的薄膜金晶体，就像我当时正在研究的那个，当时我的朋友在她的实验室里向我展示了一个薄膜金晶体。回想起来，也许我应该从那里开始，通过*看到*我试图模拟的真实生活中的东西。我的现在的优先事项有所不同，我总是首先询问自己是否关心我试图模拟的东西，我选择工作的模型有多接近现实，以及思考分析解是否值得为这个特定应用付出时间和精力。
- en: Discretization And The Curse Of Dimensionality
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 离散化和维度的诅咒
- en: 'Mathematicians who study PDEs like the continuous world but machines like the
    discrete world. Mathematicians like to analyze functions but machines like to
    compute functions. To reconcile the two, and for machines to be of aid to mathematicians
    and vice versa, we can discretize our continuum equations. How? First, we discretize
    the domain of the equation, creating a discrete mesh. We choose the type of the
    mesh (regular or irregular) and how fine or coarse it is. Then we discretize the
    differential equation itself, using one of four popular methods:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 研究偏微分方程的数学家喜欢连续世界，但机器喜欢离散世界。数学家喜欢分析函数，但机器喜欢计算函数。为了调和这两者，使机器能够帮助数学家，反之亦然，我们可以离散化我们的连续方程。如何做到？首先，我们离散化方程的定义域，创建一个离散网格。我们选择网格的类型（规则或不规则）以及精细程度。然后我们离散化微分方程本身，使用四种流行的方法之一：
- en: '**Finite differences**: Deterministic, good for discretizing time, one dimensional
    or relatively regular spatial geometries.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限差分**：确定性，适用于离散化时间，一维或相对规则的空间几何。'
- en: '**Finite elements**: Deterministic, good for discretizing more complex spatial
    geometries, also spatial geometries that vary with time.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有限元：确定性，适用于离散化更复杂的空间几何结构，也适用于随时间变化的空间几何结构。
- en: '**Variational or energy methods**: This is similar to finite elements but works
    on a narrower set of PDEs. They should possess a *variational principle*, or an
    *energy formulation*, that is, the PDE itself should be equivalent to <math alttext="normal
    nabla upper E left-parenthesis u right-parenthesis equals 0"><mrow><mi>∇</mi>
    <mi>E</mi> <mo>(</mo> <mi>u</mi> <mo>)</mo> <mo>=</mo> <mn>0</mn></mrow></math>
    for some energy functional *E(u)* (mapping functions to the real line). The reason
    I was able to get my Ph.D. is that I discovered such an energy functional for
    my PDE, by pure luck. Just like the minimum of a calculus function happens at
    points where <math alttext="normal nabla f left-parenthesis ModifyingAbove x With
    right-arrow right-parenthesis equals 0"><mrow><mi>∇</mi> <mi>f</mi> <mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo> <mo>=</mo> <mn>0</mn></mrow></math>
    , the minimum of an energy functional happens at *functions* where <math alttext="normal
    nabla upper E left-parenthesis u right-parenthesis equals 0"><mrow><mi>∇</mi>
    <mi>E</mi> <mo>(</mo> <mi>u</mi> <mo>)</mo> <mo>=</mo> <mn>0</mn></mrow></math>
    , but of course we need to define what it means to take the derivative of a *functional*.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变分或能量方法：这类似于有限元，但适用于一组更窄的偏微分方程。它们应该具有一个“变分原理”或一个“能量形式”，即，PDE本身应该等价于“∇E（u）= 0”对于某个能量函数E（u）（将函数映射到实数线）。我能获得博士学位的原因是我纯粹凭运气为我的PDE发现了这样一个能量函数。就像微积分函数的最小值出现在“∇f（x→）=
    0”的点处一样，能量函数的最小值出现在“∇E（u）= 0”的“函数”处，但当然我们需要定义如何对“泛函”进行导数运算。
- en: '**Monte Carlo Methods**: Probabilistic, starts with discretizing the PDE then
    use that to devise an appropriate random walk scheme that enables us to *aggregate*
    the solution at a certain point in the domain.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蒙特卡洛方法：概率性的，从离散化PDE开始，然后利用这一点设计一个适当的随机游走方案，使我们能够在域中的某一点“聚合”解决方案。
- en: The word *finite* in these methods stresses the fact that this process moves
    us from continuum infinite dimensional spaces of functions to finite dimensional
    spaces of vectors.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的“有限”一词强调了这个过程将我们从函数的连续无限维空间转移到有限维向量空间。
- en: 'If the mesh we use for discretization is too fine, it captures more resolution,
    but we end up with high dimensional vectors and matrices. Keep this curse of dimensionality
    in mind, and the following: One of the main reasons neural networks’ popularity
    skyrocketed is that they seem to have a magical ability to overcome the curse
    of dimensionality. We will see how soon.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用于离散化的网格太细，它会捕捉更多的分辨率，但我们最终会得到高维向量和矩阵。记住这种维度的诅咒，以及以下内容：神经网络的流行之所以飙升是因为它们似乎有一种神奇的能力来克服维度的诅咒。我们很快会看到这一点。
- en: Finite Differences
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有限差分
- en: We use finite differences to numerically approximate the derivatives of the
    functions that appear in PDEs. For example, a particle’s velocity is the derivative
    in time of its position vector, and a particle’s acceleration is two detivatives
    in time of it’s position vector.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用有限差分来数值逼近偏微分方程中出现的函数的导数。例如，粒子的速度是其位置矢量在时间上的导数，粒子的加速度是其位置矢量在时间上的两个导数。
- en: 'In finite difference approximations, we replace the derivatives with linear
    combinations of function values at discrete points in the domain. Recall that
    one derivative measures a function’s rate of change. Two derivatives measure concavity.
    Higher derivatives measure more stuff that some people in the sciences happen
    to use. The connection between a function’s derivatives at a point and how its
    values near that point compare to each other is pretty intuitive. The mathematical
    justification for these approximations rely on Taylor’s theorem from calculus:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在有限差分逼近中，我们用域中离散点处的函数值的线性组合替换导数。回想一下，一个导数测量函数的变化率。两个导数测量凹度。更高阶导数测量更多一些科学家偶尔使用的东西。函数在一个点处的导数与其在该点附近的值如何相互比较之间的联系是相当直观的。这些逼近的数学理由依赖于微积分中的泰勒定理：
- en: <math alttext="dollar-sign f left-parenthesis x right-parenthesis equals f left-parenthesis
    x Subscript i Baseline right-parenthesis plus f prime left-parenthesis x Subscript
    i Baseline right-parenthesis left-parenthesis x minus x Subscript i Baseline right-parenthesis
    plus StartFraction f double-prime left-parenthesis x Subscript i Baseline right-parenthesis
    Over 2 EndFraction left-parenthesis x minus x Subscript i Superscript 2 Baseline
    right-parenthesis plus StartFraction f Superscript left-parenthesis 3 right-parenthesis
    Baseline left-parenthesis x Subscript i Baseline right-parenthesis Over 3 factorial
    EndFraction left-parenthesis x minus x Subscript i Baseline right-parenthesis
    cubed plus ellipsis plus StartFraction f Superscript left-parenthesis n right-parenthesis
    Baseline left-parenthesis x Subscript i Baseline right-parenthesis Over n factorial
    EndFraction left-parenthesis x minus x Subscript i Baseline right-parenthesis
    Superscript n Baseline plus error term comma dollar-sign"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <msub><mi>x</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow> <mo>+</mo> <msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo>
    <mi>x</mi> <mo>-</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow> <mo>+</mo>
    <mfrac><mrow><msup><mi>f</mi> <mrow><mo>'</mo><mo>'</mo></mrow></msup> <mrow><mo>(</mo><msub><mi>x</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow></mrow> <mn>2</mn></mfrac> <mrow><mo>(</mo>
    <mi>x</mi> <mo>-</mo> <msubsup><mi>x</mi> <mi>i</mi> <mn>2</mn></msubsup> <mo>)</mo></mrow>
    <mo>+</mo> <mfrac><mrow><msup><mi>f</mi> <mrow><mo>(</mo><mn>3</mn><mo>)</mo></mrow></msup>
    <mrow><mo>(</mo><msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow> <mrow><mn>3</mn><mo>!</mo></mrow></mfrac>
    <msup><mrow><mo>(</mo><mi>x</mi><mo>-</mo><msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow>
    <mn>3</mn></msup> <mo>+</mo> <mo>⋯</mo> <mo>+</mo> <mfrac><mrow><msup><mi>f</mi>
    <mrow><mo>(</mo><mi>n</mi><mo>)</mo></mrow></msup> <mrow><mo>(</mo><msub><mi>x</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow></mrow> <mrow><mi>n</mi><mo>!</mo></mrow></mfrac>
    <msup><mrow><mo>(</mo><mi>x</mi><mo>-</mo><msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow>
    <mi>n</mi></msup> <mo>+</mo> <mtext>error</mtext> <mtext>term</mtext> <mo>,</mo></mrow></math>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign f left-parenthesis x right-parenthesis equals f left-parenthesis
    x Subscript i Baseline right-parenthesis plus f prime left-parenthesis x Subscript
    i Baseline right-parenthesis left-parenthesis x minus x Subscript i Baseline right-parenthesis
    plus StartFraction f double-prime left-parenthesis x Subscript i Baseline right-parenthesis
    Over 2 EndFraction left-parenthesis x minus x Subscript i Superscript 2 Baseline
    right-parenthesis plus StartFraction f Superscript left-parenthesis 3 right-parenthesis
    Baseline left-parenthesis x Subscript i Baseline right-parenthesis Over 3 factorial
    EndFraction left-parenthesis x minus x Subscript i Baseline right-parenthesis
    cubed plus ellipsis plus StartFraction f Superscript left-parenthesis n right-parenthesis
    Baseline left-parenthesis x Subscript i Baseline right-parenthesis Over n factorial
    EndFraction left-parenthesis x minus x Subscript i Baseline right-parenthesis
    Superscript n Baseline plus error term comma dollar-sign"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <msub><mi>x</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow> <mo>+</mo> <msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo>
    <mi>x</mi> <mo>-</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow> <mo>+</mo>
    <mfrac><mrow><msup><mi>f</mi> <mrow><mo>'</mo><mo>'</mo></mrow></msup> <mrow><mo>(</mo><msub><mi>x</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow></mrow> <mn>2</mn></mfrac> <mrow><mo>(</mo>
    <mi>x</mi> <mo>-</mo> <msubsup><mi>x</mi> <mi>i</mi> <mn>2</mn></msubsup> <mo>)</mo></mrow>
    <mo>+</mo> <mfrac><mrow><msup><mi>f</mi> <mrow><mo>(</mo><mn>3</mn><mo>)</mo></mrow></msup>
    <mrow><mo>(</mo><msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow> <mrow><mn>3</mn><mo>!</mo></mrow></mfrac>
    <msup><mrow><mo>(</mo><mi>x</mi><mo>-</mo><msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow>
    <mn>3</mn></msup> <mo>+</mo> <mo>⋯</mo> <mo>+</mo> <mfrac><mrow><msup><mi>f</mi>
    <mrow><mo>(</mo><mi>n</mi><mo>)</mo></mrow></msup> <mrow><mo>(</mo><msub><mi>x</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow></mrow> <mrow><mi>n</mi><mo>!</mo></mrow></mfrac>
    <msup><mrow><mo>(</mo><mi>x</mi><mo>-</mo><msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow>
    <mi>n</mi></msup> <mo>+</mo> <mtext>error</mtext> <mtext>term</mtext> <mo>,</mo></mrow></math>
- en: where the error term depends on how nice the next order derivative <math alttext="f
    Superscript left-parenthesis n plus 1 right-parenthesis Baseline left-parenthesis
    xi right-parenthesis"><mrow><msup><mi>f</mi> <mrow><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msup>
    <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow></mrow></math> near the <math alttext="x
    Subscript i"><msub><mi>x</mi> <mi>i</mi></msub></math> where we are attempting
    to use our polynomial approximation. Taylor’s theorem approximates a nice enough
    function near a point with a polynomial whose coefficients are determined by the
    derivatives of the function at that point. The more derivatives the function has
    at a point the nicer it is and the *more like a polynomial* it behaves near that
    point.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 其中误差项取决于下一个阶导数在我们尝试使用多项式逼近的点附近的“xi”处的“f（n+1）（xi）”有多好。泰勒定理近似了一个足够好的函数在一个点附近的多项式，其系数由该点处函数的导数确定。函数在一个点处具有的导数越多，它就越好，它在该点附近的行为就越像一个多项式。
- en: 'Now let’s discretize a one dimensional interval [a,b] then write down finite
    difference approximations for the derivatives of a function *f(x)* defined over
    this interval. We can discretize [a,b] using n+1 equally spaced points, so the
    mesh size is <math alttext="h equals StartFraction b minus a Over n EndFraction"><mrow><mi>h</mi>
    <mo>=</mo> <mfrac><mrow><mi>b</mi><mo>-</mo><mi>a</mi></mrow> <mi>n</mi></mfrac></mrow></math>
    . We can now evaluate *f* at any of these discrete points. If we care about the
    values near some point <math alttext="x Subscript i"><msub><mi>x</mi> <mi>i</mi></msub></math>
    , we define <math alttext="f Subscript i plus 1 Baseline equals f left-parenthesis
    x Subscript i Baseline plus h right-parenthesis comma f Subscript i plus 2 Baseline
    equals f left-parenthesis x Subscript i Baseline plus 2 h right-parenthesis comma
    f Subscript i minus 1 Baseline equals f left-parenthesis x Subscript i Baseline
    minus h right-parenthesis"><mrow><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>+</mo>
    <mi>h</mi> <mo>)</mo></mrow> <mo>,</mo> <msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>+</mo>
    <mn>2</mn> <mi>h</mi> <mo>)</mo></mrow> <mo>,</mo> <msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>-</mo>
    <mi>h</mi> <mo>)</mo></mrow></mrow></math> , *etc*. In the following, *h* is small,
    so an <math alttext="upper O left-parenthesis h squared right-parenthesis"><mrow><mi>O</mi>
    <mo>(</mo> <msup><mi>h</mi> <mn>2</mn></msup> <mo>)</mo></mrow></math> method
    (or higher order in *h*) is more accurate than an <math alttext="upper O left-parenthesis
    h right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <mi>h</mi> <mo>)</mo></mrow></math>
    method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们离散化一个一维区间[a，b]，然后写出定义在该区间上的函数*f(x)*的导数的有限差分逼近。我们可以使用n+1个等间距点来离散化[a，b]，因此网格大小为h
    = (b-a)/n。我们现在可以在任何这些离散点上评估*f*。如果我们关心某点附近的值x_i，我们定义f_{i+1} = f(x_i + h)，f_{i+2}
    = f(x_i + 2h)，f_{i-1} = f(x_i - h)，等等。在接下来的内容中，h很小，因此一个O(h^2)方法（或更高阶的h）比一个O(h)方法更准确：
- en: 'Forward difference approximation of O(h) accuracy for the first derivative
    (uses 2 points): (add picture)'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一阶导数的O(h)精度的前向差分逼近（使用2个点）：（添加图片）
- en: <math alttext="dollar-sign f prime left-parenthesis x Subscript i Baseline right-parenthesis
    almost-equals StartFraction f Subscript i plus 1 Baseline minus f Subscript i
    Baseline Over h EndFraction dollar-sign"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow> <mo>≈</mo>
    <mfrac><mrow><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>-</mo><msub><mi>f</mi> <mi>i</mi></msub></mrow> <mi>h</mi></mfrac></mrow></math>
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign f prime left-parenthesis x Subscript i Baseline right-parenthesis
    almost-equals StartFraction f Subscript i plus 1 Baseline minus f Subscript i
    Baseline Over h EndFraction dollar-sign"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow> <mo>≈</mo>
    <mfrac><mrow><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>-</mo><msub><mi>f</mi> <mi>i</mi></msub></mrow> <mi>h</mi></mfrac></mrow></math>
- en: 'Backward difference approximation of O(h) accuracy for the first derivative
    (uses 2 points): (add picture)'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一阶导数的O(h)精度的后向差分逼近（使用2个点）：（添加图片）
- en: <math alttext="dollar-sign f prime left-parenthesis x Subscript i Baseline right-parenthesis
    almost-equals StartFraction f Subscript i Baseline minus f Subscript i minus 1
    Baseline Over h EndFraction dollar-sign"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow> <mo>≈</mo>
    <mfrac><mrow><msub><mi>f</mi> <mi>i</mi></msub> <mo>-</mo><msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow>
    <mi>h</mi></mfrac></mrow></math>
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign f prime left-parenthesis x Subscript i Baseline right-parenthesis
    almost-equals StartFraction f Subscript i Baseline minus f Subscript i minus 1
    Baseline Over h EndFraction dollar-sign"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow> <mo>≈</mo>
    <mfrac><mrow><msub><mi>f</mi> <mi>i</mi></msub> <mo>-</mo><msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow>
    <mi>h</mi></mfrac></mrow></math>
- en: 'Central-difference approximations of <math alttext="upper O left-parenthesis
    h squared right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>h</mi> <mn>2</mn></msup>
    <mo>)</mo></mrow></math> accuracy for derivatives up to the fourth (uses 2 points,
    averages forward and backward differences): (add picture)'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中心差分逼近的O(h^2)精度，适用于高达四阶的导数（使用2个点，平均前向和后向差分）：（添加图片）
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column f prime left-parenthesis
    x Subscript i Baseline right-parenthesis 2nd Column almost-equals StartFraction
    f Subscript i plus 1 Baseline minus f Subscript i minus 1 Baseline Over 2 h EndFraction
    2nd Row 1st Column f double-prime left-parenthesis x Subscript i Baseline right-parenthesis
    2nd Column almost-equals StartFraction f Subscript i plus 1 Baseline minus 2 f
    Subscript i Baseline plus f Subscript i minus 1 Baseline Over h squared EndFraction
    3rd Row 1st Column f triple-prime left-parenthesis x Subscript i Baseline right-parenthesis
    2nd Column almost-equals StartFraction f Subscript i plus 2 Baseline minus 2 f
    Subscript i plus 1 Baseline plus 2 f Subscript i minus 1 Baseline minus f Subscript
    i minus 2 Baseline Over 2 h cubed EndFraction 4th Row 1st Column f Superscript
    left-parenthesis 4 right-parenthesis Baseline left-parenthesis x Subscript i Baseline
    right-parenthesis 2nd Column almost-equals StartFraction f Subscript i plus 2
    Baseline minus 4 f Subscript i plus 1 Baseline plus 6 f Subscript i Baseline minus
    4 f Subscript i minus 1 Baseline plus f Subscript i minus 2 Baseline Over h Superscript
    4 Baseline EndFraction EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd> <mtd columnalign="left"><mrow><mo>≈</mo>
    <mfrac><mrow><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>-</mo><msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow>
    <mrow><mn>2</mn><mi>h</mi></mrow></mfrac></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><msup><mi>f</mi>
    <mrow><mo>'</mo><mo>'</mo></mrow></msup> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub>
    <mo>)</mo></mrow></mrow></mtd> <mtd columnalign="left"><mrow><mo>≈</mo> <mfrac><mrow><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>-</mo><mn>2</mn><msub><mi>f</mi>
    <mi>i</mi></msub> <mo>+</mo><msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow>
    <msup><mi>h</mi> <mn>2</mn></msup></mfrac></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><msup><mi>f</mi>
    <mrow><mo>'</mo><mo>'</mo><mo>'</mo></mrow></msup> <mrow><mo>(</mo> <msub><mi>x</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd> <mtd columnalign="left"><mrow><mo>≈</mo>
    <mfrac><mrow><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub>
    <mo>-</mo><mn>2</mn><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>+</mo><mn>2</mn><msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>-</mo><msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow>
    <mrow><mn>2</mn><msup><mi>h</mi> <mn>3</mn></msup></mrow></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><msup><mi>f</mi> <mrow><mo>(</mo><mn>4</mn><mo>)</mo></mrow></msup>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>≈</mo> <mfrac><mrow><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub>
    <mo>-</mo><mn>4</mn><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>+</mo><mn>6</mn><msub><mi>f</mi> <mi>i</mi></msub> <mo>-</mo><mn>4</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>+</mo><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow> <msup><mi>h</mi> <mn>4</mn></msup></mfrac></mrow></mtd></mtr></mtable></math>
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column f prime left-parenthesis
    x Subscript i Baseline right-parenthesis 2nd Column almost-equals StartFraction
    f Subscript i plus 1 Baseline minus f Subscript i minus 1 Baseline Over 2 h EndFraction
    2nd Row 1st Column f double-prime left-parenthesis x Subscript i Baseline right-parenthesis
    2nd Column almost-equals StartFraction f Subscript i plus 1 Baseline minus 2 f
    Subscript i Baseline plus f Subscript i minus 1 Baseline Over h squared EndFraction
    3rd Row 1st Column f triple-prime left-parenthesis x Subscript i Baseline right-parenthesis
    2nd Column almost-equals StartFraction f Subscript i plus 2 Baseline minus 2 f
    Subscript i plus 1 Baseline plus 2 f Subscript i minus 1 Baseline minus f Subscript
    i minus 2 Baseline Over 2 h cubed EndFraction 4th Row 1st Column f Superscript
    left-parenthesis 4 right-parenthesis Baseline left-parenthesis x Subscript i Baseline
    right-parenthesis 2nd Column almost-equals StartFraction f Subscript i plus 2
    Baseline minus 4 f Subscript i plus 1 Baseline plus 6 f Subscript i Baseline minus
    4 f Subscript i minus 1 Baseline plus f Subscript i minus 2 Baseline Over h Superscript
    4 Baseline EndFraction EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd> <mtd columnalign="left"><mrow><mo>≈</mo>
    <mfrac><mrow><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>-</mo><msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow>
    <mrow><mn>2</mn><mi>h</mi></mrow></mfrac></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><msup><mi>f</mi>
    <mrow><mo>'</mo><mo>'</mo></mrow></msup> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub>
    <mo>)</mo></mrow></mrow></mtd> <mtd columnalign="left"><mrow><mo>≈</mo> <mfrac><mrow><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>-</mo><mn>2</mn><msub><mi>f</mi>
    <mi>i</mi></msub> <mo>+</mo><msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow>
    <msup><mi>h</mi> <mn>2</mn></msup></mfrac></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><msup><mi>f</mi>
    <mrow><mo>'</mo><mo>'</mo><mo>'</mo></mrow></msup> <mrow><mo>(</mo> <msub><mi>x</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd> <mtd columnalign="left"><mrow><mo>≈</mo>
    <mfrac><mrow><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub>
    <mo>-</mo><mn>2</mn><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>+</mo><mn>2</mn><msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>-</mo><msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow>
    <mrow><mn>2</mn><msup><mi>h</mi> <mn>3</mn></msup></mrow></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><msup><mi>f</mi> <mrow><mo>(</mo><mn>4</mn><mo>)</mo></mrow></msup>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>≈</mo> <mfrac><mrow><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub>
    <mo>-</mo><mn>4</mn><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>+</mo><mn>6</mn><msub><mi>f</mi> <mi>i</mi></msub> <mo>-</mo><mn>4</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>+</mo><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow> <msup><mi>h</mi> <mn>4</mn></msup></mfrac></mrow></mtd></mtr></mtable></math>
- en: 'Central-difference approximations of <math alttext="upper O left-parenthesis
    h Superscript 4 Baseline right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>h</mi>
    <mn>4</mn></msup> <mo>)</mo></mrow></math> accuracy for derivatives up to the
    fourth:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中心差分逼近的O(h^4)精度，适用于高达四阶的导数：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column f prime left-parenthesis
    x Subscript i Baseline right-parenthesis 2nd Column almost-equals StartFraction
    minus f Subscript i plus 2 Baseline plus 8 f Subscript i plus 1 Baseline minus
    8 f Subscript i minus 1 Baseline plus f Subscript i minus 2 Baseline Over 12 h
    EndFraction 2nd Row 1st Column f double-prime left-parenthesis x Subscript i Baseline
    right-parenthesis 2nd Column almost-equals StartFraction minus f Subscript i plus
    2 Baseline plus 16 f Subscript i plus 1 Baseline minus 30 f Subscript i Baseline
    plus 16 f Subscript i minus 1 Baseline minus f Subscript i minus 2 Baseline Over
    12 h squared EndFraction 3rd Row 1st Column f triple-prime left-parenthesis x
    Subscript i Baseline right-parenthesis 2nd Column almost-equals StartFraction
    minus f Subscript i plus 3 Baseline plus 8 f Subscript i plus 2 Baseline minus
    13 f Subscript i plus 1 Baseline plus 13 f Subscript i minus 1 Baseline minus
    8 f Subscript i minus 2 Baseline plus f Subscript i minus 3 Baseline Over 8 h
    cubed EndFraction 4th Row 1st Column f Superscript left-parenthesis 4 right-parenthesis
    Baseline left-parenthesis x Subscript i Baseline right-parenthesis 2nd Column
    almost-equals StartFraction minus f Subscript i plus 3 Baseline plus 12 f Subscript
    i plus 2 Baseline minus 39 f Subscript i plus 1 Baseline plus 56 f Subscript i
    Baseline minus 39 f Subscript i minus 1 Baseline plus 12 f Subscript i minus 2
    Baseline minus f Subscript i minus 3 Baseline Over 6 h Superscript 4 Baseline
    EndFraction EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>≈</mo> <mfrac><mrow><mo>-</mo><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub> <mo>+</mo><mn>8</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>-</mo><mn>8</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>+</mo><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow> <mrow><mn>12</mn><mi>h</mi></mrow></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><msup><mi>f</mi> <mrow><mo>'</mo><mo>'</mo></mrow></msup>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>≈</mo> <mfrac><mrow><mo>-</mo><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub> <mo>+</mo><mn>16</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>-</mo><mn>30</mn><msub><mi>f</mi>
    <mi>i</mi></msub> <mo>+</mo><mn>16</mn><msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>-</mo><msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow>
    <mrow><mn>12</mn><msup><mi>h</mi> <mn>2</mn></msup></mrow></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><msup><mi>f</mi> <mrow><mo>'</mo><mo>'</mo><mo>'</mo></mrow></msup>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>≈</mo> <mfrac><mrow><mo>-</mo><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>3</mn></mrow></msub> <mo>+</mo><mn>8</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub> <mo>-</mo><mn>13</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>+</mo><mn>13</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>-</mo><mn>8</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>2</mn></mrow></msub> <mo>+</mo><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>3</mn></mrow></msub></mrow> <mrow><mn>8</mn><msup><mi>h</mi>
    <mn>3</mn></msup></mrow></mfrac></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><msup><mi>f</mi>
    <mrow><mo>(</mo><mn>4</mn><mo>)</mo></mrow></msup> <mrow><mo>(</mo> <msub><mi>x</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd> <mtd columnalign="left"><mrow><mo>≈</mo>
    <mfrac><mrow><mo>-</mo><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>3</mn></mrow></msub>
    <mo>+</mo><mn>12</mn><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub>
    <mo>-</mo><mn>39</mn><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>+</mo><mn>56</mn><msub><mi>f</mi> <mi>i</mi></msub> <mo>-</mo><mn>39</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>+</mo><mn>12</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>2</mn></mrow></msub> <mo>-</mo><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>3</mn></mrow></msub></mrow> <mrow><mn>6</mn><msup><mi>h</mi>
    <mn>4</mn></msup></mrow></mfrac></mrow></mtd></mtr></mtable></math>
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column f prime left-parenthesis
    x Subscript i Baseline right-parenthesis 2nd Column almost-equals StartFraction
    minus f Subscript i plus 2 Baseline plus 8 f Subscript i plus 1 Baseline minus
    8 f Subscript i minus 1 Baseline plus f Subscript i minus 2 Baseline Over 12 h
    EndFraction 2nd Row 1st Column f double-prime left-parenthesis x Subscript i Baseline
    right-parenthesis 2nd Column almost-equals StartFraction minus f Subscript i plus
    2 Baseline plus 16 f Subscript i plus 1 Baseline minus 30 f Subscript i Baseline
    plus 16 f Subscript i minus 1 Baseline minus f Subscript i minus 2 Baseline Over
    12 h squared EndFraction 3rd Row 1st Column f triple-prime left-parenthesis x
    Subscript i Baseline right-parenthesis 2nd Column almost-equals StartFraction
    minus f Subscript i plus 3 Baseline plus 8 f Subscript i plus 2 Baseline minus
    13 f Subscript i plus 1 Baseline plus 13 f Subscript i minus 1 Baseline minus
    8 f Subscript i minus 2 Baseline plus f Subscript i minus 3 Baseline Over 8 h
    cubed EndFraction 4th Row 1st Column f Superscript left-parenthesis 4 right-parenthesis
    Baseline left-parenthesis x Subscript i Baseline right-parenthesis 2nd Column
    almost-equals StartFraction minus f Subscript i plus 3 Baseline plus 12 f Subscript
    i plus 2 Baseline minus 39 f Subscript i plus 1 Baseline plus 56 f Subscript i
    Baseline minus 39 f Subscript i minus 1 Baseline plus 12 f Subscript i minus 2
    Baseline minus f Subscript i minus 3 Baseline Over 6 h Superscript 4 Baseline
    EndFraction EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>≈</mo> <mfrac><mrow><mo>-</mo><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub> <mo>+</mo><mn>8</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>-</mo><mn>8</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>+</mo><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow> <mrow><mn>12</mn><mi>h</mi></mrow></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><msup><mi>f</mi> <mrow><mo>'</mo><mo>'</mo></mrow></msup>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>≈</mo> <mfrac><mrow><mo>-</mo><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub> <mo>+</mo><mn>16</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>-</mo><mn>30</mn><msub><mi>f</mi>
    <mi>i</mi></msub> <mo>+</mo><mn>16</mn><msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>-</mo><msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow>
    <mrow><mn>12</mn><msup><mi>h</mi> <mn>2</mn></msup></mrow></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><msup><mi>f</mi> <mrow><mo>'</mo><mo>'</mo><mo>'</mo></mrow></msup>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>≈</mo> <mfrac><mrow><mo>-</mo><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>3</mn></mrow></msub> <mo>+</mo><mn>8</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub> <mo>-</mo><mn>13</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>+</mo><mn>13</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>-</mo><mn>8</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>2</mn></mrow></msub> <mo>+</mo><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>3</mn></mrow></msub></mrow> <mrow><mn>8</mn><msup><mi>h</mi>
    <mn>3</mn></msup></mrow></mfrac></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><msup><mi>f</mi>
    <mrow><mo>(</mo><mn>4</mn><mo>)</mo></mrow></msup> <mrow><mo>(</mo> <msub><mi>x</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd> <mtd columnalign="left"><mrow><mo>≈</mo>
    <mfrac><mrow><mo>-</mo><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>3</mn></mrow></msub>
    <mo>+</mo><mn>12</mn><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub>
    <mo>-</mo><mn>39</mn><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>+</mo><mn>56</mn><msub><mi>f</mi> <mi>i</mi></msub> <mo>-</mo><mn>39</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>+</mo><mn>12</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>2</mn></mrow></msub> <mo>-</mo><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>3</mn></mrow></msub></mrow> <mrow><mn>6</mn><msup><mi>h</mi>
    <mn>4</mn></msup></mrow></mfrac></mrow></mtd></mtr></mtable></math>
- en: '**What does the <math alttext="upper O left-parenthesis h Superscript k Baseline
    right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>h</mi> <mi>k</mi></msup>
    <mo>)</mo></mrow></math> mean?** It is the order of the numerical approximation
    in *h*. When we replace a derivative using its numerical approximation, we commit
    an error. The <math alttext="upper O left-parenthesis h Superscript k Baseline
    right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>h</mi> <mi>k</mi></msup>
    <mo>)</mo></mrow></math> tells us how much error we are committing. Obviously
    this depends on the size of the mesh *h*. The error should be smaller with finer
    meshes. To derive such error bounds, we use Taylor expansions of f(x+h), f(x-h),
    f(x+2h), f(x-2h), *etc.* and linear combinations of those to determine both the
    desired derivative’s approximation and the order of our finite difference approximation
    in terms of *h*. To be able to use Taylor expansions, we assume that we are dealing
    with functions that *indeed have the required number of derivatives* at the points
    we are evaluating them at. This means that we assume that our function is nice
    enough to allow these derivative evaluations. If the function has singularities
    near these points, then we need to find ways around that, such as using much finer
    meshes near the singularities.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**<math alttext="上标 k 的 h 的 O 左括号"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>h</mi>
    <mi>k</mi></msup> <mo>)</mo></mrow></math> 是什么意思？** 这是*h*的数值逼近的阶数。当我们用数值逼近替换导数时，就会产生误差。
    <math alttext="上标 k 的 h 的 O 左括号"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>h</mi>
    <mi>k</mi></msup> <mo>)</mo></mrow></math> 告诉我们我们产生了多少误差。显然，这取决于网格*h*的大小。误差应该随着网格更细而变小。为了推导这种误差界限，我们使用f(x+h),
    f(x-h), f(x+2h), f(x-2h)等的泰勒展开，以及这些的线性组合来确定所需导数的逼近和我们的有限差分逼近的*h*阶。为了使用泰勒展开，我们假设我们正在处理的函数在我们评估它们的点上*确实具有所需数量的导数*。这意味着我们假设我们的函数足够好，以允许这些导数评估。如果函数在这些点附近有奇点，那么我们需要找到解决方法，比如在奇点附近使用更细的网格。'
- en: 'Example: Let’s solve <math alttext="y double-prime left-parenthesis x right-parenthesis
    equals 1"><mrow><msup><mi>y</mi> <mrow><mo>''</mo><mo>''</mo></mrow></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>1</mn></mrow></math> on [0,1], with
    boundary conditions y(0)=-1 and y(1)=0\. This is a second linear order ordinary
    differential equation on a bounded domain in one dimension.'
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 例子：让我们在[0,1]上解决<math alttext="y 双撇左括号 x 右括号 等于 1"><mrow><msup><mi>y</mi> <mrow><mo>'</mo><mo>'</mo></mrow></msup>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>1</mn></mrow></math>，带有边界条件y(0)=-1和y(1)=0。这是一维有界域上的二阶线性常微分方程。
- en: This example is trivial because the analytical solution is so easy. All we have
    to do is to integrate the equation twice and recover the function without its
    derivatives <math alttext="y left-parenthesis x right-parenthesis equals 0.5 x
    squared plus c 1 x plus c 2"><mrow><mi>y</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>0</mn> <mo>.</mo> <mn>5</mn> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <msub><mi>c</mi> <mn>1</mn></msub> <mi>x</mi> <mo>+</mo> <msub><mi>c</mi>
    <mn>2</mn></msub></mrow></math> where the c’s are the constants of integration.
    We plug the two boundary conditions to find the c’s and obtain the analytical
    solution <math alttext="y left-parenthesis x right-parenthesis equals 0.5 x squared
    plus 0.5 x minus 1"><mrow><mi>y</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>0</mn> <mo>.</mo> <mn>5</mn> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>0</mn> <mo>.</mo> <mn>5</mn> <mi>x</mi> <mo>-</mo> <mn>1</mn></mrow></math>
    . However, the point of this example is to show how to use finite differences
    to compute the *numerical solution*, not the analytical one, since analytical
    solutions are not available for many other differential equations so we might
    as well get good at this. We first discretize the domain [0,1]. We can use as
    many points as we want. The more points the higher dimension we have to deal with
    but the resolution will be better. We’ll use only eight points, so the mesh size
    is *h=1/7* ([Figure 13-7](#Fig_discretize)). Our continuum [0,1] interval is now
    reduced to the eight points (0,1/7,2/7,3/7,4/7,5/7,6/7,1).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很简单，因为解析解非常容易。我们只需对方程积分两次，恢复函数而不带其导数<math alttext="y 左括号 x 右括号 等于 0.5 x
    平方 加 c 1 x 加 c 2"><mrow><mi>y</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>0</mn> <mo>.</mo> <mn>5</mn> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <msub><mi>c</mi> <mn>1</mn></msub> <mi>x</mi> <mo>+</mo> <msub><mi>c</mi>
    <mn>2</mn></msub></mrow></math>，其中c是积分常数。我们将两个边界条件代入以找到c，并获得解析解<math alttext="y
    左括号 x 右括号 等于 0.5 x 平方 加 0.5 x 减 1"><mrow><mi>y</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn> <mo>.</mo> <mn>5</mn> <msup><mi>x</mi>
    <mn>2</mn></msup> <mo>+</mo> <mn>0</mn> <mo>.</mo> <mn>5</mn> <mi>x</mi> <mo>-</mo>
    <mn>1</mn></mrow></math>。然而，这个例子的重点是展示如何使用有限差分来计算*数值解*，而不是解析解，因为对于许多其他微分方程，解析解是不可用的，所以我们最好擅长这个。我们首先离散化域[0,1]。我们可以使用任意多的点。点数越多，我们需要处理的维度就越高，但分辨率会更好。我们只使用八个点，因此网格大小为*h=1/7*（[图13-7](#Fig_discretize)）。我们的连续[0,1]区间现在缩减为八个点（0,1/7,2/7,3/7,4/7,5/7,6/7,1）。
- en: '![250](assets/emai_1307.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![250](assets/emai_1307.png)'
- en: Figure 13-7\. Discretizing the unit interval using eight discrete points, which
    is the same as seven intervals. The step size (or mesh size) is h=1/7.
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-7。使用八个离散点离散化单位区间，这等同于七个间隔。步长（或网格大小）为*h=1/7*。
- en: 'Next, we discretize the differential equation. We can use any finite difference
    scheme to discretize the second derivative. Let’s choose the <math alttext="upper
    O left-parenthesis h squared right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>h</mi>
    <mn>2</mn></msup> <mo>)</mo></mrow></math> central difference, so the discretized
    differential equation becomes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们离散化微分方程。我们可以使用任何有限差分方案来离散化二阶导数。让我们选择<math alttext="上标 h 平方的 O 左括号"><mrow><mi>O</mi>
    <mo>(</mo> <msup><mi>h</mi> <mn>2</mn></msup> <mo>)</mo></mrow></math> 中心差分，因此离散化的微分方程变为：
- en: <math alttext="dollar-sign StartFraction y Subscript i plus 1 Baseline minus
    2 y Subscript i Baseline plus y Subscript i minus 1 Baseline Over h squared EndFraction
    equals 1 for i equals 1 comma 2 comma 3 comma 4 comma 5 comma 6 period dollar-sign"><mrow><mfrac><mrow><msub><mi>y</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>-</mo><mn>2</mn><msub><mi>y</mi>
    <mi>i</mi></msub> <mo>+</mo><msub><mi>y</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow>
    <msup><mi>h</mi> <mn>2</mn></msup></mfrac> <mo>=</mo> <mn>1</mn> <mtext>for</mtext>
    <mi>i</mi> <mo>=</mo> <mn>1</mn> <mo>,</mo> <mn>2</mn> <mo>,</mo> <mn>3</mn> <mo>,</mo>
    <mn>4</mn> <mo>,</mo> <mn>5</mn> <mo>,</mo> <mn>6</mn> <mo>.</mo></mrow></math>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartFraction y Subscript i plus 1 Baseline minus
    2 y Subscript i Baseline plus y Subscript i minus 1 Baseline Over h squared EndFraction
    equals 1 for i equals 1 comma 2 comma 3 comma 4 comma 5 comma 6 period dollar-sign"><mrow><mfrac><mrow><msub><mi>y</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>-</mo><mn>2</mn><msub><mi>y</mi>
    <mi>i</mi></msub> <mo>+</mo><msub><mi>y</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow>
    <msup><mi>h</mi> <mn>2</mn></msup></mfrac> <mo>=</mo> <mn>1</mn> <mtext>for</mtext>
    <mi>i</mi> <mo>=</mo> <mn>1</mn> <mo>,</mo> <mn>2</mn> <mo>,</mo> <mn>3</mn> <mo>,</mo>
    <mn>4</mn> <mo>,</mo> <mn>5</mn> <mo>,</mo> <mn>6</mn> <mo>.</mo></mrow></math>
- en: 'Note that the differential equation is only valid in the *interior* of the
    domain, that is why we do not include the points i=0 and i=7 when we write its
    discrete analogue. We get the values at i=0 and i=7 from the boundary conditions:
    <math alttext="y 0 equals negative 1"><mrow><msub><mi>y</mi> <mn>0</mn></msub>
    <mo>=</mo> <mo>-</mo> <mn>1</mn></mrow></math> and <math alttext="y 7 equals 0"><mrow><msub><mi>y</mi>
    <mn>7</mn></msub> <mo>=</mo> <mn>0</mn></mrow></math> . Now, we have a system
    of six equations six unknowns, <math alttext="y 1 comma y 2 comma y 3 comma y
    4 comma y 5 comma y 6"><mrow><msub><mi>y</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>y</mi>
    <mn>2</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>3</mn></msub> <mo>,</mo> <msub><mi>y</mi>
    <mn>4</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>5</mn></msub> <mo>,</mo> <msub><mi>y</mi>
    <mn>6</mn></msub></mrow></math> :'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，微分方程仅在域的*内部*有效，这就是为什么我们在写其离散模拟时不包括i=0和i=7的原因。我们从边界条件中得到i=0和i=7处的值：<math
    alttext="y 0 equals negative 1"><mrow><msub><mi>y</mi> <mn>0</mn></msub> <mo>=</mo>
    <mo>-</mo> <mn>1</mn></mrow></math> 和 <math alttext="y 7 equals 0"><mrow><msub><mi>y</mi>
    <mn>7</mn></msub> <mo>=</mo> <mn>0</mn></mrow></math>。现在，我们有一个六个未知数的六个方程的系统，<math
    alttext="y 1 comma y 2 comma y 3 comma y 4 comma y 5 comma y 6"><mrow><msub><mi>y</mi>
    <mn>1</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>2</mn></msub> <mo>,</mo> <msub><mi>y</mi>
    <mn>3</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>4</mn></msub> <mo>,</mo> <msub><mi>y</mi>
    <mn>5</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>6</mn></msub></mrow></math>：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column y
    2 minus 2 y 1 minus 1 equals 1 slash 49 2nd Row 1st Column Blank 2nd Column y
    3 minus 2 y 2 plus y 1 equals 1 slash 49 3rd Row 1st Column Blank 2nd Column y
    4 minus 2 y 3 plus y 2 equals 1 slash 49 4th Row 1st Column Blank 2nd Column y
    5 minus 2 y 4 plus y 3 equals 1 slash 49 5th Row 1st Column Blank 2nd Column y
    6 minus 2 y 5 plus y 4 equals 1 slash 49 6th Row 1st Column Blank 2nd Column 0
    minus 2 y 6 plus y 5 equals 1 slash 49 EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><msub><mi>y</mi> <mn>2</mn></msub> <mo>-</mo> <mn>2</mn>
    <msub><mi>y</mi> <mn>1</mn></msub> <mo>-</mo> <mn>1</mn> <mo>=</mo> <mn>1</mn>
    <mo>/</mo> <mn>49</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><msub><mi>y</mi>
    <mn>3</mn></msub> <mo>-</mo> <mn>2</mn> <msub><mi>y</mi> <mn>2</mn></msub> <mo>+</mo>
    <msub><mi>y</mi> <mn>1</mn></msub> <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><msub><mi>y</mi> <mn>4</mn></msub> <mo>-</mo>
    <mn>2</mn> <msub><mi>y</mi> <mn>3</mn></msub> <mo>+</mo> <msub><mi>y</mi> <mn>2</mn></msub>
    <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><msub><mi>y</mi>
    <mn>5</mn></msub> <mo>-</mo> <mn>2</mn> <msub><mi>y</mi> <mn>4</mn></msub> <mo>+</mo>
    <msub><mi>y</mi> <mn>3</mn></msub> <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><msub><mi>y</mi> <mn>6</mn></msub> <mo>-</mo>
    <mn>2</mn> <msub><mi>y</mi> <mn>5</mn></msub> <mo>+</mo> <msub><mi>y</mi> <mn>4</mn></msub>
    <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mn>0</mn>
    <mo>-</mo> <mn>2</mn> <msub><mi>y</mi> <mn>6</mn></msub> <mo>+</mo> <msub><mi>y</mi>
    <mn>5</mn></msub> <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column y
    2 minus 2 y 1 minus 1 equals 1 slash 49 2nd Row 1st Column Blank 2nd Column y
    3 minus 2 y 2 plus y 1 equals 1 slash 49 3rd Row 1st Column Blank 2nd Column y
    4 minus 2 y 3 plus y 2 equals 1 slash 49 4th Row 1st Column Blank 2nd Column y
    5 minus 2 y 4 plus y 3 equals 1 slash 49 5th Row 1st Column Blank 2nd Column y
    6 minus 2 y 5 plus y 4 equals 1 slash 49 6th Row 1st Column Blank 2nd Column 0
    minus 2 y 6 plus y 5 equals 1 slash 49 EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><msub><mi>y</mi> <mn>2</mn></msub> <mo>-</mo> <mn>2</mn>
    <msub><mi>y</mi> <mn>1</mn></msub> <mo>-</mo> <mn>1</mn> <mo>=</mo> <mn>1</mn>
    <mo>/</mo> <mn>49</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><msub><mi>y</mi>
    <mn>3</mn></msub> <mo>-</mo> <mn>2</mn> <msub><mi>y</mi> <mn>2</mn></msub> <mo>+</mo>
    <msub><mi>y</mi> <mn>1</mn></msub> <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><msub><mi>y</mi> <mn>4</mn></msub> <mo>-</mo>
    <mn>2</mn> <msub><mi>y</mi> <mn>3</mn></msub> <mo>+</mo> <msub><mi>y</mi> <mn>2</mn></msub>
    <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><msub><mi>y</mi>
    <mn>5</mn></msub> <mo>-</mo> <mn>2</mn> <msub><mi>y</mi> <mn>4</mn></msub> <mo>+</mo>
    <msub><mi>y</mi> <mn>3</mn></msub> <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><msub><mi>y</mi> <mn>6</mn></msub> <mo>-</mo>
    <mn>2</mn> <msub><mi>y</mi> <mn>5</mn></msub> <mo>+</mo> <msub><mi>y</mi> <mn>4</mn></msub>
    <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mn>0</mn>
    <mo>-</mo> <mn>2</mn> <msub><mi>y</mi> <mn>6</mn></msub> <mo>+</mo> <msub><mi>y</mi>
    <mn>5</mn></msub> <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr></mtable></math>
- en: 'So now we moved from the continuum world to the linear algebra world:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在从连续世界转移到线性代数世界：
- en: <math alttext="dollar-sign Start 6 By 6 Matrix 1st Row 1st Column negative 2
    2nd Column 1 3rd Column 0 4th Column 0 5th Column 0 6th Column 0 2nd Row 1st Column
    1 2nd Column negative 2 3rd Column 1 4th Column 0 5th Column 0 6th Column 0 3rd
    Row 1st Column 0 2nd Column 1 3rd Column negative 2 4th Column 1 5th Column 0
    6th Column 0 4th Row 1st Column 0 2nd Column 0 3rd Column 1 4th Column negative
    2 5th Column 1 6th Column 0 5th Row 1st Column 0 2nd Column 0 3rd Column 0 4th
    Column 1 5th Column negative 2 6th Column 1 6th Row 1st Column 0 2nd Column 0
    3rd Column 0 4th Column 0 5th Column 1 6th Column negative 2 EndMatrix Start 6
    By 1 Matrix 1st Row  y 1 2nd Row  y 2 3rd Row  y 3 4th Row  y 4 5th Row  y 5 6th
    Row  y 6 EndMatrix equals Start 6 By 1 Matrix 1st Row  1 slash 49 plus 1 2nd Row  1
    slash 49 3rd Row  1 slash 49 4th Row  1 slash 49 5th Row  1 slash 49 6th Row  1
    slash 49 EndMatrix dollar-sign"><mrow><mfenced close=")" open="("><mtable><mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd></mtr></mtable></mfenced> <mfenced
    close=")" open="("><mtable><mtr><mtd><msub><mi>y</mi> <mn>1</mn></msub></mtd></mtr>
    <mtr><mtd><msub><mi>y</mi> <mn>2</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>y</mi>
    <mn>3</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>y</mi> <mn>4</mn></msub></mtd></mtr>
    <mtr><mtd><msub><mi>y</mi> <mn>5</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>y</mi>
    <mn>6</mn></msub></mtd></mtr></mtable></mfenced> <mo>=</mo> <mfenced close=")"
    open="("><mtable><mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mn>49</mn> <mo>+</mo>
    <mn>1</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr>
    <mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn>
    <mo>/</mo> <mn>49</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn> <mo>/</mo>
    <mn>49</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign Start 6 By 6 Matrix 1st Row 1st Column negative 2
    2nd Column 1 3rd Column 0 4th Column 0 5th Column 0 6th Column 0 2nd Row 1st Column
    1 2nd Column negative 2 3rd Column 1 4th Column 0 5th Column 0 6th Column 0 3rd
    Row 1st Column 0 2nd Column 1 3rd Column negative 2 4th Column 1 5th Column 0
    6th Column 0 4th Row 1st Column 0 2nd Column 0 3rd Column 1 4th Column negative
    2 5th Column 1 6th Column 0 5th Row 1st Column 0 2nd Column 0 3rd Column 0 4th
    Column 1 5th Column negative 2 6th Column 1 6th Row 1st Column 0 2nd Column 0
    3rd Column 0 4th Column 0 5th Column 1 6th Column negative 2 EndMatrix Start 6
    By 1 Matrix 1st Row  y 1 2nd Row  y 2 3rd Row  y 3 4th Row  y 4 5th Row  y 5 6th
    Row  y 6 EndMatrix equals Start 6 By 1 Matrix 1st Row  1 slash 49 plus 1 2nd Row  1
    slash 49 3rd Row  1 slash 49 4th Row  1 slash 49 5th Row  1 slash 49 6th Row  1
    slash 49 EndMatrix dollar-sign"><mrow><mfenced close=")" open="("><mtable><mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd></mtr></mtable></mfenced> <mfenced
    close=")" open="("><mtable><mtr><mtd><msub><mi>y</mi> <mn>1</mn></msub></mtd></mtr>
    <mtr><mtd><msub><mi>y</mi> <mn>2</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>y</mi>
    <mn>3</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>y</mi> <mn>4</mn></msub></mtd></mtr>
    <mtr><mtd><msub><mi>y</mi> <mn>5</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>y</mi>
    <mn>6</mn></msub></mtd></mtr></mtable></mfenced> <mo>=</mo> <mfenced close=")"
    open="("><mtable><mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mn>49</mn> <mo>+</mo>
    <mn>1</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr>
    <mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn>
    <mo>/</mo> <mn>49</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn> <mo>/</mo>
    <mn>49</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: Solving this system amounts to *inverting* the tridiagonal matrix above, which
    is the discrete analogue of our second order derivative operator. In the continuum
    world we *integrate* the differential operator to recover *y(x)* and in the discrete
    world we *invert* the discrete operator to recover the discrete values <math alttext="y
    Subscript i"><msub><mi>y</mi> <mi>i</mi></msub></math> . Keep the curse of dimensionality
    in mind when using more points to discretize the domain.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个系统相当于*求逆*上面的三对角矩阵，这是我们二阶导数算子的离散模拟。在连续世界中，我们*积分*微分算子以恢复*y(x)*，在离散世界中，我们*求逆*离散算子以恢复离散值<math
    alttext="y Subscript i"><msub><mi>y</mi> <mi>i</mi></msub></math>。在使用更多点离散化域时，请记住维度的诅咒。
- en: Obviously we must compare the discrete values <math alttext="y Subscript i"><msub><mi>y</mi>
    <mi>i</mi></msub></math> with their exact counterparts <math alttext="y left-parenthesis
    x Subscript i Baseline right-parenthesis"><mrow><mi>y</mi> <mo>(</mo> <msub><mi>x</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow></math> to see how well our finite difference
    scheme with only eight discrete points performed ([Figure 13-8](#Fig_numerical_analytical)).
    [Figure 13-9](#Fig_numerical_analytical_graph) shows the graph of the numerical
    solution (using only four discrete points) against the exact analytical solution.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们必须将离散值<math alttext="y Subscript i"><msub><mi>y</mi> <mi>i</mi></msub></math>与它们的精确对应物<math
    alttext="y left-parenthesis x Subscript i Baseline right-parenthesis"><mrow><mi>y</mi>
    <mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow></math>进行比较，以查看我们仅使用八个离散点执行的有限差分方案的性能（[图13-8](#Fig_numerical_analytical)）。[图13-9](#Fig_numerical_analytical_graph)显示了数值解（仅使用四个离散点）与精确解析解的图形。
- en: '![250](assets/emai_1308.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![250](assets/emai_1308.png)'
- en: Figure 13-8\. Comparing the numerical solution to the exact analytical solution
    at each discrete point.
  id: totrans-116
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-8\. 在每个离散点比较数值解和精确解析解。
- en: '![250](assets/emai_1309.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![250](assets/emai_1309.png)'
- en: Figure 13-9\. Graph of the numerical solution (using only four discrete points)
    against the exact analytical solution (solid line).
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-9\. 数值解的图形（仅使用四个离散点）与精确解析解的对比（实线）。
- en: Now we can use finite differences to discretize *any* differential equation
    of any order or type, on a domain in any dimension. All we have to do is discretize
    the domain and decide on finite difference schemes to approximate the derivatives
    at all the discrete points in the interior of the domain.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用有限差分来离散化*任何*任意阶或类型的微分方程，在任何维度的域上。我们所要做的就是离散化域并决定有限差分方案，以近似域内所有离散点处的导数。
- en: 'Example: Discretize the one dimensional heat equation <math alttext="u Subscript
    t Baseline equals alpha u Subscript x x"><mrow><msub><mi>u</mi> <mi>t</mi></msub>
    <mo>=</mo> <mi>α</mi> <msub><mi>u</mi> <mrow><mi>x</mi><mi>x</mi></mrow></msub></mrow></math>
    in the interior of the interval <math alttext="x element-of left-parenthesis 0
    comma 1 right-parenthesis"><mrow><mi>x</mi> <mo>∈</mo> <mo>(</mo> <mn>0</mn> <mo>,</mo>
    <mn>1</mn> <mo>)</mo></mrow></math> . This is a second order linear partial differential
    equation on a bounded spatial domain in one dimension.'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：在区间<math alttext="x element-of left-parenthesis 0 comma 1 right-parenthesis"><mrow><mi>x</mi>
    <mo>∈</mo> <mo>(</mo> <mn>0</mn> <mo>,</mo> <mn>1</mn> <mo>)</mo></mrow></math>的内部离散化一维热方程<math
    alttext="u Subscript t Baseline equals alpha u Subscript x x"><mrow><msub><mi>u</mi>
    <mi>t</mi></msub> <mo>=</mo> <mi>α</mi> <msub><mi>u</mi> <mrow><mi>x</mi><mi>x</mi></mrow></msub></mrow></math>。这是一维有界空间域上的二阶线性偏微分方程。
- en: Here, u=u(x,t) is a function of two variables, so our discretization scheme
    should address both coordinates. We can discretize only in space and keep time
    continuous, only in time and keep space continuous, or both in space and time.
    We always have more than one numerical route. Options are good. If we discretize
    in both space and time, then we end up with a system of algebraic equations. If
    we discretize only in space and not in time, then we end up with a system of ordinary
    differential equations. Since the PDE is linear then the discretized system is
    linear as well.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，u=u(x,t)是两个变量的函数，因此我们的离散化方案应该涉及两个坐标。我们可以只在空间中离散化并保持时间连续，只在时间中离散化并保持空间连续，或者在空间和时间中都离散化。我们总是有多个数值路径。选择是好的。如果我们在空间和时间中都离散化，那么我们最终得到一个代数方程组。如果我们只在空间中离散化而不在时间中离散化，那么我们最终得到一个常微分方程组。由于PDE是线性的，因此离散化系统也是线性的。
- en: 'Let’s write down a full discrete scheme: To discretize in space, let’s use
    a second order centered difference. And to discretize in time, let’s use a forward
    difference:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写出一个完整的离散方案：为了在空间中离散化，让我们使用二阶中心差分。为了在时间中离散化，让我们使用向前差分：
- en: <math alttext="dollar-sign StartFraction u Subscript i comma j plus 1 Baseline
    minus u Subscript i comma j Baseline Over s EndFraction equals StartFraction u
    Subscript i plus 1 comma j Baseline minus 2 u Subscript i comma j Baseline plus
    u Subscript i minus 1 comma j Baseline Over h squared EndFraction for i equals
    1 comma 2 comma ellipsis comma n and j equals 1 comma 2 comma ellipsis dollar-sign"><mrow><mfrac><mrow><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>-</mo><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow> <mi>s</mi></mfrac> <mo>=</mo>
    <mfrac><mrow><msub><mi>u</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>-</mo><mn>2</mn><msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>+</mo><msub><mi>u</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub></mrow>
    <msup><mi>h</mi> <mn>2</mn></msup></mfrac> <mtext>for</mtext> <mi>i</mi> <mo>=</mo>
    <mn>1</mn> <mo>,</mo> <mn>2</mn> <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <mi>n</mi> <mtext>and</mtext>
    <mi>j</mi> <mo>=</mo> <mn>1</mn> <mo>,</mo> <mn>2</mn> <mo>,</mo> <mo>⋯</mo></mrow></math>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartFraction u Subscript i comma j plus 1 Baseline
    minus u Subscript i comma j Baseline Over s EndFraction equals StartFraction u
    Subscript i plus 1 comma j Baseline minus 2 u Subscript i comma j Baseline plus
    u Subscript i minus 1 comma j Baseline Over h squared EndFraction for i equals
    1 comma 2 comma ellipsis comma n and j equals 1 comma 2 comma ellipsis dollar-sign"><mrow><mfrac><mrow><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>-</mo><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow> <mi>s</mi></mfrac> <mo>=</mo>
    <mfrac><mrow><msub><mi>u</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>-</mo><mn>2</mn><msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>+</mo><msub><mi>u</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub></mrow>
    <msup><mi>h</mi> <mn>2</mn></msup></mfrac> <mtext>for</mtext> <mi>i</mi> <mo>=</mo>
    <mn>1</mn> <mo>,</mo> <mn>2</mn> <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <mi>n</mi> <mtext>and</mtext>
    <mi>j</mi> <mo>=</mo> <mn>1</mn> <mo>,</mo> <mn>2</mn> <mo>,</mo> <mo>⋯</mo></mrow></math>
- en: In such equations *u(x,t)* can be known at some initial time (*u(x,0)=g(x)*)
    and we want to know *u(x,t)* time evolves. In the numerical scheme above, the
    subscript *j* stands for discrete time, so the unknowns are <math alttext="u Subscript
    i comma j plus 1"><msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub></math>
    .
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的方程中，*u(x,t)* 在某个初始时间可以被确定（*u(x,0)=g(x)*），我们想要知道 *u(x,t)* 随时间的演变。在上面的数值方案中，下标
    *j* 代表离散时间，因此未知数是 <math alttext="u Subscript i comma j plus 1"><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub></math>。
- en: (finish this up)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: （完成这部分）
- en: Finite Elements
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有限元
- en: Finite element methods are different than finite difference methods in the sense
    that they operate on a *weak formulation* of the PDE as opposed to operating directly
    on the PDE. A weak formulation is *weighted and averaged*, so we are thinking
    integrals and integration by parts. We will come back to this shortly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有限元方法与有限差分方法不同，因为它们是基于PDE的*弱形式*而不是直接操作PDE。弱形式是*加权和平均*的，因此我们考虑积分和分部积分。我们很快会回到这个问题。
- en: 'Before discussing the general idea of finite elements, let’s observe [Figure 13-10](#Fig_finite_elements)
    a little: This shows a finite element solution of a PDE on top of a circular domain.
    The discretization of the domain uses a triangular mesh and the solution seems
    to be approximated by a piecewise linear function. We can use other polygonal
    shapes for the meshes, and we can use *smoother* functions than piecewise linear
    such as piecewise quadratic or higher degree polynomials. The tradeoff for more
    smoothness is more computation.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论有限元的一般概念之前，让我们稍微观察一下[图13-10](#Fig_finite_elements)：这显示了在圆形域上的PDE的有限元解。域的离散化使用三角形网格，解似乎被分段线性函数逼近。我们可以使用其他多边形形状的网格，我们可以使用比分段线性更*平滑*的函数，如分段二次或更高次多项式。更平滑的代价是更多的计算。
- en: '![250](assets/emai_1310.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![250](assets/emai_1310.png)'
- en: Figure 13-10\. Finite elements solution over a circular domain [(image source)](https://commons.wikimedia.org/wiki/File:Finite_element_solution.svg).
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-10。在圆形域上的有限元解[(图片来源)](https://commons.wikimedia.org/wiki/File:Finite_element_solution.svg)。
- en: 'Let’s demonstrate how the finite element method gives a numerical approximation
    to the solution of the following PDE:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们演示有限元方法如何给出以下PDE的数值近似解：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column minus
    normal upper Delta u left-parenthesis x comma y right-parenthesis equals f left-parenthesis
    x comma y right-parenthesis for left-parenthesis x comma y right-parenthesis element-of
    normal upper Omega subset-of double-struck upper R squared 2nd Row 1st Column
    Blank 2nd Column u left-parenthesis x comma y right-parenthesis equals 0 for left-parenthesis
    x comma y right-parenthesis element-of b o u n d a r y Subscript normal upper
    Omega Baseline EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mo>-</mo>
    <mi>Δ</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mtext>for</mtext> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>∈</mo> <mi>Ω</mi> <mo>⊂</mo> <msup><mi>ℝ</mi> <mn>2</mn></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn> <mtext>for</mtext> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>b</mi> <mi>o</mi>
    <mi>u</mi> <mi>n</mi> <mi>d</mi> <mi>a</mi> <mi>r</mi> <msub><mi>y</mi> <mi>Ω</mi></msub></mrow></mtd></mtr></mtable></math>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column minus
    normal upper Delta u left-parenthesis x comma y right-parenthesis equals f left-parenthesis
    x comma y right-parenthesis for left-parenthesis x comma y right-parenthesis element-of
    normal upper Omega subset-of double-struck upper R squared 2nd Row 1st Column
    Blank 2nd Column u left-parenthesis x comma y right-parenthesis equals 0 for left-parenthesis
    x comma y right-parenthesis element-of b o u n d a r y Subscript normal upper
    Omega Baseline EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mo>-</mo>
    <mi>Δ</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mtext>for</mtext> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>∈</mo> <mi>Ω</mi> <mo>⊂</mo> <msup><mi>ℝ</mi> <mn>2</mn></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn> <mtext>for</mtext> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>b</mi> <mi>o</mi>
    <mi>u</mi> <mi>n</mi> <mi>d</mi> <mi>a</mi> <mi>r</mi> <msub><mi>y</mi> <mi>Ω</mi></msub></mrow></mtd></mtr></mtable></math>
- en: This is Poisson equation (appears in electrostatics). There is no time evolution.
    f(x,y) is specified and we are looking for an unknown function u(x,y) which is
    zero at the entire boundary, and whose second derivatives <math alttext="u Subscript
    x x"><msub><mi>u</mi> <mrow><mi>x</mi><mi>x</mi></mrow></msub></math> and <math
    alttext="u Subscript y y"><msub><mi>u</mi> <mrow><mi>y</mi><mi>y</mi></mrow></msub></math>
    add up to *-f(x,y)*. This PDE is very well studied and we have formulas for its
    analytical solution, but we are only interested in the numerical approximation
    of the solution using the finite element method.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是泊松方程（出现在静电学中）。没有时间演变。f(x,y)是指定的，我们正在寻找一个未知函数u(x,y)，它在整个边界上为零，并且其二阶导数 <math
    alttext="u Subscript x x"><msub><mi>u</mi> <mrow><mi>x</mi><mi>x</mi></mrow></msub></math>
    和 <math alttext="u Subscript y y"><msub><mi>u</mi> <mrow><mi>y</mi><mi>y</mi></mrow></msub></math>
    加起来为*-f(x,y)*。这个PDE已经被广泛研究，我们有其解析解的公式，但我们只对使用有限元方法进行数值逼近感兴趣。
- en: For this, we will produce an approximation of the unknown function *u(x,y)*
    that lives in an *infinite* dimensional space using a known function that lives
    in a *finite* dimensional space. Finite dimensional spaces are spanned only by
    *finitely many linearly independent functions*. We get to choose these *basis
    functions* so we make sure that our choice makes our computations very easy. We
    usually choose piecewise linear functions or piecewise polynomial functions, each
    *supported minimally on the mesh*. This means that the basis function is nonzero
    only top of one or two adjacent elements of the mesh, and zero everywhere else.
    Thus, an integration involving this function on the whole domain of the PDE would
    reduce to an integration on only one or two elements of the mesh.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将使用一个存在于*无限*维空间中的未知函数*u(x,y)*的近似，使用一个存在于*有限*维空间中的已知函数。有限维空间仅由*有限多个线性无关函数*张成。我们可以选择这些*基函数*，以确保我们的选择使我们的计算非常容易。我们通常选择分段线性函数或分段多项式函数，每个*最小支持在网格上*。这意味着基函数仅在网格的一个或两个相邻元素的顶部为非零，而在其他地方为零。因此，涉及该函数在PDE的整个域上的积分将简化为在网格的一个或两个元素上的积分。
- en: 'After choosing these *basis functions* each supported on few mesh elements,
    we approximate the true solution *u(x,y)* by a linear combination of these easy
    and locally supported basis functions:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择这些*基函数*之后，每个基函数都支持在少量网格元素上，我们通过这些简单且局部支持的基函数的线性组合来近似真实解*u(x,y)*：
- en: <math alttext="dollar-sign u left-parenthesis x comma y right-parenthesis almost-equals
    u 1 b a s i s 1 left-parenthesis x comma y right-parenthesis plus u 2 b a s i
    s 2 left-parenthesis x comma y right-parenthesis plus ellipsis u Subscript n Baseline
    b a s i s Subscript n Baseline left-parenthesis x comma y right-parenthesis dollar-sign"><mrow><mi>u</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>≈</mo>
    <msub><mi>u</mi> <mn>1</mn></msub> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi>
    <msub><mi>s</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>+</mo> <msub><mi>u</mi> <mn>2</mn></msub> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <mo>⋯</mo> <msub><mi>u</mi>
    <mi>n</mi></msub> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign u left-parenthesis x comma y right-parenthesis almost-equals
    u 1 b a s i s 1 left-parenthesis x comma y right-parenthesis plus u 2 b a s i
    s 2 left-parenthesis x comma y right-parenthesis plus ellipsis u Subscript n Baseline
    b a s i s Subscript n Baseline left-parenthesis x comma y right-parenthesis dollar-sign"><mrow><mi>u</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>≈</mo>
    <msub><mi>u</mi> <mn>1</mn></msub> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi>
    <msub><mi>s</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>+</mo> <msub><mi>u</mi> <mn>2</mn></msub> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <mo>⋯</mo> <msub><mi>u</mi>
    <mi>n</mi></msub> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow></mrow></math>
- en: 'Now we must find the constants <math alttext="u Subscript i"><msub><mi>u</mi>
    <mi>i</mi></msub></math> of the linear combination. Therefore, we reduced our
    problem from solving for the unknown function *u(x,y)* in the continuum to solving
    for the unknown vector of coefficients <math alttext="left-parenthesis u 1 comma
    u 2 comma ellipsis comma u Subscript n Baseline right-parenthesis"><mrow><mo>(</mo>
    <msub><mi>u</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>u</mi> <mn>2</mn></msub>
    <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <msub><mi>u</mi> <mi>n</mi></msub> <mo>)</mo></mrow></math>
    . We must choose them so that the approximation <math alttext="u 1 e l e m e n
    t 1 left-parenthesis x comma y right-parenthesis plus u 2 e l e m e n t 2 left-parenthesis
    x comma y right-parenthesis plus ellipsis u Subscript n Baseline e l e m e n t
    Subscript n Baseline left-parenthesis x comma y right-parenthesis"><mrow><msub><mi>u</mi>
    <mn>1</mn></msub> <mi>e</mi> <mi>l</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi>
    <msub><mi>t</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>+</mo> <msub><mi>u</mi> <mn>2</mn></msub> <mi>e</mi> <mi>l</mi>
    <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo>
    <mo>⋯</mo> <msub><mi>u</mi> <mi>n</mi></msub> <mi>e</mi> <mi>l</mi> <mi>e</mi>
    <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mi>n</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow></mrow></math> satisfies the
    PDE, in some sense. We have *n* unknowns, so we must write *n* equations and solve
    a system of *n* equations *n* unknowns. We get these from the PDE, or *its weak
    formulation*. To get a weak formulation of the PDE, we multiply it by a function
    *v(x,y)*, integrate over our domain, then use *integration by parts* to get rid
    of higher order derivatives. Remember that the less derivatives we have the closer
    to the unknown function we get. Let do this step by step:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须找到线性组合的常数<math alttext="u Subscript i"><msub><mi>u</mi> <mi>i</mi></msub></math>。因此，我们将问题从在连续介质中解决未知函数*u(x,y)*降低到解决未知系数向量<math
    alttext="left-parenthesis u 1 comma u 2 comma ellipsis comma u Subscript n Baseline
    right-parenthesis"><mrow><mo>(</mo> <msub><mi>u</mi> <mn>1</mn></msub> <mo>,</mo>
    <msub><mi>u</mi> <mn>2</mn></msub> <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <msub><mi>u</mi>
    <mi>n</mi></msub> <mo>)</mo></mrow></math>。我们必须选择它们，使得近似<math alttext="u 1 e l
    e m e n t 1 left-parenthesis x comma y right-parenthesis plus u 2 e l e m e n
    t 2 left-parenthesis x comma y right-parenthesis plus ellipsis u Subscript n Baseline
    e l e m e n t Subscript n Baseline left-parenthesis x comma y right-parenthesis"><mrow><msub><mi>u</mi>
    <mn>1</mn></msub> <mi>e</mi> <mi>l</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi>
    <msub><mi>t</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>+</mo> <msub><mi>u</mi> <mn>2</mn></msub> <mi>e</mi> <mi>l</mi>
    <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo>
    <mo>⋯</mo> <msub><mi>u</mi> <mi>n</mi></msub> <mi>e</mi> <mi>l</mi> <mi>e</mi>
    <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mi>n</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow></mrow></math>满足PDE，在某种意义上。我们有*n*个未知数，所以我们必须写*n*个方程并解决一个*n*个未知数的系统。我们从PDE或*其弱形式*中得到这些。为了得到PDE的弱形式，我们将其乘以一个函数*v(x,y)*，在整个域上积分，然后使用*分部积分*来摆脱高阶导数。记住我们有的导数越少，我们就越接近未知函数。让我们一步一步来做：
- en: 'The original PDE is:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 原始PDE是：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column minus
    normal upper Delta u left-parenthesis x comma y right-parenthesis equals f left-parenthesis
    x comma y right-parenthesis for left-parenthesis x comma y right-parenthesis element-of
    normal upper Omega subset-of double-struck upper R squared 2nd Row 1st Column
    Blank 2nd Column u left-parenthesis x comma y right-parenthesis equals 0 for left-parenthesis
    x comma y right-parenthesis element-of b o u n d a r y Subscript normal upper
    Omega Baseline EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mo>-</mo>
    <mi>Δ</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mtext>for</mtext> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>∈</mo> <mi>Ω</mi> <mo>⊂</mo> <msup><mi>ℝ</mi> <mn>2</mn></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn> <mtext>for</mtext> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>b</mi> <mi>o</mi>
    <mi>u</mi> <mi>n</mi> <mi>d</mi> <mi>a</mi> <mi>r</mi> <msub><mi>y</mi> <mi>Ω</mi></msub></mrow></mtd></mtr></mtable></math>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column minus
    normal upper Delta u left-parenthesis x comma y right-parenthesis equals f left-parenthesis
    x comma y right-parenthesis for left-parenthesis x comma y right-parenthesis element-of
    normal upper Omega subset-of double-struck upper R squared 2nd Row 1st Column
    Blank 2nd Column u left-parenthesis x comma y right-parenthesis equals 0 for left-parenthesis
    x comma y right-parenthesis element-of b o u n d a r y Subscript normal upper
    Omega Baseline EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mo>-</mo>
    <mi>Δ</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mtext>for</mtext> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>∈</mo> <mi>Ω</mi> <mo>⊂</mo> <msup><mi>ℝ</mi> <mn>2</mn></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn> <mtext>for</mtext> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>b</mi> <mi>o</mi>
    <mi>u</mi> <mi>n</mi> <mi>d</mi> <mi>a</mi> <mi>r</mi> <msub><mi>y</mi> <mi>Ω</mi></msub></mrow></mtd></mtr></mtable></math>
- en: 'Multiply the PDE by a function *v(x,y)* and integrate over the entire domain.
    This is a *weak formulation* of the PDE since it makes it satisfied in an integral
    form as opposed to a point by point form:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将PDE乘以一个函数*v(x,y)*并在整个域上积分。这是PDE的*弱形式*，因为它以积分形式满足，而不是逐点形式：
- en: <math alttext="dollar-sign minus integral Underscript normal upper Omega Endscripts
    normal upper Delta u left-parenthesis x comma y right-parenthesis v left-parenthesis
    x comma y right-parenthesis d x d y equals integral Underscript normal upper Omega
    Endscripts f left-parenthesis x comma y right-parenthesis v left-parenthesis x
    comma y right-parenthesis d x d y dollar-sign"><mrow><mo>-</mo> <msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>Δ</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>=</mo>
    <msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></math>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign minus integral Underscript normal upper Omega Endscripts
    normal upper Delta u left-parenthesis x comma y right-parenthesis v left-parenthesis
    x comma y right-parenthesis d x d y equals integral Underscript normal upper Omega
    Endscripts f left-parenthesis x comma y right-parenthesis v left-parenthesis x
    comma y right-parenthesis d x d y dollar-sign"><mrow><mo>-</mo> <msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>Δ</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>=</mo>
    <msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></math>
- en: 'Note that the operator <math alttext="normal upper Delta equals normal nabla
    period normal nabla"><mrow><mi>Δ</mi> <mo>=</mo> <mi>∇</mi> <mo>.</mo> <mi>∇</mi></mrow></math>
    , the dot product of two derivative operators. Integration by parts helps us get
    rid of one of the derivatives by moving it over to the other function inside the
    integral. This doesn’t come for free: In the process of doing this, it picks up
    a negative sign and another integral term that operates on the boundary of the
    domain. This new integral on the boundary integrates the product of two anti-derivatives.
    The boundary term needs the outward unit normal vector to the boundary <math alttext="ModifyingAbove
    n With right-arrow"><mover accent="true"><mi>n</mi> <mo>→</mo></mover></math>
    :'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意算子<math alttext="normal upper Delta equals normal nabla period normal nabla"><mrow><mi>Δ</mi>
    <mo>=</mo> <mi>∇</mi> <mo>.</mo> <mi>∇</mi></mrow></math>，两个导数算子的点积。通过分部积分，我们可以通过将一个导数移到积分内的另一个函数来摆脱其中一个导数。这并非免费：在这个过程中，它会带上一个负号和另一个作用于域边界的积分项。域边界上的新积分积分了两个反导数的乘积。边界项需要外法向量到边界<math
    alttext="ModifyingAbove n With right-arrow"><mover accent="true"><mi>n</mi> <mo>→</mo></mover></math>：
- en: <math alttext="dollar-sign integral Underscript normal upper Omega Endscripts
    normal nabla u left-parenthesis x comma y right-parenthesis period normal nabla
    v left-parenthesis x comma y right-parenthesis d x d y minus integral Underscript
    b o u n d a r y Subscript normal upper Omega Baseline Endscripts v left-parenthesis
    x comma y right-parenthesis normal nabla u left-parenthesis x comma y right-parenthesis
    period ModifyingAbove n With right-arrow d s equals integral Underscript normal
    upper Omega Endscripts f left-parenthesis x comma y right-parenthesis v left-parenthesis
    x comma y right-parenthesis d x d y dollar-sign"><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub>
    <mi>∇</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>.</mo> <mi>∇</mi> <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>-</mo> <msub><mo>∫</mo>
    <mrow><mi>b</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mi>a</mi><mi>r</mi><msub><mi>y</mi>
    <mi>Ω</mi></msub></mrow></msub> <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mi>∇</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>.</mo> <mover accent="true"><mi>n</mi>
    <mo>→</mo></mover> <mi>d</mi> <mi>s</mi> <mo>=</mo> <msub><mo>∫</mo> <mi>Ω</mi></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></math>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign integral Underscript normal upper Omega Endscripts
    normal nabla u left-parenthesis x comma y right-parenthesis period normal nabla
    v left-parenthesis x comma y right-parenthesis d x d y minus integral Underscript
    b o u n d a r y Subscript normal upper Omega Baseline Endscripts v left-parenthesis
    x comma y right-parenthesis normal nabla u left-parenthesis x comma y right-parenthesis
    period ModifyingAbove n With right-arrow d s equals integral Underscript normal
    upper Omega Endscripts f left-parenthesis x comma y right-parenthesis v left-parenthesis
    x comma y right-parenthesis d x d y dollar-sign"><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub>
    <mi>∇</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>.</mo> <mi>∇</mi> <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>-</mo> <msub><mo>∫</mo>
    <mrow><mi>b</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mi>a</mi><mi>r</mi><msub><mi>y</mi>
    <mi>Ω</mi></msub></mrow></msub> <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mi>∇</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>.</mo> <mover accent="true"><mi>n</mi>
    <mo>→</mo></mover> <mi>d</mi> <mi>s</mi> <mo>=</mo> <msub><mo>∫</mo> <mi>Ω</mi></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></math>
- en: 'We can choose *v(x,y)=0* on the boundary and that makes the whole boundary
    term disappear:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择*v(x,y)=0*在边界上，这样整个边界项就消失了：
- en: <math alttext="dollar-sign integral Underscript normal upper Omega Endscripts
    normal nabla u left-parenthesis x comma y right-parenthesis period normal nabla
    v left-parenthesis x comma y right-parenthesis d x d y equals integral Underscript
    normal upper Omega Endscripts f left-parenthesis x comma y right-parenthesis v
    left-parenthesis x comma y right-parenthesis d x d y dollar-sign"><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>∇</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi> <mi>v</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi>
    <mi>y</mi> <mo>=</mo> <msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>v</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi>
    <mi>y</mi></mrow></math>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign integral Underscript normal upper Omega Endscripts
    normal nabla u left-parenthesis x comma y right-parenthesis period normal nabla
    v left-parenthesis x comma y right-parenthesis d x d y equals integral Underscript
    normal upper Omega Endscripts f left-parenthesis x comma y right-parenthesis v
    left-parenthesis x comma y right-parenthesis d x d y dollar-sign"><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>∇</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi> <mi>v</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi>
    <mi>y</mi> <mo>=</mo> <msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>v</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi>
    <mi>y</mi></mrow></math>
- en: 'Now we replace *u(x,y)* with its finite dimensional approximation:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们用有限维近似替换*u(x,y)*：
- en: <math alttext="dollar-sign integral Underscript normal upper Omega Endscripts
    normal nabla left-parenthesis u 1 b a s i s 1 left-parenthesis x comma y right-parenthesis
    plus u 2 b a s i s 2 left-parenthesis x comma y right-parenthesis plus ellipsis
    u Subscript n Baseline b a s i s Subscript n Baseline left-parenthesis x comma
    y right-parenthesis right-parenthesis period normal nabla v left-parenthesis x
    comma y right-parenthesis d x d y equals integral Underscript normal upper Omega
    Endscripts f left-parenthesis x comma y right-parenthesis v left-parenthesis x
    comma y right-parenthesis d x d y comma dollar-sign"><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub>
    <mi>∇</mi> <mrow><mo>(</mo> <msub><mi>u</mi> <mn>1</mn></msub> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>u</mi> <mn>2</mn></msub>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo>
    <mo>⋯</mo> <msub><mi>u</mi> <mi>n</mi></msub> <mi>b</mi> <mi>a</mi> <mi>s</mi>
    <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi> <mi>v</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>=</mo> <msub><mo>∫</mo> <mi>Ω</mi></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>,</mo></mrow></math>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign integral Underscript normal upper Omega Endscripts
    normal nabla left-parenthesis u 1 b a s i s 1 left-parenthesis x comma y right-parenthesis
    plus u 2 b a s i s 2 left-parenthesis x comma y right-parenthesis plus ellipsis
    u Subscript n Baseline b a s i s Subscript n Baseline left-parenthesis x comma
    y right-parenthesis right-parenthesis period normal nabla v left-parenthesis x
    comma y right-parenthesis d x d y equals integral Underscript normal upper Omega
    Endscripts f left-parenthesis x comma y right-parenthesis v left-parenthesis x
    comma y right-parenthesis d x d y comma dollar-sign"><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub>
    <mi>∇</mi> <mrow><mo>(</mo> <msub><mi>u</mi> <mn>1</mn></msub> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>u</mi> <mn>2</mn></msub>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo>
    <mo>⋯</mo> <msub><mi>u</mi> <mi>n</mi></msub> <mi>b</mi> <mi>a</mi> <mi>s</mi>
    <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi> <mi>v</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>=</mo> <msub><mo>∫</mo> <mi>Ω</mi></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>,</mo></mrow></math>
- en: 'which is equivalent to:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于：
- en: <math alttext="dollar-sign integral Underscript normal upper Omega Endscripts
    left-parenthesis u 1 normal nabla b a s i s 1 left-parenthesis x comma y right-parenthesis
    plus u 2 normal nabla b a s i s 2 left-parenthesis x comma y right-parenthesis
    plus ellipsis u Subscript n Baseline normal nabla b a s i s Subscript n Baseline
    left-parenthesis x comma y right-parenthesis right-parenthesis period normal nabla
    v left-parenthesis x comma y right-parenthesis d x d y equals integral Underscript
    normal upper Omega Endscripts f left-parenthesis x comma y right-parenthesis v
    left-parenthesis x comma y right-parenthesis d x d y dollar-sign"><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mrow><mo>(</mo> <msub><mi>u</mi> <mn>1</mn></msub> <mi>∇</mi>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>1</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo>
    <msub><mi>u</mi> <mn>2</mn></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi>
    <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <mo>⋯</mo> <msub><mi>u</mi> <mi>n</mi></msub>
    <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>.</mo> <mi>∇</mi> <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>=</mo> <msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></math>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign integral Underscript normal upper Omega Endscripts
    left-parenthesis u 1 normal nabla b a s i s 1 left-parenthesis x comma y right-parenthesis
    plus u 2 normal nabla b a s i s 2 left-parenthesis x comma y right-parenthesis
    plus ellipsis u Subscript n Baseline normal nabla b a s i s Subscript n Baseline
    left-parenthesis x comma y right-parenthesis right-parenthesis period normal nabla
    v left-parenthesis x comma y right-parenthesis d x d y equals integral Underscript
    normal upper Omega Endscripts f left-parenthesis x comma y right-parenthesis v
    left-parenthesis x comma y right-parenthesis d x d y dollar-sign"><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mrow><mo>(</mo> <msub><mi>u</mi> <mn>1</mn></msub> <mi>∇</mi>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>1</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo>
    <msub><mi>u</mi> <mn>2</mn></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi>
    <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <mo>⋯</mo> <msub><mi>u</mi> <mi>n</mi></msub>
    <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>.</mo> <mi>∇</mi> <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>=</mo> <msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></math>
- en: 'This is it: We can choose *n* different functions for *v(x,y)* to get *n* different
    equations in *n* unknowns (the <math alttext="u Subscript i"><msub><mi>u</mi>
    <mi>i</mi></msub></math> ’s are the unknowns). A common theme is that everytime
    we get to pick, we pick things that do not complicate our computation life. The
    easiest choices for *v(x,y)* are the *n* basis functions that we already have,
    since these produce many cancellations when inetgrated against each other (*orthogonality*),
    and when integrated against themselves produce the number 1 (*normality*). The
    basis functions that we orginially choose form an *orthonormal* set of functions.
    All for the business of making our life easier. Therefore, the *n* equations are:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样：我们可以选择*n*个不同的函数作为*v(x,y)*，得到*n*个未知数的*n*个不同方程（<math alttext="u Subscript
    i"><msub><mi>u</mi> <mi>i</mi></msub></math> 是未知数）。一个共同的主题是，每次我们都可以选择，我们选择那些不会使我们的计算变得复杂的东西。*v(x,y)*的最简单选择是我们已经有的*n*个基函数，因为这些在相互积分时产生许多抵消（*正交性*），并且在与自身积分时产生数字1（*正规性*）。我们最初选择的基函数形成了一组*正交归一*的函数。一切都是为了让我们的生活更轻松。因此，这*n*个方程是：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column integral
    Underscript normal upper Omega Endscripts left-parenthesis u 1 normal nabla b
    a s i s 1 left-parenthesis x comma y right-parenthesis plus u 2 normal nabla b
    a s i s 2 left-parenthesis x comma y right-parenthesis plus ellipsis u Subscript
    n Baseline normal nabla b a s i s Subscript n Baseline left-parenthesis x comma
    y right-parenthesis right-parenthesis period normal nabla b a s i s 1 left-parenthesis
    x comma y right-parenthesis d x d y equals integral Underscript normal upper Omega
    Endscripts f left-parenthesis x comma y right-parenthesis b a s i s 1 left-parenthesis
    x comma y right-parenthesis d x d y 2nd Row 1st Column Blank 2nd Column integral
    Underscript normal upper Omega Endscripts left-parenthesis u 1 normal nabla b
    a s i s 1 left-parenthesis x comma y right-parenthesis plus u 2 normal nabla b
    a s i s 2 left-parenthesis x comma y right-parenthesis plus ellipsis u Subscript
    n Baseline normal nabla b a s i s Subscript n Baseline left-parenthesis x comma
    y right-parenthesis right-parenthesis period normal nabla b a s i s 2 left-parenthesis
    x comma y right-parenthesis d x d y equals integral Underscript normal upper Omega
    Endscripts f left-parenthesis x comma y right-parenthesis b a s i s 2 left-parenthesis
    x comma y right-parenthesis d x d y 3rd Row 1st Column Blank 2nd Column  ellipsis
    4th Row 1st Column Blank 2nd Column integral Underscript normal upper Omega Endscripts
    left-parenthesis u 1 normal nabla b a s i s 1 left-parenthesis x comma y right-parenthesis
    plus u 2 normal nabla b a s i s 2 left-parenthesis x comma y right-parenthesis
    plus ellipsis u Subscript n Baseline normal nabla b a s i s Subscript n Baseline
    left-parenthesis x comma y right-parenthesis right-parenthesis period normal nabla
    b a s i s Subscript n Baseline left-parenthesis x comma y right-parenthesis d
    x d y equals integral Underscript normal upper Omega Endscripts f left-parenthesis
    x comma y right-parenthesis b a s i s Subscript n Baseline left-parenthesis x
    comma y right-parenthesis d x d y EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mrow><mo>(</mo> <msub><mi>u</mi>
    <mn>1</mn></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>+</mo> <msub><mi>u</mi> <mn>2</mn></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <mo>⋯</mo> <msub><mi>u</mi>
    <mi>n</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi>
    <msub><mi>s</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>=</mo> <msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mrow><mo>(</mo> <msub><mi>u</mi> <mn>1</mn></msub> <mi>∇</mi>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>1</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo>
    <msub><mi>u</mi> <mn>2</mn></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi>
    <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <mo>⋯</mo> <msub><mi>u</mi> <mi>n</mi></msub>
    <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>=</mo> <msub><mo>∫</mo> <mi>Ω</mi></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mo>⋯</mo></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mrow><mo>(</mo>
    <msub><mi>u</mi> <mn>1</mn></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi>
    <mi>i</mi> <msub><mi>s</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>u</mi> <mn>2</mn></msub> <mi>∇</mi>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo>
    <mo>⋯</mo> <msub><mi>u</mi> <mi>n</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>=</mo> <msub><mo>∫</mo> <mi>Ω</mi></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column integral
    Underscript normal upper Omega Endscripts left-parenthesis u 1 normal nabla b
    a s i s 1 left-parenthesis x comma y right-parenthesis plus u 2 normal nabla b
    a s i s 2 left-parenthesis x comma y right-parenthesis plus ellipsis u Subscript
    n Baseline normal nabla b a s i s Subscript n Baseline left-parenthesis x comma
    y right-parenthesis right-parenthesis period normal nabla b a s i s 1 left-parenthesis
    x comma y right-parenthesis d x d y equals integral Underscript normal upper Omega
    Endscripts f left-parenthesis x comma y right-parenthesis b a s i s 1 left-parenthesis
    x comma y right-parenthesis d x d y 2nd Row 1st Column Blank 2nd Column integral
    Underscript normal upper Omega Endscripts left-parenthesis u 1 normal nabla b
    a s i s 1 left-parenthesis x comma y right-parenthesis plus u 2 normal nabla b
    a s i s 2 left-parenthesis x comma y right-parenthesis plus ellipsis u Subscript
    n Baseline normal nabla b a s i s Subscript n Baseline left-parenthesis x comma
    y right-parenthesis right-parenthesis period normal nabla b a s i s 2 left-parenthesis
    x comma y right-parenthesis d x d y equals integral Underscript normal upper Omega
    Endscripts f left-parenthesis x comma y right-parenthesis b a s i s 2 left-parenthesis
    x comma y right-parenthesis d x d y 3rd Row 1st Column Blank 2nd Column  ellipsis
    4th Row 1st Column Blank 2nd Column integral Underscript normal upper Omega Endscripts
    left-parenthesis u 1 normal nabla b a s i s 1 left-parenthesis x comma y right-parenthesis
    plus u 2 normal nabla b a s i s 2 left-parenthesis x comma y right-parenthesis
    plus ellipsis u Subscript n Baseline normal nabla b a s i s Subscript n Baseline
    left-parenthesis x comma y right-parenthesis right-parenthesis period normal nabla
    b a s i s Subscript n Baseline left-parenthesis x comma y right-parenthesis d
    x d y equals integral Underscript normal upper Omega Endscripts f left-parenthesis
    x comma y right-parenthesis b a s i s Subscript n Baseline left-parenthesis x
    comma y right-parenthesis d x d y EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mrow><mo>(</mo> <msub><mi>u</mi>
    <mn>1</mn></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>+</mo> <msub><mi>u</mi> <mn>2</mn></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <mo>⋯</mo> <msub><mi>u</mi>
    <mi>n</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi>
    <msub><mi>s</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>=</mo> <msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mrow><mo>(</mo> <msub><mi>u</mi> <mn>1</mn></msub> <mi>∇</mi>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>1</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo>
    <msub><mi>u</mi> <mn>2</mn></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi>
    <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <mo>⋯</mo> <msub><mi>u</mi> <mi>n</mi></msub>
    <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>=</mo> <msub><mo>∫</mo> <mi>Ω</mi></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mo>⋯</mo></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mrow><mo>(</mo>
    <msub><mi>u</mi> <mn>1</mn></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi>
    <mi>i</mi> <msub><mi>s</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>u</mi> <mn>2</mn></msub> <mi>∇</mi>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo>
    <mo>⋯</mo> <msub><mi>u</mi> <mi>n</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>=</mo> <msub><mo>∫</mo> <mi>Ω</mi></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr></mtable></math>
- en: 'Finally we solve the system of *n* equations *n* unknowns, which we set in
    a linear algebra form:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们解决了* n *方程* n *未知数的系统，我们将其设置为线性代数形式：
- en: <math alttext="dollar-sign Start 4 By 4 Matrix 1st Row 1st Column integral Underscript
    normal upper Omega Endscripts normal nabla b a s i s 1 left-parenthesis x comma
    y right-parenthesis period normal nabla b a s i s 1 left-parenthesis x comma y
    right-parenthesis d x d y 2nd Column integral Underscript normal upper Omega Endscripts
    normal nabla b a s i s 2 left-parenthesis x comma y right-parenthesis period normal
    nabla b a s i s 1 left-parenthesis x comma y right-parenthesis d x d y 3rd Column  ellipsis
    4th Column integral Underscript normal upper Omega Endscripts normal nabla b a
    s i s Subscript n Baseline left-parenthesis x comma y right-parenthesis period
    normal nabla b a s i s 1 left-parenthesis x comma y right-parenthesis d x d y
    2nd Row 1st Column integral Underscript normal upper Omega Endscripts normal nabla
    b a s i s 1 left-parenthesis x comma y right-parenthesis period normal nabla b
    a s i s 2 left-parenthesis x comma y right-parenthesis d x d y 2nd Column integral
    Underscript normal upper Omega Endscripts normal nabla b a s i s 2 left-parenthesis
    x comma y right-parenthesis period normal nabla b a s i s 2 left-parenthesis x
    comma y right-parenthesis d x d y 3rd Column  ellipsis 4th Column integral Underscript
    normal upper Omega Endscripts normal nabla b a s i s Subscript n Baseline left-parenthesis
    x comma y right-parenthesis period normal nabla b a s i s 2 left-parenthesis x
    comma y right-parenthesis d x d y 3rd Row 1st Column  ellipsis 2nd Column  ellipsis
    3rd Column  ellipsis 4th Column  ellipsis 4th Row 1st Column integral Underscript
    normal upper Omega Endscripts normal nabla b a s i s 1 left-parenthesis x comma
    y right-parenthesis period normal nabla b a s i s Subscript n Baseline left-parenthesis
    x comma y right-parenthesis d x d y 2nd Column integral Underscript normal upper
    Omega Endscripts normal nabla b a s i s 2 left-parenthesis x comma y right-parenthesis
    period normal nabla b a s i s Subscript n Baseline left-parenthesis x comma y
    right-parenthesis d x d y 3rd Column  ellipsis 4th Column integral Underscript
    normal upper Omega Endscripts normal nabla b a s i s Subscript n Baseline left-parenthesis
    x comma y right-parenthesis period normal nabla b a s i s Subscript n Baseline
    left-parenthesis x comma y right-parenthesis d x d y EndMatrix Start 4 By 1 Matrix
    1st Row  u 1 2nd Row  u 2 3rd Row   ellipsis 4th Row  u Subscript n Baseline EndMatrix
    equals Start 4 By 1 Matrix 1st Row  integral Underscript normal upper Omega Endscripts
    f left-parenthesis x comma y right-parenthesis b a s i s 1 left-parenthesis x
    comma y right-parenthesis d x d y 2nd Row  integral Underscript normal upper Omega
    Endscripts f left-parenthesis x comma y right-parenthesis b a s i s 2 left-parenthesis
    x comma y right-parenthesis d x d y 3rd Row   ellipsis 4th Row  integral Underscript
    normal upper Omega Endscripts f left-parenthesis x comma y right-parenthesis b
    a s i s Subscript n Baseline left-parenthesis x comma y right-parenthesis d x
    d y EndMatrix dollar-sign"><mrow><mfenced close=")" open="("><mtable><mtr><mtd><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd> <mtd><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd> <mtd><mo>⋯</mo></mtd>
    <mtd><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr>
    <mtr><mtd><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd>
    <mtd><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd>
    <mtd><mo>⋯</mo></mtd> <mtd><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>∇</mi>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>.</mo>
    <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd><mo>⋮</mo></mtd>
    <mtd><mo>⋮</mo></mtd> <mtd><mo>⋯</mo></mtd> <mtd><mo>⋮</mo></mtd></mtr> <mtr><mtd><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd> <mtd><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd> <mtd><mo>⋯</mo></mtd>
    <mtd><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr></mtable></mfenced>
    <mfenced close=")" open="("><mtable><mtr><mtd><msub><mi>u</mi> <mn>1</mn></msub></mtd></mtr>
    <mtr><mtd><msub><mi>u</mi> <mn>2</mn></msub></mtd></mtr> <mtr><mtd><mo>⋮</mo></mtd></mtr>
    <mtr><mtd><msub><mi>u</mi> <mi>n</mi></msub></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close=")" open="("><mtable><mtr><mtd><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>1</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd><mo>⋮</mo></mtd></mtr>
    <mtr><mtd><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>b</mi> <mi>a</mi> <mi>s</mi>
    <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign Start 4 By 4 Matrix 1st Row 1st Column integral Underscript
    normal upper Omega Endscripts normal nabla b a s i s 1 left-parenthesis x comma
    y right-parenthesis period normal nabla b a s i s 1 left-parenthesis x comma y
    right-parenthesis d x d y 2nd Column integral Underscript normal upper Omega Endscripts
    normal nabla b a s i s 2 left-parenthesis x comma y right-parenthesis period normal
    nabla b a s i s 1 left-parenthesis x comma y right-parenthesis d x d y 3rd Column  ellipsis
    4th Column integral Underscript normal upper Omega Endscripts normal nabla b a
    s i s Subscript n Baseline left-parenthesis x comma y right-parenthesis period
    normal nabla b a s i s 1 left-parenthesis x comma y right-parenthesis d x d y
    2nd Row 1st Column integral Underscript normal upper Omega Endscripts normal nabla
    b a s i s 1 left-parenthesis x comma y right-parenthesis period normal nabla b
    a s i s 2 left-parenthesis x comma y right-parenthesis d x d y 2nd Column integral
    Underscript normal upper Omega Endscripts normal nabla b a s i s 2 left-parenthesis
    x comma y right-parenthesis period normal nabla b a s i s 2 left-parenthesis x
    comma y right-parenthesis d x d y 3rd Column  ellipsis 4th Column integral Underscript
    normal upper Omega Endscripts normal nabla b a s i s Subscript n Baseline left-parenthesis
    x comma y right-parenthesis period normal nabla b a s i s 2 left-parenthesis x
    comma y right-parenthesis d x d y 3rd Row 1st Column  ellipsis 2nd Column  ellipsis
    3rd Column  ellipsis 4th Column  ellipsis 4th Row 1st Column integral Underscript
    normal upper Omega Endscripts normal nabla b a s i s 1 left-parenthesis x comma
    y right-parenthesis period normal nabla b a s i s Subscript n Baseline left-parenthesis
    x comma y right-parenthesis d x d y 2nd Column integral Underscript normal upper
    Omega Endscripts normal nabla b a s i s 2 left-parenthesis x comma y right-parenthesis
    period normal nabla b a s i s Subscript n Baseline left-parenthesis x comma y
    right-parenthesis d x d y 3rd Column  ellipsis 4th Column integral Underscript
    normal upper Omega Endscripts normal nabla b a s i s Subscript n Baseline left-parenthesis
    x comma y right-parenthesis period normal nabla b a s i s Subscript n Baseline
    left-parenthesis x comma y right-parenthesis d x d y EndMatrix Start 4 By 1 Matrix
    1st Row  u 1 2nd Row  u 2 3rd Row   ellipsis 4th Row  u Subscript n Baseline EndMatrix
    equals Start 4 By 1 Matrix 1st Row  integral Underscript normal upper Omega Endscripts
    f left-parenthesis x comma y right-parenthesis b a s i s 1 left-parenthesis x
    comma y right-parenthesis d x d y 2nd Row  integral Underscript normal upper Omega
    Endscripts f left-parenthesis x comma y right-parenthesis b a s i s 2 left-parenthesis
    x comma y right-parenthesis d x d y 3rd Row   ellipsis 4th Row  integral Underscript
    normal upper Omega Endscripts f left-parenthesis x comma y right-parenthesis b
    a s i s Subscript n Baseline left-parenthesis x comma y right-parenthesis d x
    d y EndMatrix dollar-sign"><mrow><mfenced close=")" open="("><mtable><mtr><mtd><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd> <mtd><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd> <mtd><mo>⋯</mo></mtd>
    <mtd><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr>
    <mtr><mtd><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd>
    <mtd><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd>
    <mtd><mo>⋯</mo></mtd> <mtd><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>∇</mi>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>.</mo>
    <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd><mo>⋮</mo></mtd>
    <mtd><mo>⋮</mo></mtd> <mtd><mo>⋯</mo></mtd> <mtd><mo>⋮</mo></mtd></mtr> <mtr><mtd><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd> <mtd><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd> <mtd><mo>⋯</mo></mtd>
    <mtd><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr></mtable></mfenced>
    <mfenced close=")" open="("><mtable><mtr><mtd><msub><mi>u</mi> <mn>1</mn></msub></mtd></mtr>
    <mtr><mtd><msub><mi>u</mi> <mn>2</mn></msub></mtd></mtr> <mtr><mtd><mo>⋮</mo></mtd></mtr>
    <mtr><mtd><msub><mi>u</mi> <mi>n</mi></msub></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close=")" open="("><mtable><mtr><mtd><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>1</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd><mo>⋮</mo></mtd></mtr>
    <mtr><mtd><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>b</mi> <mi>a</mi> <mi>s</mi>
    <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: Recall that we know the function *f(x,y)*, all the basis functions, and the
    domain <math alttext="normal upper Omega"><mi>Ω</mi></math> , so all we have to
    do is solve the system of equations. This system is *sparse* because most of these
    integrals are zero. We chose the basis functions with small support for this reason.
    We never want to solve a *dense* system of equations.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们知道函数*f(x,y)*、所有基函数和域<math alttext="normal upper Omega"><mi>Ω</mi></math>，所以我们要做的就是解方程组。这个系统是*稀疏*的，因为大多数这些积分为零。出于这个原因，我们选择了支持较小的基函数。我们永远不想解一个*密集*的方程组。
- en: 'Of course we have many questions and a rich literature on finite elements that
    deals with them:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们对有限元有许多问题和丰富的文献来处理这些问题：
- en: Do all PDEs have a weak formulation that allow us to do things like this? (Yes
    because we can always multiply PDEs with *v* functions and integrate by parts,
    but some PDEs have better structures to carry out simplifiying computations than
    others).
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有PDE都有一个允许我们做这样事情的弱形式吗？（是的，因为我们总是可以将PDE与*v*函数相乘并进行部分积分，但有些PDE比其他PDE具有更好的结构来进行简化计算）。
- en: What about the *energy formulations* or *variational principles* of PDEs, are
    they related? (Yes, they are related. Look up the Ritz method. We hinted at this
    in the chapter on Operations Research and the calculus of variations, when we
    related minimizing energy functionals to solving PDEs. One thing to keep in mind
    here is that most PDEs have a weak formulation but not all of them have an energy
    minimization formulation. One of the reasons I got my Ph.D. was that I discovered
    an energy formulation for the PDE that I was working with. It was by complete
    chance. All I did was one lucky *weak formulation* followed by an integration
    by parts. Just like we did in this section. Trial and error are underestimated
    in this life).
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDE的*能量形式*或*变分原理*与之相关吗？（是的，它们相关。查找里兹方法。我们在运筹学和变分微积分章节中暗示了这一点，当我们将最小化能量泛函与解PDE联系起来时。在这里要记住的一件事是，大多数PDE具有弱形式，但并非所有PDE都有能量最小化形式。我获得博士学位的一个原因是我发现了我正在研究的PDE的能量形式。这完全是偶然。我所做的只是一个幸运的*弱形式*，然后是部分积分。就像我们在本节中所做的那样。在这个生活中，试错是被低估的）。
- en: What about Sobolov spaces, why do we study them in advanced courses on PDEs?
    (Because we need to set our functions *u*, *v*, and the basis functions, in the
    appropriate *function spaces* that tell us that all the computations and the approximations
    that we are using are valid. For example, we don’t want the involved integrals
    that contain our functions and their derivatives to blow up).
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sobolov空间是怎么回事，为什么我们在PDE的高级课程中学习它们？（因为我们需要将我们的函数*u*、*v*和基函数设置在适当的*函数空间*中，告诉我们我们正在使用的所有计算和近似是有效的。例如，我们不希望包含我们的函数及其导数的涉及积分爆炸）。
- en: Can we use nonuniform meshes to adjust for the more detailed part of the domain
    such as the one in [Figure 13-11](#Fig_nonuniform_mesh)? (Yes, nothing in our
    discussion relies strictly on a uniform mesh).
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用非均匀网格来调整域的更详细部分，比如[图13-11](#Fig_nonuniform_mesh)中的部分吗？（是的，我们讨论中的内容并不严格依赖于均匀网格）。
- en: '![150](assets/emai_1311.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![150](assets/emai_1311.png)'
- en: Figure 13-11\. A two dimensional domain with a nonuniform triangular mesh [*(image
    source)*](https://commons.wikimedia.org/wiki/File:Example_of_2D_mesh.png).
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-11。一个具有非均匀三角形网格的二维域[*(图片来源)*](https://commons.wikimedia.org/wiki/File:Example_of_2D_mesh.png)。
- en: How many basis functions do we need? (As many as our mesh elements).
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要多少基函数？（和我们的网格元素一样多）。
- en: Under what conditions does the approximate solution converge to the true solution?
    (Welcome to finite element analysis).
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在什么条件下，近似解会收敛到真实解？（欢迎来到有限元分析）。
- en: 'How is this used in applications? (All the time. It started with mechanics
    and structural designs: loads, stresses, and strains; but now the finite element
    method is used to *numerically* solve all kinds of PDEs whose spatial domains
    have complex geometries).'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这在应用中如何使用？（一直在使用。它始于力学和结构设计：载荷、应力和应变；但现在有限元方法被用来*数值*解决各种具有复杂几何空间域的PDE）。
- en: What could go wrong? (As always, the curse of dimensionality. We need more mesh
    elements for higher resolution, so the system of equations that we end up having
    to solve grows exponenially with the number of mesh elements. No bueno. Ideally,
    we want a mesh that is not detailed in places where it doesn’t need to be and
    more detailed in more interesting parts of the domain.)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能出什么问题？（一如既往，维度的诅咒。我们需要更多的网格元素以获得更高的分辨率，因此我们最终需要解决的方程组随着网格元素数量的增加呈指数增长。不好。理想情况下，我们希望网格在不需要详细的地方不详细，并在域的更有趣的部分更详细）。
- en: What else could complicate matters? (For PDEs whose *domain evolves in time*,
    we need meshes that evolve in time accordingly).
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有什么可能使事情复杂化？（对于*域随时间演变*的PDE，我们需要相应随时间演变的网格）。
- en: Can AI help learn an appropriate mesh given a certain geometry and PDE? (Yes,
    we will see this soon in this chapter).
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AI能帮助学习给定几何和PDE的适当网格吗？（是的，我们将在本章中很快看到这一点）。
- en: Before moving on, we note that the finite element method is a finite dimensional
    mesh dependent method that approximates the solution of the PDE. Later in this
    chapter we will learn about meshless neural network methods.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们注意到有限元方法是一个有限维度的网格依赖方法，用于近似PDE的解。在本章的后面，我们将学习无网格神经网络方法。
- en: Variational or Energy Methods
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变分或能量方法
- en: Some PDEs are very special in the sense that their solution minimizes an energy
    functional. We say that such a PDE possesses a *variational principle*. Poisson
    equation, the one we just solved using finite elements, is one of these lucky
    PDEs. When a PDE possesses a variational principle, it opens for us another route
    to understand its solution, via studying the energy functional that it happens
    to minimize.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write Poisson equation and the energy functional that its solution minimizes,
    without going through the details of why this is the case:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column normal
    upper Delta u left-parenthesis x comma y right-parenthesis equals f left-parenthesis
    x comma y right-parenthesis for left-parenthesis x comma y right-parenthesis element-of
    normal upper Omega subset-of double-struck upper R squared 2nd Row 1st Column
    Blank 2nd Column u left-parenthesis x comma y right-parenthesis equals 0 for left-parenthesis
    x comma y right-parenthesis element-of b o u n d a r y Subscript normal upper
    Omega Baseline EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mi>Δ</mi>
    <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mtext>for</mtext> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>∈</mo> <mi>Ω</mi> <mo>⊂</mo> <msup><mi>ℝ</mi> <mn>2</mn></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn> <mtext>for</mtext> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>b</mi> <mi>o</mi>
    <mi>u</mi> <mi>n</mi> <mi>d</mi> <mi>a</mi> <mi>r</mi> <msub><mi>y</mi> <mi>Ω</mi></msub></mrow></mtd></mtr></mtable></math><math
    alttext="dollar-sign upper E left-parenthesis u left-parenthesis x comma y right-parenthesis
    right-parenthesis equals integral Underscript normal upper Omega Endscripts StartAbsoluteValue
    normal nabla u left-parenthesis x comma y right-parenthesis EndAbsoluteValue squared
    plus 2 f left-parenthesis x comma y right-parenthesis d x d y period dollar-sign"><mrow><mi>E</mi>
    <mrow><mo>(</mo> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mo>∫</mo> <mi>Ω</mi></msub>
    <msup><mrow><mo>|</mo><mi>∇</mi><mi>u</mi><mrow><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo></mrow><mo>|</mo></mrow>
    <mn>2</mn></msup> <mo>+</mo> <mn>2</mn> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi>
    <mo>.</mo></mrow></math>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can exploit this new knowledge to numerically approximate the solution
    of the PDE: Look for an approximate minimizing scheme of the energy functional.
    Similar to the finite elements method, we project our infinite dimensional solution
    <math alttext="u left-parenthesis x comma y right-parenthesis"><mrow><mi>u</mi>
    <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow></math> onto a finite
    dimensional space, where we get to choose the basis elements:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign u left-parenthesis x comma y right-parenthesis almost-equals
    u 1 b a s i s 1 left-parenthesis x comma y right-parenthesis plus u 2 b a s i
    s 2 left-parenthesis x comma y right-parenthesis plus ellipsis u Subscript n Baseline
    b a s i s Subscript n Baseline left-parenthesis x comma y right-parenthesis dollar-sign"><mrow><mi>u</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>≈</mo>
    <msub><mi>u</mi> <mn>1</mn></msub> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi>
    <msub><mi>s</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>+</mo> <msub><mi>u</mi> <mn>2</mn></msub> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <mo>⋯</mo> <msub><mi>u</mi>
    <mi>n</mi></msub> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign u left-parenthesis x comma y right-parenthesis almost-equals
    u 1 b a s i s 1 left-parenthesis x comma y right-parenthesis plus u 2 b a s i
    s 2 left-parenthesis x comma y right-parenthesis plus ellipsis u Subscript n Baseline
    b a s i s Subscript n Baseline left-parenthesis x comma y right-parenthesis dollar-sign"><mrow><mi>u</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>≈</mo>
    <msub><mi>u</mi> <mn>1</mn></msub> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi>
    <msub><mi>s</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>+</mo> <msub><mi>u</mi> <mn>2</mn></msub> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <mo>⋯</mo> <msub><mi>u</mi>
    <mi>n</mi></msub> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow></mrow></math>
- en: and we must again solve for the numbers <math alttext="left-parenthesis u 1
    comma u 2 comma ellipsis comma u Subscript n Baseline right-parenthesis"><mrow><mo>(</mo>
    <msub><mi>u</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>u</mi> <mn>2</mn></msub>
    <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <msub><mi>u</mi> <mi>n</mi></msub> <mo>)</mo></mrow></math>
    . To do this, we plug the approximate u(x,y) into the formula of the energy functional.
    Since we know all the basis elements, this is now a *function* of <math alttext="left-parenthesis
    u 1 comma u 2 comma ellipsis comma u Subscript n Baseline right-parenthesis"><mrow><mo>(</mo>
    <msub><mi>u</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>u</mi> <mn>2</mn></msub>
    <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <msub><mi>u</mi> <mi>n</mi></msub> <mo>)</mo></mrow></math>
    , which we can minimize using standard calculus methods. Done!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须再次解出数字<u_1, u_2, ..., u_n>。为了做到这一点，我们将近似的u(x, y)代入能量泛函的公式中。由于我们知道所有的基元素，这现在是<u_1,
    u_2, ..., u_n>的*函数*，我们可以使用标准微积分方法来最小化。完成！
- en: This method is fairly general and introduces us smoothly into the calculus of
    variations, which is about finding optima of functionals instead of functions,
    like in normal calculus.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法相当通用，并将我们顺利引入变分微积分，这是关于寻找泛函的最优解而不是函数的，就像在正常微积分中一样。
- en: Monte Carlo Methods
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蒙特卡洛方法
- en: 'We are now used to switching our brain to probabilistic thinking in order to
    solve deterministic problems. We did that with the stochastic gradient descent
    for minimizing loss functions, multiplication of large matrices, randomized singular
    value decomposition of a large matrix, random walks on graphs to identify communities,
    rank webpages, and other purposes. The most famous introductory examples to Monte
    Carlo methods are:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在习惯于将大脑转换为概率思维，以解决确定性问题。我们用随机梯度下降来最小化损失函数，相乘大矩阵，对大矩阵进行随机奇异值分解，图上的随机游走来识别社区，排名网页等等。蒙特卡洛方法最著名的入门示例有：
- en: 'Estimating <math alttext="pi"><mi>π</mi></math> by generating many random points
    <math alttext="left-parenthesis x Subscript r a n d o m Baseline comma y Subscript
    r a n d o m Baseline right-parenthesis"><mrow><mo>(</mo> <msub><mi>x</mi> <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub>
    <mo>,</mo> <msub><mi>y</mi> <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub>
    <mo>)</mo></mrow></math> in a unit square, and finding the proportion that lies
    inside the inscribed quarter circle of radius 1: <math alttext="x Subscript r
    a n d o m Superscript 2 Baseline plus y Subscript r a n d o m Superscript 2 Baseline
    less-than-or-equal-to 1"><mrow><msubsup><mi>x</mi> <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow>
    <mn>2</mn></msubsup> <mo>+</mo> <msubsup><mi>y</mi> <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow>
    <mn>2</mn></msubsup> <mo>≤</mo> <mn>1</mn></mrow></math> . Now we can estimate
    the probability of landing in the quarter circle:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在单位正方形内生成许多随机点<x_random, y_random>，并找到落在半径为1的内切四分之一圆内的比例：<x_random^2 + y_random^2
    ≤ 1>。现在我们可以估计落入四分之一圆内的概率：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column upper
    P r o b left-parenthesis point inside the quarter circle right-parenthesis 2nd
    Row 1st Column Blank 2nd Column equals StartFraction area of quarter circle of
    radius 1 Over area of unit square EndFraction 3rd Row 1st Column Blank 2nd Column
    equals StartFraction pi Over 4 EndFraction 4th Row 1st Column Blank 2nd Column
    almost-equals StartFraction number of times point is inside the quarter circle
    Over total number of points generated EndFraction period EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><mi>P</mi> <mi>r</mi> <mi>o</mi>
    <mi>b</mi> <mo>(</mo> <mtext>point</mtext> <mtext>inside</mtext> <mtext>the</mtext>
    <mtext>quarter</mtext> <mtext>circle</mtext> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd
    columnalign="left"><mrow><mo>=</mo> <mfrac><mrow><mtext>area</mtext><mtext>of</mtext><mtext>quarter</mtext><mtext>circle</mtext><mtext>of</mtext><mtext>radius</mtext><mtext>1</mtext></mrow>
    <mrow><mtext>area</mtext><mtext>of</mtext><mtext>unit</mtext><mtext>square</mtext></mrow></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>=</mo> <mfrac><mi>π</mi> <mn>4</mn></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>≈</mo> <mfrac><mrow><mtext>number</mtext><mtext>of</mtext><mtext>times</mtext><mtext>point</mtext><mtext>is</mtext><mtext>inside</mtext><mtext>the</mtext><mtext>quarter</mtext><mtext>circle</mtext></mrow>
    <mrow><mtext>total</mtext><mtext>number</mtext><mtext>of</mtext><mtext>points</mtext><mtext>generated</mtext></mrow></mfrac>
    <mo>.</mo></mrow></mtd></mtr></mtable></math>
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column upper
    P r o b left-parenthesis point inside the quarter circle right-parenthesis 2nd
    Row 1st Column Blank 2nd Column equals StartFraction area of quarter circle of
    radius 1 Over area of unit square EndFraction 3rd Row 1st Column Blank 2nd Column
    equals StartFraction pi Over 4 EndFraction 4th Row 1st Column Blank 2nd Column
    almost-equals StartFraction number of times point is inside the quarter circle
    Over total number of points generated EndFraction period EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><mi>P</mi> <mi>r</mi> <mi>o</mi>
    <mi>b</mi> <mo>(</mo> <mtext>point</mtext> <mtext>inside</mtext> <mtext>the</mtext>
    <mtext>quarter</mtext> <mtext>circle</mtext> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd
    columnalign="left"><mrow><mo>=</mo> <mfrac><mrow><mtext>area</mtext><mtext>of</mtext><mtext>quarter</mtext><mtext>circle</mtext><mtext>of</mtext><mtext>radius</mtext><mtext>1</mtext></mrow>
    <mrow><mtext>area</mtext><mtext>of</mtext><mtext>unit</mtext><mtext>square</mtext></mrow></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>=</mo> <mfrac><mi>π</mi> <mn>4</mn></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>≈</mo> <mfrac><mrow><mtext>number</mtext><mtext>of</mtext><mtext>times</mtext><mtext>point</mtext><mtext>is</mtext><mtext>inside</mtext><mtext>the</mtext><mtext>quarter</mtext><mtext>circle</mtext></mrow>
    <mrow><mtext>total</mtext><mtext>number</mtext><mtext>of</mtext><mtext>points</mtext><mtext>generated</mtext></mrow></mfrac>
    <mo>.</mo></mrow></mtd></mtr></mtable></math>
- en: 'Estimating the integral <math alttext="integral Subscript a Superscript b Baseline
    f left-parenthesis x right-parenthesis d x"><mrow><msubsup><mo>∫</mo> <mrow><mi>a</mi></mrow>
    <mi>b</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi></mrow></math> of a nonnegative and continuous function *f(x)*
    over an interval [a,b] by generating random points <math alttext="left-parenthesis
    x Subscript r a n d o m Baseline comma y Subscript r a n d o m Baseline right-parenthesis"><mrow><mo>(</mo>
    <msub><mi>x</mi> <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub>
    <mo>,</mo> <msub><mi>y</mi> <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub>
    <mo>)</mo></mrow></math> where <math alttext="a less-than-or-equal-to x Subscript
    r a n d o m Baseline less-than-or-equal-to b"><mrow><mi>a</mi> <mo>≤</mo> <msub><mi>x</mi>
    <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub>
    <mo>≤</mo> <mi>b</mi></mrow></math> and <math alttext="0 less-than-or-equal-to
    y Subscript r a n d o m Baseline less-than-or-equal-to max left-parenthesis f
    right-parenthesis"><mrow><mn>0</mn> <mo>≤</mo> <msub><mi>y</mi> <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub>
    <mo>≤</mo> <mo form="prefix" movablelimits="true">max</mo> <mrow><mo>(</mo> <mi>f</mi>
    <mo>)</mo></mrow></mrow></math> . The value of the integral is the area under
    the graph of *f*. We can estimate it by finding the proportion of times that the
    random point lies under the graph of *f(x)*, or <math alttext="y Subscript r a
    n d o m Baseline less-than-or-equal-to f left-parenthesis x Subscript r a n d
    o m Baseline right-parenthesis"><mrow><msub><mi>y</mi> <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub>
    <mo>≤</mo> <mi>f</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub>
    <mo>)</mo></mrow></mrow></math> :'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过生成随机点<math alttext="left-parenthesis x Subscript r a n d o m Baseline comma
    y Subscript r a n d o m Baseline right-parenthesis"><mrow><mo>(</mo> <msub><mi>x</mi>
    <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub>
    <mo>,</mo> <msub><mi>y</mi> <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub>
    <mo>)</mo></mrow></math>，其中<math alttext="a less-than-or-equal-to x Subscript
    r a n d o m Baseline less-than-or-equal-to b"><mrow><mi>a</mi> <mo>≤</mo> <msub><mi>x</mi>
    <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub>
    <mo>≤</mo> <mi>b</mi></mrow></math>和<math alttext="0 less-than-or-equal-to y Subscript
    r a n d o m Baseline less-than-or-equal-to max left-parenthesis f right-parenthesis"><mrow><mn>0</mn>
    <mo>≤</mo> <msub><mi>y</mi> <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub>
    <mo>≤</mo> <mo form="prefix" movablelimits="true">max</mo> <mrow><mo>(</mo> <mi>f</mi>
    <mo>)</mo></mrow></mrow></math>，来估计非负连续函数*f(x)*在区间[a,b]上的积分<math alttext="integral
    Subscript a Superscript b Baseline f left-parenthesis x right-parenthesis d x"><mrow><msubsup><mo>∫</mo>
    <mrow><mi>a</mi></mrow> <mi>b</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi></mrow></math>。积分的值是*f*图形下的面积。我们可以通过找到随机点位于*f(x)*图形下的比例来估计它，或者<math
    alttext="y Subscript r a n d o m Baseline less-than-or-equal-to f left-parenthesis
    x Subscript r a n d o m Baseline right-parenthesis"><mrow><msub><mi>y</mi> <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub>
    <mo>≤</mo> <mi>f</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub>
    <mo>)</mo></mrow></mrow></math>：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column upper
    P r o b left-parenthesis point under the graph of f right-parenthesis 3rd Column
    equals StartFraction area under the graph of f Over total area of the rectangle
    EndFraction 2nd Row 1st Column Blank 2nd Column equals StartFraction integral
    Subscript a Superscript b Baseline f left-parenthesis x right-parenthesis d x
    Over left-parenthesis b minus a right-parenthesis times m a x left-parenthesis
    f right-parenthesis EndFraction 3rd Row 1st Column Blank 2nd Column almost-equals
    StartFraction number of times point is under the graph of f Over total number
    of points generated EndFraction EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mi>P</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mo>(</mo>
    <mtext>point</mtext> <mtext>under</mtext> <mtext>the</mtext> <mtext>graph</mtext>
    <mtext>of</mtext> <mtext>f</mtext> <mo>)</mo></mrow></mtd> <mtd columnalign="right"><mrow><mo>=</mo>
    <mfrac><mrow><mtext>area</mtext><mtext>under</mtext><mtext>the</mtext><mtext>graph</mtext><mtext>of</mtext><mtext>f</mtext></mrow>
    <mrow><mtext>total</mtext><mtext>area</mtext><mtext>of</mtext><mtext>the</mtext><mtext>rectangle</mtext></mrow></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>=</mo> <mfrac><mrow><msubsup><mo>∫</mo>
    <mrow><mi>a</mi></mrow> <mi>b</mi></msubsup> <mi>f</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mi>d</mi><mi>x</mi></mrow>
    <mrow><mo>(</mo><mi>b</mi><mo>-</mo><mi>a</mi><mo>)</mo><mo>×</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>f</mi><mo>)</mo></mrow></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>≈</mo> <mfrac><mrow><mtext>number</mtext><mtext>of</mtext><mtext>times</mtext><mtext>point</mtext><mtext>is</mtext><mtext>under</mtext><mtext>the</mtext><mtext>graph</mtext><mtext>of</mtext><mtext>f</mtext></mrow>
    <mrow><mtext>total</mtext><mtext>number</mtext><mtext>of</mtext><mtext>points</mtext><mtext>generated</mtext></mrow></mfrac></mrow></mtd></mtr></mtable></math>
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column upper
    P r o b left-parenthesis point under the graph of f right-parenthesis 3rd Column
    equals StartFraction area under the graph of f Over total area of the rectangle
    EndFraction 2nd Row 1st Column Blank 2nd Column equals StartFraction integral
    Subscript a Superscript b Baseline f left-parenthesis x right-parenthesis d x
    Over left-parenthesis b minus a right-parenthesis times m a x left-parenthesis
    f right-parenthesis EndFraction 3rd Row 1st Column Blank 2nd Column almost-equals
    StartFraction number of times point is under the graph of f Over total number
    of points generated EndFraction EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mi>P</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mo>(</mo>
    <mtext>point</mtext> <mtext>under</mtext> <mtext>the</mtext> <mtext>graph</mtext>
    <mtext>of</mtext> <mtext>f</mtext> <mo>)</mo></mrow></mtd> <mtd columnalign="right"><mrow><mo>=</mo>
    <mfrac><mrow><mtext>area</mtext><mtext>under</mtext><mtext>the</mtext><mtext>graph</mtext><mtext>of</mtext><mtext>f</mtext></mrow>
    <mrow><mtext>total</mtext><mtext>area</mtext><mtext>of</mtext><mtext>the</mtext><mtext>rectangle</mtext></mrow></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>=</mo> <mfrac><mrow><msubsup><mo>∫</mo>
    <mrow><mi>a</mi></mrow> <mi>b</mi></msubsup> <mi>f</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mi>d</mi><mi>x</mi></mrow>
    <mrow><mo>(</mo><mi>b</mi><mo>-</mo><mi>a</mi><mo>)</mo><mo>×</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>f</mi><mo>)</mo></mrow></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>≈</mo> <mfrac><mrow><mtext>number</mtext><mtext>of</mtext><mtext>times</mtext><mtext>point</mtext><mtext>is</mtext><mtext>under</mtext><mtext>the</mtext><mtext>graph</mtext><mtext>of</mtext><mtext>f</mtext></mrow>
    <mrow><mtext>total</mtext><mtext>number</mtext><mtext>of</mtext><mtext>points</mtext><mtext>generated</mtext></mrow></mfrac></mrow></mtd></mtr></mtable></math>
- en: Such stochastic methods to solve deterministic problems are called *Monte Carlo*
    methods because they involve repetitive games of chance, and counting proportions
    of certain outcomes, just like gambling in Monte Carlo casinos in Monaco, France.
    They could’ve been called *Las Vegas Strip* methods as well. This is analogous
    to *randomized controlled trials* to answer deterministic questions, for example
    to assess the effect of a certain drug on a given population. Another way to answer
    the same question would be a completely deterministic observational study, where
    one controls for all suspected confounding variables, and assesses the effects
    of the drug intervention.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 解决确定性问题的这种随机方法被称为*蒙特卡罗*方法，因为它们涉及重复的机会游戏，并计算特定结果的比例，就像在摩纳哥的蒙特卡洛赌场赌博一样。它们也可以被称为*拉斯维加斯大道*方法。这类似于*随机对照试验*来回答确定性问题，例如评估某种药物对给定人群的影响。回答相同问题的另一种方法是完全确定性的观察性研究，其中控制所有疑似混杂变量，并评估药物干预的效果。
- en: 'Now suppose we have a deterministic PDE and we want to find its solution using
    randomized numerical trials (Monte Carlo). To illustrate how this works, let’s
    use a simple PDE:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们有一个确定性的PDE，并且我们想使用随机数值试验（蒙特卡洛）来找到它的解决方案。为了说明这是如何工作的，让我们使用一个简单的PDE：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column normal
    upper Delta u left-parenthesis x comma y right-parenthesis equals 0 for left-parenthesis
    x comma y right-parenthesis in the unit square subset-of double-struck upper R
    squared comma 2nd Row 1st Column Blank 2nd Column u left-parenthesis x comma y
    right-parenthesis equals g left-parenthesis x comma y right-parenthesis for left-parenthesis
    x comma y right-parenthesis element-of b o u n d a r y Subscript s q u a r e Baseline
    period EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mi>Δ</mi>
    <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>0</mn> <mtext>for</mtext> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mtext>in</mtext> <mtext>the</mtext> <mtext>unit</mtext>
    <mtext>square</mtext> <mo>⊂</mo> <msup><mi>ℝ</mi> <mn>2</mn></msup> <mo>,</mo></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>g</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mtext>for</mtext> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>b</mi> <mi>o</mi> <mi>u</mi>
    <mi>n</mi> <mi>d</mi> <mi>a</mi> <mi>r</mi> <msub><mi>y</mi> <mrow><mi>s</mi><mi>q</mi><mi>u</mi><mi>a</mi><mi>r</mi><mi>e</mi></mrow></msub>
    <mo>.</mo></mrow></mtd></mtr></mtable></math>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column normal
    upper Delta u left-parenthesis x comma y right-parenthesis equals 0 for left-parenthesis
    x comma y right-parenthesis in the unit square subset-of double-struck upper R
    squared comma 2nd Row 1st Column Blank 2nd Column u left-parenthesis x comma y
    right-parenthesis equals g left-parenthesis x comma y right-parenthesis for left-parenthesis
    x comma y right-parenthesis element-of b o u n d a r y Subscript s q u a r e Baseline
    period EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mi>Δ</mi>
    <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>0</mn> <mtext>for</mtext> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mtext>in</mtext> <mtext>the</mtext> <mtext>unit</mtext>
    <mtext>square</mtext> <mo>⊂</mo> <msup><mi>ℝ</mi> <mn>2</mn></msup> <mo>,</mo></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>g</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mtext>for</mtext> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>b</mi> <mi>o</mi> <mi>u</mi>
    <mi>n</mi> <mi>d</mi> <mi>a</mi> <mi>r</mi> <msub><mi>y</mi> <mrow><mi>s</mi><mi>q</mi><mi>u</mi><mi>a</mi><mi>r</mi><mi>e</mi></mrow></msub>
    <mo>.</mo></mrow></mtd></mtr></mtable></math>
- en: 'Let’s first discretize the domain using a uniform grid, then write a finite
    difference scheme for the PDE at the interior grid points and for the boundary
    conditions:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用均匀网格离散化域，然后为内部网格点和边界条件编写PDE的有限差分方案：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column StartFraction
    u Subscript i plus 1 comma j Baseline minus 2 u Subscript i comma j Baseline plus
    u Subscript i minus 1 comma j Baseline Over h squared EndFraction plus StartFraction
    u Subscript i comma j plus 1 Baseline minus 2 u Subscript i comma j Baseline plus
    u Subscript i comma j minus 1 Baseline Over h squared EndFraction equals 0 2nd
    Row 1st Column Blank 2nd Column when left-parenthesis i comma j right-parenthesis
    corresponds to an interior grid point comma 3rd Row 1st Column Blank 2nd Column
    u Subscript i prime comma j Sub Superscript prime Subscript Baseline equals g
    Subscript i prime comma j Sub Superscript prime Subscript Baseline when left-parenthesis
    i prime comma j prime right-parenthesis corresponds to a boundary point period
    EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mfrac><mrow><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub> <mo>-</mo><mn>2</mn><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub> <mo>+</mo><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub></mrow>
    <msup><mi>h</mi> <mn>2</mn></msup></mfrac> <mo>+</mo> <mfrac><mrow><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>-</mo><mn>2</mn><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub> <mo>+</mo><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow>
    <msup><mi>h</mi> <mn>2</mn></msup></mfrac> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mtext>when</mtext> <mtext>(i,j)</mtext> <mtext>corresponds</mtext>
    <mtext>to</mtext> <mtext>an</mtext> <mtext>interior</mtext> <mtext>grid</mtext>
    <mtext>point</mtext> <mo>,</mo></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><msub><mi>u</mi>
    <mrow><msup><mi>i</mi> <mo>'</mo></msup> <mo>,</mo><msup><mi>j</mi> <mo>'</mo></msup></mrow></msub>
    <mo>=</mo> <msub><mi>g</mi> <mrow><msup><mi>i</mi> <mo>'</mo></msup> <mo>,</mo><msup><mi>j</mi>
    <mo>'</mo></msup></mrow></msub> <mtext>when</mtext> <mtext>(i',j')</mtext> <mtext>corresponds</mtext>
    <mtext>to</mtext> <mtext>a</mtext> <mtext>boundary</mtext> <mtext>point</mtext>
    <mo>.</mo></mrow></mtd></mtr></mtable></math>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column StartFraction
    u Subscript i plus 1 comma j Baseline minus 2 u Subscript i comma j Baseline plus
    u Subscript i minus 1 comma j Baseline Over h squared EndFraction plus StartFraction
    u Subscript i comma j plus 1 Baseline minus 2 u Subscript i comma j Baseline plus
    u Subscript i comma j minus 1 Baseline Over h squared EndFraction equals 0 2nd
    Row 1st Column Blank 2nd Column when left-parenthesis i comma j right-parenthesis
    corresponds to an interior grid point comma 3rd Row 1st Column Blank 2nd Column
    u Subscript i prime comma j Sub Superscript prime Subscript Baseline equals g
    Subscript i prime comma j Sub Superscript prime Subscript Baseline when left-parenthesis
    i prime comma j prime right-parenthesis corresponds to a boundary point period
    EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mfrac><mrow><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub> <mo>-</mo><mn>2</mn><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub> <mo>+</mo><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub></mrow>
    <msup><mi>h</mi> <mn>2</mn></msup></mfrac> <mo>+</mo> <mfrac><mrow><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>-</mo><mn>2</mn><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub> <mo>+</mo><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow>
    <msup><mi>h</mi> <mn>2</mn></msup></mfrac> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mtext>when</mtext> <mtext>(i,j)</mtext> <mtext>corresponds</mtext>
    <mtext>to</mtext> <mtext>an</mtext> <mtext>interior</mtext> <mtext>grid</mtext>
    <mtext>point</mtext> <mo>,</mo></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><msub><mi>u</mi>
    <mrow><msup><mi>i</mi> <mo>'</mo></msup> <mo>,</mo><msup><mi>j</mi> <mo>'</mo></msup></mrow></msub>
    <mo>=</mo> <msub><mi>g</mi> <mrow><msup><mi>i</mi> <mo>'</mo></msup> <mo>,</mo><msup><mi>j</mi>
    <mo>'</mo></msup></mrow></msub> <mtext>when</mtext> <mtext>(i',j')</mtext> <mtext>corresponds</mtext>
    <mtext>to</mtext> <mtext>a</mtext> <mtext>boundary</mtext> <mtext>point</mtext>
    <mo>.</mo></mrow></mtd></mtr></mtable></math>
- en: 'The goal is to use the above numerical scheme to find <math alttext="u Subscript
    i comma j"><msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></math>
    for each interior point of the grid. This will be the numerical estimate of the
    true solution *u(x,y)* at that particular interior point. Let’s solve for <math
    alttext="u Subscript i comma j"><msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></math>
    :'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是使用上述数值方案找到网格的每个内部点的<math alttext="u Subscript i comma j"><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></math>。这将是该特定内部点真实解*u(x,y)*的数值估计。让我们解出<math
    alttext="u Subscript i comma j"><msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></math>：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column u
    Subscript i comma j Baseline equals one-fourth u Subscript i plus 1 comma j Baseline
    plus one-fourth u Subscript i minus 1 comma j Baseline plus one-fourth u Subscript
    i comma j plus 1 Baseline plus one-fourth u Subscript i comma j minus 1 Baseline
    2nd Row 1st Column Blank 2nd Column when left-parenthesis i comma j right-parenthesis
    corresponds to an interior grid point comma 3rd Row 1st Column Blank 2nd Column
    u Subscript i prime comma j Sub Superscript prime Subscript Baseline equals g
    Subscript i prime comma j Sub Superscript prime Subscript Baseline when left-parenthesis
    i prime comma j prime right-parenthesis corresponds to a boundary point period
    EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub> <mo>=</mo> <mfrac><mn>1</mn>
    <mn>4</mn></mfrac> <msub><mi>u</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>+</mo> <mfrac><mn>1</mn> <mn>4</mn></mfrac> <msub><mi>u</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>+</mo> <mfrac><mn>1</mn> <mn>4</mn></mfrac> <msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <mfrac><mn>1</mn> <mn>4</mn></mfrac> <msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mtext>when</mtext> <mtext>(i,j)</mtext> <mtext>corresponds</mtext>
    <mtext>to</mtext> <mtext>an</mtext> <mtext>interior</mtext> <mtext>grid</mtext>
    <mtext>point</mtext> <mo>,</mo></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><msub><mi>u</mi>
    <mrow><msup><mi>i</mi> <mo>'</mo></msup> <mo>,</mo><msup><mi>j</mi> <mo>'</mo></msup></mrow></msub>
    <mo>=</mo> <msub><mi>g</mi> <mrow><msup><mi>i</mi> <mo>'</mo></msup> <mo>,</mo><msup><mi>j</mi>
    <mo>'</mo></msup></mrow></msub> <mtext>when</mtext> <mtext>(i',j')</mtext> <mtext>corresponds</mtext>
    <mtext>to</mtext> <mtext>a</mtext> <mtext>boundary</mtext> <mtext>point</mtext>
    <mo>.</mo></mrow></mtd></mtr></mtable></math>
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column u
    Subscript i comma j Baseline equals one-fourth u Subscript i plus 1 comma j Baseline
    plus one-fourth u Subscript i minus 1 comma j Baseline plus one-fourth u Subscript
    i comma j plus 1 Baseline plus one-fourth u Subscript i comma j minus 1 Baseline
    2nd Row 1st Column Blank 2nd Column when left-parenthesis i comma j right-parenthesis
    corresponds to an interior grid point comma 3rd Row 1st Column Blank 2nd Column
    u Subscript i prime comma j Sub Superscript prime Subscript Baseline equals g
    Subscript i prime comma j Sub Superscript prime Subscript Baseline when left-parenthesis
    i prime comma j prime right-parenthesis corresponds to a boundary point period
    EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub> <mo>=</mo> <mfrac><mn>1</mn>
    <mn>4</mn></mfrac> <msub><mi>u</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>+</mo> <mfrac><mn>1</mn> <mn>4</mn></mfrac> <msub><mi>u</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>+</mo> <mfrac><mn>1</mn> <mn>4</mn></mfrac> <msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <mfrac><mn>1</mn> <mn>4</mn></mfrac> <msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mtext>when</mtext> <mtext>(i,j)</mtext> <mtext>corresponds</mtext>
    <mtext>to</mtext> <mtext>an</mtext> <mtext>interior</mtext> <mtext>grid</mtext>
    <mtext>point</mtext> <mo>,</mo></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><msub><mi>u</mi>
    <mrow><msup><mi>i</mi> <mo>'</mo></msup> <mo>,</mo><msup><mi>j</mi> <mo>'</mo></msup></mrow></msub>
    <mo>=</mo> <msub><mi>g</mi> <mrow><msup><mi>i</mi> <mo>'</mo></msup> <mo>,</mo><msup><mi>j</mi>
    <mo>'</mo></msup></mrow></msub> <mtext>when</mtext> <mtext>(i',j')</mtext> <mtext>corresponds</mtext>
    <mtext>to</mtext> <mtext>a</mtext> <mtext>boundary</mtext> <mtext>point</mtext>
    <mo>.</mo></mrow></mtd></mtr></mtable></math>
- en: 'This is how we interpret the above equations for a random walk setting: If
    we are at the boundary, then we know the solution, it is <math alttext="u Subscript
    i prime comma j Sub Superscript prime Subscript Baseline equals g Subscript i
    prime comma j prime"><mrow><msub><mi>u</mi> <mrow><msup><mi>i</mi> <mo>''</mo></msup>
    <mo>,</mo><msup><mi>j</mi> <mo>''</mo></msup></mrow></msub> <mo>=</mo> <msub><mi>g</mi>
    <mrow><msup><mi>i</mi> <mo>''</mo></msup> <mo>,</mo><msup><mi>j</mi> <mo>''</mo></msup></mrow></msub></mrow></math>
    . So a random walker who is following the guidance of the PDE scheme to structure
    his walk would collect his reward <math alttext="g Subscript i prime comma j prime"><msub><mi>g</mi>
    <mrow><msup><mi>i</mi> <mo>''</mo></msup> <mo>,</mo><msup><mi>j</mi> <mo>''</mo></msup></mrow></msub></math>
    at the boundary point. Moreover, the solution <math alttext="u Subscript i comma
    j"><msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></math>
    at an interior grid point (i,j) is the unweighted average of the solution at the
    four surrounding grid points. So if a random walker starts at an interior grid
    point (i,j), we will give him a 0.25 probability of wandering off to any of his
    four neighboring points, then to their neighboring point, until he hits a boundary
    grid point (i’,j’), where he collects his reward <math alttext="g Subscript i
    prime comma j prime"><msub><mi>g</mi> <mrow><msup><mi>i</mi> <mo>''</mo></msup>
    <mo>,</mo><msup><mi>j</mi> <mo>''</mo></msup></mrow></msub></math> . That would
    be only one exploration of the PDE scheme, in a way getting us a tiny piece of
    information on which boundary point contributed to the solution <math alttext="u
    Subscript i comma j"><msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></math>
    . If we repeat this process may times, say a thousand times, all starting from
    the same grid point (i,j) where we want to find the numerical solution, then we
    can count the proportion of times the random walker ended up at each of the boundary
    points:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何解释上述方程对于随机行走设置的：如果我们在边界上，那么我们知道解，它是 <math alttext="u Subscript i prime
    comma j Sub Superscript prime Subscript Baseline equals g Subscript i prime comma
    j prime"><mrow><msub><mi>u</mi> <mrow><msup><mi>i</mi> <mo>'</mo></msup> <mo>,</mo><msup><mi>j</mi>
    <mo>'</mo></msup></mrow></msub> <mo>=</mo> <msub><mi>g</mi> <mrow><msup><mi>i</mi>
    <mo>'</mo></msup> <mo>,</mo><msup><mi>j</mi> <mo>'</mo></msup></mrow></msub></mrow></math>
    。因此，遵循PDE方案指导进行行走的随机行走者将在边界点收集他的奖励 <math alttext="g Subscript i prime comma j
    prime"><msub><mi>g</mi> <mrow><msup><mi>i</mi> <mo>'</mo></msup> <mo>,</mo><msup><mi>j</mi>
    <mo>'</mo></msup></mrow></msub></math> 。此外，在内部网格点（i，j）处的解 <math alttext="u Subscript
    i comma j"><msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></math>
    是四个周围网格点的解的无权平均值。因此，如果一个随机行走者从内部网格点（i，j）开始，我们将给他0.25的概率漫步到他的四个相邻点中的任意一个，然后到它们的相邻点，直到他碰到一个边界网格点（i'，j'），在那里他收集他的奖励
    <math alttext="g Subscript i prime comma j prime"><msub><mi>g</mi> <mrow><msup><mi>i</mi>
    <mo>'</mo></msup> <mo>,</mo><msup><mi>j</mi> <mo>'</mo></msup></mrow></msub></math>
    。这只是PDE方案的一个探索，以某种方式为我们提供了有关哪个边界点对解 <math alttext="u Subscript i comma j"><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></math> 有贡献的微小信息。如果我们重复这个过程很多次，比如一千次，都从相同的网格点（i，j）开始，我们想要找到数值解的地方，那么我们可以计算随机行走者最终到达每个边界点的比例：
- en: <math alttext="dollar-sign p r o b left-parenthesis ending up at point left-parenthesis
    i prime comma j Superscript prime Baseline right-parenthesis right-parenthesis
    almost-equals StartFraction number of times random walker ended up at point left-parenthesis
    i prime comma j Superscript prime Baseline right-parenthesis Over total number
    of random walks starting at left-parenthesis i comma j right-parenthesis EndFraction
    dollar-sign"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mrow><mo>(</mo>
    <mtext>ending</mtext> <mtext>up</mtext> <mtext>at</mtext> <mtext>point</mtext>
    <mrow><mo>(</mo> <msup><mi>i</mi> <mo>'</mo></msup> <mo>,</mo> <msup><mi>j</mi>
    <mo>'</mo></msup> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>≈</mo> <mfrac><mrow><mtext>number</mtext><mtext>of</mtext><mtext>times</mtext><mtext>random</mtext><mtext>walker</mtext><mtext>ended</mtext><mtext>up</mtext><mtext>at</mtext><mtext>point</mtext><mo>(</mo><msup><mi>i</mi>
    <mo>'</mo></msup> <mo>,</mo><msup><mi>j</mi> <mo>'</mo></msup> <mo>)</mo></mrow>
    <mrow><mtext>total</mtext><mtext>number</mtext><mtext>of</mtext><mtext>random</mtext><mtext>walks</mtext><mtext>starting</mtext><mtext>at</mtext><mtext>(i,j)</mtext></mrow></mfrac></mrow></math>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign p r o b left-parenthesis ending up at point left-parenthesis
    i prime comma j Superscript prime Baseline right-parenthesis right-parenthesis
    almost-equals StartFraction number of times random walker ended up at point left-parenthesis
    i prime comma j Superscript prime Baseline right-parenthesis Over total number
    of random walks starting at left-parenthesis i comma j right-parenthesis EndFraction
    dollar-sign"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mrow><mo>(</mo>
    <mtext>ending</mtext> <mtext>up</mtext> <mtext>at</mtext> <mtext>point</mtext>
    <mrow><mo>(</mo> <msup><mi>i</mi> <mo>'</mo></msup> <mo>,</mo> <msup><mi>j</mi>
    <mo>'</mo></msup> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>≈</mo> <mfrac><mrow><mtext>number</mtext><mtext>of</mtext><mtext>times</mtext><mtext>random</mtext><mtext>walker</mtext><mtext>ended</mtext><mtext>up</mtext><mtext>at</mtext><mtext>point</mtext><mo>(</mo><msup><mi>i</mi>
    <mo>'</mo></msup> <mo>,</mo><msup><mi>j</mi> <mo>'</mo></msup> <mo>)</mo></mrow>
    <mrow><mtext>total</mtext><mtext>number</mtext><mtext>of</mtext><mtext>random</mtext><mtext>walks</mtext><mtext>starting</mtext><mtext>at</mtext><mtext>(i,j)</mtext></mrow></mfrac></mrow></math>
- en: 'This will give us an estimate of his expected rewards from all the boundary
    points, which is exactly the numerical solution that what we are looking for:
    How does each boundary value play a role in the solution at the interior point.
    So the numerical solution of the PDE is:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供他从所有边界点预期奖励的估计，这正是我们正在寻找的数值解：每个边界值在内部点的解中扮演什么角色。因此，PDE的数值解是：
- en: <math alttext="dollar-sign u Subscript i comma j Baseline equals sigma-summation
    Underscript left-parenthesis i prime comma j Superscript prime Baseline right-parenthesis
    Endscripts p r o b left-parenthesis ending up at point left-parenthesis i prime
    comma j Superscript prime Baseline right-parenthesis right-parenthesis g Subscript
    i prime comma j prime dollar-sign"><mrow><msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>=</mo> <msub><mo>∑</mo> <mrow><mo>(</mo><msup><mi>i</mi> <mo>'</mo></msup>
    <mo>,</mo><msup><mi>j</mi> <mo>'</mo></msup> <mo>)</mo></mrow></msub> <mi>p</mi>
    <mi>r</mi> <mi>o</mi> <mi>b</mi> <mrow><mo>(</mo> <mtext>ending</mtext> <mtext>up</mtext>
    <mtext>at</mtext> <mtext>point</mtext> <mrow><mo>(</mo> <msup><mi>i</mi> <mo>'</mo></msup>
    <mo>,</mo> <msup><mi>j</mi> <mo>'</mo></msup> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <msub><mi>g</mi> <mrow><msup><mi>i</mi> <mo>'</mo></msup> <mo>,</mo><msup><mi>j</mi>
    <mo>'</mo></msup></mrow></msub></mrow></math>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign u Subscript i comma j Baseline equals sigma-summation
    Underscript left-parenthesis i prime comma j Superscript prime Baseline right-parenthesis
    Endscripts p r o b left-parenthesis ending up at point left-parenthesis i prime
    comma j Superscript prime Baseline right-parenthesis right-parenthesis g Subscript
    i prime comma j prime dollar-sign"><mrow><msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>=</mo> <msub><mo>∑</mo> <mrow><mo>(</mo><msup><mi>i</mi> <mo>'</mo></msup>
    <mo>,</mo><msup><mi>j</mi> <mo>'</mo></msup> <mo>)</mo></mrow></msub> <mi>p</mi>
    <mi>r</mi> <mi>o</mi> <mi>b</mi> <mrow><mo>(</mo> <mtext>ending</mtext> <mtext>up</mtext>
    <mtext>at</mtext> <mtext>point</mtext> <mrow><mo>(</mo> <msup><mi>i</mi> <mo>'</mo></msup>
    <mo>,</mo> <msup><mi>j</mi> <mo>'</mo></msup> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <msub><mi>g</mi> <mrow><msup><mi>i</mi> <mo>'</mo></msup> <mo>,</mo><msup><mi>j</mi>
    <mo>'</mo></msup></mrow></msub></mrow></math>
- en: This is such a neat way of getting a numerical solution that does not involve
    solving a linear system of equations (which could be very large and undesirable).
    It is also excellent when we care about finding the solution at few points only
    as opposed to finding the solution at the entire grid.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常巧妙的获得数值解的方法，不涉及解线性方程组（可能非常庞大和不可取）。当我们关心仅在少数点找到解而不是在整个网格找到解时，这也非常出色。
- en: Of course, for each PDE we have to device the correct numerical scheme along
    with the transition probabilities of the random walker. For example, if the PDE
    had a coefficients multiplied with the second derivatives, then the random walker
    would not wander off to each of his four neighboring points with equal probability
    of 0.25\. The coefficients would introduce weights for each neighbor so we adjust
    the transition probabilities to each.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于每个PDE，我们必须设计正确的数值方案，以及随机行走者的转移概率。例如，如果PDE中有与二阶导数相乘的系数，那么随机行走者不会以0.25的等概率漫步到他的四个相邻点中的每一个。系数会为每个相邻点引入权重，因此我们调整每个转移概率。
- en: In terms of theory, we have to prove that a walker does eventually hit the boundary
    and that the numerical solution obtained this way does converge to the true analytical
    solution of the PDE. We also have to obtain analytical estimates on how long until
    a random walk stops (on average), how fast the numerical solution converges, and
    how a numerical solution obtained this way fairs against the ones obtained from
    finite differences or finite elements in terms of accuracy, computation cost,
    and speed of convergence.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在理论上，我们必须证明行走者最终会碰到边界，并且以这种方式获得的数值解会收敛到PDE的真实解析解。我们还必须获得关于随机行走停止时间（平均值）、数值解收敛速度有多快，以及以这种方式获得的数值解在准确性、计算成本和收敛速度方面与从有限差分或有限元获得的解相比如何的分析估计。
- en: With Monte Carlo methods, sometimes we start the other way around. We device
    a simulation involving the different processes and transition rates mimicking
    some physical phenomena (such as interacting particles of a system), then we average
    that and transition to writing PDEs involving the descriptors of the system at
    hand. This is the exact opposite of starting with a PDE then devising a granular
    scale Monte Carlo simulation to solve it. We discuss this next.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用蒙特卡洛方法，有时我们从另一个角度开始。我们设计一个涉及不同过程和转移速率的模拟，模拟某些物理现象（例如系统中相互作用的粒子），然后我们对其进行平均，并转变为编写涉及手头系统描述符的偏微分方程。这与从偏微分方程开始然后设计一个颗粒尺度的蒙特卡洛模拟来解决它的过程完全相反。我们接下来讨论这一点。
- en: 'Some Statistical Mechanics: The Wonderful Master Equation'
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些统计力学：奇妙的主方程
- en: 'One of my favorite PDEs is *the master equation* from statistical mechanics,
    because it is one of the few PDEs out there that is able to get us from characterizing
    a system at an atomistic or molecular scale (system of particles), where the description
    is probabilistic, to the same system at a macro scale, where the description is
    deterministic. It is only logical to expect that the underlying atomistic processes
    and transitions give rise to an observed behavior at the macro scale. The very
    wise person who introduced me to statistical mechanics told me: *Isn’t our whole
    lived experience the result of the collective behavior of some massive underlying
    chemical reaction?*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的偏微分方程之一是来自统计力学的*主方程*，因为它是少数能够让我们从以概率描述系统的原子或分子尺度（粒子系统）转变到以确定性描述系统的宏观尺度的偏微分方程之一。可以合理地期望，底层的原子过程和转变导致了在宏观尺度上观察到的行为。向我介绍统计力学的非常聪明的人告诉我：*我们整个生活经验不就是一些庞大的基础化学反应的集体行为的结果吗？*
- en: The transition from the master equation for atomistic probabilities to deterministic
    PDEs for observed quantities is neat and doesn’t feel like we cheated or made
    fuzzy assumptions, or that we have two completely disconnected models, one at
    a macro scale and another at an atomistic scale, that have nothing to do with
    each other.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 从原子概率的主方程转变为观察量的确定性偏微分方程是干净的，不会让我们感到欺骗或做出模糊的假设，或者让我们有两个完全不相关的模型，一个在宏观尺度，另一个在原子尺度，彼此毫无关联。
- en: 'The master equation tracks the evolution of the probability of a statistical
    system (some particles) being in some state at a certain time. We calculate the
    rate of change of the probability of the state of the system by subtracting the
    losses from the gains and accounting for transition rates between different states:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 主方程跟踪统计系统（一些粒子）在某个特定时间处于某种状态的概率的演变。我们通过减去损失并考虑不同状态之间的转移速率来计算系统状态的概率的变化率：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column StartFraction normal
    partial-differential upper P left-parenthesis h comma t right-parenthesis Over
    normal partial-differential t EndFraction 2nd Column equals sigma-summation Underscript
    h Superscript prime Baseline Endscripts upper P left-parenthesis h prime comma
    t right-parenthesis upper T left-parenthesis h prime right-arrow h right-parenthesis
    minus upper P left-parenthesis h comma t right-parenthesis upper T left-parenthesis
    h right-arrow h Superscript prime Baseline right-parenthesis comma 2nd Row 1st
    Column Blank 2nd Column colon equals upper L upper P comma EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mfrac><mrow><mi>∂</mi><mi>P</mi><mo>(</mo><mi>h</mi><mo>,</mo><mi>t</mi><mo>)</mo></mrow>
    <mrow><mi>∂</mi><mi>t</mi></mrow></mfrac></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <munder><mo>∑</mo> <msup><mi>h</mi> <mo>'</mo></msup></munder> <mi>P</mi> <mrow><mo>(</mo>
    <msup><mi>h</mi> <mo>'</mo></msup> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mi>T</mi>
    <mrow><mo>(</mo> <msup><mi>h</mi> <mo>'</mo></msup> <mo>→</mo> <mi>h</mi> <mo>)</mo></mrow>
    <mo>-</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>h</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mi>T</mi> <mrow><mo>(</mo> <mi>h</mi> <mo>→</mo> <msup><mi>h</mi> <mo>'</mo></msup>
    <mo>)</mo></mrow> <mo>,</mo></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mo>:</mo>
    <mo>=</mo> <mi>L</mi> <mi>P</mi> <mo>,</mo></mrow></mtd></mtr></mtable></math>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column StartFraction normal
    partial-differential upper P left-parenthesis h comma t right-parenthesis Over
    normal partial-differential t EndFraction 2nd Column equals sigma-summation Underscript
    h Superscript prime Baseline Endscripts upper P left-parenthesis h prime comma
    t right-parenthesis upper T left-parenthesis h prime right-arrow h right-parenthesis
    minus upper P left-parenthesis h comma t right-parenthesis upper T left-parenthesis
    h right-arrow h Superscript prime Baseline right-parenthesis comma 2nd Row 1st
    Column Blank 2nd Column colon equals upper L upper P comma EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mfrac><mrow><mi>∂</mi><mi>P</mi><mo>(</mo><mi>h</mi><mo>,</mo><mi>t</mi><mo>)</mo></mrow>
    <mrow><mi>∂</mi><mi>t</mi></mrow></mfrac></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <munder><mo>∑</mo> <msup><mi>h</mi> <mo>'</mo></msup></munder> <mi>P</mi> <mrow><mo>(</mo>
    <msup><mi>h</mi> <mo>'</mo></msup> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mi>T</mi>
    <mrow><mo>(</mo> <msup><mi>h</mi> <mo>'</mo></msup> <mo>→</mo> <mi>h</mi> <mo>)</mo></mrow>
    <mo>-</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>h</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mi>T</mi> <mrow><mo>(</mo> <mi>h</mi> <mo>→</mo> <msup><mi>h</mi> <mo>'</mo></msup>
    <mo>)</mo></mrow> <mo>,</mo></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mo>:</mo>
    <mo>=</mo> <mi>L</mi> <mi>P</mi> <mo>,</mo></mrow></mtd></mtr></mtable></math>
- en: where <math alttext="upper T left-parenthesis h right-arrow h prime right-parenthesis"><mrow><mi>T</mi>
    <mo>(</mo> <mi>h</mi> <mo>→</mo> <msup><mi>h</mi> <mo>'</mo></msup> <mo>)</mo></mrow></math>
    and <math alttext="upper T left-parenthesis h prime right-arrow h right-parenthesis"><mrow><mi>T</mi>
    <mo>(</mo> <msup><mi>h</mi> <mo>'</mo></msup> <mo>→</mo> <mi>h</mi> <mo>)</mo></mrow></math>
    are the transition rates from state *h* to *h’* and vice versa. We calculate these
    transition rates using the underlying physical assumptions or observations on
    the system, for example evaporation and condensation rates of atoms, diffusion
    rates, *etc.*
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 其中<math alttext="上T左括号h右箭头h prime右括号"><mrow><mi>T</mi> <mo>(</mo> <mi>h</mi>
    <mo>→</mo> <msup><mi>h</mi> <mo>'</mo></msup> <mo>)</mo></mrow></math>和<math alttext="上T左括号h
    prime右箭头h右括号"><mrow><mi>T</mi> <mo>(</mo> <msup><mi>h</mi> <mo>'</mo></msup> <mo>→</mo>
    <mi>h</mi> <mo>)</mo></mrow></math>是从状态*h*到*h’*和反之的转移速率。我们使用底层的物理假设或对系统的观察来计算这些转移速率，例如原子的蒸发和凝结速率，扩散速率，*等等*。
- en: 'Now we can employ the master equation to write partial differential equations
    for the determistic descriptors of the system, by computing their expectations.
    Expectations transition us from probabilistic quantities to deterministic ones.
    Here’s how we calculate it:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以利用主方程为系统的确定性描述符编写偏微分方程，通过计算它们的期望值。期望值将我们从概率量转换为确定性量。这是我们计算的方法：
- en: <math alttext="dollar-sign mathematical left-angle f mathematical right-angle
    equals sigma-summation Underscript h Endscripts f upper P left-parenthesis h comma
    t right-parenthesis equals sigma-summation Underscript h Endscripts f StartFraction
    e Superscript minus upper H left-parenthesis h right-parenthesis slash upper K
    upper T Baseline Over upper Z EndFraction comma dollar-sign"><mrow><mrow><mo>〈</mo>
    <mi>f</mi> <mo>〉</mo></mrow> <mo>=</mo> <msub><mo>∑</mo> <mi>h</mi></msub> <mi>f</mi>
    <mi>P</mi> <mrow><mo>(</mo> <mi>h</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mo>∑</mo> <mi>h</mi></msub> <mi>f</mi> <mfrac><msup><mi>e</mi>
    <mrow><mo>-</mo><mi>H</mi><mo>(</mo><mi>h</mi><mo>)</mo><mo>/</mo><mi>K</mi><mi>T</mi></mrow></msup>
    <mi>Z</mi></mfrac> <mo>,</mo></mrow></math>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign mathematical left-angle f mathematical right-angle
    equals sigma-summation Underscript h Endscripts f upper P left-parenthesis h comma
    t right-parenthesis equals sigma-summation Underscript h Endscripts f StartFraction
    e Superscript minus upper H left-parenthesis h right-parenthesis slash upper K
    upper T Baseline Over upper Z EndFraction comma dollar-sign"><mrow><mrow><mo>〈</mo>
    <mi>f</mi> <mo>〉</mo></mrow> <mo>=</mo> <msub><mo>∑</mo> <mi>h</mi></msub> <mi>f</mi>
    <mi>P</mi> <mrow><mo>(</mo> <mi>h</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mo>∑</mo> <mi>h</mi></msub> <mi>f</mi> <mfrac><msup><mi>e</mi>
    <mrow><mo>-</mo><mi>H</mi><mo>(</mo><mi>h</mi><mo>)</mo><mo>/</mo><mi>K</mi><mi>T</mi></mrow></msup>
    <mi>Z</mi></mfrac> <mo>,</mo></mrow></math>
- en: where H(h) is the total energy and Z is the partition function. The expression
    <math alttext="StartFraction e Superscript minus upper H left-parenthesis h right-parenthesis
    slash upper K upper T Baseline Over upper Z EndFraction"><mfrac><msup><mi>e</mi>
    <mrow><mo>-</mo><mi>H</mi><mo>(</mo><mi>h</mi><mo>)</mo><mo>/</mo><mi>K</mi><mi>T</mi></mrow></msup>
    <mi>Z</mi></mfrac></math> is very common in statistical mechanics and it expresses
    the intuitive idea that states with high energy are exponentially less likely
    to occur, meaning systems prefer low energy and prefer to evolve towards the states
    that lower the total energy.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 其中H(h)是总能量，Z是配分函数。表达式<math alttext="分数e上标负H左括号h右括号除KT上方除Z"><mfrac><msup><mi>e</mi>
    <mrow><mo>-</mo><mi>H</mi><mo>(</mo><mi>h</mi><mo>)</mo><mo>/</mo><mi>K</mi><mi>T</mi></mrow></msup>
    <mi>Z</mi></mfrac></math>在统计力学中非常常见，它表达了高能量状态指数上更不可能发生的直观观念，意味着系统更倾向于低能量，并且更倾向于向降低总能量的状态演化。
- en: Expectation vs averaging over N repititions of a Monte Carlo simulation
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 期望值与对Monte Carlo模拟的N次重复平均值比较
- en: 'This expectation <math alttext="mathematical left-angle f mathematical right-angle"><mrow><mo>〈</mo>
    <mi>f</mi> <mo>〉</mo></mrow></math> is related to Monte Carlo simulations: It
    is equivalent to the limit as <math alttext="upper N right-arrow normal infinity"><mrow><mi>N</mi>
    <mo>→</mo> <mi>∞</mi></mrow></math> of the mean <math alttext="f overbar"><mover
    accent="true"><mi>f</mi> <mo>¯</mo></mover></math> of *f* after *N* repetitions
    of the Monte Carlo simulations.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个期望值<math alttext="数学左角f数学右角"><mrow><mo>〈</mo> <mi>f</mi> <mo>〉</mo></mrow></math>与蒙特卡洛模拟相关：它等同于蒙特卡洛模拟重复*N*次后*f*的均值的极限<math
    alttext="上N右箭头正无穷"><mrow><mi>N</mi> <mo>→</mo> <mi>∞</mi></mrow></math>。
- en: 'We can now compute the rate of change of the expectation of the quantity of
    interest, say <math alttext="h Subscript i"><msub><mi>h</mi> <mi>i</mi></msub></math>
    representing the height of a crystal profile (made up of atoms) at a certain site
    *i*, using the master equation:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以计算感兴趣量的期望变化率，比如表示晶体剖面（由原子组成）在某个位置*i*处的高度的<math alttext="h Subscript i"><msub><mi>h</mi>
    <mi>i</mi></msub></math>，使用主方程：
- en: <math alttext="dollar-sign StartFraction d mathematical left-angle h Subscript
    i Baseline mathematical right-angle Over d t EndFraction equals sigma-summation
    Underscript h Endscripts h Subscript i Baseline StartFraction normal partial-differential
    upper P Over normal partial-differential t EndFraction equals sigma-summation
    Underscript h Endscripts h Subscript i Baseline upper L upper P period dollar-sign"><mrow><mfrac><mrow><mi>d</mi><mo>〈</mo><msub><mi>h</mi>
    <mi>i</mi></msub> <mo>〉</mo></mrow> <mrow><mi>d</mi><mi>t</mi></mrow></mfrac>
    <mo>=</mo> <msub><mo>∑</mo> <mi>h</mi></msub> <msub><mi>h</mi> <mi>i</mi></msub>
    <mfrac><mrow><mi>∂</mi><mi>P</mi></mrow> <mrow><mi>∂</mi><mi>t</mi></mrow></mfrac>
    <mo>=</mo> <msub><mo>∑</mo> <mi>h</mi></msub> <msub><mi>h</mi> <mi>i</mi></msub>
    <mi>L</mi> <mi>P</mi> <mo>.</mo></mrow></math>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartFraction d mathematical left-angle h Subscript
    i Baseline mathematical right-angle Over d t EndFraction equals sigma-summation
    Underscript h Endscripts h Subscript i Baseline StartFraction normal partial-differential
    upper P Over normal partial-differential t EndFraction equals sigma-summation
    Underscript h Endscripts h Subscript i Baseline upper L upper P period dollar-sign"><mrow><mfrac><mrow><mi>d</mi><mo>〈</mo><msub><mi>h</mi>
    <mi>i</mi></msub> <mo>〉</mo></mrow> <mrow><mi>d</mi><mi>t</mi></mrow></mfrac>
    <mo>=</mo> <msub><mo>∑</mo> <mi>h</mi></msub> <msub><mi>h</mi> <mi>i</mi></msub>
    <mfrac><mrow><mi>∂</mi><mi>P</mi></mrow> <mrow><mi>∂</mi><mi>t</mi></mrow></mfrac>
    <mo>=</mo> <msub><mo>∑</mo> <mi>h</mi></msub> <msub><mi>h</mi> <mi>i</mi></msub>
    <mi>L</mi> <mi>P</mi> <mo>.</mo></mrow></math>
- en: If the system is closed, meaning if we are able to express the right hand side
    in terms of *h* and its derivatives with respect to space and time, then we obtain
    equation of motion for the expected height profile. If the system is not closed,
    then we have to make an approximation in order to close the system. We better
    make a physically plausible approximation, such as the system is near equilibrium,
    otherwise our efforts will be useless.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统是封闭的，也就是说，如果我们能够用*h*及其对空间和时间的导数来表达右侧，那么我们就可以得到期望高度剖面的运动方程。如果系统不是封闭的，那么我们必须做一个近似以关闭系统。最好做一个物理上合理的近似，比如系统接近平衡，否则我们的努力将是无用的。
- en: 'The final step is coarse graining the resulting discrete equations of motion
    in order to obtain a continuum PDE model describing the crystal profile. This
    step moves us from a finite difference scheme to a continuum PDE, which is the
    reverse of the discretizing process we learned with finite differences. Using
    this process, the resulting PDE emerges directly from atomistic processes. Such
    a PDE usually looks like:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是对离散运动方程进行粗粒化，以获得描述晶体剖面的连续PDE模型。这一步将我们从有限差分方案转移到连续PDE，这与我们通过有限差分学习的离散化过程相反。使用这个过程，得到的PDE直接从原子过程中出现。这样的PDE通常看起来像：
- en: <math alttext="dollar-sign h Subscript t Baseline left-parenthesis ModifyingAbove
    x With right-arrow comma t right-parenthesis equals upper F left-parenthesis h
    left-parenthesis ModifyingAbove x With right-arrow comma t right-parenthesis comma
    t semicolon ModifyingAbove omega With right-arrow right-parenthesis dollar-sign"><mrow><msub><mi>h</mi>
    <mi>t</mi></msub> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo>
    <mi>h</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>t</mi> <mo>;</mo> <mover
    accent="true"><mi>ω</mi> <mo>→</mo></mover> <mo>)</mo></mrow></mrow></math>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign h Subscript t Baseline left-parenthesis ModifyingAbove
    x With right-arrow comma t right-parenthesis equals upper F left-parenthesis h
    left-parenthesis ModifyingAbove x With right-arrow comma t right-parenthesis comma
    t semicolon ModifyingAbove omega With right-arrow right-parenthesis dollar-sign"><mrow><msub><mi>h</mi>
    <mi>t</mi></msub> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo>
    <mi>h</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>t</mi> <mo>;</mo> <mover
    accent="true"><mi>ω</mi> <mo>→</mo></mover> <mo>)</mo></mrow></mrow></math>
- en: where <math alttext="ModifyingAbove omega With right-arrow"><mover accent="true"><mi>ω</mi>
    <mo>→</mo></mover></math> is the set of the system’s physical parameters.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 其中<math alttext="ModifyingAbove omega With right-arrow"><mover accent="true"><mi>ω</mi>
    <mo>→</mo></mover></math>是系统的物理参数集。
- en: Soon in this chapter, we will learn about using graph neural networks to simulate
    natural phenomena at the macroscopic scale directly from particle systems. This
    bypasses writing down PDEs as we did in this section. The inputs to the network
    will be the particles along with their interactions and rates of interaction,
    and the output will be the time evolution (a video, or a time sequence of graphs)
    of the system as a whole.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后续部分，我们将学习如何使用图神经网络直接从粒子系统模拟宏观尺度的自然现象。这将绕过我们在本节中所做的写PDE的过程。网络的输入将是粒子及其相互作用和相互作用速率，输出将是整个系统的时间演变（视频或图的时间序列）。
- en: Solutions As Expectations Of Underlying Random Processes
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案作为基础随机过程的期望
- en: 'For some types of PDEs, a neat way to find solutions is to formulate them as
    expectations of some underlying random processes: We simulate random paths of
    an appropriate stochastic process then compute the expectation. This allows us
    to evaluate solutions at any given space–time locations.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些类型的PDE，找到解决方案的一个巧妙方法是将它们制定为某些基础随机过程的期望：我们模拟适当随机过程的随机路径，然后计算期望。这使我们能够在任何给定的空间-时间位置评估解决方案。
- en: To learn how to do this, we need to study the *Feynman–Kac formula* and *Itô’s
    calculus* (helps us find derivatives of functions of time dependent random variables).
    These tie PDEs and probability nicely together.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习如何做到这一点，我们需要研究*费曼-卡克公式*和*伊藤微积分*（帮助我们找到依赖于时间的随机变量函数的导数）。这些将PDE和概率很好地联系在一起。
- en: The Feynman-Kac formula (which we will not write) offers a practical way to
    solve some PDEs that have been haunted by the curse of dimensionality. For example,
    in quantitative finance, we can use the Feynman–Kac formula to efficiently calculate
    solutions to the Black–Scholes equation to price options on stocks. In quantum
    chemistry, we can use it to solve the Schrödinger equation.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 费曼-卡克公式（我们不会写）提供了一种实用的方法来解决一些被维度诅咒困扰的PDE。例如，在量化金融中，我们可以使用费曼-卡克公式高效计算解决方案，以定价股票期权的布莱克-斯科尔斯方程。在量子化学中，我们可以用它来解决薛定谔方程。
- en: Transforming The PDE
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换PDE
- en: 'The idea here is simple: Maybe the PDE in a transformed space is easier to
    solve (analytically or numerically) than in the space it currently lives in. So
    we transform it in some way and wish for the best.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法很简单：也许在一个转换后的空间中解决PDE问题会比在当前空间中更容易（无论是分析还是数值解）。因此，我们以某种方式对其进行转换，并期望最好的结果。
- en: Fourier Transform
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 傅里叶变换
- en: 'The Fourier transform is an integral transform from *x* space to frequency
    <math alttext="xi"><mi>ξ</mi></math> space:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 傅里叶变换是从*x*空间到频率<math alttext="xi"><mi>ξ</mi></math>空间的积分变换：
- en: <math alttext="dollar-sign upper F period upper T left-parenthesis f left-parenthesis
    x right-parenthesis right-parenthesis equals ModifyingAbove f With caret left-parenthesis
    xi right-parenthesis equals StartFraction 1 Over StartRoot 2 pi EndRoot EndFraction
    integral Subscript negative normal infinity Superscript normal infinity Baseline
    e Superscript minus i xi x Baseline f left-parenthesis x right-parenthesis d x
    dollar-sign"><mrow><mi>F</mi> <mo>.</mo> <mi>T</mi> <mrow><mo>(</mo> <mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mover
    accent="true"><mi>f</mi> <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mfrac><mn>1</mn> <msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mfrac>
    <msubsup><mo>∫</mo> <mrow><mo>-</mo><mi>∞</mi></mrow> <mi>∞</mi></msubsup> <msup><mi>e</mi>
    <mrow><mo>-</mo><mi>i</mi><mi>ξ</mi><mi>x</mi></mrow></msup> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi></mrow></math>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper F period upper T left-parenthesis f left-parenthesis
    x right-parenthesis right-parenthesis equals ModifyingAbove f With caret left-parenthesis
    xi right-parenthesis equals StartFraction 1 Over StartRoot 2 pi EndRoot EndFraction
    integral Subscript negative normal infinity Superscript normal infinity Baseline
    e Superscript minus i xi x Baseline f left-parenthesis x right-parenthesis d x
    dollar-sign"><mrow><mi>F</mi> <mo>.</mo> <mi>T</mi> <mrow><mo>(</mo> <mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mover
    accent="true"><mi>f</mi> <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mfrac><mn>1</mn> <msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mfrac>
    <msubsup><mo>∫</mo> <mrow><mo>-</mo><mi>∞</mi></mrow> <mi>∞</mi></msubsup> <msup><mi>e</mi>
    <mrow><mo>-</mo><mi>i</mi><mi>ξ</mi><mi>x</mi></mrow></msup> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi></mrow></math>
- en: 'The inverse Fourier transform undoes the Fourier transform and brings us back
    from frequency <math alttext="xi"><mi>ξ</mi></math> space to *x* space:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 逆傅里叶变换撤销了傅里叶变换，并将我们从频率<math alttext="xi"><mi>ξ</mi></math>空间带回到*x*空间：
- en: <math alttext="dollar-sign upper F period upper T Superscript negative 1 Baseline
    left-parenthesis ModifyingAbove f With caret left-parenthesis xi right-parenthesis
    right-parenthesis equals f left-parenthesis x right-parenthesis equals StartFraction
    1 Over StartRoot 2 pi EndRoot EndFraction integral Subscript negative normal infinity
    Superscript normal infinity Baseline e Superscript i xi x Baseline ModifyingAbove
    f With caret left-parenthesis xi right-parenthesis d x dollar-sign"><mrow><mi>F</mi>
    <mo>.</mo> <msup><mi>T</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mrow><mo>(</mo>
    <mover accent="true"><mi>f</mi> <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mfrac>
    <msubsup><mo>∫</mo> <mrow><mo>-</mo><mi>∞</mi></mrow> <mi>∞</mi></msubsup> <msup><mi>e</mi>
    <mrow><mi>i</mi><mi>ξ</mi><mi>x</mi></mrow></msup> <mover accent="true"><mi>f</mi>
    <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi></mrow></math>
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper F period upper T Superscript negative 1 Baseline
    left-parenthesis ModifyingAbove f With caret left-parenthesis xi right-parenthesis
    right-parenthesis equals f left-parenthesis x right-parenthesis equals StartFraction
    1 Over StartRoot 2 pi EndRoot EndFraction integral Subscript negative normal infinity
    Superscript normal infinity Baseline e Superscript i xi x Baseline ModifyingAbove
    f With caret left-parenthesis xi right-parenthesis d x dollar-sign"><mrow><mi>F</mi>
    <mo>.</mo> <msup><mi>T</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mrow><mo>(</mo>
    <mover accent="true"><mi>f</mi> <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mfrac>
    <msubsup><mo>∫</mo> <mrow><mo>-</mo><mi>∞</mi></mrow> <mi>∞</mi></msubsup> <msup><mi>e</mi>
    <mrow><mi>i</mi><mi>ξ</mi><mi>x</mi></mrow></msup> <mover accent="true"><mi>f</mi>
    <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi></mrow></math>
- en: There are tables with the Fourier transforms of many functions for our convenience.
    When these are not available, we resort to numerical methods. Beacuse the Fourier
    transform and its inverse are important for many applications, such as frequency
    analysis, signal modulation, and filtering, there are algorithms that have been
    specifically developed for its fast computation.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多函数的傅里叶变换表格供我们方便使用。当这些不可用时，我们就求助于数值方法。由于傅里叶变换及其逆变换对于许多应用非常重要，比如频率分析、信号调制和滤波，因此已经专门开发了用于快速计算的算法。
- en: 'The following are some powerful things that we need to know about the Fourier
    transform:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于傅里叶变换的一些重要事项：
- en: 'It strips a function down to its frequency components: The Fourier transform
    of a function tells us how much of each frequency a function has. The frequency
    spectrum of a function *f(x)* is the absolute value of its Fourier transform:
    <math alttext="StartAbsoluteValue upper F left-parenthesis xi right-parenthesis
    EndAbsoluteValue"><mrow><mo>|</mo> <mi>F</mi> <mo>(</mo> <mi>ξ</mi> <mo>)</mo>
    <mo>|</mo></mrow></math> .'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将一个函数分解为其频率分量：函数的傅里叶变换告诉我们函数具有每个频率的多少。函数*f(x)*的频率谱是其傅里叶变换的绝对值：<math alttext="StartAbsoluteValue
    upper F left-parenthesis xi right-parenthesis EndAbsoluteValue"><mrow><mo>|</mo>
    <mi>F</mi> <mo>(</mo> <mi>ξ</mi> <mo>)</mo> <mo>|</mo></mrow></math>。
- en: It has an inverse transform that allows us to move back and forth between *x*
    space and frequency space <math alttext="xi"><mi>ξ</mi></math> .
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它有一个逆变换，允许我们在*x*空间和频率空间<math alttext="xi"><mi>ξ</mi></math>之间来回移动。
- en: 'It changes the convolution of two functions in *x* space to multiplication
    of functions in frequency <math alttext="xi"><mi>ξ</mi></math> space: <math alttext="upper
    F period upper T period left-parenthesis f asterisk g left-parenthesis x right-parenthesis
    right-parenthesis equals upper F period upper T period left-parenthesis f left-parenthesis
    x right-parenthesis right-parenthesis times upper F period upper T period left-parenthesis
    g left-parenthesis x right-parenthesis right-parenthesis equals ModifyingAbove
    f With caret left-parenthesis xi right-parenthesis ModifyingAbove g With caret
    left-parenthesis xi right-parenthesis"><mrow><mi>F</mi> <mo>.</mo> <mi>T</mi>
    <mo>.</mo> <mrow><mo>(</mo> <mi>f</mi> <mo>*</mo> <mi>g</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mo>.</mo>
    <mi>T</mi> <mo>.</mo> <mrow><mo>(</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>×</mo> <mi>F</mi> <mo>.</mo> <mi>T</mi>
    <mo>.</mo> <mrow><mo>(</mo> <mi>g</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>)</mo></mrow> <mo>=</mo> <mover accent="true"><mi>f</mi> <mo>^</mo></mover>
    <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow> <mover accent="true"><mi>g</mi>
    <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow></mrow></math>
    . This is helpful when trying to find analytical solutions for PDEs: Solving a
    PDE in *x* space boils down to solving an algebraic equation or an easier differential
    equation in <math alttext="xi"><mi>ξ</mi></math> space then using the inverse
    Fourier transform to get back to *x* space. Many of these times we are inverting
    the product of two Fourier transforms so the solution ends up being a convolution
    in *x* space. If you have encountered *Green’s functions* for analytical solutions
    before, this is one way to arrive at them.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将*x*空间中两个函数的卷积转换为频率<math alttext="xi"><mi>ξ</mi></math>空间中函数的乘积：<math alttext="upper
    F period upper T period left-parenthesis f asterisk g left-parenthesis x right-parenthesis
    right-parenthesis equals upper F period upper T period left-parenthesis f left-parenthesis
    x right-parenthesis right-parenthesis times upper F period upper T period left-parenthesis
    g left-parenthesis x right-parenthesis right-parenthesis equals ModifyingAbove
    f With caret left-parenthesis xi right-parenthesis ModifyingAbove g With caret
    left-parenthesis xi right-parenthesis"><mrow><mi>F</mi> <mo>.</mo> <mi>T</mi>
    <mo>.</mo> <mrow><mo>(</mo> <mi>f</mi> <mo>*</mo> <mi>g</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mo>.</mo>
    <mi>T</mi> <mo>.</mo> <mrow><mo>(</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>×</mo> <mi>F</mi> <mo>.</mo> <mi>T</mi>
    <mo>.</mo> <mrow><mo>(</mo> <mi>g</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>)</mo></mrow> <mo>=</mo> <mover accent="true"><mi>f</mi> <mo>^</mo></mover>
    <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow> <mover accent="true"><mi>g</mi>
    <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow></mrow></math>。当尝试为PDE找到解析解时，这是有帮助的：在*x*空间中解PDE归结为在<math
    alttext="xi"><mi>ξ</mi></math>空间中解代数方程或更简单的微分方程，然后使用傅里叶逆变换回到*x*空间。许多情况下，我们要反转两个傅里叶变换的乘积，因此解最终变成*x*空间中的卷积。如果您之前遇到过用于解析解的*Green函数*，这是到达它们的一种方法。
- en: It changes differentiation in *x* to multiplication by <math alttext="i xi"><mrow><mi>i</mi>
    <mi>ξ</mi></mrow></math> , so <math alttext="upper F period upper T period left-parenthesis
    u Subscript x Baseline left-parenthesis x right-parenthesis right-parenthesis
    equals i xi upper F period upper T period left-parenthesis u left-parenthesis
    x right-parenthesis right-parenthesis equals i xi ModifyingAbove u With caret
    left-parenthesis xi right-parenthesis"><mrow><mi>F</mi> <mo>.</mo> <mi>T</mi>
    <mo>.</mo> <mrow><mo>(</mo> <msub><mi>u</mi> <mi>x</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>i</mi> <mi>ξ</mi>
    <mi>F</mi> <mo>.</mo> <mi>T</mi> <mo>.</mo> <mrow><mo>(</mo> <mi>u</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>i</mi> <mi>ξ</mi>
    <mover accent="true"><mi>u</mi> <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi>
    <mo>)</mo></mrow></mrow></math> , and <math alttext="upper F period upper T period
    left-parenthesis u Subscript x x Baseline left-parenthesis x right-parenthesis
    right-parenthesis equals minus xi squared upper F period upper T period left-parenthesis
    u left-parenthesis x right-parenthesis right-parenthesis equals minus xi squared
    ModifyingAbove u With caret left-parenthesis xi right-parenthesis"><mrow><mi>F</mi>
    <mo>.</mo> <mi>T</mi> <mo>.</mo> <mrow><mo>(</mo> <msub><mi>u</mi> <mrow><mi>x</mi><mi>x</mi></mrow></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mo>-</mo>
    <msup><mi>ξ</mi> <mn>2</mn></msup> <mi>F</mi> <mo>.</mo> <mi>T</mi> <mo>.</mo>
    <mrow><mo>(</mo> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>=</mo> <mo>-</mo> <msup><mi>ξ</mi> <mn>2</mn></msup> <mover accent="true"><mi>u</mi>
    <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow></mrow></math>
    . Getting rid of derivatives is huge. It means that differential equations in
    original space become algebraic equations in Fourier space.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将*x*上的微分变为<math alttext="i xi"><mrow><mi>i</mi> <mi>ξ</mi></mrow></math>的乘法，因此<math
    alttext="upper F period upper T period left-parenthesis u Subscript x Baseline
    left-parenthesis x right-parenthesis right-parenthesis equals i xi upper F period
    upper T period left-parenthesis u left-parenthesis x right-parenthesis right-parenthesis
    equals i xi ModifyingAbove u With caret left-parenthesis xi right-parenthesis"><mrow><mi>F</mi>
    <mo>.</mo> <mi>T</mi> <mo>.</mo> <mrow><mo>(</mo> <msub><mi>u</mi> <mi>x</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>i</mi>
    <mi>ξ</mi> <mi>F</mi> <mo>.</mo> <mi>T</mi> <mo>.</mo> <mrow><mo>(</mo> <mi>u</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>i</mi>
    <mi>ξ</mi> <mover accent="true"><mi>u</mi> <mo>^</mo></mover> <mrow><mo>(</mo>
    <mi>ξ</mi> <mo>)</mo></mrow></mrow></math>，以及<math alttext="upper F period upper
    T period left-parenthesis u Subscript x x Baseline left-parenthesis x right-parenthesis
    right-parenthesis equals minus xi squared upper F period upper T period left-parenthesis
    u left-parenthesis x right-parenthesis right-parenthesis equals minus xi squared
    ModifyingAbove u With caret left-parenthesis xi right-parenthesis"><mrow><mi>F</mi>
    <mo>.</mo> <mi>T</mi> <mo>.</mo> <mrow><mo>(</mo> <msub><mi>u</mi> <mrow><mi>x</mi><mi>x</mi></mrow></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mrow> <mo>)</mo></mrow> <mo>=</mo> <mo>-</mo>
    <msup><mi>ξ</mi> <mn>2</mn></msup> <mi>F</mi> <mo>.</mo> <mi>T</mi> <mo>.</mo>
    <mrow><mo>(</mo> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>=</mo> <mo>-</mo> <msup><mi>ξ</mi> <mn>2</mn></msup> <mover accent="true"><mi>u</mi>
    <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow></mrow></math>。摆脱导数是巨大的。这意味着原始空间中的微分方程变成了傅里叶空间中的代数方程。
- en: It is a linear transformation, so we can apply it separately to each term in
    a PDE. It enables us to solve linear PDEs with constant coefficients seamlessly.
    For linear PDEs with nonconstant coefficents (where the parameter depend on space),
    we can still use the Fourier transform if we are willing to get messy with series
    expansions of these coefficients. The moment we write series we have to investigate
    their convergence.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个线性变换，因此我们可以将其分别应用于PDE中的每一项。这使我们能够无缝解决具有恒定系数的线性PDE。对于具有非恒定系数的线性PDE（其中参数取决于空间），如果我们愿意用这些系数的级数展开来解决问题，我们仍然可以使用傅里叶变换。一旦我们写出级数，就必须调查它们的收敛性。
- en: We use it to prove the universal approximation theorem for neural networks *(Hornik
    et al., 1989)*.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用它来证明神经网络的通用逼近定理*(Hornik等人，1989)*。
- en: We can use it to speed up convolutional neural networks *(Mathieu et al., 2013)*.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以用它来加速卷积神经网络*(Mathieu等人，2013)*。
- en: It turns out representing PDEs in Fourier space is convenient if we want to
    train neural networks to learn PDE solutions.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将PDE表示为傅里叶空间中是方便的，如果我们想要训练神经网络来学习PDE解决方案。
- en: 'There are also some *not so* convenient things:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些*不太*方便的事情：
- en: Many functions have complex valued Fourier transforms. We just learn complex
    analysis and live with that.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多函数具有复值傅里叶变换。我们只是学习复分析并接受这一点。
- en: Not all functions have a Fourier transform. The involved integral operates on
    an infinite domain, so if there is no function inside the integral that compensates
    with a rapid decay to zero, the integral blows up (rendering the Fourier transform
    useless). The kernel of the Fourier transform is <math alttext="e Superscript
    minus i xi x Baseline equals cosine left-parenthesis xi x right-parenthesis minus
    i sine left-parenthesis xi x right-parenthesis"><mrow><msup><mi>e</mi> <mrow><mo>-</mo><mi>i</mi><mi>ξ</mi><mi>x</mi></mrow></msup>
    <mo>=</mo> <mo form="prefix">cos</mo> <mrow><mo>(</mo> <mi>ξ</mi> <mi>x</mi> <mo>)</mo></mrow>
    <mo>-</mo> <mi>i</mi> <mo form="prefix">sin</mo> <mrow><mo>(</mo> <mi>ξ</mi> <mi>x</mi>
    <mo>)</mo></mrow></mrow></math> . This oscillates with frequency <math alttext="xi"><mi>ξ</mi></math>
    and never decays to zero.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有函数都有傅里叶变换。涉及的积分在无限域上操作，因此如果积分中没有函数补偿以快速衰减为零，积分会发散（使傅里叶变换无用）。傅里叶变换的核是<math
    alttext="e Superscript minus i xi x Baseline equals cosine left-parenthesis xi
    x right-parenthesis minus i sine left-parenthesis xi x right-parenthesis"><mrow><msup><mi>e</mi>
    <mrow><mo>-</mo><mi>i</mi><mi>ξ</mi><mi>x</mi></mrow></msup> <mo>=</mo> <mo form="prefix">cos</mo>
    <mrow><mo>(</mo> <mi>ξ</mi> <mi>x</mi> <mo>)</mo></mrow> <mo>-</mo> <mi>i</mi>
    <mo form="prefix">sin</mo> <mrow><mo>(</mo> <mi>ξ</mi> <mi>x</mi> <mo>)</mo></mrow></mrow></math>。这以频率<math
    alttext="xi"><mi>ξ</mi></math>振荡，永远不会衰减为零。
- en: Even for functions whose inverse Fourier transform (which helps us find analytic
    solutions for PDEs) exists, we sometimes do not their formula. In these cases,
    we wouldn’t be able to write an explicit analytic solution using this method.
    This is a common problem for many analytic methods.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使对于其逆傅里叶变换存在（帮助我们找到PDE的解析解）的函数，有时我们也不知道它们的公式。在这些情况下，我们将无法使用这种方法编写明确的解析解。这是许多解析方法的常见问题。
- en: 'They have the [Heisenburg uncertainty principle](http://math.uchicago.edu/~may/REU2021/REUPapers/Dubey.pdf)
    *The study of uncertainty principles began with Werner Heisenberg’s argument that
    it is impossible to simultaneously determine a free particle’s position and momentum
    to arbitrary precision. In quantum mechanics, the wave function of position is
    the Fourier transform of the wave function of momentum.: The most popular use
    of Fourier uncertainty principles is as a description of the natural tradeoff
    between the stability and measurability of a system, particularly quantum mechanical
    systems.. Imagining that f(x) is the probability that a particle’s position is
    x, and f(ξ) is the probability that its momentum is ξ, Heisenberg’s inequality
    gives a lower bound on how spread out these two probability distributions must
    be. The physical assumption is that position and momentum are related by Fourier
    transform. |f|2L2 ≤ 4π · |(x - xo)f|L2 · |(ξ - ξo)f|L2\. Qualitatively, this means
    a narrow function has a wide Fourier transform, and a wide function has a narrow
    Fourier transform. In either domain, a wider function means there is literally
    a wide distribution of data, so there always exists uncertainty in one domain.*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 它们有[海森堡不确定性原理](http://math.uchicago.edu/~may/REU2021/REUPapers/Dubey.pdf) *不确定性原理的研究始于沃纳·海森堡的论点，即不可能同时确定自由粒子的位置和动量到任意精度。在量子力学中，位置的波函数是动量的波函数的傅里叶变换。：傅里叶不确定性原理最常见的用途是描述系统稳定性和可测性之间的自然权衡，特别是量子力学系统。假设f(x)是粒子位置为x的概率，f(ξ)是其动量为ξ的概率，海森堡的不等式给出了这两个概率分布必须有多分散的下限。物理假设是位置和动量由傅里叶变换相关联。|f|2L2
    ≤ 4π · |(x - xo)f|L2 · |(ξ - ξo)f|L2\. 从定性上讲，这意味着一个狭窄的函数具有宽广的傅里叶变换，而一个宽广的函数具有狭窄的傅里叶变换。在任一域中，一个更宽广的函数意味着数据分布广泛，因此总是存在一定的不确定性。*
- en: Fourier transform vs Fourier series
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 傅里叶变换与傅里叶级数
- en: We should not confuse the Fourier transform with the Fourier sine and cosine
    series. The function <math alttext="sine x"><mrow><mo form="prefix">sin</mo> <mi>x</mi></mrow></math>
    does not have a Fourier transform, but its Fourier sine series is itself.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应将傅里叶变换与傅里叶正弦和余弦级数混淆。函数<math alttext="sine x"><mrow><mo form="prefix">sin</mo>
    <mi>x</mi></mrow></math>没有傅里叶变换，但其傅里叶正弦级数本身就是。
- en: Laplace Transform
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拉普拉斯变换
- en: The Laplace transform allows us to transform a wider class of functions than
    the Fourier transform, because its kernel <math alttext="e Superscript minus s
    t"><msup><mi>e</mi> <mrow><mo>-</mo><mi>s</mi><mi>t</mi></mrow></msup></math>
    decays to zero exponentially fast (there is no complex valued *i* in the exponent
    to mess things up). The Laplace transform operates on functions defined on <math
    alttext="left-bracket 0 comma normal infinity right-parenthesis"><mrow><mo>[</mo>
    <mn>0</mn> <mo>,</mo> <mi>∞</mi> <mo>)</mo></mrow></math> , so in PDEs, we use
    it to transform the time variable, or other variables if they range from <math
    alttext="left-bracket 0 comma normal infinity right-parenthesis"><mrow><mo>[</mo>
    <mn>0</mn> <mo>,</mo> <mi>∞</mi> <mo>)</mo></mrow></math> . So instead of solving
    the PDE directly in time domain we Laplace transform it, solve it in *s* domain,
    then inverse Laplace transform it back to time domain.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 拉普拉斯变换使我们能够转换比傅里叶变换更广泛的函数类，因为它的核<math alttext="e Superscript minus s t"><msup><mi>e</mi>
    <mrow><mo>-</mo><mi>s</mi><mi>t</mi></mrow></msup></math>以指数速度衰减为零（指数中没有复值*i*来搞乱事情）。拉普拉斯变换作用于定义在<math
    alttext="left-bracket 0 comma normal infinity right-parenthesis"><mrow><mo>[</mo>
    <mn>0</mn> <mo>,</mo> <mi>∞</mi> <mo>)</mo></mrow></math>上的函数，因此在偏微分方程中，我们使用它来转换时间变量，或者如果其他变量的范围是<math
    alttext="left-bracket 0 comma normal infinity right-parenthesis"><mrow><mo>[</mo>
    <mn>0</mn> <mo>,</mo> <mi>∞</mi> <mo>)</mo></mrow></math>。因此，我们不直接在时间域中解决PDE，而是对其进行拉普拉斯变换，用*s*域中解决它，然后再将其逆拉普拉斯变换回时间域。
- en: 'The formula for the Laplace transform is:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 拉普拉斯变换的公式是：
- en: <math alttext="dollar-sign upper L period upper T period left-parenthesis f
    left-parenthesis t right-parenthesis right-parenthesis equals ModifyingAbove f
    With caret left-parenthesis s right-parenthesis equals integral Subscript 0 Superscript
    normal infinity Baseline e Superscript minus s t Baseline f left-parenthesis t
    right-parenthesis d t dollar-sign"><mrow><mi>L</mi> <mo>.</mo> <mi>T</mi> <mo>.</mo>
    <mrow><mo>(</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>=</mo> <mover accent="true"><mi>f</mi> <mo>^</mo></mover> <mrow><mo>(</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mo>=</mo> <msubsup><mo>∫</mo> <mn>0</mn> <mi>∞</mi></msubsup>
    <msup><mi>e</mi> <mrow><mo>-</mo><mi>s</mi><mi>t</mi></mrow></msup> <mi>f</mi>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>t</mi></mrow></math>
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper L period upper T period left-parenthesis f
    left-parenthesis t right-parenthesis right-parenthesis equals ModifyingAbove f
    With caret left-parenthesis s right-parenthesis equals integral Subscript 0 Superscript
    normal infinity Baseline e Superscript minus s t Baseline f left-parenthesis t
    right-parenthesis d t dollar-sign"><mrow><mi>L</mi> <mo>.</mo> <mi>T</mi> <mo>.</mo>
    <mrow><mo>(</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>=</mo> <mover accent="true"><mi>f</mi> <mo>^</mo></mover> <mrow><mo>(</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mo>=</mo> <msubsup><mo>∫</mo> <mn>0</mn> <mi>∞</mi></msubsup>
    <msup><mi>e</mi> <mrow><mo>-</mo><mi>s</mi><mi>t</mi></mrow></msup> <mi>f</mi>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>t</mi></mrow></math>
- en: 'And the formula for the inverse Laplace transform is:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 逆拉普拉斯变换的公式是：
- en: <math alttext="dollar-sign upper L period upper T period Superscript negative
    1 Baseline left-parenthesis ModifyingAbove f With caret left-parenthesis s right-parenthesis
    right-parenthesis equals f left-parenthesis t right-parenthesis equals StartFraction
    1 Over 2 pi i EndFraction integral Subscript c minus i normal infinity Superscript
    c plus i normal infinity Baseline e Superscript s t Baseline ModifyingAbove f
    With caret left-parenthesis s right-parenthesis d s dollar-sign"><mrow><mi>L</mi>
    <mo>.</mo> <mi>T</mi> <msup><mo>.</mo> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mrow><mo>(</mo> <mover accent="true"><mi>f</mi> <mo>^</mo></mover> <mrow><mo>(</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <mrow><mn>2</mn><mi>π</mi><mi>i</mi></mrow></mfrac>
    <msubsup><mo>∫</mo> <mrow><mi>c</mi><mo>-</mo><mi>i</mi><mi>∞</mi></mrow> <mrow><mi>c</mi><mo>+</mo><mi>i</mi><mi>∞</mi></mrow></msubsup>
    <msup><mi>e</mi> <mrow><mi>s</mi><mi>t</mi></mrow></msup> <mover accent="true"><mi>f</mi>
    <mo>^</mo></mover> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi></mrow></math>
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper L period upper T period Superscript negative
    1 Baseline left-parenthesis ModifyingAbove f With caret left-parenthesis s right-parenthesis
    right-parenthesis equals f left-parenthesis t right-parenthesis equals StartFraction
    1 Over 2 pi i EndFraction integral Subscript c minus i normal infinity Superscript
    c plus i normal infinity Baseline e Superscript s t Baseline ModifyingAbove f
    With caret left-parenthesis s right-parenthesis d s dollar-sign"><mrow><mi>L</mi>
    <mo>.</mo> <mi>T</mi> <msup><mo>.</mo> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mrow><mo>(</mo> <mover accent="true"><mi>f</mi> <mo>^</mo></mover> <mrow><mo>(</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <mrow><mn>2</mn><mi>π</mi><mi>i</mi></mrow></mfrac>
    <msubsup><mo>∫</mo> <mrow><mi>c</mi><mo>-</mo><mi>i</mi><mi>∞</mi></mrow> <mrow><mi>c</mi><mo>+</mo><mi>i</mi><mi>∞</mi></mrow></msubsup>
    <msup><mi>e</mi> <mrow><mi>s</mi><mi>t</mi></mrow></msup> <mover accent="true"><mi>f</mi>
    <mo>^</mo></mover> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi></mrow></math>
- en: Just like in the case of the Fourier transform, there are tables with the Laplace
    transforms of many functions computed for our convenience.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 就像傅里叶变换一样，有许多函数的拉普拉斯变换表格供我们方便计算。
- en: 'We care about how the Laplace transform acts on the (time) derivatives involved
    in a PDE. It better get rid of them because how else will a PDE get us closer
    to its solution? It does:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关心拉普拉斯变换对PDE中涉及的（时间）导数的作用。它最好消除它们，否则PDE如何让我们更接近其解？它确实做到了：
- en: <math alttext="upper L period upper T left-parenthesis u Subscript t Baseline
    left-parenthesis x comma t right-parenthesis right-parenthesis equals s ModifyingAbove
    u With caret left-parenthesis x comma s right-parenthesis minus u left-parenthesis
    x comma 0 right-parenthesis"><mrow><mi>L</mi> <mo>.</mo> <mi>T</mi> <mrow><mo>(</mo>
    <msub><mi>u</mi> <mi>t</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>s</mi> <mover accent="true"><mi>u</mi>
    <mo>^</mo></mover> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mo>-</mo> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mn>0</mn> <mo>)</mo></mrow></mrow></math>
    .
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="upper L period upper T left-parenthesis u Subscript t Baseline
    left-parenthesis x comma t right-parenthesis right-parenthesis equals s ModifyingAbove
    u With caret left-parenthesis x comma s right-parenthesis minus u left-parenthesis
    x comma 0 right-parenthesis"><mrow><mi>L</mi> <mo>.</mo> <mi>T</mi> <mrow><mo>(</mo>
    <msub><mi>u</mi> <mi>t</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>s</mi> <mover accent="true"><mi>u</mi>
    <mo>^</mo></mover> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mo>-</mo> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mn>0</mn> <mo>)</mo></mrow></mrow></math>。
- en: <math alttext="upper L period upper T left-parenthesis u Subscript t t Baseline
    left-parenthesis x comma t right-parenthesis right-parenthesis equals s squared
    ModifyingAbove u With caret left-parenthesis x comma s right-parenthesis minus
    s u left-parenthesis x comma 0 right-parenthesis minus u Subscript t Baseline
    left-parenthesis x comma 0 right-parenthesis"><mrow><mi>L</mi> <mo>.</mo> <mi>T</mi>
    <mrow><mo>(</mo> <msub><mi>u</mi> <mrow><mi>t</mi><mi>t</mi></mrow></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>s</mi> <mn>2</mn></msup> <mover accent="true"><mi>u</mi> <mo>^</mo></mover>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>-</mo>
    <mi>s</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mn>0</mn> <mo>)</mo></mrow>
    <mo>-</mo> <msub><mi>u</mi> <mi>t</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mn>0</mn> <mo>)</mo></mrow></mrow></math> .
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="upper L period upper T left-parenthesis u Subscript t t Baseline
    left-parenthesis x comma t right-parenthesis right-parenthesis equals s squared
    ModifyingAbove u With caret left-parenthesis x comma s right-parenthesis minus
    s u left-parenthesis x comma 0 right-parenthesis minus u Subscript t Baseline
    left-parenthesis x comma 0 right-parenthesis"><mrow><mi>L</mi> <mo>.</mo> <mi>T</mi>
    <mrow><mo>(</mo> <msub><mi>u</mi> <mrow><mi>t</mi><mi>t</mi></mrow></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>s</mi> <mn>2</mn></msup> <mover accent="true"><mi>u</mi> <mo>^</mo></mover>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>-</mo>
    <mi>s</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mn>0</mn> <mo>)</mo></mrow>
    <mo>-</mo> <msub><mi>u</mi> <mi>t</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mn>0</mn> <mo>)</mo></mrow></mrow></math> .
- en: Note that we usually know the initial conditions for a PDE <math alttext="u
    left-parenthesis x comma 0 right-parenthesis"><mrow><mi>u</mi> <mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mn>0</mn> <mo>)</mo></mrow></math> and <math alttext="u Subscript
    t Baseline left-parenthesis x comma 0 right-parenthesis"><mrow><msub><mi>u</mi>
    <mi>t</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mn>0</mn> <mo>)</mo></mrow></mrow></math>
    , so the above transformations do get rid of the derivatives with respect to time.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通常知道PDE的初始条件<math alttext="u left-parenthesis x comma 0 right-parenthesis"><mrow><mi>u</mi>
    <mo>(</mo> <mi>x</mi> <mo>,</mo> <mn>0</mn> <mo>)</mo></mrow></math>和<math alttext="u
    Subscript t Baseline left-parenthesis x comma 0 right-parenthesis"><mrow><msub><mi>u</mi>
    <mi>t</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mn>0</mn> <mo>)</mo></mrow></mrow></math>，因此上述变换确实消除了对时间的导数。
- en: 'We also care about the convolution to multiplication property so that we can
    transfer back algebraic expressions in *s* to PDE solutions in *t* space using
    the inverse Laplace transform. Careful here that this is a finite convolution,
    from *0* to *t*, as opposed to from <math alttext="negative normal infinity"><mrow><mo>-</mo>
    <mi>∞</mi></mrow></math> to <math alttext="normal infinity"><mi>∞</mi></math>
    like in the Fourier transform case:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还关心卷积到乘法的性质，这样我们可以通过逆拉普拉斯变换将*s*中的代数表达式转换回*t*空间中的PDE解。请注意，这是一个有限卷积，从*0*到*t*，而不是从<math
    alttext="negative normal infinity"><mrow><mo>-</mo> <mi>∞</mi></mrow></math>到<math
    alttext="normal infinity"><mi>∞</mi></math>，就像在傅立叶变换的情况下一样：
- en: <math alttext="upper L period upper T period left-parenthesis left-parenthesis
    f asterisk g right-parenthesis left-parenthesis t right-parenthesis right-parenthesis
    equals ModifyingAbove f With caret left-parenthesis s right-parenthesis ModifyingAbove
    g With caret left-parenthesis s right-parenthesis"><mrow><mi>L</mi> <mo>.</mo>
    <mi>T</mi> <mo>.</mo> <mrow><mo>(</mo> <mrow><mo>(</mo> <mi>f</mi> <mo>*</mo>
    <mi>g</mi> <mo>)</mo></mrow> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>=</mo> <mover accent="true"><mi>f</mi> <mo>^</mo></mover> <mrow><mo>(</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mover accent="true"><mi>g</mi> <mo>^</mo></mover>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow></mrow></math> where <math alttext="left-parenthesis
    f asterisk g right-parenthesis left-parenthesis t right-parenthesis equals integral
    Subscript 0 Superscript t Baseline f left-parenthesis tau right-parenthesis g
    left-parenthesis t minus tau right-parenthesis d tau equals integral Subscript
    0 Superscript t Baseline f left-parenthesis t minus tau right-parenthesis g left-parenthesis
    tau right-parenthesis d tau period"><mrow><mrow><mo>(</mo> <mi>f</mi> <mo>*</mo>
    <mi>g</mi> <mo>)</mo></mrow> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msubsup><mo>∫</mo> <mn>0</mn> <mi>t</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo>
    <mi>τ</mi> <mo>)</mo></mrow> <mi>g</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>-</mo>
    <mi>τ</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>τ</mi> <mo>=</mo> <msubsup><mo>∫</mo>
    <mn>0</mn> <mi>t</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>-</mo>
    <mi>τ</mi> <mo>)</mo></mrow> <mi>g</mi> <mrow><mo>(</mo> <mi>τ</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>τ</mi> <mo>.</mo></mrow></math>
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="upper L period upper T period left-parenthesis left-parenthesis
    f asterisk g right-parenthesis left-parenthesis t right-parenthesis right-parenthesis
    equals ModifyingAbove f With caret left-parenthesis s right-parenthesis ModifyingAbove
    g With caret left-parenthesis s right-parenthesis"><mrow><mi>L</mi> <mo>.</mo>
    <mi>T</mi> <mo>.</mo> <mrow><mo>(</mo> <mrow><mo>(</mo> <mi>f</mi> <mo>*</mo>
    <mi>g</mi> <mo>)</mo></mrow> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>=</mo> <mover accent="true"><mi>f</mi> <mo>^</mo></mover> <mrow><mo>(</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mover accent="true"><mi>g</mi> <mo>^</mo></mover>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow></mrow></math> 其中 <math alttext="left-parenthesis
    f asterisk g right-parenthesis left-parenthesis t right-parenthesis equals integral
    Subscript 0 Superscript t Baseline f left-parenthesis tau right-parenthesis g
    left-parenthesis t minus tau right-parenthesis d tau equals integral Subscript
    0 Superscript t Baseline f left-parenthesis t minus tau right-parenthesis g left-parenthesis
    tau right-parenthesis d tau period"><mrow><mrow><mo>(</mo> <mi>f</mi> <mo>*</mo>
    <mi>g</mi> <mo>)</mo></mrow> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msubsup><mo>∫</mo> <mn>0</mn> <mi>t</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo>
    <mi>τ</mi> <mo>)</mo></mrow> <mi>g</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>-</mo>
    <mi>τ</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>τ</mi> <mo>=</mo> <msubsup><mo>∫</mo>
    <mn>0</mn> <mi>t</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>-</mo>
    <mi>τ</mi> <mo>)</mo></mrow> <mi>g</mi> <mrow><mo>(</mo> <mi>τ</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>τ</mi> <mo>.</mo></mrow></math>
- en: Similar to the Fourier transform, the Laplace transform is a linear operator,
    so it is best used with linear PDEs.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于傅立叶变换，拉普拉斯变换是一个线性算子，因此最适合用于线性PDEs。
- en: Reducing PDEs to algebraic equations or to ODEs
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将PDEs简化为代数方程或ODEs
- en: Both the Fourier transform, the Laplace transform, and some other transforms,
    such as the Hankel and Mellin transforms are able to get rid of derivatives of
    the PDE in certain variables (time, space, *etc.*). What we are left with is an
    algebraic equation, if the transform acts on all the variables involved in the
    PDE, or an ordinary differential equation (ODE), if the transform acts on all
    the variables except one. The hope here is that the algebraic equations or the
    ODE are easier to solve than the original PDE, and that we can utilize known methods
    from algebra, numerics, and ODEs to solve the new equations in transformation
    variables. We will see a simple example of how this works in the following section
    on solution operators.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 傅里叶变换、拉普拉斯变换以及其他一些变换，如汉克尔变换和梅林变换，能够消除PDE中某些变量（时间、空间等）的导数。我们剩下的是一个代数方程，如果变换作用于PDE中涉及的所有变量，或者是一个普通微分方程（ODE），如果变换作用于除一个变量之外的所有变量。希望这里的代数方程或ODE比原始PDE更容易解决，并且我们可以利用代数、数值和ODE的已知方法来解决变换变量中的新方程。我们将在解算符的下一节中看到这种工作方式的一个简单示例。
- en: Solution Operators
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解算符
- en: We now work through two simple but informative examples that illustrate the
    above transform methods, while at the same time showcasing the ideas behind solution
    operators for PDEs. These are fairly general and more importantly lay the ground
    for leveraging neural networks to solve PDEs. In addition, both examples have
    explicit analytic solutions so we can use them to test approximation or iterative
    methods for solving PDEs (including neural network methods).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过两个简单但具有信息性的示例来说明上述变换方法，同时展示解决PDE的解算符背后的思想。这些例子相当一般化，更重要的是为利用神经网络解决PDE奠定了基础。此外，这两个示例都有明确的解析解，因此我们可以使用它们来测试解决PDE的近似或迭代方法（包括神经网络方法）。
- en: The first example uses a one dimensional heat equation with constant coefficients
    on an infinite domain (this is time dependent), and the second example uses a
    two dimensional Poisson equation with constant coefficients on a bounded domain
    with a simple geometry (this is not time dependent, the solution is static in
    time).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例使用具有恒定系数的一维热方程在无限域上（这是时间相关的），第二个示例使用具有恒定系数的二维泊松方程在具有简单几何形状的有界域上（这不是时间相关的，解在时间上是静态的）。
- en: Example Using The Heat Equation
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用热方程的示例
- en: 'The heat equation on an infinite one dimensional rod looks like:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 无限一维杆上的热方程如下：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column u
    Subscript t Baseline left-parenthesis x comma t right-parenthesis equals alpha
    u Subscript x x Baseline left-parenthesis x comma t right-parenthesis for x element-of
    double-struck upper R comma t element-of left-parenthesis 0 comma normal infinity
    right-parenthesis 2nd Row 1st Column Blank 2nd Column u left-parenthesis x comma
    0 right-parenthesis equals u 0 left-parenthesis x right-parenthesis for x element-of
    double-struck upper R period EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><msub><mi>u</mi> <mi>t</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>α</mi> <msub><mi>u</mi>
    <mrow><mi>x</mi><mi>x</mi></mrow></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mtext>for</mtext> <mi>x</mi> <mo>∈</mo> <mi>ℝ</mi>
    <mo>,</mo> <mi>t</mi> <mo>∈</mo> <mrow><mo>(</mo> <mn>0</mn> <mo>,</mo> <mi>∞</mi>
    <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>u</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mn>0</mn> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mtext>for</mtext> <mi>x</mi> <mo>∈</mo> <mi>ℝ</mi> <mo>.</mo></mrow></mtd></mtr></mtable></math>
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column u
    Subscript t Baseline left-parenthesis x comma t right-parenthesis equals alpha
    u Subscript x x Baseline left-parenthesis x comma t right-parenthesis for x element-of
    double-struck upper R comma t element-of left-parenthesis 0 comma normal infinity
    right-parenthesis 2nd Row 1st Column Blank 2nd Column u left-parenthesis x comma
    0 right-parenthesis equals u 0 left-parenthesis x right-parenthesis for x element-of
    double-struck upper R period EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><msub><mi>u</mi> <mi>t</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>α</mi> <msub><mi>u</mi>
    <mrow><mi>x</mi><mi>x</mi></mrow></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mtext>for</mtext> <mi>x</mi> <mo>∈</mo> <mi>ℝ</mi>
    <mo>,</mo> <mi>t</mi> <mo>∈</mo> <mrow><mo>(</mo> <mn>0</mn> <mo>,</mo> <mi>∞</mi>
    <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>u</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mn>0</mn> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mtext>for</mtext> <mi>x</mi> <mo>∈</mo> <mi>ℝ</mi> <mo>.</mo></mrow></mtd></mtr></mtable></math>
- en: Since this PDE is defined on an infinite domain in *x*, we must specify the
    far field conditions (there is no boundary so we must specify what is it that
    we think the solution function *u(x,t)* looks like when <math alttext="x right-arrow
    normal infinity"><mrow><mi>x</mi> <mo>→</mo> <mi>∞</mi></mrow></math> and <math
    alttext="x right-arrow negative normal infinity"><mrow><mi>x</mi> <mo>→</mo> <mo>-</mo>
    <mi>∞</mi></mrow></math> ). Let’s assume that these limits are zero.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个PDE在*x*的无限域上定义，我们必须指定远场条件（没有边界，因此我们必须指定当<mi>x</mi>→∞和<mi>x</mi>→-∞时我们认为解函数*u(x,t)*是什么样子）。让我们假设这些极限为零。
- en: 'For simplicity, let’s assume that the parameter <math alttext="alpha"><mi>α</mi></math>
    is constant so we can apply the Fourier transform. When applying this transform
    (with respect to *x*) to the PDE <math alttext="u Subscript t Baseline left-parenthesis
    x comma t right-parenthesis equals alpha u Subscript x x Baseline left-parenthesis
    x comma t right-parenthesis"><mrow><msub><mi>u</mi> <mi>t</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>α</mi> <msub><mi>u</mi>
    <mrow><mi>x</mi><mi>x</mi></mrow></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></math> and the initial condition, we manage
    to get rid of the derivatives in *x* and simplify the PDE into an ordinary differential
    equation with only one derivative in time:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，让我们假设参数<mi>α</mi>是常数，这样我们就可以应用傅里叶变换。当将这种变换（关于*x*）应用于PDE时，我们设法消除*x*中的导数，并将PDE简化为只有时间导数的常微分方程：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column ModifyingAbove
    u With caret Subscript t Baseline left-parenthesis xi comma t right-parenthesis
    equals minus alpha xi squared ModifyingAbove u With caret left-parenthesis xi
    comma t right-parenthesis for xi element-of double-struck upper R comma t element-of
    left-parenthesis 0 comma normal infinity right-parenthesis 2nd Row 1st Column
    Blank 2nd Column ModifyingAbove u With caret left-parenthesis xi comma 0 right-parenthesis
    equals ModifyingAbove u With caret Subscript 0 Baseline left-parenthesis xi right-parenthesis
    for xi element-of double-struck upper R period EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><msub><mover accent="true"><mi>u</mi>
    <mo>^</mo></mover> <mi>t</mi></msub> <mrow><mo>(</mo> <mi>ξ</mi> <mo>,</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mo>-</mo> <mi>α</mi> <msup><mi>ξ</mi> <mn>2</mn></msup>
    <mover accent="true"><mi>u</mi> <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi>
    <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mtext>for</mtext> <mi>ξ</mi> <mo>∈</mo>
    <mi>ℝ</mi> <mo>,</mo> <mi>t</mi> <mo>∈</mo> <mrow><mo>(</mo> <mn>0</mn> <mo>,</mo>
    <mi>∞</mi> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mi>u</mi> <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi> <mo>,</mo>
    <mn>0</mn> <mo>)</mo></mrow> <mo>=</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>^</mo></mover> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow>
    <mtext>for</mtext> <mi>ξ</mi> <mo>∈</mo> <mi>ℝ</mi> <mo>.</mo></mrow></mtd></mtr></mtable></math>
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column ModifyingAbove
    u With caret Subscript t Baseline left-parenthesis xi comma t right-parenthesis
    equals minus alpha xi squared ModifyingAbove u With caret left-parenthesis xi
    comma t right-parenthesis for xi element-of double-struck upper R comma t element-of
    left-parenthesis 0 comma normal infinity right-parenthesis 2nd Row 1st Column
    Blank 2nd Column ModifyingAbove u With caret left-parenthesis xi comma 0 right-parenthesis
    equals ModifyingAbove u With caret Subscript 0 Baseline left-parenthesis xi right-parenthesis
    for xi element-of double-struck upper R period EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><msub><mover accent="true"><mi>u</mi>
    <mo>^</mo></mover> <mi>t</mi></msub> <mrow><mo>(</mo> <mi>ξ</mi> <mo>,</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mo>-</mo> <mi>α</mi> <msup><mi>ξ</mi> <mn>2</mn></msup>
    <mover accent="true"><mi>u</mi> <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi>
    <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mtext>for</mtext> <mi>ξ</mi> <mo>∈</mo>
    <mi>ℝ</mi> <mo>,</mo> <mi>t</mi> <mo>∈</mo> <mrow><mo>(</mo> <mn>0</mn> <mo>,</mo>
    <mi>∞</mi> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mi>u</mi> <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi> <mo>,</mo>
    <mn>0</mn> <mo>)</mo></mrow> <mo>=</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>^</mo></mover> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow>
    <mtext>for</mtext> <mi>ξ</mi> <mo>∈</mo> <mi>ℝ</mi> <mo>.</mo></mrow></mtd></mtr></mtable></math>
- en: 'We can now easily solve this using a method from ordinary differential equations
    called separation of variables (let’s not bother with the details), obtaining
    the solution in Fourier space :'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以轻松地使用常微分方程中的变量分离方法（让我们不要去烦恼细节），在傅里叶空间中获得解决方案：
- en: <math alttext="dollar-sign ModifyingAbove u With caret left-parenthesis xi comma
    t right-parenthesis equals e Superscript minus alpha xi squared t Baseline ModifyingAbove
    u With caret Subscript 0 Baseline left-parenthesis xi right-parenthesis dollar-sign"><mrow><mover
    accent="true"><mi>u</mi> <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi> <mo>,</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi> <mrow><mo>-</mo><mi>α</mi><msup><mi>ξ</mi>
    <mn>2</mn></msup> <mi>t</mi></mrow></msup> <msub><mover accent="true"><mi>u</mi>
    <mo>^</mo></mover> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign ModifyingAbove u With caret left-parenthesis xi comma
    t right-parenthesis equals e Superscript minus alpha xi squared t Baseline ModifyingAbove
    u With caret Subscript 0 Baseline left-parenthesis xi right-parenthesis dollar-sign"><mrow><mover
    accent="true"><mi>u</mi> <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi> <mo>,</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi> <mrow><mo>-</mo><mi>α</mi><msup><mi>ξ</mi>
    <mn>2</mn></msup> <mi>t</mi></mrow></msup> <msub><mover accent="true"><mi>u</mi>
    <mo>^</mo></mover> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow></mrow></math>
- en: 'We need the solution in *x* space not in Fourier space, so we take the inverse
    Fourier transform of the above expression, and use the knowledge that multiplications
    become convolutions when transforming between x space and Fourier space. Therefore,
    the solution in x space is:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在*x*空间中的解决方案而不是在傅里叶空间中，因此我们对上述表达式进行逆傅里叶变换，并利用了在*x*空间和傅里叶空间之间转换时乘法变为卷积的知识。因此，在*x*空间中的解决方案是：
- en: <math alttext="dollar-sign u left-parenthesis x comma t right-parenthesis equals
    upper F period upper T period Superscript negative 1 Baseline left-parenthesis
    e Superscript minus alpha xi squared t Baseline ModifyingAbove u With caret Subscript
    0 Baseline left-parenthesis xi right-parenthesis right-parenthesis equals upper
    F period upper T period Superscript negative 1 Baseline left-parenthesis e Superscript
    minus alpha xi squared t Baseline right-parenthesis asterisk u 0 left-parenthesis
    x right-parenthesis equals StartFraction 1 Over StartRoot 4 pi alpha t EndRoot
    EndFraction e Superscript minus StartFraction x squared Over 4 alpha t EndFraction
    Baseline asterisk u 0 left-parenthesis x right-parenthesis equals integral Subscript
    negative normal infinity Superscript normal infinity Baseline StartFraction 1
    Over StartRoot 4 pi alpha t EndRoot EndFraction e Superscript minus StartFraction
    left-parenthesis s minus x right-parenthesis squared Over 4 alpha t EndFraction
    Baseline u 0 left-parenthesis s right-parenthesis d s equals integral Subscript
    negative normal infinity Superscript normal infinity Baseline k e r n e l left-parenthesis
    s comma x semicolon t semicolon alpha right-parenthesis u 0 left-parenthesis s
    right-parenthesis d s dollar-sign"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mo>.</mo> <mi>T</mi>
    <msup><mo>.</mo> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mrow><mo>(</mo> <msup><mi>e</mi>
    <mrow><mo>-</mo><mi>α</mi><msup><mi>ξ</mi> <mn>2</mn></msup> <mi>t</mi></mrow></msup>
    <msub><mover accent="true"><mi>u</mi> <mo>^</mo></mover> <mn>0</mn></msub> <mrow><mo>(</mo>
    <mi>ξ</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mo>.</mo>
    <mi>T</mi> <msup><mo>.</mo> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mrow><mo>(</mo>
    <msup><mi>e</mi> <mrow><mo>-</mo><mi>α</mi><msup><mi>ξ</mi> <mn>2</mn></msup>
    <mi>t</mi></mrow></msup> <mo>)</mo></mrow> <mo>*</mo> <msub><mi>u</mi> <mn>0</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <msqrt><mrow><mn>4</mn><mi>π</mi><mi>α</mi><mi>t</mi></mrow></msqrt></mfrac>
    <msup><mi>e</mi> <mrow><mo>-</mo><mfrac><msup><mi>x</mi> <mn>2</mn></msup> <mrow><mn>4</mn><mi>α</mi><mi>t</mi></mrow></mfrac></mrow></msup>
    <mo>*</mo> <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msubsup><mo>∫</mo> <mrow><mo>-</mo><mi>∞</mi></mrow> <mi>∞</mi></msubsup>
    <mfrac><mn>1</mn> <msqrt><mrow><mn>4</mn><mi>π</mi><mi>α</mi><mi>t</mi></mrow></msqrt></mfrac>
    <msup><mi>e</mi> <mrow><mo>-</mo><mfrac><msup><mrow><mo>(</mo><mi>s</mi><mo>-</mo><mi>x</mi><mo>)</mo></mrow>
    <mn>2</mn></msup> <mrow><mn>4</mn><mi>α</mi><mi>t</mi></mrow></mfrac></mrow></msup>
    <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi> <mo>=</mo> <msubsup><mo>∫</mo> <mrow><mo>-</mo><mi>∞</mi></mrow>
    <mi>∞</mi></msubsup> <mi>k</mi> <mi>e</mi> <mi>r</mi> <mi>n</mi> <mi>e</mi> <mi>l</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>x</mi> <mo>;</mo> <mi>t</mi> <mo>;</mo>
    <mi>α</mi> <mo>)</mo></mrow> <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi></mrow></math>
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign u left-parenthesis x comma t right-parenthesis equals
    upper F period upper T period Superscript negative 1 Baseline left-parenthesis
    e Superscript minus alpha xi squared t Baseline ModifyingAbove u With caret Subscript
    0 Baseline left-parenthesis xi right-parenthesis right-parenthesis equals upper
    F period upper T period Superscript negative 1 Baseline left-parenthesis e Superscript
    minus alpha xi squared t Baseline right-parenthesis asterisk u 0 left-parenthesis
    x right-parenthesis equals StartFraction 1 Over StartRoot 4 pi alpha t EndRoot
    EndFraction e Superscript minus StartFraction x squared Over 4 alpha t EndFraction
    Baseline asterisk u 0 left-parenthesis x right-parenthesis equals integral Subscript
    negative normal infinity Superscript normal infinity Baseline StartFraction 1
    Over StartRoot 4 pi alpha t EndRoot EndFraction e Superscript minus StartFraction
    left-parenthesis s minus x right-parenthesis squared Over 4 alpha t EndFraction
    Baseline u 0 left-parenthesis s right-parenthesis d s equals integral Subscript
    negative normal infinity Superscript normal infinity Baseline k e r n e l left-parenthesis
    s comma x semicolon t semicolon alpha right-parenthesis u 0 left-parenthesis s
    right-parenthesis d s dollar-sign"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mo>.</mo> <mi>T</mi>
    <msup><mo>.</mo> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mrow><mo>(</mo> <msup><mi>e</mi>
    <mrow><mo>-</mo><mi>α</mi><msup><mi>ξ</mi> <mn>2</mn></msup> <mi>t</mi></mrow></msup>
    <msub><mover accent="true"><mi>u</mi> <mo>^</mo></mover> <mn>0</mn></msub> <mrow><mo>(</mo>
    <mi>ξ</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mo>.</mo>
    <mi>T</mi> <msup><mo>.</mo> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mrow><mo>(</mo>
    <msup><mi>e</mi> <mrow><mo>-</mo><mi>α</mi><msup><mi>ξ</mi> <mn>2</mn></msup>
    <mi>t</mi></mrow></msup> <mo>)</mo></mrow> <mo>*</mo> <msub><mi>u</mi> <mn>0</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <msqrt><mrow><mn>4</mn><mi>π</mi><mi>α</mi><mi>t</mi></mrow></msqrt></mfrac>
    <msup><mi>e</mi> <mrow><mo>-</mo><mfrac><msup><mi>x</mi> <mn>2</mn></msup> <mrow><mn>4</mn><mi>α</mi><mi>t</mi></mrow></mfrac></mrow></msup>
    <mo>*</mo> <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msubsup><mo>∫</mo> <mrow><mo>-</mo><mi>∞</mi></mrow> <mi>∞</mi></msubsup>
    <mfrac><mn>1</mn> <msqrt><mrow><mn>4</mn><mi>π</mi><mi>α</mi><mi>t</mi></mrow></msqrt></mfrac>
    <msup><mi>e</mi> <mrow><mo>-</mo><mfrac><msup><mrow><mo>(</mo><mi>s</mi><mo>-</mo><mi>x</mi><mo>)</mo></mrow>
    <mn>2</mn></msup> <mrow><mn>4</mn><mi>α</mi><mi>t</mi></mrow></mfrac></mrow></msup>
    <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi> <mo>=</mo> <msubsup><mo>∫</mo> <mrow><mo>-</mo><mi>∞</mi></mrow>
    <mi>∞</mi></msubsup> <mi>k</mi> <mi>e</mi> <mi>r</mi> <mi>n</mi> <mi>e</mi> <mi>l</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>x</mi> <mo>;</mo> <mi>t</mi> <mo>;</mo>
    <mi>α</mi> <mo>)</mo></mrow> <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi></mrow></math>
- en: 'The punch line from the above calculation is this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以上计算的要点是：
- en: '*The solution u(x,t) of the PDE is the integral of some kernel function <math
    alttext="k left-parenthesis s comma x semicolon t semicolon alpha right-parenthesis"><mrow><mi>k</mi>
    <mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>x</mi> <mo>;</mo> <mi>t</mi> <mo>;</mo> <mi>α</mi>
    <mo>)</mo></mrow></math> against the initial state of the solution <math alttext="u
    0 left-parenthesis s right-parenthesis"><mrow><msub><mi>u</mi> <mn>0</mn></msub>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow></mrow></math> .*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*PDE的解u(x,t)是一些核函数<mrow><mi>k</mi> <mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>x</mi>
    <mo>;</mo> <mi>t</mi> <mo>;</mo> <mi>α</mi> <mo>)</mo></mrow>对解的初始状态<mrow><msub><mi>u</mi>
    <mn>0</mn></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow></mrow>的积分。*'
- en: Moreover, *the solution operator of the PDE maps the given input data, which
    in this case are the parameter <math alttext="alpha"><mi>α</mi></math> and initial
    state <math alttext="u 0 left-parenthesis x right-parenthesis"><mrow><msub><mi>u</mi>
    <mn>0</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    , to the output which is the solution we are seeking, u(x,t), via integrating
    the initial state against some kernel function that depends on the parameter of
    the PDE (along with its dependence on space and time).*
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，*PDE的解算子将给定的输入数据，即参数<math alttext="alpha"><mi>α</mi></math>和初始状态<math alttext="u
    0 left-parenthesis x right-parenthesis"><mrow><msub><mi>u</mi> <mn>0</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>，映射到我们正在寻找的解u(x,t)的输出，通过将初始状态与某个取决于PDE参数（以及其对空间和时间的依赖性）的核函数进行积分。*
- en: Knowing the formula of this kernel, or using a neural network to approximate
    it, unlocks the solution of a given PDE. We then say that the neural network *learned
    the solution operator* of the PDE.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这个核的公式，或使用神经网络来近似它，可以解锁给定PDE的解。然后我们说神经网络*学习了PDE的解算子*。
- en: In our simple example, we leveraged linearity and constant coefficients to incorporate
    Fourier transform methods and convolution when reverting back to real space, and
    had the luxury of working out an explicit analytic formula of the kernel of the
    integral, namely, <math alttext="k left-parenthesis s comma x semicolon t semicolon
    alpha right-parenthesis equals StartFraction 1 Over StartRoot 4 pi alpha t EndRoot
    EndFraction e Superscript minus StartFraction left-parenthesis s minus x right-parenthesis
    squared Over 4 alpha t EndFraction"><mrow><mi>k</mi> <mrow><mo>(</mo> <mi>s</mi>
    <mo>,</mo> <mi>x</mi> <mo>;</mo> <mi>t</mi> <mo>;</mo> <mi>α</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mfrac><mn>1</mn> <msqrt><mrow><mn>4</mn><mi>π</mi><mi>α</mi><mi>t</mi></mrow></msqrt></mfrac>
    <msup><mi>e</mi> <mrow><mo>-</mo><mfrac><msup><mrow><mo>(</mo><mi>s</mi><mo>-</mo><mi>x</mi><mo>)</mo></mrow>
    <mn>2</mn></msup> <mrow><mn>4</mn><mi>α</mi><mi>t</mi></mrow></mfrac></mrow></msup></mrow></math>
    , so there is no need for approximations. On a nice side note, this kernel comes
    from a time dependent Gaussian function <math alttext="upper G a u s s i a n left-parenthesis
    x semicolon t semicolon alpha right-parenthesis equals StartFraction 1 Over StartRoot
    4 pi alpha t EndRoot EndFraction e Superscript minus StartFraction x squared Over
    4 alpha t EndFraction"><mrow><mi>G</mi> <mi>a</mi> <mi>u</mi> <mi>s</mi> <mi>s</mi>
    <mi>i</mi> <mi>a</mi> <mi>n</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>;</mo> <mi>t</mi>
    <mo>;</mo> <mi>α</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <msqrt><mrow><mn>4</mn><mi>π</mi><mi>α</mi><mi>t</mi></mrow></msqrt></mfrac>
    <msup><mi>e</mi> <mrow><mo>-</mo><mfrac><msup><mi>x</mi> <mn>2</mn></msup> <mrow><mn>4</mn><mi>α</mi><mi>t</mi></mrow></mfrac></mrow></msup></mrow></math>
    that spreads out as time evolves. The effect of convolving this with the initial
    state of the solution has a smoothing effect that spreads out and smoothes any
    initial oscillations and spikes. We observe this smoothing with any diffusion
    process that we can visualize, such as diffusion of smoke in the air, or diffusion
    of a dye in a liquid, where the substance spreads out smoothly until we obtain
    one homogeneous looking medium.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们简单的例子中，我们利用线性和恒定系数来融入傅立叶变换方法和卷积，当回到实空间时，我们有幸得到了积分核的显式解析公式，即，<math alttext="k
    left-parenthesis s comma x semicolon t semicolon alpha right-parenthesis equals
    StartFraction 1 Over StartRoot 4 pi alpha t EndRoot EndFraction e Superscript
    minus StartFraction left-parenthesis s minus x right-parenthesis squared Over
    4 alpha t EndFraction"><mrow><mi>k</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo>
    <mi>x</mi> <mo>;</mo> <mi>t</mi> <mo>;</mo> <mi>α</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mfrac><mn>1</mn> <msqrt><mrow><mn>4</mn><mi>π</mi><mi>α</mi><mi>t</mi></mrow></msqrt></mfrac>
    <msup><mi>e</mi> <mrow><mo>-</mo><mfrac><msup><mrow><mo>(</mo><mi>s</mi><mo>-</mo><mi>x</mi><mo>)</mo></mrow>
    <mn>2</mn></msup> <mrow><mn>4</mn><mi>α</mi><mi>t</mi></mrow></mfrac></mrow></msup></mrow></math>，因此不需要近似。有趣的是，这个核来自于一个时间相关的高斯函数<math
    alttext="upper G a u s s i a n left-parenthesis x semicolon t semicolon alpha
    right-parenthesis equals StartFraction 1 Over StartRoot 4 pi alpha t EndRoot EndFraction
    e Superscript minus StartFraction x squared Over 4 alpha t EndFraction"><mrow><mi>G</mi>
    <mi>a</mi> <mi>u</mi> <mi>s</mi> <mi>s</mi> <mi>i</mi> <mi>a</mi> <mi>n</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>;</mo> <mi>t</mi> <mo>;</mo> <mi>α</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mfrac><mn>1</mn> <msqrt><mrow><mn>4</mn><mi>π</mi><mi>α</mi><mi>t</mi></mrow></msqrt></mfrac>
    <msup><mi>e</mi> <mrow><mo>-</mo><mfrac><msup><mi>x</mi> <mn>2</mn></msup> <mrow><mn>4</mn><mi>α</mi><mi>t</mi></mrow></mfrac></mrow></msup></mrow></math>，随着时间的推移扩散开来。将其与解的初始状态进行卷积会产生平滑效果，使任何初始振荡和尖峰变得平滑。我们观察到这种平滑效果在任何我们可以可视化的扩散过程中，比如空气中的烟雾扩散，或液体中染料的扩散，物质会平滑地扩散直到我们得到一个均匀的介质。
- en: Example Using Poisson Equation
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用泊松方程的示例
- en: 'Poisson equation on a bounded domain looks like:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有界域上的泊松方程如下：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column negative
    normal nabla period left-parenthesis a left-parenthesis ModifyingAbove x With
    right-arrow right-parenthesis normal nabla u left-parenthesis ModifyingAbove x
    With right-arrow right-parenthesis right-parenthesis equals f left-parenthesis
    ModifyingAbove x With right-arrow right-parenthesis for ModifyingAbove x With
    right-arrow element-of upper D 2nd Row 1st Column Blank 2nd Column u left-parenthesis
    ModifyingAbove x With right-arrow right-parenthesis equals 0 for ModifyingAbove
    x With right-arrow at the boundary of upper D period EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><mo>-</mo> <mi>∇</mi> <mo>.</mo>
    <mrow><mo>(</mo> <mi>a</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mi>∇</mi> <mi>u</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow> <mtext>for</mtext>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>∈</mo> <mi>D</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>u</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn> <mtext>for</mtext>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mtext>at</mtext> <mtext>the</mtext>
    <mtext>boundary</mtext> <mtext>of</mtext> <mtext>D.</mtext></mrow></mtd></mtr></mtable></math>
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column negative
    normal nabla period left-parenthesis a left-parenthesis ModifyingAbove x With
    right-arrow right-parenthesis normal nabla u left-parenthesis ModifyingAbove x
    With right-arrow right-parenthesis right-parenthesis equals f left-parenthesis
    ModifyingAbove x With right-arrow right-parenthesis for ModifyingAbove x With
    right-arrow element-of upper D 2nd Row 1st Column Blank 2nd Column u left-parenthesis
    ModifyingAbove x With right-arrow right-parenthesis equals 0 for ModifyingAbove
    x With right-arrow at the boundary of upper D period EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><mo>-</mo> <mi>∇</mi> <mo>.</mo>
    <mrow><mo>(</mo> <mi>a</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mi>∇</mi> <mi>u</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow> <mtext>for</mtext>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>∈</mo> <mi>D</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>u</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn> <mtext>for</mtext>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mtext>at</mtext> <mtext>the</mtext>
    <mtext>boundary</mtext> <mtext>of</mtext> <mtext>D.</mtext></mrow></mtd></mtr></mtable></math>
- en: 'When <math alttext="a left-parenthesis ModifyingAbove x With right-arrow right-parenthesis"><mrow><mi>a</mi>
    <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow></math>
    is constant and the domain is two dimensional this becomes:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当<math alttext="a left-parenthesis ModifyingAbove x With right-arrow right-parenthesis"><mrow><mi>a</mi>
    <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow></math>是常数且定义域是二维时，变成：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column minus
    a normal upper Delta u left-parenthesis x comma y right-parenthesis equals f left-parenthesis
    x comma y right-parenthesis for left-parenthesis x comma y right-parenthesis element-of
    upper D subset-of double-struck upper R squared 2nd Row 1st Column Blank 2nd Column
    u left-parenthesis x comma y right-parenthesis equals 0 for left-parenthesis x
    comma y right-parenthesis at the boundary of upper D comma EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><mo>-</mo> <mi>a</mi> <mi>Δ</mi>
    <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mtext>for</mtext> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>∈</mo> <mi>D</mi> <mo>⊂</mo> <msup><mi>ℝ</mi> <mn>2</mn></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>u</mi> <mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo> <mo>=</mo> <mn>0</mn> <mtext>for</mtext> <mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo> <mtext>at</mtext> <mtext>the</mtext> <mtext>boundary</mtext>
    <mtext>of</mtext> <mtext>D,</mtext></mrow></mtd></mtr></mtable></math>
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column minus
    a normal upper Delta u left-parenthesis x comma y right-parenthesis equals f left-parenthesis
    x comma y right-parenthesis for left-parenthesis x comma y right-parenthesis element-of
    upper D subset-of double-struck upper R squared 2nd Row 1st Column Blank 2nd Column
    u left-parenthesis x comma y right-parenthesis equals 0 for left-parenthesis x
    comma y right-parenthesis at the boundary of upper D comma EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><mo>-</mo> <mi>a</mi> <mi>Δ</mi>
    <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mtext>for</mtext> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>∈</mo> <mi>D</mi> <mo>⊂</mo> <msup><mi>ℝ</mi> <mn>2</mn></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>u</mi> <mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo> <mo>=</mo> <mn>0</mn> <mtext>for</mtext> <mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo> <mtext>at</mtext> <mtext>the</mtext> <mtext>boundary</mtext>
    <mtext>of</mtext> <mtext>D,</mtext></mrow></mtd></mtr></mtable></math>
- en: 'where <math alttext="normal upper Delta u left-parenthesis x comma y right-parenthesis
    equals u Subscript x x Baseline left-parenthesis x comma y right-parenthesis plus
    u Subscript y y Baseline left-parenthesis x comma y right-parenthesis"><mrow><mi>Δ</mi>
    <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mi>u</mi> <mrow><mi>x</mi><mi>x</mi></mrow></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>u</mi>
    <mrow><mi>y</mi><mi>y</mi></mrow></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow></mrow></math> . We can employ the Fourier transform
    in *x* and *y* like we did for the heat equation (linear equation with constant
    coefficients), but let’s demonstrate the Green’s function method instead. We can
    think of the right hand side of the PDE as an aggregation in the continuum of
    impulses of intensity f(x,y) at locations (x,y). We need the *Dirac delta measure*
    <math alttext="delta Subscript left-parenthesis x comma y right-parenthesis Baseline
    left-parenthesis s comma p right-parenthesis"><mrow><msub><mi>δ</mi> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo></mrow></msub>
    <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow></mrow></math>
    to express the concept of an impulse mathematically. This is zero everywhere on
    the domain except at the point *(x,y)*, where it is infinite, and it’s total measure
    on the domain is normalized to 1\. The rationale here is that we can solve the
    PDE with the right hand side consisting of only an impulse at a certain location
    then aggregate the original solution from these. Presumably, solving the PDE with
    only an impulse as the right hand side is easier than solving it with some given
    function as the right hand side, so we will build up the solution *u(x,y)* from
    the solution *G(x,y;s,p)* of the impulse PDE. More importantly, using the Green’s
    function allows us to get an integral representation of the solution of the input
    data against a kernel (which is the Green’s function). The PDE with an impulse
    right hand side is:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以像处理热方程（具有恒定系数的线性方程）一样，在*x*和*y*上使用傅立叶变换，但让我们改用格林函数方法。我们可以将PDE的右侧视为在连续脉冲聚集的位置（x，y）处的强度f（x，y）的聚合。我们需要*Dirac
    delta measure* <math alttext="delta Subscript left-parenthesis x comma y right-parenthesis
    Baseline left-parenthesis s comma p right-parenthesis"><mrow><msub><mi>δ</mi>
    <mrow><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo></mrow></msub> <mrow><mo>(</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow></mrow></math> 来在数学上表达脉冲的概念。这在域上的任何地方都是零，除了在点*(x，y)*处是无穷大，它在域上的总测度被归一化为1。这里的理念是，我们可以解决只有在特定位置有脉冲的PDE，然后从中聚合原始解决方案。可以推测，仅将脉冲作为右侧的PDE比将给定函数作为右侧的PDE更容易解决，因此我们将从脉冲PDE的解决方案*G（x，y；s，p）*构建出解决方案*u（x，y）*。更重要的是，使用格林函数允许我们获得输入数据的解的积分表示形式，该积分表示形式是针对一个核（即格林函数）的。带有脉冲右侧的PDE是：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column minus
    a normal upper Delta upper G left-parenthesis s comma p semicolon x comma y right-parenthesis
    equals delta Subscript left-parenthesis x comma y right-parenthesis Baseline left-parenthesis
    s comma p right-parenthesis for left-parenthesis s comma p right-parenthesis element-of
    upper D subset-of double-struck upper R squared 2nd Row 1st Column Blank 2nd Column
    upper G left-parenthesis s comma p semicolon x comma y right-parenthesis equals
    0 for left-parenthesis s comma p right-parenthesis at the boundary of upper D
    period EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mo>-</mo>
    <mi>a</mi> <mi>Δ</mi> <mi>G</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi>
    <mo>;</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>δ</mi>
    <mrow><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo></mrow></msub> <mrow><mo>(</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow> <mtext>for</mtext> <mrow><mo>(</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>D</mi> <mo>⊂</mo>
    <msup><mi>ℝ</mi> <mn>2</mn></msup></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>G</mi>
    <mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>;</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo> <mo>=</mo> <mn>0</mn> <mtext>for</mtext> <mo>(</mo> <mi>s</mi> <mo>,</mo>
    <mi>p</mi> <mo>)</mo> <mtext>at</mtext> <mtext>the</mtext> <mtext>boundary</mtext>
    <mtext>of</mtext> <mtext>D.</mtext></mrow></mtd></mtr></mtable></math>
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column minus
    a normal upper Delta upper G left-parenthesis s comma p semicolon x comma y right-parenthesis
    equals delta Subscript left-parenthesis x comma y right-parenthesis Baseline left-parenthesis
    s comma p right-parenthesis for left-parenthesis s comma p right-parenthesis element-of
    upper D subset-of double-struck upper R squared 2nd Row 1st Column Blank 2nd Column
    upper G left-parenthesis s comma p semicolon x comma y right-parenthesis equals
    0 for left-parenthesis s comma p right-parenthesis at the boundary of upper D
    period EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mo>-</mo>
    <mi>a</mi> <mi>Δ</mi> <mi>G</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi>
    <mo>;</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>δ</mi>
    <mrow><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo></mrow></msub> <mrow><mo>(</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow> <mtext>for</mtext> <mrow><mo>(</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>D</mi> <mo>⊂</mo>
    <msup><mi>ℝ</mi> <mn>2</mn></msup></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>G</mi>
    <mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>;</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo> <mo>=</mo> <mn>0</mn> <mtext>for</mtext> <mo>(</mo> <mi>s</mi> <mo>,</mo>
    <mi>p</mi> <mo>)</mo> <mtext>at</mtext> <mtext>the</mtext> <mtext>boundary</mtext>
    <mtext>of</mtext> <mtext>D.</mtext></mrow></mtd></mtr></mtable></math>
- en: 'Let’s now write:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们写：
- en: <math alttext="dollar-sign f left-parenthesis x comma y right-parenthesis equals
    integral Underscript upper D Endscripts f left-parenthesis s comma p right-parenthesis
    delta Subscript left-parenthesis x comma y right-parenthesis Baseline left-parenthesis
    s comma p right-parenthesis d s d p comma dollar-sign"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo>∫</mo>
    <mi>D</mi></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi>
    <mo>)</mo></mrow> <msub><mi>δ</mi> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo></mrow></msub>
    <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>s</mi> <mi>d</mi> <mi>p</mi> <mo>,</mo></mrow></math>
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign f left-parenthesis x comma y right-parenthesis equals
    integral Underscript upper D Endscripts f left-parenthesis s comma p right-parenthesis
    delta Subscript left-parenthesis x comma y right-parenthesis Baseline left-parenthesis
    s comma p right-parenthesis d s d p comma dollar-sign"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo>∫</mo>
    <mi>D</mi></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi>
    <mo>)</mo></mrow> <msub><mi>δ</mi> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo></mrow></msub>
    <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>s</mi> <mi>d</mi> <mi>p</mi> <mo>,</mo></mrow></math>
- en: 'and the PDE as:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以及PDE为：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column minus
    a normal upper Delta u left-parenthesis x comma y right-parenthesis equals integral
    Underscript upper D Endscripts f left-parenthesis s comma p right-parenthesis
    delta Subscript left-parenthesis x comma y right-parenthesis Baseline left-parenthesis
    s comma p right-parenthesis d s d p for left-parenthesis x comma y right-parenthesis
    element-of upper D subset-of double-struck upper R squared 2nd Row 1st Column
    Blank 2nd Column u left-parenthesis x comma y right-parenthesis equals 0 for left-parenthesis
    x comma y right-parenthesis at the boundary of upper D period EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><mo>-</mo> <mi>a</mi> <mi>Δ</mi>
    <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mo>∫</mo> <mi>D</mi></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>s</mi>
    <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow> <msub><mi>δ</mi> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo></mrow></msub>
    <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>s</mi> <mi>d</mi> <mi>p</mi> <mtext>for</mtext> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>D</mi> <mo>⊂</mo> <msup><mi>ℝ</mi>
    <mn>2</mn></msup></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>u</mi>
    <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo> <mo>=</mo> <mn>0</mn> <mtext>for</mtext>
    <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo> <mtext>at</mtext> <mtext>the</mtext>
    <mtext>boundary</mtext> <mtext>of</mtext> <mtext>D.</mtext></mrow></mtd></mtr></mtable></math>
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column minus
    a normal upper Delta u left-parenthesis x comma y right-parenthesis equals integral
    Underscript upper D Endscripts f left-parenthesis s comma p right-parenthesis
    delta Subscript left-parenthesis x comma y right-parenthesis Baseline left-parenthesis
    s comma p right-parenthesis d s d p for left-parenthesis x comma y right-parenthesis
    element-of upper D subset-of double-struck upper R squared 2nd Row 1st Column
    Blank 2nd Column u left-parenthesis x comma y right-parenthesis equals 0 for left-parenthesis
    x comma y right-parenthesis at the boundary of upper D period EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><mo>-</mo> <mi>a</mi> <mi>Δ</mi>
    <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mo>∫</mo> <mi>D</mi></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>s</mi>
    <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow> <msub><mi>δ</mi> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo></mrow></msub>
    <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>s</mi> <mi>d</mi> <mi>p</mi> <mtext>for</mtext> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>D</mi> <mo>⊂</mo> <msup><mi>ℝ</mi>
    <mn>2</mn></msup></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>u</mi>
    <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo> <mo>=</mo> <mn>0</mn> <mtext>for</mtext>
    <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo> <mtext>at</mtext> <mtext>the</mtext>
    <mtext>boundary</mtext> <mtext>of</mtext> <mtext>D.</mtext></mrow></mtd></mtr></mtable></math>
- en: 'Let’s substitute the <math alttext="delta Subscript left-parenthesis x comma
    y right-parenthesis Baseline left-parenthesis s comma p right-parenthesis"><mrow><msub><mi>δ</mi>
    <mrow><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo></mrow></msub> <mrow><mo>(</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow></mrow></math> inside the integral
    with <math alttext="minus a normal upper Delta upper G left-parenthesis s comma
    p semicolon x comma y right-parenthesis"><mrow><mo>-</mo> <mi>a</mi> <mi>Δ</mi>
    <mi>G</mi> <mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>;</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow></math> :'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用<math alttext="delta Subscript left-parenthesis x comma y right-parenthesis
    Baseline left-parenthesis s comma p right-parenthesis"><mrow><msub><mi>δ</mi>
    <mrow><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo></mrow></msub> <mrow><mo>(</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow></mrow></math>替换积分中的<math alttext="minus
    a normal upper Delta upper G left-parenthesis s comma p semicolon x comma y right-parenthesis"><mrow><mo>-</mo>
    <mi>a</mi> <mi>Δ</mi> <mi>G</mi> <mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>;</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow></math>：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column minus
    a normal upper Delta u left-parenthesis x comma y right-parenthesis equals integral
    Underscript upper D Endscripts minus a normal upper Delta upper G left-parenthesis
    s comma p semicolon x comma y right-parenthesis f left-parenthesis s comma p right-parenthesis
    d s d p for left-parenthesis x comma y right-parenthesis element-of upper D subset-of
    double-struck upper R squared 2nd Row 1st Column Blank 2nd Column u left-parenthesis
    x comma y right-parenthesis equals 0 for ModifyingAbove x With right-arrow at
    the boundary of upper D period EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mo>-</mo> <mi>a</mi> <mi>Δ</mi> <mi>u</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo>∫</mo>
    <mi>D</mi></msub> <mo>-</mo> <mi>a</mi> <mi>Δ</mi> <mi>G</mi> <mrow><mo>(</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>;</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>f</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi> <mi>d</mi> <mi>p</mi> <mtext>for</mtext> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>D</mi> <mo>⊂</mo>
    <msup><mi>ℝ</mi> <mn>2</mn></msup></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>u</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mn>0</mn> <mtext>for</mtext> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mtext>at</mtext> <mtext>the</mtext> <mtext>boundary</mtext> <mtext>of</mtext>
    <mtext>D.</mtext></mrow></mtd></mtr></mtable></math>
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column minus
    a normal upper Delta u left-parenthesis x comma y right-parenthesis equals integral
    Underscript upper D Endscripts minus a normal upper Delta upper G left-parenthesis
    s comma p semicolon x comma y right-parenthesis f left-parenthesis s comma p right-parenthesis
    d s d p for left-parenthesis x comma y right-parenthesis element-of upper D subset-of
    double-struck upper R squared 2nd Row 1st Column Blank 2nd Column u left-parenthesis
    x comma y right-parenthesis equals 0 for ModifyingAbove x With right-arrow at
    the boundary of upper D period EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mo>-</mo> <mi>a</mi> <mi>Δ</mi> <mi>u</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo>∫</mo>
    <mi>D</mi></msub> <mo>-</mo> <mi>a</mi> <mi>Δ</mi> <mi>G</mi> <mrow><mo>(</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>;</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>f</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi> <mi>d</mi> <mi>p</mi> <mtext>for</mtext> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>D</mi> <mo>⊂</mo>
    <msup><mi>ℝ</mi> <mn>2</mn></msup></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>u</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mn>0</mn> <mtext>for</mtext> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mtext>at</mtext> <mtext>the</mtext> <mtext>boundary</mtext> <mtext>of</mtext>
    <mtext>D.</mtext></mrow></mtd></mtr></mtable></math>
- en: 'Now let’s assume that we have the right conditions to swap differentiation
    and integration:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们假设我们有正确的条件来交换微分和积分：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column minus
    a normal upper Delta u left-parenthesis x comma y right-parenthesis equals minus
    a normal upper Delta left-parenthesis integral Underscript upper D Endscripts
    upper G left-parenthesis s comma p semicolon x comma y right-parenthesis f left-parenthesis
    s comma p right-parenthesis d s d p right-parenthesis for left-parenthesis x comma
    y right-parenthesis element-of upper D subset-of double-struck upper R squared
    2nd Row 1st Column Blank 2nd Column u left-parenthesis x comma y right-parenthesis
    equals 0 for left-parenthesis x comma y right-parenthesis at the boundary of upper
    D period EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mo>-</mo>
    <mi>a</mi> <mi>Δ</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mo>-</mo> <mi>a</mi> <mi>Δ</mi> <mrow><mo>(</mo>
    <msub><mo>∫</mo> <mi>D</mi></msub> <mi>G</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo>
    <mi>p</mi> <mo>;</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>f</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>s</mi> <mi>d</mi> <mi>p</mi> <mo>)</mo></mrow> <mtext>for</mtext> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>D</mi> <mo>⊂</mo>
    <msup><mi>ℝ</mi> <mn>2</mn></msup></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>u</mi>
    <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo> <mo>=</mo> <mn>0</mn> <mtext>for</mtext>
    <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo> <mtext>at</mtext> <mtext>the</mtext>
    <mtext>boundary</mtext> <mtext>of</mtext> <mtext>D.</mtext></mrow></mtd></mtr></mtable></math>
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column minus
    a normal upper Delta u left-parenthesis x comma y right-parenthesis equals minus
    a normal upper Delta left-parenthesis integral Underscript upper D Endscripts
    upper G left-parenthesis s comma p semicolon x comma y right-parenthesis f left-parenthesis
    s comma p right-parenthesis d s d p right-parenthesis for left-parenthesis x comma
    y right-parenthesis element-of upper D subset-of double-struck upper R squared
    2nd Row 1st Column Blank 2nd Column u left-parenthesis x comma y right-parenthesis
    equals 0 for left-parenthesis x comma y right-parenthesis at the boundary of upper
    D period EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mo>-</mo>
    <mi>a</mi> <mi>Δ</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mo>-</mo> <mi>a</mi> <mi>Δ</mi> <mrow><mo>(</mo>
    <msub><mo>∫</mo> <mi>D</mi></msub> <mi>G</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo>
    <mi>p</mi> <mo>;</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>f</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>s</mi> <mi>d</mi> <mi>p</mi> <mo>)</mo></mrow> <mtext>for</mtext> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>D</mi> <mo>⊂</mo>
    <msup><mi>ℝ</mi> <mn>2</mn></msup></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>u</mi>
    <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo> <mo>=</mo> <mn>0</mn> <mtext>for</mtext>
    <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo> <mtext>at</mtext> <mtext>the</mtext>
    <mtext>boundary</mtext> <mtext>of</mtext> <mtext>D.</mtext></mrow></mtd></mtr></mtable></math>
- en: 'Finally this allows us to represent the solution *u(x,y)* as:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这使我们能够将解*u（x，y）*表示为：
- en: <math alttext="dollar-sign u left-parenthesis x comma y right-parenthesis equals
    integral Underscript upper D Endscripts upper G left-parenthesis x comma y semicolon
    s comma p semicolon a right-parenthesis f left-parenthesis s comma p right-parenthesis
    d s d p dollar-sign"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msub><mo>∫</mo> <mi>D</mi></msub> <mi>G</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>;</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>;</mo>
    <mi>a</mi> <mo>)</mo></mrow> <mi>f</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo>
    <mi>p</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mi>d</mi> <mi>p</mi></mrow></math>
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign u left-parenthesis x comma y right-parenthesis equals
    integral Underscript upper D Endscripts upper G left-parenthesis x comma y semicolon
    s comma p semicolon a right-parenthesis f left-parenthesis s comma p right-parenthesis
    d s d p dollar-sign"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msub><mo>∫</mo> <mi>D</mi></msub> <mi>G</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>;</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>;</mo>
    <mi>a</mi> <mo>)</mo></mrow> <mi>f</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo>
    <mi>p</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mi>d</mi> <mi>p</mi></mrow></math>
- en: 'Note that we made the dependency of G on *a* explicit in *G*, since later in
    a neural network setting to learn the solution operator of the PDE, the physical
    parameter *a* would be part of the network’s input. If the parameter *a=a(s,p)*
    is not constant then we would write *G(x,y;s,p;a(s,p))*. Analogous to the discussion
    of the previous example, the punch line from the above calculation is:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在*G*中明确了G对*a*的依赖关系，因为在神经网络设置中学习PDE的解算子时，物理参数*a*将成为网络输入的一部分。如果参数*a=a(s,p)*不是常数，那么我们将写成*G(x,y;s,p;a(s,p))*。类似于前面示例的讨论，上述计算的要点是：
- en: '*The solution u(x,y) of the PDE is the integral of some kernel function, in
    this case the Green’s function <math alttext="upper G left-parenthesis s comma
    p semicolon x comma y semicolon a right-parenthesis"><mrow><mi>G</mi> <mo>(</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>;</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>;</mo>
    <mi>a</mi> <mo>)</mo></mrow></math> against the right hand side of the PDE <math
    alttext="f left-parenthesis s comma p right-parenthesis"><mrow><mi>f</mi> <mo>(</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow></math> .*'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*PDE的解*u（x，y）*是某个核函数的积分，本例中是格林函数<math alttext="upper G left-parenthesis s comma
    p semicolon x comma y semicolon a right-parenthesis"><mrow><mi>G</mi> <mo>(</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>;</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>;</mo>
    <mi>a</mi> <mo>)</mo></mrow></math> 对PDE的右侧<math alttext="f left-parenthesis s
    comma p right-parenthesis"><mrow><mi>f</mi> <mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi>
    <mo>)</mo></mrow></math> 的积分。*'
- en: Moreover, *the solution operator of the PDE maps the given input data, which
    in this case are the parameter <math alttext="a"><mi>a</mi></math> and the right
    hand side of the PDE <math alttext="f left-parenthesis x comma y right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow></math> , to the
    output which is the solution we are seeking, u(x,y), via integrating the right
    hand side function against some kernel function that depends on the parameter
    of the PDE (along with its dependence on space).* In our case, the kernel of the
    solution operator is the Green’s function of the PDE, which we happen to know
    for Poisson equation on domains with an easy geometry, but not in more complex
    situations. Once again, knowing the formula of this kernel, or using a neural
    network to approximate it, unlocks the solution of a given PDE.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，PDE的解算子将给定的输入数据（在本例中为参数a和PDE的右手边f(x, y)）映射到我们正在寻找的解u(x, y)的输出，通过将右手边函数与依赖于PDE参数的某个核函数进行积分（以及其对空间的依赖）。在我们的情况下，解算子的核是PDE的Green函数，我们恰好知道它适用于具有简单几何形状的域上的Poisson方程，但在更复杂的情况下则不知道。再次强调，了解这个核的公式，或者使用神经网络来近似它，可以解锁给定PDE的解。
- en: Fixed Point Iteration
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固定点迭代
- en: The fixed point iteration is useful to construct explicit solutions and to prove
    existence and uniqueness for certain lucky PDEs. It is such an easy and general
    method so a definite must have in our toolbox. We will write it down then immediately
    apply it to represent the solution of a *dynamical system* as a series. A dynamical
    system is an ordinary differential equation that describes the evolution in time
    of a particle or a bunch of particles (a system). Again, we would like neural
    networks to learn the solution operators of dynamical systems so this is consistent
    with our discussion above. Moreover, it is good to have the fixed point iteration
    series representation of the solution side by side to the neural network representation.
    Recall that in many mathematical settings, we can represent the same solution
    in multiple ways. A fixed point iteration series is additive while a neural network
    representation is compositional. Moreover, neural networks seem to have the advantage
    of representing the solution operators of whole families of PDEs and an overall
    wider variety which is like a dream come true in this field.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 固定点迭代对于构建显式解以及证明某些幸运的PDE的存在性和唯一性非常有用。这是一种简单而通用的方法，因此绝对是我们工具箱中必不可少的。我们将把它写下来，然后立即应用它来表示*动力系统*的解作为一个级数。动力系统是描述粒子或一群粒子（系统）随时间演化的常微分方程。同样，我们希望神经网络学习动力系统的解算子，这与我们上面的讨论是一致的。此外，将固定点迭代级数表示的解与神经网络表示并列是很好的。请记住，在许多数学设置中，我们可以用多种方式表示相同的解。固定点迭代级数是加法的，而神经网络表示是组合的。此外，神经网络似乎有优势，可以表示整个PDE家族的解算子和更广泛的多样性，这在这个领域是一种梦想成真。
- en: 'The fixed point iteration aims to find a fixed point of a function, or a point
    <math alttext="x Superscript asterisk"><msup><mi>x</mi> <mo>*</mo></msup></math>
    that the function maps back to iteself: <math alttext="f left-parenthesis x Superscript
    asterisk Baseline right-parenthesis equals x Superscript asterisk"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mo>*</mo></msup> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>x</mi> <mo>*</mo></msup></mrow></math> . This is not simple task since
    *f* is usually nonlinear, and most of the time we have no idea if such points
    exist for a given function. As always the case with nonlinear equations, iterative
    methods avoid *one shot* solutions and instead come up with a sequence of points
    that *hopefully, and under the right conditions* converge to the desired solution,
    in this case, the fixed point of a function.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 固定点迭代旨在找到一个函数的不动点，或者一个函数映射回自身的点x*：f(x*) = x*。这并不是一项简单的任务，因为f通常是非线性的，大多数情况下我们不知道给定函数是否存在这样的点。与非线性方程一样，迭代方法避免了“一次性”解决方案，而是提出了一系列点，希望在正确条件下收敛到期望的解，即函数的不动点。
- en: How does it work?
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: 'Here is how the fixed point iteration goes:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 固定点迭代的步骤如下：
- en: <math alttext="x 0"><msub><mi>x</mi> <mn>0</mn></msub></math> is the starting
    point, then
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x0是起始点，然后
- en: <math alttext="x Subscript i plus 1 Baseline equals f left-parenthesis x Subscript
    i Baseline right-parenthesis"><mrow><msub><mi>x</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></math>
    .
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: xi+1 = f(xi)。
- en: That’s it. Our sequence <math alttext="StartSet x 0 comma x 1 comma x 2 ellipsis
    EndSet"><mrow><mo>{</mo> <msub><mi>x</mi> <mn>0</mn></msub> <mo>,</mo> <msub><mi>x</mi>
    <mn>1</mn></msub> <mo>,</mo> <msub><mi>x</mi> <mn>2</mn></msub> <mo>⋯</mo> <mo>}</mo></mrow></math>
    is generated by consecutive applications of *f* and looks like <math alttext="StartSet
    x 0 comma f left-parenthesis x 0 right-parenthesis comma f left-parenthesis f
    left-parenthesis x 0 right-parenthesis right-parenthesis comma f left-parenthesis
    f left-parenthesis f left-parenthesis x 0 right-parenthesis right-parenthesis
    right-parenthesis comma period period period EndSet"><mrow><mo>{</mo> <msub><mi>x</mi>
    <mn>0</mn></msub> <mo>,</mo> <mi>f</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mn>0</mn></msub>
    <mo>)</mo></mrow> <mo>,</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>f</mi> <mrow><mo>(</mo>
    <msub><mi>x</mi> <mn>0</mn></msub> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>,</mo>
    <mi>f</mi> <mrow><mo>(</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>f</mi> <mrow><mo>(</mo>
    <msub><mi>x</mi> <mn>0</mn></msub> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>,</mo> <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>}</mo></mrow></math> . Under the
    right conditions on *f* and <math alttext="x 0"><msub><mi>x</mi> <mn>0</mn></msub></math>
    , this sequence converges to a fixed point <math alttext="x Superscript asterisk"><msup><mi>x</mi>
    <mo>*</mo></msup></math> of *f* (so <math alttext="f left-parenthesis x Superscript
    asterisk Baseline right-parenthesis equals x Superscript asterisk"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mo>*</mo></msup> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>x</mi> <mo>*</mo></msup></mrow></math> ).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们的序列<math alttext="StartSet x 0 comma x 1 comma x 2 ellipsis EndSet"><mrow><mo>{</mo>
    <msub><mi>x</mi> <mn>0</mn></msub> <mo>,</mo> <msub><mi>x</mi> <mn>1</mn></msub>
    <mo>,</mo> <msub><mi>x</mi> <mn>2</mn></msub> <mo>⋯</mo> <mo>}</mo></mrow></math>是通过连续应用*f*生成的，看起来像<math
    alttext="StartSet x 0 comma f left-parenthesis x 0 right-parenthesis comma f left-parenthesis
    f left-parenthesis x 0 right-parenthesis right-parenthesis comma f left-parenthesis
    f left-parenthesis f left-parenthesis x 0 right-parenthesis right-parenthesis
    right-parenthesis comma period period period EndSet"><mrow><mo>{</mo> <msub><mi>x</mi>
    <mn>0</mn></msub> <mo>,</mo> <mi>f</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mn>0</mn></msub>
    <mo>)</mo></mrow> <mo>,</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>f</mi> <mrow><mo>(</mo>
    <msub><mi>x</mi> <mn>0</mn></msub> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>,</mo>
    <mi>f</mi> <mrow><mo>(</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>f</mi> <mrow><mo>(</mo>
    <msub><mi>x</mi> <mn>0</mn></msub> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>,</mo> <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>}</mo></mrow></math>。在*f*和<math
    alttext="x 0"><msub><mi>x</mi> <mn>0</mn></msub></math>的正确条件下，这个序列会收敛到*f*的一个不动点<math
    alttext="x Superscript asterisk"><msup><mi>x</mi> <mo>*</mo></msup></math>（所以<math
    alttext="f left-parenthesis x Superscript asterisk Baseline right-parenthesis
    equals x Superscript asterisk"><mrow><mi>f</mi> <mrow><mo>(</mo> <msup><mi>x</mi>
    <mo>*</mo></msup> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>x</mi> <mo>*</mo></msup></mrow></math>）。
- en: 'Note that depending on *f* and the starting point, the asymptotic behavior
    of this sequence can be any of these:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，根据*f*和起始点，这个序列的渐近行为可以是以下任何一种：
- en: 'Convergence to a limit <math alttext="x Superscript asterisk"><msup><mi>x</mi>
    <mo>*</mo></msup></math> : If the FPI converges, then it captures a fixed point
    (for a continuous function *f*, if the FPI converges then the limit must be a
    fixed point of *f*).'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收敛到极限<math alttext="x Superscript asterisk"><msup><mi>x</mi> <mo>*</mo></msup></math>：如果FPI收敛，那么它捕获了一个不动点（对于一个连续函数*f*，如果FPI收敛，那么极限必须是*f*的不动点）。
- en: 'Divergence to <math alttext="normal infinity"><mi>∞</mi></math> : The sequence
    grows without a bound'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发散到<math alttext="normal infinity"><mi>∞</mi></math>：序列增长无限制
- en: 'Periodic behavior: The sequence oscillates between two or more values.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 周期性行为：序列在两个或更多值之间振荡。
- en: 'Chaotic behavior: The sequence behaves erratically, with no pattern whatsoever.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混沌行为：序列表现得不规律，没有任何模式。
- en: Theorems related to the fixed point iteration assert that the choice of <math
    alttext="x 0"><msub><mi>x</mi> <mn>0</mn></msub></math> , the starting point for
    the fixed point iteration, matters for whether it converges to a fixed point or
    not.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 与不动点迭代相关的定理断言，不动点迭代的起始点<math alttext="x 0"><msub><mi>x</mi> <mn>0</mn></msub></math>的选择对于是否收敛到一个不动点很重要。
- en: How do we use it to solve ODEs and PDEs?
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们如何用它来解ODEs和PDEs？
- en: Our concern for this chapter is finding solutions of differential equations,
    which are functions. So we will first re-formulate a PDE in a way that its solution
    *u* satisfies an equation that looks like *F(u)=u* (note that *F* here is an *operator*
    not a *function*), making it perfect for a fixed point iteration setting, then
    we will apply the same logic above and construct a sequence of *functions* that
    hopefully, under the right conditions, converges to the fixed point <math alttext="u
    Superscript asterisk"><msup><mi>u</mi> <mo>*</mo></msup></math> of the *operator*,
    which is the solution of the PDE that we are looking for. Note that in the previous
    discussion, we constructed a sequence of *numbers* (rather than functions) that
    hopefully, under the right conditions, converges to a fixed point of a *function*
    (rather than an operator).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们关注的是找到微分方程的解，这些解是函数。因此，我们首先会重新表述一个PDE，使得它的解*u*满足一个看起来像*F(u)=u*的方程（注意这里的*F*是一个*算子*而不是一个*函数*），使其适合于一个不动点迭代设置，然后我们将应用上述相同的逻辑并构建一个*函数*序列，希望在正确的条件下，收敛到*算子*的不动点<math
    alttext="u Superscript asterisk"><msup><mi>u</mi> <mo>*</mo></msup></math>，这就是我们正在寻找的PDE的解。请注意，在前面的讨论中，我们构建了一个*数字*序列（而不是函数），希望在正确的条件下，收敛到一个*函数*（而不是算子）的不动点。
- en: Let’s demonstrate this using a *dynamical system* setting. This is one of the
    most important, general, and well studied ordinary differential equations, which
    describes the time evolution of a point in space. It is easy in the sense that
    it is usually first order with only one derivative to get rid of, and hard in
    the sense that it is generally nonlinear. There is a habit of linearizing the
    dynamical system near a point and studying its linearized behavior. This is many
    times informative about the nonlinear behavior, but the two should not be conflated.
    Too much is known about linearized systems and not much is known about nonlinear
    systems so we need equal attention to nonlinear systems. In this section we do
    not linearize. Instead, we find approximate the solution using a series constructed
    by a fixed point iteration.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用*动力系统*设置来演示这一点。这是描述空间中点的时间演变的最重要、最普遍和最深入研究的常微分方程之一。它易于理解，因为通常是一阶的，只有一个导数需要消除，但在一般情况下是非线性的，因此难以理解。人们习惯于在线性系统附近对动力系统进行线性化研究其线性化行为。这通常对非线性行为具有启发性，但两者不应混淆。对于线性化系统了解很多，对于非线性系统了解很少，因此我们需要同等关注非线性系统。在本节中，我们不进行线性化。相反，我们使用固定点迭代构造的级数来近似解。
- en: 'Knowing the initial state of the point <math alttext="ModifyingAbove u With
    right-arrow left-parenthesis t 0 right-parenthesis equals ModifyingAbove u With
    right-arrow Subscript 0"><mrow><mover accent="true"><mi>u</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <msub><mi>t</mi> <mn>0</mn></msub> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>0</mn></msub></mrow></math>
    , a solution trajectory <math alttext="ModifyingAbove u With right-arrow left-parenthesis
    t right-parenthesis"><mrow><mover accent="true"><mi>u</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math> tracks all of its
    future states. The function <math alttext="ModifyingAbove f With right-arrow left-parenthesis
    ModifyingAbove u With right-arrow left-parenthesis t right-parenthesis comma a
    left-parenthesis t right-parenthesis comma t right-parenthesis"><mrow><mover accent="true"><mi>f</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mover accent="true"><mi>u</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    specifies the evolution:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 知道点的初始状态<math alttext="ModifyingAbove u With right-arrow left-parenthesis t
    0 right-parenthesis equals ModifyingAbove u With right-arrow Subscript 0"><mrow><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mi>t</mi>
    <mn>0</mn></msub> <mo>)</mo></mrow> <mo>=</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>0</mn></msub></mrow></math>，一个解轨迹<math alttext="ModifyingAbove
    u With right-arrow left-parenthesis t right-parenthesis"><mrow><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>跟踪其所有未来状态。函数<math
    alttext="ModifyingAbove f With right-arrow left-parenthesis ModifyingAbove u With
    right-arrow left-parenthesis t right-parenthesis comma a left-parenthesis t right-parenthesis
    comma t right-parenthesis"><mrow><mover accent="true"><mi>f</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mover accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>指定了演变：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column StartFraction
    d ModifyingAbove u With right-arrow left-parenthesis t right-parenthesis Over
    d t EndFraction equals ModifyingAbove f With right-arrow left-parenthesis ModifyingAbove
    u With right-arrow left-parenthesis t right-parenthesis comma a left-parenthesis
    t right-parenthesis comma t right-parenthesis 2nd Row 1st Column Blank 2nd Column
    ModifyingAbove u With right-arrow left-parenthesis t 0 right-parenthesis equals
    ModifyingAbove u With right-arrow Subscript 0 EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mfrac><mrow><mi>d</mi><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover><mrow><mo>(</mo><mi>t</mi><mo>)</mo></mrow></mrow> <mrow><mi>d</mi><mi>t</mi></mrow></mfrac>
    <mo>=</mo> <mover accent="true"><mi>f</mi> <mo>→</mo></mover> <mrow><mo>(</mo>
    <mover accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mi>t</mi>
    <mn>0</mn></msub> <mo>)</mo></mrow> <mo>=</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>0</mn></msub></mrow></mtd></mtr></mtable></math>
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column StartFraction
    d ModifyingAbove u With right-arrow left-parenthesis t right-parenthesis Over
    d t EndFraction equals ModifyingAbove f With right-arrow left-parenthesis ModifyingAbove
    u With right-arrow left-parenthesis t right-parenthesis comma a left-parenthesis
    t right-parenthesis comma t right-parenthesis 2nd Row 1st Column Blank 2nd Column
    ModifyingAbove u With right-arrow left-parenthesis t 0 right-parenthesis equals
    ModifyingAbove u With right-arrow Subscript 0 EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mfrac><mrow><mi>d</mi><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover><mrow><mo>(</mo><mi>t</mi><mo>)</mo></mrow></mrow> <mrow><mi>d</mi><mi>t</mi></mrow></mfrac>
    <mo>=</mo> <mover accent="true"><mi>f</mi> <mo>→</mo></mover> <mrow><mo>(</mo>
    <mover accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mi>t</mi>
    <mn>0</mn></msub> <mo>)</mo></mrow> <mo>=</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>0</mn></msub></mrow></mtd></mtr></mtable></math>
- en: 'There is one derivative with respect to time that we need to get rid of, so
    we integrate once with respect to time:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要消除一个关于时间的导数，因此我们对时间积分一次：
- en: <math alttext="dollar-sign ModifyingAbove u With right-arrow left-parenthesis
    t right-parenthesis equals ModifyingAbove u With right-arrow Subscript 0 Baseline
    plus integral Subscript t 0 Superscript t Baseline ModifyingAbove f With right-arrow
    left-parenthesis ModifyingAbove u With right-arrow left-parenthesis s right-parenthesis
    comma a left-parenthesis s right-parenthesis comma s right-parenthesis d s dollar-sign"><mrow><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>0</mn></msub>
    <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi> <mn>0</mn></msub></mrow>
    <mi>t</mi></msubsup> <mover accent="true"><mi>f</mi> <mo>→</mo></mover> <mrow><mo>(</mo>
    <mover accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>s</mi>
    <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi></mrow></math>
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign ModifyingAbove u With right-arrow left-parenthesis
    t right-parenthesis equals ModifyingAbove u With right-arrow Subscript 0 Baseline
    plus integral Subscript t 0 Superscript t Baseline ModifyingAbove f With right-arrow
    left-parenthesis ModifyingAbove u With right-arrow left-parenthesis s right-parenthesis
    comma a left-parenthesis s right-parenthesis comma s right-parenthesis d s dollar-sign"><mrow><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>0</mn></msub>
    <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi> <mn>0</mn></msub></mrow>
    <mi>t</mi></msubsup> <mover accent="true"><mi>f</mi> <mo>→</mo></mover> <mrow><mo>(</mo>
    <mover accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>s</mi>
    <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi></mrow></math>
- en: 'Now let’s re-write the above integral equation in a form that is ripe for the
    fixed point iteration: We consider the whole right hand side as an operator whose
    input is <math alttext="ModifyingAbove u With right-arrow left-parenthesis t right-parenthesis"><mrow><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    ,'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们以适合固定点迭代的形式重新写上述积分方程：我们将整个右手边视为一个运算符，其输入为<math alttext="ModifyingAbove
    u With right-arrow left-parenthesis t right-parenthesis"><mrow><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>，
- en: <math alttext="dollar-sign ModifyingAbove u With right-arrow left-parenthesis
    t right-parenthesis equals upper F left-parenthesis ModifyingAbove u With right-arrow
    left-parenthesis t right-parenthesis right-parenthesis period dollar-sign"><mrow><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <mover accent="true"><mi>u</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>.</mo></mrow></math>
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign ModifyingAbove u With right-arrow left-parenthesis
    t right-parenthesis equals upper F left-parenthesis ModifyingAbove u With right-arrow
    left-parenthesis t right-parenthesis right-parenthesis period dollar-sign"><mrow><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <mover accent="true"><mi>u</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>.</mo></mrow></math>
- en: 'Now we can generate the sequence <math alttext="StartSet ModifyingAbove u With
    right-arrow Subscript 0 Baseline left-parenthesis t right-parenthesis comma ModifyingAbove
    u With right-arrow Subscript 1 Baseline left-parenthesis t right-parenthesis comma
    ModifyingAbove u With right-arrow Subscript 2 Baseline left-parenthesis t right-parenthesis
    comma ModifyingAbove u With right-arrow Subscript 3 Baseline left-parenthesis
    t right-parenthesis comma ellipsis EndSet"><mrow><mo>{</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>,</mo> <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>1</mn></msub>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>,</mo> <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>3</mn></msub>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mo>⋯</mo> <mo>}</mo></mrow></math>
    that converges to the solution <math alttext="ModifyingAbove u With right-arrow
    left-parenthesis t right-parenthesis"><mrow><mover accent="true"><mi>u</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math> , for all time or
    for a finite amount of time, under the right conditions on *f*. The sequence looks
    like:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以生成序列<math alttext="StartSet ModifyingAbove u With right-arrow Subscript
    0 Baseline left-parenthesis t right-parenthesis comma ModifyingAbove u With right-arrow
    Subscript 1 Baseline left-parenthesis t right-parenthesis comma ModifyingAbove
    u With right-arrow Subscript 2 Baseline left-parenthesis t right-parenthesis comma
    ModifyingAbove u With right-arrow Subscript 3 Baseline left-parenthesis t right-parenthesis
    comma ellipsis EndSet"><mrow><mo>{</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>,</mo> <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>1</mn></msub>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>,</mo> <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>3</mn></msub>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mo>⋯</mo> <mo>}</mo></mrow></math>，它收敛到解<math
    alttext="ModifyingAbove u With right-arrow left-parenthesis t right-parenthesis"><mrow><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>，在所有时间或有限时间内，在*f*的正确条件下。该序列看起来像：
- en: <math alttext="ModifyingAbove u With right-arrow Subscript 0 Baseline left-parenthesis
    t right-parenthesis equals ModifyingAbove u With right-arrow Subscript 0 Baseline
    left-parenthesis t right-parenthesis"><mrow><msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>0</mn></msub>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="ModifyingAbove u With right-arrow Subscript 0 Baseline left-parenthesis
    t right-parenthesis equals ModifyingAbove u With right-arrow Subscript 0 Baseline
    left-parenthesis t right-parenthesis"><mrow><msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>0</mn></msub>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
- en: <math alttext="ModifyingAbove u With right-arrow Subscript 1 Baseline left-parenthesis
    t right-parenthesis equals upper F left-parenthesis ModifyingAbove u With right-arrow
    Subscript 0 Baseline left-parenthesis t right-parenthesis right-parenthesis equals
    ModifyingAbove u With right-arrow Subscript 0 Baseline plus integral Subscript
    t 0 Superscript t Baseline ModifyingAbove f With right-arrow left-parenthesis
    ModifyingAbove u With right-arrow Subscript 0 Baseline left-parenthesis s right-parenthesis
    comma a left-parenthesis s right-parenthesis comma s right-parenthesis d s"><mrow><msub><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>1</mn></msub> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <msub><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>0</mn></msub> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>0</mn></msub> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi>
    <mn>0</mn></msub></mrow> <mi>t</mi></msubsup> <mover accent="true"><mi>f</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover>
    <mn>0</mn></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi></mrow></math>
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="ModifyingAbove u With right-arrow Subscript 1 Baseline left-parenthesis
    t right-parenthesis equals upper F left-parenthesis ModifyingAbove u With right-arrow
    Subscript 0 Baseline left-parenthesis t right-parenthesis right-parenthesis equals
    ModifyingAbove u With right-arrow Subscript 0 Baseline plus integral Subscript
    t 0 Superscript t Baseline ModifyingAbove f With right-arrow left-parenthesis
    ModifyingAbove u With right-arrow Subscript 0 Baseline left-parenthesis s right-parenthesis
    comma a left-parenthesis s right-parenthesis comma s right-parenthesis d s"><mrow><msub><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>1</mn></msub> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <msub><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>0</mn></msub> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>0</mn></msub> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi>
    <mn>0</mn></msub></mrow> <mi>t</mi></msubsup> <mover accent="true"><mi>f</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover>
    <mn>0</mn></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi></mrow></math>
- en: <math alttext="ModifyingAbove u With right-arrow Subscript 2 Baseline left-parenthesis
    t right-parenthesis equals upper F left-parenthesis ModifyingAbove u With right-arrow
    Subscript 1 Baseline left-parenthesis t right-parenthesis right-parenthesis equals
    ModifyingAbove u With right-arrow Subscript 0 Baseline plus integral Subscript
    t 0 Superscript t Baseline ModifyingAbove f With right-arrow left-parenthesis
    ModifyingAbove u With right-arrow Subscript 1 Baseline left-parenthesis s right-parenthesis
    comma a left-parenthesis s right-parenthesis comma s right-parenthesis d s"><mrow><msub><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>2</mn></msub> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <msub><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>1</mn></msub> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>0</mn></msub> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi>
    <mn>0</mn></msub></mrow> <mi>t</mi></msubsup> <mover accent="true"><mi>f</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover>
    <mn>1</mn></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi></mrow></math>
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="ModifyingAbove u With right-arrow Subscript 2 Baseline left-parenthesis
    t right-parenthesis equals upper F left-parenthesis ModifyingAbove u With right-arrow
    Subscript 1 Baseline left-parenthesis t right-parenthesis right-parenthesis equals
    ModifyingAbove u With right-arrow Subscript 0 Baseline plus integral Subscript
    t 0 Superscript t Baseline ModifyingAbove f With right-arrow left-parenthesis
    ModifyingAbove u With right-arrow Subscript 1 Baseline left-parenthesis s right-parenthesis
    comma a left-parenthesis s right-parenthesis comma s right-parenthesis d s"><mrow><msub><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>2</mn></msub> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <msub><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>1</mn></msub> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>0</mn></msub> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi>
    <mn>0</mn></msub></mrow> <mi>t</mi></msubsup> <mover accent="true"><mi>f</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover>
    <mn>1</mn></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi></mrow></math>
- en: <math alttext="ModifyingAbove u With right-arrow Subscript 3 Baseline left-parenthesis
    t right-parenthesis equals upper F left-parenthesis ModifyingAbove u With right-arrow
    Subscript 2 Baseline left-parenthesis t right-parenthesis right-parenthesis equals
    ModifyingAbove u With right-arrow Subscript 0 Baseline plus integral Subscript
    t 0 Superscript t Baseline ModifyingAbove f With right-arrow left-parenthesis
    ModifyingAbove u With right-arrow Subscript 2 Baseline left-parenthesis s right-parenthesis
    comma a left-parenthesis s right-parenthesis comma s right-parenthesis d s"><mrow><msub><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>3</mn></msub> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <msub><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>2</mn></msub> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>0</mn></msub> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi>
    <mn>0</mn></msub></mrow> <mi>t</mi></msubsup> <mover accent="true"><mi>f</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover>
    <mn>2</mn></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi></mrow></math>
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="ModifyingAbove u With right-arrow Subscript 3 Baseline left-parenthesis
    t right-parenthesis equals upper F left-parenthesis ModifyingAbove u With right-arrow
    Subscript 2 Baseline left-parenthesis t right-parenthesis right-parenthesis equals
    ModifyingAbove u With right-arrow Subscript 0 Baseline plus integral Subscript
    t 0 Superscript t Baseline ModifyingAbove f With right-arrow left-parenthesis
    ModifyingAbove u With right-arrow Subscript 2 Baseline left-parenthesis s right-parenthesis
    comma a left-parenthesis s right-parenthesis comma s right-parenthesis d s"><mrow><msub><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>3</mn></msub> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <msub><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>2</mn></msub> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>0</mn></msub> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi>
    <mn>0</mn></msub></mrow> <mi>t</mi></msubsup> <mover accent="true"><mi>f</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover>
    <mn>2</mn></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi></mrow></math>
- en: and so on…
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 等等...
- en: Simple but very informative example
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单但非常有启发性的例子
- en: 'The best examples are the ones that are simple enough to have multiple ways
    of solving them. Seeing more than one way to do the same thing at once helps solidify
    the gist of a newly learned method. Consider the very simple one dimensional and
    linear dynamical system:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的例子是那些简单到有多种解决方法的例子。同时看到多种解决方法有助于巩固新学习方法的要点。考虑非常简单的一维线性动力系统：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column StartFraction
    d u left-parenthesis t right-parenthesis Over d t EndFraction equals u left-parenthesis
    t right-parenthesis 2nd Row 1st Column Blank 2nd Column u left-parenthesis 0 right-parenthesis
    equals 1 period EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mfrac><mrow><mi>d</mi><mi>u</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow>
    <mrow><mi>d</mi><mi>t</mi></mrow></mfrac> <mo>=</mo> <mi>u</mi> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>u</mi>
    <mo>(</mo> <mn>0</mn> <mo>)</mo> <mo>=</mo> <mn>1</mn> <mo>.</mo></mrow></mtd></mtr></mtable></math>
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column StartFraction
    d u left-parenthesis t right-parenthesis Over d t EndFraction equals u left-parenthesis
    t right-parenthesis 2nd Row 1st Column Blank 2nd Column u left-parenthesis 0 right-parenthesis
    equals 1 period EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mfrac><mrow><mi>d</mi><mi>u</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow>
    <mrow><mi>d</mi><mi>t</mi></mrow></mfrac> <mo>=</mo> <mi>u</mi> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>u</mi>
    <mo>(</mo> <mn>0</mn> <mo>)</mo> <mo>=</mo> <mn>1</mn> <mo>.</mo></mrow></mtd></mtr></mtable></math>
- en: 'The first way to solve this is by separation of variables, where we put everything
    that has *u(t)* on one side of the equation, and everything that has *t* alone
    on the other side:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的第一种方法是通过变量分离，将所有包含 *u(t)* 的内容放在方程的一边，将所有仅包含 *t* 的内容放在另一边：
- en: <math alttext="dollar-sign StartFraction d u left-parenthesis t right-parenthesis
    Over u left-parenthesis t right-parenthesis EndFraction equals d t dollar-sign"><mrow><mfrac><mrow><mi>d</mi><mi>u</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow>
    <mrow><mi>u</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow></mfrac> <mo>=</mo> <mi>d</mi>
    <mi>t</mi></mrow></math>
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartFraction d u left-parenthesis t right-parenthesis
    Over u left-parenthesis t right-parenthesis EndFraction equals d t dollar-sign"><mrow><mfrac><mrow><mi>d</mi><mi>u</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow>
    <mrow><mi>u</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow></mfrac> <mo>=</mo> <mi>d</mi>
    <mi>t</mi></mrow></math>
- en: 'Now we can integrate from *0* to *t*:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从 *0* 积分到 *t*：
- en: <math alttext="dollar-sign integral Subscript 0 Superscript t Baseline StartFraction
    d u left-parenthesis s right-parenthesis Over u left-parenthesis s right-parenthesis
    EndFraction equals integral Subscript 0 Superscript t Baseline d s dollar-sign"><mrow><msubsup><mo>∫</mo>
    <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup> <mfrac><mrow><mi>d</mi><mi>u</mi><mo>(</mo><mi>s</mi><mo>)</mo></mrow>
    <mrow><mi>u</mi><mo>(</mo><mi>s</mi><mo>)</mo></mrow></mfrac> <mo>=</mo> <msubsup><mo>∫</mo>
    <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup> <mi>d</mi> <mi>s</mi></mrow></math>
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign integral Subscript 0 Superscript t Baseline StartFraction
    d u left-parenthesis s right-parenthesis Over u left-parenthesis s right-parenthesis
    EndFraction equals integral Subscript 0 Superscript t Baseline d s dollar-sign"><mrow><msubsup><mo>∫</mo>
    <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup> <mfrac><mrow><mi>d</mi><mi>u</mi><mo>(</mo><mi>s</mi><mo>)</mo></mrow>
    <mrow><mi>u</mi><mo>(</mo><mi>s</mi><mo>)</mo></mrow></mfrac> <mo>=</mo> <msubsup><mo>∫</mo>
    <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup> <mi>d</mi> <mi>s</mi></mrow></math>
- en: 'We get <math alttext="ln left-parenthesis u left-parenthesis t right-parenthesis
    right-parenthesis equals t"><mrow><mo form="prefix">ln</mo> <mo>(</mo> <mi>u</mi>
    <mo>(</mo> <mi>t</mi> <mo>)</mo> <mo>)</mo> <mo>=</mo> <mi>t</mi></mrow></math>
    therefore the solution of our simple dynamical system using the separation of
    variables method is <math alttext="u left-parenthesis t right-parenthesis equals
    e Superscript t"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mi>e</mi> <mi>t</mi></msup></mrow></math> (arguably the most
    important function in mathematics). Now let’s construct a sequence of functions
    using the fixed point iteration and see if it converges to the solution <math
    alttext="u left-parenthesis t right-parenthesis equals e Superscript t"><mrow><mi>u</mi>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi> <mi>t</mi></msup></mrow></math>
    of the dynamical system:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到 <math alttext="ln left-parenthesis u left-parenthesis t right-parenthesis
    right-parenthesis equals t"><mrow><mo form="prefix">ln</mo> <mo>(</mo> <mi>u</mi>
    <mo>(</mo> <mi>t</mi> <mo>)</mo> <mo>)</mo> <mo>=</mo> <mi>t</mi></mrow></math>
    因此我们使用变量分离方法解决我们简单的动力系统，得到解 <math alttext="u left-parenthesis t right-parenthesis
    equals e Superscript t"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mi>e</mi> <mi>t</mi></msup></mrow></math>（可以说是数学中最重要的函数）。现在让我们使用不动点迭代构造一系列函数，并看它是否收敛到动力系统的解
    <math alttext="u left-parenthesis t right-parenthesis equals e Superscript t"><mrow><mi>u</mi>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi> <mi>t</mi></msup></mrow></math>：
- en: <math alttext="u 0 left-parenthesis t right-parenthesis equals 1"><mrow><msub><mi>u</mi>
    <mn>0</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>1</mn></mrow></math>
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="u 0 left-parenthesis t right-parenthesis equals 1"><mrow><msub><mi>u</mi>
    <mn>0</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>1</mn></mrow></math>
- en: <math alttext="u 1 left-parenthesis t right-parenthesis equals upper F left-parenthesis
    u 0 left-parenthesis t right-parenthesis right-parenthesis equals u 0 left-parenthesis
    t right-parenthesis plus integral Subscript 0 Superscript t Baseline u 0 left-parenthesis
    s right-parenthesis d s equals 1 plus integral Subscript 0 Superscript t Baseline
    1 d s equals 1 plus t"><mrow><msub><mi>u</mi> <mn>1</mn></msub> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <msub><mi>u</mi>
    <mn>0</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>+</mo> <msubsup><mo>∫</mo> <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup> <msub><mi>u</mi>
    <mn>0</mn></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi>
    <mo>=</mo> <mn>1</mn> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup>
    <mn>1</mn> <mi>d</mi> <mi>s</mi> <mo>=</mo> <mn>1</mn> <mo>+</mo> <mi>t</mi></mrow></math>
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="u 1 left-parenthesis t right-parenthesis equals upper F left-parenthesis
    u 0 left-parenthesis t right-parenthesis right-parenthesis equals u 0 left-parenthesis
    t right-parenthesis plus integral Subscript 0 Superscript t Baseline u 0 left-parenthesis
    s right-parenthesis d s equals 1 plus integral Subscript 0 Superscript t Baseline
    1 d s equals 1 plus t"><mrow><msub><mi>u</mi> <mn>1</mn></msub> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <msub><mi>u</mi>
    <mn>0</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>+</mo> <msubsup><mo>∫</mo> <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup> <msub><mi>u</mi>
    <mn>0</mn></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi>
    <mo>=</mo> <mn>1</mn> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup>
    <mn>1</mn> <mi>d</mi> <mi>s</mi> <mo>=</mo> <mn>1</mn> <mo>+</mo> <mi>t</mi></mrow></math>
- en: <math alttext="u 2 left-parenthesis t right-parenthesis equals upper F left-parenthesis
    u 1 left-parenthesis t right-parenthesis right-parenthesis equals u 0 left-parenthesis
    t right-parenthesis plus integral Subscript 0 Superscript t Baseline u 1 left-parenthesis
    s right-parenthesis d s equals 1 plus integral Subscript 0 Superscript t Baseline
    1 plus s d s equals 1 plus t plus StartFraction t squared Over 2 EndFraction"><mrow><msub><mi>u</mi>
    <mn>2</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi>
    <mrow><mo>(</mo> <msub><mi>u</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>u</mi> <mn>0</mn></msub>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><mn>0</mn></mrow>
    <mi>t</mi></msubsup> <msub><mi>u</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>s</mi>
    <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mo>=</mo> <mn>1</mn> <mo>+</mo> <msubsup><mo>∫</mo>
    <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup> <mn>1</mn> <mo>+</mo> <mi>s</mi>
    <mi>d</mi> <mi>s</mi> <mo>=</mo> <mn>1</mn> <mo>+</mo> <mi>t</mi> <mo>+</mo> <mfrac><msup><mi>t</mi>
    <mn>2</mn></msup> <mn>2</mn></mfrac></mrow></math>
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="u 2 left-parenthesis t right-parenthesis equals upper F left-parenthesis
    u 1 left-parenthesis t right-parenthesis right-parenthesis equals u 0 left-parenthesis
    t right-parenthesis plus integral Subscript 0 Superscript t Baseline u 1 left-parenthesis
    s right-parenthesis d s equals 1 plus integral Subscript 0 Superscript t Baseline
    1 plus s d s equals 1 plus t plus StartFraction t squared Over 2 EndFraction"><mrow><msub><mi>u</mi>
    <mn>2</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi>
    <mrow><mo>(</mo> <msub><mi>u</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>u</mi> <mn>0</mn></msub>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><mn>0</mn></mrow>
    <mi>t</mi></msubsup> <msub><mi>u</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>s</mi>
    <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mo>=</mo> <mn>1</mn> <mo>+</mo> <msubsup><mo>∫</mo>
    <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup> <mn>1</mn> <mo>+</mo> <mi>s</mi>
    <mi>d</mi> <mi>s</mi> <mo>=</mo> <mn>1</mn> <mo>+</mo> <mi>t</mi> <mo>+</mo> <mfrac><msup><mi>t</mi>
    <mn>2</mn></msup> <mn>2</mn></mfrac></mrow></math>
- en: <math alttext="u 3 left-parenthesis t right-parenthesis equals upper F left-parenthesis
    u 2 left-parenthesis t right-parenthesis right-parenthesis equals u 0 left-parenthesis
    t right-parenthesis plus integral Subscript 0 Superscript t Baseline u 2 left-parenthesis
    s right-parenthesis d s equals 1 plus integral Subscript 0 Superscript t Baseline
    1 plus s plus StartFraction s squared Over 2 EndFraction d s equals 1 plus t plus
    StartFraction t squared Over 2 EndFraction plus StartFraction t cubed Over 3 factorial
    EndFraction"><mrow><msub><mi>u</mi> <mn>3</mn></msub> <mrow><mo>(</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <msub><mi>u</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>u</mi>
    <mn>0</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>+</mo> <msubsup><mo>∫</mo>
    <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup> <msub><mi>u</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mo>=</mo>
    <mn>1</mn> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup>
    <mn>1</mn> <mo>+</mo> <mi>s</mi> <mo>+</mo> <mfrac><msup><mi>s</mi> <mn>2</mn></msup>
    <mn>2</mn></mfrac> <mi>d</mi> <mi>s</mi> <mo>=</mo> <mn>1</mn> <mo>+</mo> <mi>t</mi>
    <mo>+</mo> <mfrac><msup><mi>t</mi> <mn>2</mn></msup> <mn>2</mn></mfrac> <mo>+</mo>
    <mfrac><msup><mi>t</mi> <mn>3</mn></msup> <mrow><mn>3</mn><mo>!</mo></mrow></mfrac></mrow></math>
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math alttext="u 3 left-parenthesis t right-parenthesis equals upper F left-parenthesis
    u 2 left-parenthesis t right-parenthesis right-parenthesis equals u 0 left-parenthesis
    t right-parenthesis plus integral Subscript 0 Superscript t Baseline u 2 left-parenthesis
    s right-parenthesis d s equals 1 plus integral Subscript 0 Superscript t Baseline
    1 plus s plus StartFraction s squared Over 2 EndFraction d s equals 1 plus t plus
    StartFraction t squared Over 2 EndFraction plus StartFraction t cubed Over 3 factorial
    EndFraction"><mrow><msub><mi>u</mi> <mn>3</mn></msub> <mrow><mo>(</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <msub><mi>u</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>u</mi>
    <mn>0</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>+</mo> <msubsup><mo>∫</mo>
    <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup> <msub><mi>u</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mo>=</mo>
    <mn>1</mn> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup>
    <mn>1</mn> <mo>+</mo> <mi>s</mi> <mo>+</mo> <mfrac><msup><mi>s</mi> <mn>2</mn></msup>
    <mn>2</mn></mfrac> <mi>d</mi> <mi>s</mi> <mo>=</mo> <mn>1</mn> <mo>+</mo> <mi>t</mi>
    <mo>+</mo> <mfrac><msup><mi>t</mi> <mn>2</mn></msup> <mn>2</mn></mfrac> <mo>+</mo>
    <mfrac><msup><mi>t</mi> <mn>3</mn></msup> <mrow><mn>3</mn><mo>!</mo></mrow></mfrac></mrow></math>
- en: 'Keep going: <math alttext="u Subscript n Baseline left-parenthesis t right-parenthesis
    equals upper F left-parenthesis u Subscript n minus 1 Baseline left-parenthesis
    t right-parenthesis right-parenthesis equals u 0 left-parenthesis t right-parenthesis
    plus integral Subscript 0 Superscript t Baseline u Subscript n minus 1 Baseline
    left-parenthesis s right-parenthesis d s equals 1 plus t plus StartFraction t
    squared Over 2 EndFraction plus StartFraction t cubed Over 3 factorial EndFraction
    plus ellipsis plus StartFraction t Superscript n Baseline Over n factorial EndFraction"><mrow><msub><mi>u</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi>
    <mrow><mo>(</mo> <msub><mi>u</mi> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>u</mi>
    <mn>0</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>+</mo> <msubsup><mo>∫</mo>
    <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup> <msub><mi>u</mi> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mo>=</mo>
    <mn>1</mn> <mo>+</mo> <mi>t</mi> <mo>+</mo> <mfrac><msup><mi>t</mi> <mn>2</mn></msup>
    <mn>2</mn></mfrac> <mo>+</mo> <mfrac><msup><mi>t</mi> <mn>3</mn></msup> <mrow><mn>3</mn><mo>!</mo></mrow></mfrac>
    <mo>+</mo> <mo>⋯</mo> <mo>+</mo> <mfrac><msup><mi>t</mi> <mi>n</mi></msup> <mrow><mi>n</mi><mo>!</mo></mrow></mfrac></mrow></math>'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续： <math alttext="u Subscript n Baseline left-parenthesis t right-parenthesis
    equals upper F left-parenthesis u Subscript n minus 1 Baseline left-parenthesis
    t right-parenthesis right-parenthesis equals u 0 left-parenthesis t right-parenthesis
    plus integral Subscript 0 Superscript t Baseline u Subscript n minus 1 Baseline
    left-parenthesis s right-parenthesis d s equals 1 plus t plus StartFraction t
    squared Over 2 EndFraction plus StartFraction t cubed Over 3 factorial EndFraction
    plus ellipsis plus StartFraction t Superscript n Baseline Over n factorial EndFraction"><mrow><msub><mi>u</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi>
    <mrow><mo>(</mo> <msub><mi>u</mi> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>u</mi>
    <mn>0</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>+</mo> <msubsup><mo>∫</mo>
    <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup> <msub><mi>u</mi> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mo>=</mo>
    <mn>1</mn> <mo>+</mo> <mi>t</mi> <mo>+</mo> <mfrac><msup><mi>t</mi> <mn>2</mn></msup>
    <mn>2</mn></mfrac> <mo>+</mo> <mfrac><msup><mi>t</mi> <mn>3</mn></msup> <mrow><mn>3</mn><mo>!</mo></mrow></mfrac>
    <mo>+</mo> <mo>⋯</mo> <mo>+</mo> <mfrac><msup><mi>t</mi> <mi>n</mi></msup> <mrow><mi>n</mi><mo>!</mo></mrow></mfrac></mrow></math>
- en: As <math alttext="n right-arrow normal infinity"><mrow><mi>n</mi> <mo>→</mo>
    <mi>∞</mi></mrow></math> , the fixed point iteration converges to the series
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 当 <math alttext="n right-arrow normal infinity"><mrow><mi>n</mi> <mo>→</mo>
    <mi>∞</mi></mrow></math> 时，不动点迭代收敛到级数
- en: <math alttext="dollar-sign u Subscript normal infinity Baseline left-parenthesis
    t right-parenthesis equals 1 plus t plus StartFraction t squared Over 2 EndFraction
    plus StartFraction t cubed Over 3 factorial EndFraction plus ellipsis plus StartFraction
    t Superscript n Baseline Over n factorial EndFraction plus ellipsis equals sigma-summation
    Underscript n equals 0 Overscript normal infinity Endscripts StartFraction t Superscript
    n Baseline Over n factorial EndFraction dollar-sign"><mrow><msub><mi>u</mi> <mi>∞</mi></msub>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>1</mn> <mo>+</mo>
    <mi>t</mi> <mo>+</mo> <mfrac><msup><mi>t</mi> <mn>2</mn></msup> <mn>2</mn></mfrac>
    <mo>+</mo> <mfrac><msup><mi>t</mi> <mn>3</mn></msup> <mrow><mn>3</mn><mo>!</mo></mrow></mfrac>
    <mo>+</mo> <mo>⋯</mo> <mo>+</mo> <mfrac><msup><mi>t</mi> <mi>n</mi></msup> <mrow><mi>n</mi><mo>!</mo></mrow></mfrac>
    <mo>+</mo> <mo>⋯</mo> <mo>=</mo> <msubsup><mo>∑</mo> <mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow>
    <mi>∞</mi></msubsup> <mfrac><msup><mi>t</mi> <mi>n</mi></msup> <mrow><mi>n</mi><mo>!</mo></mrow></mfrac></mrow></math>
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign u Subscript normal infinity Baseline left-parenthesis
    t right-parenthesis equals 1 plus t plus StartFraction t squared Over 2 EndFraction
    plus StartFraction t cubed Over 3 factorial EndFraction plus ellipsis plus StartFraction
    t Superscript n Baseline Over n factorial EndFraction plus ellipsis equals sigma-summation
    Underscript n equals 0 Overscript normal infinity Endscripts StartFraction t Superscript
    n Baseline Over n factorial EndFraction dollar-sign"><mrow><msub><mi>u</mi> <mi>∞</mi></msub>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>1</mn> <mo>+</mo>
    <mi>t</mi> <mo>+</mo> <mfrac><msup><mi>t</mi> <mn>2</mn></msup> <mn>2</mn></mfrac>
    <mo>+</mo> <mfrac><msup><mi>t</mi> <mn>3</mn></msup> <mrow><mn>3</mn><mo>!</mo></mrow></mfrac>
    <mo>+</mo> <mo>⋯</mo> <mo>+</mo> <mfrac><msup><mi>t</mi> <mi>n</mi></msup> <mrow><mi>n</mi><mo>!</mo></mrow></mfrac>
    <mo>+</mo> <mo>⋯</mo> <mo>=</mo> <msubsup><mo>∑</mo> <mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow>
    <mi>∞</mi></msubsup> <mfrac><msup><mi>t</mi> <mi>n</mi></msup> <mrow><mi>n</mi><mo>!</mo></mrow></mfrac></mrow></math>
- en: which is the power series expansion of <math alttext="u left-parenthesis t right-parenthesis
    equals e Superscript t"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mi>e</mi> <mi>t</mi></msup></mrow></math> , the same solution
    we arrived at using separation of variables (albeit in different form). Cool.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 <math alttext="u left-parenthesis t right-parenthesis equals e Superscript
    t"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mrow> <mo>=</mo> <msup><mi>e</mi>
    <mi>t</mi></msup></mrow></math> 的幂级数展开，与我们使用变量分离得到的解相同（尽管形式不同）。很酷。
- en: When we use this iterative way to construct a solution of a dynamical system,
    or of a PDE reformulated as a dynamical system or in a way that is fit for a fixed
    point iteration (*u=F(u)*), we call it *Picard’s iteration*. It is simple and
    arrives at the solution (when it converges) in steps.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用这种迭代方式构造动力系统的解，或者将PDE重新表述为动力系统，或者适合不动点迭代的方式（*u=F(u)*），我们称之为*皮卡迭代*。它简单并且在步骤中到达解（当它收敛时）。
- en: Where is the complication?
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复杂在哪里？
- en: Why don’t we use *Picard’s iteration* to construct solutions of *all* dynamical
    systems and of *all* PDEs that we are able to reformulate into a form fit for
    fixed point iteration? As always, the answer is the curse of dimensionality. Even
    for our very simple *one dimensional* and linear example, each Picard iteration
    step involves evaluating an integral, which for more complex problems we have
    to evaluate numerically. For example, for dynamical systems representing the evolution
    and interactions of many particles, this gets multiplied by the number of particles.
    Overall in the ODE and PDE literature, there is a limited number of cases where
    practical algorithms are available for high dimensional settings.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不使用*皮卡迭代*来构建*所有*动力系统和*所有*我们能够重构成适合固定点迭代的形式的偏微分方程的解？和往常一样，答案是维度的诅咒。即使对于我们非常简单的*一维*和线性示例，每个皮卡迭代步骤都涉及评估一个积分，对于更复杂的问题，我们必须进行数值评估。例如，对于代表许多粒子的演化和相互作用的动力系统，这个过程会乘以粒子的数量。总体而言，在ODE和PDE文献中，只有有限数量的情况下，可以为高维设置提供实用算法。
- en: Recent successes!
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最近的成功！
- en: 'That said, a recent method for finding explicit solutions for high dimensional
    nonlinear parabolic PDEs and backward stochastic differential equations based
    on Picard’s iteration has been quite successful in finding explicit solutions
    for high dimensional PDEs arising in real life physics and finance applications.
    [The paper’s (2017)](https://arxiv.org/abs/1708.03223) abstract is insightful:
    *Parabolic partial differential equations (PDEs) and backward stochastic differential
    equations (BSDEs) are key ingredients in a number of models in physics and financial
    engineering. In particular, parabolic PDEs and BSDEs are fundamental tools in
    the state-of-the-art pricing and hedging of financial derivatives. The PDEs and
    BSDEs appearing in such applications are often high-dimensional and nonlinear.
    Since explicit solutions of such PDEs and BSDEs are typically not available, it
    is a very active topic of research to solve such PDEs and BSDEs approximately.
    In the recent article [E, W., Hutzenthaler, M., Jentzen, A., and Kruse, T. Linear
    scaling algorithms for solving high-dimensional nonlinear parabolic differential
    equations. arXiv:1607.03295 (2017)] we proposed a family of approximation methods
    based on Picard approximations and multilevel Monte Carlo methods and showed under
    suitable regularity assumptions on the exact solution for semilinear heat equations
    that the computational complexity is bounded by <math alttext="upper O left-parenthesis
    d epsilon Superscript minus left-parenthesis 4 plus delta right-parenthesis Baseline
    right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <mi>d</mi> <msup><mi>ϵ</mi> <mrow><mo>-</mo><mo>(</mo><mn>4</mn><mo>+</mo><mi>δ</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math> for any <math alttext="delta element-of left-parenthesis
    0 comma normal infinity right-parenthesis"><mrow><mi>δ</mi> <mo>∈</mo> <mo>(</mo>
    <mn>0</mn> <mo>,</mo> <mi>∞</mi> <mo>)</mo></mrow></math> , where d is the dimensionality
    of the problem and <math alttext="epsilon element-of left-parenthesis 0 comma
    normal infinity right-parenthesis"><mrow><mi>ϵ</mi> <mo>∈</mo> <mo>(</mo> <mn>0</mn>
    <mo>,</mo> <mi>∞</mi> <mo>)</mo></mrow></math> is the prescribed accuracy. In
    this paper, we test the applicability of this algorithm on a variety of 100-dimensional
    nonlinear PDEs that arise in physics and finance by means of numerical simulations
    presenting approximation accuracy against runtime. The simulation results for
    these 100-dimensional example PDEs are very satisfactory in terms of accuracy
    and speed. In addition, we also provide a review of other approximation methods
    for nonlinear PDEs and BSDEs from the literature.*'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，最近一种基于皮卡迭代找到高维非线性拟线性抛物型PDE和反向随机微分方程的显式解的方法在找到现实生活中物理学和金融应用中出现的高维PDE的显式解方面取得了相当成功。[该论文（2017年）](https://arxiv.org/abs/1708.03223)的摘要很有见地：*抛物型偏微分方程（PDEs）和反向随机微分方程（BSDEs）是物理学和金融工程模型中的关键要素。特别是，抛物型PDE和BSDE是金融衍生品定价和对冲的最先进工具。在这些应用中出现的PDE和BSDE通常是高维和非线性的。由于这些PDE和BSDE的显式解通常不可用，因此解决这些PDE和BSDE的近似方法是一个非常活跃的研究课题。在最近的文章[E,
    W., Hutzenthaler, M., Jentzen, A., and Kruse, T. Linear scaling algorithms for
    solving high-dimensional nonlinear parabolic differential equations. arXiv:1607.03295
    (2017)]中，我们提出了一系列基于皮卡逼近和多层蒙特卡洛方法的近似方法，并在对半线性热方程的精确解的适当正则性假设下表明，计算复杂度受到<math alttext="upper
    O left-parenthesis d epsilon Superscript minus left-parenthesis 4 plus delta right-parenthesis
    Baseline right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <mi>d</mi> <msup><mi>ϵ</mi>
    <mrow><mo>-</mo><mo>(</mo><mn>4</mn><mo>+</mo><mi>δ</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math>的限制，其中d是问题的维度，<math alttext="delta element-of left-parenthesis
    0 comma normal infinity right-parenthesis"><mrow><mi>δ</mi> <mo>∈</mo> <mo>(</mo>
    <mn>0</mn> <mo>,</mo> <mi>∞</mi> <mo>)</mo></mrow></math>，而<math alttext="epsilon
    element-of left-parenthesis 0 comma normal infinity right-parenthesis"><mrow><mi>ϵ</mi>
    <mo>∈</mo> <mo>(</mo> <mn>0</mn> <mo>,</mo> <mi>∞</mi> <mo>)</mo></mrow></math>是所需的精度。在本文中，我们通过数值模拟测试了这种算法在物理学和金融中出现的各种100维非线性PDE的适用性，展示了逼近精度与运行时间的关系。这些100维示例PDE的模拟结果在精度和速度方面非常令人满意。此外，我们还从文献中提供了其他非线性PDE和BSDE的逼近方法的综述。*
- en: Setting the stage for deep learning for PDEs
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为PDE的深度学习做准备
- en: 'Before leaving this section, let’s set the stage for solving ODEs and PDEs
    in the context of deep learning, in particular, for *deep operator networks*.
    We’ll keep our one dimensional dynamical system example, but this time we highlight
    the dependence on the physical parameters *a(t)*, and make it slightly more general
    by adding another explicit dependence on time:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开这一部分之前，让我们为解决ODE和PDE在深度学习背景下的情况，特别是*深度算子网络*，做好准备。我们将保留我们的一维动力系统示例，但这次我们强调对物理参数*a(t)*的依赖，并通过在时间上增加另一个显式依赖，使其稍微更一般化：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column StartFraction
    d u left-parenthesis t right-parenthesis Over d t EndFraction equals ModifyingAbove
    f With right-arrow left-parenthesis u left-parenthesis t right-parenthesis comma
    a left-parenthesis t right-parenthesis comma t right-parenthesis 2nd Row 1st Column
    Blank 2nd Column ModifyingAbove u With right-arrow left-parenthesis t 0 right-parenthesis
    equals ModifyingAbove u With right-arrow Subscript 0 EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><mfrac><mrow><mi>d</mi><mi>u</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow>
    <mrow><mi>d</mi><mi>t</mi></mrow></mfrac> <mo>=</mo> <mover accent="true"><mi>f</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>u</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mi>t</mi>
    <mn>0</mn></msub> <mo>)</mo></mrow> <mo>=</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>0</mn></msub></mrow></mtd></mtr></mtable></math>
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column StartFraction
    d u left-parenthesis t right-parenthesis Over d t EndFraction equals ModifyingAbove
    f With right-arrow left-parenthesis u left-parenthesis t right-parenthesis comma
    a left-parenthesis t right-parenthesis comma t right-parenthesis 2nd Row 1st Column
    Blank 2nd Column ModifyingAbove u With right-arrow left-parenthesis t 0 right-parenthesis
    equals ModifyingAbove u With right-arrow Subscript 0 EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><mfrac><mrow><mi>d</mi><mi>u</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow>
    <mrow><mi>d</mi><mi>t</mi></mrow></mfrac> <mo>=</mo> <mover accent="true"><mi>f</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>u</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mi>t</mi>
    <mn>0</mn></msub> <mo>)</mo></mrow> <mo>=</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>0</mn></msub></mrow></mtd></mtr></mtable></math>
- en: 'As before we integrate once with respect to time:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这之前，我们对时间进行一次积分：
- en: <math alttext="dollar-sign u left-parenthesis t right-parenthesis equals u 0
    plus integral Subscript t 0 Superscript t Baseline f left-parenthesis u left-parenthesis
    s right-parenthesis comma a left-parenthesis s right-parenthesis comma s right-parenthesis
    d s dollar-sign"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mi>u</mi> <mn>0</mn></msub> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi>
    <mn>0</mn></msub></mrow> <mi>t</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo> <mi>u</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>s</mi></mrow></math>
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign u left-parenthesis t right-parenthesis equals u 0
    plus integral Subscript t 0 Superscript t Baseline f left-parenthesis u left-parenthesis
    s right-parenthesis comma a left-parenthesis s right-parenthesis comma s right-parenthesis
    d s dollar-sign"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mi>u</mi> <mn>0</mn></msub> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi>
    <mn>0</mn></msub></mrow> <mi>t</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo> <mi>u</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>s</mi></mrow></math>
- en: 'The purpose of a neural network is to take data as input, do something to it,
    then give us an output that we care for. For an ODE or a PDE, of course the output
    that we care for is the solution <math alttext="u left-parenthesis t right-parenthesis"><mrow><mi>u</mi>
    <mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></math> . Let’s write this solution as
    the output of some operator *G* that takes the given data of an ODE or PDE as
    input. In our dynamical system case, the input data is the function *a(t)* representing
    the physical parameters of the dynamical system. Note that we do not need to input
    the right hand side function *f* of the dynamical system. This is implicit in
    the training data, which now looks like the pairs *(training input,training output)*=
    <math alttext="left-parenthesis a left-parenthesis t right-parenthesis comma u
    left-parenthesis t right-parenthesis right-parenthesis"><mrow><mo>(</mo> <mi>a</mi>
    <mo>(</mo> <mi>t</mi> <mo>)</mo> <mo>,</mo> <mi>u</mi> <mo>(</mo> <mi>t</mi> <mo>)</mo>
    <mo>)</mo></mrow></math> . By not inputing *f*, in a way we are saying: I don’t
    care about the exact form of the ODE or PDE that this behavior comes from, but
    I am able to *learn* what the system is doing regardless. This is the epitome
    of machine learning: No need to encode the rules that the system obeys, the model
    can still emulate it if it observes enough instances of it.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络的目的是将数据作为输入，对其进行处理，然后给我们一个我们关心的输出。对于常微分方程或偏微分方程，当然我们关心的输出是解<u(t)>。让我们将这个解写成某个运算符*G*的输出，该运算符将常微分方程或偏微分方程的给定数据作为输入。在我们的动力系统案例中，输入数据是表示动力系统物理参数的函数*a(t)*。请注意，我们不需要输入动力系统右侧函数*f*。这在训练数据中是隐含的，现在看起来像是*(训练输入，训练输出)*=
    <math alttext="left-parenthesis a left-parenthesis t right-parenthesis comma u
    left-parenthesis t right-parenthesis right-parenthesis"><mrow><mo>(</mo> <mi>a</mi>
    <mo>(</mo> <mi>t</mi> <mo>)</mo> <mo>,</mo> <mi>u</mi> <mo>(</mo> <mi>t</mi> <mo>)</mo>
    <mo>)</mo></mrow></math>。通过不输入*f*，我们在某种程度上在说：我不关心这种行为来自哪个精确形式的常微分方程或偏微分方程，但我能够*学习*系统正在做什么。这就是机器学习的典范：无需编码系统遵守的规则，模型仍然可以模拟它，只要观察到足够多的实例。
- en: 'We can write the solution <math alttext="u left-parenthesis t right-parenthesis
    equals upper G left-parenthesis a left-parenthesis t right-parenthesis right-parenthesis"><mrow><mi>u</mi>
    <mo>(</mo> <mi>t</mi> <mo>)</mo> <mo>=</mo> <mi>G</mi> <mo>(</mo> <mi>a</mi> <mo>(</mo>
    <mi>t</mi> <mo>)</mo> <mo>)</mo></mrow></math> where the *solution operator G*
    is to be learned using a neural network. Hold this notation and thought till later
    in this chapter when we discuss neural operator networks. Plugging <math alttext="u
    left-parenthesis t right-parenthesis equals upper G left-parenthesis a left-parenthesis
    t right-parenthesis right-parenthesis"><mrow><mi>u</mi> <mo>(</mo> <mi>t</mi>
    <mo>)</mo> <mo>=</mo> <mi>G</mi> <mo>(</mo> <mi>a</mi> <mo>(</mo> <mi>t</mi> <mo>)</mo>
    <mo>)</mo></mrow></math> into the integral equation above we find that the solution
    operator, which we want to learn using a neural network satisfies:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将解<u(t)>等于上述积分方程中的解算符G写成<math alttext="u left-parenthesis t right-parenthesis
    equals upper G left-parenthesis a left-parenthesis t right-parenthesis right-parenthesis"><mrow><mi>u</mi>
    <mo>(</mo> <mi>t</mi> <mo>)</mo> <mo>=</mo> <mi>G</mi> <mo>(</mo> <mi>a</mi> <mo>(</mo>
    <mi>t</mi> <mo>)</mo> <mo>)</mo></mrow></math>，其中*解算符G*将使用神经网络进行学习。请记住这个符号和思想，直到本章后面讨论神经运算符网络时。将<math
    alttext="u left-parenthesis t right-parenthesis equals upper G left-parenthesis
    a left-parenthesis t right-parenthesis right-parenthesis"><mrow><mi>u</mi> <mo>(</mo>
    <mi>t</mi> <mo>)</mo> <mo>=</mo> <mi>G</mi> <mo>(</mo> <mi>a</mi> <mo>(</mo> <mi>t</mi>
    <mo>)</mo> <mo>)</mo></mrow></math>代入上述积分方程中，我们发现要学习的解算符，它满足使用神经网络的条件：
- en: <math alttext="dollar-sign upper G left-parenthesis a left-parenthesis t right-parenthesis
    right-parenthesis equals u 0 plus integral Subscript t 0 Superscript t Baseline
    f left-parenthesis upper G left-parenthesis a left-parenthesis s right-parenthesis
    right-parenthesis comma a left-parenthesis s right-parenthesis comma s right-parenthesis
    d s period dollar-sign"><mrow><mi>G</mi> <mrow><mo>(</mo> <mi>a</mi> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>u</mi> <mn>0</mn></msub>
    <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi> <mn>0</mn></msub></mrow>
    <mi>t</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo> <mi>G</mi> <mrow><mo>(</mo> <mi>a</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi> <mo>.</mo></mrow></math>
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper G left-parenthesis a left-parenthesis t right-parenthesis
    right-parenthesis equals u 0 plus integral Subscript t 0 Superscript t Baseline
    f left-parenthesis upper G left-parenthesis a left-parenthesis s right-parenthesis
    right-parenthesis comma a left-parenthesis s right-parenthesis comma s right-parenthesis
    d s period dollar-sign"><mrow><mi>G</mi> <mrow><mo>(</mo> <mi>a</mi> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>u</mi> <mn>0</mn></msub>
    <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi> <mn>0</mn></msub></mrow>
    <mi>t</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo> <mi>G</mi> <mrow><mo>(</mo> <mi>a</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi> <mo>.</mo></mrow></math>
- en: We just wrote an integral equation that we will not do anything with. It just
    shows the *true* property that the entity *G(a(t))* that we care for satisfies.
    In the discussion above we approximated this using a Picard’s iteration, and in
    the new era of deep learning we approximate it using a deep operator network (more
    on this soon). This deep learning approach is computationally more efficient,
    if we include the Fourier transform to speed up the computations. Moreover, the
    deep learning approach is more widely encompassing, in the sense that it applies
    to more PDEs and ODEs than just dynamical systems. A dynamical system is easy
    to integrate once and obtain a representation that gets us closer to the solution,
    which is not the case for many ODEs and PDEs.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚写了一个积分方程，我们不会对其进行任何操作。它只是展示了我们关心的实体*G(a(t))*满足的*真实*属性。在上面的讨论中，我们使用了Picard的迭代来近似这个方程，在深度学习的新时代中，我们使用深度运算网络来近似它（更多内容即将介绍）。这种深度学习方法在计算上更有效，如果我们包括傅立叶变换来加快计算速度。此外，深度学习方法更广泛，它适用于更多的偏微分方程和常微分方程，而不仅仅是动力系统。动力系统很容易积分一次并获得一个让我们更接近解决方案的表示，而对于许多常微分方程和偏微分方程来说并非如此。
- en: Mesh independence and different resolutions
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网格独立性和不同分辨率
- en: 'One final note: An input and output pair for a neural network learning the
    solution of our dynamical system looks like: *(training input,training output)*=
    <math alttext="left-parenthesis a left-parenthesis t right-parenthesis comma u
    left-parenthesis t right-parenthesis right-parenthesis"><mrow><mo>(</mo> <mi>a</mi>
    <mo>(</mo> <mi>t</mi> <mo>)</mo> <mo>,</mo> <mi>u</mi> <mo>(</mo> <mi>t</mi> <mo>)</mo>
    <mo>)</mo></mrow></math> . Since machines take numerical values only and not functions,
    we must discretize when we implement this. Here’s the pretty thing that differentiates
    *operators acting on functions* from *functions acting on points* and gives neural
    operator networks their *mesh independence* feature: *a(t)* and *u(t)* do not
    have to be discretized at the same values of *t*. All we care for is to map one
    function to another, so we can think of discretized *a(t)* as a vector mapped
    to another vector which is the discretized *u(t)*, not necessarily at the same
    points or not even of the same size. For the same reason, we can train the network
    at a given resolution then make predictions at *another* resolution. This is great
    for the field of ODEs and PDEs where the quality of numerical solutions have always
    been limited by the resolution of the employed discretization.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点：神经网络学习我们动力系统解决方案的输入和输出对看起来像：*(训练输入，训练输出)*= <math alttext="左括号 a 左括号 t 右括号
    逗号 u 左括号 t 右括号 右括号"><mrow><mo>(</mo> <mi>a</mi> <mo>(</mo> <mi>t</mi> <mo>)</mo>
    <mo>,</mo> <mi>u</mi> <mo>(</mo> <mi>t</mi> <mo>)</mo> <mo>)</mo></mrow></math>
    。由于机器只接受数值而不是函数，我们在实现时必须离散化。这里有一件很漂亮的事情，区分了*作用于函数的算子*和*作用于点的函数*，并赋予神经算子网络其*网格独立性*特征：*a(t)*和*u(t)*不必在相同的*t*值上离散化。我们只关心将一个函数映射到另一个函数，因此我们可以将离散化的*a(t)*看作映射到另一个向量的向量，该向量是离散化的*u(t)*，不一定在相同的点上，甚至不一定是相同大小的。出于同样的原因，我们可以在给定分辨率下训练网络，然后在*另一个*分辨率下进行预测。这对于常微分方程和偏微分方程领域非常有用，因为数值解的质量一直受到所使用的离散化分辨率的限制。
- en: AI For PDEs
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PDE的AI
- en: 'After surveying the main concerns and the basic approaches for solving PDEs,
    we are finally ready to discuss AI as it relates to PDEs, instead of only hinting
    at it or setting its stage here and there. We want to distinguish between few
    different ways in which deep learning has stepped into the PDE community:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在调查解决PDE的主要关注点和基本方法之后，我们终于准备讨论AI与PDE的关系，而不仅仅是在这里或那里暗示或设定其舞台。我们希望区分深度学习进入PDE社区的几种不同方式：
- en: Deep learning to learn the PDE’s physical parameter values
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度学习学习PDE的物理参数值
- en: Deep learning to learn two dimensional and three dimensional meshes for numerical
    simulations and solid modeling
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度学习学习二维和三维网格，用于数值模拟和实体建模
- en: 'Deep learning to learn a PDE’s solution operator: A neural network learns a
    map between two *infinite dimensional* spaces'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度学习学习PDE的解算子：神经网络学习两个*无限维*空间之间的映射
- en: Deep learning to bypass PDEs, and simulate natural phenomena directly from observing
    data (particle systems and their interactions)
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度学习绕过PDE，直接从观察数据中模拟自然现象（粒子系统及其相互作用）
- en: Deep Learning To Learn Physical Parameter Values
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深度学习学习物理参数值
- en: 'We can use neural networks to infer the parameters of a PDE model and their
    uncertainties. We would get training data from experiments (real or synthetic
    via simulations of well known phenomena with known parameters). This training
    data would be labeled with the parameter values, so the neural network would learn
    to map a certain PDE’s initial setting to appropriate parameter values, leading
    to more accurate modeling results. Historically, parameters that couldn’t be directly
    measured had to be guessed or hand tuned to fit some observed behavior, a practice
    that undermines the whole modeling process. This simple application of deep learning
    helps the PDE modeling community tremendously, because it brings more authenticity
    to their results. We can now learn parameter values from labeled images of experiments,
    or recorded audio, and other unstructured or very high dimensional data. Once
    trained, the neural networks can estimate parameters and uncertainties for any
    input data with similar settings. This poster has a nice and simple example that
    uses deep learning to predict the parameters of the velocity field for the G-equation
    (which models the combustion process) using flame front image data: [Bayesian
    Inference in Physics-Based Nonlinear Flame Models](https://openreview.net/attachment?id=WppGnva0Qm0&name=conference_poster).'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用神经网络推断PDE模型的参数及其不确定性。我们可以从实验中获取训练数据（真实的或通过模拟已知参数的众所周知现象）。这些训练数据将带有参数值标签，因此神经网络将学习将某个PDE的初始设置映射到适当的参数值，从而产生更准确的建模结果。在历史上，无法直接测量的参数必须被猜测或手动调整以适应某些观察到的行为，这种做法破坏了整个建模过程。深度学习的这种简单应用极大地帮助了PDE建模社区，因为它为他们的结果带来了更多的真实性。我们现在可以从实验的标记图像、录音以及其他非结构化或非常高维的数据中学习参数值。一旦训练完成，神经网络可以估计具有相似设置的任何输入数据的参数和不确定性。这篇海报有一个很好而简单的例子，使用深度学习来预测G方程（模拟燃烧过程）的速度场参数：[基于物理非线性火焰模型的贝叶斯推断](https://openreview.net/attachment?id=WppGnva0Qm0&name=conference_poster)。
- en: Deep Learning To Learn Meshes
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深度学习学习网格
- en: We learned in this chapter that generating a mesh is an integral part of the
    finite element method, which in turn finds numerical solutions for a wide array
    of PDEs modeling natural phenomena with complex domain geometries. The quality
    of the underlying mesh affects the quality of the numerical solution. The finer
    the mesh, the more of the true solution it is likely to capture, but the more
    computational cost it incurs. An ideal mesh would be dense where the error between
    the numerical solution and the true solution is more likely to be high, and coarse
    where the error is low, hence preserving fedelity while keeping the overall computational
    cost manageable ([Figure 13-12](#Fig_meshing)).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中学到，生成网格是有限元方法的一个组成部分，有限元方法又为模拟具有复杂域几何形状的自然现象的各种PDE提供了数值解。底层网格的质量会影响数值解的质量。网格越精细，就越有可能捕捉到真实解，但也会增加计算成本。一个理想的网格应该在数值解与真实解之间的误差可能较大的地方密集，而在误差较小的地方粗糙，从而在保持精度的同时保持整体计算成本可控（[图13-12](#Fig_meshing)）。
- en: '![250](assets/emai_1312.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![250](assets/emai_1312.png)'
- en: Figure 13-12\. Nonuniform mesh on the left vs uniform mesh on the right. A mesh
    needs to be finer where the error is large ([image source](https://arxiv.org/pdf/2004.07016.pdf)).
  id: totrans-370
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-12\. 左侧为非均匀网格，右侧为均匀网格。网格需要在误差较大的地方更细致（[图片来源](https://arxiv.org/pdf/2004.07016.pdf)）。
- en: It would be nice if given a PDE, its domain geometry, boundary conditions, and
    parameter values as inputs, we could train a neural network to automatically generate
    an ideal mesh, predicting the density distribution of the mesh elements at each
    location of the domain. This is exactly what [MeshingNet(2020)](https://arxiv.org/pdf/2004.07016.pdf)
    does.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定一个偏微分方程（PDE）、其定义域几何形状、边界条件和参数值作为输入，我们可以训练一个神经网络自动生成一个理想的网格，预测在定义域的每个位置的网格元素的密度分布，这将是非常好的。这正是[MeshingNet(2020)](https://arxiv.org/pdf/2004.07016.pdf)所做的。
- en: Before MeshingNet, mesh learning was done via expensive multistep finite element
    solutions and error estimators. In contrast, MeshingNet relies on similar problems
    to predict ideal meshes for new problems. It starts with an initial uniform and
    coarse mesh and predicts a nonuniform mesh density for refinement. A hallmark
    of deep learning, MeshingNet generalizes well to different geometric domains with
    various governing PDEs, boundary conditions, and parameters.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在MeshingNet之前，网格学习是通过昂贵的多步有限元解和误差估计器来完成的。相比之下，MeshingNet依赖于类似的问题来预测新问题的理想网格。它从一个初始均匀和粗糙的网格开始，并预测用于细化的非均匀网格密度。作为深度学习的标志，MeshingNet在不同几何域中的各种控制PDE、边界条件和参数下都有很好的泛化能力。
- en: The inputs to MeshingNet are the governing PDE, PDE parameters, domain geometry,
    and the boundary conditions, and the output is an area upper bound distribution
    A(X) over the whole domain. The mapping between input and output is highly nonlinear
    and is thus learned by a neural network, which have demonstrated an impressive
    ability to express many kinds of nonlinear relationships.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: MeshingNet的输入是控制PDE、PDE参数、定义域几何形状和边界条件，输出是整个定义域上的区域上限分布A(X)。输入和输出之间的映射是高度非线性的，因此通过神经网络学习，神经网络已经展示出表达许多种非线性关系的出色能力。
- en: To build the training data set, the MeshingNet team computes high-accuracy solutions
    on high density uniform meshes using standard finite element solvers. They also
    do the same computation for low density uniform meshes to obtain lower accuracy
    solutions. Then they compute an error distribution E(X) by interpolating between
    these solutions. They use E(X) as a guide to refine A(X). They enrich the training
    data by combining different geometries with different parameters and boundary
    conditions.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建训练数据集，MeshingNet团队使用标准有限元求解器在高密度均匀网格上计算高精度解。他们还对低密度均匀网格进行相同的计算以获得较低精度的解。然后他们通过在这些解之间进行插值来计算一个误差分布E(X)。他们使用E(X)作为指导来细化A(X)。他们通过结合不同几何形状、不同参数和边界条件来丰富训练数据。
- en: Deep learning for three dimensional meshes
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于三维网格的深度学习
- en: Three dimensional meshes ([Figure 13-13](#Fig_dolphin_mesh)) are useful for
    computer graphics, animations for the entertainment industry, and solid modeling.
    It is also highly desirable to reconstruct textured and realistic surfaces from
    a given set of three dimensional data points. Traditional methods include Delaunay
    triangulations and Voronoi diagrams, which interpolate points using triangular
    meshes. However, when there is noise in the coordinates, the resulting surface
    would be unnecessarily rough, which requires data pre-processing.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 三维网格（[图13-13](#Fig_dolphin_mesh)）对计算机图形、娱乐行业的动画和实体建模非常有用。从给定的三维数据点集合中重建纹理和逼真的表面也是非常有价值的。传统方法包括Delaunay三角剖分和Voronoi图，它们使用三角形网格对点进行插值。然而，当坐标中存在噪声时，得到的表面会过于粗糙，需要数据预处理。
- en: '![250](assets/emai_1313.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![250](assets/emai_1313.png)'
- en: Figure 13-13\. Three dimensional mesh [(image source)](https://commons.wikimedia.org/wiki/File:Dolphin_triangle_mesh.png).
  id: totrans-378
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-13\. 三维网格 [(图片来源)](https://commons.wikimedia.org/wiki/File:Dolphin_triangle_mesh.png)。
- en: Deep learning is stepping in to generate higher quality three dimensional meshes,
    see for example, [Deep Hybrid Self-Prior for Full 3D Mesh Generation(2021)](https://arxiv.org/pdf/2108.08017.pdf)
    and [Pixel To Mesh (2018)](https://openaccess.thecvf.com/content_ECCV_2018/papers/Nanyang_Wang_Pixel2Mesh_Generating_3D_ECCV_2018_paper.pdf),
    which produces a three dimensional shape in triangular mesh from a single color
    image, by continuously deforming an ellipsoid.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习正在生成更高质量的三维网格，例如，[Deep Hybrid Self-Prior for Full 3D Mesh Generation(2021)](https://arxiv.org/pdf/2108.08017.pdf)和[Pixel
    To Mesh (2018)](https://openaccess.thecvf.com/content_ECCV_2018/papers/Nanyang_Wang_Pixel2Mesh_Generating_3D_ECCV_2018_paper.pdf)，它们通过不断变形椭球从单色图像中生成三维三角形网格中的三维形状。
- en: Deep Learning to Approximate Solution Operators of PDEs
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用深度学习来逼近PDE的解算子
- en: 'We have already started this discussion multiple times in this chapter. Instead
    of using deep learning to enhance existing methods for PDEs, such as learning
    physical parameter values from data, or learning better meshes for numerical methods,
    we would like to learn a PDE’s solution operator. This maps the PDE’s input, such
    as its domain, physical parameters, intial/final states of the solution, and/or
    boundary conditions, directly to its solution. We can think of this as:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中已经多次开始讨论这个问题。我们不想使用深度学习来增强PDE的现有方法，比如从数据中学习物理参数值，或者学习数值方法的更好网格，我们想要学习PDE的解算子。这将PDE的输入，如其域、物理参数、解的初始/最终状态和/或边界条件，直接映射到其解。我们可以将其视为：
- en: '*solution of PDE=function(PDE’s physical parameters, domain, boundary conditions,
    initial conditions, _etc.)*'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '*PDE的解=函数（PDE的物理参数、域、边界条件、初始条件等）*'
- en: 'We want to build a neural network to approximate this function. This is in
    fact an operator and not a function in the usual sense, since it sends functions
    to other functions. The caveat here is that differential operators and their inverses
    map *infinite dimensional spaces* to *infinite dimensional spaces*, sometimes
    in a linear way, such as the map from the *right hand side* of Poisson equation
    to the solution, and most of the time in a nonlinear way, such as the map from
    *the parameters* of Poisson equation to the solution. In contrast, the inputs
    and outputs of the neural networks that we learned about throughout this book
    are finite dimensional (inputs and outputs are vectors, images, graphs, *etc.*).
    These neural networks are able to approximate *function mappings* between *finite
    dimensional spaces*. They have a powerful universal approximation theorem going
    on for them, and a myriad of successes in practical applications (we can approximate
    any continuous function to arbitrary accuracy using neural networks if we place
    no constraints on the width and depth of the hidden layers). In order to solve
    PDEs analogously using deep learning, we must answer two questions:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要构建一个神经网络来逼近这个函数。实际上，这是一个操作符，而不是通常意义上的函数，因为它将函数映射到其他函数。这里的警告是，微分算子及其逆映射*无限维空间*到*无限维空间*，有时是线性的，比如从泊松方程的*右侧*到解的映射，大多数情况下是非线性的，比如从泊松方程的*参数*到解的映射。相比之下，我们在整本书中学到的神经网络的输入和输出是有限维的（输入和输出是向量、图像、图形等）。这些神经网络能够逼近*有限维空间*之间的*函数映射*。它们有一个强大的通用逼近定理，并在实际应用中取得了许多成功（如果对隐藏层的宽度和深度没有约束，我们可以使用神经网络以任意精度逼近任何连续函数）。为了类比地使用深度学习来解决PDE，我们必须回答两个问题：
- en: Can neural networks approximate mappings between infinite dimensional spaces?
    That is, can they approximate any nonlinear continuous functional (the input to
    the network would be a function or a bunch of functions and the output would be
    a real number) or nonlinear operator (the input to the network would be a function
    or a bunch of functions and the output would be another function)? The answer
    is a *yes*! There is a *universal approximation theorem* for *neural network operators*
    just like there are universal approximation theorems for *neural network functions*.
    A neural network with a single hidden layer can approximate accurately any nonlinear
    continuous functional or operator. Moreover, neural networks are able to learn
    the solution operator of an entire family of PDEs, as opposed to classical methods
    for solving PDEs which only solve a single instance of a given PDE at a time.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 神经网络能够逼近无限维空间之间的映射吗？也就是说，它们能够逼近任何非线性连续泛函（网络的输入将是一个函数或一组函数，输出将是一个实数）或非线性算子（网络的输入将是一个函数或一组函数，输出将是另一个函数）吗？答案是*是*！就像有关*神经网络函数*的通用逼近定理一样，*神经网络算子*也有通用逼近定理。具有单个隐藏层的神经网络可以准确逼近任何非线性连续泛函或算子。此外，神经网络能够学习整个PDE族的解算子，而不是传统的解PDE方法，后者一次只能解决给定PDE的一个实例。
- en: 'How do we implement this in practice? For the finite dimensional case, a node
    in a neural network linearly combines the finite dimensional features of the input
    vector (or the outputs of the previous layer), adds a bias term, applies a nonlinear
    activation function, then passes the result to the next layer. The analogue for
    the infinite dimensional case, where we do not have finitely many entries to linearly
    combine anymore, would be to integrate some learnable kernel (multiplier function)
    of the input functions (for numerical integration, we have to sample this at finitely
    many points, converting integration to addition), add a bias function (this is
    optional), apply a nonlinear activation function, before passing the result to
    the next layer. The next layer would then add multiples of the node results of
    the previous layer, and integrate them against a learnable kernel of the results
    of the nodes of the previous layer, and so on. One example of doing this would
    look like:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实践中如何实现这一点？对于有限维情况，神经网络中的一个节点线性组合输入向量的有限维特征（或上一层的输出），添加偏置项，应用非线性激活函数，然后将结果传递给下一层。在无限维情况下，我们不再有有限数量的条目进行线性组合，类似的做法是对输入函数的一些可学习核（乘法器函数）进行积分（对于数值积分，我们必须在有限多个点上采样，将积分转换为加法），添加偏置函数（可选），应用非线性激活函数，然后将结果传递给下一层。下一层将对上一层节点结果的倍数进行相加，并将它们与上一层节点结果的可学习核进行积分，依此类推。一个这样做的例子看起来像：
- en: <math alttext="dollar-sign u Subscript n plus 1 Baseline left-parenthesis x
    right-parenthesis equals sigma left-parenthesis integral Underscript upper D Endscripts
    k e r n e l left-parenthesis x comma s comma a left-parenthesis x right-parenthesis
    comma a left-parenthesis s right-parenthesis semicolon omega right-parenthesis
    u Subscript n Baseline left-parenthesis s right-parenthesis d s plus upper W u
    Subscript n Baseline left-parenthesis x right-parenthesis right-parenthesis comma
    dollar-sign"><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>σ</mi> <mrow><mo>(</mo>
    <msub><mo>∫</mo> <mi>D</mi></msub> <mi>k</mi> <mi>e</mi> <mi>r</mi> <mi>n</mi>
    <mi>e</mi> <mi>l</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>s</mi> <mo>,</mo>
    <mi>a</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>;</mo> <mi>ω</mi> <mo>)</mo></mrow>
    <msub><mi>u</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi> <mo>+</mo> <mi>W</mi> <msub><mi>u</mi> <mi>n</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>,</mo></mrow></math>
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign u Subscript n plus 1 Baseline left-parenthesis x
    right-parenthesis equals sigma left-parenthesis integral Underscript upper D Endscripts
    k e r n e l left-parenthesis x comma s comma a left-parenthesis x right-parenthesis
    comma a left-parenthesis s right-parenthesis semicolon omega right-parenthesis
    u Subscript n Baseline left-parenthesis s right-parenthesis d s plus upper W u
    Subscript n Baseline left-parenthesis x right-parenthesis right-parenthesis comma
    dollar-sign"><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>σ</mi> <mrow><mo>(</mo>
    <msub><mo>∫</mo> <mi>D</mi></msub> <mi>k</mi> <mi>e</mi> <mi>r</mi> <mi>n</mi>
    <mi>e</mi> <mi>l</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>s</mi> <mo>,</mo>
    <mi>a</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>;</mo> <mi>ω</mi> <mo>)</mo></mrow>
    <msub><mi>u</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi> <mo>+</mo> <mi>W</mi> <msub><mi>u</mi> <mi>n</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>,</mo></mrow></math>
- en: where we arrive at the solution *u(x)* iteratively after a certain number of
    global integrations against a kernel, local linear transformations, and compositions
    with a nonlinear activation function. The parameters of the kernel in the iterative
    process are <math alttext="omega"><mi>ω</mi></math> and the entries of *W*. The
    neural network learns these parameters from the labeled data (labeled with the
    solutions of the PDE) during training via minimizing a loss function. Analogous
    to the finite dimensional case, neural operator networks approximate nonlinear
    operators by composing linear integral operators that act globally over the entire
    domain with nonlinear activation functions. The above interative formula also
    includes a local linear multiplier, which becomes a matrix when we discretize
    (check this).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过一定数量的全局积分、与核函数的局部线性变换以及与非线性激活函数的组合迭代地到达解*u(x)*。迭代过程中的核函数参数是<math alttext="omega"><mi>ω</mi></math>和*W*的条目。神经网络通过训练从带有PDE解的标记数据中学习这些参数，通过最小化损失函数。类似于有限维情况，神经算子网络通过将在整个域上全局作用的线性积分算子与非线性激活函数组合来逼近非线性算子。上述迭代公式还包括一个局部线性乘数，在我们离散化时变为矩阵（检查这一点）。
- en: Neural operator networks to learn the solution operators that we derived
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 神经算子网络学习我们推导出的解算子
- en: 'Let’s pause for a moment and compare the above expression to the three true
    solution operators which we derived for: The heat equation, Poisson equation,
    and dynamical systems. We can easily adapt the neural operator iterative process
    to each of the above three settings:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂停一下，将上述表达式与我们为以下三种情况推导出的真实解算子进行比较：热方程、泊松方程和动力系统。我们可以很容易地将神经算子迭代过程适应到上述三种情况中的每一种：
- en: 'For the heat equation in one space dimension and constant coefficients, the
    solution operator maps the initial state and the PDE’s physical parameter (constant)
    to the solution *u(x,t)*, and we are lucky enough to have explicit formulas for
    all the quantities involved:'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一维空间中具有恒定系数的热方程，解算子将初始状态和PDE的物理参数（恒定）映射到解*u(x,t)*，我们很幸运地对所有涉及的量都有明确的公式：
- en: <math alttext="dollar-sign upper G left-parenthesis u 0 left-parenthesis x right-parenthesis
    comma a right-parenthesis equals u left-parenthesis x comma t right-parenthesis
    equals integral Subscript negative normal infinity Superscript normal infinity
    Baseline StartFraction 1 Over StartRoot 4 pi a t EndRoot EndFraction e Superscript
    minus StartFraction left-parenthesis s minus x right-parenthesis squared Over
    4 a t EndFraction Baseline u 0 left-parenthesis s right-parenthesis d s equals
    integral Subscript negative normal infinity Superscript normal infinity Baseline
    k e r n e l left-parenthesis s comma x semicolon t semicolon a right-parenthesis
    u 0 left-parenthesis s right-parenthesis d s dollar-sign"><mrow><mi>G</mi> <mrow><mo>(</mo>
    <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>,</mo> <mi>a</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>u</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <msubsup><mo>∫</mo>
    <mrow><mo>-</mo><mi>∞</mi></mrow> <mi>∞</mi></msubsup> <mfrac><mn>1</mn> <msqrt><mrow><mn>4</mn><mi>π</mi><mi>a</mi><mi>t</mi></mrow></msqrt></mfrac>
    <msup><mi>e</mi> <mrow><mo>-</mo><mfrac><msup><mrow><mo>(</mo><mi>s</mi><mo>-</mo><mi>x</mi><mo>)</mo></mrow>
    <mn>2</mn></msup> <mrow><mn>4</mn><mi>a</mi><mi>t</mi></mrow></mfrac></mrow></msup>
    <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi> <mo>=</mo> <msubsup><mo>∫</mo> <mrow><mo>-</mo><mi>∞</mi></mrow>
    <mi>∞</mi></msubsup> <mi>k</mi> <mi>e</mi> <mi>r</mi> <mi>n</mi> <mi>e</mi> <mi>l</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>x</mi> <mo>;</mo> <mi>t</mi> <mo>;</mo>
    <mi>a</mi> <mo>)</mo></mrow> <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi></mrow></math>
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper G left-parenthesis u 0 left-parenthesis x right-parenthesis
    comma a right-parenthesis equals u left-parenthesis x comma t right-parenthesis
    equals integral Subscript negative normal infinity Superscript normal infinity
    Baseline StartFraction 1 Over StartRoot 4 pi a t EndRoot EndFraction e Superscript
    minus StartFraction left-parenthesis s minus x right-parenthesis squared Over
    4 a t EndFraction Baseline u 0 left-parenthesis s right-parenthesis d s equals
    integral Subscript negative normal infinity Superscript normal infinity Baseline
    k e r n e l left-parenthesis s comma x semicolon t semicolon a right-parenthesis
    u 0 left-parenthesis s right-parenthesis d s dollar-sign"><mrow><mi>G</mi> <mrow><mo>(</mo>
    <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>,</mo> <mi>a</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>u</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <msubsup><mo>∫</mo>
    <mrow><mo>-</mo><mi>∞</mi></mrow> <mi>∞</mi></msubsup> <mfrac><mn>1</mn> <msqrt><mrow><mn>4</mn><mi>π</mi><mi>a</mi><mi>t</mi></mrow></msqrt></mfrac>
    <msup><mi>e</mi> <mrow><mo>-</mo><mfrac><msup><mrow><mo>(</mo><mi>s</mi><mo>-</mo><mi>x</mi><mo>)</mo></mrow>
    <mn>2</mn></msup> <mrow><mn>4</mn><mi>a</mi><mi>t</mi></mrow></mfrac></mrow></msup>
    <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi> <mo>=</mo> <msubsup><mo>∫</mo> <mrow><mo>-</mo><mi>∞</mi></mrow>
    <mi>∞</mi></msubsup> <mi>k</mi> <mi>e</mi> <mi>r</mi> <mi>n</mi> <mi>e</mi> <mi>l</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>x</mi> <mo>;</mo> <mi>t</mi> <mo>;</mo>
    <mi>a</mi> <mo>)</mo></mrow> <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi></mrow></math>
- en: 'In this case, the neural operator network does the following iteration to approximate
    the true operator:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，神经算子网络通过以下迭代来逼近真实算子：
- en: <math alttext="dollar-sign upper G left-parenthesis u 0 left-parenthesis x right-parenthesis
    comma a right-parenthesis equals u left-parenthesis x comma t right-parenthesis
    almost-equals u Subscript n plus 1 Baseline left-parenthesis x comma t right-parenthesis
    equals sigma left-parenthesis integral Underscript upper D Endscripts k e r n
    e l left-parenthesis s comma x semicolon t semicolon a semicolon omega right-parenthesis
    u Subscript n Baseline left-parenthesis s right-parenthesis d s plus upper W u
    Subscript n Baseline left-parenthesis x right-parenthesis right-parenthesis dollar-sign"><mrow><mi>G</mi>
    <mrow><mo>(</mo> <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>u</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>≈</mo>
    <msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>σ</mi> <mrow><mo>(</mo>
    <msub><mo>∫</mo> <mi>D</mi></msub> <mi>k</mi> <mi>e</mi> <mi>r</mi> <mi>n</mi>
    <mi>e</mi> <mi>l</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>x</mi> <mo>;</mo>
    <mi>t</mi> <mo>;</mo> <mi>a</mi> <mo>;</mo> <mi>ω</mi> <mo>)</mo></mrow> <msub><mi>u</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi>
    <mo>+</mo> <mi>W</mi> <msub><mi>u</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper G left-parenthesis u 0 left-parenthesis x right-parenthesis
    comma a right-parenthesis equals u left-parenthesis x comma t right-parenthesis
    almost-equals u Subscript n plus 1 Baseline left-parenthesis x comma t right-parenthesis
    equals sigma left-parenthesis integral Underscript upper D Endscripts k e r n
    e l left-parenthesis s comma x semicolon t semicolon a semicolon omega right-parenthesis
    u Subscript n Baseline left-parenthesis s right-parenthesis d s plus upper W u
    Subscript n Baseline left-parenthesis x right-parenthesis right-parenthesis dollar-sign"><mrow><mi>G</mi>
    <mrow><mo>(</mo> <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>u</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>≈</mo>
    <msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>σ</mi> <mrow><mo>(</mo>
    <msub><mo>∫</mo> <mi>D</mi></msub> <mi>k</mi> <mi>e</mi> <mi>r</mi> <mi>n</mi>
    <mi>e</mi> <mi>l</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>x</mi> <mo>;</mo>
    <mi>t</mi> <mo>;</mo> <mi>a</mi> <mo>;</mo> <mi>ω</mi> <mo>)</mo></mrow> <msub><mi>u</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi>
    <mo>+</mo> <mi>W</mi> <msub><mi>u</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
- en: 'For Poisson equation in two space dimensions, zero boundary conditions, and
    constant coefficients, the solution operator maps the PDE’s right hand side *f*,
    and its physical parameters (constant) to the solution *u(x,y)*, and only for
    certain simple geometries, we are lucky to have explicit formulas for all the
    quantities involved (none of which we write here):'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于二维空间中具有零边界条件和恒定系数的泊松方程，解算子将PDE的右侧*f*和其物理参数（恒定）映射到解*u(x,y)*，只有对于某些简单的几何形状，我们才有所有涉及的数量的明确公式（我们这里没有写出）：
- en: <math alttext="dollar-sign upper G left-parenthesis f left-parenthesis x comma
    y right-parenthesis comma a right-parenthesis equals u left-parenthesis x comma
    y right-parenthesis equals integral Underscript upper D Endscripts upper G r e
    e n upper F u n c t i o n left-parenthesis x comma y semicolon s comma p semicolon
    a right-parenthesis f left-parenthesis s comma p right-parenthesis d s d p dollar-sign"><mrow><mi>G</mi>
    <mrow><mo>(</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>u</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mo>∫</mo> <mi>D</mi></msub> <mi>G</mi> <mi>r</mi> <mi>e</mi> <mi>e</mi>
    <mi>n</mi> <mi>F</mi> <mi>u</mi> <mi>n</mi> <mi>c</mi> <mi>t</mi> <mi>i</mi> <mi>o</mi>
    <mi>n</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>;</mo> <mi>s</mi>
    <mo>,</mo> <mi>p</mi> <mo>;</mo> <mi>a</mi> <mo>)</mo></mrow> <mi>f</mi> <mrow><mo>(</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mi>d</mi>
    <mi>p</mi></mrow></math>
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper G left-parenthesis f left-parenthesis x comma
    y right-parenthesis comma a right-parenthesis equals u left-parenthesis x comma
    y right-parenthesis equals integral Underscript upper D Endscripts upper G r e
    e n upper F u n c t i o n left-parenthesis x comma y semicolon s comma p semicolon
    a right-parenthesis f left-parenthesis s comma p right-parenthesis d s d p dollar-sign"><mrow><mi>G</mi>
    <mrow><mo>(</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>u</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mo>∫</mo> <mi>D</mi></msub> <mi>G</mi> <mi>r</mi> <mi>e</mi> <mi>e</mi>
    <mi>n</mi> <mi>F</mi> <mi>u</mi> <mi>n</mi> <mi>c</mi> <mi>t</mi> <mi>i</mi> <mi>o</mi>
    <mi>n</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>;</mo> <mi>s</mi>
    <mo>,</mo> <mi>p</mi> <mo>;</mo> <mi>a</mi> <mo>)</mo></mrow> <mi>f</mi> <mrow><mo>(</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mi>d</mi>
    <mi>p</mi></mrow></math>
- en: 'In this case, the neural operator network does the following iteration to approximate
    the true operator:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，神经算子网络通过以下迭代来逼近真实算子：
- en: <math alttext="dollar-sign upper G left-parenthesis f left-parenthesis x comma
    y right-parenthesis comma a right-parenthesis equals u left-parenthesis x comma
    y right-parenthesis almost-equals u Subscript n plus 1 Baseline left-parenthesis
    x comma y right-parenthesis equals sigma left-parenthesis integral Underscript
    upper D Endscripts k e r n e l left-parenthesis x comma y comma s comma p comma
    a semicolon omega right-parenthesis u Subscript n Baseline left-parenthesis s
    comma p right-parenthesis d s d p plus upper W u Subscript n Baseline left-parenthesis
    x comma y right-parenthesis right-parenthesis dollar-sign"><mrow><mi>G</mi> <mrow><mo>(</mo>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>,</mo> <mi>a</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>u</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>≈</mo> <msub><mi>u</mi>
    <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>σ</mi> <mrow><mo>(</mo>
    <msub><mo>∫</mo> <mi>D</mi></msub> <mi>k</mi> <mi>e</mi> <mi>r</mi> <mi>n</mi>
    <mi>e</mi> <mi>l</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>,</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>,</mo> <mi>a</mi> <mo>;</mo> <mi>ω</mi> <mo>)</mo></mrow>
    <msub><mi>u</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi>
    <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mi>d</mi> <mi>p</mi> <mo>+</mo> <mi>W</mi>
    <msub><mi>u</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper G left-parenthesis f left-parenthesis x comma
    y right-parenthesis comma a right-parenthesis equals u left-parenthesis x comma
    y right-parenthesis almost-equals u Subscript n plus 1 Baseline left-parenthesis
    x comma y right-parenthesis equals sigma left-parenthesis integral Underscript
    upper D Endscripts k e r n e l left-parenthesis x comma y comma s comma p comma
    a semicolon omega right-parenthesis u Subscript n Baseline left-parenthesis s
    comma p right-parenthesis d s d p plus upper W u Subscript n Baseline left-parenthesis
    x comma y right-parenthesis right-parenthesis dollar-sign"><mrow><mi>G</mi> <mrow><mo>(</mo>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>,</mo> <mi>a</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>u</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>≈</mo> <msub><mi>u</mi>
    <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>σ</mi> <mrow><mo>(</mo>
    <msub><mo>∫</mo> <mi>D</mi></msub> <mi>k</mi> <mi>e</mi> <mi>r</mi> <mi>n</mi>
    <mi>e</mi> <mi>l</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>,</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>,</mo> <mi>a</mi> <mo>;</mo> <mi>ω</mi> <mo>)</mo></mrow>
    <msub><mi>u</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi>
    <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mi>d</mi> <mi>p</mi> <mo>+</mo> <mi>W</mi>
    <msub><mi>u</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
- en: 'For a one dimensional dynamical system, the solution operator maps the ODE’s
    physical parameter (function) to the solution *u(t)*, and we have an implicit
    integral equation that it satisfies:'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一维动力系统，解算子将ODE的物理参数（函数）映射到解*u(t)*，我们有一个隐式积分方程来满足它：
- en: <math alttext="dollar-sign upper G left-parenthesis a left-parenthesis t right-parenthesis
    right-parenthesis equals u left-parenthesis t right-parenthesis equals u 0 plus
    integral Subscript t 0 Superscript t Baseline f left-parenthesis upper G left-parenthesis
    a left-parenthesis s right-parenthesis right-parenthesis comma a left-parenthesis
    s right-parenthesis comma s right-parenthesis d s period dollar-sign"><mrow><mi>G</mi>
    <mrow><mo>(</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>=</mo> <mi>u</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mi>u</mi> <mn>0</mn></msub> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi>
    <mn>0</mn></msub></mrow> <mi>t</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo> <mi>G</mi>
    <mrow><mo>(</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mo>.</mo></mrow></math>
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper G left-parenthesis a left-parenthesis t right-parenthesis
    right-parenthesis equals u left-parenthesis t right-parenthesis equals u 0 plus
    integral Subscript t 0 Superscript t Baseline f left-parenthesis upper G left-parenthesis
    a left-parenthesis s right-parenthesis right-parenthesis comma a left-parenthesis
    s right-parenthesis comma s right-parenthesis d s period dollar-sign"><mrow><mi>G</mi>
    <mrow><mo>(</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>=</mo> <mi>u</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mi>u</mi> <mn>0</mn></msub> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi>
    <mn>0</mn></msub></mrow> <mi>t</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo> <mi>G</mi>
    <mrow><mo>(</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mo>.</mo></mrow></math>
- en: 'In this case, the neural operator network does the following iteration to approximate
    the true operator:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，神经算子网络通过以下迭代来逼近真实算子：
- en: <math alttext="dollar-sign upper G left-parenthesis a left-parenthesis t right-parenthesis
    right-parenthesis equals u left-parenthesis t right-parenthesis almost-equals
    u Subscript n plus 1 Baseline left-parenthesis t right-parenthesis equals sigma
    left-parenthesis integral Subscript t 0 Superscript t Baseline k e r n e l left-parenthesis
    t comma s comma a left-parenthesis t right-parenthesis comma a left-parenthesis
    s right-parenthesis semicolon omega right-parenthesis u Subscript n Baseline left-parenthesis
    s right-parenthesis d s plus upper W u Subscript n Baseline left-parenthesis t
    right-parenthesis right-parenthesis dollar-sign"><mrow><mi>G</mi> <mrow><mo>(</mo>
    <mi>a</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo>
    <mi>u</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>≈</mo> <msub><mi>u</mi>
    <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub> <mrow><mo>(</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mi>σ</mi> <mrow><mo>(</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi>
    <mn>0</mn></msub></mrow> <mi>t</mi></msubsup> <mi>k</mi> <mi>e</mi> <mi>r</mi>
    <mi>n</mi> <mi>e</mi> <mi>l</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>,</mo> <mi>s</mi>
    <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo>
    <mi>a</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>;</mo> <mi>ω</mi>
    <mo>)</mo></mrow> <msub><mi>u</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>s</mi>
    <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mo>+</mo> <mi>W</mi> <msub><mi>u</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper G left-parenthesis a left-parenthesis t right-parenthesis
    right-parenthesis equals u left-parenthesis t right-parenthesis almost-equals
    u Subscript n plus 1 Baseline left-parenthesis t right-parenthesis equals sigma
    left-parenthesis integral Subscript t 0 Superscript t Baseline k e r n e l left-parenthesis
    t comma s comma a left-parenthesis t right-parenthesis comma a left-parenthesis
    s right-parenthesis semicolon omega right-parenthesis u Subscript n Baseline left-parenthesis
    s right-parenthesis d s plus upper W u Subscript n Baseline left-parenthesis t
    right-parenthesis right-parenthesis dollar-sign"><mrow><mi>G</mi> <mrow><mo>(</mo>
    <mi>a</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo>
    <mi>u</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>≈</mo> <msub><mi>u</mi>
    <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub> <mrow><mo>(</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mi>σ</mi> <mrow><mo>(</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi>
    <mn>0</mn></msub></mrow> <mi>t</mi></msubsup> <mi>k</mi> <mi>e</mi> <mi>r</mi>
    <mi>n</mi> <mi>e</mi> <mi>l</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>,</mo> <mi>s</mi>
    <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo>
    <mi>a</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>;</mo> <mi>ω</mi>
    <mo>)</mo></mrow> <msub><mi>u</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>s</mi>
    <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mo>+</mo> <mi>W</mi> <msub><mi>u</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
- en: '*Here, one data point is a triplet (t, a(t), G(a(t))), and thus one specific
    input a may appear in multiple data points with different values of t. For example,
    a dataset of size 10,000 may only be generated from 100 a(t) trajectories, and
    each evaluates G(a)(t) for 100 t locations. (explain this)*'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这里，一个数据点是一个三元组(t, a(t), G(a(t)))，因此一个特定的输入a可能会出现在多个具有不同t值的数据点中。例如，一个大小为10,000的数据集可能只从100个a(t)轨迹中生成，并且每个轨迹对100个t位置进行评估。(解释这个)*'
- en: 'One thing to observe with the three different settings above is that neural
    operator networks require only input and output data, and no knowledge of the
    underlying PDEs. The knowledge about the PDEs is implicit in the training data.
    With this in mind, let’s reinforce the *input output* form of a neural operator
    network:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 观察上述三种不同情境时要注意的一点是，神经算子网络只需要输入和输出数据，而不需要了解底层的PDE。关于PDE的知识隐含在训练数据中。有了这个想法，让我们强调神经算子网络的*输入输出*形式：
- en: '*Solution of PDE <math alttext="almost-equals"><mo>≈</mo></math> learned_operator(PDE’s
    physical parameters, domain, boundary conditions, initial conditions, _etc.)*.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '*PDE的解 <math alttext="almost-equals"><mo>≈</mo></math> learned_operator(PDE的物理参数，域，边界条件，初始条件，_等)*。'
- en: The important questions
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重要的问题
- en: 'When we branch out beyond this book to expand our knowledge on neural operator
    networks, we must keep the following questions as our guide:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们超越这本书去扩展我们对神经算子网络的了解时，我们必须将以下问题作为我们的指南：
- en: For a given PDE, what is the input to the network, and what is the output?
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的PDE，网络的输入和输出是什么？
- en: We addressed these in the simple contexts of the heat equation, Poisson equation,
    and dynamical systems.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在热方程、泊松方程和动力系统的简单情境中解决了这些问题。
- en: What is an example of an architecture of a neural operator?
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 神经算子的架构示例是什么？
- en: '[Figure 13-14](#Fig_DeepONet) shows the input and output structure of [DeepONet](https://arxiv.org/pdf/1910.03193.pdf).
    The input is a discretized pair (t,a(t)) and the output is a discrete G(a(t)).'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-14](#Fig_DeepONet)显示了[DeepONet](https://arxiv.org/pdf/1910.03193.pdf)的输入和输出结构。输入是一个离散化的对(t,a(t))，输出是一个离散的G(a(t))。'
- en: '![300](assets/emai_1314.png)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![300](assets/emai_1314.png)'
- en: Figure 13-14\. (Remake this figure with the correct labels in terms of G,u,a
    and t) (A) The network to learn an operator G(a(t)) takes two inputs <math alttext="left-parenthesis
    a left-parenthesis t 1 right-parenthesis comma a left-parenthesis t 2 right-parenthesis
    comma ellipsis comma a left-parenthesis t Subscript m Baseline right-parenthesis
    right-parenthesis"><mrow><mo>(</mo> <mi>a</mi> <mrow><mo>(</mo> <msub><mi>t</mi>
    <mn>1</mn></msub> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo> <msub><mi>t</mi>
    <mn>2</mn></msub> <mo>)</mo></mrow> <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <mi>a</mi>
    <mrow><mo>(</mo> <msub><mi>t</mi> <mi>m</mi></msub> <mo>)</mo></mrow> <mo>)</mo></mrow></math>
    and t. (B) Illustration of the training data [(*image source*)](https://arxiv.org/pdf/1910.03193.pdf).
  id: totrans-412
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-14\.（使用正确的标签重新制作此图，标签为G,u,a和t）（A）学习算子G(a(t))的网络接受两个输入<math alttext="left-parenthesis
    a left-parenthesis t 1 right-parenthesis comma a left-parenthesis t 2 right-parenthesis
    comma ellipsis comma a left-parenthesis t Subscript m Baseline right-parenthesis
    right-parenthesis"><mrow><mo>(</mo> <mi>a</mi> <mrow><mo>(</mo> <msub><mi>t</mi>
    <mn>1</mn></msub> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo> <msub><mi>t</mi>
    <mn>2</mn></msub> <mo>)</mo></mrow> <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <mi>a</mi>
    <mrow><mo>(</mo> <msub><mi>t</mi> <mi>m</mi></msub> <mo>)</mo></mrow> <mo>)</mo></mrow></math>和t。（B）训练数据的示意图[(*图片来源*)](https://arxiv.org/pdf/1910.03193.pdf)。
- en: How do we deal with the fact that the inputs have such drastic differences in
    dimension, such as finite dimensional and infinite dimensional at the same time?
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理输入在维度上存在如此巨大差异的事实，比如同时具有有限维和无限维？
- en: In other words, how do we discretize the involved finite dimensional (independent
    variables such as time and space) and infinite dimensional quantities (solution
    functions, parameter function, boundary conditions, initial conditions, *etc*.)
    during training and inference? Note that for neural networks that learn finite
    dimensional mappings, inputs (tables, images, audio files, graphs, natural language
    text) always have the same dimension, are preprocessed to have the same dimension,
    or the network itself processes fixed dimension portions of the input individually.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在训练和推断过程中，我们如何离散化涉及的有限维（如时间和空间）和无限维量（解函数、参数函数、边界条件、初始条件等）？请注意，对于学习有限维映射的神经网络，输入（表格、图像、音频文件、图形、自然语言文本）始终具有相同的维度，被预处理为具有相同的维度，或者网络本身逐个处理输入的固定维度部分。
- en: How do we avoid the common trap in many PDE solution methods, which end up being
    discretization dependent?
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何避免许多PDE解决方法中的常见陷阱，这些方法最终取决于离散化？
- en: In what sense are neural operator networks meshless and able to generalize their
    learned parameters to work for other discretizations than the ones they have been
    trained on? The significant advancement here is that neural operator networks
    are discretization invariant, sharing the same network parameters between different
    discretizations. This means that their outputs do not depend on the underlying
    discretization and can be used with different grid representations.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 神经操作器网络在哪种意义上是无网格的，并且能够将其学习的参数推广到其他不同于训练过的离散化的情况？这里的重大进展在于神经操作器网络是离散化不变的，它们在不同的离散化之间共享相同的网络参数。这意味着它们的输出不依赖于底层的离散化，并且可以与不同的网格表示一起使用。
- en: How do we speed up the computation time for the integrals involved in the neural
    operators and make it less costly?
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何加快神经操作器中涉及的积分的计算时间，并使其成本更低？
- en: We involve the Fourier transform. Fourier neural network speeds up the process
    of computing the involved integrals tranforming the inputs to Fourier space. This
    has the fast Fourier transform methods at its disposal. Fourier neural network,
    which we discuss in the next subsection, implements this.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入傅立叶变换。傅立叶神经网络加速了计算所涉及积分的过程，将输入转换为傅立叶空间。这利用了快速傅立叶变换方法。我们将在下一小节讨论的傅立叶神经网络实现了这一点。
- en: How do neural operator networks fair with high dimensional PDEs involving hundreds
    or thousands of variables?
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 神经操作器网络如何处理涉及数百或数千个变量的高维PDE？
- en: PDEs that model financial markets with all the underlying assets (Black Scholes),
    game theoretic settings with many participating agents (Hamilton Jacobi Bellman),
    or physical systems with many particles, are very high dimensional. Discretization
    in each of these dimensions explodes the size of an already big problem computationally
    and have until now made any practical implementation of these elegant PDEs infeasible.
    The 2018 article, [*Solving High Dimensional Differential Equations Using Deep
    Learning*](https://www.pnas.org/doi/epdf/10.1073/pnas.1718942115), which we also
    discuss soon, uses AI techniques to address such PDEs, but it would be nice to
    compare that article’s methodology to a deep neural operator setting.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 金融市场模型（Black Scholes）、涉及多个参与代理的博弈论设置（Hamilton Jacobi Bellman），或者涉及多粒子的物理系统，都是非常高维的。在每个维度上的离散化会使本来就很大的问题在计算上变得更加庞大，直到现在，这些优雅的PDE的任何实际实现都是不可行的。2018年的文章[*使用深度学习解决高维微分方程*](https://www.pnas.org/doi/epdf/10.1073/pnas.1718942115)，我们很快也会讨论，使用AI技术来解决这些PDE，但是将该文章的方法与深度神经操作器设置进行比较会更好。
- en: Fourier neural network
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 傅立叶神经网络
- en: The California Institute of Technology has recently open sourced its Fourier
    neural network for solving partial differential equations, whose approach is illustrated
    in the article [*Fourier Neural Operator For Parametric Partial Differential Equations
    (2021)*](https://arxiv.org/pdf/2010.08895.pdf).These networks can approximate
    solution operators for PDEs that are highly non-linear, with high frequency modes
    and slow energy decay.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 加州理工学院最近开源了其傅立叶神经网络，用于解决偏微分方程，其方法在文章[*参数化偏微分方程的傅立叶神经操作器（2021）*](https://arxiv.org/pdf/2010.08895.pdf)中有所说明。这些网络可以近似高度非线性、高频模式和能量衰减缓慢的PDE的解算符。
- en: Each layer in Fourier neural network network applies a fast Fourier transform
    to its input data, then a linear transform, then an inverse fast Fourier transform.
    This results in a quasi-linear computational complexity, that is, of order O(n
    polynomial(log(n))) and makes the model invariant to the spatial resolution of
    the data (even though it still requires a uniform mesh).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 傅立叶神经网络中的每一层都对其输入数据应用快速傅立叶变换，然后是线性变换，然后是逆傅立叶变换。这导致准线性的计算复杂度，即O(n多项式(log(n)))的顺序，并使模型对数据的空间分辨率不变（尽管仍需要均匀网格）。
- en: '[Figure 13-15](#Fig_FourierNN) shows the architechture of the Fourier neural
    network.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-15显示了傅立叶神经网络的架构。
- en: '![250](assets/emai_1315.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![250](assets/emai_1315.png)'
- en: Figure 13-15\. The architecture of Fourier neural network [(*image source*)](https://arxiv.org/pdf/2010.08895.pdf).
  id: totrans-426
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-15. 傅立叶神经网络的架构（*图片来源*）。
- en: The input is the physical parameter a(x) and the output is the PDE solution
    u(x).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 输入是物理参数a(x)，输出是PDE解u(x)。
- en: Start from input a(x).
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从输入a(x)开始。
- en: 'Lift to a higher dimension channel space by a shallow fully connected neural
    network P: v0(x) = P(a(x)).'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过一个浅度全连接的神经网络P将其提升到更高维度的通道空间：v0(x) = P(a(x))。
- en: 'Apply several Fourier layers of integral operators and activation functions.
    In each of these layers we: Apply the Fourier transform F.T; a linear transform
    R on the lower Fourier modes and filters out the higher modes; Apply the inverse
    Fourier transform <math alttext="upper F period upper T Superscript negative 1"><mrow><mi>F</mi>
    <mo>.</mo> <msup><mi>T</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
    . On the bottom: apply a local linear transform W.'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用几个傅立叶层的积分算子和激活函数。在这些层中，我们：应用傅立叶变换F.T；对较低的傅立叶模式应用线性变换R并滤除较高的模式；应用逆傅立叶变换 <math
    alttext="上F周期上T负1"><mrow><mi>F</mi> <mo>.</mo> <msup><mi>T</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
    。在底部：应用局部线性变换W。
- en: Project back to the target dimension by a neural network Q. Finish with the
    output u(x) = Q(vT (x)), which is the projection of v by the a local transformation
    Q also parameterized by a shallow fully connected neural network.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过神经网络Q将结果投影回目标维度。最后输出u(x) = Q(vT(x))，这是通过局部变换Q对v进行的投影，Q也由一个浅度全连接的神经网络参数化。
- en: Finish with the output u(x).
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后输出u(x)。
- en: 'The article demonstrates the method with a variety of important PDEs:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 文章展示了各种重要的PDE的方法：
- en: Burgers’ equation
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伯格斯方程
- en: Darcy flow
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 达西流
- en: Navier-Stokes equation
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Navier-Stokes方程
- en: Turbulent flows in regimes where other methods diverged
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他方法发散的湍流流动区域中进行。
- en: The Fourier neural network is mesh-invariant, so it can be trained on a lower
    resolution and evaluated at a higher resolution, without seeing any higher resolution
    data (zero-shot super-resolution).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 傅立叶神经网络是网格不变的，因此可以在较低分辨率上进行训练，并在较高分辨率上进行评估，而不需要看到任何更高分辨率的数据（零样本超分辨率）。
- en: 'Since data driven methods rely on the quality and quantity of data, we need
    to generate training pairs of inputs and outputs for the neural operator networks
    by solving the actual PDEs via some other methods. To this end, the authors note
    that: To learn Navier-Stokes equation with <math alttext="v i s c o s i t y equals
    1 e Superscript negative 4"><mrow><mi>v</mi> <mi>i</mi> <mi>s</mi> <mi>c</mi>
    <mi>o</mi> <mi>s</mi> <mi>i</mi> <mi>t</mi> <mi>y</mi> <mo>=</mo> <mn>1</mn> <msup><mi>e</mi>
    <mrow><mo>-</mo><mn>4</mn></mrow></msup></mrow></math> , we need to generate N
    = 10000 training pairs <math alttext="left-parenthesis a left-parenthesis x right-parenthesis
    comma u left-parenthesis x right-parenthesis right-parenthesis"><mrow><mo>(</mo>
    <mi>a</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>,</mo> <mi>u</mi> <mo>(</mo> <mi>x</mi>
    <mo>)</mo> <mo>)</mo></mrow></math> using a numerical solver. For more challenging
    PDEs, generating even a few training samples can be very expensive. A future direction
    would be to combine neural operators with numerical solvers to levitate the requirements
    on data.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据驱动方法依赖于数据的质量和数量，我们需要通过其他方法解决实际PDE来生成神经算子网络的输入和输出的训练对。为此，作者指出：为了学习具有 <math
    alttext="粘度等于1e负4的Navier-Stokes方程"><mrow><mi>v</mi> <mi>i</mi> <mi>s</mi> <mi>c</mi>
    <mi>o</mi> <mi>s</mi> <mi>i</mi> <mi>t</mi> <mi>y</mi> <mo>=</mo> <mn>1</mn> <msup><mi>e</mi>
    <mrow><mo>-</mo><mn>4</mn></mrow></msup></mrow></math> ，我们需要生成N = 10000个训练对 <math
    alttext="left-parenthesis a left-parenthesis x right-parenthesis comma u left-parenthesis
    x right-parenthesis right-parenthesis"><mrow><mo>(</mo> <mi>a</mi> <mo>(</mo>
    <mi>x</mi> <mo>)</mo> <mo>,</mo> <mi>u</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>)</mo></mrow></math>
    使用数值求解器。对于更具挑战性的PDE，生成甚至少量的训练样本可能非常昂贵。未来的方向将是将神经算子与数值求解器结合起来，以减轻对数据的要求。
- en: Statement of the universal approximation theorem for operators
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运算符的通用逼近定理陈述
- en: Suppose that <math alttext="sigma"><mi>σ</mi></math> is a continuous nonpolynomial
    function, X is a Banach Space, <math alttext="upper K 1 subset-of upper X"><mrow><msub><mi>K</mi>
    <mn>1</mn></msub> <mo>⊂</mo> <mi>X</mi></mrow></math> , <math alttext="upper K
    2 subset-of double-struck upper R Superscript d"><mrow><msub><mi>K</mi> <mn>2</mn></msub>
    <mo>⊂</mo> <msup><mi>ℝ</mi> <mi>d</mi></msup></mrow></math> are two compact sets,
    V is a compact set in <math alttext="upper C left-parenthesis upper K 1 right-parenthesis"><mrow><mi>C</mi>
    <mo>(</mo> <msub><mi>K</mi> <mn>1</mn></msub> <mo>)</mo></mrow></math> , G is
    a nonlinear continuous operator, which maps V into <math alttext="upper C left-parenthesis
    upper K 2 right-parenthesis"><mrow><mi>C</mi> <mo>(</mo> <msub><mi>K</mi> <mn>2</mn></msub>
    <mo>)</mo></mrow></math> . Then for any <math alttext="epsilon greater-than 0"><mrow><mi>ϵ</mi>
    <mo>></mo> <mn>0</mn></mrow></math> , there are positive integers n, p, m, constants
    <math alttext="c Subscript i Superscript k Baseline comma xi Subscript i comma
    j Superscript k Baseline comma theta Subscript i Superscript k Baseline comma
    xi Subscript k Baseline element-of double-struck upper R comma omega Subscript
    k Baseline element-of double-struck upper R Superscript d Baseline comma x Subscript
    j Baseline element-of upper K 1 comma i equals 1 comma ellipsis comma n comma
    k equals 1 comma ellipsis comma p comma j equals 1 comma ellipsis comma m"><mrow><msubsup><mi>c</mi>
    <mi>i</mi> <mi>k</mi></msubsup> <mo>,</mo> <msubsup><mi>ξ</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow>
    <mi>k</mi></msubsup> <mo>,</mo> <msubsup><mi>θ</mi> <mi>i</mi> <mi>k</mi></msubsup>
    <mo>,</mo> <msub><mi>ξ</mi> <mi>k</mi></msub> <mo>∈</mo> <mi>ℝ</mi> <mo>,</mo>
    <msub><mi>ω</mi> <mi>k</mi></msub> <mo>∈</mo> <msup><mi>ℝ</mi> <mi>d</mi></msup>
    <mo>,</mo> <msub><mi>x</mi> <mi>j</mi></msub> <mo>∈</mo> <msub><mi>K</mi> <mn>1</mn></msub>
    <mo>,</mo> <mi>i</mi> <mo>=</mo> <mn>1</mn> <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <mi>n</mi>
    <mo>,</mo> <mi>k</mi> <mo>=</mo> <mn>1</mn> <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <mi>p</mi>
    <mo>,</mo> <mi>j</mi> <mo>=</mo> <mn>1</mn> <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <mi>m</mi></mrow></math>
    , such that
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 假设<math alttext="σ"><mi>σ</mi></math>是一个连续非多项式函数，X是Banach空间，<math alttext="K1是X的子集"><mrow><msub><mi>K</mi>
    <mn>1</mn></msub> <mo>⊂</mo> <mi>X</mi></mrow></math>，<math alttext="K2是R^d的紧集"><mrow><msub><mi>K</mi>
    <mn>2</mn></msub> <mo>⊂</mo> <msup><mi>ℝ</mi> <mi>d</mi></msup></mrow></math>是两个紧集，V是<math
    alttext="C(K1)中的紧集"><mrow><mi>C</mi> <mo>(</mo> <msub><mi>K</mi> <mn>1</mn></msub>
    <mo>)</mo></mrow></math>中的紧集，G是一个非线性连续算子，将V映射到<math alttext="C(K2)中"><mrow><mi>C</mi>
    <mo>(</mo> <msub><mi>K</mi> <mn>2</mn></msub> <mo>)</mo></mrow></math>。那么对于任意<math
    alttext="ϵ大于0"><mrow><mi>ϵ</mi> <mo>></mo> <mn>0</mn></mrow></math>，存在正整数n，p，m，常数<math
    alttext="ci^k, xi_i^k, theta_i^k, xi_k, omega_k, x_j, i=1,...,n, k=1,...,p, j=1,...,m"><mrow><msubsup><mi>c</mi>
    <mi>i</mi> <mi>k</mi></msubsup> <mo>,</mo> <msubsup><mi>ξ</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow>
    <mi>k</mi></msubsup> <mo>,</mo> <msubsup><mi>θ</mi> <mi>i</mi> <mi>k</mi></msubsup>
    <mo>,</mo> <msub><mi>ξ</mi> <mi>k</mi></msub> <mo>∈</mo> <mi>ℝ</mi> <mo>,</mo>
    <msub><mi>ω</mi> <mi>k</mi></msub> <mo>∈</mo> <msup><mi>ℝ</mi> <mi>d</mi></msup>
    <mo>,</mo> <msub><mi>x</mi> <mi>j</mi></msub> <mo>∈</mo> <msub><mi>K</mi> <mn>1</mn></msub>
    <mo>,</mo> <mi>i</mi> <mo>=</mo> <mn>1</mn> <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <mi>n</mi>
    <mo>,</mo> <mi>k</mi> <mo>=</mo> <mn>1</mn> <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <mi>p</mi>
    <mo>,</mo> <mi>j</mi> <mo>=</mo> <mn>1</mn> <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <mi>m</mi></mrow></math>，使得
- en: <math alttext="dollar-sign StartAbsoluteValue upper G left-parenthesis u right-parenthesis
    left-parenthesis y right-parenthesis minus sigma-summation Underscript k equals
    1 Overscript p Endscripts sigma-summation Underscript i equals 1 Overscript n
    Endscripts c Subscript i Superscript k Baseline sigma left-parenthesis sigma-summation
    Underscript j equals 1 Overscript m Endscripts xi Subscript i j Superscript k
    Baseline u left-parenthesis x Subscript j Baseline right-parenthesis plus theta
    Subscript i Superscript k Baseline right-parenthesis sigma left-parenthesis omega
    Subscript k Baseline period y plus xi Subscript k Baseline right-parenthesis EndAbsoluteValue
    less-than epsilon dollar-sign"><mrow><mrow><mo>|</mo> <mi>G</mi> <mrow><mo>(</mo>
    <mi>u</mi> <mo>)</mo></mrow> <mrow><mo>(</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>-</mo></mrow>
    <msubsup><mo>∑</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>p</mi></msubsup>
    <msubsup><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup>
    <msubsup><mi>c</mi> <mi>i</mi> <mi>k</mi></msubsup> <mi>σ</mi> <mrow><mo>(</mo>
    <msubsup><mo>∑</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>m</mi></msubsup>
    <msubsup><mi>ξ</mi> <mrow><mi>i</mi><mi>j</mi></mrow> <mi>k</mi></msubsup> <mi>u</mi>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>j</mi></msub> <mo>)</mo></mrow> <mo>+</mo>
    <msubsup><mi>θ</mi> <mi>i</mi> <mi>k</mi></msubsup> <mo>)</mo></mrow> <mi>σ</mi>
    <mrow><mo>(</mo> <msub><mi>ω</mi> <mi>k</mi></msub> <mo>.</mo> <mi>y</mi> <mo>+</mo>
    <msub><mi>ξ</mi> <mi>k</mi></msub> <mo>)</mo></mrow> <mrow><mo>|</mo> <mo><</mo>
    <mi>ϵ</mi></mrow></mrow></math>
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartAbsoluteValue upper G left-parenthesis u right-parenthesis
    left-parenthesis y right-parenthesis minus sigma-summation Underscript k equals
    1 Overscript p Endscripts sigma-summation Underscript i equals 1 Overscript n
    Endscripts c Subscript i Superscript k Baseline sigma left-parenthesis sigma-summation
    Underscript j equals 1 Overscript m Endscripts xi Subscript i j Superscript k
    Baseline u left-parenthesis x Subscript j Baseline right-parenthesis plus theta
    Subscript i Superscript k Baseline right-parenthesis sigma left-parenthesis omega
    Subscript k Baseline period y plus xi Subscript k Baseline right-parenthesis EndAbsoluteValue
    less-than epsilon dollar-sign"><mrow><mrow><mo>|</mo> <mi>G</mi> <mrow><mo>(</mo>
    <mi>u</mi> <mo>)</mo></mrow> <mrow><mo>(</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>-</mo></mrow>
    <msubsup><mo>∑</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>p</mi></msubsup>
    <msubsup><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup>
    <msubsup><mi>c</mi> <mi>i</mi> <mi>k</mi></msubsup> <mi>σ</mi> <mrow><mo>(</mo>
    <msubsup><mo>∑</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>m</mi></msubsup>
    <msubsup><mi>ξ</mi> <mrow><mi>i</mi><mi>j</mi></mrow> <mi>k</mi></msubsup> <mi>u</mi>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>j</mi></msub> <mo>)</mo></mrow> <mo>+</mo>
    <msubsup><mi>θ</mi> <mi>i</mi> <mi>k</mi></msubsup> <mo>)</mo></mrow> <mi>σ</mi>
    <mrow><mo>(</mo> <msub><mi>ω</mi> <mi>k</mi></msub> <mo>.</mo> <mi>y</mi> <mo>+</mo>
    <msub><mi>ξ</mi> <mi>k</mi></msub> <mo>)</mo></mrow> <mrow><mo>|</mo> <mo><</mo>
    <mi>ϵ</mi></mrow></mrow></math>
- en: holds for all <math alttext="u element-of upper V"><mrow><mi>u</mi> <mo>∈</mo>
    <mi>V</mi></mrow></math> and <math alttext="y element-of upper K 2"><mrow><mi>y</mi>
    <mo>∈</mo> <msub><mi>K</mi> <mn>2</mn></msub></mrow></math> . Note that this approximation
    theorem only uses one hidden layer in the neural network, but does not specify
    how many nodes this layer has. In applications, just like in the finite dimensional
    case, we use more than one layer.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有<math alttext="u属于V"><mrow><mi>u</mi> <mo>∈</mo> <mi>V</mi></mrow></math>和<math
    alttext="y属于K2"><mrow><mi>y</mi> <mo>∈</mo> <msub><mi>K</mi> <mn>2</mn></msub></mrow></math>成立。请注意，这个逼近定理只使用神经网络中的一个隐藏层，但没有指定这个层有多少节点。在应用中，就像在有限维情况下一样，我们使用多个层。
- en: Do not be intimidated by the big words and the greek letters. What this theorem
    tells us is that we have theoretical grounds to formulate a neural network operator,
    and expect it to approximate the PDE solution operator very well. Even though
    we may never know the exact formula for the PDE solution operator, the operator
    neural network that we construct acts as a very good proxy. This is the reason
    we are all in love with approximation theorems, and should be eternally grateful
    to the mathematicians who find them.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被大词汇和希腊字母吓到。这个定理告诉我们的是，我们有理论基础来制定一个神经网络算子，并期望它能很好地逼近PDE解算子。即使我们可能永远不会知道PDE解算子的确切公式，我们构建的算子神经网络作为一个很好的代理。这就是我们都热爱逼近定理的原因，应该永远感激那些找到它们的数学家们。
- en: 'We have mentioned this in the context of the fixed point iteration’s *additive*
    approximation of a solution, and it is worth mentioning again: Whether approximating
    a mapping between finite dimensional spaces or a mapping between infinite dimensional
    spaces, neural networks represent functions, functionals, or operators using *compositions*
    of simple functions (a linear combination or linear integral operator composed
    with a nonlinear activation function) to approximate complicated ones. This is
    different than classical approximation approaches where the approximation is *additive*
    and not compositional.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在固定点迭代的*加法*逼近解的背景下提到过这一点，值得再次提到：无论是逼近有限维空间之间的映射还是无限维空间之间的映射，神经网络都使用*简单函数的组合*（线性组合或线性积分算子与非线性激活函数组合）来逼近复杂函数、泛函或算子。这与传统的逼近方法不同，传统的逼近是*加法*的，而不是组合的。
- en: How do we branch out and dive into the more technical details?
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们如何拓展并深入了解更多技术细节？
- en: 'For a deeper dive into neural operator networks, the three important publications
    on this topic are:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入研究神经算子网络，关于这个主题的三个重要出版物是：
- en: '[*DeepONet: Learning nonlinear operators for identifying differential equations
    based on the universal approximation theorem of operators (2020)*](https://arxiv.org/pdf/1910.03193.pdf)'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[*DeepONet: Learning nonlinear operators for identifying differential equations
    based on the universal approximation theorem of operators (2020)*](https://arxiv.org/pdf/1910.03193.pdf)'
- en: '[*Neural Operator: Graph Kernel Network for Partial Differential Equations
    (2020)*](https://arxiv.org/pdf/2003.03485.pdf)'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[*Neural Operator: Graph Kernel Network for Partial Differential Equations
    (2020)*](https://arxiv.org/pdf/2003.03485.pdf)'
- en: '[*Fourier Neural Operator For Parametric PDEs (2021)*](https://arxiv.org/pdf/2010.08895.pdf)'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[*Fourier Neural Operator For Parametric PDEs (2021)*](https://arxiv.org/pdf/2010.08895.pdf)'
- en: Numerical Solutions of High Dimensional Differential Equations
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高维微分方程的数值解
- en: 'Differential equations are universal, they can model almost anything we can
    think of, including our daily commute and traffic. It is hard to be exposed to
    differential equations then *not think* of each situation that we find ourselves
    in as fitting into some sort of differential equation. That said, the curse of
    dimensionality has haunted this field since its inception, and stood in the way
    of many practical applications. This is why many introductory PDE courses misleadingly
    focus only on one and two dimensional differential equations, as if that is all
    there is. If AI was to be given a different name, that is not as flashy and definitely
    would not make it into any movies, it would be: *Processing, computation, and
    analysis of high dimensional data*. This does not talk AI down, because processing,
    computation, and analysis of high dimensional data are exactly what humans do
    on a daily basis, provided that we add a creative dimension to it (which in AI
    would translate to generative models). It is then not surprising that deep learning
    turns out to be an appropriate setting for finding numerical solution of *very*
    high dimensional differential equations. This is the focus of the 2018 article
    [Solving High Dimensional Differential Equations Using Deep Learning (2018)](https://www.pnas.org/doi/epdf/10.1073/pnas.1718942115),
    which addresses PDEs with hundreds or even thousands of dimensions. This way,
    we can include all participating agents, assets, resources, or particles at the
    same time, instead of artificially devising handmade assumptions about their interactions
    and connections. The authors consider multiple high dimensional PDEs, including
    the Hamilton–Jacobi–Bellman equation (what is the optimal strategy for each interacting
    agent, among hundreds of agents?) and the Black–Scholes equation (What is the
    fair price of a European claim based on 100 underlying assets given that no default
    having occurred yet?)'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 微分方程是普遍的，它们可以模拟我们几乎可以想到的任何事物，包括我们的日常通勤和交通情况。暴露于微分方程然后*不考虑*我们所处的每种情况是否符合某种微分方程是很困难的。也就是说，自从微分方程领域诞生以来，维度的诅咒一直困扰着这个领域，并阻碍了许多实际应用。这就是为什么许多初级PDE课程误导性地只关注一维和二维微分方程，好像那就是全部了。如果AI被赋予一个不那么花哨的名字，肯定不会出现在任何电影中，那就是：*高维数据的处理、计算和分析*。这并不是贬低AI，因为处理、计算和分析高维数据正是人类每天所做的事情，前提是我们为其增加了创造性的维度（在AI中这将转化为生成模型）。因此，深度学习结果被证明是寻找*非常*高维微分方程的数值解的合适设置。这是2018年文章[Solving
    High Dimensional Differential Equations Using Deep Learning (2018)](https://www.pnas.org/doi/epdf/10.1073/pnas.1718942115)的重点，该文章涉及具有数百甚至数千维的PDE。通过这种方式，我们可以同时包括所有参与者、资产、资源或粒子，而不是人为地设计关于它们相互作用和联系的假设。作者考虑了多个高维PDE，包括Hamilton-Jacobi-Bellman方程（每个相互作用代理的最佳策略是什么，涉及数百个代理？）和Black-Scholes方程（基于100个基础资产，尚未发生违约的情况下，欧洲索赔的公平价格是多少？）
- en: When we rely on a deep learning setting as a basis for our models, for example,
    for computing solutions of high dimensional PDEs, the first question we must ask
    is what is the input and what is the output of our deep learning network. For
    any PDE whose solution is *u(x,t)*, ideally we would input *x* and *t* and output
    *u(x,t)*. *x* in this case can be an extremely high dimensional <math alttext="ModifyingAbove
    x With right-arrow"><mover accent="true"><mi>x</mi> <mo>→</mo></mover></math>
    . If the entries of *x* have any inherent stochasticity into them, such as prices
    of financial market assets, then we must model them as such, and if we don’t,
    then we are usually assuming some sort of averaging. The bottom line is, for many
    realistic cases, we can input *x* as *X*, a stochastic process. We must define
    this mathematically.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将深度学习设置作为模型的基础时，例如用于计算高维PDE的解时，我们必须首先问的问题是我们的深度学习网络的输入和输出是什么。对于任何解为*u(x,t)*的PDE，理想情况下我们会输入*x*和*t*，输出*u(x,t)*。在这种情况下，*x*可以是一个极高维度的向量。如果*x*的条目具有任何固有的随机性，比如金融市场资产的价格，那么我们必须将它们建模为这样，如果我们不这样做，那么我们通常是在假设某种平均值。最重要的是，对于许多现实情况，我们可以将*x*作为*X*，一个随机过程进行输入。我们必须在数学上定义这一点。
- en: 'One big step in the aforementioned article is reformulating the high dimensional
    PDEs as backward stochastic differential equations before inputting *X* into a
    neural network that approximates the gradient of the solution. To master the essential
    math required here, we must define:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 上述文章中的一个重要步骤是在将*X*输入到近似解梯度的神经网络之前，将高维PDE重新表述为反向随机微分方程。为了掌握这里所需的基本数学，我们必须定义：
- en: Brownian motion (see [Chapter 11](ch11.xhtml#ch11))
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布朗运动（见[第11章](ch11.xhtml#ch11)）
- en: Stochastic process (see [Chapter 11](ch11.xhtml#ch11))
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机过程（见[第11章](ch11.xhtml#ch11)）
- en: Stochastic differential equation (this is beyond the scope of the book)
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机微分方程（这超出了本书的范围）
- en: Relating nonlinear parabolic PDEs to stochastic PDEs (this is beyond the scope
    of the book)
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将非线性抛物型PDE与随机PDE相关联（这超出了本书的范围）
- en: Backward stochastic differential equation (this is beyond the scope of the book)
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反向随机微分方程（这超出了本书的范围）
- en: 'And we must answer the question: Why did we have to reformulate the PDE into
    a stochastic form before training the network? What advantage does this form give
    us? This goes beyond the scope of the book, but you now know what to look for
    and what questions to ask.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须回答一个问题：为什么在训练网络之前我们必须将偏微分方程重新表述为随机形式？这种形式给我们带来了什么优势？这超出了本书的范围，但现在你知道要寻找什么以及要问什么问题了。
- en: Finally, the method opens the door to solving many high dimensional differential
    equations, but there are limitations. The method cannot be applied to the quantum
    many body problem due to the difficulty in dealing with the [Pauli exclusion principle](https://en.wikipedia.org/wiki/Pauli_exclusion_principle).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这种方法为解决许多高维微分方程打开了大门，但也存在一些限制。该方法无法应用于量子多体问题，因为处理[泡利不相容原理](https://en.wikipedia.org/wiki/Pauli_exclusion_principle)的困难。
- en: Simulating Natural Phenomena Directly From Data
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直接从数据模拟自然现象
- en: 'We have addressed particle systems once in this chapter: We used a statistical
    mechanics framework to describe the probabilities of the states of the system
    at the particle scale then we used those to write down PDEs modeling the time
    evolution of the system at the macroscale.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们曾经讨论过粒子系统：我们使用统计力学框架描述了粒子尺度系统状态的概率，然后用这些概率编写了描述系统在宏观尺度上时间演变的偏微分方程。
- en: In this section, we explain how recent neural network based models simulate
    a particle system and predict its evolution *without* writing any PDEs. In other
    words, we bypass PDEs and trade them for *learning from data*.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释最近基于神经网络的模型如何模拟粒子系统并预测其演变，而不需要编写任何偏微分方程。换句话说，我们绕过了偏微分方程，将其替换为从数据中学习。
- en: In order to track the evolution of a certain particle system (such as a water
    or sand) at a granular scale, we need to know each particle’s position vector
    <math alttext="ModifyingAbove p With right-arrow Subscript i Baseline left-parenthesis
    t right-parenthesis"><mrow><msub><mover accent="true"><mi>p</mi> <mo>→</mo></mover>
    <mi>i</mi></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    at each time step *t*. How these positions change depends on local and long range
    interactions between a particle and its neighbors (such as exchanging energy and
    momentum), which are dictated both by the physical nature of the system and by
    external effects such as gravity, temperature, forces, magnetic fields, *etc.*
    Instead of writing down explicit equations for these interactions, and relating
    them to the particles’ positions, velocities, and/or accelerations, we can train
    a neural network to learn a map between a given state of particle system at a
    certain time (input) and the positions of all of its particles (or velocities
    or accelerations) at a future time (output). Graph networks are well suited to
    model particle systems since each particle along with its state can be a node
    and the edges along with their features model the interactions between specific
    particles.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪某个粒子系统（如水或沙）在颗粒尺度上的演变，我们需要知道每个粒子在每个时间步长*t*的位置矢量<math alttext="ModifyingAbove
    p With right-arrow Subscript i Baseline left-parenthesis t right-parenthesis"><mrow><msub><mover
    accent="true"><mi>p</mi> <mo>→</mo></mover> <mi>i</mi></msub> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></math>。这些位置的变化取决于粒子与其邻居之间的局部和远程相互作用（如能量和动量交换），这些相互作用既受系统的物理性质影响，也受重力、温度、力、磁场等外部影响的影响。我们可以训练一个神经网络来学习一个给定时间点（输入）的粒子系统状态与未来某个时间点的所有粒子位置（或速度或加速度）之间的映射，而不是为这些相互作用编写明确的方程，并将它们与粒子的位置、速度和/或加速度联系起来。图网络非常适合模拟粒子系统，因为每个粒子及其状态可以是一个节点，边及其特征可以模拟特定粒子之间的相互作用。
- en: 'We highlight and comment on the general ideas from a recent work that learns
    such a map: [Learning to Simulate Complex Physics with Graph Networks (2020, Google’s
    DeepMind and Stanford University)](https://arxiv.org/pdf/2002.09405.pdf)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强调并评论了一项最近的工作中的一般思想，该工作学习了这样一个映射：[使用图网络学习复杂物理学（2020年，谷歌DeepMind和斯坦福大学）](https://arxiv.org/pdf/2002.09405.pdf)
- en: First, we need training data
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要训练数据
- en: 'We can generate input (particle system and its features at a certain time)
    and target (each particle’s acceleration at a later time) pairs from a dataset
    of observed or simulated trajectories of a certain particle system: For example,
    from a 1000-step long trajectory, the team generates 995 pairs, conditioning on
    the 5 past states. In the datasets, we only need the position vectors, and we
    can derive velocity and acceleration vectors using finite differences. The datasets
    typically contained 1000 train, 100 validation and 100 test trajectories, each
    simulated for 300-2000 timesteps, tailored to the average duration for the various
    materials to come to a stable equilibrium.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从观察或模拟某个粒子系统的轨迹数据集中生成输入（某个时间点的粒子系统及其特征）和目标（稍后时间点每个粒子的加速度）对：例如，从一个1000步长的轨迹中，团队生成995对，以过去5个状态为条件。在数据集中，我们只需要位置矢量，可以使用有限差分推导出速度和加速度矢量。数据集通常包含1000个训练、100个验证和100个测试轨迹，每个轨迹模拟了300-2000个时间步长，根据各种材料达到稳定平衡所需的平均持续时间进行调整。
- en: Next, we need to build the map from input to output (the network components)
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要构建从输入到输出（网络组件）的映射。
- en: Start with the system at a certain state at integer time t <math alttext="upper
    X Superscript t Baseline equals left-parenthesis ModifyingAbove x With right-arrow
    Subscript 0 Superscript t Baseline comma ellipsis comma ModifyingAbove x With
    right-arrow Subscript upper N Superscript t Baseline right-parenthesis"><mrow><msup><mi>X</mi>
    <mi>t</mi></msup> <mo>=</mo> <mrow><mo>(</mo> <msubsup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mn>0</mn> <mi>t</mi></msubsup> <mo>,</mo> <mo>⋯</mo> <mo>,</mo>
    <msubsup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mi>N</mi> <mi>t</mi></msubsup>
    <mo>)</mo></mrow></mrow></math> , where each of the N particles’ <math alttext="ModifyingAbove
    x With right-arrow Subscript i Superscript t"><msubsup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mi>i</mi> <mi>t</mi></msubsup></math> represents its state
    at time t (which includes its position <math alttext="ModifyingAbove p With right-arrow
    Subscript i Superscript t"><msubsup><mover accent="true"><mi>p</mi> <mo>→</mo></mover>
    <mi>i</mi> <mi>t</mi></msubsup></math> and other characteristics such as mass,
    material properties, *etc.*).
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 从整数时间 t 的某个状态开始系统 <math alttext="upper X Superscript t Baseline equals left-parenthesis
    ModifyingAbove x With right-arrow Subscript 0 Superscript t Baseline comma ellipsis
    comma ModifyingAbove x With right-arrow Subscript upper N Superscript t Baseline
    right-parenthesis"><mrow><msup><mi>X</mi> <mi>t</mi></msup> <mo>=</mo> <mrow><mo>(</mo>
    <msubsup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mn>0</mn> <mi>t</mi></msubsup>
    <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <msubsup><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mi>N</mi> <mi>t</mi></msubsup> <mo>)</mo></mrow></mrow></math>，其中每个 N 个粒子的 <math
    alttext="ModifyingAbove x With right-arrow Subscript i Superscript t"><msubsup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mi>i</mi> <mi>t</mi></msubsup></math>
    代表其在时间 t 的状态（包括其位置 <math alttext="ModifyingAbove p With right-arrow Subscript
    i Superscript t"><msubsup><mover accent="true"><mi>p</mi> <mo>→</mo></mover> <mi>i</mi>
    <mi>t</mi></msubsup></math> 和其他特性，如质量，材料属性等）。
- en: Next, learn a map that represents the state <math alttext="upper X Superscript
    t Baseline equals left-parenthesis ModifyingAbove x With right-arrow Subscript
    0 Superscript t Baseline comma ellipsis comma ModifyingAbove x With right-arrow
    Subscript upper N Superscript t Baseline right-parenthesis"><mrow><msup><mi>X</mi>
    <mi>t</mi></msup> <mo>=</mo> <mrow><mo>(</mo> <msubsup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mn>0</mn> <mi>t</mi></msubsup> <mo>,</mo> <mo>⋯</mo> <mo>,</mo>
    <msubsup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mi>N</mi> <mi>t</mi></msubsup>
    <mo>)</mo></mrow></mrow></math> as graph G = (nodes,edges, global properties which
    can alternatively be included as node features). The node embeddings <math alttext="ModifyingAbove
    n o d e With right-arrow Subscript i Baseline equals f u n c t i o n left-parenthesis
    ModifyingAbove x With right-arrow Subscript i Baseline right-parenthesis"><mrow><msub><mover
    accent="true"><mrow><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi></mrow> <mo>→</mo></mover>
    <mi>i</mi></msub> <mo>=</mo> <mi>f</mi> <mi>u</mi> <mi>n</mi> <mi>c</mi> <mi>t</mi>
    <mi>i</mi> <mi>o</mi> <mi>n</mi> <mrow><mo>(</mo> <msub><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></math> are learned
    functions (using a multilayer perceptron) of the particles’states. Directed edges
    are added to create paths between particle nodes which have some potential interaction.
    The edge embeddings, <math alttext="ModifyingAbove e With right-arrow Subscript
    i comma j Baseline equals f u n c t i o n left-parenthesis ModifyingAbove r With
    right-arrow Subscript i comma j Baseline right-parenthesis"><mrow><msub><mover
    accent="true"><mi>e</mi> <mo>→</mo></mover> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>=</mo> <mi>f</mi> <mi>u</mi> <mi>n</mi> <mi>c</mi> <mi>t</mi> <mi>i</mi> <mi>o</mi>
    <mi>n</mi> <mrow><mo>(</mo> <msub><mover accent="true"><mi>r</mi> <mo>→</mo></mover>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub> <mo>)</mo></mrow></mrow></math>
    , are learned functions (using a multilayer perceptron) of the pairwise properties
    of the corresponding particles <math alttext="ModifyingAbove r With right-arrow
    Subscript i comma j"><msub><mover accent="true"><mi>r</mi> <mo>→</mo></mover>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></math> , for example, displacement
    between their positions, spring constant, *etc*.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，学习一个表示状态的地图 <math alttext="upper X Superscript t Baseline equals left-parenthesis
    ModifyingAbove x With right-arrow Subscript 0 Superscript t Baseline comma ellipsis
    comma ModifyingAbove x With right-arrow Subscript upper N Superscript t Baseline
    right-parenthesis"><mrow><msup><mi>X</mi> <mi>t</mi></msup> <mo>=</mo> <mrow><mo>(</mo>
    <msubsup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mn>0</mn> <mi>t</mi></msubsup>
    <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <msubsup><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mi>N</mi> <mi>t</mi></msubsup> <mo>)</mo></mrow></mrow></math> 作为图 G = (节点，边，全局属性，也可以作为节点特征包含)。节点嵌入
    <math alttext="ModifyingAbove n o d e With right-arrow Subscript i Baseline equals
    f u n c t i o n left-parenthesis ModifyingAbove x With right-arrow Subscript i
    Baseline right-parenthesis"><mrow><msub><mover accent="true"><mrow><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi></mrow>
    <mo>→</mo></mover> <mi>i</mi></msub> <mo>=</mo> <mi>f</mi> <mi>u</mi> <mi>n</mi>
    <mi>c</mi> <mi>t</mi> <mi>i</mi> <mi>o</mi> <mi>n</mi> <mrow><mo>(</mo> <msub><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></math>
    是粒子状态的学习函数（使用多层感知器）。添加有向边以创建粒子节点之间可能相互作用的路径。边的嵌入 <math alttext="ModifyingAbove
    e With right-arrow Subscript i comma j Baseline equals f u n c t i o n left-parenthesis
    ModifyingAbove r With right-arrow Subscript i comma j Baseline right-parenthesis"><mrow><msub><mover
    accent="true"><mi>e</mi> <mo>→</mo></mover> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>=</mo> <mi>f</mi> <mi>u</mi> <mi>n</mi> <mi>c</mi> <mi>t</mi> <mi>i</mi> <mi>o</mi>
    <mi>n</mi> <mrow><mo>(</mo> <msub><mover accent="true"><mi>r</mi> <mo>→</mo></mover>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub> <mo>)</mo></mrow></mrow></math>
    是对应粒子的成对属性的学习函数（使用多层感知器），例如它们位置之间的位移，弹簧常数等等。
- en: 'Then learn a graph to graph map: This computes the interactions among the nodes
    via M steps of learned message-passing, to generate a sequence of updated latent
    graphs, <math alttext="upper G equals left-parenthesis upper G 1 comma ellipsis
    comma upper G Subscript upper M Baseline right-parenthesis"><mrow><mi>G</mi> <mo>=</mo>
    <mo>(</mo> <msub><mi>G</mi> <mn>1</mn></msub> <mo>,</mo> <mo>⋯</mo> <mo>,</mo>
    <msub><mi>G</mi> <mi>M</mi></msub> <mo>)</mo></mrow></math> . Then returns the
    final graph. Message-passing allows information to propagate between the nodes
    via the edges, and for the constraints to be respected. This way, the complex
    dynamics of the system are approximated by learned message-passing among the nodes
    within their local neighborhoods. Moreover, the final graph has the same structure
    as first graph, but with potentially different node, edge, and graph-level attributes.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 然后学习一个图到图的映射：通过M步学习的消息传递计算节点之间的相互作用，生成一系列更新的潜在图，<math alttext="upper G equals
    left-parenthesis upper G 1 comma ellipsis comma upper G Subscript upper M Baseline
    right-parenthesis"><mrow><mi>G</mi> <mo>=</mo> <mo>(</mo> <msub><mi>G</mi> <mn>1</mn></msub>
    <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <msub><mi>G</mi> <mi>M</mi></msub> <mo>)</mo></mrow></math>。然后返回最终图。消息传递允许信息通过边在节点之间传播，并且遵守约束。这样，系统的复杂动态通过节点之间的学习消息传递在它们的局部邻域内近似。此外，最终图具有与第一个图相同的结构，但具有潜在不同的节点、边和图级属性。
- en: Then, learn a map (multilayer perceptron) from the final graph to a matrix that
    extracts the dynamics of the system, for example, the matrix of the particles’
    acceleration <math alttext="upper Y equals left-parenthesis ModifyingAbove p With
    right-arrow double-prime Subscript 1 Baseline comma ModifyingAbove p With right-arrow
    double-prime Subscript 2 Baseline comma ellipsis comma ModifyingAbove p With right-arrow
    double-prime Subscript upper N right-parenthesis"><mrow><mi>Y</mi> <mo>=</mo>
    <mo>(</mo> <msubsup><mover accent="true"><mi>p</mi> <mo>→</mo></mover> <mn>1</mn>
    <mrow><mo>'</mo><mo>'</mo></mrow></msubsup> <mo>,</mo> <msubsup><mover accent="true"><mi>p</mi>
    <mo>→</mo></mover> <mn>2</mn> <mrow><mo>'</mo><mo>'</mo></mrow></msubsup> <mo>,</mo>
    <mo>⋯</mo> <mo>,</mo> <msubsup><mover accent="true"><mi>p</mi> <mo>→</mo></mover>
    <mi>N</mi> <mrow><mo>'</mo><mo>'</mo></mrow></msubsup> <mo>)</mo></mrow></math>
    . Finally, the particles’ positions and velocities are updated using an Euler
    integrator of the accelerations in Y. This in turn updates the system’s state
    to <math alttext="upper X Superscript t plus 1"><msup><mi>X</mi> <mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msup></math>
    .
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，学习一个从最终图到提取系统动态的矩阵的映射（多层感知器），例如，粒子加速度的矩阵<math alttext="upper Y equals left-parenthesis
    ModifyingAbove p With right-arrow double-prime Subscript 1 Baseline comma ModifyingAbove
    p With right-arrow double-prime Subscript 2 Baseline comma ellipsis comma ModifyingAbove
    p With right-arrow double-prime Subscript upper N right-parenthesis"><mrow><mi>Y</mi>
    <mo>=</mo> <mo>(</mo> <msubsup><mover accent="true"><mi>p</mi> <mo>→</mo></mover>
    <mn>1</mn> <mrow><mo>'</mo><mo>'</mo></mrow></msubsup> <mo>,</mo> <msubsup><mover
    accent="true"><mi>p</mi> <mo>→</mo></mover> <mn>2</mn> <mrow><mo>'</mo><mo>'</mo></mrow></msubsup>
    <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <msubsup><mover accent="true"><mi>p</mi> <mo>→</mo></mover>
    <mi>N</mi> <mrow><mo>'</mo><mo>'</mo></mrow></msubsup> <mo>)</mo></mrow></math>。最后，使用Y中的加速度的Euler积分器更新粒子的位置和速度。这反过来将系统的状态更新为<math
    alttext="upper X Superscript t plus 1"><msup><mi>X</mi> <mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msup></math>。
- en: Such models are not restricted to materials and particle systems, but can model
    systems with many interacting agents, such as robotic control systems. They are
    a great step towards simulating complex phenomena authentically, which is of great
    value to science and engineering.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的模型不仅限于材料和粒子系统，还可以模拟具有许多相互作用代理人的系统，例如机器人控制系统。这是朝着真实模拟复杂现象迈出的一大步，对科学和工程领域具有重要价值。
- en: Hamilton-Jacobi-Bellman PDE for Dynamic Programming
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态规划的Hamilton-Jacobi-Bellman PDE
- en: The Hamilton–Jacobi–Bellman equation is yet another PDE whose solution unlocks
    many possibilities in economics, operations research, and finance, *if only* we
    are able to solve it in high dimensions. In a nutshell, we are searching for an
    *optimal strategy* (such as an investment strategy) that guarantees some *minimal*
    implementation cost over a *given period of time*. Ideally, we would like to include
    hundreds or thousands of interacting agents, such as all the financial assets
    for investment banking, instead of downsizing to unrealistic *represenative agent*
    models. This is where using neural networks to find numerical solutions for high
    dimensional PDEs helps us, as we saw earlier in this chapter.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: Hamilton-Jacobi-Bellman方程是另一个偏微分方程，其解决方案在经济学、运筹学和金融领域中打开了许多可能性，*只要*我们能够在高维度中解决它。简而言之，我们正在寻找一个*最佳策略*（如投资策略），以确保在*一定时间段内*有一些*最小*的实施成本。理想情况下，我们希望包括数百或数千个相互作用的代理人，例如所有投资银行的金融资产，而不是缩小到不切实际的*代理人*模型。这就是在本章前面看到的使用神经网络为高维度PDE找到数值解的地方。
- en: 'Mathematically, the Hamilton-Jacobi-Bellman PDE is very *rich*: It combines
    dynamical systems ( <math alttext="StartFraction normal partial-differential x
    left-parenthesis t right-parenthesis Over d t EndFraction equals f left-parenthesis
    x left-parenthesis t right-parenthesis comma a left-parenthesis t right-parenthesis
    comma t right-parenthesis"><mrow><mfrac><mrow><mi>∂</mi><mi>x</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow>
    <mrow><mi>d</mi><mi>t</mi></mrow></mfrac> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    ), PDEs (partial derivatives and equalities), and optimization (*max* or *min*
    problems). When we learn how to derive this one PDE from real world applications,
    attempt to understand it, find its solutions, and analyze these solutions (existence,
    uniqueness, smoothness, etc.), we acquire a ton of math.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，哈密尔顿-雅可比-贝尔曼偏微分方程非常丰富：它结合了动力系统（<math alttext="StartFraction normal partial-differential
    x left-parenthesis t right-parenthesis Over d t EndFraction equals f left-parenthesis
    x left-parenthesis t right-parenthesis comma a left-parenthesis t right-parenthesis
    comma t right-parenthesis"><mrow><mfrac><mrow><mi>∂</mi><mi>x</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow>
    <mrow><mi>d</mi><mi>t</mi></mrow></mfrac> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>），偏微分方程（偏导数和等式）以及优化（*max*或*min*问题）。当我们学会如何从现实世界应用中推导出这个偏微分方程时，尝试理解它，找到它的解，并分析这些解（存在性，唯一性，平滑性等），我们会获得大量数学知识。
- en: Moreover, this PDE is directly related to *reinforcement learning* in AI, but
    instead of thinking about reinforcement probabilistically, in terms Markov decision
    processes, such as in [Chapter 11](ch11.xhtml#ch11), we think about reinforcement
    in terms of deterministic dynamic programming.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个偏微分方程直接与人工智能中的强化学习相关，但是与以马尔可夫决策过程为基础的概率强化学习不同，我们考虑以确定性动态规划的方式来思考强化学习。
- en: 'In the dynamic programming setting, the states of the interacting agents, bundled
    in a vector <math alttext="ModifyingAbove x With right-arrow left-parenthesis
    t right-parenthesis"><mrow><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math> , evolve in time according
    to a dynamic system, and we need to find an optimizing policy that induces a special
    solution of this dynamic system: The one which incurs a minimal cost over a given
    period of time. The train of thought goes like this: A certain time dependent
    policy affects the behavior of a dynamic system which in turn affects the incurred
    cost. All of these are mathematical quantities.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态规划设置中，相互作用代理的状态，捆绑在一个向量<math alttext="ModifyingAbove x With right-arrow left-parenthesis
    t right-parenthesis"><mrow><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>中，随时间演变，我们需要找到一种优化策略，引发这个动态系统的特殊解：在给定时间段内产生最小成本。思路是这样的：一种特定的时间依赖策略影响动态系统的行为，进而影响产生的成本。所有这些都是数学量。
- en: The contributions of Richard Bellman (1920-1984) to the dynamic programming
    field (finding optimal strategies for an evolving system over a given period of
    time) are invaluable. We will encounter Bellman’s principle for optimality shortly,
    and in fact, it is him who coined the term *curse of dimensionality*. This principle
    is tremendously helpful as it breaks down the involved optimization problem over
    the considered period of time into smaller subproblems at smaller time intervals,
    which we can then solve in a recursive manner.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 理查德·贝尔曼（1920-1984）对动态规划领域（在给定时间段内找到演变系统的最佳策略）的贡献是无价的。我们很快将遇到贝尔曼最优性原理，实际上，正是他创造了“维度诅咒”这个术语。这个原理非常有帮助，因为它将在考虑的时间段内涉及的优化问题分解为更小的子问题，然后我们可以以递归方式解决这些问题。
- en: Bellman’s equation in deterministic and stochastic settings
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定性和随机设置中的贝尔曼方程
- en: 'In a *deterministic* dynamic programming setting, there are:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定性动态规划设置中，有：
- en: '*Discrete time* Bellman’s equation: We can find the value function starting
    from the current time till the final time by picking the best strategy (or control
    or policy) <math alttext="a Subscript k"><msub><mi>a</mi> <mi>k</mi></msub></math>
    at the current time step *k* so that the current cost plus the value function
    at the next time step is minimized. This is a recursive process:'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离散时间贝尔曼方程：我们可以通过选择当前时间步骤*k*处的最佳策略（或控制或政策）<math alttext="a Subscript k"><msub><mi>a</mi>
    <mi>k</mi></msub></math>来找到从当前时间到最终时间的值函数，以便当前成本加上下一个时间步骤的值函数最小化。这是一个递归过程：
- en: <math alttext="dollar-sign upper V a l u e left-parenthesis ModifyingAbove x
    With right-arrow Subscript k Baseline comma n right-parenthesis equals min Underscript
    ModifyingAbove a With right-arrow Subscript k Baseline Endscripts left-parenthesis
    upper C o s t left-parenthesis ModifyingAbove x With right-arrow Subscript k Baseline
    comma ModifyingAbove a With right-arrow Subscript k Baseline right-parenthesis
    plus upper V a l u e left-parenthesis ModifyingAbove x With right-arrow Subscript
    k plus 1 Baseline comma n minus 1 right-parenthesis right-parenthesis dollar-sign"><mrow><mi>V</mi>
    <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mrow><mo>(</mo> <msub><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mi>k</mi></msub> <mo>,</mo> <mi>n</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mo form="prefix" movablelimits="true">min</mo> <msub><mover accent="true"><mi>a</mi>
    <mo>→</mo></mover> <mi>k</mi></msub></msub> <mrow><mo>(</mo> <mi>C</mi> <mi>o</mi>
    <mi>s</mi> <mi>t</mi> <mrow><mo>(</mo> <msub><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mi>k</mi></msub> <mo>,</mo> <msub><mover accent="true"><mi>a</mi> <mo>→</mo></mover>
    <mi>k</mi></msub> <mo>)</mo></mrow> <mo>+</mo> <mi>V</mi> <mi>a</mi> <mi>l</mi>
    <mi>u</mi> <mi>e</mi> <mrow><mo>(</mo> <msub><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>,</mo> <mi>n</mi> <mo>-</mo>
    <mn>1</mn> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper V a l u e left-parenthesis ModifyingAbove x
    With right-arrow Subscript k Baseline comma n right-parenthesis equals min Underscript
    ModifyingAbove a With right-arrow Subscript k Baseline Endscripts left-parenthesis
    upper C o s t left-parenthesis ModifyingAbove x With right-arrow Subscript k Baseline
    comma ModifyingAbove a With right-arrow Subscript k Baseline right-parenthesis
    plus upper V a l u e left-parenthesis ModifyingAbove x With right-arrow Subscript
    k plus 1 Baseline comma n minus 1 right-parenthesis right-parenthesis dollar-sign"><mrow><mi>V</mi>
    <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mrow><mo>(</mo> <msub><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mi>k</mi></msub> <mo>,</mo> <mi>n</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mo form="prefix" movablelimits="true">min</mo> <msub><mover accent="true"><mi>a</mi>
    <mo>→</mo></mover> <mi>k</mi></msub></msub> <mrow><mo>(</mo> <mi>C</mi> <mi>o</mi>
    <mi>s</mi> <mi>t</mi> <mrow><mo>(</mo> <msub><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mi>k</mi></msub> <mo>,</mo> <msub><mover accent="true"><mi>a</mi> <mo>→</mo></mover>
    <mi>k</mi></msub> <mo>)</mo></mrow> <mo>+</mo> <mi>V</mi> <mi>a</mi> <mi>l</mi>
    <mi>u</mi> <mi>e</mi> <mrow><mo>(</mo> <msub><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>,</mo> <mi>n</mi> <mo>-</mo>
    <mn>1</mn> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
- en: where *n* is the final time step, and the discrete time dynamics are
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*n*是最终时间步骤，离散时间动态是
- en: <math alttext="dollar-sign ModifyingAbove x With right-arrow Subscript k plus
    1 Baseline equals ModifyingAbove f With right-arrow left-parenthesis ModifyingAbove
    x With right-arrow Subscript k Baseline comma ModifyingAbove a With right-arrow
    Subscript k Baseline right-parenthesis dollar-sign"><mrow><msub><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>=</mo>
    <mover accent="true"><mi>f</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mi>k</mi></msub> <mo>,</mo> <msub><mover
    accent="true"><mi>a</mi> <mo>→</mo></mover> <mi>k</mi></msub> <mo>)</mo></mrow></mrow></math>
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign ModifyingAbove x With right-arrow Subscript k plus
    1 Baseline equals ModifyingAbove f With right-arrow left-parenthesis ModifyingAbove
    x With right-arrow Subscript k Baseline comma ModifyingAbove a With right-arrow
    Subscript k Baseline right-parenthesis dollar-sign"><mrow><msub><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>=</mo>
    <mover accent="true"><mi>f</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mi>k</mi></msub> <mo>,</mo> <msub><mover
    accent="true"><mi>a</mi> <mo>→</mo></mover> <mi>k</mi></msub> <mo>)</mo></mrow></mrow></math>
- en: so that
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 因此
- en: <math alttext="dollar-sign upper V a l u e left-parenthesis ModifyingAbove x
    With right-arrow Subscript k Baseline comma n right-parenthesis equals min Underscript
    ModifyingAbove a With right-arrow Subscript k Baseline Endscripts left-parenthesis
    upper C o s t left-parenthesis ModifyingAbove x With right-arrow Subscript k Baseline
    comma ModifyingAbove a With right-arrow Subscript k Baseline right-parenthesis
    plus upper V a l u e left-parenthesis ModifyingAbove f With right-arrow left-parenthesis
    ModifyingAbove x With right-arrow Subscript k Baseline comma ModifyingAbove a
    With right-arrow Subscript k Baseline right-parenthesis comma n minus 1 right-parenthesis
    right-parenthesis dollar-sign"><mrow><mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi>
    <mi>e</mi> <mrow><mo>(</mo> <msub><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mi>k</mi></msub> <mo>,</mo> <mi>n</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo
    form="prefix" movablelimits="true">min</mo> <msub><mover accent="true"><mi>a</mi>
    <mo>→</mo></mover> <mi>k</mi></msub></msub> <mrow><mo>(</mo> <mi>C</mi> <mi>o</mi>
    <mi>s</mi> <mi>t</mi> <mrow><mo>(</mo> <msub><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mi>k</mi></msub> <mo>,</mo> <msub><mover accent="true"><mi>a</mi> <mo>→</mo></mover>
    <mi>k</mi></msub> <mo>)</mo></mrow> <mo>+</mo> <mi>V</mi> <mi>a</mi> <mi>l</mi>
    <mi>u</mi> <mi>e</mi> <mrow><mo>(</mo> <mover accent="true"><mi>f</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <msub><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mi>k</mi></msub>
    <mo>,</mo> <msub><mover accent="true"><mi>a</mi> <mo>→</mo></mover> <mi>k</mi></msub>
    <mo>)</mo></mrow> <mo>,</mo> <mi>n</mi> <mo>-</mo> <mn>1</mn> <mo>)</mo></mrow>
    <mo>)</mo></mrow></mrow></math>
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper V a l u e left-parenthesis ModifyingAbove x
    With right-arrow Subscript k Baseline comma n right-parenthesis equals min Underscript
    ModifyingAbove a With right-arrow Subscript k Baseline Endscripts left-parenthesis
    upper C o s t left-parenthesis ModifyingAbove x With right-arrow Subscript k Baseline
    comma ModifyingAbove a With right-arrow Subscript k Baseline right-parenthesis
    plus upper V a l u e left-parenthesis ModifyingAbove f With right-arrow left-parenthesis
    ModifyingAbove x With right-arrow Subscript k Baseline comma ModifyingAbove a
    With right-arrow Subscript k Baseline right-parenthesis comma n minus 1 right-parenthesis
    right-parenthesis dollar-sign"><mrow><mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi>
    <mi>e</mi> <mrow><mo>(</mo> <msub><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mi>k</mi></msub> <mo>,</mo> <mi>n</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo
    form="prefix" movablelimits="true">min</mo> <msub><mover accent="true"><mi>a</mi>
    <mo>→</mo></mover> <mi>k</mi></msub></msub> <mrow><mo>(</mo> <mi>C</mi> <mi>o</mi>
    <mi>s</mi> <mi>t</mi> <mrow><mo>(</mo> <msub><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mi>k</mi></msub> <mo>,</mo> <msub><mover accent="true"><mi>a</mi> <mo>→</mo></mover>
    <mi>k</mi></msub> <mo>)</mo></mrow> <mo>+</mo> <mi>V</mi> <mi>a</mi> <mi>l</mi>
    <mi>u</mi> <mi>e</mi> <mrow><mo>(</mo> <mover accent="true"><mi>f</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <msub><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mi>k</mi></msub>
    <mo>,</mo> <msub><mover accent="true"><mi>a</mi> <mo>→</mo></mover> <mi>k</mi></msub>
    <mo>)</mo></mrow> <mo>,</mo> <mi>n</mi> <mo>-</mo> <mn>1</mn> <mo>)</mo></mrow>
    <mo>)</mo></mrow></mrow></math>
- en: The sequence of optimizers <math alttext="ModifyingAbove a With right-arrow
    Subscript k"><msub><mover accent="true"><mi>a</mi> <mo>→</mo></mover> <mi>k</mi></msub></math>
    at each discrete time step *k* constitute the optimal policy (or strategy or control)
    for the whole time period, that guarantees the minimal total cost, exactly as
    in reinforcement learning.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 每个离散时间步骤*k*处的优化器<math alttext="ModifyingAbove a With right-arrow Subscript k"><msub><mover
    accent="true"><mi>a</mi> <mo>→</mo></mover> <mi>k</mi></msub></math>序列构成了整个时间段的最优策略（或策略或控制），保证了最小总成本，就像在强化学习中一样。
- en: '*Continuous time* Bellman’s equation, which *is* the Hamilton-Jacobi-Bellman
    PDE.'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*连续时间*贝尔曼方程，即哈密尔顿-雅可比-贝尔曼偏微分方程。'
- en: In a *stochastic* optimal control setting, there is also a stochastic version
    of Bellman’s equation. This is widely applicable in investment banking, and in
    scheduling and routing problems. In the stochastic framework, we need to find
    an optimal control input (strategy or policy) that guides the underlying stochastic
    processes to some desired final state, with minimal cost. Consider for example
    the problem where we need to execute a financial order, with a minimal implementation
    cost and within a certain period of time. We can first model the short term dynamics
    of the underlying assets, then discretize both in time and state spaces. This
    allows us to execute a given amount of shares at each of the time steps, with
    the condition that we must execute all of the shares during the given time period.
    We search for the policy that tells us, among all possible actions that we can
    take at each point in time, what the optimal one is, that gets us to where we
    want to be.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在*随机*最优控制设置中，还有贝尔曼方程的随机版本。这在投资银行、调度和路径问题中广泛适用。在随机框架中，我们需要找到一个引导基础随机过程到达某个期望最终状态的最优控制输入（策略或政策），并且成本最小。例如，考虑这样一个问题：我们需要执行一个金融订单，最小化实施成本，并在一定时间内完成。我们可以首先对基础资产的短期动态进行建模，然后在时间和状态空间中进行离散化。这使我们能够在每个时间步执行给定数量的股票，条件是我们必须在给定时间段内执行所有股票。我们寻找告诉我们，在每个时间点我们可以采取的所有可能行动中，哪一个是最优的，让我们达到我们想要的位置的策略。
- en: 'In [Chapter 11](ch11.xhtml#ch11), we connected Bellman’s equation to reinforcement
    learning. This was done in the context of a Markov decision process with value
    function:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](ch11.xhtml#ch11)中，我们将贝尔曼方程与强化学习联系起来。这是在具有价值函数的马尔可夫决策过程的背景下完成的：
- en: <math alttext="dollar-sign upper V a l u e left-parenthesis ModifyingAbove s
    With right-arrow right-parenthesis equals max Underscript states and actions Endscripts
    double-struck upper E left-parenthesis r e w a r d 0 plus gamma upper V a l u
    e left-parenthesis ModifyingAbove s With right-arrow prime right-parenthesis right-parenthesis
    dollar-sign"><mrow><mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mrow><mo>(</mo>
    <mover accent="true"><mi>s</mi> <mo>→</mo></mover> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mo form="prefix" movablelimits="true">max</mo> <mrow><mtext>states</mtext><mtext>and</mtext><mtext>actions</mtext></mrow></msub>
    <mi>𝔼</mi> <mrow><mo>(</mo> <mi>r</mi> <mi>e</mi> <mi>w</mi> <mi>a</mi> <mi>r</mi>
    <msub><mi>d</mi> <mn>0</mn></msub> <mo>+</mo> <mi>γ</mi> <mi>V</mi> <mi>a</mi>
    <mi>l</mi> <mi>u</mi> <mi>e</mi> <mrow><mo>(</mo> <msup><mover accent="true"><mi>s</mi>
    <mo>→</mo></mover> <mo>'</mo></msup> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper V a l u e left-parenthesis ModifyingAbove s
    With right-arrow right-parenthesis equals max Underscript states and actions Endscripts
    double-struck upper E left-parenthesis r e w a r d 0 plus gamma upper V a l u
    e left-parenthesis ModifyingAbove s With right-arrow prime right-parenthesis right-parenthesis
    dollar-sign"><mrow><mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mrow><mo>(</mo>
    <mover accent="true"><mi>s</mi> <mo>→</mo></mover> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mo form="prefix" movablelimits="true">max</mo> <mrow><mtext>states</mtext><mtext>and</mtext><mtext>actions</mtext></mrow></msub>
    <mi>𝔼</mi> <mrow><mo>(</mo> <mi>r</mi> <mi>e</mi> <mi>w</mi> <mi>a</mi> <mi>r</mi>
    <msub><mi>d</mi> <mn>0</mn></msub> <mo>+</mo> <mi>γ</mi> <mi>V</mi> <mi>a</mi>
    <mi>l</mi> <mi>u</mi> <mi>e</mi> <mrow><mo>(</mo> <msup><mover accent="true"><mi>s</mi>
    <mo>→</mo></mover> <mo>'</mo></msup> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
- en: 'In a deterministic dynamic programming setting, the analogous equation is the
    Hamilton Jacobi Bellman PDE for the value function. Before writing its formula,
    this is the language that we need to pay attention to:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定性动态规划设置中，价值函数的类似方程是哈密尔顿雅可比贝尔曼PDE。在写出其公式之前，这是我们需要注意的语言：
- en: 'Minimizing a cost function: Is there a more common objective in this world?'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最小化成本函数：在这个世界上还有更常见的目标吗？
- en: 'Choosing an optimal control or optimal policy: This is minimizer that we are
    looking for, it controls the dynamical system.'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择最优控制或最优策略：这是我们正在寻找的最小化器，它控制着动态系统。
- en: 'Value function: The total minimum cost over the considered period of time.'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 价值函数：在考虑的时间段内的总最小成本。
- en: 'Bellman optimality principle: An amazingly helpful principle that allows us
    to simplify the optimization problem.'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 贝尔曼最优性原理：一个非常有帮助的原理，让我们能够简化优化问题。
- en: 'Backward in time solution: Start with the desired outcome and work our way
    backwards, optimally, to an initial state. It is intuitive to see why a backward
    in time solution is easier in this setting. Since we know the end goal, we immediately
    exclude all paths that don’t lead to it from the preceding time step, saving us
    the exploration of many useless paths. If on the other hand we solve forward in
    time, starting at the beginning of the time interval, then we do not have the
    advantage of *closeness* to the desired outcome, so we must waste our time and
    computational resources explore many more useless paths.'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 时间反向解：从期望的结果开始，逆向地、最优地工作到初始状态。在这种情况下，逆向解是更容易理解的。因为我们知道最终目标，我们立即排除了不会导致它的所有路径，从前一个时间步开始，节省了我们探索许多无用路径的时间。另一方面，如果我们向前解决问题，从时间间隔的开始开始，那么我们就没有*接近*期望结果的优势，因此我们必须浪费时间和计算资源来探索更多无用的路径。
- en: The Big Picture
  id: totrans-500
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大局观
- en: 'The ultimate question is: What must we do now (what is the initial state <math
    alttext="ModifyingAbove x With right-arrow left-parenthesis t Subscript i n i
    t i a l Baseline right-parenthesis"><mrow><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></mrow></math> and the time dependent policy <math alttext="ModifyingAbove
    a With right-arrow left-parenthesis t right-parenthesis"><mrow><mover accent="true"><mi>a</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    ) in order to get us to where we want to be ( <math alttext="ModifyingAbove x
    With right-arrow left-parenthesis t Subscript f i n a l Baseline right-parenthesis"><mrow><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mi>t</mi>
    <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub> <mo>)</mo></mrow></mrow></math>
    ), in the most cost efficient way (attain the value function <math alttext="upper
    V a l u e left-parenthesis ModifyingAbove x With right-arrow left-parenthesis
    t Subscript i n i t i a l Baseline right-parenthesis comma t Subscript i n i t
    i a l Baseline comma t Subscript f i n a l Baseline right-parenthesis"><mrow><mi>V</mi>
    <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></math> which is the minimum value of the strategy implementation
    cost function)?'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的问题是：我们现在必须做什么（初始状态是<math alttext="ModifyingAbove x With right-arrow left-parenthesis
    t Subscript i n i t i a l Baseline right-parenthesis"><mrow><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mrow><mo>（</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>）</mo></mrow></mrow></math>和时间相关的策略<math alttext="ModifyingAbove a With right-arrow
    left-parenthesis t right-parenthesis"><mrow><mover accent="true"><mi>a</mi> <mo>→</mo></mover>
    <mrow><mo>（</mo> <mi>t</mi> <mo>）</mo></mrow></mrow></math>），以便以最经济的方式（实现策略成本函数的最小值）将我们带到我们想要到达的地方（<math
    alttext="ModifyingAbove x With right-arrow left-parenthesis t Subscript f i n
    a l Baseline right-parenthesis"><mrow><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mo>（</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>）</mo></mrow></mrow></math>）？
- en: 'The involved quantities are:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的数量有：
- en: <math alttext="ModifyingAbove x With right-arrow left-parenthesis t right-parenthesis"><mrow><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    is a vector characterizing the state of the dynamic system.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="ModifyingAbove x With right-arrow left-parenthesis t right-parenthesis"><mrow><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>（</mo> <mi>t</mi> <mo>）</mo></mrow></mrow></math>是描述动态系统状态的向量。
- en: 'The strategy (or policy or control) <math alttext="ModifyingAbove a With right-arrow
    left-parenthesis t right-parenthesis"><mrow><mover accent="true"><mi>a</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math> : We need to design
    this so that it invokes a state <math alttext="ModifyingAbove x With right-arrow
    left-parenthesis t right-parenthesis"><mrow><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math> that minimizes some
    cost function. That is, if we input this special <math alttext="ModifyingAbove
    a With right-arrow left-parenthesis t right-parenthesis"><mrow><mover accent="true"><mi>a</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    that we are looking for to the dynamic system, the output <math alttext="ModifyingAbove
    x With right-arrow left-parenthesis t right-parenthesis"><mrow><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    would minimize the cost function.'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 策略（或政策或控制）<math alttext="ModifyingAbove a With right-arrow left-parenthesis
    t right-parenthesis"><mrow><mover accent="true"><mi>a</mi> <mo>→</mo></mover>
    <mrow><mo>（</mo> <mi>t</mi> <mo>）</mo></mrow></mrow></math>：我们需要设计这个策略，以便调用一个状态<math
    alttext="ModifyingAbove x With right-arrow left-parenthesis t right-parenthesis"><mrow><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>（</mo> <mi>t</mi> <mo>）</mo></mrow></mrow></math>，使某个成本函数最小化。也就是说，如果我们将我们正在寻找的特殊<math
    alttext="ModifyingAbove a With right-arrow left-parenthesis t right-parenthesis"><mrow><mover
    accent="true"><mi>a</mi> <mo>→</mo></mover> <mrow><mo>（</mo> <mi>t</mi> <mo>）</mo></mrow></mrow></math>输入到动态系统中，输出<math
    alttext="ModifyingAbove x With right-arrow left-parenthesis t right-parenthesis"><mrow><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>（</mo> <mi>t</mi> <mo>）</mo></mrow></mrow></math>将最小化成本函数。
- en: 'The cost function <math alttext="upper C o s t left-parenthesis ModifyingAbove
    x With right-arrow left-parenthesis t right-parenthesis comma ModifyingAbove a
    With right-arrow left-parenthesis t right-parenthesis comma t Subscript i n i
    t i a l Baseline comma t Subscript f i n a l Baseline right-parenthesis"><mrow><mi>C</mi>
    <mi>o</mi> <mi>s</mi> <mi>t</mi> <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mover accent="true"><mi>a</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi>
    <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></math> incurred due to the implementation of the strategy (or
    policy or control): This is given by some terminal cost at <math alttext="t Subscript
    f i n a l"><msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub></math>
    and the sum of incremental costs (integral) as we transition from <math alttext="t
    Subscript i n i t i a l"><msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub></math>
    to <math alttext="t Subscript f i n a l"><msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub></math>
    . The incremental costs depend on the current state of the system and the current
    control.'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成本函数 <math alttext="upper C o s t left-parenthesis ModifyingAbove x With right-arrow
    left-parenthesis t right-parenthesis comma ModifyingAbove a With right-arrow left-parenthesis
    t right-parenthesis comma t Subscript i n i t i a l Baseline comma t Subscript
    f i n a l Baseline right-parenthesis"><mrow><mi>C</mi> <mi>o</mi> <mi>s</mi> <mi>t</mi>
    <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mover accent="true"><mi>a</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></math> 是由于实施策略（或政策或控制）而产生的成本：这是由某个终端成本在 <math alttext="t Subscript
    f i n a l"><msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub></math>
    处以及从 <math alttext="t Subscript i n i t i a l"><msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub></math>
    过渡到 <math alttext="t Subscript f i n a l"><msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub></math>
    的增量成本（积分）组成。增量成本取决于系统的当前状态和当前控制。
- en: The value function <math alttext="upper V a l u e left-parenthesis ModifyingAbove
    x With right-arrow left-parenthesis t Subscript i n i t i a l Baseline right-parenthesis
    comma t Subscript i n i t i a l Baseline comma t Subscript f i n a l Baseline
    right-parenthesis"><mrow><mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi>
    <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo>
    <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></math> is the minimal cost in a specific time period attained
    by enforcing the minimizing policy <math alttext="ModifyingAbove a With right-arrow
    Superscript asterisk Baseline left-parenthesis t right-parenthesis"><mrow><msup><mover
    accent="true"><mi>a</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></math> , which in turn specifies the state
    <math alttext="ModifyingAbove x With right-arrow Superscript asterisk Baseline
    left-parenthesis t right-parenthesis"><mrow><msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    using the information about dynamics of the system.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值函数 <math alttext="upper V a l u e left-parenthesis ModifyingAbove x With right-arrow
    left-parenthesis t Subscript i n i t i a l Baseline right-parenthesis comma t
    Subscript i n i t i a l Baseline comma t Subscript f i n a l Baseline right-parenthesis"><mrow><mi>V</mi>
    <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></math> 是通过实施最小化策略 <math alttext="ModifyingAbove a With right-arrow
    Superscript asterisk Baseline left-parenthesis t right-parenthesis"><mrow><msup><mover
    accent="true"><mi>a</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></math> 获得的特定时间段内的最小成本，该策略进一步指定了使用系统动态信息的状态
    <math alttext="ModifyingAbove x With right-arrow Superscript asterisk Baseline
    left-parenthesis t right-parenthesis"><mrow><msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>。
- en: Hamilton-Jacobi-Bellman PDE
  id: totrans-507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Hamilton-Jacobi-Bellman PDE
- en: 'These are the involved equations and formulas:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是涉及的方程和公式：
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column StartFraction
    d ModifyingAbove x left-parenthesis t right-parenthesis With right-arrow Over
    d t EndFraction equals ModifyingAbove f With right-arrow left-parenthesis ModifyingAbove
    x With right-arrow left-parenthesis t right-parenthesis comma ModifyingAbove a
    With right-arrow left-parenthesis t right-parenthesis comma t right-parenthesis
    2nd Row 1st Column Blank 2nd Column upper C o s t left-parenthesis ModifyingAbove
    x With right-arrow left-parenthesis t right-parenthesis comma ModifyingAbove a
    With right-arrow left-parenthesis t right-parenthesis comma t Subscript i n i
    t i a l Baseline comma t Subscript f i n a l Baseline right-parenthesis equals
    upper C o s t Subscript f i n a l Baseline left-parenthesis ModifyingAbove x With
    right-arrow left-parenthesis t Subscript f i n a l Baseline right-parenthesis
    comma t Subscript f i n a l Baseline right-parenthesis plus integral Subscript
    t Subscript i n i t i a l Baseline Superscript t Subscript f i n a l Baseline
    Baseline upper C o s t Subscript i n c r e m e n t a l Baseline left-parenthesis
    ModifyingAbove x With right-arrow left-parenthesis s right-parenthesis comma ModifyingAbove
    a With right-arrow left-parenthesis s right-parenthesis right-parenthesis d s
    3rd Row 1st Column Blank 2nd Column upper V a l u e left-parenthesis ModifyingAbove
    x With right-arrow left-parenthesis t Subscript i n i t i a l Baseline right-parenthesis
    comma t Subscript i n i t i a l Baseline comma t Subscript f i n a l Baseline
    right-parenthesis equals min Underscript ModifyingAbove a With right-arrow left-parenthesis
    t right-parenthesis Endscripts upper C o s t left-parenthesis ModifyingAbove x
    With right-arrow left-parenthesis t right-parenthesis comma ModifyingAbove a With
    right-arrow left-parenthesis t right-parenthesis comma t Subscript i n i t i a
    l Baseline comma t Subscript f i n a l Baseline right-parenthesis EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><mfrac><mrow><mi>d</mi><mover
    accent="true"><mrow><mi>x</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow> <mo>→</mo></mover></mrow>
    <mrow><mi>d</mi><mi>t</mi></mrow></mfrac> <mo>=</mo> <mover accent="true"><mi>f</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mover accent="true"><mi>a</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>t</mi>
    <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>C</mi>
    <mi>o</mi> <mi>s</mi> <mi>t</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mover
    accent="true"><mi>a</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>=</mo> <mi>C</mi> <mi>o</mi> <mi>s</mi> <msub><mi>t</mi>
    <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub> <mrow><mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mi>t</mi>
    <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub> <mo>)</mo></mrow>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub></mrow>
    <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub></msubsup>
    <mi>C</mi> <mi>o</mi> <mi>s</mi> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>c</mi><mi>r</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mover accent="true"><mi>a</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi>
    <mi>e</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>=</mo> <munder><mo form="prefix" movablelimits="true">min</mo>
    <mrow><mover accent="true"><mi>a</mi> <mo>→</mo></mover><mrow><mo>(</mo><mi>t</mi><mo>)</mo></mrow></mrow></munder>
    <mi>C</mi> <mi>o</mi> <mi>s</mi> <mi>t</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mover
    accent="true"><mi>a</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></mrow></mtd></mtr></mtable></math>
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column StartFraction
    d ModifyingAbove x left-parenthesis t right-parenthesis With right-arrow Over
    d t EndFraction equals ModifyingAbove f With right-arrow left-parenthesis ModifyingAbove
    x With right-arrow left-parenthesis t right-parenthesis comma ModifyingAbove a
    With right-arrow left-parenthesis t right-parenthesis comma t right-parenthesis
    2nd Row 1st Column Blank 2nd Column upper C o s t left-parenthesis ModifyingAbove
    x With right-arrow left-parenthesis t right-parenthesis comma ModifyingAbove a
    With right-arrow left-parenthesis t right-parenthesis comma t Subscript i n i
    t i a l Baseline comma t Subscript f i n a l Baseline right-parenthesis equals
    upper C o s t Subscript f i n a l Baseline left-parenthesis ModifyingAbove x With
    right-arrow left-parenthesis t Subscript f i n a l Baseline right-parenthesis
    comma t Subscript f i n a l Baseline right-parenthesis plus integral Subscript
    t Subscript i n i t i a l Baseline Superscript t Subscript f i n a l Baseline
    Baseline upper C o s t Subscript i n c r e m e n t a l Baseline left-parenthesis
    ModifyingAbove x With right-arrow left-parenthesis s right-parenthesis comma ModifyingAbove
    a With right-arrow left-parenthesis s right-parenthesis right-parenthesis d s
    3rd Row 1st Column Blank 2nd Column upper V a l u e left-parenthesis ModifyingAbove
    x With right-arrow left-parenthesis t Subscript i n i t i a l Baseline right-parenthesis
    comma t Subscript i n i t i a l Baseline comma t Subscript f i n a l Baseline
    right-parenthesis equals min Underscript ModifyingAbove a With right-arrow left-parenthesis
    t right-parenthesis Endscripts upper C o s t left-parenthesis ModifyingAbove x
    With right-arrow left-parenthesis t right-parenthesis comma ModifyingAbove a With
    right-arrow left-parenthesis t right-parenthesis comma t Subscript i n i t i a
    l Baseline comma t Subscript f i n a l Baseline right-parenthesis EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><mfrac><mrow><mi>d</mi><mover
    accent="true"><mrow><mi>x</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow> <mo>→</mo></mover></mrow>
    <mrow><mi>d</mi><mi>t</mi></mrow></mfrac> <mo>=</mo> <mover accent="true"><mi>f</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mover accent="true"><mi>a</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>t</mi>
    <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>C</mi>
    <mi>o</mi> <mi>s</mi> <mi>t</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mover
    accent="true"><mi>a</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>=</mo> <mi>C</mi> <mi>o</mi> <mi>s</mi> <msub><mi>t</mi>
    <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub> <mrow><mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mi>t</mi>
    <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub> <mo>)</mo></mrow>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub></mrow>
    <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub></msubsup>
    <mi>C</mi> <mi>o</mi> <mi>s</mi> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>c</mi><mi>r</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mover accent="true"><mi>a</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi>
    <mi>e</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>=</mo> <munder><mo form="prefix" movablelimits="true">min</mo>
    <mrow><mover accent="true"><mi>a</mi> <mo>→</mo></mover><mrow><mo>(</mo><mi>t</mi><mo>)</mo></mrow></mrow></munder>
    <mi>C</mi> <mi>o</mi> <mi>s</mi> <mi>t</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mover
    accent="true"><mi>a</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></mrow></mtd></mtr></mtable></math>
- en: 'Bellman’s optimality principle tells us something very valuable about the behavior
    of the value function (the optimal cost) along the special trajectory <math alttext="ModifyingAbove
    x With right-arrow Superscript asterisk Baseline left-parenthesis t right-parenthesis"><mrow><msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></math> corresponding to the optimizing policy
    <math alttext="ModifyingAbove a With right-arrow Superscript asterisk Baseline
    left-parenthesis t right-parenthesis"><mrow><msup><mover accent="true"><mi>a</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    : The value at a specified time interval is the sum of values if we break the
    time interval apart along the special trajectory <math alttext="ModifyingAbove
    x With right-arrow Superscript asterisk Baseline left-parenthesis t right-parenthesis"><mrow><msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></math> corresponding to the optimizing policy
    <math alttext="ModifyingAbove a With right-arrow Superscript asterisk Baseline
    left-parenthesis t right-parenthesis"><mrow><msup><mover accent="true"><mi>a</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    . This enables us to break up the optimization problem over a longer time interval
    into a recursion of optimization problems over much shorter time intervals:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 贝尔曼最优性原理告诉我们关于值函数（最优成本）在特殊轨迹 <math alttext="ModifyingAbove x With right-arrow
    Superscript asterisk Baseline left-parenthesis t right-parenthesis"><mrow><msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></math> 对应于优化策略 <math alttext="ModifyingAbove
    a With right-arrow Superscript asterisk Baseline left-parenthesis t right-parenthesis"><mrow><msup><mover
    accent="true"><mi>a</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></math> 的行为非常有价值：在指定时间间隔内的值是如果我们沿着特殊轨迹 <math
    alttext="ModifyingAbove x With right-arrow Superscript asterisk Baseline left-parenthesis
    t right-parenthesis"><mrow><msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>*</mo></msup> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    对应于优化策略 <math alttext="ModifyingAbove a With right-arrow Superscript asterisk
    Baseline left-parenthesis t right-parenthesis"><mrow><msup><mover accent="true"><mi>a</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    ，值的总和。这使我们能够将长时间间隔上的优化问题分解为在更短时间间隔上的优化问题的递归：
- en: <math alttext="dollar-sign upper V a l u e left-parenthesis ModifyingAbove x
    With right-arrow Superscript asterisk Baseline left-parenthesis t Subscript i
    n i t i a l Baseline right-parenthesis comma t Subscript i n i t i a l Baseline
    comma t Subscript f i n a l Baseline right-parenthesis equals upper V a l u e
    left-parenthesis ModifyingAbove x With right-arrow Superscript asterisk Baseline
    left-parenthesis t Subscript i n i t i a l Baseline right-parenthesis comma t
    Subscript i n i t i a l Baseline comma t Subscript i n t e r m e d i a t e Baseline
    right-parenthesis plus upper V a l u e left-parenthesis ModifyingAbove x With
    right-arrow Superscript asterisk Baseline left-parenthesis t Subscript i n t e
    r m e d i a t e Baseline right-parenthesis comma t Subscript i n t e r m e d i
    a t e Baseline comma t Subscript f i n a l Baseline right-parenthesis dollar-sign"><mrow><mi>V</mi>
    <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mrow><mo>(</mo> <msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>=</mo> <mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi>
    <mrow><mo>(</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup>
    <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>+</mo> <mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi>
    <mrow><mo>(</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup>
    <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></mrow></math>
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper V a l u e left-parenthesis ModifyingAbove x
    With right-arrow Superscript asterisk Baseline left-parenthesis t Subscript i
    n i t i a l Baseline right-parenthesis comma t Subscript i n i t i a l Baseline
    comma t Subscript f i n a l Baseline right-parenthesis equals upper V a l u e
    left-parenthesis ModifyingAbove x With right-arrow Superscript asterisk Baseline
    left-parenthesis t Subscript i n i t i a l Baseline right-parenthesis comma t
    Subscript i n i t i a l Baseline comma t Subscript i n t e r m e d i a t e Baseline
    right-parenthesis plus upper V a l u e left-parenthesis ModifyingAbove x With
    right-arrow Superscript asterisk Baseline left-parenthesis t Subscript i n t e
    r m e d i a t e Baseline right-parenthesis comma t Subscript i n t e r m e d i
    a t e Baseline comma t Subscript f i n a l Baseline right-parenthesis dollar-sign"><mrow><mi>V</mi>
    <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mrow><mo>(</mo> <msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>=</mo> <mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi>
    <mrow><mo>(</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup>
    <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>+</mo> <mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi>
    <mrow><mo>(</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup>
    <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></mrow></math>
- en: 'Using Bellman’s principle, we can derive the Hamilton-Jacobi-Bellman PDE that
    the value function satisfies. This PDE generalized an older Hamilton-Jacobi PDE
    for optimal control. The solution of this PDE contains very valuable information:
    Suppose we encounter the system at *any time t*, not only at its initial state
    <math alttext="t Subscript i n i t i a l"><msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub></math>
    , then we can compute the value function up to the desired final cost, by solving
    the Hamilton-Jacobi-Bellman equation:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 利用贝尔曼原理，我们可以推导出值函数满足的哈密尔顿-雅可比-贝尔曼PDE。这个PDE推广了一个旧的用于最优控制的哈密尔顿-雅可比PDE。这个PDE的解包含非常有价值的信息：假设我们在*任何时间
    t* 遇到系统，不仅仅是在其初始状态 <math alttext="t Subscript i n i t i a l"><msub><mi>t</mi>
    <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub></math>，那么我们可以通过解哈密尔顿-雅可比-贝尔曼方程计算值函数直到期望的最终成本。
- en: <math alttext="dollar-sign minus StartFraction normal partial-differential upper
    V a l u e Over normal partial-differential t EndFraction equals min Underscript
    ModifyingAbove a With right-arrow left-parenthesis t right-parenthesis Endscripts
    left-parenthesis left-parenthesis StartFraction normal partial-differential upper
    V a l u e Over normal partial-differential ModifyingAbove x With right-arrow EndFraction
    right-parenthesis Superscript upper T Baseline ModifyingAbove f With right-arrow
    left-parenthesis ModifyingAbove x With right-arrow left-parenthesis t right-parenthesis
    comma ModifyingAbove a With right-arrow left-parenthesis t right-parenthesis right-parenthesis
    plus upper C o s t Subscript i n c r e m e n t a l Baseline left-parenthesis ModifyingAbove
    x With right-arrow left-parenthesis t right-parenthesis comma ModifyingAbove a
    With right-arrow left-parenthesis t right-parenthesis right-parenthesis right-parenthesis
    dollar-sign"><mrow><mo>-</mo> <mfrac><mrow><mi>∂</mi><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow>
    <mrow><mi>∂</mi><mi>t</mi></mrow></mfrac> <mo>=</mo> <msub><mo form="prefix" movablelimits="true">min</mo>
    <mrow><mover accent="true"><mi>a</mi> <mo>→</mo></mover><mrow><mo>(</mo><mi>t</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>(</mo> <msup><mrow><mo>(</mo><mfrac><mrow><mi>∂</mi><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow>
    <mrow><mi>∂</mi><mover accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></mfrac><mo>)</mo></mrow>
    <mi>T</mi></msup> <mover accent="true"><mi>f</mi> <mo>→</mo></mover> <mrow><mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>,</mo> <mover accent="true"><mi>a</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>+</mo> <mi>C</mi>
    <mi>o</mi> <mi>s</mi> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>c</mi><mi>r</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mover accent="true"><mi>a</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign minus StartFraction normal partial-differential upper
    V a l u e Over normal partial-differential t EndFraction equals min Underscript
    ModifyingAbove a With right-arrow left-parenthesis t right-parenthesis Endscripts
    left-parenthesis left-parenthesis StartFraction normal partial-differential upper
    V a l u e Over normal partial-differential ModifyingAbove x With right-arrow EndFraction
    right-parenthesis Superscript upper T Baseline ModifyingAbove f With right-arrow
    left-parenthesis ModifyingAbove x With right-arrow left-parenthesis t right-parenthesis
    comma ModifyingAbove a With right-arrow left-parenthesis t right-parenthesis right-parenthesis
    plus upper C o s t Subscript i n c r e m e n t a l Baseline left-parenthesis ModifyingAbove
    x With right-arrow left-parenthesis t right-parenthesis comma ModifyingAbove a
    With right-arrow left-parenthesis t right-parenthesis right-parenthesis right-parenthesis
    dollar-sign"><mrow><mo>-</mo> <mfrac><mrow><mi>∂</mi><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow>
    <mrow><mi>∂</mi><mi>t</mi></mrow></mfrac> <mo>=</mo> <msub><mo form="prefix" movablelimits="true">min</mo>
    <mrow><mover accent="true"><mi>a</mi> <mo>→</mo></mover><mrow><mo>(</mo><mi>t</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>(</mo> <msup><mrow><mo>(</mo><mfrac><mrow><mi>∂</mi><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow>
    <mrow><mi>∂</mi><mover accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></mfrac><mo>)</mo></mrow>
    <mi>T</mi></msup> <mover accent="true"><mi>f</mi> <mo>→</mo></mover> <mrow><mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>,</mo> <mover accent="true"><mi>a</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>+</mo> <mi>C</mi>
    <mi>o</mi> <mi>s</mi> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>c</mi><mi>r</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mover accent="true"><mi>a</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
- en: 'subject to final time condition:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 根据最终时间条件：
- en: <math alttext="dollar-sign upper V a l u e left-parenthesis ModifyingAbove x
    With right-arrow left-parenthesis t Subscript f i n a l Baseline right-parenthesis
    comma t Subscript f i n a l Baseline right-parenthesis equals upper C o s t Subscript
    f i n a l Baseline left-parenthesis ModifyingAbove x With right-arrow left-parenthesis
    t Subscript f i n a l Baseline right-parenthesis comma t Subscript f i n a l Baseline
    right-parenthesis dollar-sign"><mrow><mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi>
    <mi>e</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>=</mo> <mi>C</mi> <mi>o</mi> <mi>s</mi> <msub><mi>t</mi>
    <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub> <mrow><mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mi>t</mi>
    <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub> <mo>)</mo></mrow>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></mrow></math>
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="dollar-sign upper V a l u e left-parenthesis ModifyingAbove x
    With right-arrow left-parenthesis t Subscript f i n a l Baseline right-parenthesis
    comma t Subscript f i n a l Baseline right-parenthesis equals upper C o s t Subscript
    f i n a l Baseline left-parenthesis ModifyingAbove x With right-arrow left-parenthesis
    t Subscript f i n a l Baseline right-parenthesis comma t Subscript f i n a l Baseline
    right-parenthesis dollar-sign"><mrow><mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi>
    <mi>e</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>=</mo> <mi>C</mi> <mi>o</mi> <mi>s</mi> <msub><mi>t</mi>
    <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub> <mrow><mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mi>t</mi>
    <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub> <mo>)</mo></mrow>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></mrow></math>
- en: This is a first order PDE for the value function <math alttext="upper V a l
    u e left-parenthesis ModifyingAbove x With right-arrow left-parenthesis t right-parenthesis
    comma t comma t Subscript f i n a l Baseline right-parenthesis"><mrow><mi>V</mi>
    <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>t</mi>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></math> . Again, this is the optimal cost incurred from starting
    in state <math alttext="ModifyingAbove x With right-arrow left-parenthesis t right-parenthesis"><mrow><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    at time *t* and controlling the system optimally from then until time <math alttext="t
    Subscript f i n a l"><msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub></math>
    . We know the final value function at <math alttext="t Subscript f i n a l"><msub><mi>t</mi>
    <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub></math>
    , and we are looking for value function at time *t*, namely, <math alttext="upper
    V a l u e left-parenthesis ModifyingAbove x With right-arrow left-parenthesis
    t right-parenthesis right-parenthesis"><mrow><mi>V</mi> <mi>a</mi> <mi>l</mi>
    <mi>u</mi> <mi>e</mi> <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow></math> . So we
    solve the PDE *backwards in time*, starting at <math alttext="t Subscript f i
    n a l"><msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub></math>
    and ending at <math alttext="t Subscript i n i t i a l"><msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub></math>
    .
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这是值函数<math alttext="upper V a l u e left-parenthesis ModifyingAbove x With right-arrow
    left-parenthesis t right-parenthesis comma t comma t Subscript f i n a l Baseline
    right-parenthesis"><mrow><mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi>
    <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>t</mi> <mo>,</mo> <msub><mi>t</mi>
    <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub> <mo>)</mo></mrow></math>的一阶PDE。同样，这是从时间*t*开始在状态<math
    alttext="ModifyingAbove x With right-arrow left-parenthesis t right-parenthesis"><mrow><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>控制系统的最优成本，直到时间<math
    alttext="t Subscript f i n a l"><msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub></math>。我们知道在<math
    alttext="t Subscript f i n a l"><msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub></math>时的最终值函数，我们正在寻找时间*t*时的值函数，即<math
    alttext="upper V a l u e left-parenthesis ModifyingAbove x With right-arrow left-parenthesis
    t right-parenthesis right-parenthesis"><mrow><mi>V</mi> <mi>a</mi> <mi>l</mi>
    <mi>u</mi> <mi>e</mi> <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow></math>。因此，我们*逆向解决*这个PDE，从<math
    alttext="t Subscript f i n a l"><msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub></math>开始，直到<math
    alttext="t Subscript i n i t i a l"><msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub></math>结束。
- en: Solving the Hamilton-Jacobi-Bellman PDE
  id: totrans-517
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决哈密尔顿-雅可比-贝尔曼PDE
- en: If we are able solve the Hamilton Jacobi Bellman PDE for the value function,
    then we know the optimal control <math alttext="ModifyingAbove a With right-arrow
    Superscript asterisk Baseline left-parenthesis t right-parenthesis"><mrow><msup><mover
    accent="true"><mi>a</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></math> , which in turn produces the least
    costly (or most rewarding) trajectory <math alttext="ModifyingAbove x With right-arrow
    Superscript asterisk Baseline left-parenthesis t right-parenthesis"><mrow><msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></math> from our current state <math alttext="ModifyingAbove
    x With right-arrow Superscript asterisk Baseline left-parenthesis t Subscript
    i n i t i a l Baseline right-parenthesis"><mrow><msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></mrow></math> to the final desired state <math alttext="ModifyingAbove
    x With right-arrow Superscript asterisk Baseline left-parenthesis t Subscript
    f i n a l Baseline right-parenthesis"><mrow><msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></mrow></math> .
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够解决哈密尔顿-雅可比-贝尔曼偏微分方程，那么我们就知道最优控制<math alttext="ModifyingAbove a With right-arrow
    Superscript asterisk Baseline left-parenthesis t right-parenthesis"><mrow><msup><mover
    accent="true"><mi>a</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></math>，这将产生从当前状态<math alttext="ModifyingAbove
    x With right-arrow Superscript asterisk Baseline left-parenthesis t Subscript
    i n i t i a l Baseline right-parenthesis"><mrow><msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></mrow></math>到最终期望状态<math alttext="ModifyingAbove x With right-arrow
    Superscript asterisk Baseline left-parenthesis t Subscript f i n a l Baseline
    right-parenthesis"><mrow><msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>*</mo></msup> <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></mrow></math>的最少成本（或最有益）轨迹。
- en: The Hamilton-Jacobi-Bellman PDE does not in general have a smooth solution,
    so we must satisfy ourselves with *weak* or *generalized* solutions. This is a
    common theme for many PDEs, and a person studying PDE theory focuses almost exclusively
    on developing generalized solutions and understanding the function spaces that
    they live in (Sobolov spaces *et al*). Classic examples of generalized solutions
    for the Hamilton Jacobi Bellman PDE, which we only mention without elaboration,
    include viscosity solutions and minimax solutions.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 汉密尔顿-雅可比-贝尔曼PDE通常没有平滑解，因此我们必须满足于*弱*或*广义*解。这是许多PDE的共同主题，研究PDE理论的人几乎专注于发展广义解并理解它们存在的函数空间（如Sobolov空间等）。汉密尔顿雅可比贝尔曼PDE的广义解的经典例子，我们只是简单提及而不详细解释，包括粘性解和极小极大解。
- en: What AI contributes to the vast literature on the Hamilton-Jacobi-Bellman equation
    is numerically solving it in very high dimensions, as in hundreds or thousands.
    The value function is a function of the state vector <math alttext="ModifyingAbove
    x With right-arrow left-parenthesis t right-parenthesis"><mrow><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    of the underlying assets or contributing agents, and if there are many of these,
    then the PDE is very high dimensional. The paper we referenced earlier, [*Solving
    High Dimensional PDEs Using Deep Learning*](https://www.pnas.org/doi/epdf/10.1073/pnas.1718942115),
    addresses numerical solutions of the Hamilton-Jacobi-Bellman equation, in addition
    to other important and widely impactful high dimensional PDEs.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能对汉密尔顿-雅可比-贝尔曼方程的广泛文献做出的贡献是在非常高维度中进行数值求解，如数百或数千维。价值函数是基础资产或贡献代理的状态向量<math
    alttext="ModifyingAbove x With right-arrow left-parenthesis t right-parenthesis"><mrow><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>的函数，如果这些很多，那么PDE就是非常高维的。我们之前引用的论文[*使用深度学习解决高维PDE*](https://www.pnas.org/doi/epdf/10.1073/pnas.1718942115)，讨论了汉密尔顿-雅可比-贝尔曼方程的数值解，以及其他重要且具有广泛影响的高维PDE。
- en: The term *Hopf formulas* is usually associated with solutions of Hamilton-Jacobi
    PDEs. For a class of inviscid Hamilton–Jacobi type PDEs, Darbon and Osher [Algorithms
    for Overcoming the Curse of Dimensionality for Certain Hamilton-Jacobi Equations
    Arising in Control Theory and Elsewhere (2016)](https://arxiv.org/abs/1605.01799)
    developed an effective algorithm for high dimensional Hamilton-Jacobi PDEs, based
    on the Hopf formulas.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*Hopf formulas*通常与汉密尔顿-雅可比PDE的解相关联。对于一类无粘汉密尔顿-雅可比类型PDE，Darbon和Osher [克服控制理论和其他领域中某些汉密尔顿-雅可比方程维度诅咒的算法（2016）](https://arxiv.org/abs/1605.01799)
    基于Hopf formulas开发了一种高维汉密尔顿-雅可比PDE的有效算法。
- en: Dynamic programming and Reinforcement Learning
  id: totrans-522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态规划和强化学习
- en: Using neural networks to learn optimal strategies for dynamic programming is
    called reinforcement learning in some circles and *neuro-dynamic programming*
    in others. The neural network, and the machine endowed with it, learns to anticipate
    how current and future actions affect a long-term cumulative cost or reward, the
    value of that time period. How do our current and daily investment strategies
    affect our annual performance? How do our first and subsequent chess moves affect
    the overall outcome of the game? The value function is the total of costs and
    rewards corresponding to following the optimal strategies at each (discrete or
    continuum) step of time.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些领域中，使用神经网络学习动态规划的最佳策略被称为强化学习，而在其他领域中被称为*神经动态规划*。神经网络和搭载它的机器学会预测当前和未来的动作如何影响长期累积成本或奖励，即该时间段的价值。我们当前和每日的投资策略如何影响我们的年度表现？我们的第一步和随后的国际象棋走法如何影响游戏的整体结果？价值函数是遵循每个（离散或连续）时间步骤的最佳策略所对应的成本和奖励的总和。
- en: 'The neural network needs inputs and outputs during training with historical
    data. The inputs are the state and all the potential actions that are allowed
    at that state, and the output is the value (the total costs and rewards). After
    training, for example, for a business model that is strategizing on how to address
    each customer, the neural network learns to take the customer’s state as input,
    and outputs the next sequence of actions so as to maximize long term value. Check
    [Neurodynamic programming (1996)](http://athenasc.com/ndpbook.xhtml) D. P. Bertsekas
    and J. N. Tsitsiklis for an older but thorough explanation of neuro-dynamic programming
    and the use of artificial neural networks for approximating the value function
    in Bellman’s equation. This is great for reducing the effects of the curse dimensionality:
    Instead of storing and evaluating the whole high dimensional functions, we only
    need to store the parameters of the neural network.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络在训练过程中需要历史数据的输入和输出。输入是状态和该状态下允许的所有潜在动作，输出是价值（总成本和奖励）。训练后，例如对于一个正在制定如何处理每个客户的业务模型，神经网络学会将客户的状态作为输入，并输出下一个动作序列，以最大化长期价值。查看[神经动态规划（1996）](http://athenasc.com/ndpbook.xhtml)
    D. P. Bertsekas和J. N. Tsitsiklis，了解神经动态规划和利用人工神经网络逼近贝尔曼方程中价值函数的更早但全面的解释。这对于减少维度的影响非常有用：我们不需要存储和评估整个高维函数，只需要存储神经网络的参数。
- en: PDEs For AI?
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AI的PDE？
- en: The previous section highlighted the fact that dynamic programming and the Bellman
    equation are highly intertwined with AI’s reinforcement learning.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节强调了动态规划和贝尔曼方程与人工智能的强化学习密切相关。
- en: Moreover, the field of PDEs has an arsenal of analysis behind it, studying all
    kinds of functions, the spaces they live in, weak and strong solutions, and all
    kinds of convergence in all kinds of senses. If any field has the tools to unlock
    the secrets behind the success of neural networks in approximating many data generating
    processes, whether joint probability distributions or deterministic function,
    it would be the field of PDEs. We need to back neural networks with theorems and
    the mathematical rigor that eventually help with their design and architecture
    optimization. Neural network’s magical abilities need to be under the lens of
    analysis, and tools from the analysis of PDEs and their solutions are one promising
    way forward. Examples include Sobolev training (Czarnecki, Osindero, Jaderberg,
    Swirszcz, Pascanu; 2017) (add examples)
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，PDE领域有一整套分析工具，研究各种函数、它们所在的空间、弱解和强解，以及各种意义上的收敛。如果有任何领域有能力解锁神经网络在近似许多数据生成过程中的成功秘密，无论是联合概率分布还是确定性函数，那将是PDE领域。我们需要用定理和最终有助于设计和架构优化的数学严谨来支持神经网络。神经网络的神奇能力需要在分析的镜头下，以及来自PDE及其解的分析工具，是前进的一种有希望的方式。例如，Sobolev训练（Czarnecki，Osindero，Jaderberg，Swirszcz，Pascanu；2017）（添加示例）
- en: Other Considerations In Partial Differential Equations
  id: totrans-528
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在偏微分方程中的其他考虑
- en: 'For most of the time we stayed away from the famous partial differential equations
    while highlighting the themes of this chapter, so as to stress the fact these
    themes apply to much more than the well studied differential equations and applications.
    Undergraduate courses primarily address linear PDEs involving only functions of
    two variables (x,y) or (x,t). Students are left either misled, thinking that is
    all what matters, or wondering: What about nonlinear PDEs? And all the high dimensional
    applications? Systems of PDEs? These courses also tend to focus on the heat equation
    (parabolic), wave equation (hyperbolic), Laplace equation (elliptic), and some
    numerical solutions and simulations (finite differences, finite elements, and
    Monte Carlo). These are presented in their simplest forms: Linear, one, two, or
    three dimensional, defined on domains with regular geometries, giving undergraduate
    students the false impression that these PDEs are the base for all equations that
    might appear in applications. They also provide an artificial division between
    *types* of equations: Elliptical, parabolic, and hyperbolic, as if there is a
    complete theory that encompasses each type. Analytical solution methods are narrow,
    focusing only on the principle of superposition of simple solutions (because of
    linearity), which leads to Fourier series and transforms (this is in fact a very
    good thing). Neural networks broaden the scope, in the sense of approximating
    solutions of nonlinear equations using compositions of simple functions as opposed
    to additions.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在强调本章主题时，我们大多数时间都远离了著名的偏微分方程，以强调这些主题适用于远不止研究过的微分方程和应用。本科课程主要涉及仅涉及两个变量（x，y）或（x，t）的函数的线性PDE。学生们要么被误导，认为这就是所有重要的内容，要么感到困惑：非线性PDE呢？以及所有高维应用呢？PDE系统呢？这些课程还倾向于专注于热方程（抛物线）、波动方程（双曲线）、拉普拉斯方程（椭圆）以及一些数值解和模拟（有限差分、有限元和蒙特卡洛）。这些以最简单的形式呈现：线性的、一维、二维或三维的，在具有规则几何形状的域上定义，给本科生们一种错误的印象，即这些PDE是可能出现在应用中的所有方程的基础。它们还在*类型*之间提供了人为的区分：椭圆型、抛物型和双曲型，好像有一个完整的理论包括每种类型。分析解方法是狭窄的，仅关注简单解的叠加原理（由于线性性），这导致了傅立叶级数和变换（实际上这是一件非常好的事情）。神经网络扩大了范围，以近似使用简单函数的组合而不是加法来解非线性方程。
- en: 'The way undergraduate PDE courses are set up are all wonderful, but they do
    not truly reflect the reality of PDEs: Not theoretically, not numerically, not
    even their wide applicability. Students graduate feeling that given a brand new
    PDE, they have no idea what to do with it, because it doesn’t fit anything that
    they learned in an introductory PDE class (I can tell you what to first do with
    it, of course after googling it: Discretize it and simulate it; this will give
    you tremendous insight into the behavior of its solution).'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 本科PDE课程的设置都很好，但它们并没有真正反映PDE的现实：不是在理论上，也不是在数值上，甚至不是在它们的广泛适用性上。学生毕业时会感到，如果给他们一个全新的PDE，他们不知道该怎么处理，因为它与他们在入门PDE课程中学到的任何内容都不匹配（我可以告诉你首先要做什么，当然是在谷歌搜索之后：离散化并模拟它；这将让你对其解的行为有深刻的了解）。
- en: That said, there are general ways of thinking about putting the PDEs together
    (modeling), which is almost always related to some conservation laws from physics,
    and going about their analysis (theory- existence, uniqueness, and sensitivity
    analysis of solutions and *weak solutions*), and finding the actual solutions
    analytically or numerically (representation formulas, green’s functions, transform
    methods, and numerics).
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，有一些一般的思考方式可以将PDEs（偏微分方程）组合在一起（建模），这几乎总是与物理学中的一些守恒定律相关，并且进行它们的分析（理论-解的存在性、唯一性和敏感性分析以及*弱解*），并找到实际的解析或数值解（表示公式、格林函数、变换方法和数值解）。
- en: 'For starters, each area of study has its own differential equations that model
    the phenomena that it cares for, for example:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，每个研究领域都有自己的微分方程，用于模拟其关心的现象，例如：
- en: In fluid dynamics, we study Navier Stokes equations (among others). This is
    a nonlinear system of PDEs. Navier Stokes PDEs take into account the velocity
    of the fluid, pressure, density, stresses, compressibility, and the forces acting
    on it. The equation expresses the conservation of mass and conservation of momentum
    The solution of the equation describes the motion of the viscous fluid
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在流体动力学中，我们研究纳维-斯托克斯方程（以及其他方程）。这是一个非线性的PDE系统。纳维-斯托克斯PDE考虑了流体的速度、压力、密度、应力、可压缩性以及作用在其上的力。该方程表达了质量守恒和动量守恒。方程的解描述了粘性流体的运动。
- en: In economics and finance, we study the Black Scholes equation (among others).
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在经济和金融领域，我们研究布莱克-斯科尔斯方程（以及其他方程）。
- en: In population dynamics, we study the Lotka Volterra predator prey equations
    (among others).
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在人口动态学中，我们研究洛特卡-沃尔特拉捕食者-猎物方程（以及其他方程）。
- en: In general relativity, we study the Einestein field equations (among others).
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在广义相对论中，我们研究爱因斯坦场方程（以及其他方程）。
- en: 'When PDEs model phenomena that evolve with time, there could be higher driver
    of the evolution, which provide more insight into the PDE solution and its properties:
    A tendency to decrease an energy. Mathematically, the *derivative* of an energy
    functional is negative when evaluated at the solution of the PDE. We learn a lot
    of math understanding these energy functionals, their *derivatives*, and the function
    spaces they act on. We use a lot of relatively easy *energy estimates* to prove
    existence of solutions to various nonlinear PDE. The correct setting to study
    PDEs via energy methods is *Sobolov function spaces*. The calculus of variations
    is concerned with the maxima or minima (collectively called extrema) of energy
    functionals. It is fundamental for the theory of nonlinear PDEs. PDEs that appear
    as minimizers of energy functionals are called *Euler Lagrange equation*.'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 当偏微分方程模拟随时间演化的现象时，可能会有更高级的演化驱动因素，这些因素可以更深入地了解偏微分方程解及其性质：倾向于减少能量。在数学上，当在PDE的解处评估能量泛函的*导数*时，结果为负数。通过理解这些能量泛函、它们的*导数*以及它们作用的函数空间，我们学到了很多数学知识。我们使用许多相对容易的*能量估计*来证明各种非线性PDE的解的存在性。通过能量方法研究PDE的正确设置是*Sobolov函数空间*。变分法关注能量泛函的最大值或最小值（统称为极值）。这对于非线性PDE的理论是基础的。作为能量泛函的极小值出现的PDE被称为*欧拉-拉格朗日方程*。
- en: Summary And Looking Ahead
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结和展望
- en: This chapter introduced us to PDEs as they relate to AI. PDEs have an unparalleled
    ability to model natural and social phenomena. Unlocking their solutions opens
    up many possibilities for many fields. We highlighted many of the difficulties
    obtaining these solutions, such as the curse of dimensionality, mesh generation,
    noisy data, and how AI helps address those.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章向我们介绍了PDE与人工智能的关系。PDE具有无与伦比的能力来模拟自然和社会现象。解开它们的解决方案为许多领域打开了许多可能性。我们强调了许多获得这些解决方案的困难，如维度诅咒、网格生成、嘈杂数据，以及AI如何帮助解决这些问题。
- en: There is much more work to be done. For developing physics informed intelligent
    machines, we need to build new frameworks, data sets, standardized benchmarks,
    and new rigorous mathematics for scalable and robust systems.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多工作要做。为了开发物理信息智能机器，我们需要建立新的框架、数据集、标准化基准和可扩展和稳健系统的新严格数学。
- en: There are many important PDE topics that we did not touch on, such as ill-posed
    inverse problems, where we need to learn the PDE’s parameters or initial data
    from partially or fully observing its solution. Physics informed neural networks
    are effective and efficient for these kinds of problems.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多重要的PDE主题我们没有涉及，比如不适定的反问题，我们需要从部分或完全观察其解中学习PDE的参数或初始数据。物理信息神经网络对于这类问题非常有效和高效。
- en: In the context of the Hamilton Jacobi Bellman equation, we mentioned viscosity
    solutions and Hopf Lax formulas only casually. In the context of existence methods
    for PDEs, other than the fixed point iteration, there are minimax methods for
    certain PDE types. For example, we did not mention monotinicity or the maximum
    principle for elliptic and parabolic PDEs.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在哈密顿-雅可比-贝尔曼方程的背景下，我们只是随意提到了粘性解和霍普夫-拉克斯公式。在PDE的存在性方法方面，除了固定点迭代外，还有某些PDE类型的极小极大方法。例如，我们没有提到椭圆和抛物线PDE的单调性或最大值原理。
- en: 'We leave this chapter with a question to ponder: *Will PDEs advance us towards
    more intelligent agents?* and with [the 2021 article](https://www.brown.edu/research/projects/crunch/sites/brown.edu.research.projects.crunch/files/uploads/Nature-REviews_GK.pdf),
    where the authors make the case for *Physics Informed Machine Learning (2021)*,
    where we merge neural networks with physical laws, in order to leverage the best
    of both worlds, and minitgate the lack of large data sets, or noisy data, in many
    scientific settings. The following is a quote from the article: *Such networks
    can be trained from additional information obtained by enforcing the physical
    laws (for example, at random points in the continuous space-time domain). Such
    physics-informed learning integrates (noisy) data and mathematical models, and
    implements them through neural networks or other kernel based regression networks.
    Moreover, it may be possible to design specialized network architectures that
    automatically satisfy some of the physical invariants for better accuracy, faster
    training and improved generalization.*'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这一章节中留下一个思考的问题：*PDE是否会推动我们朝着更智能的代理前进？*以及[这篇2021年的文章](https://www.brown.edu/research/projects/crunch/sites/brown.edu.research.projects.crunch/files/uploads/Nature-REviews_GK.pdf)，在这篇文章中，作者们提出了*物理信息机器学习（2021年）*的观点，我们将神经网络与物理定律相结合，以利用两者的优势，并在许多科学环境中弥补大数据集或嘈杂数据的缺失。以下是文章中的一句引用：*这样的网络可以通过强制执行物理定律（例如，在连续时空域的随机点）获得额外信息进行训练。这种物理信息学习通过神经网络或其他基于核的回归网络集成（嘈杂）数据和数学模型，并通过它们实现。此外，可能可以设计专门的网络架构，以自动满足一些物理不变量，以获得更好的准确性、更快的训练和改进的泛化能力。*
