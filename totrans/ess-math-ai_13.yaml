- en: Chapter 13\. Artificial Intelligence and Partial Differential Equations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first scene in Top Gun Maverick (2022 movie) shows Maverick (Tom Cruise)
    manning an experimental military aircraft and pushing it to 10 times the speed
    of sound (10 Mach) before losing its stability at around 10.2 Mach. The fastest
    nonfictional manned aircraft so far can reach 6.7 Mach ([Figure 13-1](#Fig_fastest_aircraft)).
    Real speed or unreal (yet), it is mesmerizing to watch physics, math, and engineering
    come together to put these planes in the air, especially with their spectacular
    midair manoeuvering. These are few of the partial differential equations (PDEs)
    that come to mind while watching Maverick’s awesome dogfight and 10 Mach scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![250](assets/emai_1301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-1\. Fastest manned aircrafts ever made ([*image source*](https://migflug.com/jetflights/the-10-fastest-aircraft-in-the-world/)
    or need an uncopy righted image similar to this one)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**The wave equation for wave propagation**: Think of the speed of sound, the
    propagation of a sound wave in the air, and the variations of the sound of speed
    at different altitudes due to the variations in the temperature and density of
    air.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Navier Stokes equations for fluid dynamics**: Think of the fluid flow, air
    tunnels, and turbulence.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The G-equation for combustion**: Think of the combustion in the aircraft’s
    engine and the flames coming out of the aircraft’s exhausts.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Material elasticity equations**: Think of the aircraft wing panel, the lift
    force, the buckling of the wing panel (the process of out-of-stress-plane movement
    which happens under compression [Figure 13-2](#Fig_buckling)) caused by loading,
    which in turn reduces the load carrying capabilities of the wing. When load carrying
    capabilities fall below the design limits, failure happens.'
  prefs: []
  type: TYPE_NORMAL
- en: '![250](assets/emai_1302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-2\. Buckling in an aircraft ([*imagesource*](https://c1.staticflickr.com/8/7605/27273400154_3fa64e11bd_b.jpg)).
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'PDE simulations also come to mind: Think of the flight path simulation and
    the crew chatting with Maverick as they watch his flight unfold in real time on
    their computer screens.'
  prefs: []
  type: TYPE_NORMAL
- en: The list goes on. Are we claiming here that we made aircrafts fly because we
    wrote down and solved PDEs? No. Aviation museums tell the story of the Wright
    Brothers, *their experiments*, and the evolution of aviation industry. Science
    and experimentation go hand in hand. What we want to claim instead is that we
    can invent, improve, and optimize all kinds of designs because of differential
    equations and math.
  prefs: []
  type: TYPE_NORMAL
- en: What Is A Partial Differential Equation?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A PDE is an equation, which means a left hand side equals to a right hand side,
    that involves a function of several variables along with any of its partial derivatives.
    A partial derivative of a function with respect to a certain variable measures
    the rate of change of the function with respect to that variable. Ordinary differential
    equations (ODEs) are those that involve functions of only one variable, such as
    only time, only space, etc… (as opposed to several variables) and their derivatives.
    A dynamic system is a greatly important ODE, describing the evolution in time
    of the state of a system that we care for, such as a system of particles, or the
    state of a customer in a business setting. The ODE involves one derivative in
    time of the state of the system, and the dynamics are prescribed as a function
    of the system state, system physical parameters, and time. The ODE looks like
    <math alttext="StartFraction d ModifyingAbove x With right-arrow left-parenthesis
    t right-parenthesis Over d t EndFraction equals f left-parenthesis ModifyingAbove
    x With right-arrow left-parenthesis t right-parenthesis comma a left-parenthesis
    t right-parenthesis comma t right-parenthesis"><mrow><mfrac><mrow><mi>d</mi><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover><mrow><mo>(</mo><mi>t</mi><mo>)</mo></mrow></mrow>
    <mrow><mi>d</mi><mi>t</mi></mrow></mfrac> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math> . We will visit dynamic
    systems multiple times in this chapter. Most of the time, if we able to transform
    a PDE into a system of ODEs, or maybe into a dynamical system, it is more or less
    solved.
  prefs: []
  type: TYPE_NORMAL
- en: Nature gave us neither the deterministic functions nor the joint probability
    distributions that it uses to produce the world that we observe around us and
    can accurately measure. Until now, it has kept those secret. It did, however,
    give us ways to measure, assess, or make laws about *how things change* relative
    to each other, which is exactly what partial differential equations represent.
    Because *how things change* are nothing but derivatives.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of solving a PDE is to undo the differential operator so that we can
    recover the function without any derivatives. So we search for an exact or an
    approximate inverse (or pseudo inverse) of the differential operator that the
    PDE represents. Integrals undo derivatives so solution represenations of PDEs
    often involve the integrals of some kernel functions against the input data of
    a PDE (its parameters, initial and/or boundary conditions). We will elaborate
    on this as the chapter evolves.
  prefs: []
  type: TYPE_NORMAL
- en: People usually classify ODEs and PDEs into *types*. My take on this is that
    we should not confuse ourselves with *classifications* unless we happen to be
    personally working with these special ODEs or PDEs and the solutions of these
    happen to have a direct and immediate impact on the future of humanity. When in
    this chapter you encounter a certain type, such as nonlinear parabolic, or backward
    stochastic, accept the name then move directly to understanding the point that
    I am trying to make. Don’t even try to google these terms. It will be similar
    to when you google your symptoms and the internet tells you that you will die
    tomorrow. Consider yourself warned.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling With Differential Equations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Differential equations model countless phenomena in the real world, from air
    turbulence to the motions of galaxies to the behavior of materials at the nanoscale
    to pricing financial instruments to games with adversaries and multiple players
    to population mobility and growth. Typical courses on PDEs skip the modeling step,
    so the PDEs that we end up studying seem to come out of the blue, but that is
    not the case. Where PDEs come from is as important as trying to analyze them and
    solve them. Usually PDEs express some conservation laws, such as conservation
    of energy, mass, momentum, *etc.*, as they relate to our particular application.
    Many PDEs are an expression of a conservation statement that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '*rate of change of a quantity in time= gains- losses*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when we have a bounded domain, the PDE works in the *interior* of the domain,
    but we need to accompany it with *boundary conditions* that tell us exactly what
    is happening at the boundary of the domain. If the domain is unbounded, then we
    need *far field conditions* that tell us what is happening as <math alttext="x
    right-arrow normal infinity"><mrow><mi>x</mi> <mo>→</mo> <mi>∞</mi></mrow></math>
    . We write these conditions using limits notation. If the PDE has derivatives
    in time then we need some initial time conditions, or end time conditions. How
    many of these conditions we need depends on the order of the PDE. Think of these
    as how many equations we need to solve for how many unknowns. The unknowns are
    the *integration constants* of the PDEs. When we solve a PDE, we seek information
    about the function given information about its derivatives. To get rid of these
    derivatives and recover the function, we must *integrate* the PDE, getting integration
    constants along the way. We need the boundary and/or far field conditions to solve
    for these constants.
  prefs: []
  type: TYPE_NORMAL
- en: Models At Different Scales
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Realistic models that mimic nature faithfully need to account for all the important
    variables along with their interactions, sometimes at varying scales of space
    and time. There is some work that goes into writing the equations for the mathematical
    models. Once formulated, they are elegant, condensing a whole wealth of information
    into few lines of equations. These equations involve functions, their derivatives,
    and the model’s parameters, and are usually harder to solve than to formulate.
    Moreover, if two models describe the same phenomenon at different scales, say
    one on the atomistic scale (rapidly wiggling molecules) and another at a bigger
    scale, say at the microscopic or at the macro scales (the one we observe), then
    the two models’ equations would look very different, and they may even be relying
    on physical laws from different fields of science. Think for example about describing
    the motion of gases at the molecular level (particle velocity, position, forces
    acting on it, *etc.*) and how to relate that to the thermodynamics of the gaseous
    system observed at the macroscopic scale. Or think of the ways atoms bond together
    to form crystalline structures, and how those structures translate into material
    properties such as conductivity, permeability, brittleness, *etc.*. The natural
    question is then, can we reconcile such models when each operates and is succesfull
    to some degree at a different scale? More precisely, if we take the limit of one
    model to the regime of the other, would we get the same thing? These are all the
    types of questions that analysts address. Reconciling different scale models validates
    them and unifies different areas of math and science.
  prefs: []
  type: TYPE_NORMAL
- en: The Parameters of a PDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The PDEs that we write down for a model usually involve parameters. These parameters
    have to do with the properties of the physical system that we are modeling. For
    example, for the heat equation
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign u Subscript t Baseline left-parenthesis ModifyingAbove
    x With right-arrow comma t right-parenthesis equals alpha normal upper Delta u
    left-parenthesis ModifyingAbove x With right-arrow comma t right-parenthesis comma
    dollar-sign"><mrow><msub><mi>u</mi> <mi>t</mi></msub> <mrow><mo>(</mo> <mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>α</mi> <mi>Δ</mi> <mi>u</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: the parameter <math alttext="alpha"><mi>α</mi></math> is the *diffusion coefficient*,
    which is a physical constant depending on the properties the diffusing substance
    and the properties of the medium it is diffusing into. We usually get these from
    reference tables obtained from experiments. Their values are very important for
    engineering purposes. When our equations model reality, we must use parameter
    values that are derived from this real experimental or observational data. But
    experimental and observational data are usually noisy, have missing values, unexplained
    outliers, and all kinds of rough seas for mathematical models. Many times we don’t
    even have experimental values for the parameters that are in our equations. The
    experiments can be expensive (think Large Hadron Collider) or even impossible.
    So one must *learn* the parameter values using indirect ways, based on accessible
    combinations of experimental, observational, and computer simulated values of
    some other variables. Historically, many of these parameter values were *hand
    tuned* in order fit some desired outcome, which is not good! We should have clear
    justifications for the choices of the parameter values that go into simulations.
    We will see how machine learning helps PDEs here in learning parameter values
    from data.
  prefs: []
  type: TYPE_NORMAL
- en: Changing One Thing in a PDE can be a Big Deal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you had a partial differential equations (PDEs) class in college, think
    back to the simplest equation that you studied, perhaps the heat diffusion equation
    on a rod such as those in [Figure 13-3](#Fig_steel_rod). If you did not study
    PDEs, do not worry about its details. The formula of the heat equation is:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign u Subscript t Baseline left-parenthesis x comma t
    right-parenthesis equals alpha normal upper Delta u left-parenthesis x comma t
    right-parenthesis period dollar-sign"><mrow><msub><mi>u</mi> <mi>t</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mi>α</mi> <mi>Δ</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>.</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Here, <math alttext="u left-parenthesis x comma t right-parenthesis"><mrow><mi>u</mi>
    <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow></math> measures
    the temperature at the point *x* in the rod and at time *t*, and the operator
    <math alttext="normal upper Delta"><mi>Δ</mi></math> is the second derivative
    in *x* (so <math alttext="normal upper Delta u left-parenthesis x comma t right-parenthesis
    equals u Subscript x x Baseline left-parenthesis x comma t right-parenthesis"><mrow><mi>Δ</mi>
    <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mi>u</mi> <mrow><mi>x</mi><mi>x</mi></mrow></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math> ), since a rod
    is only one dimensional if we ignore its thickness. In higher dimensions, the
    operator <math alttext="normal upper Delta"><mi>Δ</mi></math> is the sum of second
    derivatives in each of the dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s change the domain from a rod to a weird shaped plate: Not a square
    or a circle or ellipse, but something irregular, for example, compare [Figure 13-3](#Fig_steel_rod)
    with [Figure 13-4](#Fig_irregular_plate). The formula for the true solution which
    we learn in an introductory PDE class, which works for the rod, does not work
    for the weird plate anymore. This gets even worse. We do not only lose access
    to the analytical solution by changing the domain: When we try to solve the differential
    equation with the new domain numerically, the new geometry suddenly complicates
    matters. Now we have to find a discrete mesh that accurately portrays the shape
    of the new domain with all its details, then we have to compute a numerical solution
    on top of that mesh that satisfies the equation in the interior of the domain,
    and satisfies the boundary conditions along the weird looking boundary.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A](assets/emai_1303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-3\. Studying heat diffusion on a rod is easy (for people who studied
    PDEs) both analytically and numerically ([image source](https://commons.wikimedia.org/wiki/File:Steel-Dowel-Pins.jpg))
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![B](assets/emai_1304.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-4\. Studying heat diffusion on an irregular geometry is not as easy
    ([image source](https://www.theapollobox.com/product/sku590002/irregular-shaped-ceramic-plate)).
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This is normal in PDEs: Change one tiny thing and suddenly all the mathematical
    methods that we learned may not apply anymore. Such changes include:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the shape of the domain,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: change the types of the boundary conditions,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: introduce a space or time dependence in the coefficients (the parameters),
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: introduce nonlinearities,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: introduce terms with more derivatives (higher order), *etc.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: introduce more variables (higher dimension)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This frustrating aspect turns off many students from specializing in PDEs (no
    one wants to be an expert at only one equation, which could be very removed from
    modeling reality to start with). We don’t want to be turned off. We want to see
    the big picture. Natural phenomena are wonderfully varied so we have to accept
    the variations in the PDEs and their solution methods as part of our quest to
    understand and predict nature. Moreover, PDEs is a large and old field. A lot
    of progress has been made on unifying methods for many families of both linear
    and non-linear partial differential equations, and a lot of powerful analysis
    has been discovered along the way. The status quo is that PDEs is a very useful
    field that does not have, and might never have, a unifying theory.
  prefs: []
  type: TYPE_NORMAL
- en: In general, nonlinear PDEs are more difficult than linear PDEs, higher order
    PDEs are more difficult than lower order ones, higher dimensional PDEs are more
    difficult than lower dimensional ones, systems of PDEs are more difficult than
    single PDEs, we cannot write explicit formulas for solutions for the majority
    of PDEs out there, and many PDEs are only satisfied in *weak* forms. Many PDEs
    have solutions that develop singularities as time evolves (think the wave equation
    and shock waves). Mathematicians who develop PDE theory spend their time proving
    *existence* of solutions of PDEs, and trying to understand the *regularity* of
    these solutions, which means how nice they are in terms of actually possessing
    the derivatives that are involved in the PDE. These use a lot of advanced calculus
    methods, looking for estimates on integrals (inequalities for upper and lower
    bounds).
  prefs: []
  type: TYPE_NORMAL
- en: Can AI Step In?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now wouldn’t it be great if we had methods that account for variations in the
    PDE, the geometry of the domain, the boundary conditions, and the parameter ranges,
    similar to the actual physical problems? Many sectors of the industry and areas
    of science have their eyes on AI and deep learning to address their long standing
    problems, or shed new lights on them. The past decade’s astronomical advancement
    in computing solutions of very high dimensional problems has the potential to
    transform many fields held down by the curse of dimensionality. Such a transformation
    would be a sea change for PDEs and in turn to humanity as a whole, because of
    the sheer amount of science that is unlocked by PDEs and their solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the rest of this chapter, we highlight the hurdles that the differential
    equations community encounters with the traditional approaches to finding solutions
    to their PDEs, and with fitting real and noisy data into their models. We then
    illustrate how machine learning is stepping in to help bypass or alleviate these
    difficulties. We also distinguish two questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What can AI do for PDEs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What can PDEs do for AI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to make sure that the machine learning hallmarks of *training function,
    loss function, and optimization* settings are clear when serving PDEs, along with
    the labels or targets for supervised learning. Fitting the well established field
    of PDEs into a machine learning setting is not super straightforward. Ideally,
    we need to establish a map from a PDE to its solution. This requires some pausing
    and thinking.
  prefs: []
  type: TYPE_NORMAL
- en: Numerical Solutions Are Very Valuable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing a mathematical model that describes a natural phenomenon, in the form
    of equations describing how the involved variables interact with each other, is
    only a first step. We need to solve these equations.
  prefs: []
  type: TYPE_NORMAL
- en: Analytical solutions are harder than numerical solutions, since the more the
    model mimics nature the more complex the equations tend to be. Even when analytical
    methods cannot provide formulas for the solutions, they still provide valuable
    insights into their important properties. Numerical solutions are easier than
    analytical solutions, because they involve discretizing the continuous equations,
    moving us to from the realm of continuous functions to the realm of discrete numbers,
    or from infinite dimensional function spaces to finite dimensional vector spaces
    (linear algebra), which our machines are built to compute. Numerical solutions
    provide invaluable insights into the true analytical solutions of the models,
    and are easy to test against experimental observations, when available. They are
    also easy to tune so they are great aids for experimental design.
  prefs: []
  type: TYPE_NORMAL
- en: We can devise numerical solutions at any scale, but the curse of dimensionality
    haunts us whe we try to implement and compute our numerical schemes. In many situations,
    for a numerical simulation to mimic even one second of the natural evolution of
    a system requires a tremendous amount of computational power, so a lot of dimension
    reductions and simplification assumptions must happen, which moves us even farther
    from having a good approximation of the true solutions. The sad part is that this
    is the norm rather than the exception.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Functions vs Discrete Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The function <math alttext="f left-parenthesis x right-parenthesis equals x
    squared minus 3"><mrow><mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mn>3</mn></mrow></math>
    is continuous over the whole real line <math alttext="left-parenthesis negative
    normal infinity comma normal infinity right-parenthesis"><mrow><mo>(</mo> <mo>-</mo>
    <mi>∞</mi> <mo>,</mo> <mi>∞</mi> <mo>)</mo></mrow></math> . When we discretize
    it for a numerical scheme for a machine to process, first, the domain cannot be
    the whole real line anymore, because machines cannot yet conceptulaze infinite
    domains. So our first approximation is slashing the domain dramatically to some
    finite [-N,N] where N is a large number. Our second approximation is discretizing
    this finite domain, drastically reducing it one more time, from a continuum [-N,N]
    to only a finite set of points. If we use many points then our mesh will be finer
    and our approximation better, on the expense of increased computation cost. Say
    we use 6 points only to discretize the interval [-5,5]: -5, -3, -1, 1, 3, 5, then
    our continuous function will be reduced to a vector with only six entries:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column f left-parenthesis
    x right-parenthesis 2nd Column equals x squared minus 3 is continuous on left-parenthesis
    negative normal infinity comma normal infinity right-parenthesis 2nd Row 1st Column
    ModifyingAbove discrete f With right-arrow 2nd Column Start 6 By 1 Matrix 1st
    Row  left-parenthesis negative 5 right-parenthesis squared minus 3 2nd Row  left-parenthesis
    negative 3 right-parenthesis squared minus 3 3rd Row  left-parenthesis negative
    1 right-parenthesis squared minus 3 4th Row  1 squared minus 3 5th Row  3 squared
    minus 3 6th Row  5 squared minus 3 EndMatrix equals Start 6 By 1 Matrix 1st Row  22
    2nd Row  6 3rd Row  negative 2 4th Row  negative 2 5th Row  6 6th Row  22 EndMatrix
    EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <msup><mi>x</mi> <mn>2</mn></msup> <mo>-</mo> <mn>3</mn> <mtext>is</mtext> <mtext>continuous</mtext>
    <mtext>on</mtext> <mrow><mo>(</mo> <mo>-</mo> <mi>∞</mi> <mo>,</mo> <mi>∞</mi>
    <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mover accent="true"><mrow><mtext>discrete</mtext><mtext>f</mtext></mrow>
    <mo>→</mo></mover></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mfenced close=")"
    open="("><mtable><mtr><mtd><mrow><msup><mrow><mo>(</mo><mo>-</mo><mn>5</mn><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>-</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mrow><msup><mrow><mo>(</mo><mo>-</mo><mn>3</mn><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>-</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mrow><msup><mrow><mo>(</mo><mo>-</mo><mn>1</mn><mo>)</mo></mrow>
    <mn>2</mn></msup> <mo>-</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mrow><msup><mn>1</mn>
    <mn>2</mn></msup> <mo>-</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mrow><msup><mn>3</mn>
    <mn>2</mn></msup> <mo>-</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mrow><msup><mn>5</mn>
    <mn>2</mn></msup> <mo>-</mo> <mn>3</mn></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close=")" open="("><mtable><mtr><mtd><mn>22</mn></mtd></mtr>
    <mtr><mtd><mn>6</mn></mtd></mtr> <mtr><mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd></mtr>
    <mtr><mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd></mtr> <mtr><mtd><mn>6</mn></mtd></mtr>
    <mtr><mtd><mn>22</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-5](#Fig_discrete_f) shows the continuous function and its insanely
    under-representative six point approximation.'
  prefs: []
  type: TYPE_NORMAL
- en: '![250](assets/emai_1305.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-5\. Discretizing the continuous function into a vector with only six
    points. We lose all the continuous wealth of information in between the points.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We still need to discretize derivatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can discretize a function *f(x)* by selecting points in an interval, just
    like we did above. Differential equations contain *derivatives of functions* such
    as <math alttext="f Subscript x Baseline comma normal upper Delta f"><mrow><msub><mi>f</mi>
    <mi>x</mi></msub> <mo>,</mo> <mi>Δ</mi> <mi>f</mi></mrow></math> , not only functions.
    So we must discretize the derivatives, or find some other way to reduce a problem
    from functional spaces (such as continuous spaces) to vector spaces (so we can
    use linear algebra and compute using our machines). Finite differences and finite
    elements are two popular discretization methods for differential equations. We
    will go over them shortly, along with a probabilistic Monte Carlo method based
    on random walks.
  prefs: []
  type: TYPE_NORMAL
- en: One tradeoff of the simplicity of numerical solutions is that when we discretize,
    we make an approximation, reducing an infinite continuum to a finite set of points,
    losing all the infinitely detailed information that is between the finite set
    of points. That is, we sacrifice of high resolution. For certain equations, there
    are analytical methods which help us quantify exactly how much information we
    lose by discretization, and help move us back to an accurate analytical solution
    by taking the limit as the size of the discrete mesh goes to zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Discretizing continuous functions and the equations that involve them has advantages:
    Easy access. We can teach high school students how to solve the heat equation
    describing the diffusion of heat in a rod numerically (soon in this chapter),
    but we can cannot teach them how to solve it analytically until they finish their
    college calculus sequence and linear algebra. This is why we must teach children
    how to model and compute numerical solutions of real life problems at a very young
    age. The simplicity of numerical solutions and the power of computation to aid
    in solving all kinds of human problems should make this a priority in our education
    system. I doubt that nature intended for us to build and unravel crazily complicated
    mathematical theories before *computing* how the world around us works. I also
    doubt that nature is as complicated as some mathematical theories happen to be
    (even though they are still interesting in their own right, if only as an exercise
    in how far the rules of logic and inference can lead us).'
  prefs: []
  type: TYPE_NORMAL
- en: PDE Themes From My Ph.D. Thesis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The story of my Ph.D. thesis demonstrates the drastic difference between mathematical
    theory and numerical approaches. It is also a good prototype for some of the themes
    of this chapter. For my Ph.D., I worked on a mathematical model that describes
    the way atoms diffuse and hop between different levels of a stair like surface
    of a thin crystal. This is useful for the materials science community and for
    the engineers involved in designing the mini things that go into our electronic
    devices. As time evolves the crystal’s shape changes due to the movement of atoms
    on its surface. Eventually, the crystal relaxes into some stable shape.
  prefs: []
  type: TYPE_NORMAL
- en: Discretize Right Away And Do A Computer Simulation
  prefs: []
  type: TYPE_NORMAL
- en: 'The moment I wrote down the equations, I was able to do a computer simulation
    that showed how the shape of the crystal evolves with time. This is one of the
    PDEs that I worked on (not that you should care for it or know what the function
    in it refer to):'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign u Subscript t Baseline left-parenthesis h comma t
    right-parenthesis equals minus u squared left-parenthesis u cubed right-parenthesis
    Subscript h h h h Baseline where h element-of left-bracket 0 comma 1 right-bracket
    comma t element-of left-bracket 0 comma normal infinity right-parenthesis dollar-sign"><mrow><msub><mi>u</mi>
    <mi>t</mi></msub> <mrow><mo>(</mo> <mi>h</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mo>-</mo> <msup><mi>u</mi> <mn>2</mn></msup> <msub><mrow><mo>(</mo><msup><mi>u</mi>
    <mn>3</mn></msup> <mo>)</mo></mrow> <mrow><mi>h</mi><mi>h</mi><mi>h</mi><mi>h</mi></mrow></msub>
    <mtext>where</mtext> <mi>h</mi> <mo>∈</mo> <mrow><mo>[</mo> <mn>0</mn> <mo>,</mo>
    <mn>1</mn> <mo>]</mo></mrow> <mo>,</mo> <mi>t</mi> <mo>∈</mo> <mrow><mo>[</mo>
    <mn>0</mn> <mo>,</mo> <mi>∞</mi> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'For the trained eye, this is a highly nonlinear fourth order equation: The
    unknown function *u* appears both squared and cubed. Its cube appears with four
    derivatives in space, which we can think of as four degrees removed from the function
    that we want to evaluate. [Figure 13-6](#Fig_discrete_continuum) shows my PDE’s
    discretization in space using finite differences (we will discuss finite differences
    shortly), and its boundary conditions (the function values at the points 0 and
    1).'
  prefs: []
  type: TYPE_NORMAL
- en: '![250](assets/emai_1306.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-6\. Discrete differential equations and their continuum analogue.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Usually the more nonlinear an equation is the more stubborn it is in submitting
    to standard analytical techniques. I still needed to do the mathematical analysis
    and prove that the shape that the numerical simulation showed is indeed what the
    equations want the solution to do, meaning that it is *the* analytical solution,
    and it is what nature chooses among possible others. I had to spend the next two
    years of my life doing only that. What I came up with was a tiny proof in a tiny
    case for a physically unrealistic *one dimensional crystal*! I had to reduce my
    equations to only one dimension to be able to do any mathematical analysis with
    them.
  prefs: []
  type: TYPE_NORMAL
- en: The Curse of Dimensionality
  prefs: []
  type: TYPE_NORMAL
- en: 'One theme which is always present is the dimensionality of the problem: Even
    when I did the numerical simulation, which took less than one afternoon, I was
    only able to do it for the equation over the one dimensional domain. When I tried
    to do a simulation to model a realistic thin film laboratory crystal that lays
    on a flat surface, meaning when I had to discretize a two dimensional surface
    instead of a one dimensional segment, the number of dicrete points jumped from
    100 on the one dimensional segment to <math alttext="100 squared equals 100 comma
    000"><mrow><msup><mn>100</mn> <mn>2</mn></msup> <mo>=</mo> <mn>100</mn> <mo>,</mo>
    <mn>000</mn></mrow></math> on the two dimensional surface. My computer at the
    time could not numerically solve the exact same equation that took only few seconds
    in the one dimensional case. Granted, I was not sophisticated enough to compute
    on the university’s server or use parallel computing (I do not know if distributed
    cloud computing had even been invented back then). So is life with the curse of
    dimensionality. The computational expense rises exponentially with the number
    of dimensions. Now let’s think of the equations whose domains have high dimensions
    to start with (even before discretization), like Shrödinger equation for quantum
    particle systems, Black Scholes equation for pricing financial instruments, or
    the Hamilton–Jacobi–Bellman equation in dynamic programming which models multi-player
    games or resource allocation problems. Imagine then the magnitude of the curse
    of dimensionality.'
  prefs: []
  type: TYPE_NORMAL
- en: The Geometry of the Problem
  prefs: []
  type: TYPE_NORMAL
- en: 'Another theme that we have mentioned earlier but is worth repeating: The shape
    of the domain matters, for both analysis and numerical computation. In my unrealistic
    one dimensional case, I used a segment as the domain for my equation. In the two
    dimensional case, I had much more choices: A rectangle (has the advantage of a
    regular grid), a circle (has the advantage of radial symmetry), or any other realistic
    unregular shape which doesn’t usually have a name. For analysis, the rectangle
    and the circle domains are the easiest (not for my particular equations but for
    other simpler equations like linear equations). For simulations, these are good
    too. But when the shape of the domain is not regular, which is the case for most
    realistic things, we need to place more discrete points in the parts where it
    is irregular if we want to capture the domain faithfully. The curse of dimensionality
    bears its unwelcome head again: More points means longer vectors and larger input
    matrices for computations.'
  prefs: []
  type: TYPE_NORMAL
- en: Model Things That You Care For
  prefs: []
  type: TYPE_NORMAL
- en: To finish my Ph.D. story, I never saw a real thin film crystal like the one
    I was working on until ten years after I finished my degree, when my friend showed
    me a thin film crystal of gold in her lab. In retrospect, maybe I should’ve started
    there, by *seeing* exactly what it is in real life that I was trying to model.
    My priorities now are aligned differently, and I always start by asking whether
    I care for what it is I am trying to model, how closely the model I choose to
    work on mimics reality, and whether thinking about analytical solutions is even
    worth the time and the effort for this particular application.
  prefs: []
  type: TYPE_NORMAL
- en: Discretization And The Curse Of Dimensionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mathematicians who study PDEs like the continuous world but machines like the
    discrete world. Mathematicians like to analyze functions but machines like to
    compute functions. To reconcile the two, and for machines to be of aid to mathematicians
    and vice versa, we can discretize our continuum equations. How? First, we discretize
    the domain of the equation, creating a discrete mesh. We choose the type of the
    mesh (regular or irregular) and how fine or coarse it is. Then we discretize the
    differential equation itself, using one of four popular methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Finite differences**: Deterministic, good for discretizing time, one dimensional
    or relatively regular spatial geometries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Finite elements**: Deterministic, good for discretizing more complex spatial
    geometries, also spatial geometries that vary with time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variational or energy methods**: This is similar to finite elements but works
    on a narrower set of PDEs. They should possess a *variational principle*, or an
    *energy formulation*, that is, the PDE itself should be equivalent to <math alttext="normal
    nabla upper E left-parenthesis u right-parenthesis equals 0"><mrow><mi>∇</mi>
    <mi>E</mi> <mo>(</mo> <mi>u</mi> <mo>)</mo> <mo>=</mo> <mn>0</mn></mrow></math>
    for some energy functional *E(u)* (mapping functions to the real line). The reason
    I was able to get my Ph.D. is that I discovered such an energy functional for
    my PDE, by pure luck. Just like the minimum of a calculus function happens at
    points where <math alttext="normal nabla f left-parenthesis ModifyingAbove x With
    right-arrow right-parenthesis equals 0"><mrow><mi>∇</mi> <mi>f</mi> <mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo> <mo>=</mo> <mn>0</mn></mrow></math>
    , the minimum of an energy functional happens at *functions* where <math alttext="normal
    nabla upper E left-parenthesis u right-parenthesis equals 0"><mrow><mi>∇</mi>
    <mi>E</mi> <mo>(</mo> <mi>u</mi> <mo>)</mo> <mo>=</mo> <mn>0</mn></mrow></math>
    , but of course we need to define what it means to take the derivative of a *functional*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monte Carlo Methods**: Probabilistic, starts with discretizing the PDE then
    use that to devise an appropriate random walk scheme that enables us to *aggregate*
    the solution at a certain point in the domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The word *finite* in these methods stresses the fact that this process moves
    us from continuum infinite dimensional spaces of functions to finite dimensional
    spaces of vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the mesh we use for discretization is too fine, it captures more resolution,
    but we end up with high dimensional vectors and matrices. Keep this curse of dimensionality
    in mind, and the following: One of the main reasons neural networks’ popularity
    skyrocketed is that they seem to have a magical ability to overcome the curse
    of dimensionality. We will see how soon.'
  prefs: []
  type: TYPE_NORMAL
- en: Finite Differences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use finite differences to numerically approximate the derivatives of the
    functions that appear in PDEs. For example, a particle’s velocity is the derivative
    in time of its position vector, and a particle’s acceleration is two detivatives
    in time of it’s position vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'In finite difference approximations, we replace the derivatives with linear
    combinations of function values at discrete points in the domain. Recall that
    one derivative measures a function’s rate of change. Two derivatives measure concavity.
    Higher derivatives measure more stuff that some people in the sciences happen
    to use. The connection between a function’s derivatives at a point and how its
    values near that point compare to each other is pretty intuitive. The mathematical
    justification for these approximations rely on Taylor’s theorem from calculus:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign f left-parenthesis x right-parenthesis equals f left-parenthesis
    x Subscript i Baseline right-parenthesis plus f prime left-parenthesis x Subscript
    i Baseline right-parenthesis left-parenthesis x minus x Subscript i Baseline right-parenthesis
    plus StartFraction f double-prime left-parenthesis x Subscript i Baseline right-parenthesis
    Over 2 EndFraction left-parenthesis x minus x Subscript i Superscript 2 Baseline
    right-parenthesis plus StartFraction f Superscript left-parenthesis 3 right-parenthesis
    Baseline left-parenthesis x Subscript i Baseline right-parenthesis Over 3 factorial
    EndFraction left-parenthesis x minus x Subscript i Baseline right-parenthesis
    cubed plus ellipsis plus StartFraction f Superscript left-parenthesis n right-parenthesis
    Baseline left-parenthesis x Subscript i Baseline right-parenthesis Over n factorial
    EndFraction left-parenthesis x minus x Subscript i Baseline right-parenthesis
    Superscript n Baseline plus error term comma dollar-sign"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <msub><mi>x</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow> <mo>+</mo> <msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow> <mrow><mo>(</mo>
    <mi>x</mi> <mo>-</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow> <mo>+</mo>
    <mfrac><mrow><msup><mi>f</mi> <mrow><mo>'</mo><mo>'</mo></mrow></msup> <mrow><mo>(</mo><msub><mi>x</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow></mrow> <mn>2</mn></mfrac> <mrow><mo>(</mo>
    <mi>x</mi> <mo>-</mo> <msubsup><mi>x</mi> <mi>i</mi> <mn>2</mn></msubsup> <mo>)</mo></mrow>
    <mo>+</mo> <mfrac><mrow><msup><mi>f</mi> <mrow><mo>(</mo><mn>3</mn><mo>)</mo></mrow></msup>
    <mrow><mo>(</mo><msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow> <mrow><mn>3</mn><mo>!</mo></mrow></mfrac>
    <msup><mrow><mo>(</mo><mi>x</mi><mo>-</mo><msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow>
    <mn>3</mn></msup> <mo>+</mo> <mo>⋯</mo> <mo>+</mo> <mfrac><mrow><msup><mi>f</mi>
    <mrow><mo>(</mo><mi>n</mi><mo>)</mo></mrow></msup> <mrow><mo>(</mo><msub><mi>x</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow></mrow> <mrow><mi>n</mi><mo>!</mo></mrow></mfrac>
    <msup><mrow><mo>(</mo><mi>x</mi><mo>-</mo><msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow>
    <mi>n</mi></msup> <mo>+</mo> <mtext>error</mtext> <mtext>term</mtext> <mo>,</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: where the error term depends on how nice the next order derivative <math alttext="f
    Superscript left-parenthesis n plus 1 right-parenthesis Baseline left-parenthesis
    xi right-parenthesis"><mrow><msup><mi>f</mi> <mrow><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></msup>
    <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow></mrow></math> near the <math alttext="x
    Subscript i"><msub><mi>x</mi> <mi>i</mi></msub></math> where we are attempting
    to use our polynomial approximation. Taylor’s theorem approximates a nice enough
    function near a point with a polynomial whose coefficients are determined by the
    derivatives of the function at that point. The more derivatives the function has
    at a point the nicer it is and the *more like a polynomial* it behaves near that
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s discretize a one dimensional interval [a,b] then write down finite
    difference approximations for the derivatives of a function *f(x)* defined over
    this interval. We can discretize [a,b] using n+1 equally spaced points, so the
    mesh size is <math alttext="h equals StartFraction b minus a Over n EndFraction"><mrow><mi>h</mi>
    <mo>=</mo> <mfrac><mrow><mi>b</mi><mo>-</mo><mi>a</mi></mrow> <mi>n</mi></mfrac></mrow></math>
    . We can now evaluate *f* at any of these discrete points. If we care about the
    values near some point <math alttext="x Subscript i"><msub><mi>x</mi> <mi>i</mi></msub></math>
    , we define <math alttext="f Subscript i plus 1 Baseline equals f left-parenthesis
    x Subscript i Baseline plus h right-parenthesis comma f Subscript i plus 2 Baseline
    equals f left-parenthesis x Subscript i Baseline plus 2 h right-parenthesis comma
    f Subscript i minus 1 Baseline equals f left-parenthesis x Subscript i Baseline
    minus h right-parenthesis"><mrow><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>+</mo>
    <mi>h</mi> <mo>)</mo></mrow> <mo>,</mo> <msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>+</mo>
    <mn>2</mn> <mi>h</mi> <mo>)</mo></mrow> <mo>,</mo> <msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>-</mo>
    <mi>h</mi> <mo>)</mo></mrow></mrow></math> , *etc*. In the following, *h* is small,
    so an <math alttext="upper O left-parenthesis h squared right-parenthesis"><mrow><mi>O</mi>
    <mo>(</mo> <msup><mi>h</mi> <mn>2</mn></msup> <mo>)</mo></mrow></math> method
    (or higher order in *h*) is more accurate than an <math alttext="upper O left-parenthesis
    h right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <mi>h</mi> <mo>)</mo></mrow></math>
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Forward difference approximation of O(h) accuracy for the first derivative
    (uses 2 points): (add picture)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign f prime left-parenthesis x Subscript i Baseline right-parenthesis
    almost-equals StartFraction f Subscript i plus 1 Baseline minus f Subscript i
    Baseline Over h EndFraction dollar-sign"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow> <mo>≈</mo>
    <mfrac><mrow><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>-</mo><msub><mi>f</mi> <mi>i</mi></msub></mrow> <mi>h</mi></mfrac></mrow></math>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Backward difference approximation of O(h) accuracy for the first derivative
    (uses 2 points): (add picture)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign f prime left-parenthesis x Subscript i Baseline right-parenthesis
    almost-equals StartFraction f Subscript i Baseline minus f Subscript i minus 1
    Baseline Over h EndFraction dollar-sign"><mrow><msup><mi>f</mi> <mo>'</mo></msup>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow> <mo>≈</mo>
    <mfrac><mrow><msub><mi>f</mi> <mi>i</mi></msub> <mo>-</mo><msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow>
    <mi>h</mi></mfrac></mrow></math>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Central-difference approximations of <math alttext="upper O left-parenthesis
    h squared right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>h</mi> <mn>2</mn></msup>
    <mo>)</mo></mrow></math> accuracy for derivatives up to the fourth (uses 2 points,
    averages forward and backward differences): (add picture)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column f prime left-parenthesis
    x Subscript i Baseline right-parenthesis 2nd Column almost-equals StartFraction
    f Subscript i plus 1 Baseline minus f Subscript i minus 1 Baseline Over 2 h EndFraction
    2nd Row 1st Column f double-prime left-parenthesis x Subscript i Baseline right-parenthesis
    2nd Column almost-equals StartFraction f Subscript i plus 1 Baseline minus 2 f
    Subscript i Baseline plus f Subscript i minus 1 Baseline Over h squared EndFraction
    3rd Row 1st Column f triple-prime left-parenthesis x Subscript i Baseline right-parenthesis
    2nd Column almost-equals StartFraction f Subscript i plus 2 Baseline minus 2 f
    Subscript i plus 1 Baseline plus 2 f Subscript i minus 1 Baseline minus f Subscript
    i minus 2 Baseline Over 2 h cubed EndFraction 4th Row 1st Column f Superscript
    left-parenthesis 4 right-parenthesis Baseline left-parenthesis x Subscript i Baseline
    right-parenthesis 2nd Column almost-equals StartFraction f Subscript i plus 2
    Baseline minus 4 f Subscript i plus 1 Baseline plus 6 f Subscript i Baseline minus
    4 f Subscript i minus 1 Baseline plus f Subscript i minus 2 Baseline Over h Superscript
    4 Baseline EndFraction EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><msup><mi>f</mi> <mo>'</mo></msup> <mrow><mo>(</mo>
    <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd> <mtd columnalign="left"><mrow><mo>≈</mo>
    <mfrac><mrow><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>-</mo><msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow>
    <mrow><mn>2</mn><mi>h</mi></mrow></mfrac></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><msup><mi>f</mi>
    <mrow><mo>'</mo><mo>'</mo></mrow></msup> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub>
    <mo>)</mo></mrow></mrow></mtd> <mtd columnalign="left"><mrow><mo>≈</mo> <mfrac><mrow><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>-</mo><mn>2</mn><msub><mi>f</mi>
    <mi>i</mi></msub> <mo>+</mo><msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow>
    <msup><mi>h</mi> <mn>2</mn></msup></mfrac></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><msup><mi>f</mi>
    <mrow><mo>'</mo><mo>'</mo><mo>'</mo></mrow></msup> <mrow><mo>(</mo> <msub><mi>x</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd> <mtd columnalign="left"><mrow><mo>≈</mo>
    <mfrac><mrow><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub>
    <mo>-</mo><mn>2</mn><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>+</mo><mn>2</mn><msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>-</mo><msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow>
    <mrow><mn>2</mn><msup><mi>h</mi> <mn>3</mn></msup></mrow></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><msup><mi>f</mi> <mrow><mo>(</mo><mn>4</mn><mo>)</mo></mrow></msup>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>≈</mo> <mfrac><mrow><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub>
    <mo>-</mo><mn>4</mn><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>+</mo><mn>6</mn><msub><mi>f</mi> <mi>i</mi></msub> <mo>-</mo><mn>4</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>+</mo><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow> <msup><mi>h</mi> <mn>4</mn></msup></mfrac></mrow></mtd></mtr></mtable></math>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Central-difference approximations of <math alttext="upper O left-parenthesis
    h Superscript 4 Baseline right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>h</mi>
    <mn>4</mn></msup> <mo>)</mo></mrow></math> accuracy for derivatives up to the
    fourth:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column f prime left-parenthesis
    x Subscript i Baseline right-parenthesis 2nd Column almost-equals StartFraction
    minus f Subscript i plus 2 Baseline plus 8 f Subscript i plus 1 Baseline minus
    8 f Subscript i minus 1 Baseline plus f Subscript i minus 2 Baseline Over 12 h
    EndFraction 2nd Row 1st Column f double-prime left-parenthesis x Subscript i Baseline
    right-parenthesis 2nd Column almost-equals StartFraction minus f Subscript i plus
    2 Baseline plus 16 f Subscript i plus 1 Baseline minus 30 f Subscript i Baseline
    plus 16 f Subscript i minus 1 Baseline minus f Subscript i minus 2 Baseline Over
    12 h squared EndFraction 3rd Row 1st Column f triple-prime left-parenthesis x
    Subscript i Baseline right-parenthesis 2nd Column almost-equals StartFraction
    minus f Subscript i plus 3 Baseline plus 8 f Subscript i plus 2 Baseline minus
    13 f Subscript i plus 1 Baseline plus 13 f Subscript i minus 1 Baseline minus
    8 f Subscript i minus 2 Baseline plus f Subscript i minus 3 Baseline Over 8 h
    cubed EndFraction 4th Row 1st Column f Superscript left-parenthesis 4 right-parenthesis
    Baseline left-parenthesis x Subscript i Baseline right-parenthesis 2nd Column
    almost-equals StartFraction minus f Subscript i plus 3 Baseline plus 12 f Subscript
    i plus 2 Baseline minus 39 f Subscript i plus 1 Baseline plus 56 f Subscript i
    Baseline minus 39 f Subscript i minus 1 Baseline plus 12 f Subscript i minus 2
    Baseline minus f Subscript i minus 3 Baseline Over 6 h Superscript 4 Baseline
    EndFraction EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><msup><mi>f</mi>
    <mo>'</mo></msup> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>≈</mo> <mfrac><mrow><mo>-</mo><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub> <mo>+</mo><mn>8</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>-</mo><mn>8</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>+</mo><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow> <mrow><mn>12</mn><mi>h</mi></mrow></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><msup><mi>f</mi> <mrow><mo>'</mo><mo>'</mo></mrow></msup>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>≈</mo> <mfrac><mrow><mo>-</mo><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub> <mo>+</mo><mn>16</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>-</mo><mn>30</mn><msub><mi>f</mi>
    <mi>i</mi></msub> <mo>+</mo><mn>16</mn><msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>-</mo><msub><mi>f</mi> <mrow><mi>i</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow>
    <mrow><mn>12</mn><msup><mi>h</mi> <mn>2</mn></msup></mrow></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><msup><mi>f</mi> <mrow><mo>'</mo><mo>'</mo><mo>'</mo></mrow></msup>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>≈</mo> <mfrac><mrow><mo>-</mo><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>3</mn></mrow></msub> <mo>+</mo><mn>8</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub> <mo>-</mo><mn>13</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>+</mo><mn>13</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>-</mo><mn>8</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>2</mn></mrow></msub> <mo>+</mo><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>3</mn></mrow></msub></mrow> <mrow><mn>8</mn><msup><mi>h</mi>
    <mn>3</mn></msup></mrow></mfrac></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><msup><mi>f</mi>
    <mrow><mo>(</mo><mn>4</mn><mo>)</mo></mrow></msup> <mrow><mo>(</mo> <msub><mi>x</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd> <mtd columnalign="left"><mrow><mo>≈</mo>
    <mfrac><mrow><mo>-</mo><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>3</mn></mrow></msub>
    <mo>+</mo><mn>12</mn><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub>
    <mo>-</mo><mn>39</mn><msub><mi>f</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>+</mo><mn>56</mn><msub><mi>f</mi> <mi>i</mi></msub> <mo>-</mo><mn>39</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>+</mo><mn>12</mn><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>2</mn></mrow></msub> <mo>-</mo><msub><mi>f</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>3</mn></mrow></msub></mrow> <mrow><mn>6</mn><msup><mi>h</mi>
    <mn>4</mn></msup></mrow></mfrac></mrow></mtd></mtr></mtable></math>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**What does the <math alttext="upper O left-parenthesis h Superscript k Baseline
    right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>h</mi> <mi>k</mi></msup>
    <mo>)</mo></mrow></math> mean?** It is the order of the numerical approximation
    in *h*. When we replace a derivative using its numerical approximation, we commit
    an error. The <math alttext="upper O left-parenthesis h Superscript k Baseline
    right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>h</mi> <mi>k</mi></msup>
    <mo>)</mo></mrow></math> tells us how much error we are committing. Obviously
    this depends on the size of the mesh *h*. The error should be smaller with finer
    meshes. To derive such error bounds, we use Taylor expansions of f(x+h), f(x-h),
    f(x+2h), f(x-2h), *etc.* and linear combinations of those to determine both the
    desired derivative’s approximation and the order of our finite difference approximation
    in terms of *h*. To be able to use Taylor expansions, we assume that we are dealing
    with functions that *indeed have the required number of derivatives* at the points
    we are evaluating them at. This means that we assume that our function is nice
    enough to allow these derivative evaluations. If the function has singularities
    near these points, then we need to find ways around that, such as using much finer
    meshes near the singularities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Let’s solve <math alttext="y double-prime left-parenthesis x right-parenthesis
    equals 1"><mrow><msup><mi>y</mi> <mrow><mo>''</mo><mo>''</mo></mrow></msup> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>1</mn></mrow></math> on [0,1], with
    boundary conditions y(0)=-1 and y(1)=0\. This is a second linear order ordinary
    differential equation on a bounded domain in one dimension.'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example is trivial because the analytical solution is so easy. All we have
    to do is to integrate the equation twice and recover the function without its
    derivatives <math alttext="y left-parenthesis x right-parenthesis equals 0.5 x
    squared plus c 1 x plus c 2"><mrow><mi>y</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>0</mn> <mo>.</mo> <mn>5</mn> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <msub><mi>c</mi> <mn>1</mn></msub> <mi>x</mi> <mo>+</mo> <msub><mi>c</mi>
    <mn>2</mn></msub></mrow></math> where the c’s are the constants of integration.
    We plug the two boundary conditions to find the c’s and obtain the analytical
    solution <math alttext="y left-parenthesis x right-parenthesis equals 0.5 x squared
    plus 0.5 x minus 1"><mrow><mi>y</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>0</mn> <mo>.</mo> <mn>5</mn> <msup><mi>x</mi> <mn>2</mn></msup>
    <mo>+</mo> <mn>0</mn> <mo>.</mo> <mn>5</mn> <mi>x</mi> <mo>-</mo> <mn>1</mn></mrow></math>
    . However, the point of this example is to show how to use finite differences
    to compute the *numerical solution*, not the analytical one, since analytical
    solutions are not available for many other differential equations so we might
    as well get good at this. We first discretize the domain [0,1]. We can use as
    many points as we want. The more points the higher dimension we have to deal with
    but the resolution will be better. We’ll use only eight points, so the mesh size
    is *h=1/7* ([Figure 13-7](#Fig_discretize)). Our continuum [0,1] interval is now
    reduced to the eight points (0,1/7,2/7,3/7,4/7,5/7,6/7,1).
  prefs: []
  type: TYPE_NORMAL
- en: '![250](assets/emai_1307.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-7\. Discretizing the unit interval using eight discrete points, which
    is the same as seven intervals. The step size (or mesh size) is h=1/7.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Next, we discretize the differential equation. We can use any finite difference
    scheme to discretize the second derivative. Let’s choose the <math alttext="upper
    O left-parenthesis h squared right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>h</mi>
    <mn>2</mn></msup> <mo>)</mo></mrow></math> central difference, so the discretized
    differential equation becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartFraction y Subscript i plus 1 Baseline minus
    2 y Subscript i Baseline plus y Subscript i minus 1 Baseline Over h squared EndFraction
    equals 1 for i equals 1 comma 2 comma 3 comma 4 comma 5 comma 6 period dollar-sign"><mrow><mfrac><mrow><msub><mi>y</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>-</mo><mn>2</mn><msub><mi>y</mi>
    <mi>i</mi></msub> <mo>+</mo><msub><mi>y</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow>
    <msup><mi>h</mi> <mn>2</mn></msup></mfrac> <mo>=</mo> <mn>1</mn> <mtext>for</mtext>
    <mi>i</mi> <mo>=</mo> <mn>1</mn> <mo>,</mo> <mn>2</mn> <mo>,</mo> <mn>3</mn> <mo>,</mo>
    <mn>4</mn> <mo>,</mo> <mn>5</mn> <mo>,</mo> <mn>6</mn> <mo>.</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the differential equation is only valid in the *interior* of the
    domain, that is why we do not include the points i=0 and i=7 when we write its
    discrete analogue. We get the values at i=0 and i=7 from the boundary conditions:
    <math alttext="y 0 equals negative 1"><mrow><msub><mi>y</mi> <mn>0</mn></msub>
    <mo>=</mo> <mo>-</mo> <mn>1</mn></mrow></math> and <math alttext="y 7 equals 0"><mrow><msub><mi>y</mi>
    <mn>7</mn></msub> <mo>=</mo> <mn>0</mn></mrow></math> . Now, we have a system
    of six equations six unknowns, <math alttext="y 1 comma y 2 comma y 3 comma y
    4 comma y 5 comma y 6"><mrow><msub><mi>y</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>y</mi>
    <mn>2</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>3</mn></msub> <mo>,</mo> <msub><mi>y</mi>
    <mn>4</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>5</mn></msub> <mo>,</mo> <msub><mi>y</mi>
    <mn>6</mn></msub></mrow></math> :'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column y
    2 minus 2 y 1 minus 1 equals 1 slash 49 2nd Row 1st Column Blank 2nd Column y
    3 minus 2 y 2 plus y 1 equals 1 slash 49 3rd Row 1st Column Blank 2nd Column y
    4 minus 2 y 3 plus y 2 equals 1 slash 49 4th Row 1st Column Blank 2nd Column y
    5 minus 2 y 4 plus y 3 equals 1 slash 49 5th Row 1st Column Blank 2nd Column y
    6 minus 2 y 5 plus y 4 equals 1 slash 49 6th Row 1st Column Blank 2nd Column 0
    minus 2 y 6 plus y 5 equals 1 slash 49 EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><msub><mi>y</mi> <mn>2</mn></msub> <mo>-</mo> <mn>2</mn>
    <msub><mi>y</mi> <mn>1</mn></msub> <mo>-</mo> <mn>1</mn> <mo>=</mo> <mn>1</mn>
    <mo>/</mo> <mn>49</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><msub><mi>y</mi>
    <mn>3</mn></msub> <mo>-</mo> <mn>2</mn> <msub><mi>y</mi> <mn>2</mn></msub> <mo>+</mo>
    <msub><mi>y</mi> <mn>1</mn></msub> <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><msub><mi>y</mi> <mn>4</mn></msub> <mo>-</mo>
    <mn>2</mn> <msub><mi>y</mi> <mn>3</mn></msub> <mo>+</mo> <msub><mi>y</mi> <mn>2</mn></msub>
    <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><msub><mi>y</mi>
    <mn>5</mn></msub> <mo>-</mo> <mn>2</mn> <msub><mi>y</mi> <mn>4</mn></msub> <mo>+</mo>
    <msub><mi>y</mi> <mn>3</mn></msub> <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><msub><mi>y</mi> <mn>6</mn></msub> <mo>-</mo>
    <mn>2</mn> <msub><mi>y</mi> <mn>5</mn></msub> <mo>+</mo> <msub><mi>y</mi> <mn>4</mn></msub>
    <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mn>0</mn>
    <mo>-</mo> <mn>2</mn> <msub><mi>y</mi> <mn>6</mn></msub> <mo>+</mo> <msub><mi>y</mi>
    <mn>5</mn></msub> <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'So now we moved from the continuum world to the linear algebra world:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign Start 6 By 6 Matrix 1st Row 1st Column negative 2
    2nd Column 1 3rd Column 0 4th Column 0 5th Column 0 6th Column 0 2nd Row 1st Column
    1 2nd Column negative 2 3rd Column 1 4th Column 0 5th Column 0 6th Column 0 3rd
    Row 1st Column 0 2nd Column 1 3rd Column negative 2 4th Column 1 5th Column 0
    6th Column 0 4th Row 1st Column 0 2nd Column 0 3rd Column 1 4th Column negative
    2 5th Column 1 6th Column 0 5th Row 1st Column 0 2nd Column 0 3rd Column 0 4th
    Column 1 5th Column negative 2 6th Column 1 6th Row 1st Column 0 2nd Column 0
    3rd Column 0 4th Column 0 5th Column 1 6th Column negative 2 EndMatrix Start 6
    By 1 Matrix 1st Row  y 1 2nd Row  y 2 3rd Row  y 3 4th Row  y 4 5th Row  y 5 6th
    Row  y 6 EndMatrix equals Start 6 By 1 Matrix 1st Row  1 slash 49 plus 1 2nd Row  1
    slash 49 3rd Row  1 slash 49 4th Row  1 slash 49 5th Row  1 slash 49 6th Row  1
    slash 49 EndMatrix dollar-sign"><mrow><mfenced close=")" open="("><mtable><mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd>
    <mtd><mrow><mo>-</mo> <mn>2</mn></mrow></mtd></mtr></mtable></mfenced> <mfenced
    close=")" open="("><mtable><mtr><mtd><msub><mi>y</mi> <mn>1</mn></msub></mtd></mtr>
    <mtr><mtd><msub><mi>y</mi> <mn>2</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>y</mi>
    <mn>3</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>y</mi> <mn>4</mn></msub></mtd></mtr>
    <mtr><mtd><msub><mi>y</mi> <mn>5</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>y</mi>
    <mn>6</mn></msub></mtd></mtr></mtable></mfenced> <mo>=</mo> <mfenced close=")"
    open="("><mtable><mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mn>49</mn> <mo>+</mo>
    <mn>1</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr>
    <mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn>
    <mo>/</mo> <mn>49</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn> <mo>/</mo>
    <mn>49</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mn>49</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Solving this system amounts to *inverting* the tridiagonal matrix above, which
    is the discrete analogue of our second order derivative operator. In the continuum
    world we *integrate* the differential operator to recover *y(x)* and in the discrete
    world we *invert* the discrete operator to recover the discrete values <math alttext="y
    Subscript i"><msub><mi>y</mi> <mi>i</mi></msub></math> . Keep the curse of dimensionality
    in mind when using more points to discretize the domain.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously we must compare the discrete values <math alttext="y Subscript i"><msub><mi>y</mi>
    <mi>i</mi></msub></math> with their exact counterparts <math alttext="y left-parenthesis
    x Subscript i Baseline right-parenthesis"><mrow><mi>y</mi> <mo>(</mo> <msub><mi>x</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow></math> to see how well our finite difference
    scheme with only eight discrete points performed ([Figure 13-8](#Fig_numerical_analytical)).
    [Figure 13-9](#Fig_numerical_analytical_graph) shows the graph of the numerical
    solution (using only four discrete points) against the exact analytical solution.
  prefs: []
  type: TYPE_NORMAL
- en: '![250](assets/emai_1308.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-8\. Comparing the numerical solution to the exact analytical solution
    at each discrete point.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![250](assets/emai_1309.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-9\. Graph of the numerical solution (using only four discrete points)
    against the exact analytical solution (solid line).
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now we can use finite differences to discretize *any* differential equation
    of any order or type, on a domain in any dimension. All we have to do is discretize
    the domain and decide on finite difference schemes to approximate the derivatives
    at all the discrete points in the interior of the domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Discretize the one dimensional heat equation <math alttext="u Subscript
    t Baseline equals alpha u Subscript x x"><mrow><msub><mi>u</mi> <mi>t</mi></msub>
    <mo>=</mo> <mi>α</mi> <msub><mi>u</mi> <mrow><mi>x</mi><mi>x</mi></mrow></msub></mrow></math>
    in the interior of the interval <math alttext="x element-of left-parenthesis 0
    comma 1 right-parenthesis"><mrow><mi>x</mi> <mo>∈</mo> <mo>(</mo> <mn>0</mn> <mo>,</mo>
    <mn>1</mn> <mo>)</mo></mrow></math> . This is a second order linear partial differential
    equation on a bounded spatial domain in one dimension.'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, u=u(x,t) is a function of two variables, so our discretization scheme
    should address both coordinates. We can discretize only in space and keep time
    continuous, only in time and keep space continuous, or both in space and time.
    We always have more than one numerical route. Options are good. If we discretize
    in both space and time, then we end up with a system of algebraic equations. If
    we discretize only in space and not in time, then we end up with a system of ordinary
    differential equations. Since the PDE is linear then the discretized system is
    linear as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write down a full discrete scheme: To discretize in space, let’s use
    a second order centered difference. And to discretize in time, let’s use a forward
    difference:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartFraction u Subscript i comma j plus 1 Baseline
    minus u Subscript i comma j Baseline Over s EndFraction equals StartFraction u
    Subscript i plus 1 comma j Baseline minus 2 u Subscript i comma j Baseline plus
    u Subscript i minus 1 comma j Baseline Over h squared EndFraction for i equals
    1 comma 2 comma ellipsis comma n and j equals 1 comma 2 comma ellipsis dollar-sign"><mrow><mfrac><mrow><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>-</mo><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow> <mi>s</mi></mfrac> <mo>=</mo>
    <mfrac><mrow><msub><mi>u</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>-</mo><mn>2</mn><msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>+</mo><msub><mi>u</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub></mrow>
    <msup><mi>h</mi> <mn>2</mn></msup></mfrac> <mtext>for</mtext> <mi>i</mi> <mo>=</mo>
    <mn>1</mn> <mo>,</mo> <mn>2</mn> <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <mi>n</mi> <mtext>and</mtext>
    <mi>j</mi> <mo>=</mo> <mn>1</mn> <mo>,</mo> <mn>2</mn> <mo>,</mo> <mo>⋯</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: In such equations *u(x,t)* can be known at some initial time (*u(x,0)=g(x)*)
    and we want to know *u(x,t)* time evolves. In the numerical scheme above, the
    subscript *j* stands for discrete time, so the unknowns are <math alttext="u Subscript
    i comma j plus 1"><msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub></math>
    .
  prefs: []
  type: TYPE_NORMAL
- en: (finish this up)
  prefs: []
  type: TYPE_NORMAL
- en: Finite Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finite element methods are different than finite difference methods in the sense
    that they operate on a *weak formulation* of the PDE as opposed to operating directly
    on the PDE. A weak formulation is *weighted and averaged*, so we are thinking
    integrals and integration by parts. We will come back to this shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before discussing the general idea of finite elements, let’s observe [Figure 13-10](#Fig_finite_elements)
    a little: This shows a finite element solution of a PDE on top of a circular domain.
    The discretization of the domain uses a triangular mesh and the solution seems
    to be approximated by a piecewise linear function. We can use other polygonal
    shapes for the meshes, and we can use *smoother* functions than piecewise linear
    such as piecewise quadratic or higher degree polynomials. The tradeoff for more
    smoothness is more computation.'
  prefs: []
  type: TYPE_NORMAL
- en: '![250](assets/emai_1310.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-10\. Finite elements solution over a circular domain [(image source)](https://commons.wikimedia.org/wiki/File:Finite_element_solution.svg).
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s demonstrate how the finite element method gives a numerical approximation
    to the solution of the following PDE:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column minus
    normal upper Delta u left-parenthesis x comma y right-parenthesis equals f left-parenthesis
    x comma y right-parenthesis for left-parenthesis x comma y right-parenthesis element-of
    normal upper Omega subset-of double-struck upper R squared 2nd Row 1st Column
    Blank 2nd Column u left-parenthesis x comma y right-parenthesis equals 0 for left-parenthesis
    x comma y right-parenthesis element-of b o u n d a r y Subscript normal upper
    Omega Baseline EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mo>-</mo>
    <mi>Δ</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mtext>for</mtext> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>∈</mo> <mi>Ω</mi> <mo>⊂</mo> <msup><mi>ℝ</mi> <mn>2</mn></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn> <mtext>for</mtext> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>b</mi> <mi>o</mi>
    <mi>u</mi> <mi>n</mi> <mi>d</mi> <mi>a</mi> <mi>r</mi> <msub><mi>y</mi> <mi>Ω</mi></msub></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: This is Poisson equation (appears in electrostatics). There is no time evolution.
    f(x,y) is specified and we are looking for an unknown function u(x,y) which is
    zero at the entire boundary, and whose second derivatives <math alttext="u Subscript
    x x"><msub><mi>u</mi> <mrow><mi>x</mi><mi>x</mi></mrow></msub></math> and <math
    alttext="u Subscript y y"><msub><mi>u</mi> <mrow><mi>y</mi><mi>y</mi></mrow></msub></math>
    add up to *-f(x,y)*. This PDE is very well studied and we have formulas for its
    analytical solution, but we are only interested in the numerical approximation
    of the solution using the finite element method.
  prefs: []
  type: TYPE_NORMAL
- en: For this, we will produce an approximation of the unknown function *u(x,y)*
    that lives in an *infinite* dimensional space using a known function that lives
    in a *finite* dimensional space. Finite dimensional spaces are spanned only by
    *finitely many linearly independent functions*. We get to choose these *basis
    functions* so we make sure that our choice makes our computations very easy. We
    usually choose piecewise linear functions or piecewise polynomial functions, each
    *supported minimally on the mesh*. This means that the basis function is nonzero
    only top of one or two adjacent elements of the mesh, and zero everywhere else.
    Thus, an integration involving this function on the whole domain of the PDE would
    reduce to an integration on only one or two elements of the mesh.
  prefs: []
  type: TYPE_NORMAL
- en: 'After choosing these *basis functions* each supported on few mesh elements,
    we approximate the true solution *u(x,y)* by a linear combination of these easy
    and locally supported basis functions:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign u left-parenthesis x comma y right-parenthesis almost-equals
    u 1 b a s i s 1 left-parenthesis x comma y right-parenthesis plus u 2 b a s i
    s 2 left-parenthesis x comma y right-parenthesis plus ellipsis u Subscript n Baseline
    b a s i s Subscript n Baseline left-parenthesis x comma y right-parenthesis dollar-sign"><mrow><mi>u</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>≈</mo>
    <msub><mi>u</mi> <mn>1</mn></msub> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi>
    <msub><mi>s</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>+</mo> <msub><mi>u</mi> <mn>2</mn></msub> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <mo>⋯</mo> <msub><mi>u</mi>
    <mi>n</mi></msub> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we must find the constants <math alttext="u Subscript i"><msub><mi>u</mi>
    <mi>i</mi></msub></math> of the linear combination. Therefore, we reduced our
    problem from solving for the unknown function *u(x,y)* in the continuum to solving
    for the unknown vector of coefficients <math alttext="left-parenthesis u 1 comma
    u 2 comma ellipsis comma u Subscript n Baseline right-parenthesis"><mrow><mo>(</mo>
    <msub><mi>u</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>u</mi> <mn>2</mn></msub>
    <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <msub><mi>u</mi> <mi>n</mi></msub> <mo>)</mo></mrow></math>
    . We must choose them so that the approximation <math alttext="u 1 e l e m e n
    t 1 left-parenthesis x comma y right-parenthesis plus u 2 e l e m e n t 2 left-parenthesis
    x comma y right-parenthesis plus ellipsis u Subscript n Baseline e l e m e n t
    Subscript n Baseline left-parenthesis x comma y right-parenthesis"><mrow><msub><mi>u</mi>
    <mn>1</mn></msub> <mi>e</mi> <mi>l</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi>
    <msub><mi>t</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>+</mo> <msub><mi>u</mi> <mn>2</mn></msub> <mi>e</mi> <mi>l</mi>
    <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo>
    <mo>⋯</mo> <msub><mi>u</mi> <mi>n</mi></msub> <mi>e</mi> <mi>l</mi> <mi>e</mi>
    <mi>m</mi> <mi>e</mi> <mi>n</mi> <msub><mi>t</mi> <mi>n</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow></mrow></math> satisfies the
    PDE, in some sense. We have *n* unknowns, so we must write *n* equations and solve
    a system of *n* equations *n* unknowns. We get these from the PDE, or *its weak
    formulation*. To get a weak formulation of the PDE, we multiply it by a function
    *v(x,y)*, integrate over our domain, then use *integration by parts* to get rid
    of higher order derivatives. Remember that the less derivatives we have the closer
    to the unknown function we get. Let do this step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The original PDE is:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column minus
    normal upper Delta u left-parenthesis x comma y right-parenthesis equals f left-parenthesis
    x comma y right-parenthesis for left-parenthesis x comma y right-parenthesis element-of
    normal upper Omega subset-of double-struck upper R squared 2nd Row 1st Column
    Blank 2nd Column u left-parenthesis x comma y right-parenthesis equals 0 for left-parenthesis
    x comma y right-parenthesis element-of b o u n d a r y Subscript normal upper
    Omega Baseline EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mo>-</mo>
    <mi>Δ</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mtext>for</mtext> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>∈</mo> <mi>Ω</mi> <mo>⊂</mo> <msup><mi>ℝ</mi> <mn>2</mn></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn> <mtext>for</mtext> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>b</mi> <mi>o</mi>
    <mi>u</mi> <mi>n</mi> <mi>d</mi> <mi>a</mi> <mi>r</mi> <msub><mi>y</mi> <mi>Ω</mi></msub></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply the PDE by a function *v(x,y)* and integrate over the entire domain.
    This is a *weak formulation* of the PDE since it makes it satisfied in an integral
    form as opposed to a point by point form:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign minus integral Underscript normal upper Omega Endscripts
    normal upper Delta u left-parenthesis x comma y right-parenthesis v left-parenthesis
    x comma y right-parenthesis d x d y equals integral Underscript normal upper Omega
    Endscripts f left-parenthesis x comma y right-parenthesis v left-parenthesis x
    comma y right-parenthesis d x d y dollar-sign"><mrow><mo>-</mo> <msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>Δ</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>=</mo>
    <msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the operator <math alttext="normal upper Delta equals normal nabla
    period normal nabla"><mrow><mi>Δ</mi> <mo>=</mo> <mi>∇</mi> <mo>.</mo> <mi>∇</mi></mrow></math>
    , the dot product of two derivative operators. Integration by parts helps us get
    rid of one of the derivatives by moving it over to the other function inside the
    integral. This doesn’t come for free: In the process of doing this, it picks up
    a negative sign and another integral term that operates on the boundary of the
    domain. This new integral on the boundary integrates the product of two anti-derivatives.
    The boundary term needs the outward unit normal vector to the boundary <math alttext="ModifyingAbove
    n With right-arrow"><mover accent="true"><mi>n</mi> <mo>→</mo></mover></math>
    :'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign integral Underscript normal upper Omega Endscripts
    normal nabla u left-parenthesis x comma y right-parenthesis period normal nabla
    v left-parenthesis x comma y right-parenthesis d x d y minus integral Underscript
    b o u n d a r y Subscript normal upper Omega Baseline Endscripts v left-parenthesis
    x comma y right-parenthesis normal nabla u left-parenthesis x comma y right-parenthesis
    period ModifyingAbove n With right-arrow d s equals integral Underscript normal
    upper Omega Endscripts f left-parenthesis x comma y right-parenthesis v left-parenthesis
    x comma y right-parenthesis d x d y dollar-sign"><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub>
    <mi>∇</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>.</mo> <mi>∇</mi> <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>-</mo> <msub><mo>∫</mo>
    <mrow><mi>b</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mi>a</mi><mi>r</mi><msub><mi>y</mi>
    <mi>Ω</mi></msub></mrow></msub> <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mi>∇</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>.</mo> <mover accent="true"><mi>n</mi>
    <mo>→</mo></mover> <mi>d</mi> <mi>s</mi> <mo>=</mo> <msub><mo>∫</mo> <mi>Ω</mi></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'We can choose *v(x,y)=0* on the boundary and that makes the whole boundary
    term disappear:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign integral Underscript normal upper Omega Endscripts
    normal nabla u left-parenthesis x comma y right-parenthesis period normal nabla
    v left-parenthesis x comma y right-parenthesis d x d y equals integral Underscript
    normal upper Omega Endscripts f left-parenthesis x comma y right-parenthesis v
    left-parenthesis x comma y right-parenthesis d x d y dollar-sign"><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>∇</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi> <mi>v</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi>
    <mi>y</mi> <mo>=</mo> <msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>v</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi>
    <mi>y</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we replace *u(x,y)* with its finite dimensional approximation:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign integral Underscript normal upper Omega Endscripts
    normal nabla left-parenthesis u 1 b a s i s 1 left-parenthesis x comma y right-parenthesis
    plus u 2 b a s i s 2 left-parenthesis x comma y right-parenthesis plus ellipsis
    u Subscript n Baseline b a s i s Subscript n Baseline left-parenthesis x comma
    y right-parenthesis right-parenthesis period normal nabla v left-parenthesis x
    comma y right-parenthesis d x d y equals integral Underscript normal upper Omega
    Endscripts f left-parenthesis x comma y right-parenthesis v left-parenthesis x
    comma y right-parenthesis d x d y comma dollar-sign"><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub>
    <mi>∇</mi> <mrow><mo>(</mo> <msub><mi>u</mi> <mn>1</mn></msub> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>u</mi> <mn>2</mn></msub>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo>
    <mo>⋯</mo> <msub><mi>u</mi> <mi>n</mi></msub> <mi>b</mi> <mi>a</mi> <mi>s</mi>
    <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi> <mi>v</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>=</mo> <msub><mo>∫</mo> <mi>Ω</mi></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>,</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'which is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign integral Underscript normal upper Omega Endscripts
    left-parenthesis u 1 normal nabla b a s i s 1 left-parenthesis x comma y right-parenthesis
    plus u 2 normal nabla b a s i s 2 left-parenthesis x comma y right-parenthesis
    plus ellipsis u Subscript n Baseline normal nabla b a s i s Subscript n Baseline
    left-parenthesis x comma y right-parenthesis right-parenthesis period normal nabla
    v left-parenthesis x comma y right-parenthesis d x d y equals integral Underscript
    normal upper Omega Endscripts f left-parenthesis x comma y right-parenthesis v
    left-parenthesis x comma y right-parenthesis d x d y dollar-sign"><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mrow><mo>(</mo> <msub><mi>u</mi> <mn>1</mn></msub> <mi>∇</mi>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>1</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo>
    <msub><mi>u</mi> <mn>2</mn></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi>
    <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <mo>⋯</mo> <msub><mi>u</mi> <mi>n</mi></msub>
    <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>.</mo> <mi>∇</mi> <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>=</mo> <msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mi>v</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This is it: We can choose *n* different functions for *v(x,y)* to get *n* different
    equations in *n* unknowns (the <math alttext="u Subscript i"><msub><mi>u</mi>
    <mi>i</mi></msub></math> ’s are the unknowns). A common theme is that everytime
    we get to pick, we pick things that do not complicate our computation life. The
    easiest choices for *v(x,y)* are the *n* basis functions that we already have,
    since these produce many cancellations when inetgrated against each other (*orthogonality*),
    and when integrated against themselves produce the number 1 (*normality*). The
    basis functions that we orginially choose form an *orthonormal* set of functions.
    All for the business of making our life easier. Therefore, the *n* equations are:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column integral
    Underscript normal upper Omega Endscripts left-parenthesis u 1 normal nabla b
    a s i s 1 left-parenthesis x comma y right-parenthesis plus u 2 normal nabla b
    a s i s 2 left-parenthesis x comma y right-parenthesis plus ellipsis u Subscript
    n Baseline normal nabla b a s i s Subscript n Baseline left-parenthesis x comma
    y right-parenthesis right-parenthesis period normal nabla b a s i s 1 left-parenthesis
    x comma y right-parenthesis d x d y equals integral Underscript normal upper Omega
    Endscripts f left-parenthesis x comma y right-parenthesis b a s i s 1 left-parenthesis
    x comma y right-parenthesis d x d y 2nd Row 1st Column Blank 2nd Column integral
    Underscript normal upper Omega Endscripts left-parenthesis u 1 normal nabla b
    a s i s 1 left-parenthesis x comma y right-parenthesis plus u 2 normal nabla b
    a s i s 2 left-parenthesis x comma y right-parenthesis plus ellipsis u Subscript
    n Baseline normal nabla b a s i s Subscript n Baseline left-parenthesis x comma
    y right-parenthesis right-parenthesis period normal nabla b a s i s 2 left-parenthesis
    x comma y right-parenthesis d x d y equals integral Underscript normal upper Omega
    Endscripts f left-parenthesis x comma y right-parenthesis b a s i s 2 left-parenthesis
    x comma y right-parenthesis d x d y 3rd Row 1st Column Blank 2nd Column  ellipsis
    4th Row 1st Column Blank 2nd Column integral Underscript normal upper Omega Endscripts
    left-parenthesis u 1 normal nabla b a s i s 1 left-parenthesis x comma y right-parenthesis
    plus u 2 normal nabla b a s i s 2 left-parenthesis x comma y right-parenthesis
    plus ellipsis u Subscript n Baseline normal nabla b a s i s Subscript n Baseline
    left-parenthesis x comma y right-parenthesis right-parenthesis period normal nabla
    b a s i s Subscript n Baseline left-parenthesis x comma y right-parenthesis d
    x d y equals integral Underscript normal upper Omega Endscripts f left-parenthesis
    x comma y right-parenthesis b a s i s Subscript n Baseline left-parenthesis x
    comma y right-parenthesis d x d y EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mrow><mo>(</mo> <msub><mi>u</mi>
    <mn>1</mn></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>+</mo> <msub><mi>u</mi> <mn>2</mn></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <mo>⋯</mo> <msub><mi>u</mi>
    <mi>n</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi>
    <msub><mi>s</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>=</mo> <msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mrow><mo>(</mo> <msub><mi>u</mi> <mn>1</mn></msub> <mi>∇</mi>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>1</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo>
    <msub><mi>u</mi> <mn>2</mn></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi>
    <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <mo>⋯</mo> <msub><mi>u</mi> <mi>n</mi></msub>
    <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>=</mo> <msub><mo>∫</mo> <mi>Ω</mi></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mo>⋯</mo></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mrow><mo>(</mo>
    <msub><mi>u</mi> <mn>1</mn></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi>
    <mi>i</mi> <msub><mi>s</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>u</mi> <mn>2</mn></msub> <mi>∇</mi>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo>
    <mo>⋯</mo> <msub><mi>u</mi> <mi>n</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>x</mi> <mi>d</mi> <mi>y</mi> <mo>=</mo> <msub><mo>∫</mo> <mi>Ω</mi></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally we solve the system of *n* equations *n* unknowns, which we set in
    a linear algebra form:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign Start 4 By 4 Matrix 1st Row 1st Column integral Underscript
    normal upper Omega Endscripts normal nabla b a s i s 1 left-parenthesis x comma
    y right-parenthesis period normal nabla b a s i s 1 left-parenthesis x comma y
    right-parenthesis d x d y 2nd Column integral Underscript normal upper Omega Endscripts
    normal nabla b a s i s 2 left-parenthesis x comma y right-parenthesis period normal
    nabla b a s i s 1 left-parenthesis x comma y right-parenthesis d x d y 3rd Column  ellipsis
    4th Column integral Underscript normal upper Omega Endscripts normal nabla b a
    s i s Subscript n Baseline left-parenthesis x comma y right-parenthesis period
    normal nabla b a s i s 1 left-parenthesis x comma y right-parenthesis d x d y
    2nd Row 1st Column integral Underscript normal upper Omega Endscripts normal nabla
    b a s i s 1 left-parenthesis x comma y right-parenthesis period normal nabla b
    a s i s 2 left-parenthesis x comma y right-parenthesis d x d y 2nd Column integral
    Underscript normal upper Omega Endscripts normal nabla b a s i s 2 left-parenthesis
    x comma y right-parenthesis period normal nabla b a s i s 2 left-parenthesis x
    comma y right-parenthesis d x d y 3rd Column  ellipsis 4th Column integral Underscript
    normal upper Omega Endscripts normal nabla b a s i s Subscript n Baseline left-parenthesis
    x comma y right-parenthesis period normal nabla b a s i s 2 left-parenthesis x
    comma y right-parenthesis d x d y 3rd Row 1st Column  ellipsis 2nd Column  ellipsis
    3rd Column  ellipsis 4th Column  ellipsis 4th Row 1st Column integral Underscript
    normal upper Omega Endscripts normal nabla b a s i s 1 left-parenthesis x comma
    y right-parenthesis period normal nabla b a s i s Subscript n Baseline left-parenthesis
    x comma y right-parenthesis d x d y 2nd Column integral Underscript normal upper
    Omega Endscripts normal nabla b a s i s 2 left-parenthesis x comma y right-parenthesis
    period normal nabla b a s i s Subscript n Baseline left-parenthesis x comma y
    right-parenthesis d x d y 3rd Column  ellipsis 4th Column integral Underscript
    normal upper Omega Endscripts normal nabla b a s i s Subscript n Baseline left-parenthesis
    x comma y right-parenthesis period normal nabla b a s i s Subscript n Baseline
    left-parenthesis x comma y right-parenthesis d x d y EndMatrix Start 4 By 1 Matrix
    1st Row  u 1 2nd Row  u 2 3rd Row   ellipsis 4th Row  u Subscript n Baseline EndMatrix
    equals Start 4 By 1 Matrix 1st Row  integral Underscript normal upper Omega Endscripts
    f left-parenthesis x comma y right-parenthesis b a s i s 1 left-parenthesis x
    comma y right-parenthesis d x d y 2nd Row  integral Underscript normal upper Omega
    Endscripts f left-parenthesis x comma y right-parenthesis b a s i s 2 left-parenthesis
    x comma y right-parenthesis d x d y 3rd Row   ellipsis 4th Row  integral Underscript
    normal upper Omega Endscripts f left-parenthesis x comma y right-parenthesis b
    a s i s Subscript n Baseline left-parenthesis x comma y right-parenthesis d x
    d y EndMatrix dollar-sign"><mrow><mfenced close=")" open="("><mtable><mtr><mtd><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd> <mtd><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd> <mtd><mo>⋯</mo></mtd>
    <mtd><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr>
    <mtr><mtd><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd>
    <mtd><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd>
    <mtd><mo>⋯</mo></mtd> <mtd><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>∇</mi>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>.</mo>
    <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd><mo>⋮</mo></mtd>
    <mtd><mo>⋮</mo></mtd> <mtd><mo>⋯</mo></mtd> <mtd><mo>⋮</mo></mtd></mtr> <mtr><mtd><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd> <mtd><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd> <mtd><mo>⋯</mo></mtd>
    <mtd><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>.</mo> <mi>∇</mi> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr></mtable></mfenced>
    <mfenced close=")" open="("><mtable><mtr><mtd><msub><mi>u</mi> <mn>1</mn></msub></mtd></mtr>
    <mtr><mtd><msub><mi>u</mi> <mn>2</mn></msub></mtd></mtr> <mtr><mtd><mo>⋮</mo></mtd></mtr>
    <mtr><mtd><msub><mi>u</mi> <mi>n</mi></msub></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close=")" open="("><mtable><mtr><mtd><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>1</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd><mrow><msub><mo>∫</mo>
    <mi>Ω</mi></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr> <mtr><mtd><mo>⋮</mo></mtd></mtr>
    <mtr><mtd><mrow><msub><mo>∫</mo> <mi>Ω</mi></msub> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>b</mi> <mi>a</mi> <mi>s</mi>
    <mi>i</mi> <msub><mi>s</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Recall that we know the function *f(x,y)*, all the basis functions, and the
    domain <math alttext="normal upper Omega"><mi>Ω</mi></math> , so all we have to
    do is solve the system of equations. This system is *sparse* because most of these
    integrals are zero. We chose the basis functions with small support for this reason.
    We never want to solve a *dense* system of equations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course we have many questions and a rich literature on finite elements that
    deals with them:'
  prefs: []
  type: TYPE_NORMAL
- en: Do all PDEs have a weak formulation that allow us to do things like this? (Yes
    because we can always multiply PDEs with *v* functions and integrate by parts,
    but some PDEs have better structures to carry out simplifiying computations than
    others).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What about the *energy formulations* or *variational principles* of PDEs, are
    they related? (Yes, they are related. Look up the Ritz method. We hinted at this
    in the chapter on Operations Research and the calculus of variations, when we
    related minimizing energy functionals to solving PDEs. One thing to keep in mind
    here is that most PDEs have a weak formulation but not all of them have an energy
    minimization formulation. One of the reasons I got my Ph.D. was that I discovered
    an energy formulation for the PDE that I was working with. It was by complete
    chance. All I did was one lucky *weak formulation* followed by an integration
    by parts. Just like we did in this section. Trial and error are underestimated
    in this life).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What about Sobolov spaces, why do we study them in advanced courses on PDEs?
    (Because we need to set our functions *u*, *v*, and the basis functions, in the
    appropriate *function spaces* that tell us that all the computations and the approximations
    that we are using are valid. For example, we don’t want the involved integrals
    that contain our functions and their derivatives to blow up).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we use nonuniform meshes to adjust for the more detailed part of the domain
    such as the one in [Figure 13-11](#Fig_nonuniform_mesh)? (Yes, nothing in our
    discussion relies strictly on a uniform mesh).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![150](assets/emai_1311.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-11\. A two dimensional domain with a nonuniform triangular mesh [*(image
    source)*](https://commons.wikimedia.org/wiki/File:Example_of_2D_mesh.png).
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: How many basis functions do we need? (As many as our mesh elements).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under what conditions does the approximate solution converge to the true solution?
    (Welcome to finite element analysis).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How is this used in applications? (All the time. It started with mechanics
    and structural designs: loads, stresses, and strains; but now the finite element
    method is used to *numerically* solve all kinds of PDEs whose spatial domains
    have complex geometries).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What could go wrong? (As always, the curse of dimensionality. We need more mesh
    elements for higher resolution, so the system of equations that we end up having
    to solve grows exponenially with the number of mesh elements. No bueno. Ideally,
    we want a mesh that is not detailed in places where it doesn’t need to be and
    more detailed in more interesting parts of the domain.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What else could complicate matters? (For PDEs whose *domain evolves in time*,
    we need meshes that evolve in time accordingly).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can AI help learn an appropriate mesh given a certain geometry and PDE? (Yes,
    we will see this soon in this chapter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before moving on, we note that the finite element method is a finite dimensional
    mesh dependent method that approximates the solution of the PDE. Later in this
    chapter we will learn about meshless neural network methods.
  prefs: []
  type: TYPE_NORMAL
- en: Variational or Energy Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some PDEs are very special in the sense that their solution minimizes an energy
    functional. We say that such a PDE possesses a *variational principle*. Poisson
    equation, the one we just solved using finite elements, is one of these lucky
    PDEs. When a PDE possesses a variational principle, it opens for us another route
    to understand its solution, via studying the energy functional that it happens
    to minimize.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write Poisson equation and the energy functional that its solution minimizes,
    without going through the details of why this is the case:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column normal
    upper Delta u left-parenthesis x comma y right-parenthesis equals f left-parenthesis
    x comma y right-parenthesis for left-parenthesis x comma y right-parenthesis element-of
    normal upper Omega subset-of double-struck upper R squared 2nd Row 1st Column
    Blank 2nd Column u left-parenthesis x comma y right-parenthesis equals 0 for left-parenthesis
    x comma y right-parenthesis element-of b o u n d a r y Subscript normal upper
    Omega Baseline EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mi>Δ</mi>
    <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mtext>for</mtext> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>∈</mo> <mi>Ω</mi> <mo>⊂</mo> <msup><mi>ℝ</mi> <mn>2</mn></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn> <mtext>for</mtext> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>b</mi> <mi>o</mi>
    <mi>u</mi> <mi>n</mi> <mi>d</mi> <mi>a</mi> <mi>r</mi> <msub><mi>y</mi> <mi>Ω</mi></msub></mrow></mtd></mtr></mtable></math><math
    alttext="dollar-sign upper E left-parenthesis u left-parenthesis x comma y right-parenthesis
    right-parenthesis equals integral Underscript normal upper Omega Endscripts StartAbsoluteValue
    normal nabla u left-parenthesis x comma y right-parenthesis EndAbsoluteValue squared
    plus 2 f left-parenthesis x comma y right-parenthesis d x d y period dollar-sign"><mrow><mi>E</mi>
    <mrow><mo>(</mo> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mo>∫</mo> <mi>Ω</mi></msub>
    <msup><mrow><mo>|</mo><mi>∇</mi><mi>u</mi><mrow><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo></mrow><mo>|</mo></mrow>
    <mn>2</mn></msup> <mo>+</mo> <mn>2</mn> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi> <mi>d</mi> <mi>y</mi>
    <mo>.</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can exploit this new knowledge to numerically approximate the solution
    of the PDE: Look for an approximate minimizing scheme of the energy functional.
    Similar to the finite elements method, we project our infinite dimensional solution
    <math alttext="u left-parenthesis x comma y right-parenthesis"><mrow><mi>u</mi>
    <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow></math> onto a finite
    dimensional space, where we get to choose the basis elements:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign u left-parenthesis x comma y right-parenthesis almost-equals
    u 1 b a s i s 1 left-parenthesis x comma y right-parenthesis plus u 2 b a s i
    s 2 left-parenthesis x comma y right-parenthesis plus ellipsis u Subscript n Baseline
    b a s i s Subscript n Baseline left-parenthesis x comma y right-parenthesis dollar-sign"><mrow><mi>u</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>≈</mo>
    <msub><mi>u</mi> <mn>1</mn></msub> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi>
    <msub><mi>s</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>+</mo> <msub><mi>u</mi> <mn>2</mn></msub> <mi>b</mi> <mi>a</mi>
    <mi>s</mi> <mi>i</mi> <msub><mi>s</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <mo>⋯</mo> <msub><mi>u</mi>
    <mi>n</mi></msub> <mi>b</mi> <mi>a</mi> <mi>s</mi> <mi>i</mi> <msub><mi>s</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: and we must again solve for the numbers <math alttext="left-parenthesis u 1
    comma u 2 comma ellipsis comma u Subscript n Baseline right-parenthesis"><mrow><mo>(</mo>
    <msub><mi>u</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>u</mi> <mn>2</mn></msub>
    <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <msub><mi>u</mi> <mi>n</mi></msub> <mo>)</mo></mrow></math>
    . To do this, we plug the approximate u(x,y) into the formula of the energy functional.
    Since we know all the basis elements, this is now a *function* of <math alttext="left-parenthesis
    u 1 comma u 2 comma ellipsis comma u Subscript n Baseline right-parenthesis"><mrow><mo>(</mo>
    <msub><mi>u</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>u</mi> <mn>2</mn></msub>
    <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <msub><mi>u</mi> <mi>n</mi></msub> <mo>)</mo></mrow></math>
    , which we can minimize using standard calculus methods. Done!
  prefs: []
  type: TYPE_NORMAL
- en: This method is fairly general and introduces us smoothly into the calculus of
    variations, which is about finding optima of functionals instead of functions,
    like in normal calculus.
  prefs: []
  type: TYPE_NORMAL
- en: Monte Carlo Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now used to switching our brain to probabilistic thinking in order to
    solve deterministic problems. We did that with the stochastic gradient descent
    for minimizing loss functions, multiplication of large matrices, randomized singular
    value decomposition of a large matrix, random walks on graphs to identify communities,
    rank webpages, and other purposes. The most famous introductory examples to Monte
    Carlo methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Estimating <math alttext="pi"><mi>π</mi></math> by generating many random points
    <math alttext="left-parenthesis x Subscript r a n d o m Baseline comma y Subscript
    r a n d o m Baseline right-parenthesis"><mrow><mo>(</mo> <msub><mi>x</mi> <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub>
    <mo>,</mo> <msub><mi>y</mi> <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub>
    <mo>)</mo></mrow></math> in a unit square, and finding the proportion that lies
    inside the inscribed quarter circle of radius 1: <math alttext="x Subscript r
    a n d o m Superscript 2 Baseline plus y Subscript r a n d o m Superscript 2 Baseline
    less-than-or-equal-to 1"><mrow><msubsup><mi>x</mi> <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow>
    <mn>2</mn></msubsup> <mo>+</mo> <msubsup><mi>y</mi> <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow>
    <mn>2</mn></msubsup> <mo>≤</mo> <mn>1</mn></mrow></math> . Now we can estimate
    the probability of landing in the quarter circle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column upper
    P r o b left-parenthesis point inside the quarter circle right-parenthesis 2nd
    Row 1st Column Blank 2nd Column equals StartFraction area of quarter circle of
    radius 1 Over area of unit square EndFraction 3rd Row 1st Column Blank 2nd Column
    equals StartFraction pi Over 4 EndFraction 4th Row 1st Column Blank 2nd Column
    almost-equals StartFraction number of times point is inside the quarter circle
    Over total number of points generated EndFraction period EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><mi>P</mi> <mi>r</mi> <mi>o</mi>
    <mi>b</mi> <mo>(</mo> <mtext>point</mtext> <mtext>inside</mtext> <mtext>the</mtext>
    <mtext>quarter</mtext> <mtext>circle</mtext> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd
    columnalign="left"><mrow><mo>=</mo> <mfrac><mrow><mtext>area</mtext><mtext>of</mtext><mtext>quarter</mtext><mtext>circle</mtext><mtext>of</mtext><mtext>radius</mtext><mtext>1</mtext></mrow>
    <mrow><mtext>area</mtext><mtext>of</mtext><mtext>unit</mtext><mtext>square</mtext></mrow></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>=</mo> <mfrac><mi>π</mi> <mn>4</mn></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>≈</mo> <mfrac><mrow><mtext>number</mtext><mtext>of</mtext><mtext>times</mtext><mtext>point</mtext><mtext>is</mtext><mtext>inside</mtext><mtext>the</mtext><mtext>quarter</mtext><mtext>circle</mtext></mrow>
    <mrow><mtext>total</mtext><mtext>number</mtext><mtext>of</mtext><mtext>points</mtext><mtext>generated</mtext></mrow></mfrac>
    <mo>.</mo></mrow></mtd></mtr></mtable></math>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Estimating the integral <math alttext="integral Subscript a Superscript b Baseline
    f left-parenthesis x right-parenthesis d x"><mrow><msubsup><mo>∫</mo> <mrow><mi>a</mi></mrow>
    <mi>b</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>x</mi></mrow></math> of a nonnegative and continuous function *f(x)*
    over an interval [a,b] by generating random points <math alttext="left-parenthesis
    x Subscript r a n d o m Baseline comma y Subscript r a n d o m Baseline right-parenthesis"><mrow><mo>(</mo>
    <msub><mi>x</mi> <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub>
    <mo>,</mo> <msub><mi>y</mi> <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub>
    <mo>)</mo></mrow></math> where <math alttext="a less-than-or-equal-to x Subscript
    r a n d o m Baseline less-than-or-equal-to b"><mrow><mi>a</mi> <mo>≤</mo> <msub><mi>x</mi>
    <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub>
    <mo>≤</mo> <mi>b</mi></mrow></math> and <math alttext="0 less-than-or-equal-to
    y Subscript r a n d o m Baseline less-than-or-equal-to max left-parenthesis f
    right-parenthesis"><mrow><mn>0</mn> <mo>≤</mo> <msub><mi>y</mi> <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub>
    <mo>≤</mo> <mo form="prefix" movablelimits="true">max</mo> <mrow><mo>(</mo> <mi>f</mi>
    <mo>)</mo></mrow></mrow></math> . The value of the integral is the area under
    the graph of *f*. We can estimate it by finding the proportion of times that the
    random point lies under the graph of *f(x)*, or <math alttext="y Subscript r a
    n d o m Baseline less-than-or-equal-to f left-parenthesis x Subscript r a n d
    o m Baseline right-parenthesis"><mrow><msub><mi>y</mi> <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub>
    <mo>≤</mo> <mi>f</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub>
    <mo>)</mo></mrow></mrow></math> :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column upper
    P r o b left-parenthesis point under the graph of f right-parenthesis 3rd Column
    equals StartFraction area under the graph of f Over total area of the rectangle
    EndFraction 2nd Row 1st Column Blank 2nd Column equals StartFraction integral
    Subscript a Superscript b Baseline f left-parenthesis x right-parenthesis d x
    Over left-parenthesis b minus a right-parenthesis times m a x left-parenthesis
    f right-parenthesis EndFraction 3rd Row 1st Column Blank 2nd Column almost-equals
    StartFraction number of times point is under the graph of f Over total number
    of points generated EndFraction EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mi>P</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mo>(</mo>
    <mtext>point</mtext> <mtext>under</mtext> <mtext>the</mtext> <mtext>graph</mtext>
    <mtext>of</mtext> <mtext>f</mtext> <mo>)</mo></mrow></mtd> <mtd columnalign="right"><mrow><mo>=</mo>
    <mfrac><mrow><mtext>area</mtext><mtext>under</mtext><mtext>the</mtext><mtext>graph</mtext><mtext>of</mtext><mtext>f</mtext></mrow>
    <mrow><mtext>total</mtext><mtext>area</mtext><mtext>of</mtext><mtext>the</mtext><mtext>rectangle</mtext></mrow></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>=</mo> <mfrac><mrow><msubsup><mo>∫</mo>
    <mrow><mi>a</mi></mrow> <mi>b</mi></msubsup> <mi>f</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mi>d</mi><mi>x</mi></mrow>
    <mrow><mo>(</mo><mi>b</mi><mo>-</mo><mi>a</mi><mo>)</mo><mo>×</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>f</mi><mo>)</mo></mrow></mfrac></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>≈</mo> <mfrac><mrow><mtext>number</mtext><mtext>of</mtext><mtext>times</mtext><mtext>point</mtext><mtext>is</mtext><mtext>under</mtext><mtext>the</mtext><mtext>graph</mtext><mtext>of</mtext><mtext>f</mtext></mrow>
    <mrow><mtext>total</mtext><mtext>number</mtext><mtext>of</mtext><mtext>points</mtext><mtext>generated</mtext></mrow></mfrac></mrow></mtd></mtr></mtable></math>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Such stochastic methods to solve deterministic problems are called *Monte Carlo*
    methods because they involve repetitive games of chance, and counting proportions
    of certain outcomes, just like gambling in Monte Carlo casinos in Monaco, France.
    They could’ve been called *Las Vegas Strip* methods as well. This is analogous
    to *randomized controlled trials* to answer deterministic questions, for example
    to assess the effect of a certain drug on a given population. Another way to answer
    the same question would be a completely deterministic observational study, where
    one controls for all suspected confounding variables, and assesses the effects
    of the drug intervention.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now suppose we have a deterministic PDE and we want to find its solution using
    randomized numerical trials (Monte Carlo). To illustrate how this works, let’s
    use a simple PDE:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column normal
    upper Delta u left-parenthesis x comma y right-parenthesis equals 0 for left-parenthesis
    x comma y right-parenthesis in the unit square subset-of double-struck upper R
    squared comma 2nd Row 1st Column Blank 2nd Column u left-parenthesis x comma y
    right-parenthesis equals g left-parenthesis x comma y right-parenthesis for left-parenthesis
    x comma y right-parenthesis element-of b o u n d a r y Subscript s q u a r e Baseline
    period EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mi>Δ</mi>
    <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mn>0</mn> <mtext>for</mtext> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mtext>in</mtext> <mtext>the</mtext> <mtext>unit</mtext>
    <mtext>square</mtext> <mo>⊂</mo> <msup><mi>ℝ</mi> <mn>2</mn></msup> <mo>,</mo></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>g</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mtext>for</mtext> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>b</mi> <mi>o</mi> <mi>u</mi>
    <mi>n</mi> <mi>d</mi> <mi>a</mi> <mi>r</mi> <msub><mi>y</mi> <mrow><mi>s</mi><mi>q</mi><mi>u</mi><mi>a</mi><mi>r</mi><mi>e</mi></mrow></msub>
    <mo>.</mo></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first discretize the domain using a uniform grid, then write a finite
    difference scheme for the PDE at the interior grid points and for the boundary
    conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column StartFraction
    u Subscript i plus 1 comma j Baseline minus 2 u Subscript i comma j Baseline plus
    u Subscript i minus 1 comma j Baseline Over h squared EndFraction plus StartFraction
    u Subscript i comma j plus 1 Baseline minus 2 u Subscript i comma j Baseline plus
    u Subscript i comma j minus 1 Baseline Over h squared EndFraction equals 0 2nd
    Row 1st Column Blank 2nd Column when left-parenthesis i comma j right-parenthesis
    corresponds to an interior grid point comma 3rd Row 1st Column Blank 2nd Column
    u Subscript i prime comma j Sub Superscript prime Subscript Baseline equals g
    Subscript i prime comma j Sub Superscript prime Subscript Baseline when left-parenthesis
    i prime comma j prime right-parenthesis corresponds to a boundary point period
    EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mfrac><mrow><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub> <mo>-</mo><mn>2</mn><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub> <mo>+</mo><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>-</mo><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub></mrow>
    <msup><mi>h</mi> <mn>2</mn></msup></mfrac> <mo>+</mo> <mfrac><mrow><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>-</mo><mn>2</mn><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub> <mo>+</mo><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow>
    <msup><mi>h</mi> <mn>2</mn></msup></mfrac> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mtext>when</mtext> <mtext>(i,j)</mtext> <mtext>corresponds</mtext>
    <mtext>to</mtext> <mtext>an</mtext> <mtext>interior</mtext> <mtext>grid</mtext>
    <mtext>point</mtext> <mo>,</mo></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><msub><mi>u</mi>
    <mrow><msup><mi>i</mi> <mo>'</mo></msup> <mo>,</mo><msup><mi>j</mi> <mo>'</mo></msup></mrow></msub>
    <mo>=</mo> <msub><mi>g</mi> <mrow><msup><mi>i</mi> <mo>'</mo></msup> <mo>,</mo><msup><mi>j</mi>
    <mo>'</mo></msup></mrow></msub> <mtext>when</mtext> <mtext>(i',j')</mtext> <mtext>corresponds</mtext>
    <mtext>to</mtext> <mtext>a</mtext> <mtext>boundary</mtext> <mtext>point</mtext>
    <mo>.</mo></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal is to use the above numerical scheme to find <math alttext="u Subscript
    i comma j"><msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></math>
    for each interior point of the grid. This will be the numerical estimate of the
    true solution *u(x,y)* at that particular interior point. Let’s solve for <math
    alttext="u Subscript i comma j"><msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></math>
    :'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column u
    Subscript i comma j Baseline equals one-fourth u Subscript i plus 1 comma j Baseline
    plus one-fourth u Subscript i minus 1 comma j Baseline plus one-fourth u Subscript
    i comma j plus 1 Baseline plus one-fourth u Subscript i comma j minus 1 Baseline
    2nd Row 1st Column Blank 2nd Column when left-parenthesis i comma j right-parenthesis
    corresponds to an interior grid point comma 3rd Row 1st Column Blank 2nd Column
    u Subscript i prime comma j Sub Superscript prime Subscript Baseline equals g
    Subscript i prime comma j Sub Superscript prime Subscript Baseline when left-parenthesis
    i prime comma j prime right-parenthesis corresponds to a boundary point period
    EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><msub><mi>u</mi>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub> <mo>=</mo> <mfrac><mn>1</mn>
    <mn>4</mn></mfrac> <msub><mi>u</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>+</mo> <mfrac><mn>1</mn> <mn>4</mn></mfrac> <msub><mi>u</mi> <mrow><mi>i</mi><mo>-</mo><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>+</mo> <mfrac><mn>1</mn> <mn>4</mn></mfrac> <msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <mfrac><mn>1</mn> <mn>4</mn></mfrac> <msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mtext>when</mtext> <mtext>(i,j)</mtext> <mtext>corresponds</mtext>
    <mtext>to</mtext> <mtext>an</mtext> <mtext>interior</mtext> <mtext>grid</mtext>
    <mtext>point</mtext> <mo>,</mo></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><msub><mi>u</mi>
    <mrow><msup><mi>i</mi> <mo>'</mo></msup> <mo>,</mo><msup><mi>j</mi> <mo>'</mo></msup></mrow></msub>
    <mo>=</mo> <msub><mi>g</mi> <mrow><msup><mi>i</mi> <mo>'</mo></msup> <mo>,</mo><msup><mi>j</mi>
    <mo>'</mo></msup></mrow></msub> <mtext>when</mtext> <mtext>(i',j')</mtext> <mtext>corresponds</mtext>
    <mtext>to</mtext> <mtext>a</mtext> <mtext>boundary</mtext> <mtext>point</mtext>
    <mo>.</mo></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we interpret the above equations for a random walk setting: If
    we are at the boundary, then we know the solution, it is <math alttext="u Subscript
    i prime comma j Sub Superscript prime Subscript Baseline equals g Subscript i
    prime comma j prime"><mrow><msub><mi>u</mi> <mrow><msup><mi>i</mi> <mo>''</mo></msup>
    <mo>,</mo><msup><mi>j</mi> <mo>''</mo></msup></mrow></msub> <mo>=</mo> <msub><mi>g</mi>
    <mrow><msup><mi>i</mi> <mo>''</mo></msup> <mo>,</mo><msup><mi>j</mi> <mo>''</mo></msup></mrow></msub></mrow></math>
    . So a random walker who is following the guidance of the PDE scheme to structure
    his walk would collect his reward <math alttext="g Subscript i prime comma j prime"><msub><mi>g</mi>
    <mrow><msup><mi>i</mi> <mo>''</mo></msup> <mo>,</mo><msup><mi>j</mi> <mo>''</mo></msup></mrow></msub></math>
    at the boundary point. Moreover, the solution <math alttext="u Subscript i comma
    j"><msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></math>
    at an interior grid point (i,j) is the unweighted average of the solution at the
    four surrounding grid points. So if a random walker starts at an interior grid
    point (i,j), we will give him a 0.25 probability of wandering off to any of his
    four neighboring points, then to their neighboring point, until he hits a boundary
    grid point (i’,j’), where he collects his reward <math alttext="g Subscript i
    prime comma j prime"><msub><mi>g</mi> <mrow><msup><mi>i</mi> <mo>''</mo></msup>
    <mo>,</mo><msup><mi>j</mi> <mo>''</mo></msup></mrow></msub></math> . That would
    be only one exploration of the PDE scheme, in a way getting us a tiny piece of
    information on which boundary point contributed to the solution <math alttext="u
    Subscript i comma j"><msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></math>
    . If we repeat this process may times, say a thousand times, all starting from
    the same grid point (i,j) where we want to find the numerical solution, then we
    can count the proportion of times the random walker ended up at each of the boundary
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign p r o b left-parenthesis ending up at point left-parenthesis
    i prime comma j Superscript prime Baseline right-parenthesis right-parenthesis
    almost-equals StartFraction number of times random walker ended up at point left-parenthesis
    i prime comma j Superscript prime Baseline right-parenthesis Over total number
    of random walks starting at left-parenthesis i comma j right-parenthesis EndFraction
    dollar-sign"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mrow><mo>(</mo>
    <mtext>ending</mtext> <mtext>up</mtext> <mtext>at</mtext> <mtext>point</mtext>
    <mrow><mo>(</mo> <msup><mi>i</mi> <mo>'</mo></msup> <mo>,</mo> <msup><mi>j</mi>
    <mo>'</mo></msup> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>≈</mo> <mfrac><mrow><mtext>number</mtext><mtext>of</mtext><mtext>times</mtext><mtext>random</mtext><mtext>walker</mtext><mtext>ended</mtext><mtext>up</mtext><mtext>at</mtext><mtext>point</mtext><mo>(</mo><msup><mi>i</mi>
    <mo>'</mo></msup> <mo>,</mo><msup><mi>j</mi> <mo>'</mo></msup> <mo>)</mo></mrow>
    <mrow><mtext>total</mtext><mtext>number</mtext><mtext>of</mtext><mtext>random</mtext><mtext>walks</mtext><mtext>starting</mtext><mtext>at</mtext><mtext>(i,j)</mtext></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This will give us an estimate of his expected rewards from all the boundary
    points, which is exactly the numerical solution that what we are looking for:
    How does each boundary value play a role in the solution at the interior point.
    So the numerical solution of the PDE is:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign u Subscript i comma j Baseline equals sigma-summation
    Underscript left-parenthesis i prime comma j Superscript prime Baseline right-parenthesis
    Endscripts p r o b left-parenthesis ending up at point left-parenthesis i prime
    comma j Superscript prime Baseline right-parenthesis right-parenthesis g Subscript
    i prime comma j prime dollar-sign"><mrow><msub><mi>u</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>=</mo> <msub><mo>∑</mo> <mrow><mo>(</mo><msup><mi>i</mi> <mo>'</mo></msup>
    <mo>,</mo><msup><mi>j</mi> <mo>'</mo></msup> <mo>)</mo></mrow></msub> <mi>p</mi>
    <mi>r</mi> <mi>o</mi> <mi>b</mi> <mrow><mo>(</mo> <mtext>ending</mtext> <mtext>up</mtext>
    <mtext>at</mtext> <mtext>point</mtext> <mrow><mo>(</mo> <msup><mi>i</mi> <mo>'</mo></msup>
    <mo>,</mo> <msup><mi>j</mi> <mo>'</mo></msup> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <msub><mi>g</mi> <mrow><msup><mi>i</mi> <mo>'</mo></msup> <mo>,</mo><msup><mi>j</mi>
    <mo>'</mo></msup></mrow></msub></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: This is such a neat way of getting a numerical solution that does not involve
    solving a linear system of equations (which could be very large and undesirable).
    It is also excellent when we care about finding the solution at few points only
    as opposed to finding the solution at the entire grid.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, for each PDE we have to device the correct numerical scheme along
    with the transition probabilities of the random walker. For example, if the PDE
    had a coefficients multiplied with the second derivatives, then the random walker
    would not wander off to each of his four neighboring points with equal probability
    of 0.25\. The coefficients would introduce weights for each neighbor so we adjust
    the transition probabilities to each.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of theory, we have to prove that a walker does eventually hit the boundary
    and that the numerical solution obtained this way does converge to the true analytical
    solution of the PDE. We also have to obtain analytical estimates on how long until
    a random walk stops (on average), how fast the numerical solution converges, and
    how a numerical solution obtained this way fairs against the ones obtained from
    finite differences or finite elements in terms of accuracy, computation cost,
    and speed of convergence.
  prefs: []
  type: TYPE_NORMAL
- en: With Monte Carlo methods, sometimes we start the other way around. We device
    a simulation involving the different processes and transition rates mimicking
    some physical phenomena (such as interacting particles of a system), then we average
    that and transition to writing PDEs involving the descriptors of the system at
    hand. This is the exact opposite of starting with a PDE then devising a granular
    scale Monte Carlo simulation to solve it. We discuss this next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some Statistical Mechanics: The Wonderful Master Equation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of my favorite PDEs is *the master equation* from statistical mechanics,
    because it is one of the few PDEs out there that is able to get us from characterizing
    a system at an atomistic or molecular scale (system of particles), where the description
    is probabilistic, to the same system at a macro scale, where the description is
    deterministic. It is only logical to expect that the underlying atomistic processes
    and transitions give rise to an observed behavior at the macro scale. The very
    wise person who introduced me to statistical mechanics told me: *Isn’t our whole
    lived experience the result of the collective behavior of some massive underlying
    chemical reaction?*'
  prefs: []
  type: TYPE_NORMAL
- en: The transition from the master equation for atomistic probabilities to deterministic
    PDEs for observed quantities is neat and doesn’t feel like we cheated or made
    fuzzy assumptions, or that we have two completely disconnected models, one at
    a macro scale and another at an atomistic scale, that have nothing to do with
    each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The master equation tracks the evolution of the probability of a statistical
    system (some particles) being in some state at a certain time. We calculate the
    rate of change of the probability of the state of the system by subtracting the
    losses from the gains and accounting for transition rates between different states:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column StartFraction normal
    partial-differential upper P left-parenthesis h comma t right-parenthesis Over
    normal partial-differential t EndFraction 2nd Column equals sigma-summation Underscript
    h Superscript prime Baseline Endscripts upper P left-parenthesis h prime comma
    t right-parenthesis upper T left-parenthesis h prime right-arrow h right-parenthesis
    minus upper P left-parenthesis h comma t right-parenthesis upper T left-parenthesis
    h right-arrow h Superscript prime Baseline right-parenthesis comma 2nd Row 1st
    Column Blank 2nd Column colon equals upper L upper P comma EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mfrac><mrow><mi>∂</mi><mi>P</mi><mo>(</mo><mi>h</mi><mo>,</mo><mi>t</mi><mo>)</mo></mrow>
    <mrow><mi>∂</mi><mi>t</mi></mrow></mfrac></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <munder><mo>∑</mo> <msup><mi>h</mi> <mo>'</mo></msup></munder> <mi>P</mi> <mrow><mo>(</mo>
    <msup><mi>h</mi> <mo>'</mo></msup> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mi>T</mi>
    <mrow><mo>(</mo> <msup><mi>h</mi> <mo>'</mo></msup> <mo>→</mo> <mi>h</mi> <mo>)</mo></mrow>
    <mo>-</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>h</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mi>T</mi> <mrow><mo>(</mo> <mi>h</mi> <mo>→</mo> <msup><mi>h</mi> <mo>'</mo></msup>
    <mo>)</mo></mrow> <mo>,</mo></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mo>:</mo>
    <mo>=</mo> <mi>L</mi> <mi>P</mi> <mo>,</mo></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: where <math alttext="upper T left-parenthesis h right-arrow h prime right-parenthesis"><mrow><mi>T</mi>
    <mo>(</mo> <mi>h</mi> <mo>→</mo> <msup><mi>h</mi> <mo>'</mo></msup> <mo>)</mo></mrow></math>
    and <math alttext="upper T left-parenthesis h prime right-arrow h right-parenthesis"><mrow><mi>T</mi>
    <mo>(</mo> <msup><mi>h</mi> <mo>'</mo></msup> <mo>→</mo> <mi>h</mi> <mo>)</mo></mrow></math>
    are the transition rates from state *h* to *h’* and vice versa. We calculate these
    transition rates using the underlying physical assumptions or observations on
    the system, for example evaporation and condensation rates of atoms, diffusion
    rates, *etc.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can employ the master equation to write partial differential equations
    for the determistic descriptors of the system, by computing their expectations.
    Expectations transition us from probabilistic quantities to deterministic ones.
    Here’s how we calculate it:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign mathematical left-angle f mathematical right-angle
    equals sigma-summation Underscript h Endscripts f upper P left-parenthesis h comma
    t right-parenthesis equals sigma-summation Underscript h Endscripts f StartFraction
    e Superscript minus upper H left-parenthesis h right-parenthesis slash upper K
    upper T Baseline Over upper Z EndFraction comma dollar-sign"><mrow><mrow><mo>〈</mo>
    <mi>f</mi> <mo>〉</mo></mrow> <mo>=</mo> <msub><mo>∑</mo> <mi>h</mi></msub> <mi>f</mi>
    <mi>P</mi> <mrow><mo>(</mo> <mi>h</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mo>∑</mo> <mi>h</mi></msub> <mi>f</mi> <mfrac><msup><mi>e</mi>
    <mrow><mo>-</mo><mi>H</mi><mo>(</mo><mi>h</mi><mo>)</mo><mo>/</mo><mi>K</mi><mi>T</mi></mrow></msup>
    <mi>Z</mi></mfrac> <mo>,</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: where H(h) is the total energy and Z is the partition function. The expression
    <math alttext="StartFraction e Superscript minus upper H left-parenthesis h right-parenthesis
    slash upper K upper T Baseline Over upper Z EndFraction"><mfrac><msup><mi>e</mi>
    <mrow><mo>-</mo><mi>H</mi><mo>(</mo><mi>h</mi><mo>)</mo><mo>/</mo><mi>K</mi><mi>T</mi></mrow></msup>
    <mi>Z</mi></mfrac></math> is very common in statistical mechanics and it expresses
    the intuitive idea that states with high energy are exponentially less likely
    to occur, meaning systems prefer low energy and prefer to evolve towards the states
    that lower the total energy.
  prefs: []
  type: TYPE_NORMAL
- en: Expectation vs averaging over N repititions of a Monte Carlo simulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This expectation <math alttext="mathematical left-angle f mathematical right-angle"><mrow><mo>〈</mo>
    <mi>f</mi> <mo>〉</mo></mrow></math> is related to Monte Carlo simulations: It
    is equivalent to the limit as <math alttext="upper N right-arrow normal infinity"><mrow><mi>N</mi>
    <mo>→</mo> <mi>∞</mi></mrow></math> of the mean <math alttext="f overbar"><mover
    accent="true"><mi>f</mi> <mo>¯</mo></mover></math> of *f* after *N* repetitions
    of the Monte Carlo simulations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now compute the rate of change of the expectation of the quantity of
    interest, say <math alttext="h Subscript i"><msub><mi>h</mi> <mi>i</mi></msub></math>
    representing the height of a crystal profile (made up of atoms) at a certain site
    *i*, using the master equation:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartFraction d mathematical left-angle h Subscript
    i Baseline mathematical right-angle Over d t EndFraction equals sigma-summation
    Underscript h Endscripts h Subscript i Baseline StartFraction normal partial-differential
    upper P Over normal partial-differential t EndFraction equals sigma-summation
    Underscript h Endscripts h Subscript i Baseline upper L upper P period dollar-sign"><mrow><mfrac><mrow><mi>d</mi><mo>〈</mo><msub><mi>h</mi>
    <mi>i</mi></msub> <mo>〉</mo></mrow> <mrow><mi>d</mi><mi>t</mi></mrow></mfrac>
    <mo>=</mo> <msub><mo>∑</mo> <mi>h</mi></msub> <msub><mi>h</mi> <mi>i</mi></msub>
    <mfrac><mrow><mi>∂</mi><mi>P</mi></mrow> <mrow><mi>∂</mi><mi>t</mi></mrow></mfrac>
    <mo>=</mo> <msub><mo>∑</mo> <mi>h</mi></msub> <msub><mi>h</mi> <mi>i</mi></msub>
    <mi>L</mi> <mi>P</mi> <mo>.</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: If the system is closed, meaning if we are able to express the right hand side
    in terms of *h* and its derivatives with respect to space and time, then we obtain
    equation of motion for the expected height profile. If the system is not closed,
    then we have to make an approximation in order to close the system. We better
    make a physically plausible approximation, such as the system is near equilibrium,
    otherwise our efforts will be useless.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is coarse graining the resulting discrete equations of motion
    in order to obtain a continuum PDE model describing the crystal profile. This
    step moves us from a finite difference scheme to a continuum PDE, which is the
    reverse of the discretizing process we learned with finite differences. Using
    this process, the resulting PDE emerges directly from atomistic processes. Such
    a PDE usually looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign h Subscript t Baseline left-parenthesis ModifyingAbove
    x With right-arrow comma t right-parenthesis equals upper F left-parenthesis h
    left-parenthesis ModifyingAbove x With right-arrow comma t right-parenthesis comma
    t semicolon ModifyingAbove omega With right-arrow right-parenthesis dollar-sign"><mrow><msub><mi>h</mi>
    <mi>t</mi></msub> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo>
    <mi>h</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>t</mi> <mo>;</mo> <mover
    accent="true"><mi>ω</mi> <mo>→</mo></mover> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: where <math alttext="ModifyingAbove omega With right-arrow"><mover accent="true"><mi>ω</mi>
    <mo>→</mo></mover></math> is the set of the system’s physical parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Soon in this chapter, we will learn about using graph neural networks to simulate
    natural phenomena at the macroscopic scale directly from particle systems. This
    bypasses writing down PDEs as we did in this section. The inputs to the network
    will be the particles along with their interactions and rates of interaction,
    and the output will be the time evolution (a video, or a time sequence of graphs)
    of the system as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions As Expectations Of Underlying Random Processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For some types of PDEs, a neat way to find solutions is to formulate them as
    expectations of some underlying random processes: We simulate random paths of
    an appropriate stochastic process then compute the expectation. This allows us
    to evaluate solutions at any given space–time locations.'
  prefs: []
  type: TYPE_NORMAL
- en: To learn how to do this, we need to study the *Feynman–Kac formula* and *Itô’s
    calculus* (helps us find derivatives of functions of time dependent random variables).
    These tie PDEs and probability nicely together.
  prefs: []
  type: TYPE_NORMAL
- en: The Feynman-Kac formula (which we will not write) offers a practical way to
    solve some PDEs that have been haunted by the curse of dimensionality. For example,
    in quantitative finance, we can use the Feynman–Kac formula to efficiently calculate
    solutions to the Black–Scholes equation to price options on stocks. In quantum
    chemistry, we can use it to solve the Schrödinger equation.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming The PDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea here is simple: Maybe the PDE in a transformed space is easier to
    solve (analytically or numerically) than in the space it currently lives in. So
    we transform it in some way and wish for the best.'
  prefs: []
  type: TYPE_NORMAL
- en: Fourier Transform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Fourier transform is an integral transform from *x* space to frequency
    <math alttext="xi"><mi>ξ</mi></math> space:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign upper F period upper T left-parenthesis f left-parenthesis
    x right-parenthesis right-parenthesis equals ModifyingAbove f With caret left-parenthesis
    xi right-parenthesis equals StartFraction 1 Over StartRoot 2 pi EndRoot EndFraction
    integral Subscript negative normal infinity Superscript normal infinity Baseline
    e Superscript minus i xi x Baseline f left-parenthesis x right-parenthesis d x
    dollar-sign"><mrow><mi>F</mi> <mo>.</mo> <mi>T</mi> <mrow><mo>(</mo> <mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mover
    accent="true"><mi>f</mi> <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mfrac><mn>1</mn> <msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mfrac>
    <msubsup><mo>∫</mo> <mrow><mo>-</mo><mi>∞</mi></mrow> <mi>∞</mi></msubsup> <msup><mi>e</mi>
    <mrow><mo>-</mo><mi>i</mi><mi>ξ</mi><mi>x</mi></mrow></msup> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The inverse Fourier transform undoes the Fourier transform and brings us back
    from frequency <math alttext="xi"><mi>ξ</mi></math> space to *x* space:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign upper F period upper T Superscript negative 1 Baseline
    left-parenthesis ModifyingAbove f With caret left-parenthesis xi right-parenthesis
    right-parenthesis equals f left-parenthesis x right-parenthesis equals StartFraction
    1 Over StartRoot 2 pi EndRoot EndFraction integral Subscript negative normal infinity
    Superscript normal infinity Baseline e Superscript i xi x Baseline ModifyingAbove
    f With caret left-parenthesis xi right-parenthesis d x dollar-sign"><mrow><mi>F</mi>
    <mo>.</mo> <msup><mi>T</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mrow><mo>(</mo>
    <mover accent="true"><mi>f</mi> <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mfrac>
    <msubsup><mo>∫</mo> <mrow><mo>-</mo><mi>∞</mi></mrow> <mi>∞</mi></msubsup> <msup><mi>e</mi>
    <mrow><mi>i</mi><mi>ξ</mi><mi>x</mi></mrow></msup> <mover accent="true"><mi>f</mi>
    <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>x</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: There are tables with the Fourier transforms of many functions for our convenience.
    When these are not available, we resort to numerical methods. Beacuse the Fourier
    transform and its inverse are important for many applications, such as frequency
    analysis, signal modulation, and filtering, there are algorithms that have been
    specifically developed for its fast computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some powerful things that we need to know about the Fourier
    transform:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It strips a function down to its frequency components: The Fourier transform
    of a function tells us how much of each frequency a function has. The frequency
    spectrum of a function *f(x)* is the absolute value of its Fourier transform:
    <math alttext="StartAbsoluteValue upper F left-parenthesis xi right-parenthesis
    EndAbsoluteValue"><mrow><mo>|</mo> <mi>F</mi> <mo>(</mo> <mi>ξ</mi> <mo>)</mo>
    <mo>|</mo></mrow></math> .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It has an inverse transform that allows us to move back and forth between *x*
    space and frequency space <math alttext="xi"><mi>ξ</mi></math> .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It changes the convolution of two functions in *x* space to multiplication
    of functions in frequency <math alttext="xi"><mi>ξ</mi></math> space: <math alttext="upper
    F period upper T period left-parenthesis f asterisk g left-parenthesis x right-parenthesis
    right-parenthesis equals upper F period upper T period left-parenthesis f left-parenthesis
    x right-parenthesis right-parenthesis times upper F period upper T period left-parenthesis
    g left-parenthesis x right-parenthesis right-parenthesis equals ModifyingAbove
    f With caret left-parenthesis xi right-parenthesis ModifyingAbove g With caret
    left-parenthesis xi right-parenthesis"><mrow><mi>F</mi> <mo>.</mo> <mi>T</mi>
    <mo>.</mo> <mrow><mo>(</mo> <mi>f</mi> <mo>*</mo> <mi>g</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mo>.</mo>
    <mi>T</mi> <mo>.</mo> <mrow><mo>(</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>×</mo> <mi>F</mi> <mo>.</mo> <mi>T</mi>
    <mo>.</mo> <mrow><mo>(</mo> <mi>g</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>)</mo></mrow> <mo>=</mo> <mover accent="true"><mi>f</mi> <mo>^</mo></mover>
    <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow> <mover accent="true"><mi>g</mi>
    <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow></mrow></math>
    . This is helpful when trying to find analytical solutions for PDEs: Solving a
    PDE in *x* space boils down to solving an algebraic equation or an easier differential
    equation in <math alttext="xi"><mi>ξ</mi></math> space then using the inverse
    Fourier transform to get back to *x* space. Many of these times we are inverting
    the product of two Fourier transforms so the solution ends up being a convolution
    in *x* space. If you have encountered *Green’s functions* for analytical solutions
    before, this is one way to arrive at them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It changes differentiation in *x* to multiplication by <math alttext="i xi"><mrow><mi>i</mi>
    <mi>ξ</mi></mrow></math> , so <math alttext="upper F period upper T period left-parenthesis
    u Subscript x Baseline left-parenthesis x right-parenthesis right-parenthesis
    equals i xi upper F period upper T period left-parenthesis u left-parenthesis
    x right-parenthesis right-parenthesis equals i xi ModifyingAbove u With caret
    left-parenthesis xi right-parenthesis"><mrow><mi>F</mi> <mo>.</mo> <mi>T</mi>
    <mo>.</mo> <mrow><mo>(</mo> <msub><mi>u</mi> <mi>x</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>i</mi> <mi>ξ</mi>
    <mi>F</mi> <mo>.</mo> <mi>T</mi> <mo>.</mo> <mrow><mo>(</mo> <mi>u</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>i</mi> <mi>ξ</mi>
    <mover accent="true"><mi>u</mi> <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi>
    <mo>)</mo></mrow></mrow></math> , and <math alttext="upper F period upper T period
    left-parenthesis u Subscript x x Baseline left-parenthesis x right-parenthesis
    right-parenthesis equals minus xi squared upper F period upper T period left-parenthesis
    u left-parenthesis x right-parenthesis right-parenthesis equals minus xi squared
    ModifyingAbove u With caret left-parenthesis xi right-parenthesis"><mrow><mi>F</mi>
    <mo>.</mo> <mi>T</mi> <mo>.</mo> <mrow><mo>(</mo> <msub><mi>u</mi> <mrow><mi>x</mi><mi>x</mi></mrow></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mo>-</mo>
    <msup><mi>ξ</mi> <mn>2</mn></msup> <mi>F</mi> <mo>.</mo> <mi>T</mi> <mo>.</mo>
    <mrow><mo>(</mo> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>=</mo> <mo>-</mo> <msup><mi>ξ</mi> <mn>2</mn></msup> <mover accent="true"><mi>u</mi>
    <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow></mrow></math>
    . Getting rid of derivatives is huge. It means that differential equations in
    original space become algebraic equations in Fourier space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a linear transformation, so we can apply it separately to each term in
    a PDE. It enables us to solve linear PDEs with constant coefficients seamlessly.
    For linear PDEs with nonconstant coefficents (where the parameter depend on space),
    we can still use the Fourier transform if we are willing to get messy with series
    expansions of these coefficients. The moment we write series we have to investigate
    their convergence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use it to prove the universal approximation theorem for neural networks *(Hornik
    et al., 1989)*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use it to speed up convolutional neural networks *(Mathieu et al., 2013)*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It turns out representing PDEs in Fourier space is convenient if we want to
    train neural networks to learn PDE solutions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are also some *not so* convenient things:'
  prefs: []
  type: TYPE_NORMAL
- en: Many functions have complex valued Fourier transforms. We just learn complex
    analysis and live with that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not all functions have a Fourier transform. The involved integral operates on
    an infinite domain, so if there is no function inside the integral that compensates
    with a rapid decay to zero, the integral blows up (rendering the Fourier transform
    useless). The kernel of the Fourier transform is <math alttext="e Superscript
    minus i xi x Baseline equals cosine left-parenthesis xi x right-parenthesis minus
    i sine left-parenthesis xi x right-parenthesis"><mrow><msup><mi>e</mi> <mrow><mo>-</mo><mi>i</mi><mi>ξ</mi><mi>x</mi></mrow></msup>
    <mo>=</mo> <mo form="prefix">cos</mo> <mrow><mo>(</mo> <mi>ξ</mi> <mi>x</mi> <mo>)</mo></mrow>
    <mo>-</mo> <mi>i</mi> <mo form="prefix">sin</mo> <mrow><mo>(</mo> <mi>ξ</mi> <mi>x</mi>
    <mo>)</mo></mrow></mrow></math> . This oscillates with frequency <math alttext="xi"><mi>ξ</mi></math>
    and never decays to zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even for functions whose inverse Fourier transform (which helps us find analytic
    solutions for PDEs) exists, we sometimes do not their formula. In these cases,
    we wouldn’t be able to write an explicit analytic solution using this method.
    This is a common problem for many analytic methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They have the [Heisenburg uncertainty principle](http://math.uchicago.edu/~may/REU2021/REUPapers/Dubey.pdf)
    *The study of uncertainty principles began with Werner Heisenberg’s argument that
    it is impossible to simultaneously determine a free particle’s position and momentum
    to arbitrary precision. In quantum mechanics, the wave function of position is
    the Fourier transform of the wave function of momentum.: The most popular use
    of Fourier uncertainty principles is as a description of the natural tradeoff
    between the stability and measurability of a system, particularly quantum mechanical
    systems.. Imagining that f(x) is the probability that a particle’s position is
    x, and f(ξ) is the probability that its momentum is ξ, Heisenberg’s inequality
    gives a lower bound on how spread out these two probability distributions must
    be. The physical assumption is that position and momentum are related by Fourier
    transform. |f|2L2 ≤ 4π · |(x - xo)f|L2 · |(ξ - ξo)f|L2\. Qualitatively, this means
    a narrow function has a wide Fourier transform, and a wide function has a narrow
    Fourier transform. In either domain, a wider function means there is literally
    a wide distribution of data, so there always exists uncertainty in one domain.*'
  prefs: []
  type: TYPE_NORMAL
- en: Fourier transform vs Fourier series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should not confuse the Fourier transform with the Fourier sine and cosine
    series. The function <math alttext="sine x"><mrow><mo form="prefix">sin</mo> <mi>x</mi></mrow></math>
    does not have a Fourier transform, but its Fourier sine series is itself.
  prefs: []
  type: TYPE_NORMAL
- en: Laplace Transform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Laplace transform allows us to transform a wider class of functions than
    the Fourier transform, because its kernel <math alttext="e Superscript minus s
    t"><msup><mi>e</mi> <mrow><mo>-</mo><mi>s</mi><mi>t</mi></mrow></msup></math>
    decays to zero exponentially fast (there is no complex valued *i* in the exponent
    to mess things up). The Laplace transform operates on functions defined on <math
    alttext="left-bracket 0 comma normal infinity right-parenthesis"><mrow><mo>[</mo>
    <mn>0</mn> <mo>,</mo> <mi>∞</mi> <mo>)</mo></mrow></math> , so in PDEs, we use
    it to transform the time variable, or other variables if they range from <math
    alttext="left-bracket 0 comma normal infinity right-parenthesis"><mrow><mo>[</mo>
    <mn>0</mn> <mo>,</mo> <mi>∞</mi> <mo>)</mo></mrow></math> . So instead of solving
    the PDE directly in time domain we Laplace transform it, solve it in *s* domain,
    then inverse Laplace transform it back to time domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The formula for the Laplace transform is:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign upper L period upper T period left-parenthesis f
    left-parenthesis t right-parenthesis right-parenthesis equals ModifyingAbove f
    With caret left-parenthesis s right-parenthesis equals integral Subscript 0 Superscript
    normal infinity Baseline e Superscript minus s t Baseline f left-parenthesis t
    right-parenthesis d t dollar-sign"><mrow><mi>L</mi> <mo>.</mo> <mi>T</mi> <mo>.</mo>
    <mrow><mo>(</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>=</mo> <mover accent="true"><mi>f</mi> <mo>^</mo></mover> <mrow><mo>(</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mo>=</mo> <msubsup><mo>∫</mo> <mn>0</mn> <mi>∞</mi></msubsup>
    <msup><mi>e</mi> <mrow><mo>-</mo><mi>s</mi><mi>t</mi></mrow></msup> <mi>f</mi>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>t</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'And the formula for the inverse Laplace transform is:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign upper L period upper T period Superscript negative
    1 Baseline left-parenthesis ModifyingAbove f With caret left-parenthesis s right-parenthesis
    right-parenthesis equals f left-parenthesis t right-parenthesis equals StartFraction
    1 Over 2 pi i EndFraction integral Subscript c minus i normal infinity Superscript
    c plus i normal infinity Baseline e Superscript s t Baseline ModifyingAbove f
    With caret left-parenthesis s right-parenthesis d s dollar-sign"><mrow><mi>L</mi>
    <mo>.</mo> <mi>T</mi> <msup><mo>.</mo> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mrow><mo>(</mo> <mover accent="true"><mi>f</mi> <mo>^</mo></mover> <mrow><mo>(</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <mrow><mn>2</mn><mi>π</mi><mi>i</mi></mrow></mfrac>
    <msubsup><mo>∫</mo> <mrow><mi>c</mi><mo>-</mo><mi>i</mi><mi>∞</mi></mrow> <mrow><mi>c</mi><mo>+</mo><mi>i</mi><mi>∞</mi></mrow></msubsup>
    <msup><mi>e</mi> <mrow><mi>s</mi><mi>t</mi></mrow></msup> <mover accent="true"><mi>f</mi>
    <mo>^</mo></mover> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Just like in the case of the Fourier transform, there are tables with the Laplace
    transforms of many functions computed for our convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'We care about how the Laplace transform acts on the (time) derivatives involved
    in a PDE. It better get rid of them because how else will a PDE get us closer
    to its solution? It does:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper L period upper T left-parenthesis u Subscript t Baseline
    left-parenthesis x comma t right-parenthesis right-parenthesis equals s ModifyingAbove
    u With caret left-parenthesis x comma s right-parenthesis minus u left-parenthesis
    x comma 0 right-parenthesis"><mrow><mi>L</mi> <mo>.</mo> <mi>T</mi> <mrow><mo>(</mo>
    <msub><mi>u</mi> <mi>t</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>s</mi> <mover accent="true"><mi>u</mi>
    <mo>^</mo></mover> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mo>-</mo> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mn>0</mn> <mo>)</mo></mrow></mrow></math>
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="upper L period upper T left-parenthesis u Subscript t t Baseline
    left-parenthesis x comma t right-parenthesis right-parenthesis equals s squared
    ModifyingAbove u With caret left-parenthesis x comma s right-parenthesis minus
    s u left-parenthesis x comma 0 right-parenthesis minus u Subscript t Baseline
    left-parenthesis x comma 0 right-parenthesis"><mrow><mi>L</mi> <mo>.</mo> <mi>T</mi>
    <mrow><mo>(</mo> <msub><mi>u</mi> <mrow><mi>t</mi><mi>t</mi></mrow></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>s</mi> <mn>2</mn></msup> <mover accent="true"><mi>u</mi> <mo>^</mo></mover>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>-</mo>
    <mi>s</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mn>0</mn> <mo>)</mo></mrow>
    <mo>-</mo> <msub><mi>u</mi> <mi>t</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mn>0</mn> <mo>)</mo></mrow></mrow></math> .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we usually know the initial conditions for a PDE <math alttext="u
    left-parenthesis x comma 0 right-parenthesis"><mrow><mi>u</mi> <mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mn>0</mn> <mo>)</mo></mrow></math> and <math alttext="u Subscript
    t Baseline left-parenthesis x comma 0 right-parenthesis"><mrow><msub><mi>u</mi>
    <mi>t</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mn>0</mn> <mo>)</mo></mrow></mrow></math>
    , so the above transformations do get rid of the derivatives with respect to time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also care about the convolution to multiplication property so that we can
    transfer back algebraic expressions in *s* to PDE solutions in *t* space using
    the inverse Laplace transform. Careful here that this is a finite convolution,
    from *0* to *t*, as opposed to from <math alttext="negative normal infinity"><mrow><mo>-</mo>
    <mi>∞</mi></mrow></math> to <math alttext="normal infinity"><mi>∞</mi></math>
    like in the Fourier transform case:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper L period upper T period left-parenthesis left-parenthesis
    f asterisk g right-parenthesis left-parenthesis t right-parenthesis right-parenthesis
    equals ModifyingAbove f With caret left-parenthesis s right-parenthesis ModifyingAbove
    g With caret left-parenthesis s right-parenthesis"><mrow><mi>L</mi> <mo>.</mo>
    <mi>T</mi> <mo>.</mo> <mrow><mo>(</mo> <mrow><mo>(</mo> <mi>f</mi> <mo>*</mo>
    <mi>g</mi> <mo>)</mo></mrow> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>=</mo> <mover accent="true"><mi>f</mi> <mo>^</mo></mover> <mrow><mo>(</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mover accent="true"><mi>g</mi> <mo>^</mo></mover>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow></mrow></math> where <math alttext="left-parenthesis
    f asterisk g right-parenthesis left-parenthesis t right-parenthesis equals integral
    Subscript 0 Superscript t Baseline f left-parenthesis tau right-parenthesis g
    left-parenthesis t minus tau right-parenthesis d tau equals integral Subscript
    0 Superscript t Baseline f left-parenthesis t minus tau right-parenthesis g left-parenthesis
    tau right-parenthesis d tau period"><mrow><mrow><mo>(</mo> <mi>f</mi> <mo>*</mo>
    <mi>g</mi> <mo>)</mo></mrow> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msubsup><mo>∫</mo> <mn>0</mn> <mi>t</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo>
    <mi>τ</mi> <mo>)</mo></mrow> <mi>g</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>-</mo>
    <mi>τ</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>τ</mi> <mo>=</mo> <msubsup><mo>∫</mo>
    <mn>0</mn> <mi>t</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>-</mo>
    <mi>τ</mi> <mo>)</mo></mrow> <mi>g</mi> <mrow><mo>(</mo> <mi>τ</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>τ</mi> <mo>.</mo></mrow></math>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to the Fourier transform, the Laplace transform is a linear operator,
    so it is best used with linear PDEs.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing PDEs to algebraic equations or to ODEs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both the Fourier transform, the Laplace transform, and some other transforms,
    such as the Hankel and Mellin transforms are able to get rid of derivatives of
    the PDE in certain variables (time, space, *etc.*). What we are left with is an
    algebraic equation, if the transform acts on all the variables involved in the
    PDE, or an ordinary differential equation (ODE), if the transform acts on all
    the variables except one. The hope here is that the algebraic equations or the
    ODE are easier to solve than the original PDE, and that we can utilize known methods
    from algebra, numerics, and ODEs to solve the new equations in transformation
    variables. We will see a simple example of how this works in the following section
    on solution operators.
  prefs: []
  type: TYPE_NORMAL
- en: Solution Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now work through two simple but informative examples that illustrate the
    above transform methods, while at the same time showcasing the ideas behind solution
    operators for PDEs. These are fairly general and more importantly lay the ground
    for leveraging neural networks to solve PDEs. In addition, both examples have
    explicit analytic solutions so we can use them to test approximation or iterative
    methods for solving PDEs (including neural network methods).
  prefs: []
  type: TYPE_NORMAL
- en: The first example uses a one dimensional heat equation with constant coefficients
    on an infinite domain (this is time dependent), and the second example uses a
    two dimensional Poisson equation with constant coefficients on a bounded domain
    with a simple geometry (this is not time dependent, the solution is static in
    time).
  prefs: []
  type: TYPE_NORMAL
- en: Example Using The Heat Equation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The heat equation on an infinite one dimensional rod looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column u
    Subscript t Baseline left-parenthesis x comma t right-parenthesis equals alpha
    u Subscript x x Baseline left-parenthesis x comma t right-parenthesis for x element-of
    double-struck upper R comma t element-of left-parenthesis 0 comma normal infinity
    right-parenthesis 2nd Row 1st Column Blank 2nd Column u left-parenthesis x comma
    0 right-parenthesis equals u 0 left-parenthesis x right-parenthesis for x element-of
    double-struck upper R period EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><msub><mi>u</mi> <mi>t</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>α</mi> <msub><mi>u</mi>
    <mrow><mi>x</mi><mi>x</mi></mrow></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mtext>for</mtext> <mi>x</mi> <mo>∈</mo> <mi>ℝ</mi>
    <mo>,</mo> <mi>t</mi> <mo>∈</mo> <mrow><mo>(</mo> <mn>0</mn> <mo>,</mo> <mi>∞</mi>
    <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>u</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mn>0</mn> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mtext>for</mtext> <mi>x</mi> <mo>∈</mo> <mi>ℝ</mi> <mo>.</mo></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: Since this PDE is defined on an infinite domain in *x*, we must specify the
    far field conditions (there is no boundary so we must specify what is it that
    we think the solution function *u(x,t)* looks like when <math alttext="x right-arrow
    normal infinity"><mrow><mi>x</mi> <mo>→</mo> <mi>∞</mi></mrow></math> and <math
    alttext="x right-arrow negative normal infinity"><mrow><mi>x</mi> <mo>→</mo> <mo>-</mo>
    <mi>∞</mi></mrow></math> ). Let’s assume that these limits are zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplicity, let’s assume that the parameter <math alttext="alpha"><mi>α</mi></math>
    is constant so we can apply the Fourier transform. When applying this transform
    (with respect to *x*) to the PDE <math alttext="u Subscript t Baseline left-parenthesis
    x comma t right-parenthesis equals alpha u Subscript x x Baseline left-parenthesis
    x comma t right-parenthesis"><mrow><msub><mi>u</mi> <mi>t</mi></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>α</mi> <msub><mi>u</mi>
    <mrow><mi>x</mi><mi>x</mi></mrow></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></math> and the initial condition, we manage
    to get rid of the derivatives in *x* and simplify the PDE into an ordinary differential
    equation with only one derivative in time:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column ModifyingAbove
    u With caret Subscript t Baseline left-parenthesis xi comma t right-parenthesis
    equals minus alpha xi squared ModifyingAbove u With caret left-parenthesis xi
    comma t right-parenthesis for xi element-of double-struck upper R comma t element-of
    left-parenthesis 0 comma normal infinity right-parenthesis 2nd Row 1st Column
    Blank 2nd Column ModifyingAbove u With caret left-parenthesis xi comma 0 right-parenthesis
    equals ModifyingAbove u With caret Subscript 0 Baseline left-parenthesis xi right-parenthesis
    for xi element-of double-struck upper R period EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><msub><mover accent="true"><mi>u</mi>
    <mo>^</mo></mover> <mi>t</mi></msub> <mrow><mo>(</mo> <mi>ξ</mi> <mo>,</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mo>-</mo> <mi>α</mi> <msup><mi>ξ</mi> <mn>2</mn></msup>
    <mover accent="true"><mi>u</mi> <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi>
    <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mtext>for</mtext> <mi>ξ</mi> <mo>∈</mo>
    <mi>ℝ</mi> <mo>,</mo> <mi>t</mi> <mo>∈</mo> <mrow><mo>(</mo> <mn>0</mn> <mo>,</mo>
    <mi>∞</mi> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mi>u</mi> <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi> <mo>,</mo>
    <mn>0</mn> <mo>)</mo></mrow> <mo>=</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>^</mo></mover> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow>
    <mtext>for</mtext> <mi>ξ</mi> <mo>∈</mo> <mi>ℝ</mi> <mo>.</mo></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now easily solve this using a method from ordinary differential equations
    called separation of variables (let’s not bother with the details), obtaining
    the solution in Fourier space :'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign ModifyingAbove u With caret left-parenthesis xi comma
    t right-parenthesis equals e Superscript minus alpha xi squared t Baseline ModifyingAbove
    u With caret Subscript 0 Baseline left-parenthesis xi right-parenthesis dollar-sign"><mrow><mover
    accent="true"><mi>u</mi> <mo>^</mo></mover> <mrow><mo>(</mo> <mi>ξ</mi> <mo>,</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi> <mrow><mo>-</mo><mi>α</mi><msup><mi>ξ</mi>
    <mn>2</mn></msup> <mi>t</mi></mrow></msup> <msub><mover accent="true"><mi>u</mi>
    <mo>^</mo></mover> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>ξ</mi> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'We need the solution in *x* space not in Fourier space, so we take the inverse
    Fourier transform of the above expression, and use the knowledge that multiplications
    become convolutions when transforming between x space and Fourier space. Therefore,
    the solution in x space is:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign u left-parenthesis x comma t right-parenthesis equals
    upper F period upper T period Superscript negative 1 Baseline left-parenthesis
    e Superscript minus alpha xi squared t Baseline ModifyingAbove u With caret Subscript
    0 Baseline left-parenthesis xi right-parenthesis right-parenthesis equals upper
    F period upper T period Superscript negative 1 Baseline left-parenthesis e Superscript
    minus alpha xi squared t Baseline right-parenthesis asterisk u 0 left-parenthesis
    x right-parenthesis equals StartFraction 1 Over StartRoot 4 pi alpha t EndRoot
    EndFraction e Superscript minus StartFraction x squared Over 4 alpha t EndFraction
    Baseline asterisk u 0 left-parenthesis x right-parenthesis equals integral Subscript
    negative normal infinity Superscript normal infinity Baseline StartFraction 1
    Over StartRoot 4 pi alpha t EndRoot EndFraction e Superscript minus StartFraction
    left-parenthesis s minus x right-parenthesis squared Over 4 alpha t EndFraction
    Baseline u 0 left-parenthesis s right-parenthesis d s equals integral Subscript
    negative normal infinity Superscript normal infinity Baseline k e r n e l left-parenthesis
    s comma x semicolon t semicolon alpha right-parenthesis u 0 left-parenthesis s
    right-parenthesis d s dollar-sign"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mo>.</mo> <mi>T</mi>
    <msup><mo>.</mo> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mrow><mo>(</mo> <msup><mi>e</mi>
    <mrow><mo>-</mo><mi>α</mi><msup><mi>ξ</mi> <mn>2</mn></msup> <mi>t</mi></mrow></msup>
    <msub><mover accent="true"><mi>u</mi> <mo>^</mo></mover> <mn>0</mn></msub> <mrow><mo>(</mo>
    <mi>ξ</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mo>.</mo>
    <mi>T</mi> <msup><mo>.</mo> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mrow><mo>(</mo>
    <msup><mi>e</mi> <mrow><mo>-</mo><mi>α</mi><msup><mi>ξ</mi> <mn>2</mn></msup>
    <mi>t</mi></mrow></msup> <mo>)</mo></mrow> <mo>*</mo> <msub><mi>u</mi> <mn>0</mn></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <msqrt><mrow><mn>4</mn><mi>π</mi><mi>α</mi><mi>t</mi></mrow></msqrt></mfrac>
    <msup><mi>e</mi> <mrow><mo>-</mo><mfrac><msup><mi>x</mi> <mn>2</mn></msup> <mrow><mn>4</mn><mi>α</mi><mi>t</mi></mrow></mfrac></mrow></msup>
    <mo>*</mo> <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msubsup><mo>∫</mo> <mrow><mo>-</mo><mi>∞</mi></mrow> <mi>∞</mi></msubsup>
    <mfrac><mn>1</mn> <msqrt><mrow><mn>4</mn><mi>π</mi><mi>α</mi><mi>t</mi></mrow></msqrt></mfrac>
    <msup><mi>e</mi> <mrow><mo>-</mo><mfrac><msup><mrow><mo>(</mo><mi>s</mi><mo>-</mo><mi>x</mi><mo>)</mo></mrow>
    <mn>2</mn></msup> <mrow><mn>4</mn><mi>α</mi><mi>t</mi></mrow></mfrac></mrow></msup>
    <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi> <mo>=</mo> <msubsup><mo>∫</mo> <mrow><mo>-</mo><mi>∞</mi></mrow>
    <mi>∞</mi></msubsup> <mi>k</mi> <mi>e</mi> <mi>r</mi> <mi>n</mi> <mi>e</mi> <mi>l</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>x</mi> <mo>;</mo> <mi>t</mi> <mo>;</mo>
    <mi>α</mi> <mo>)</mo></mrow> <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The punch line from the above calculation is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The solution u(x,t) of the PDE is the integral of some kernel function <math
    alttext="k left-parenthesis s comma x semicolon t semicolon alpha right-parenthesis"><mrow><mi>k</mi>
    <mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>x</mi> <mo>;</mo> <mi>t</mi> <mo>;</mo> <mi>α</mi>
    <mo>)</mo></mrow></math> against the initial state of the solution <math alttext="u
    0 left-parenthesis s right-parenthesis"><mrow><msub><mi>u</mi> <mn>0</mn></msub>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow></mrow></math> .*'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, *the solution operator of the PDE maps the given input data, which
    in this case are the parameter <math alttext="alpha"><mi>α</mi></math> and initial
    state <math alttext="u 0 left-parenthesis x right-parenthesis"><mrow><msub><mi>u</mi>
    <mn>0</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow></mrow></math>
    , to the output which is the solution we are seeking, u(x,t), via integrating
    the initial state against some kernel function that depends on the parameter of
    the PDE (along with its dependence on space and time).*
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the formula of this kernel, or using a neural network to approximate
    it, unlocks the solution of a given PDE. We then say that the neural network *learned
    the solution operator* of the PDE.
  prefs: []
  type: TYPE_NORMAL
- en: In our simple example, we leveraged linearity and constant coefficients to incorporate
    Fourier transform methods and convolution when reverting back to real space, and
    had the luxury of working out an explicit analytic formula of the kernel of the
    integral, namely, <math alttext="k left-parenthesis s comma x semicolon t semicolon
    alpha right-parenthesis equals StartFraction 1 Over StartRoot 4 pi alpha t EndRoot
    EndFraction e Superscript minus StartFraction left-parenthesis s minus x right-parenthesis
    squared Over 4 alpha t EndFraction"><mrow><mi>k</mi> <mrow><mo>(</mo> <mi>s</mi>
    <mo>,</mo> <mi>x</mi> <mo>;</mo> <mi>t</mi> <mo>;</mo> <mi>α</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mfrac><mn>1</mn> <msqrt><mrow><mn>4</mn><mi>π</mi><mi>α</mi><mi>t</mi></mrow></msqrt></mfrac>
    <msup><mi>e</mi> <mrow><mo>-</mo><mfrac><msup><mrow><mo>(</mo><mi>s</mi><mo>-</mo><mi>x</mi><mo>)</mo></mrow>
    <mn>2</mn></msup> <mrow><mn>4</mn><mi>α</mi><mi>t</mi></mrow></mfrac></mrow></msup></mrow></math>
    , so there is no need for approximations. On a nice side note, this kernel comes
    from a time dependent Gaussian function <math alttext="upper G a u s s i a n left-parenthesis
    x semicolon t semicolon alpha right-parenthesis equals StartFraction 1 Over StartRoot
    4 pi alpha t EndRoot EndFraction e Superscript minus StartFraction x squared Over
    4 alpha t EndFraction"><mrow><mi>G</mi> <mi>a</mi> <mi>u</mi> <mi>s</mi> <mi>s</mi>
    <mi>i</mi> <mi>a</mi> <mi>n</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>;</mo> <mi>t</mi>
    <mo>;</mo> <mi>α</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>1</mn> <msqrt><mrow><mn>4</mn><mi>π</mi><mi>α</mi><mi>t</mi></mrow></msqrt></mfrac>
    <msup><mi>e</mi> <mrow><mo>-</mo><mfrac><msup><mi>x</mi> <mn>2</mn></msup> <mrow><mn>4</mn><mi>α</mi><mi>t</mi></mrow></mfrac></mrow></msup></mrow></math>
    that spreads out as time evolves. The effect of convolving this with the initial
    state of the solution has a smoothing effect that spreads out and smoothes any
    initial oscillations and spikes. We observe this smoothing with any diffusion
    process that we can visualize, such as diffusion of smoke in the air, or diffusion
    of a dye in a liquid, where the substance spreads out smoothly until we obtain
    one homogeneous looking medium.
  prefs: []
  type: TYPE_NORMAL
- en: Example Using Poisson Equation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Poisson equation on a bounded domain looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column negative
    normal nabla period left-parenthesis a left-parenthesis ModifyingAbove x With
    right-arrow right-parenthesis normal nabla u left-parenthesis ModifyingAbove x
    With right-arrow right-parenthesis right-parenthesis equals f left-parenthesis
    ModifyingAbove x With right-arrow right-parenthesis for ModifyingAbove x With
    right-arrow element-of upper D 2nd Row 1st Column Blank 2nd Column u left-parenthesis
    ModifyingAbove x With right-arrow right-parenthesis equals 0 for ModifyingAbove
    x With right-arrow at the boundary of upper D period EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><mo>-</mo> <mi>∇</mi> <mo>.</mo>
    <mrow><mo>(</mo> <mi>a</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mo>)</mo></mrow> <mi>∇</mi> <mi>u</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow> <mtext>for</mtext>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>∈</mo> <mi>D</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>u</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>)</mo></mrow> <mo>=</mo> <mn>0</mn> <mtext>for</mtext>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mtext>at</mtext> <mtext>the</mtext>
    <mtext>boundary</mtext> <mtext>of</mtext> <mtext>D.</mtext></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'When <math alttext="a left-parenthesis ModifyingAbove x With right-arrow right-parenthesis"><mrow><mi>a</mi>
    <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>)</mo></mrow></math>
    is constant and the domain is two dimensional this becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column minus
    a normal upper Delta u left-parenthesis x comma y right-parenthesis equals f left-parenthesis
    x comma y right-parenthesis for left-parenthesis x comma y right-parenthesis element-of
    upper D subset-of double-struck upper R squared 2nd Row 1st Column Blank 2nd Column
    u left-parenthesis x comma y right-parenthesis equals 0 for left-parenthesis x
    comma y right-parenthesis at the boundary of upper D comma EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><mo>-</mo> <mi>a</mi> <mi>Δ</mi>
    <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mtext>for</mtext> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>∈</mo> <mi>D</mi> <mo>⊂</mo> <msup><mi>ℝ</mi> <mn>2</mn></msup></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>u</mi> <mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo> <mo>=</mo> <mn>0</mn> <mtext>for</mtext> <mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo> <mtext>at</mtext> <mtext>the</mtext> <mtext>boundary</mtext>
    <mtext>of</mtext> <mtext>D,</mtext></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'where <math alttext="normal upper Delta u left-parenthesis x comma y right-parenthesis
    equals u Subscript x x Baseline left-parenthesis x comma y right-parenthesis plus
    u Subscript y y Baseline left-parenthesis x comma y right-parenthesis"><mrow><mi>Δ</mi>
    <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mi>u</mi> <mrow><mi>x</mi><mi>x</mi></mrow></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>u</mi>
    <mrow><mi>y</mi><mi>y</mi></mrow></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow></mrow></math> . We can employ the Fourier transform
    in *x* and *y* like we did for the heat equation (linear equation with constant
    coefficients), but let’s demonstrate the Green’s function method instead. We can
    think of the right hand side of the PDE as an aggregation in the continuum of
    impulses of intensity f(x,y) at locations (x,y). We need the *Dirac delta measure*
    <math alttext="delta Subscript left-parenthesis x comma y right-parenthesis Baseline
    left-parenthesis s comma p right-parenthesis"><mrow><msub><mi>δ</mi> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo></mrow></msub>
    <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow></mrow></math>
    to express the concept of an impulse mathematically. This is zero everywhere on
    the domain except at the point *(x,y)*, where it is infinite, and it’s total measure
    on the domain is normalized to 1\. The rationale here is that we can solve the
    PDE with the right hand side consisting of only an impulse at a certain location
    then aggregate the original solution from these. Presumably, solving the PDE with
    only an impulse as the right hand side is easier than solving it with some given
    function as the right hand side, so we will build up the solution *u(x,y)* from
    the solution *G(x,y;s,p)* of the impulse PDE. More importantly, using the Green’s
    function allows us to get an integral representation of the solution of the input
    data against a kernel (which is the Green’s function). The PDE with an impulse
    right hand side is:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column minus
    a normal upper Delta upper G left-parenthesis s comma p semicolon x comma y right-parenthesis
    equals delta Subscript left-parenthesis x comma y right-parenthesis Baseline left-parenthesis
    s comma p right-parenthesis for left-parenthesis s comma p right-parenthesis element-of
    upper D subset-of double-struck upper R squared 2nd Row 1st Column Blank 2nd Column
    upper G left-parenthesis s comma p semicolon x comma y right-parenthesis equals
    0 for left-parenthesis s comma p right-parenthesis at the boundary of upper D
    period EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mo>-</mo>
    <mi>a</mi> <mi>Δ</mi> <mi>G</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi>
    <mo>;</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>δ</mi>
    <mrow><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo></mrow></msub> <mrow><mo>(</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow> <mtext>for</mtext> <mrow><mo>(</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>D</mi> <mo>⊂</mo>
    <msup><mi>ℝ</mi> <mn>2</mn></msup></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>G</mi>
    <mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>;</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo> <mo>=</mo> <mn>0</mn> <mtext>for</mtext> <mo>(</mo> <mi>s</mi> <mo>,</mo>
    <mi>p</mi> <mo>)</mo> <mtext>at</mtext> <mtext>the</mtext> <mtext>boundary</mtext>
    <mtext>of</mtext> <mtext>D.</mtext></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now write:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign f left-parenthesis x comma y right-parenthesis equals
    integral Underscript upper D Endscripts f left-parenthesis s comma p right-parenthesis
    delta Subscript left-parenthesis x comma y right-parenthesis Baseline left-parenthesis
    s comma p right-parenthesis d s d p comma dollar-sign"><mrow><mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo>∫</mo>
    <mi>D</mi></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi>
    <mo>)</mo></mrow> <msub><mi>δ</mi> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo></mrow></msub>
    <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>s</mi> <mi>d</mi> <mi>p</mi> <mo>,</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'and the PDE as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column minus
    a normal upper Delta u left-parenthesis x comma y right-parenthesis equals integral
    Underscript upper D Endscripts f left-parenthesis s comma p right-parenthesis
    delta Subscript left-parenthesis x comma y right-parenthesis Baseline left-parenthesis
    s comma p right-parenthesis d s d p for left-parenthesis x comma y right-parenthesis
    element-of upper D subset-of double-struck upper R squared 2nd Row 1st Column
    Blank 2nd Column u left-parenthesis x comma y right-parenthesis equals 0 for left-parenthesis
    x comma y right-parenthesis at the boundary of upper D period EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><mo>-</mo> <mi>a</mi> <mi>Δ</mi>
    <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mo>∫</mo> <mi>D</mi></msub> <mi>f</mi> <mrow><mo>(</mo> <mi>s</mi>
    <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow> <msub><mi>δ</mi> <mrow><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo></mrow></msub>
    <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>s</mi> <mi>d</mi> <mi>p</mi> <mtext>for</mtext> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>D</mi> <mo>⊂</mo> <msup><mi>ℝ</mi>
    <mn>2</mn></msup></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>u</mi>
    <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo> <mo>=</mo> <mn>0</mn> <mtext>for</mtext>
    <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo> <mtext>at</mtext> <mtext>the</mtext>
    <mtext>boundary</mtext> <mtext>of</mtext> <mtext>D.</mtext></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s substitute the <math alttext="delta Subscript left-parenthesis x comma
    y right-parenthesis Baseline left-parenthesis s comma p right-parenthesis"><mrow><msub><mi>δ</mi>
    <mrow><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo></mrow></msub> <mrow><mo>(</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow></mrow></math> inside the integral
    with <math alttext="minus a normal upper Delta upper G left-parenthesis s comma
    p semicolon x comma y right-parenthesis"><mrow><mo>-</mo> <mi>a</mi> <mi>Δ</mi>
    <mi>G</mi> <mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>;</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo>)</mo></mrow></math> :'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column minus
    a normal upper Delta u left-parenthesis x comma y right-parenthesis equals integral
    Underscript upper D Endscripts minus a normal upper Delta upper G left-parenthesis
    s comma p semicolon x comma y right-parenthesis f left-parenthesis s comma p right-parenthesis
    d s d p for left-parenthesis x comma y right-parenthesis element-of upper D subset-of
    double-struck upper R squared 2nd Row 1st Column Blank 2nd Column u left-parenthesis
    x comma y right-parenthesis equals 0 for ModifyingAbove x With right-arrow at
    the boundary of upper D period EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mo>-</mo> <mi>a</mi> <mi>Δ</mi> <mi>u</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo>∫</mo>
    <mi>D</mi></msub> <mo>-</mo> <mi>a</mi> <mi>Δ</mi> <mi>G</mi> <mrow><mo>(</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>;</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mi>f</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi> <mi>d</mi> <mi>p</mi> <mtext>for</mtext> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>D</mi> <mo>⊂</mo>
    <msup><mi>ℝ</mi> <mn>2</mn></msup></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>u</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mn>0</mn> <mtext>for</mtext> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mtext>at</mtext> <mtext>the</mtext> <mtext>boundary</mtext> <mtext>of</mtext>
    <mtext>D.</mtext></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s assume that we have the right conditions to swap differentiation
    and integration:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column minus
    a normal upper Delta u left-parenthesis x comma y right-parenthesis equals minus
    a normal upper Delta left-parenthesis integral Underscript upper D Endscripts
    upper G left-parenthesis s comma p semicolon x comma y right-parenthesis f left-parenthesis
    s comma p right-parenthesis d s d p right-parenthesis for left-parenthesis x comma
    y right-parenthesis element-of upper D subset-of double-struck upper R squared
    2nd Row 1st Column Blank 2nd Column u left-parenthesis x comma y right-parenthesis
    equals 0 for left-parenthesis x comma y right-parenthesis at the boundary of upper
    D period EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mo>-</mo>
    <mi>a</mi> <mi>Δ</mi> <mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mo>-</mo> <mi>a</mi> <mi>Δ</mi> <mrow><mo>(</mo>
    <msub><mo>∫</mo> <mi>D</mi></msub> <mi>G</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo>
    <mi>p</mi> <mo>;</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mi>f</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>s</mi> <mi>d</mi> <mi>p</mi> <mo>)</mo></mrow> <mtext>for</mtext> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>∈</mo> <mi>D</mi> <mo>⊂</mo>
    <msup><mi>ℝ</mi> <mn>2</mn></msup></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>u</mi>
    <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo> <mo>=</mo> <mn>0</mn> <mtext>for</mtext>
    <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo> <mtext>at</mtext> <mtext>the</mtext>
    <mtext>boundary</mtext> <mtext>of</mtext> <mtext>D.</mtext></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally this allows us to represent the solution *u(x,y)* as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign u left-parenthesis x comma y right-parenthesis equals
    integral Underscript upper D Endscripts upper G left-parenthesis x comma y semicolon
    s comma p semicolon a right-parenthesis f left-parenthesis s comma p right-parenthesis
    d s d p dollar-sign"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>=</mo> <msub><mo>∫</mo> <mi>D</mi></msub> <mi>G</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>;</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>;</mo>
    <mi>a</mi> <mo>)</mo></mrow> <mi>f</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo>
    <mi>p</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mi>d</mi> <mi>p</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we made the dependency of G on *a* explicit in *G*, since later in
    a neural network setting to learn the solution operator of the PDE, the physical
    parameter *a* would be part of the network’s input. If the parameter *a=a(s,p)*
    is not constant then we would write *G(x,y;s,p;a(s,p))*. Analogous to the discussion
    of the previous example, the punch line from the above calculation is:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The solution u(x,y) of the PDE is the integral of some kernel function, in
    this case the Green’s function <math alttext="upper G left-parenthesis s comma
    p semicolon x comma y semicolon a right-parenthesis"><mrow><mi>G</mi> <mo>(</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>;</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>;</mo>
    <mi>a</mi> <mo>)</mo></mrow></math> against the right hand side of the PDE <math
    alttext="f left-parenthesis s comma p right-parenthesis"><mrow><mi>f</mi> <mo>(</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow></math> .*'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, *the solution operator of the PDE maps the given input data, which
    in this case are the parameter <math alttext="a"><mi>a</mi></math> and the right
    hand side of the PDE <math alttext="f left-parenthesis x comma y right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow></math> , to the
    output which is the solution we are seeking, u(x,y), via integrating the right
    hand side function against some kernel function that depends on the parameter
    of the PDE (along with its dependence on space).* In our case, the kernel of the
    solution operator is the Green’s function of the PDE, which we happen to know
    for Poisson equation on domains with an easy geometry, but not in more complex
    situations. Once again, knowing the formula of this kernel, or using a neural
    network to approximate it, unlocks the solution of a given PDE.
  prefs: []
  type: TYPE_NORMAL
- en: Fixed Point Iteration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fixed point iteration is useful to construct explicit solutions and to prove
    existence and uniqueness for certain lucky PDEs. It is such an easy and general
    method so a definite must have in our toolbox. We will write it down then immediately
    apply it to represent the solution of a *dynamical system* as a series. A dynamical
    system is an ordinary differential equation that describes the evolution in time
    of a particle or a bunch of particles (a system). Again, we would like neural
    networks to learn the solution operators of dynamical systems so this is consistent
    with our discussion above. Moreover, it is good to have the fixed point iteration
    series representation of the solution side by side to the neural network representation.
    Recall that in many mathematical settings, we can represent the same solution
    in multiple ways. A fixed point iteration series is additive while a neural network
    representation is compositional. Moreover, neural networks seem to have the advantage
    of representing the solution operators of whole families of PDEs and an overall
    wider variety which is like a dream come true in this field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fixed point iteration aims to find a fixed point of a function, or a point
    <math alttext="x Superscript asterisk"><msup><mi>x</mi> <mo>*</mo></msup></math>
    that the function maps back to iteself: <math alttext="f left-parenthesis x Superscript
    asterisk Baseline right-parenthesis equals x Superscript asterisk"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mo>*</mo></msup> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>x</mi> <mo>*</mo></msup></mrow></math> . This is not simple task since
    *f* is usually nonlinear, and most of the time we have no idea if such points
    exist for a given function. As always the case with nonlinear equations, iterative
    methods avoid *one shot* solutions and instead come up with a sequence of points
    that *hopefully, and under the right conditions* converge to the desired solution,
    in this case, the fixed point of a function.'
  prefs: []
  type: TYPE_NORMAL
- en: How does it work?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is how the fixed point iteration goes:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="x 0"><msub><mi>x</mi> <mn>0</mn></msub></math> is the starting
    point, then
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="x Subscript i plus 1 Baseline equals f left-parenthesis x Subscript
    i Baseline right-parenthesis"><mrow><msub><mi>x</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></math>
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s it. Our sequence <math alttext="StartSet x 0 comma x 1 comma x 2 ellipsis
    EndSet"><mrow><mo>{</mo> <msub><mi>x</mi> <mn>0</mn></msub> <mo>,</mo> <msub><mi>x</mi>
    <mn>1</mn></msub> <mo>,</mo> <msub><mi>x</mi> <mn>2</mn></msub> <mo>⋯</mo> <mo>}</mo></mrow></math>
    is generated by consecutive applications of *f* and looks like <math alttext="StartSet
    x 0 comma f left-parenthesis x 0 right-parenthesis comma f left-parenthesis f
    left-parenthesis x 0 right-parenthesis right-parenthesis comma f left-parenthesis
    f left-parenthesis f left-parenthesis x 0 right-parenthesis right-parenthesis
    right-parenthesis comma period period period EndSet"><mrow><mo>{</mo> <msub><mi>x</mi>
    <mn>0</mn></msub> <mo>,</mo> <mi>f</mi> <mrow><mo>(</mo> <msub><mi>x</mi> <mn>0</mn></msub>
    <mo>)</mo></mrow> <mo>,</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>f</mi> <mrow><mo>(</mo>
    <msub><mi>x</mi> <mn>0</mn></msub> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>,</mo>
    <mi>f</mi> <mrow><mo>(</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>f</mi> <mrow><mo>(</mo>
    <msub><mi>x</mi> <mn>0</mn></msub> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>,</mo> <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>}</mo></mrow></math> . Under the
    right conditions on *f* and <math alttext="x 0"><msub><mi>x</mi> <mn>0</mn></msub></math>
    , this sequence converges to a fixed point <math alttext="x Superscript asterisk"><msup><mi>x</mi>
    <mo>*</mo></msup></math> of *f* (so <math alttext="f left-parenthesis x Superscript
    asterisk Baseline right-parenthesis equals x Superscript asterisk"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <msup><mi>x</mi> <mo>*</mo></msup> <mo>)</mo></mrow> <mo>=</mo>
    <msup><mi>x</mi> <mo>*</mo></msup></mrow></math> ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that depending on *f* and the starting point, the asymptotic behavior
    of this sequence can be any of these:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Convergence to a limit <math alttext="x Superscript asterisk"><msup><mi>x</mi>
    <mo>*</mo></msup></math> : If the FPI converges, then it captures a fixed point
    (for a continuous function *f*, if the FPI converges then the limit must be a
    fixed point of *f*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Divergence to <math alttext="normal infinity"><mi>∞</mi></math> : The sequence
    grows without a bound'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Periodic behavior: The sequence oscillates between two or more values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chaotic behavior: The sequence behaves erratically, with no pattern whatsoever.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Theorems related to the fixed point iteration assert that the choice of <math
    alttext="x 0"><msub><mi>x</mi> <mn>0</mn></msub></math> , the starting point for
    the fixed point iteration, matters for whether it converges to a fixed point or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: How do we use it to solve ODEs and PDEs?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our concern for this chapter is finding solutions of differential equations,
    which are functions. So we will first re-formulate a PDE in a way that its solution
    *u* satisfies an equation that looks like *F(u)=u* (note that *F* here is an *operator*
    not a *function*), making it perfect for a fixed point iteration setting, then
    we will apply the same logic above and construct a sequence of *functions* that
    hopefully, under the right conditions, converges to the fixed point <math alttext="u
    Superscript asterisk"><msup><mi>u</mi> <mo>*</mo></msup></math> of the *operator*,
    which is the solution of the PDE that we are looking for. Note that in the previous
    discussion, we constructed a sequence of *numbers* (rather than functions) that
    hopefully, under the right conditions, converges to a fixed point of a *function*
    (rather than an operator).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s demonstrate this using a *dynamical system* setting. This is one of the
    most important, general, and well studied ordinary differential equations, which
    describes the time evolution of a point in space. It is easy in the sense that
    it is usually first order with only one derivative to get rid of, and hard in
    the sense that it is generally nonlinear. There is a habit of linearizing the
    dynamical system near a point and studying its linearized behavior. This is many
    times informative about the nonlinear behavior, but the two should not be conflated.
    Too much is known about linearized systems and not much is known about nonlinear
    systems so we need equal attention to nonlinear systems. In this section we do
    not linearize. Instead, we find approximate the solution using a series constructed
    by a fixed point iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing the initial state of the point <math alttext="ModifyingAbove u With
    right-arrow left-parenthesis t 0 right-parenthesis equals ModifyingAbove u With
    right-arrow Subscript 0"><mrow><mover accent="true"><mi>u</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <msub><mi>t</mi> <mn>0</mn></msub> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>0</mn></msub></mrow></math>
    , a solution trajectory <math alttext="ModifyingAbove u With right-arrow left-parenthesis
    t right-parenthesis"><mrow><mover accent="true"><mi>u</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math> tracks all of its
    future states. The function <math alttext="ModifyingAbove f With right-arrow left-parenthesis
    ModifyingAbove u With right-arrow left-parenthesis t right-parenthesis comma a
    left-parenthesis t right-parenthesis comma t right-parenthesis"><mrow><mover accent="true"><mi>f</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mover accent="true"><mi>u</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    specifies the evolution:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column StartFraction
    d ModifyingAbove u With right-arrow left-parenthesis t right-parenthesis Over
    d t EndFraction equals ModifyingAbove f With right-arrow left-parenthesis ModifyingAbove
    u With right-arrow left-parenthesis t right-parenthesis comma a left-parenthesis
    t right-parenthesis comma t right-parenthesis 2nd Row 1st Column Blank 2nd Column
    ModifyingAbove u With right-arrow left-parenthesis t 0 right-parenthesis equals
    ModifyingAbove u With right-arrow Subscript 0 EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mfrac><mrow><mi>d</mi><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover><mrow><mo>(</mo><mi>t</mi><mo>)</mo></mrow></mrow> <mrow><mi>d</mi><mi>t</mi></mrow></mfrac>
    <mo>=</mo> <mover accent="true"><mi>f</mi> <mo>→</mo></mover> <mrow><mo>(</mo>
    <mover accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mi>t</mi>
    <mn>0</mn></msub> <mo>)</mo></mrow> <mo>=</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>0</mn></msub></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one derivative with respect to time that we need to get rid of, so
    we integrate once with respect to time:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign ModifyingAbove u With right-arrow left-parenthesis
    t right-parenthesis equals ModifyingAbove u With right-arrow Subscript 0 Baseline
    plus integral Subscript t 0 Superscript t Baseline ModifyingAbove f With right-arrow
    left-parenthesis ModifyingAbove u With right-arrow left-parenthesis s right-parenthesis
    comma a left-parenthesis s right-parenthesis comma s right-parenthesis d s dollar-sign"><mrow><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>0</mn></msub>
    <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi> <mn>0</mn></msub></mrow>
    <mi>t</mi></msubsup> <mover accent="true"><mi>f</mi> <mo>→</mo></mover> <mrow><mo>(</mo>
    <mover accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>s</mi>
    <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s re-write the above integral equation in a form that is ripe for the
    fixed point iteration: We consider the whole right hand side as an operator whose
    input is <math alttext="ModifyingAbove u With right-arrow left-parenthesis t right-parenthesis"><mrow><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    ,'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign ModifyingAbove u With right-arrow left-parenthesis
    t right-parenthesis equals upper F left-parenthesis ModifyingAbove u With right-arrow
    left-parenthesis t right-parenthesis right-parenthesis period dollar-sign"><mrow><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <mover accent="true"><mi>u</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>.</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can generate the sequence <math alttext="StartSet ModifyingAbove u With
    right-arrow Subscript 0 Baseline left-parenthesis t right-parenthesis comma ModifyingAbove
    u With right-arrow Subscript 1 Baseline left-parenthesis t right-parenthesis comma
    ModifyingAbove u With right-arrow Subscript 2 Baseline left-parenthesis t right-parenthesis
    comma ModifyingAbove u With right-arrow Subscript 3 Baseline left-parenthesis
    t right-parenthesis comma ellipsis EndSet"><mrow><mo>{</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>,</mo> <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>1</mn></msub>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>,</mo> <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>3</mn></msub>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mo>⋯</mo> <mo>}</mo></mrow></math>
    that converges to the solution <math alttext="ModifyingAbove u With right-arrow
    left-parenthesis t right-parenthesis"><mrow><mover accent="true"><mi>u</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math> , for all time or
    for a finite amount of time, under the right conditions on *f*. The sequence looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="ModifyingAbove u With right-arrow Subscript 0 Baseline left-parenthesis
    t right-parenthesis equals ModifyingAbove u With right-arrow Subscript 0 Baseline
    left-parenthesis t right-parenthesis"><mrow><msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>0</mn></msub>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="ModifyingAbove u With right-arrow Subscript 1 Baseline left-parenthesis
    t right-parenthesis equals upper F left-parenthesis ModifyingAbove u With right-arrow
    Subscript 0 Baseline left-parenthesis t right-parenthesis right-parenthesis equals
    ModifyingAbove u With right-arrow Subscript 0 Baseline plus integral Subscript
    t 0 Superscript t Baseline ModifyingAbove f With right-arrow left-parenthesis
    ModifyingAbove u With right-arrow Subscript 0 Baseline left-parenthesis s right-parenthesis
    comma a left-parenthesis s right-parenthesis comma s right-parenthesis d s"><mrow><msub><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>1</mn></msub> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <msub><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>0</mn></msub> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>0</mn></msub> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi>
    <mn>0</mn></msub></mrow> <mi>t</mi></msubsup> <mover accent="true"><mi>f</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover>
    <mn>0</mn></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi></mrow></math>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="ModifyingAbove u With right-arrow Subscript 2 Baseline left-parenthesis
    t right-parenthesis equals upper F left-parenthesis ModifyingAbove u With right-arrow
    Subscript 1 Baseline left-parenthesis t right-parenthesis right-parenthesis equals
    ModifyingAbove u With right-arrow Subscript 0 Baseline plus integral Subscript
    t 0 Superscript t Baseline ModifyingAbove f With right-arrow left-parenthesis
    ModifyingAbove u With right-arrow Subscript 1 Baseline left-parenthesis s right-parenthesis
    comma a left-parenthesis s right-parenthesis comma s right-parenthesis d s"><mrow><msub><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>2</mn></msub> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <msub><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>1</mn></msub> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>0</mn></msub> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi>
    <mn>0</mn></msub></mrow> <mi>t</mi></msubsup> <mover accent="true"><mi>f</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover>
    <mn>1</mn></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi></mrow></math>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="ModifyingAbove u With right-arrow Subscript 3 Baseline left-parenthesis
    t right-parenthesis equals upper F left-parenthesis ModifyingAbove u With right-arrow
    Subscript 2 Baseline left-parenthesis t right-parenthesis right-parenthesis equals
    ModifyingAbove u With right-arrow Subscript 0 Baseline plus integral Subscript
    t 0 Superscript t Baseline ModifyingAbove f With right-arrow left-parenthesis
    ModifyingAbove u With right-arrow Subscript 2 Baseline left-parenthesis s right-parenthesis
    comma a left-parenthesis s right-parenthesis comma s right-parenthesis d s"><mrow><msub><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>3</mn></msub> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <msub><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mn>2</mn></msub> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>0</mn></msub> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi>
    <mn>0</mn></msub></mrow> <mi>t</mi></msubsup> <mover accent="true"><mi>f</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mover accent="true"><mi>u</mi> <mo>→</mo></mover>
    <mn>2</mn></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi></mrow></math>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and so on…
  prefs: []
  type: TYPE_NORMAL
- en: Simple but very informative example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The best examples are the ones that are simple enough to have multiple ways
    of solving them. Seeing more than one way to do the same thing at once helps solidify
    the gist of a newly learned method. Consider the very simple one dimensional and
    linear dynamical system:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column StartFraction
    d u left-parenthesis t right-parenthesis Over d t EndFraction equals u left-parenthesis
    t right-parenthesis 2nd Row 1st Column Blank 2nd Column u left-parenthesis 0 right-parenthesis
    equals 1 period EndLayout dollar-sign"><mtable displaystyle="true"><mtr><mtd columnalign="left"><mrow><mfrac><mrow><mi>d</mi><mi>u</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow>
    <mrow><mi>d</mi><mi>t</mi></mrow></mfrac> <mo>=</mo> <mi>u</mi> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>u</mi>
    <mo>(</mo> <mn>0</mn> <mo>)</mo> <mo>=</mo> <mn>1</mn> <mo>.</mo></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way to solve this is by separation of variables, where we put everything
    that has *u(t)* on one side of the equation, and everything that has *t* alone
    on the other side:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartFraction d u left-parenthesis t right-parenthesis
    Over u left-parenthesis t right-parenthesis EndFraction equals d t dollar-sign"><mrow><mfrac><mrow><mi>d</mi><mi>u</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow>
    <mrow><mi>u</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow></mfrac> <mo>=</mo> <mi>d</mi>
    <mi>t</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can integrate from *0* to *t*:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign integral Subscript 0 Superscript t Baseline StartFraction
    d u left-parenthesis s right-parenthesis Over u left-parenthesis s right-parenthesis
    EndFraction equals integral Subscript 0 Superscript t Baseline d s dollar-sign"><mrow><msubsup><mo>∫</mo>
    <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup> <mfrac><mrow><mi>d</mi><mi>u</mi><mo>(</mo><mi>s</mi><mo>)</mo></mrow>
    <mrow><mi>u</mi><mo>(</mo><mi>s</mi><mo>)</mo></mrow></mfrac> <mo>=</mo> <msubsup><mo>∫</mo>
    <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup> <mi>d</mi> <mi>s</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'We get <math alttext="ln left-parenthesis u left-parenthesis t right-parenthesis
    right-parenthesis equals t"><mrow><mo form="prefix">ln</mo> <mo>(</mo> <mi>u</mi>
    <mo>(</mo> <mi>t</mi> <mo>)</mo> <mo>)</mo> <mo>=</mo> <mi>t</mi></mrow></math>
    therefore the solution of our simple dynamical system using the separation of
    variables method is <math alttext="u left-parenthesis t right-parenthesis equals
    e Superscript t"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mi>e</mi> <mi>t</mi></msup></mrow></math> (arguably the most
    important function in mathematics). Now let’s construct a sequence of functions
    using the fixed point iteration and see if it converges to the solution <math
    alttext="u left-parenthesis t right-parenthesis equals e Superscript t"><mrow><mi>u</mi>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <msup><mi>e</mi> <mi>t</mi></msup></mrow></math>
    of the dynamical system:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="u 0 left-parenthesis t right-parenthesis equals 1"><mrow><msub><mi>u</mi>
    <mn>0</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>1</mn></mrow></math>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="u 1 left-parenthesis t right-parenthesis equals upper F left-parenthesis
    u 0 left-parenthesis t right-parenthesis right-parenthesis equals u 0 left-parenthesis
    t right-parenthesis plus integral Subscript 0 Superscript t Baseline u 0 left-parenthesis
    s right-parenthesis d s equals 1 plus integral Subscript 0 Superscript t Baseline
    1 d s equals 1 plus t"><mrow><msub><mi>u</mi> <mn>1</mn></msub> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <msub><mi>u</mi>
    <mn>0</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>+</mo> <msubsup><mo>∫</mo> <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup> <msub><mi>u</mi>
    <mn>0</mn></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi>
    <mo>=</mo> <mn>1</mn> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup>
    <mn>1</mn> <mi>d</mi> <mi>s</mi> <mo>=</mo> <mn>1</mn> <mo>+</mo> <mi>t</mi></mrow></math>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="u 2 left-parenthesis t right-parenthesis equals upper F left-parenthesis
    u 1 left-parenthesis t right-parenthesis right-parenthesis equals u 0 left-parenthesis
    t right-parenthesis plus integral Subscript 0 Superscript t Baseline u 1 left-parenthesis
    s right-parenthesis d s equals 1 plus integral Subscript 0 Superscript t Baseline
    1 plus s d s equals 1 plus t plus StartFraction t squared Over 2 EndFraction"><mrow><msub><mi>u</mi>
    <mn>2</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi>
    <mrow><mo>(</mo> <msub><mi>u</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>u</mi> <mn>0</mn></msub>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><mn>0</mn></mrow>
    <mi>t</mi></msubsup> <msub><mi>u</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <mi>s</mi>
    <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mo>=</mo> <mn>1</mn> <mo>+</mo> <msubsup><mo>∫</mo>
    <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup> <mn>1</mn> <mo>+</mo> <mi>s</mi>
    <mi>d</mi> <mi>s</mi> <mo>=</mo> <mn>1</mn> <mo>+</mo> <mi>t</mi> <mo>+</mo> <mfrac><msup><mi>t</mi>
    <mn>2</mn></msup> <mn>2</mn></mfrac></mrow></math>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="u 3 left-parenthesis t right-parenthesis equals upper F left-parenthesis
    u 2 left-parenthesis t right-parenthesis right-parenthesis equals u 0 left-parenthesis
    t right-parenthesis plus integral Subscript 0 Superscript t Baseline u 2 left-parenthesis
    s right-parenthesis d s equals 1 plus integral Subscript 0 Superscript t Baseline
    1 plus s plus StartFraction s squared Over 2 EndFraction d s equals 1 plus t plus
    StartFraction t squared Over 2 EndFraction plus StartFraction t cubed Over 3 factorial
    EndFraction"><mrow><msub><mi>u</mi> <mn>3</mn></msub> <mrow><mo>(</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi> <mrow><mo>(</mo> <msub><mi>u</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>u</mi>
    <mn>0</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>+</mo> <msubsup><mo>∫</mo>
    <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup> <msub><mi>u</mi> <mn>2</mn></msub>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mo>=</mo>
    <mn>1</mn> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup>
    <mn>1</mn> <mo>+</mo> <mi>s</mi> <mo>+</mo> <mfrac><msup><mi>s</mi> <mn>2</mn></msup>
    <mn>2</mn></mfrac> <mi>d</mi> <mi>s</mi> <mo>=</mo> <mn>1</mn> <mo>+</mo> <mi>t</mi>
    <mo>+</mo> <mfrac><msup><mi>t</mi> <mn>2</mn></msup> <mn>2</mn></mfrac> <mo>+</mo>
    <mfrac><msup><mi>t</mi> <mn>3</mn></msup> <mrow><mn>3</mn><mo>!</mo></mrow></mfrac></mrow></math>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keep going: <math alttext="u Subscript n Baseline left-parenthesis t right-parenthesis
    equals upper F left-parenthesis u Subscript n minus 1 Baseline left-parenthesis
    t right-parenthesis right-parenthesis equals u 0 left-parenthesis t right-parenthesis
    plus integral Subscript 0 Superscript t Baseline u Subscript n minus 1 Baseline
    left-parenthesis s right-parenthesis d s equals 1 plus t plus StartFraction t
    squared Over 2 EndFraction plus StartFraction t cubed Over 3 factorial EndFraction
    plus ellipsis plus StartFraction t Superscript n Baseline Over n factorial EndFraction"><mrow><msub><mi>u</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>F</mi>
    <mrow><mo>(</mo> <msub><mi>u</mi> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>u</mi>
    <mn>0</mn></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>+</mo> <msubsup><mo>∫</mo>
    <mrow><mn>0</mn></mrow> <mi>t</mi></msubsup> <msub><mi>u</mi> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mo>=</mo>
    <mn>1</mn> <mo>+</mo> <mi>t</mi> <mo>+</mo> <mfrac><msup><mi>t</mi> <mn>2</mn></msup>
    <mn>2</mn></mfrac> <mo>+</mo> <mfrac><msup><mi>t</mi> <mn>3</mn></msup> <mrow><mn>3</mn><mo>!</mo></mrow></mfrac>
    <mo>+</mo> <mo>⋯</mo> <mo>+</mo> <mfrac><msup><mi>t</mi> <mi>n</mi></msup> <mrow><mi>n</mi><mo>!</mo></mrow></mfrac></mrow></math>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As <math alttext="n right-arrow normal infinity"><mrow><mi>n</mi> <mo>→</mo>
    <mi>∞</mi></mrow></math> , the fixed point iteration converges to the series
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign u Subscript normal infinity Baseline left-parenthesis
    t right-parenthesis equals 1 plus t plus StartFraction t squared Over 2 EndFraction
    plus StartFraction t cubed Over 3 factorial EndFraction plus ellipsis plus StartFraction
    t Superscript n Baseline Over n factorial EndFraction plus ellipsis equals sigma-summation
    Underscript n equals 0 Overscript normal infinity Endscripts StartFraction t Superscript
    n Baseline Over n factorial EndFraction dollar-sign"><mrow><msub><mi>u</mi> <mi>∞</mi></msub>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mn>1</mn> <mo>+</mo>
    <mi>t</mi> <mo>+</mo> <mfrac><msup><mi>t</mi> <mn>2</mn></msup> <mn>2</mn></mfrac>
    <mo>+</mo> <mfrac><msup><mi>t</mi> <mn>3</mn></msup> <mrow><mn>3</mn><mo>!</mo></mrow></mfrac>
    <mo>+</mo> <mo>⋯</mo> <mo>+</mo> <mfrac><msup><mi>t</mi> <mi>n</mi></msup> <mrow><mi>n</mi><mo>!</mo></mrow></mfrac>
    <mo>+</mo> <mo>⋯</mo> <mo>=</mo> <msubsup><mo>∑</mo> <mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow>
    <mi>∞</mi></msubsup> <mfrac><msup><mi>t</mi> <mi>n</mi></msup> <mrow><mi>n</mi><mo>!</mo></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: which is the power series expansion of <math alttext="u left-parenthesis t right-parenthesis
    equals e Superscript t"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mi>e</mi> <mi>t</mi></msup></mrow></math> , the same solution
    we arrived at using separation of variables (albeit in different form). Cool.
  prefs: []
  type: TYPE_NORMAL
- en: When we use this iterative way to construct a solution of a dynamical system,
    or of a PDE reformulated as a dynamical system or in a way that is fit for a fixed
    point iteration (*u=F(u)*), we call it *Picard’s iteration*. It is simple and
    arrives at the solution (when it converges) in steps.
  prefs: []
  type: TYPE_NORMAL
- en: Where is the complication?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Why don’t we use *Picard’s iteration* to construct solutions of *all* dynamical
    systems and of *all* PDEs that we are able to reformulate into a form fit for
    fixed point iteration? As always, the answer is the curse of dimensionality. Even
    for our very simple *one dimensional* and linear example, each Picard iteration
    step involves evaluating an integral, which for more complex problems we have
    to evaluate numerically. For example, for dynamical systems representing the evolution
    and interactions of many particles, this gets multiplied by the number of particles.
    Overall in the ODE and PDE literature, there is a limited number of cases where
    practical algorithms are available for high dimensional settings.
  prefs: []
  type: TYPE_NORMAL
- en: Recent successes!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'That said, a recent method for finding explicit solutions for high dimensional
    nonlinear parabolic PDEs and backward stochastic differential equations based
    on Picard’s iteration has been quite successful in finding explicit solutions
    for high dimensional PDEs arising in real life physics and finance applications.
    [The paper’s (2017)](https://arxiv.org/abs/1708.03223) abstract is insightful:
    *Parabolic partial differential equations (PDEs) and backward stochastic differential
    equations (BSDEs) are key ingredients in a number of models in physics and financial
    engineering. In particular, parabolic PDEs and BSDEs are fundamental tools in
    the state-of-the-art pricing and hedging of financial derivatives. The PDEs and
    BSDEs appearing in such applications are often high-dimensional and nonlinear.
    Since explicit solutions of such PDEs and BSDEs are typically not available, it
    is a very active topic of research to solve such PDEs and BSDEs approximately.
    In the recent article [E, W., Hutzenthaler, M., Jentzen, A., and Kruse, T. Linear
    scaling algorithms for solving high-dimensional nonlinear parabolic differential
    equations. arXiv:1607.03295 (2017)] we proposed a family of approximation methods
    based on Picard approximations and multilevel Monte Carlo methods and showed under
    suitable regularity assumptions on the exact solution for semilinear heat equations
    that the computational complexity is bounded by <math alttext="upper O left-parenthesis
    d epsilon Superscript minus left-parenthesis 4 plus delta right-parenthesis Baseline
    right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <mi>d</mi> <msup><mi>ϵ</mi> <mrow><mo>-</mo><mo>(</mo><mn>4</mn><mo>+</mo><mi>δ</mi><mo>)</mo></mrow></msup>
    <mo>)</mo></mrow></math> for any <math alttext="delta element-of left-parenthesis
    0 comma normal infinity right-parenthesis"><mrow><mi>δ</mi> <mo>∈</mo> <mo>(</mo>
    <mn>0</mn> <mo>,</mo> <mi>∞</mi> <mo>)</mo></mrow></math> , where d is the dimensionality
    of the problem and <math alttext="epsilon element-of left-parenthesis 0 comma
    normal infinity right-parenthesis"><mrow><mi>ϵ</mi> <mo>∈</mo> <mo>(</mo> <mn>0</mn>
    <mo>,</mo> <mi>∞</mi> <mo>)</mo></mrow></math> is the prescribed accuracy. In
    this paper, we test the applicability of this algorithm on a variety of 100-dimensional
    nonlinear PDEs that arise in physics and finance by means of numerical simulations
    presenting approximation accuracy against runtime. The simulation results for
    these 100-dimensional example PDEs are very satisfactory in terms of accuracy
    and speed. In addition, we also provide a review of other approximation methods
    for nonlinear PDEs and BSDEs from the literature.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the stage for deep learning for PDEs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before leaving this section, let’s set the stage for solving ODEs and PDEs
    in the context of deep learning, in particular, for *deep operator networks*.
    We’ll keep our one dimensional dynamical system example, but this time we highlight
    the dependence on the physical parameters *a(t)*, and make it slightly more general
    by adding another explicit dependence on time:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column StartFraction
    d u left-parenthesis t right-parenthesis Over d t EndFraction equals ModifyingAbove
    f With right-arrow left-parenthesis u left-parenthesis t right-parenthesis comma
    a left-parenthesis t right-parenthesis comma t right-parenthesis 2nd Row 1st Column
    Blank 2nd Column ModifyingAbove u With right-arrow left-parenthesis t 0 right-parenthesis
    equals ModifyingAbove u With right-arrow Subscript 0 EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><mfrac><mrow><mi>d</mi><mi>u</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow>
    <mrow><mi>d</mi><mi>t</mi></mrow></mfrac> <mo>=</mo> <mover accent="true"><mi>f</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>u</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mover
    accent="true"><mi>u</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mi>t</mi>
    <mn>0</mn></msub> <mo>)</mo></mrow> <mo>=</mo> <msub><mover accent="true"><mi>u</mi>
    <mo>→</mo></mover> <mn>0</mn></msub></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'As before we integrate once with respect to time:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign u left-parenthesis t right-parenthesis equals u 0
    plus integral Subscript t 0 Superscript t Baseline f left-parenthesis u left-parenthesis
    s right-parenthesis comma a left-parenthesis s right-parenthesis comma s right-parenthesis
    d s dollar-sign"><mrow><mi>u</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <msub><mi>u</mi> <mn>0</mn></msub> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi>
    <mn>0</mn></msub></mrow> <mi>t</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo> <mi>u</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi>
    <mi>s</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of a neural network is to take data as input, do something to it,
    then give us an output that we care for. For an ODE or a PDE, of course the output
    that we care for is the solution <math alttext="u left-parenthesis t right-parenthesis"><mrow><mi>u</mi>
    <mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></math> . Let’s write this solution as
    the output of some operator *G* that takes the given data of an ODE or PDE as
    input. In our dynamical system case, the input data is the function *a(t)* representing
    the physical parameters of the dynamical system. Note that we do not need to input
    the right hand side function *f* of the dynamical system. This is implicit in
    the training data, which now looks like the pairs *(training input,training output)*=
    <math alttext="left-parenthesis a left-parenthesis t right-parenthesis comma u
    left-parenthesis t right-parenthesis right-parenthesis"><mrow><mo>(</mo> <mi>a</mi>
    <mo>(</mo> <mi>t</mi> <mo>)</mo> <mo>,</mo> <mi>u</mi> <mo>(</mo> <mi>t</mi> <mo>)</mo>
    <mo>)</mo></mrow></math> . By not inputing *f*, in a way we are saying: I don’t
    care about the exact form of the ODE or PDE that this behavior comes from, but
    I am able to *learn* what the system is doing regardless. This is the epitome
    of machine learning: No need to encode the rules that the system obeys, the model
    can still emulate it if it observes enough instances of it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write the solution <math alttext="u left-parenthesis t right-parenthesis
    equals upper G left-parenthesis a left-parenthesis t right-parenthesis right-parenthesis"><mrow><mi>u</mi>
    <mo>(</mo> <mi>t</mi> <mo>)</mo> <mo>=</mo> <mi>G</mi> <mo>(</mo> <mi>a</mi> <mo>(</mo>
    <mi>t</mi> <mo>)</mo> <mo>)</mo></mrow></math> where the *solution operator G*
    is to be learned using a neural network. Hold this notation and thought till later
    in this chapter when we discuss neural operator networks. Plugging <math alttext="u
    left-parenthesis t right-parenthesis equals upper G left-parenthesis a left-parenthesis
    t right-parenthesis right-parenthesis"><mrow><mi>u</mi> <mo>(</mo> <mi>t</mi>
    <mo>)</mo> <mo>=</mo> <mi>G</mi> <mo>(</mo> <mi>a</mi> <mo>(</mo> <mi>t</mi> <mo>)</mo>
    <mo>)</mo></mrow></math> into the integral equation above we find that the solution
    operator, which we want to learn using a neural network satisfies:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign upper G left-parenthesis a left-parenthesis t right-parenthesis
    right-parenthesis equals u 0 plus integral Subscript t 0 Superscript t Baseline
    f left-parenthesis upper G left-parenthesis a left-parenthesis s right-parenthesis
    right-parenthesis comma a left-parenthesis s right-parenthesis comma s right-parenthesis
    d s period dollar-sign"><mrow><mi>G</mi> <mrow><mo>(</mo> <mi>a</mi> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <msub><mi>u</mi> <mn>0</mn></msub>
    <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi> <mn>0</mn></msub></mrow>
    <mi>t</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo> <mi>G</mi> <mrow><mo>(</mo> <mi>a</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi> <mo>.</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: We just wrote an integral equation that we will not do anything with. It just
    shows the *true* property that the entity *G(a(t))* that we care for satisfies.
    In the discussion above we approximated this using a Picard’s iteration, and in
    the new era of deep learning we approximate it using a deep operator network (more
    on this soon). This deep learning approach is computationally more efficient,
    if we include the Fourier transform to speed up the computations. Moreover, the
    deep learning approach is more widely encompassing, in the sense that it applies
    to more PDEs and ODEs than just dynamical systems. A dynamical system is easy
    to integrate once and obtain a representation that gets us closer to the solution,
    which is not the case for many ODEs and PDEs.
  prefs: []
  type: TYPE_NORMAL
- en: Mesh independence and different resolutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One final note: An input and output pair for a neural network learning the
    solution of our dynamical system looks like: *(training input,training output)*=
    <math alttext="left-parenthesis a left-parenthesis t right-parenthesis comma u
    left-parenthesis t right-parenthesis right-parenthesis"><mrow><mo>(</mo> <mi>a</mi>
    <mo>(</mo> <mi>t</mi> <mo>)</mo> <mo>,</mo> <mi>u</mi> <mo>(</mo> <mi>t</mi> <mo>)</mo>
    <mo>)</mo></mrow></math> . Since machines take numerical values only and not functions,
    we must discretize when we implement this. Here’s the pretty thing that differentiates
    *operators acting on functions* from *functions acting on points* and gives neural
    operator networks their *mesh independence* feature: *a(t)* and *u(t)* do not
    have to be discretized at the same values of *t*. All we care for is to map one
    function to another, so we can think of discretized *a(t)* as a vector mapped
    to another vector which is the discretized *u(t)*, not necessarily at the same
    points or not even of the same size. For the same reason, we can train the network
    at a given resolution then make predictions at *another* resolution. This is great
    for the field of ODEs and PDEs where the quality of numerical solutions have always
    been limited by the resolution of the employed discretization.'
  prefs: []
  type: TYPE_NORMAL
- en: AI For PDEs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After surveying the main concerns and the basic approaches for solving PDEs,
    we are finally ready to discuss AI as it relates to PDEs, instead of only hinting
    at it or setting its stage here and there. We want to distinguish between few
    different ways in which deep learning has stepped into the PDE community:'
  prefs: []
  type: TYPE_NORMAL
- en: Deep learning to learn the PDE’s physical parameter values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deep learning to learn two dimensional and three dimensional meshes for numerical
    simulations and solid modeling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deep learning to learn a PDE’s solution operator: A neural network learns a
    map between two *infinite dimensional* spaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deep learning to bypass PDEs, and simulate natural phenomena directly from observing
    data (particle systems and their interactions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deep Learning To Learn Physical Parameter Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use neural networks to infer the parameters of a PDE model and their
    uncertainties. We would get training data from experiments (real or synthetic
    via simulations of well known phenomena with known parameters). This training
    data would be labeled with the parameter values, so the neural network would learn
    to map a certain PDE’s initial setting to appropriate parameter values, leading
    to more accurate modeling results. Historically, parameters that couldn’t be directly
    measured had to be guessed or hand tuned to fit some observed behavior, a practice
    that undermines the whole modeling process. This simple application of deep learning
    helps the PDE modeling community tremendously, because it brings more authenticity
    to their results. We can now learn parameter values from labeled images of experiments,
    or recorded audio, and other unstructured or very high dimensional data. Once
    trained, the neural networks can estimate parameters and uncertainties for any
    input data with similar settings. This poster has a nice and simple example that
    uses deep learning to predict the parameters of the velocity field for the G-equation
    (which models the combustion process) using flame front image data: [Bayesian
    Inference in Physics-Based Nonlinear Flame Models](https://openreview.net/attachment?id=WppGnva0Qm0&name=conference_poster).'
  prefs: []
  type: TYPE_NORMAL
- en: Deep Learning To Learn Meshes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned in this chapter that generating a mesh is an integral part of the
    finite element method, which in turn finds numerical solutions for a wide array
    of PDEs modeling natural phenomena with complex domain geometries. The quality
    of the underlying mesh affects the quality of the numerical solution. The finer
    the mesh, the more of the true solution it is likely to capture, but the more
    computational cost it incurs. An ideal mesh would be dense where the error between
    the numerical solution and the true solution is more likely to be high, and coarse
    where the error is low, hence preserving fedelity while keeping the overall computational
    cost manageable ([Figure 13-12](#Fig_meshing)).
  prefs: []
  type: TYPE_NORMAL
- en: '![250](assets/emai_1312.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-12\. Nonuniform mesh on the left vs uniform mesh on the right. A mesh
    needs to be finer where the error is large ([image source](https://arxiv.org/pdf/2004.07016.pdf)).
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It would be nice if given a PDE, its domain geometry, boundary conditions, and
    parameter values as inputs, we could train a neural network to automatically generate
    an ideal mesh, predicting the density distribution of the mesh elements at each
    location of the domain. This is exactly what [MeshingNet(2020)](https://arxiv.org/pdf/2004.07016.pdf)
    does.
  prefs: []
  type: TYPE_NORMAL
- en: Before MeshingNet, mesh learning was done via expensive multistep finite element
    solutions and error estimators. In contrast, MeshingNet relies on similar problems
    to predict ideal meshes for new problems. It starts with an initial uniform and
    coarse mesh and predicts a nonuniform mesh density for refinement. A hallmark
    of deep learning, MeshingNet generalizes well to different geometric domains with
    various governing PDEs, boundary conditions, and parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The inputs to MeshingNet are the governing PDE, PDE parameters, domain geometry,
    and the boundary conditions, and the output is an area upper bound distribution
    A(X) over the whole domain. The mapping between input and output is highly nonlinear
    and is thus learned by a neural network, which have demonstrated an impressive
    ability to express many kinds of nonlinear relationships.
  prefs: []
  type: TYPE_NORMAL
- en: To build the training data set, the MeshingNet team computes high-accuracy solutions
    on high density uniform meshes using standard finite element solvers. They also
    do the same computation for low density uniform meshes to obtain lower accuracy
    solutions. Then they compute an error distribution E(X) by interpolating between
    these solutions. They use E(X) as a guide to refine A(X). They enrich the training
    data by combining different geometries with different parameters and boundary
    conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Deep learning for three dimensional meshes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Three dimensional meshes ([Figure 13-13](#Fig_dolphin_mesh)) are useful for
    computer graphics, animations for the entertainment industry, and solid modeling.
    It is also highly desirable to reconstruct textured and realistic surfaces from
    a given set of three dimensional data points. Traditional methods include Delaunay
    triangulations and Voronoi diagrams, which interpolate points using triangular
    meshes. However, when there is noise in the coordinates, the resulting surface
    would be unnecessarily rough, which requires data pre-processing.
  prefs: []
  type: TYPE_NORMAL
- en: '![250](assets/emai_1313.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-13\. Three dimensional mesh [(image source)](https://commons.wikimedia.org/wiki/File:Dolphin_triangle_mesh.png).
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Deep learning is stepping in to generate higher quality three dimensional meshes,
    see for example, [Deep Hybrid Self-Prior for Full 3D Mesh Generation(2021)](https://arxiv.org/pdf/2108.08017.pdf)
    and [Pixel To Mesh (2018)](https://openaccess.thecvf.com/content_ECCV_2018/papers/Nanyang_Wang_Pixel2Mesh_Generating_3D_ECCV_2018_paper.pdf),
    which produces a three dimensional shape in triangular mesh from a single color
    image, by continuously deforming an ellipsoid.
  prefs: []
  type: TYPE_NORMAL
- en: Deep Learning to Approximate Solution Operators of PDEs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already started this discussion multiple times in this chapter. Instead
    of using deep learning to enhance existing methods for PDEs, such as learning
    physical parameter values from data, or learning better meshes for numerical methods,
    we would like to learn a PDE’s solution operator. This maps the PDE’s input, such
    as its domain, physical parameters, intial/final states of the solution, and/or
    boundary conditions, directly to its solution. We can think of this as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*solution of PDE=function(PDE’s physical parameters, domain, boundary conditions,
    initial conditions, _etc.)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to build a neural network to approximate this function. This is in
    fact an operator and not a function in the usual sense, since it sends functions
    to other functions. The caveat here is that differential operators and their inverses
    map *infinite dimensional spaces* to *infinite dimensional spaces*, sometimes
    in a linear way, such as the map from the *right hand side* of Poisson equation
    to the solution, and most of the time in a nonlinear way, such as the map from
    *the parameters* of Poisson equation to the solution. In contrast, the inputs
    and outputs of the neural networks that we learned about throughout this book
    are finite dimensional (inputs and outputs are vectors, images, graphs, *etc.*).
    These neural networks are able to approximate *function mappings* between *finite
    dimensional spaces*. They have a powerful universal approximation theorem going
    on for them, and a myriad of successes in practical applications (we can approximate
    any continuous function to arbitrary accuracy using neural networks if we place
    no constraints on the width and depth of the hidden layers). In order to solve
    PDEs analogously using deep learning, we must answer two questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Can neural networks approximate mappings between infinite dimensional spaces?
    That is, can they approximate any nonlinear continuous functional (the input to
    the network would be a function or a bunch of functions and the output would be
    a real number) or nonlinear operator (the input to the network would be a function
    or a bunch of functions and the output would be another function)? The answer
    is a *yes*! There is a *universal approximation theorem* for *neural network operators*
    just like there are universal approximation theorems for *neural network functions*.
    A neural network with a single hidden layer can approximate accurately any nonlinear
    continuous functional or operator. Moreover, neural networks are able to learn
    the solution operator of an entire family of PDEs, as opposed to classical methods
    for solving PDEs which only solve a single instance of a given PDE at a time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'How do we implement this in practice? For the finite dimensional case, a node
    in a neural network linearly combines the finite dimensional features of the input
    vector (or the outputs of the previous layer), adds a bias term, applies a nonlinear
    activation function, then passes the result to the next layer. The analogue for
    the infinite dimensional case, where we do not have finitely many entries to linearly
    combine anymore, would be to integrate some learnable kernel (multiplier function)
    of the input functions (for numerical integration, we have to sample this at finitely
    many points, converting integration to addition), add a bias function (this is
    optional), apply a nonlinear activation function, before passing the result to
    the next layer. The next layer would then add multiples of the node results of
    the previous layer, and integrate them against a learnable kernel of the results
    of the nodes of the previous layer, and so on. One example of doing this would
    look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign u Subscript n plus 1 Baseline left-parenthesis x
    right-parenthesis equals sigma left-parenthesis integral Underscript upper D Endscripts
    k e r n e l left-parenthesis x comma s comma a left-parenthesis x right-parenthesis
    comma a left-parenthesis s right-parenthesis semicolon omega right-parenthesis
    u Subscript n Baseline left-parenthesis s right-parenthesis d s plus upper W u
    Subscript n Baseline left-parenthesis x right-parenthesis right-parenthesis comma
    dollar-sign"><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>σ</mi> <mrow><mo>(</mo>
    <msub><mo>∫</mo> <mi>D</mi></msub> <mi>k</mi> <mi>e</mi> <mi>r</mi> <mi>n</mi>
    <mi>e</mi> <mi>l</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>s</mi> <mo>,</mo>
    <mi>a</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>;</mo> <mi>ω</mi> <mo>)</mo></mrow>
    <msub><mi>u</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi> <mo>+</mo> <mi>W</mi> <msub><mi>u</mi> <mi>n</mi></msub>
    <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>,</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: where we arrive at the solution *u(x)* iteratively after a certain number of
    global integrations against a kernel, local linear transformations, and compositions
    with a nonlinear activation function. The parameters of the kernel in the iterative
    process are <math alttext="omega"><mi>ω</mi></math> and the entries of *W*. The
    neural network learns these parameters from the labeled data (labeled with the
    solutions of the PDE) during training via minimizing a loss function. Analogous
    to the finite dimensional case, neural operator networks approximate nonlinear
    operators by composing linear integral operators that act globally over the entire
    domain with nonlinear activation functions. The above interative formula also
    includes a local linear multiplier, which becomes a matrix when we discretize
    (check this).
  prefs: []
  type: TYPE_NORMAL
- en: Neural operator networks to learn the solution operators that we derived
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s pause for a moment and compare the above expression to the three true
    solution operators which we derived for: The heat equation, Poisson equation,
    and dynamical systems. We can easily adapt the neural operator iterative process
    to each of the above three settings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the heat equation in one space dimension and constant coefficients, the
    solution operator maps the initial state and the PDE’s physical parameter (constant)
    to the solution *u(x,t)*, and we are lucky enough to have explicit formulas for
    all the quantities involved:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign upper G left-parenthesis u 0 left-parenthesis x right-parenthesis
    comma a right-parenthesis equals u left-parenthesis x comma t right-parenthesis
    equals integral Subscript negative normal infinity Superscript normal infinity
    Baseline StartFraction 1 Over StartRoot 4 pi a t EndRoot EndFraction e Superscript
    minus StartFraction left-parenthesis s minus x right-parenthesis squared Over
    4 a t EndFraction Baseline u 0 left-parenthesis s right-parenthesis d s equals
    integral Subscript negative normal infinity Superscript normal infinity Baseline
    k e r n e l left-parenthesis s comma x semicolon t semicolon a right-parenthesis
    u 0 left-parenthesis s right-parenthesis d s dollar-sign"><mrow><mi>G</mi> <mrow><mo>(</mo>
    <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>)</mo></mrow>
    <mo>,</mo> <mi>a</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>u</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <msubsup><mo>∫</mo>
    <mrow><mo>-</mo><mi>∞</mi></mrow> <mi>∞</mi></msubsup> <mfrac><mn>1</mn> <msqrt><mrow><mn>4</mn><mi>π</mi><mi>a</mi><mi>t</mi></mrow></msqrt></mfrac>
    <msup><mi>e</mi> <mrow><mo>-</mo><mfrac><msup><mrow><mo>(</mo><mi>s</mi><mo>-</mo><mi>x</mi><mo>)</mo></mrow>
    <mn>2</mn></msup> <mrow><mn>4</mn><mi>a</mi><mi>t</mi></mrow></mfrac></mrow></msup>
    <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow>
    <mi>d</mi> <mi>s</mi> <mo>=</mo> <msubsup><mo>∫</mo> <mrow><mo>-</mo><mi>∞</mi></mrow>
    <mi>∞</mi></msubsup> <mi>k</mi> <mi>e</mi> <mi>r</mi> <mi>n</mi> <mi>e</mi> <mi>l</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>x</mi> <mo>;</mo> <mi>t</mi> <mo>;</mo>
    <mi>a</mi> <mo>)</mo></mrow> <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the neural operator network does the following iteration to approximate
    the true operator:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign upper G left-parenthesis u 0 left-parenthesis x right-parenthesis
    comma a right-parenthesis equals u left-parenthesis x comma t right-parenthesis
    almost-equals u Subscript n plus 1 Baseline left-parenthesis x comma t right-parenthesis
    equals sigma left-parenthesis integral Underscript upper D Endscripts k e r n
    e l left-parenthesis s comma x semicolon t semicolon a semicolon omega right-parenthesis
    u Subscript n Baseline left-parenthesis s right-parenthesis d s plus upper W u
    Subscript n Baseline left-parenthesis x right-parenthesis right-parenthesis dollar-sign"><mrow><mi>G</mi>
    <mrow><mo>(</mo> <msub><mi>u</mi> <mn>0</mn></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>u</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>≈</mo>
    <msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>σ</mi> <mrow><mo>(</mo>
    <msub><mo>∫</mo> <mi>D</mi></msub> <mi>k</mi> <mi>e</mi> <mi>r</mi> <mi>n</mi>
    <mi>e</mi> <mi>l</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>x</mi> <mo>;</mo>
    <mi>t</mi> <mo>;</mo> <mi>a</mi> <mo>;</mo> <mi>ω</mi> <mo>)</mo></mrow> <msub><mi>u</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi>
    <mo>+</mo> <mi>W</mi> <msub><mi>u</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'For Poisson equation in two space dimensions, zero boundary conditions, and
    constant coefficients, the solution operator maps the PDE’s right hand side *f*,
    and its physical parameters (constant) to the solution *u(x,y)*, and only for
    certain simple geometries, we are lucky to have explicit formulas for all the
    quantities involved (none of which we write here):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign upper G left-parenthesis f left-parenthesis x comma
    y right-parenthesis comma a right-parenthesis equals u left-parenthesis x comma
    y right-parenthesis equals integral Underscript upper D Endscripts upper G r e
    e n upper F u n c t i o n left-parenthesis x comma y semicolon s comma p semicolon
    a right-parenthesis f left-parenthesis s comma p right-parenthesis d s d p dollar-sign"><mrow><mi>G</mi>
    <mrow><mo>(</mo> <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>u</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mo>∫</mo> <mi>D</mi></msub> <mi>G</mi> <mi>r</mi> <mi>e</mi> <mi>e</mi>
    <mi>n</mi> <mi>F</mi> <mi>u</mi> <mi>n</mi> <mi>c</mi> <mi>t</mi> <mi>i</mi> <mi>o</mi>
    <mi>n</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>;</mo> <mi>s</mi>
    <mo>,</mo> <mi>p</mi> <mo>;</mo> <mi>a</mi> <mo>)</mo></mrow> <mi>f</mi> <mrow><mo>(</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mi>d</mi>
    <mi>p</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the neural operator network does the following iteration to approximate
    the true operator:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign upper G left-parenthesis f left-parenthesis x comma
    y right-parenthesis comma a right-parenthesis equals u left-parenthesis x comma
    y right-parenthesis almost-equals u Subscript n plus 1 Baseline left-parenthesis
    x comma y right-parenthesis equals sigma left-parenthesis integral Underscript
    upper D Endscripts k e r n e l left-parenthesis x comma y comma s comma p comma
    a semicolon omega right-parenthesis u Subscript n Baseline left-parenthesis s
    comma p right-parenthesis d s d p plus upper W u Subscript n Baseline left-parenthesis
    x comma y right-parenthesis right-parenthesis dollar-sign"><mrow><mi>G</mi> <mrow><mo>(</mo>
    <mi>f</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow>
    <mo>,</mo> <mi>a</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>u</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>≈</mo> <msub><mi>u</mi>
    <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub> <mrow><mo>(</mo> <mi>x</mi>
    <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>=</mo> <mi>σ</mi> <mrow><mo>(</mo>
    <msub><mo>∫</mo> <mi>D</mi></msub> <mi>k</mi> <mi>e</mi> <mi>r</mi> <mi>n</mi>
    <mi>e</mi> <mi>l</mi> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>,</mo>
    <mi>s</mi> <mo>,</mo> <mi>p</mi> <mo>,</mo> <mi>a</mi> <mo>;</mo> <mi>ω</mi> <mo>)</mo></mrow>
    <msub><mi>u</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>p</mi>
    <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mi>d</mi> <mi>p</mi> <mo>+</mo> <mi>W</mi>
    <msub><mi>u</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'For a one dimensional dynamical system, the solution operator maps the ODE’s
    physical parameter (function) to the solution *u(t)*, and we have an implicit
    integral equation that it satisfies:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign upper G left-parenthesis a left-parenthesis t right-parenthesis
    right-parenthesis equals u left-parenthesis t right-parenthesis equals u 0 plus
    integral Subscript t 0 Superscript t Baseline f left-parenthesis upper G left-parenthesis
    a left-parenthesis s right-parenthesis right-parenthesis comma a left-parenthesis
    s right-parenthesis comma s right-parenthesis d s period dollar-sign"><mrow><mi>G</mi>
    <mrow><mo>(</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>=</mo> <mi>u</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mi>u</mi> <mn>0</mn></msub> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi>
    <mn>0</mn></msub></mrow> <mi>t</mi></msubsup> <mi>f</mi> <mrow><mo>(</mo> <mi>G</mi>
    <mrow><mo>(</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mo>.</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the neural operator network does the following iteration to approximate
    the true operator:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign upper G left-parenthesis a left-parenthesis t right-parenthesis
    right-parenthesis equals u left-parenthesis t right-parenthesis almost-equals
    u Subscript n plus 1 Baseline left-parenthesis t right-parenthesis equals sigma
    left-parenthesis integral Subscript t 0 Superscript t Baseline k e r n e l left-parenthesis
    t comma s comma a left-parenthesis t right-parenthesis comma a left-parenthesis
    s right-parenthesis semicolon omega right-parenthesis u Subscript n Baseline left-parenthesis
    s right-parenthesis d s plus upper W u Subscript n Baseline left-parenthesis t
    right-parenthesis right-parenthesis dollar-sign"><mrow><mi>G</mi> <mrow><mo>(</mo>
    <mi>a</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo>
    <mi>u</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>≈</mo> <msub><mi>u</mi>
    <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub> <mrow><mo>(</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mi>σ</mi> <mrow><mo>(</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi>
    <mn>0</mn></msub></mrow> <mi>t</mi></msubsup> <mi>k</mi> <mi>e</mi> <mi>r</mi>
    <mi>n</mi> <mi>e</mi> <mi>l</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>,</mo> <mi>s</mi>
    <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo>
    <mi>a</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>;</mo> <mi>ω</mi>
    <mo>)</mo></mrow> <msub><mi>u</mi> <mi>n</mi></msub> <mrow><mo>(</mo> <mi>s</mi>
    <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi> <mo>+</mo> <mi>W</mi> <msub><mi>u</mi>
    <mi>n</mi></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: '*Here, one data point is a triplet (t, a(t), G(a(t))), and thus one specific
    input a may appear in multiple data points with different values of t. For example,
    a dataset of size 10,000 may only be generated from 100 a(t) trajectories, and
    each evaluates G(a)(t) for 100 t locations. (explain this)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to observe with the three different settings above is that neural
    operator networks require only input and output data, and no knowledge of the
    underlying PDEs. The knowledge about the PDEs is implicit in the training data.
    With this in mind, let’s reinforce the *input output* form of a neural operator
    network:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution of PDE <math alttext="almost-equals"><mo>≈</mo></math> learned_operator(PDE’s
    physical parameters, domain, boundary conditions, initial conditions, _etc.)*.'
  prefs: []
  type: TYPE_NORMAL
- en: The important questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we branch out beyond this book to expand our knowledge on neural operator
    networks, we must keep the following questions as our guide:'
  prefs: []
  type: TYPE_NORMAL
- en: For a given PDE, what is the input to the network, and what is the output?
  prefs: []
  type: TYPE_NORMAL
- en: We addressed these in the simple contexts of the heat equation, Poisson equation,
    and dynamical systems.
  prefs: []
  type: TYPE_NORMAL
- en: What is an example of an architecture of a neural operator?
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-14](#Fig_DeepONet) shows the input and output structure of [DeepONet](https://arxiv.org/pdf/1910.03193.pdf).
    The input is a discretized pair (t,a(t)) and the output is a discrete G(a(t)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![300](assets/emai_1314.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-14\. (Remake this figure with the correct labels in terms of G,u,a
    and t) (A) The network to learn an operator G(a(t)) takes two inputs <math alttext="left-parenthesis
    a left-parenthesis t 1 right-parenthesis comma a left-parenthesis t 2 right-parenthesis
    comma ellipsis comma a left-parenthesis t Subscript m Baseline right-parenthesis
    right-parenthesis"><mrow><mo>(</mo> <mi>a</mi> <mrow><mo>(</mo> <msub><mi>t</mi>
    <mn>1</mn></msub> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi> <mrow><mo>(</mo> <msub><mi>t</mi>
    <mn>2</mn></msub> <mo>)</mo></mrow> <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <mi>a</mi>
    <mrow><mo>(</mo> <msub><mi>t</mi> <mi>m</mi></msub> <mo>)</mo></mrow> <mo>)</mo></mrow></math>
    and t. (B) Illustration of the training data [(*image source*)](https://arxiv.org/pdf/1910.03193.pdf).
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: How do we deal with the fact that the inputs have such drastic differences in
    dimension, such as finite dimensional and infinite dimensional at the same time?
  prefs: []
  type: TYPE_NORMAL
- en: In other words, how do we discretize the involved finite dimensional (independent
    variables such as time and space) and infinite dimensional quantities (solution
    functions, parameter function, boundary conditions, initial conditions, *etc*.)
    during training and inference? Note that for neural networks that learn finite
    dimensional mappings, inputs (tables, images, audio files, graphs, natural language
    text) always have the same dimension, are preprocessed to have the same dimension,
    or the network itself processes fixed dimension portions of the input individually.
  prefs: []
  type: TYPE_NORMAL
- en: How do we avoid the common trap in many PDE solution methods, which end up being
    discretization dependent?
  prefs: []
  type: TYPE_NORMAL
- en: In what sense are neural operator networks meshless and able to generalize their
    learned parameters to work for other discretizations than the ones they have been
    trained on? The significant advancement here is that neural operator networks
    are discretization invariant, sharing the same network parameters between different
    discretizations. This means that their outputs do not depend on the underlying
    discretization and can be used with different grid representations.
  prefs: []
  type: TYPE_NORMAL
- en: How do we speed up the computation time for the integrals involved in the neural
    operators and make it less costly?
  prefs: []
  type: TYPE_NORMAL
- en: We involve the Fourier transform. Fourier neural network speeds up the process
    of computing the involved integrals tranforming the inputs to Fourier space. This
    has the fast Fourier transform methods at its disposal. Fourier neural network,
    which we discuss in the next subsection, implements this.
  prefs: []
  type: TYPE_NORMAL
- en: How do neural operator networks fair with high dimensional PDEs involving hundreds
    or thousands of variables?
  prefs: []
  type: TYPE_NORMAL
- en: PDEs that model financial markets with all the underlying assets (Black Scholes),
    game theoretic settings with many participating agents (Hamilton Jacobi Bellman),
    or physical systems with many particles, are very high dimensional. Discretization
    in each of these dimensions explodes the size of an already big problem computationally
    and have until now made any practical implementation of these elegant PDEs infeasible.
    The 2018 article, [*Solving High Dimensional Differential Equations Using Deep
    Learning*](https://www.pnas.org/doi/epdf/10.1073/pnas.1718942115), which we also
    discuss soon, uses AI techniques to address such PDEs, but it would be nice to
    compare that article’s methodology to a deep neural operator setting.
  prefs: []
  type: TYPE_NORMAL
- en: Fourier neural network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The California Institute of Technology has recently open sourced its Fourier
    neural network for solving partial differential equations, whose approach is illustrated
    in the article [*Fourier Neural Operator For Parametric Partial Differential Equations
    (2021)*](https://arxiv.org/pdf/2010.08895.pdf).These networks can approximate
    solution operators for PDEs that are highly non-linear, with high frequency modes
    and slow energy decay.
  prefs: []
  type: TYPE_NORMAL
- en: Each layer in Fourier neural network network applies a fast Fourier transform
    to its input data, then a linear transform, then an inverse fast Fourier transform.
    This results in a quasi-linear computational complexity, that is, of order O(n
    polynomial(log(n))) and makes the model invariant to the spatial resolution of
    the data (even though it still requires a uniform mesh).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-15](#Fig_FourierNN) shows the architechture of the Fourier neural
    network.'
  prefs: []
  type: TYPE_NORMAL
- en: '![250](assets/emai_1315.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-15\. The architecture of Fourier neural network [(*image source*)](https://arxiv.org/pdf/2010.08895.pdf).
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The input is the physical parameter a(x) and the output is the PDE solution
    u(x).
  prefs: []
  type: TYPE_NORMAL
- en: Start from input a(x).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lift to a higher dimension channel space by a shallow fully connected neural
    network P: v0(x) = P(a(x)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apply several Fourier layers of integral operators and activation functions.
    In each of these layers we: Apply the Fourier transform F.T; a linear transform
    R on the lower Fourier modes and filters out the higher modes; Apply the inverse
    Fourier transform <math alttext="upper F period upper T Superscript negative 1"><mrow><mi>F</mi>
    <mo>.</mo> <msup><mi>T</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
    . On the bottom: apply a local linear transform W.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project back to the target dimension by a neural network Q. Finish with the
    output u(x) = Q(vT (x)), which is the projection of v by the a local transformation
    Q also parameterized by a shallow fully connected neural network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finish with the output u(x).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The article demonstrates the method with a variety of important PDEs:'
  prefs: []
  type: TYPE_NORMAL
- en: Burgers’ equation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Darcy flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navier-Stokes equation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turbulent flows in regimes where other methods diverged
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Fourier neural network is mesh-invariant, so it can be trained on a lower
    resolution and evaluated at a higher resolution, without seeing any higher resolution
    data (zero-shot super-resolution).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since data driven methods rely on the quality and quantity of data, we need
    to generate training pairs of inputs and outputs for the neural operator networks
    by solving the actual PDEs via some other methods. To this end, the authors note
    that: To learn Navier-Stokes equation with <math alttext="v i s c o s i t y equals
    1 e Superscript negative 4"><mrow><mi>v</mi> <mi>i</mi> <mi>s</mi> <mi>c</mi>
    <mi>o</mi> <mi>s</mi> <mi>i</mi> <mi>t</mi> <mi>y</mi> <mo>=</mo> <mn>1</mn> <msup><mi>e</mi>
    <mrow><mo>-</mo><mn>4</mn></mrow></msup></mrow></math> , we need to generate N
    = 10000 training pairs <math alttext="left-parenthesis a left-parenthesis x right-parenthesis
    comma u left-parenthesis x right-parenthesis right-parenthesis"><mrow><mo>(</mo>
    <mi>a</mi> <mo>(</mo> <mi>x</mi> <mo>)</mo> <mo>,</mo> <mi>u</mi> <mo>(</mo> <mi>x</mi>
    <mo>)</mo> <mo>)</mo></mrow></math> using a numerical solver. For more challenging
    PDEs, generating even a few training samples can be very expensive. A future direction
    would be to combine neural operators with numerical solvers to levitate the requirements
    on data.'
  prefs: []
  type: TYPE_NORMAL
- en: Statement of the universal approximation theorem for operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose that <math alttext="sigma"><mi>σ</mi></math> is a continuous nonpolynomial
    function, X is a Banach Space, <math alttext="upper K 1 subset-of upper X"><mrow><msub><mi>K</mi>
    <mn>1</mn></msub> <mo>⊂</mo> <mi>X</mi></mrow></math> , <math alttext="upper K
    2 subset-of double-struck upper R Superscript d"><mrow><msub><mi>K</mi> <mn>2</mn></msub>
    <mo>⊂</mo> <msup><mi>ℝ</mi> <mi>d</mi></msup></mrow></math> are two compact sets,
    V is a compact set in <math alttext="upper C left-parenthesis upper K 1 right-parenthesis"><mrow><mi>C</mi>
    <mo>(</mo> <msub><mi>K</mi> <mn>1</mn></msub> <mo>)</mo></mrow></math> , G is
    a nonlinear continuous operator, which maps V into <math alttext="upper C left-parenthesis
    upper K 2 right-parenthesis"><mrow><mi>C</mi> <mo>(</mo> <msub><mi>K</mi> <mn>2</mn></msub>
    <mo>)</mo></mrow></math> . Then for any <math alttext="epsilon greater-than 0"><mrow><mi>ϵ</mi>
    <mo>></mo> <mn>0</mn></mrow></math> , there are positive integers n, p, m, constants
    <math alttext="c Subscript i Superscript k Baseline comma xi Subscript i comma
    j Superscript k Baseline comma theta Subscript i Superscript k Baseline comma
    xi Subscript k Baseline element-of double-struck upper R comma omega Subscript
    k Baseline element-of double-struck upper R Superscript d Baseline comma x Subscript
    j Baseline element-of upper K 1 comma i equals 1 comma ellipsis comma n comma
    k equals 1 comma ellipsis comma p comma j equals 1 comma ellipsis comma m"><mrow><msubsup><mi>c</mi>
    <mi>i</mi> <mi>k</mi></msubsup> <mo>,</mo> <msubsup><mi>ξ</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow>
    <mi>k</mi></msubsup> <mo>,</mo> <msubsup><mi>θ</mi> <mi>i</mi> <mi>k</mi></msubsup>
    <mo>,</mo> <msub><mi>ξ</mi> <mi>k</mi></msub> <mo>∈</mo> <mi>ℝ</mi> <mo>,</mo>
    <msub><mi>ω</mi> <mi>k</mi></msub> <mo>∈</mo> <msup><mi>ℝ</mi> <mi>d</mi></msup>
    <mo>,</mo> <msub><mi>x</mi> <mi>j</mi></msub> <mo>∈</mo> <msub><mi>K</mi> <mn>1</mn></msub>
    <mo>,</mo> <mi>i</mi> <mo>=</mo> <mn>1</mn> <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <mi>n</mi>
    <mo>,</mo> <mi>k</mi> <mo>=</mo> <mn>1</mn> <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <mi>p</mi>
    <mo>,</mo> <mi>j</mi> <mo>=</mo> <mn>1</mn> <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <mi>m</mi></mrow></math>
    , such that
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartAbsoluteValue upper G left-parenthesis u right-parenthesis
    left-parenthesis y right-parenthesis minus sigma-summation Underscript k equals
    1 Overscript p Endscripts sigma-summation Underscript i equals 1 Overscript n
    Endscripts c Subscript i Superscript k Baseline sigma left-parenthesis sigma-summation
    Underscript j equals 1 Overscript m Endscripts xi Subscript i j Superscript k
    Baseline u left-parenthesis x Subscript j Baseline right-parenthesis plus theta
    Subscript i Superscript k Baseline right-parenthesis sigma left-parenthesis omega
    Subscript k Baseline period y plus xi Subscript k Baseline right-parenthesis EndAbsoluteValue
    less-than epsilon dollar-sign"><mrow><mrow><mo>|</mo> <mi>G</mi> <mrow><mo>(</mo>
    <mi>u</mi> <mo>)</mo></mrow> <mrow><mo>(</mo> <mi>y</mi> <mo>)</mo></mrow> <mo>-</mo></mrow>
    <msubsup><mo>∑</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>p</mi></msubsup>
    <msubsup><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup>
    <msubsup><mi>c</mi> <mi>i</mi> <mi>k</mi></msubsup> <mi>σ</mi> <mrow><mo>(</mo>
    <msubsup><mo>∑</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>m</mi></msubsup>
    <msubsup><mi>ξ</mi> <mrow><mi>i</mi><mi>j</mi></mrow> <mi>k</mi></msubsup> <mi>u</mi>
    <mrow><mo>(</mo> <msub><mi>x</mi> <mi>j</mi></msub> <mo>)</mo></mrow> <mo>+</mo>
    <msubsup><mi>θ</mi> <mi>i</mi> <mi>k</mi></msubsup> <mo>)</mo></mrow> <mi>σ</mi>
    <mrow><mo>(</mo> <msub><mi>ω</mi> <mi>k</mi></msub> <mo>.</mo> <mi>y</mi> <mo>+</mo>
    <msub><mi>ξ</mi> <mi>k</mi></msub> <mo>)</mo></mrow> <mrow><mo>|</mo> <mo><</mo>
    <mi>ϵ</mi></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: holds for all <math alttext="u element-of upper V"><mrow><mi>u</mi> <mo>∈</mo>
    <mi>V</mi></mrow></math> and <math alttext="y element-of upper K 2"><mrow><mi>y</mi>
    <mo>∈</mo> <msub><mi>K</mi> <mn>2</mn></msub></mrow></math> . Note that this approximation
    theorem only uses one hidden layer in the neural network, but does not specify
    how many nodes this layer has. In applications, just like in the finite dimensional
    case, we use more than one layer.
  prefs: []
  type: TYPE_NORMAL
- en: Do not be intimidated by the big words and the greek letters. What this theorem
    tells us is that we have theoretical grounds to formulate a neural network operator,
    and expect it to approximate the PDE solution operator very well. Even though
    we may never know the exact formula for the PDE solution operator, the operator
    neural network that we construct acts as a very good proxy. This is the reason
    we are all in love with approximation theorems, and should be eternally grateful
    to the mathematicians who find them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have mentioned this in the context of the fixed point iteration’s *additive*
    approximation of a solution, and it is worth mentioning again: Whether approximating
    a mapping between finite dimensional spaces or a mapping between infinite dimensional
    spaces, neural networks represent functions, functionals, or operators using *compositions*
    of simple functions (a linear combination or linear integral operator composed
    with a nonlinear activation function) to approximate complicated ones. This is
    different than classical approximation approaches where the approximation is *additive*
    and not compositional.'
  prefs: []
  type: TYPE_NORMAL
- en: How do we branch out and dive into the more technical details?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For a deeper dive into neural operator networks, the three important publications
    on this topic are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*DeepONet: Learning nonlinear operators for identifying differential equations
    based on the universal approximation theorem of operators (2020)*](https://arxiv.org/pdf/1910.03193.pdf)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[*Neural Operator: Graph Kernel Network for Partial Differential Equations
    (2020)*](https://arxiv.org/pdf/2003.03485.pdf)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[*Fourier Neural Operator For Parametric PDEs (2021)*](https://arxiv.org/pdf/2010.08895.pdf)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Numerical Solutions of High Dimensional Differential Equations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Differential equations are universal, they can model almost anything we can
    think of, including our daily commute and traffic. It is hard to be exposed to
    differential equations then *not think* of each situation that we find ourselves
    in as fitting into some sort of differential equation. That said, the curse of
    dimensionality has haunted this field since its inception, and stood in the way
    of many practical applications. This is why many introductory PDE courses misleadingly
    focus only on one and two dimensional differential equations, as if that is all
    there is. If AI was to be given a different name, that is not as flashy and definitely
    would not make it into any movies, it would be: *Processing, computation, and
    analysis of high dimensional data*. This does not talk AI down, because processing,
    computation, and analysis of high dimensional data are exactly what humans do
    on a daily basis, provided that we add a creative dimension to it (which in AI
    would translate to generative models). It is then not surprising that deep learning
    turns out to be an appropriate setting for finding numerical solution of *very*
    high dimensional differential equations. This is the focus of the 2018 article
    [Solving High Dimensional Differential Equations Using Deep Learning (2018)](https://www.pnas.org/doi/epdf/10.1073/pnas.1718942115),
    which addresses PDEs with hundreds or even thousands of dimensions. This way,
    we can include all participating agents, assets, resources, or particles at the
    same time, instead of artificially devising handmade assumptions about their interactions
    and connections. The authors consider multiple high dimensional PDEs, including
    the Hamilton–Jacobi–Bellman equation (what is the optimal strategy for each interacting
    agent, among hundreds of agents?) and the Black–Scholes equation (What is the
    fair price of a European claim based on 100 underlying assets given that no default
    having occurred yet?)'
  prefs: []
  type: TYPE_NORMAL
- en: When we rely on a deep learning setting as a basis for our models, for example,
    for computing solutions of high dimensional PDEs, the first question we must ask
    is what is the input and what is the output of our deep learning network. For
    any PDE whose solution is *u(x,t)*, ideally we would input *x* and *t* and output
    *u(x,t)*. *x* in this case can be an extremely high dimensional <math alttext="ModifyingAbove
    x With right-arrow"><mover accent="true"><mi>x</mi> <mo>→</mo></mover></math>
    . If the entries of *x* have any inherent stochasticity into them, such as prices
    of financial market assets, then we must model them as such, and if we don’t,
    then we are usually assuming some sort of averaging. The bottom line is, for many
    realistic cases, we can input *x* as *X*, a stochastic process. We must define
    this mathematically.
  prefs: []
  type: TYPE_NORMAL
- en: 'One big step in the aforementioned article is reformulating the high dimensional
    PDEs as backward stochastic differential equations before inputting *X* into a
    neural network that approximates the gradient of the solution. To master the essential
    math required here, we must define:'
  prefs: []
  type: TYPE_NORMAL
- en: Brownian motion (see [Chapter 11](ch11.xhtml#ch11))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stochastic process (see [Chapter 11](ch11.xhtml#ch11))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stochastic differential equation (this is beyond the scope of the book)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Relating nonlinear parabolic PDEs to stochastic PDEs (this is beyond the scope
    of the book)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Backward stochastic differential equation (this is beyond the scope of the book)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And we must answer the question: Why did we have to reformulate the PDE into
    a stochastic form before training the network? What advantage does this form give
    us? This goes beyond the scope of the book, but you now know what to look for
    and what questions to ask.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the method opens the door to solving many high dimensional differential
    equations, but there are limitations. The method cannot be applied to the quantum
    many body problem due to the difficulty in dealing with the [Pauli exclusion principle](https://en.wikipedia.org/wiki/Pauli_exclusion_principle).
  prefs: []
  type: TYPE_NORMAL
- en: Simulating Natural Phenomena Directly From Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have addressed particle systems once in this chapter: We used a statistical
    mechanics framework to describe the probabilities of the states of the system
    at the particle scale then we used those to write down PDEs modeling the time
    evolution of the system at the macroscale.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explain how recent neural network based models simulate
    a particle system and predict its evolution *without* writing any PDEs. In other
    words, we bypass PDEs and trade them for *learning from data*.
  prefs: []
  type: TYPE_NORMAL
- en: In order to track the evolution of a certain particle system (such as a water
    or sand) at a granular scale, we need to know each particle’s position vector
    <math alttext="ModifyingAbove p With right-arrow Subscript i Baseline left-parenthesis
    t right-parenthesis"><mrow><msub><mover accent="true"><mi>p</mi> <mo>→</mo></mover>
    <mi>i</mi></msub> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    at each time step *t*. How these positions change depends on local and long range
    interactions between a particle and its neighbors (such as exchanging energy and
    momentum), which are dictated both by the physical nature of the system and by
    external effects such as gravity, temperature, forces, magnetic fields, *etc.*
    Instead of writing down explicit equations for these interactions, and relating
    them to the particles’ positions, velocities, and/or accelerations, we can train
    a neural network to learn a map between a given state of particle system at a
    certain time (input) and the positions of all of its particles (or velocities
    or accelerations) at a future time (output). Graph networks are well suited to
    model particle systems since each particle along with its state can be a node
    and the edges along with their features model the interactions between specific
    particles.
  prefs: []
  type: TYPE_NORMAL
- en: 'We highlight and comment on the general ideas from a recent work that learns
    such a map: [Learning to Simulate Complex Physics with Graph Networks (2020, Google’s
    DeepMind and Stanford University)](https://arxiv.org/pdf/2002.09405.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need training data
  prefs: []
  type: TYPE_NORMAL
- en: 'We can generate input (particle system and its features at a certain time)
    and target (each particle’s acceleration at a later time) pairs from a dataset
    of observed or simulated trajectories of a certain particle system: For example,
    from a 1000-step long trajectory, the team generates 995 pairs, conditioning on
    the 5 past states. In the datasets, we only need the position vectors, and we
    can derive velocity and acceleration vectors using finite differences. The datasets
    typically contained 1000 train, 100 validation and 100 test trajectories, each
    simulated for 300-2000 timesteps, tailored to the average duration for the various
    materials to come to a stable equilibrium.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to build the map from input to output (the network components)
  prefs: []
  type: TYPE_NORMAL
- en: Start with the system at a certain state at integer time t <math alttext="upper
    X Superscript t Baseline equals left-parenthesis ModifyingAbove x With right-arrow
    Subscript 0 Superscript t Baseline comma ellipsis comma ModifyingAbove x With
    right-arrow Subscript upper N Superscript t Baseline right-parenthesis"><mrow><msup><mi>X</mi>
    <mi>t</mi></msup> <mo>=</mo> <mrow><mo>(</mo> <msubsup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mn>0</mn> <mi>t</mi></msubsup> <mo>,</mo> <mo>⋯</mo> <mo>,</mo>
    <msubsup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mi>N</mi> <mi>t</mi></msubsup>
    <mo>)</mo></mrow></mrow></math> , where each of the N particles’ <math alttext="ModifyingAbove
    x With right-arrow Subscript i Superscript t"><msubsup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mi>i</mi> <mi>t</mi></msubsup></math> represents its state
    at time t (which includes its position <math alttext="ModifyingAbove p With right-arrow
    Subscript i Superscript t"><msubsup><mover accent="true"><mi>p</mi> <mo>→</mo></mover>
    <mi>i</mi> <mi>t</mi></msubsup></math> and other characteristics such as mass,
    material properties, *etc.*).
  prefs: []
  type: TYPE_NORMAL
- en: Next, learn a map that represents the state <math alttext="upper X Superscript
    t Baseline equals left-parenthesis ModifyingAbove x With right-arrow Subscript
    0 Superscript t Baseline comma ellipsis comma ModifyingAbove x With right-arrow
    Subscript upper N Superscript t Baseline right-parenthesis"><mrow><msup><mi>X</mi>
    <mi>t</mi></msup> <mo>=</mo> <mrow><mo>(</mo> <msubsup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mn>0</mn> <mi>t</mi></msubsup> <mo>,</mo> <mo>⋯</mo> <mo>,</mo>
    <msubsup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mi>N</mi> <mi>t</mi></msubsup>
    <mo>)</mo></mrow></mrow></math> as graph G = (nodes,edges, global properties which
    can alternatively be included as node features). The node embeddings <math alttext="ModifyingAbove
    n o d e With right-arrow Subscript i Baseline equals f u n c t i o n left-parenthesis
    ModifyingAbove x With right-arrow Subscript i Baseline right-parenthesis"><mrow><msub><mover
    accent="true"><mrow><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi></mrow> <mo>→</mo></mover>
    <mi>i</mi></msub> <mo>=</mo> <mi>f</mi> <mi>u</mi> <mi>n</mi> <mi>c</mi> <mi>t</mi>
    <mi>i</mi> <mi>o</mi> <mi>n</mi> <mrow><mo>(</mo> <msub><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></math> are learned
    functions (using a multilayer perceptron) of the particles’states. Directed edges
    are added to create paths between particle nodes which have some potential interaction.
    The edge embeddings, <math alttext="ModifyingAbove e With right-arrow Subscript
    i comma j Baseline equals f u n c t i o n left-parenthesis ModifyingAbove r With
    right-arrow Subscript i comma j Baseline right-parenthesis"><mrow><msub><mover
    accent="true"><mi>e</mi> <mo>→</mo></mover> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>=</mo> <mi>f</mi> <mi>u</mi> <mi>n</mi> <mi>c</mi> <mi>t</mi> <mi>i</mi> <mi>o</mi>
    <mi>n</mi> <mrow><mo>(</mo> <msub><mover accent="true"><mi>r</mi> <mo>→</mo></mover>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub> <mo>)</mo></mrow></mrow></math>
    , are learned functions (using a multilayer perceptron) of the pairwise properties
    of the corresponding particles <math alttext="ModifyingAbove r With right-arrow
    Subscript i comma j"><msub><mover accent="true"><mi>r</mi> <mo>→</mo></mover>
    <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></math> , for example, displacement
    between their positions, spring constant, *etc*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then learn a graph to graph map: This computes the interactions among the nodes
    via M steps of learned message-passing, to generate a sequence of updated latent
    graphs, <math alttext="upper G equals left-parenthesis upper G 1 comma ellipsis
    comma upper G Subscript upper M Baseline right-parenthesis"><mrow><mi>G</mi> <mo>=</mo>
    <mo>(</mo> <msub><mi>G</mi> <mn>1</mn></msub> <mo>,</mo> <mo>⋯</mo> <mo>,</mo>
    <msub><mi>G</mi> <mi>M</mi></msub> <mo>)</mo></mrow></math> . Then returns the
    final graph. Message-passing allows information to propagate between the nodes
    via the edges, and for the constraints to be respected. This way, the complex
    dynamics of the system are approximated by learned message-passing among the nodes
    within their local neighborhoods. Moreover, the final graph has the same structure
    as first graph, but with potentially different node, edge, and graph-level attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, learn a map (multilayer perceptron) from the final graph to a matrix that
    extracts the dynamics of the system, for example, the matrix of the particles’
    acceleration <math alttext="upper Y equals left-parenthesis ModifyingAbove p With
    right-arrow double-prime Subscript 1 Baseline comma ModifyingAbove p With right-arrow
    double-prime Subscript 2 Baseline comma ellipsis comma ModifyingAbove p With right-arrow
    double-prime Subscript upper N right-parenthesis"><mrow><mi>Y</mi> <mo>=</mo>
    <mo>(</mo> <msubsup><mover accent="true"><mi>p</mi> <mo>→</mo></mover> <mn>1</mn>
    <mrow><mo>'</mo><mo>'</mo></mrow></msubsup> <mo>,</mo> <msubsup><mover accent="true"><mi>p</mi>
    <mo>→</mo></mover> <mn>2</mn> <mrow><mo>'</mo><mo>'</mo></mrow></msubsup> <mo>,</mo>
    <mo>⋯</mo> <mo>,</mo> <msubsup><mover accent="true"><mi>p</mi> <mo>→</mo></mover>
    <mi>N</mi> <mrow><mo>'</mo><mo>'</mo></mrow></msubsup> <mo>)</mo></mrow></math>
    . Finally, the particles’ positions and velocities are updated using an Euler
    integrator of the accelerations in Y. This in turn updates the system’s state
    to <math alttext="upper X Superscript t plus 1"><msup><mi>X</mi> <mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msup></math>
    .
  prefs: []
  type: TYPE_NORMAL
- en: Such models are not restricted to materials and particle systems, but can model
    systems with many interacting agents, such as robotic control systems. They are
    a great step towards simulating complex phenomena authentically, which is of great
    value to science and engineering.
  prefs: []
  type: TYPE_NORMAL
- en: Hamilton-Jacobi-Bellman PDE for Dynamic Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Hamilton–Jacobi–Bellman equation is yet another PDE whose solution unlocks
    many possibilities in economics, operations research, and finance, *if only* we
    are able to solve it in high dimensions. In a nutshell, we are searching for an
    *optimal strategy* (such as an investment strategy) that guarantees some *minimal*
    implementation cost over a *given period of time*. Ideally, we would like to include
    hundreds or thousands of interacting agents, such as all the financial assets
    for investment banking, instead of downsizing to unrealistic *represenative agent*
    models. This is where using neural networks to find numerical solutions for high
    dimensional PDEs helps us, as we saw earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathematically, the Hamilton-Jacobi-Bellman PDE is very *rich*: It combines
    dynamical systems ( <math alttext="StartFraction normal partial-differential x
    left-parenthesis t right-parenthesis Over d t EndFraction equals f left-parenthesis
    x left-parenthesis t right-parenthesis comma a left-parenthesis t right-parenthesis
    comma t right-parenthesis"><mrow><mfrac><mrow><mi>∂</mi><mi>x</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow>
    <mrow><mi>d</mi><mi>t</mi></mrow></mfrac> <mo>=</mo> <mi>f</mi> <mrow><mo>(</mo>
    <mi>x</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>a</mi>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    ), PDEs (partial derivatives and equalities), and optimization (*max* or *min*
    problems). When we learn how to derive this one PDE from real world applications,
    attempt to understand it, find its solutions, and analyze these solutions (existence,
    uniqueness, smoothness, etc.), we acquire a ton of math.'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, this PDE is directly related to *reinforcement learning* in AI, but
    instead of thinking about reinforcement probabilistically, in terms Markov decision
    processes, such as in [Chapter 11](ch11.xhtml#ch11), we think about reinforcement
    in terms of deterministic dynamic programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the dynamic programming setting, the states of the interacting agents, bundled
    in a vector <math alttext="ModifyingAbove x With right-arrow left-parenthesis
    t right-parenthesis"><mrow><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math> , evolve in time according
    to a dynamic system, and we need to find an optimizing policy that induces a special
    solution of this dynamic system: The one which incurs a minimal cost over a given
    period of time. The train of thought goes like this: A certain time dependent
    policy affects the behavior of a dynamic system which in turn affects the incurred
    cost. All of these are mathematical quantities.'
  prefs: []
  type: TYPE_NORMAL
- en: The contributions of Richard Bellman (1920-1984) to the dynamic programming
    field (finding optimal strategies for an evolving system over a given period of
    time) are invaluable. We will encounter Bellman’s principle for optimality shortly,
    and in fact, it is him who coined the term *curse of dimensionality*. This principle
    is tremendously helpful as it breaks down the involved optimization problem over
    the considered period of time into smaller subproblems at smaller time intervals,
    which we can then solve in a recursive manner.
  prefs: []
  type: TYPE_NORMAL
- en: Bellman’s equation in deterministic and stochastic settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a *deterministic* dynamic programming setting, there are:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Discrete time* Bellman’s equation: We can find the value function starting
    from the current time till the final time by picking the best strategy (or control
    or policy) <math alttext="a Subscript k"><msub><mi>a</mi> <mi>k</mi></msub></math>
    at the current time step *k* so that the current cost plus the value function
    at the next time step is minimized. This is a recursive process:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign upper V a l u e left-parenthesis ModifyingAbove x
    With right-arrow Subscript k Baseline comma n right-parenthesis equals min Underscript
    ModifyingAbove a With right-arrow Subscript k Baseline Endscripts left-parenthesis
    upper C o s t left-parenthesis ModifyingAbove x With right-arrow Subscript k Baseline
    comma ModifyingAbove a With right-arrow Subscript k Baseline right-parenthesis
    plus upper V a l u e left-parenthesis ModifyingAbove x With right-arrow Subscript
    k plus 1 Baseline comma n minus 1 right-parenthesis right-parenthesis dollar-sign"><mrow><mi>V</mi>
    <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mrow><mo>(</mo> <msub><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mi>k</mi></msub> <mo>,</mo> <mi>n</mi> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mo form="prefix" movablelimits="true">min</mo> <msub><mover accent="true"><mi>a</mi>
    <mo>→</mo></mover> <mi>k</mi></msub></msub> <mrow><mo>(</mo> <mi>C</mi> <mi>o</mi>
    <mi>s</mi> <mi>t</mi> <mrow><mo>(</mo> <msub><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mi>k</mi></msub> <mo>,</mo> <msub><mover accent="true"><mi>a</mi> <mo>→</mo></mover>
    <mi>k</mi></msub> <mo>)</mo></mrow> <mo>+</mo> <mi>V</mi> <mi>a</mi> <mi>l</mi>
    <mi>u</mi> <mi>e</mi> <mrow><mo>(</mo> <msub><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>,</mo> <mi>n</mi> <mo>-</mo>
    <mn>1</mn> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: where *n* is the final time step, and the discrete time dynamics are
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign ModifyingAbove x With right-arrow Subscript k plus
    1 Baseline equals ModifyingAbove f With right-arrow left-parenthesis ModifyingAbove
    x With right-arrow Subscript k Baseline comma ModifyingAbove a With right-arrow
    Subscript k Baseline right-parenthesis dollar-sign"><mrow><msub><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>=</mo>
    <mover accent="true"><mi>f</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mi>k</mi></msub> <mo>,</mo> <msub><mover
    accent="true"><mi>a</mi> <mo>→</mo></mover> <mi>k</mi></msub> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: so that
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign upper V a l u e left-parenthesis ModifyingAbove x
    With right-arrow Subscript k Baseline comma n right-parenthesis equals min Underscript
    ModifyingAbove a With right-arrow Subscript k Baseline Endscripts left-parenthesis
    upper C o s t left-parenthesis ModifyingAbove x With right-arrow Subscript k Baseline
    comma ModifyingAbove a With right-arrow Subscript k Baseline right-parenthesis
    plus upper V a l u e left-parenthesis ModifyingAbove f With right-arrow left-parenthesis
    ModifyingAbove x With right-arrow Subscript k Baseline comma ModifyingAbove a
    With right-arrow Subscript k Baseline right-parenthesis comma n minus 1 right-parenthesis
    right-parenthesis dollar-sign"><mrow><mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi>
    <mi>e</mi> <mrow><mo>(</mo> <msub><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mi>k</mi></msub> <mo>,</mo> <mi>n</mi> <mo>)</mo></mrow> <mo>=</mo> <msub><mo
    form="prefix" movablelimits="true">min</mo> <msub><mover accent="true"><mi>a</mi>
    <mo>→</mo></mover> <mi>k</mi></msub></msub> <mrow><mo>(</mo> <mi>C</mi> <mi>o</mi>
    <mi>s</mi> <mi>t</mi> <mrow><mo>(</mo> <msub><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mi>k</mi></msub> <mo>,</mo> <msub><mover accent="true"><mi>a</mi> <mo>→</mo></mover>
    <mi>k</mi></msub> <mo>)</mo></mrow> <mo>+</mo> <mi>V</mi> <mi>a</mi> <mi>l</mi>
    <mi>u</mi> <mi>e</mi> <mrow><mo>(</mo> <mover accent="true"><mi>f</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <msub><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mi>k</mi></msub>
    <mo>,</mo> <msub><mover accent="true"><mi>a</mi> <mo>→</mo></mover> <mi>k</mi></msub>
    <mo>)</mo></mrow> <mo>,</mo> <mi>n</mi> <mo>-</mo> <mn>1</mn> <mo>)</mo></mrow>
    <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: The sequence of optimizers <math alttext="ModifyingAbove a With right-arrow
    Subscript k"><msub><mover accent="true"><mi>a</mi> <mo>→</mo></mover> <mi>k</mi></msub></math>
    at each discrete time step *k* constitute the optimal policy (or strategy or control)
    for the whole time period, that guarantees the minimal total cost, exactly as
    in reinforcement learning.
  prefs: []
  type: TYPE_NORMAL
- en: '*Continuous time* Bellman’s equation, which *is* the Hamilton-Jacobi-Bellman
    PDE.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a *stochastic* optimal control setting, there is also a stochastic version
    of Bellman’s equation. This is widely applicable in investment banking, and in
    scheduling and routing problems. In the stochastic framework, we need to find
    an optimal control input (strategy or policy) that guides the underlying stochastic
    processes to some desired final state, with minimal cost. Consider for example
    the problem where we need to execute a financial order, with a minimal implementation
    cost and within a certain period of time. We can first model the short term dynamics
    of the underlying assets, then discretize both in time and state spaces. This
    allows us to execute a given amount of shares at each of the time steps, with
    the condition that we must execute all of the shares during the given time period.
    We search for the policy that tells us, among all possible actions that we can
    take at each point in time, what the optimal one is, that gets us to where we
    want to be.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 11](ch11.xhtml#ch11), we connected Bellman’s equation to reinforcement
    learning. This was done in the context of a Markov decision process with value
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign upper V a l u e left-parenthesis ModifyingAbove s
    With right-arrow right-parenthesis equals max Underscript states and actions Endscripts
    double-struck upper E left-parenthesis r e w a r d 0 plus gamma upper V a l u
    e left-parenthesis ModifyingAbove s With right-arrow prime right-parenthesis right-parenthesis
    dollar-sign"><mrow><mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mrow><mo>(</mo>
    <mover accent="true"><mi>s</mi> <mo>→</mo></mover> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mo form="prefix" movablelimits="true">max</mo> <mrow><mtext>states</mtext><mtext>and</mtext><mtext>actions</mtext></mrow></msub>
    <mi>𝔼</mi> <mrow><mo>(</mo> <mi>r</mi> <mi>e</mi> <mi>w</mi> <mi>a</mi> <mi>r</mi>
    <msub><mi>d</mi> <mn>0</mn></msub> <mo>+</mo> <mi>γ</mi> <mi>V</mi> <mi>a</mi>
    <mi>l</mi> <mi>u</mi> <mi>e</mi> <mrow><mo>(</mo> <msup><mover accent="true"><mi>s</mi>
    <mo>→</mo></mover> <mo>'</mo></msup> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'In a deterministic dynamic programming setting, the analogous equation is the
    Hamilton Jacobi Bellman PDE for the value function. Before writing its formula,
    this is the language that we need to pay attention to:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Minimizing a cost function: Is there a more common objective in this world?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choosing an optimal control or optimal policy: This is minimizer that we are
    looking for, it controls the dynamical system.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Value function: The total minimum cost over the considered period of time.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Bellman optimality principle: An amazingly helpful principle that allows us
    to simplify the optimization problem.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Backward in time solution: Start with the desired outcome and work our way
    backwards, optimally, to an initial state. It is intuitive to see why a backward
    in time solution is easier in this setting. Since we know the end goal, we immediately
    exclude all paths that don’t lead to it from the preceding time step, saving us
    the exploration of many useless paths. If on the other hand we solve forward in
    time, starting at the beginning of the time interval, then we do not have the
    advantage of *closeness* to the desired outcome, so we must waste our time and
    computational resources explore many more useless paths.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Big Picture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ultimate question is: What must we do now (what is the initial state <math
    alttext="ModifyingAbove x With right-arrow left-parenthesis t Subscript i n i
    t i a l Baseline right-parenthesis"><mrow><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></mrow></math> and the time dependent policy <math alttext="ModifyingAbove
    a With right-arrow left-parenthesis t right-parenthesis"><mrow><mover accent="true"><mi>a</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    ) in order to get us to where we want to be ( <math alttext="ModifyingAbove x
    With right-arrow left-parenthesis t Subscript f i n a l Baseline right-parenthesis"><mrow><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mi>t</mi>
    <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub> <mo>)</mo></mrow></mrow></math>
    ), in the most cost efficient way (attain the value function <math alttext="upper
    V a l u e left-parenthesis ModifyingAbove x With right-arrow left-parenthesis
    t Subscript i n i t i a l Baseline right-parenthesis comma t Subscript i n i t
    i a l Baseline comma t Subscript f i n a l Baseline right-parenthesis"><mrow><mi>V</mi>
    <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></math> which is the minimum value of the strategy implementation
    cost function)?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The involved quantities are:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="ModifyingAbove x With right-arrow left-parenthesis t right-parenthesis"><mrow><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    is a vector characterizing the state of the dynamic system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The strategy (or policy or control) <math alttext="ModifyingAbove a With right-arrow
    left-parenthesis t right-parenthesis"><mrow><mover accent="true"><mi>a</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math> : We need to design
    this so that it invokes a state <math alttext="ModifyingAbove x With right-arrow
    left-parenthesis t right-parenthesis"><mrow><mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math> that minimizes some
    cost function. That is, if we input this special <math alttext="ModifyingAbove
    a With right-arrow left-parenthesis t right-parenthesis"><mrow><mover accent="true"><mi>a</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    that we are looking for to the dynamic system, the output <math alttext="ModifyingAbove
    x With right-arrow left-parenthesis t right-parenthesis"><mrow><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    would minimize the cost function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The cost function <math alttext="upper C o s t left-parenthesis ModifyingAbove
    x With right-arrow left-parenthesis t right-parenthesis comma ModifyingAbove a
    With right-arrow left-parenthesis t right-parenthesis comma t Subscript i n i
    t i a l Baseline comma t Subscript f i n a l Baseline right-parenthesis"><mrow><mi>C</mi>
    <mi>o</mi> <mi>s</mi> <mi>t</mi> <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mover accent="true"><mi>a</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi>
    <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></math> incurred due to the implementation of the strategy (or
    policy or control): This is given by some terminal cost at <math alttext="t Subscript
    f i n a l"><msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub></math>
    and the sum of incremental costs (integral) as we transition from <math alttext="t
    Subscript i n i t i a l"><msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub></math>
    to <math alttext="t Subscript f i n a l"><msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub></math>
    . The incremental costs depend on the current state of the system and the current
    control.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The value function <math alttext="upper V a l u e left-parenthesis ModifyingAbove
    x With right-arrow left-parenthesis t Subscript i n i t i a l Baseline right-parenthesis
    comma t Subscript i n i t i a l Baseline comma t Subscript f i n a l Baseline
    right-parenthesis"><mrow><mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi>
    <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo>
    <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></math> is the minimal cost in a specific time period attained
    by enforcing the minimizing policy <math alttext="ModifyingAbove a With right-arrow
    Superscript asterisk Baseline left-parenthesis t right-parenthesis"><mrow><msup><mover
    accent="true"><mi>a</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></math> , which in turn specifies the state
    <math alttext="ModifyingAbove x With right-arrow Superscript asterisk Baseline
    left-parenthesis t right-parenthesis"><mrow><msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    using the information about dynamics of the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hamilton-Jacobi-Bellman PDE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These are the involved equations and formulas:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign StartLayout 1st Row 1st Column Blank 2nd Column StartFraction
    d ModifyingAbove x left-parenthesis t right-parenthesis With right-arrow Over
    d t EndFraction equals ModifyingAbove f With right-arrow left-parenthesis ModifyingAbove
    x With right-arrow left-parenthesis t right-parenthesis comma ModifyingAbove a
    With right-arrow left-parenthesis t right-parenthesis comma t right-parenthesis
    2nd Row 1st Column Blank 2nd Column upper C o s t left-parenthesis ModifyingAbove
    x With right-arrow left-parenthesis t right-parenthesis comma ModifyingAbove a
    With right-arrow left-parenthesis t right-parenthesis comma t Subscript i n i
    t i a l Baseline comma t Subscript f i n a l Baseline right-parenthesis equals
    upper C o s t Subscript f i n a l Baseline left-parenthesis ModifyingAbove x With
    right-arrow left-parenthesis t Subscript f i n a l Baseline right-parenthesis
    comma t Subscript f i n a l Baseline right-parenthesis plus integral Subscript
    t Subscript i n i t i a l Baseline Superscript t Subscript f i n a l Baseline
    Baseline upper C o s t Subscript i n c r e m e n t a l Baseline left-parenthesis
    ModifyingAbove x With right-arrow left-parenthesis s right-parenthesis comma ModifyingAbove
    a With right-arrow left-parenthesis s right-parenthesis right-parenthesis d s
    3rd Row 1st Column Blank 2nd Column upper V a l u e left-parenthesis ModifyingAbove
    x With right-arrow left-parenthesis t Subscript i n i t i a l Baseline right-parenthesis
    comma t Subscript i n i t i a l Baseline comma t Subscript f i n a l Baseline
    right-parenthesis equals min Underscript ModifyingAbove a With right-arrow left-parenthesis
    t right-parenthesis Endscripts upper C o s t left-parenthesis ModifyingAbove x
    With right-arrow left-parenthesis t right-parenthesis comma ModifyingAbove a With
    right-arrow left-parenthesis t right-parenthesis comma t Subscript i n i t i a
    l Baseline comma t Subscript f i n a l Baseline right-parenthesis EndLayout dollar-sign"><mtable
    displaystyle="true"><mtr><mtd columnalign="left"><mrow><mfrac><mrow><mi>d</mi><mover
    accent="true"><mrow><mi>x</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow> <mo>→</mo></mover></mrow>
    <mrow><mi>d</mi><mi>t</mi></mrow></mfrac> <mo>=</mo> <mover accent="true"><mi>f</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mover accent="true"><mi>a</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>t</mi>
    <mo>)</mo></mrow></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mrow><mi>C</mi>
    <mi>o</mi> <mi>s</mi> <mi>t</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mover
    accent="true"><mi>a</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>=</mo> <mi>C</mi> <mi>o</mi> <mi>s</mi> <msub><mi>t</mi>
    <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub> <mrow><mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mi>t</mi>
    <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub> <mo>)</mo></mrow>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>+</mo> <msubsup><mo>∫</mo> <mrow><msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub></mrow>
    <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub></msubsup>
    <mi>C</mi> <mi>o</mi> <mi>s</mi> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>c</mi><mi>r</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo>
    <mi>s</mi> <mo>)</mo></mrow> <mo>,</mo> <mover accent="true"><mi>a</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>s</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mi>d</mi> <mi>s</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi>
    <mi>e</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>=</mo> <munder><mo form="prefix" movablelimits="true">min</mo>
    <mrow><mover accent="true"><mi>a</mi> <mo>→</mo></mover><mrow><mo>(</mo><mi>t</mi><mo>)</mo></mrow></mrow></munder>
    <mi>C</mi> <mi>o</mi> <mi>s</mi> <mi>t</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mover
    accent="true"><mi>a</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Bellman’s optimality principle tells us something very valuable about the behavior
    of the value function (the optimal cost) along the special trajectory <math alttext="ModifyingAbove
    x With right-arrow Superscript asterisk Baseline left-parenthesis t right-parenthesis"><mrow><msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></math> corresponding to the optimizing policy
    <math alttext="ModifyingAbove a With right-arrow Superscript asterisk Baseline
    left-parenthesis t right-parenthesis"><mrow><msup><mover accent="true"><mi>a</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    : The value at a specified time interval is the sum of values if we break the
    time interval apart along the special trajectory <math alttext="ModifyingAbove
    x With right-arrow Superscript asterisk Baseline left-parenthesis t right-parenthesis"><mrow><msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></math> corresponding to the optimizing policy
    <math alttext="ModifyingAbove a With right-arrow Superscript asterisk Baseline
    left-parenthesis t right-parenthesis"><mrow><msup><mover accent="true"><mi>a</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    . This enables us to break up the optimization problem over a longer time interval
    into a recursion of optimization problems over much shorter time intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign upper V a l u e left-parenthesis ModifyingAbove x
    With right-arrow Superscript asterisk Baseline left-parenthesis t Subscript i
    n i t i a l Baseline right-parenthesis comma t Subscript i n i t i a l Baseline
    comma t Subscript f i n a l Baseline right-parenthesis equals upper V a l u e
    left-parenthesis ModifyingAbove x With right-arrow Superscript asterisk Baseline
    left-parenthesis t Subscript i n i t i a l Baseline right-parenthesis comma t
    Subscript i n i t i a l Baseline comma t Subscript i n t e r m e d i a t e Baseline
    right-parenthesis plus upper V a l u e left-parenthesis ModifyingAbove x With
    right-arrow Superscript asterisk Baseline left-parenthesis t Subscript i n t e
    r m e d i a t e Baseline right-parenthesis comma t Subscript i n t e r m e d i
    a t e Baseline comma t Subscript f i n a l Baseline right-parenthesis dollar-sign"><mrow><mi>V</mi>
    <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mrow><mo>(</mo> <msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>=</mo> <mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi>
    <mrow><mo>(</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup>
    <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>+</mo> <mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi>
    <mrow><mo>(</mo> <msup><mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup>
    <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow></msub>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Bellman’s principle, we can derive the Hamilton-Jacobi-Bellman PDE that
    the value function satisfies. This PDE generalized an older Hamilton-Jacobi PDE
    for optimal control. The solution of this PDE contains very valuable information:
    Suppose we encounter the system at *any time t*, not only at its initial state
    <math alttext="t Subscript i n i t i a l"><msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub></math>
    , then we can compute the value function up to the desired final cost, by solving
    the Hamilton-Jacobi-Bellman equation:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign minus StartFraction normal partial-differential upper
    V a l u e Over normal partial-differential t EndFraction equals min Underscript
    ModifyingAbove a With right-arrow left-parenthesis t right-parenthesis Endscripts
    left-parenthesis left-parenthesis StartFraction normal partial-differential upper
    V a l u e Over normal partial-differential ModifyingAbove x With right-arrow EndFraction
    right-parenthesis Superscript upper T Baseline ModifyingAbove f With right-arrow
    left-parenthesis ModifyingAbove x With right-arrow left-parenthesis t right-parenthesis
    comma ModifyingAbove a With right-arrow left-parenthesis t right-parenthesis right-parenthesis
    plus upper C o s t Subscript i n c r e m e n t a l Baseline left-parenthesis ModifyingAbove
    x With right-arrow left-parenthesis t right-parenthesis comma ModifyingAbove a
    With right-arrow left-parenthesis t right-parenthesis right-parenthesis right-parenthesis
    dollar-sign"><mrow><mo>-</mo> <mfrac><mrow><mi>∂</mi><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow>
    <mrow><mi>∂</mi><mi>t</mi></mrow></mfrac> <mo>=</mo> <msub><mo form="prefix" movablelimits="true">min</mo>
    <mrow><mover accent="true"><mi>a</mi> <mo>→</mo></mover><mrow><mo>(</mo><mi>t</mi><mo>)</mo></mrow></mrow></msub>
    <mrow><mo>(</mo> <msup><mrow><mo>(</mo><mfrac><mrow><mi>∂</mi><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow>
    <mrow><mi>∂</mi><mover accent="true"><mi>x</mi> <mo>→</mo></mover></mrow></mfrac><mo>)</mo></mrow>
    <mi>T</mi></msup> <mover accent="true"><mi>f</mi> <mo>→</mo></mover> <mrow><mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi>
    <mo>)</mo></mrow> <mo>,</mo> <mover accent="true"><mi>a</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>+</mo> <mi>C</mi>
    <mi>o</mi> <mi>s</mi> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>c</mi><mi>r</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mover accent="true"><mi>a</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'subject to final time condition:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="dollar-sign upper V a l u e left-parenthesis ModifyingAbove x
    With right-arrow left-parenthesis t Subscript f i n a l Baseline right-parenthesis
    comma t Subscript f i n a l Baseline right-parenthesis equals upper C o s t Subscript
    f i n a l Baseline left-parenthesis ModifyingAbove x With right-arrow left-parenthesis
    t Subscript f i n a l Baseline right-parenthesis comma t Subscript f i n a l Baseline
    right-parenthesis dollar-sign"><mrow><mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi>
    <mi>e</mi> <mrow><mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>=</mo> <mi>C</mi> <mi>o</mi> <mi>s</mi> <msub><mi>t</mi>
    <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub> <mrow><mo>(</mo>
    <mover accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <msub><mi>t</mi>
    <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub> <mo>)</mo></mrow>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: This is a first order PDE for the value function <math alttext="upper V a l
    u e left-parenthesis ModifyingAbove x With right-arrow left-parenthesis t right-parenthesis
    comma t comma t Subscript f i n a l Baseline right-parenthesis"><mrow><mi>V</mi>
    <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mo>(</mo> <mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>,</mo> <mi>t</mi>
    <mo>,</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></math> . Again, this is the optimal cost incurred from starting
    in state <math alttext="ModifyingAbove x With right-arrow left-parenthesis t right-parenthesis"><mrow><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    at time *t* and controlling the system optimally from then until time <math alttext="t
    Subscript f i n a l"><msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub></math>
    . We know the final value function at <math alttext="t Subscript f i n a l"><msub><mi>t</mi>
    <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub></math>
    , and we are looking for value function at time *t*, namely, <math alttext="upper
    V a l u e left-parenthesis ModifyingAbove x With right-arrow left-parenthesis
    t right-parenthesis right-parenthesis"><mrow><mi>V</mi> <mi>a</mi> <mi>l</mi>
    <mi>u</mi> <mi>e</mi> <mo>(</mo> <mover accent="true"><mi>x</mi> <mo>→</mo></mover>
    <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow> <mo>)</mo></mrow></math> . So we
    solve the PDE *backwards in time*, starting at <math alttext="t Subscript f i
    n a l"><msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub></math>
    and ending at <math alttext="t Subscript i n i t i a l"><msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub></math>
    .
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Hamilton-Jacobi-Bellman PDE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we are able solve the Hamilton Jacobi Bellman PDE for the value function,
    then we know the optimal control <math alttext="ModifyingAbove a With right-arrow
    Superscript asterisk Baseline left-parenthesis t right-parenthesis"><mrow><msup><mover
    accent="true"><mi>a</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></math> , which in turn produces the least
    costly (or most rewarding) trajectory <math alttext="ModifyingAbove x With right-arrow
    Superscript asterisk Baseline left-parenthesis t right-parenthesis"><mrow><msup><mover
    accent="true"><mi>x</mi> <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo>
    <mi>t</mi> <mo>)</mo></mrow></mrow></math> from our current state <math alttext="ModifyingAbove
    x With right-arrow Superscript asterisk Baseline left-parenthesis t Subscript
    i n i t i a l Baseline right-parenthesis"><mrow><msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></mrow></math> to the final desired state <math alttext="ModifyingAbove
    x With right-arrow Superscript asterisk Baseline left-parenthesis t Subscript
    f i n a l Baseline right-parenthesis"><mrow><msup><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mo>*</mo></msup> <mrow><mo>(</mo> <msub><mi>t</mi> <mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub>
    <mo>)</mo></mrow></mrow></math> .
  prefs: []
  type: TYPE_NORMAL
- en: The Hamilton-Jacobi-Bellman PDE does not in general have a smooth solution,
    so we must satisfy ourselves with *weak* or *generalized* solutions. This is a
    common theme for many PDEs, and a person studying PDE theory focuses almost exclusively
    on developing generalized solutions and understanding the function spaces that
    they live in (Sobolov spaces *et al*). Classic examples of generalized solutions
    for the Hamilton Jacobi Bellman PDE, which we only mention without elaboration,
    include viscosity solutions and minimax solutions.
  prefs: []
  type: TYPE_NORMAL
- en: What AI contributes to the vast literature on the Hamilton-Jacobi-Bellman equation
    is numerically solving it in very high dimensions, as in hundreds or thousands.
    The value function is a function of the state vector <math alttext="ModifyingAbove
    x With right-arrow left-parenthesis t right-parenthesis"><mrow><mover accent="true"><mi>x</mi>
    <mo>→</mo></mover> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></mrow></math>
    of the underlying assets or contributing agents, and if there are many of these,
    then the PDE is very high dimensional. The paper we referenced earlier, [*Solving
    High Dimensional PDEs Using Deep Learning*](https://www.pnas.org/doi/epdf/10.1073/pnas.1718942115),
    addresses numerical solutions of the Hamilton-Jacobi-Bellman equation, in addition
    to other important and widely impactful high dimensional PDEs.
  prefs: []
  type: TYPE_NORMAL
- en: The term *Hopf formulas* is usually associated with solutions of Hamilton-Jacobi
    PDEs. For a class of inviscid Hamilton–Jacobi type PDEs, Darbon and Osher [Algorithms
    for Overcoming the Curse of Dimensionality for Certain Hamilton-Jacobi Equations
    Arising in Control Theory and Elsewhere (2016)](https://arxiv.org/abs/1605.01799)
    developed an effective algorithm for high dimensional Hamilton-Jacobi PDEs, based
    on the Hopf formulas.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic programming and Reinforcement Learning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using neural networks to learn optimal strategies for dynamic programming is
    called reinforcement learning in some circles and *neuro-dynamic programming*
    in others. The neural network, and the machine endowed with it, learns to anticipate
    how current and future actions affect a long-term cumulative cost or reward, the
    value of that time period. How do our current and daily investment strategies
    affect our annual performance? How do our first and subsequent chess moves affect
    the overall outcome of the game? The value function is the total of costs and
    rewards corresponding to following the optimal strategies at each (discrete or
    continuum) step of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The neural network needs inputs and outputs during training with historical
    data. The inputs are the state and all the potential actions that are allowed
    at that state, and the output is the value (the total costs and rewards). After
    training, for example, for a business model that is strategizing on how to address
    each customer, the neural network learns to take the customer’s state as input,
    and outputs the next sequence of actions so as to maximize long term value. Check
    [Neurodynamic programming (1996)](http://athenasc.com/ndpbook.xhtml) D. P. Bertsekas
    and J. N. Tsitsiklis for an older but thorough explanation of neuro-dynamic programming
    and the use of artificial neural networks for approximating the value function
    in Bellman’s equation. This is great for reducing the effects of the curse dimensionality:
    Instead of storing and evaluating the whole high dimensional functions, we only
    need to store the parameters of the neural network.'
  prefs: []
  type: TYPE_NORMAL
- en: PDEs For AI?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous section highlighted the fact that dynamic programming and the Bellman
    equation are highly intertwined with AI’s reinforcement learning.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the field of PDEs has an arsenal of analysis behind it, studying all
    kinds of functions, the spaces they live in, weak and strong solutions, and all
    kinds of convergence in all kinds of senses. If any field has the tools to unlock
    the secrets behind the success of neural networks in approximating many data generating
    processes, whether joint probability distributions or deterministic function,
    it would be the field of PDEs. We need to back neural networks with theorems and
    the mathematical rigor that eventually help with their design and architecture
    optimization. Neural network’s magical abilities need to be under the lens of
    analysis, and tools from the analysis of PDEs and their solutions are one promising
    way forward. Examples include Sobolev training (Czarnecki, Osindero, Jaderberg,
    Swirszcz, Pascanu; 2017) (add examples)
  prefs: []
  type: TYPE_NORMAL
- en: Other Considerations In Partial Differential Equations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For most of the time we stayed away from the famous partial differential equations
    while highlighting the themes of this chapter, so as to stress the fact these
    themes apply to much more than the well studied differential equations and applications.
    Undergraduate courses primarily address linear PDEs involving only functions of
    two variables (x,y) or (x,t). Students are left either misled, thinking that is
    all what matters, or wondering: What about nonlinear PDEs? And all the high dimensional
    applications? Systems of PDEs? These courses also tend to focus on the heat equation
    (parabolic), wave equation (hyperbolic), Laplace equation (elliptic), and some
    numerical solutions and simulations (finite differences, finite elements, and
    Monte Carlo). These are presented in their simplest forms: Linear, one, two, or
    three dimensional, defined on domains with regular geometries, giving undergraduate
    students the false impression that these PDEs are the base for all equations that
    might appear in applications. They also provide an artificial division between
    *types* of equations: Elliptical, parabolic, and hyperbolic, as if there is a
    complete theory that encompasses each type. Analytical solution methods are narrow,
    focusing only on the principle of superposition of simple solutions (because of
    linearity), which leads to Fourier series and transforms (this is in fact a very
    good thing). Neural networks broaden the scope, in the sense of approximating
    solutions of nonlinear equations using compositions of simple functions as opposed
    to additions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The way undergraduate PDE courses are set up are all wonderful, but they do
    not truly reflect the reality of PDEs: Not theoretically, not numerically, not
    even their wide applicability. Students graduate feeling that given a brand new
    PDE, they have no idea what to do with it, because it doesn’t fit anything that
    they learned in an introductory PDE class (I can tell you what to first do with
    it, of course after googling it: Discretize it and simulate it; this will give
    you tremendous insight into the behavior of its solution).'
  prefs: []
  type: TYPE_NORMAL
- en: That said, there are general ways of thinking about putting the PDEs together
    (modeling), which is almost always related to some conservation laws from physics,
    and going about their analysis (theory- existence, uniqueness, and sensitivity
    analysis of solutions and *weak solutions*), and finding the actual solutions
    analytically or numerically (representation formulas, green’s functions, transform
    methods, and numerics).
  prefs: []
  type: TYPE_NORMAL
- en: 'For starters, each area of study has its own differential equations that model
    the phenomena that it cares for, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: In fluid dynamics, we study Navier Stokes equations (among others). This is
    a nonlinear system of PDEs. Navier Stokes PDEs take into account the velocity
    of the fluid, pressure, density, stresses, compressibility, and the forces acting
    on it. The equation expresses the conservation of mass and conservation of momentum
    The solution of the equation describes the motion of the viscous fluid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In economics and finance, we study the Black Scholes equation (among others).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In population dynamics, we study the Lotka Volterra predator prey equations
    (among others).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general relativity, we study the Einestein field equations (among others).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When PDEs model phenomena that evolve with time, there could be higher driver
    of the evolution, which provide more insight into the PDE solution and its properties:
    A tendency to decrease an energy. Mathematically, the *derivative* of an energy
    functional is negative when evaluated at the solution of the PDE. We learn a lot
    of math understanding these energy functionals, their *derivatives*, and the function
    spaces they act on. We use a lot of relatively easy *energy estimates* to prove
    existence of solutions to various nonlinear PDE. The correct setting to study
    PDEs via energy methods is *Sobolov function spaces*. The calculus of variations
    is concerned with the maxima or minima (collectively called extrema) of energy
    functionals. It is fundamental for the theory of nonlinear PDEs. PDEs that appear
    as minimizers of energy functionals are called *Euler Lagrange equation*.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary And Looking Ahead
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced us to PDEs as they relate to AI. PDEs have an unparalleled
    ability to model natural and social phenomena. Unlocking their solutions opens
    up many possibilities for many fields. We highlighted many of the difficulties
    obtaining these solutions, such as the curse of dimensionality, mesh generation,
    noisy data, and how AI helps address those.
  prefs: []
  type: TYPE_NORMAL
- en: There is much more work to be done. For developing physics informed intelligent
    machines, we need to build new frameworks, data sets, standardized benchmarks,
    and new rigorous mathematics for scalable and robust systems.
  prefs: []
  type: TYPE_NORMAL
- en: There are many important PDE topics that we did not touch on, such as ill-posed
    inverse problems, where we need to learn the PDE’s parameters or initial data
    from partially or fully observing its solution. Physics informed neural networks
    are effective and efficient for these kinds of problems.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of the Hamilton Jacobi Bellman equation, we mentioned viscosity
    solutions and Hopf Lax formulas only casually. In the context of existence methods
    for PDEs, other than the fixed point iteration, there are minimax methods for
    certain PDE types. For example, we did not mention monotinicity or the maximum
    principle for elliptic and parabolic PDEs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We leave this chapter with a question to ponder: *Will PDEs advance us towards
    more intelligent agents?* and with [the 2021 article](https://www.brown.edu/research/projects/crunch/sites/brown.edu.research.projects.crunch/files/uploads/Nature-REviews_GK.pdf),
    where the authors make the case for *Physics Informed Machine Learning (2021)*,
    where we merge neural networks with physical laws, in order to leverage the best
    of both worlds, and minitgate the lack of large data sets, or noisy data, in many
    scientific settings. The following is a quote from the article: *Such networks
    can be trained from additional information obtained by enforcing the physical
    laws (for example, at random points in the continuous space-time domain). Such
    physics-informed learning integrates (noisy) data and mathematical models, and
    implements them through neural networks or other kernel based regression networks.
    Moreover, it may be possible to design specialized network architectures that
    automatically satisfy some of the physical invariants for better accuracy, faster
    training and improved generalization.*'
  prefs: []
  type: TYPE_NORMAL
